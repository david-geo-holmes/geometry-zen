(function () {
  var async = {};
  var root, previous_async;
  root = this;
  if (root != null) {
    previous_async = root.async;
  }
  async.noConflict = function () {
    root.async = previous_async;
    return async;
  };
  function only_once(fn) {
    var called = false;
    return function () {
      if (called)
        throw new Error('Callback was already called.');
      called = true;
      fn.apply(root, arguments);
    };
  }
  var _each = function (arr, iterator) {
    if (arr.forEach) {
      return arr.forEach(iterator);
    }
    for (var i = 0; i < arr.length; i += 1) {
      iterator(arr[i], i, arr);
    }
  };
  var _map = function (arr, iterator) {
    if (arr.map) {
      return arr.map(iterator);
    }
    var results = [];
    _each(arr, function (x, i, a) {
      results.push(iterator(x, i, a));
    });
    return results;
  };
  var _reduce = function (arr, iterator, memo) {
    if (arr.reduce) {
      return arr.reduce(iterator, memo);
    }
    _each(arr, function (x, i, a) {
      memo = iterator(memo, x, i, a);
    });
    return memo;
  };
  var _keys = function (obj) {
    if (Object.keys) {
      return Object.keys(obj);
    }
    var keys = [];
    for (var k in obj) {
      if (obj.hasOwnProperty(k)) {
        keys.push(k);
      }
    }
    return keys;
  };
  if (typeof process === 'undefined' || !process.nextTick) {
    if (typeof setImmediate === 'function') {
      async.nextTick = function (fn) {
        setImmediate(fn);
      };
      async.setImmediate = async.nextTick;
    } else {
      async.nextTick = function (fn) {
        setTimeout(fn, 0);
      };
      async.setImmediate = async.nextTick;
    }
  } else {
    async.nextTick = process.nextTick;
    if (typeof setImmediate !== 'undefined') {
      async.setImmediate = function (fn) {
        setImmediate(fn);
      };
    } else {
      async.setImmediate = async.nextTick;
    }
  }
  async.each = function (arr, iterator, callback) {
    callback = callback || function () {
    };
    if (!arr.length) {
      return callback();
    }
    var completed = 0;
    _each(arr, function (x) {
      iterator(x, only_once(function (err) {
        if (err) {
          callback(err);
          callback = function () {
          };
        } else {
          completed += 1;
          if (completed >= arr.length) {
            callback(null);
          }
        }
      }));
    });
  };
  async.forEach = async.each;
  async.eachSeries = function (arr, iterator, callback) {
    callback = callback || function () {
    };
    if (!arr.length) {
      return callback();
    }
    var completed = 0;
    var iterate = function () {
      iterator(arr[completed], function (err) {
        if (err) {
          callback(err);
          callback = function () {
          };
        } else {
          completed += 1;
          if (completed >= arr.length) {
            callback(null);
          } else {
            iterate();
          }
        }
      });
    };
    iterate();
  };
  async.forEachSeries = async.eachSeries;
  async.eachLimit = function (arr, limit, iterator, callback) {
    var fn = _eachLimit(limit);
    fn.apply(null, [
      arr,
      iterator,
      callback
    ]);
  };
  async.forEachLimit = async.eachLimit;
  var _eachLimit = function (limit) {
    return function (arr, iterator, callback) {
      callback = callback || function () {
      };
      if (!arr.length || limit <= 0) {
        return callback();
      }
      var completed = 0;
      var started = 0;
      var running = 0;
      (function replenish() {
        if (completed >= arr.length) {
          return callback();
        }
        while (running < limit && started < arr.length) {
          started += 1;
          running += 1;
          iterator(arr[started - 1], function (err) {
            if (err) {
              callback(err);
              callback = function () {
              };
            } else {
              completed += 1;
              running -= 1;
              if (completed >= arr.length) {
                callback();
              } else {
                replenish();
              }
            }
          });
        }
      }());
    };
  };
  var doParallel = function (fn) {
    return function () {
      var args = Array.prototype.slice.call(arguments);
      return fn.apply(null, [async.each].concat(args));
    };
  };
  var doParallelLimit = function (limit, fn) {
    return function () {
      var args = Array.prototype.slice.call(arguments);
      return fn.apply(null, [_eachLimit(limit)].concat(args));
    };
  };
  var doSeries = function (fn) {
    return function () {
      var args = Array.prototype.slice.call(arguments);
      return fn.apply(null, [async.eachSeries].concat(args));
    };
  };
  var _asyncMap = function (eachfn, arr, iterator, callback) {
    var results = [];
    arr = _map(arr, function (x, i) {
      return {
        index: i,
        value: x
      };
    });
    eachfn(arr, function (x, callback) {
      iterator(x.value, function (err, v) {
        results[x.index] = v;
        callback(err);
      });
    }, function (err) {
      callback(err, results);
    });
  };
  async.map = doParallel(_asyncMap);
  async.mapSeries = doSeries(_asyncMap);
  async.mapLimit = function (arr, limit, iterator, callback) {
    return _mapLimit(limit)(arr, iterator, callback);
  };
  var _mapLimit = function (limit) {
    return doParallelLimit(limit, _asyncMap);
  };
  async.reduce = function (arr, memo, iterator, callback) {
    async.eachSeries(arr, function (x, callback) {
      iterator(memo, x, function (err, v) {
        memo = v;
        callback(err);
      });
    }, function (err) {
      callback(err, memo);
    });
  };
  async.inject = async.reduce;
  async.foldl = async.reduce;
  async.reduceRight = function (arr, memo, iterator, callback) {
    var reversed = _map(arr, function (x) {
        return x;
      }).reverse();
    async.reduce(reversed, memo, iterator, callback);
  };
  async.foldr = async.reduceRight;
  var _filter = function (eachfn, arr, iterator, callback) {
    var results = [];
    arr = _map(arr, function (x, i) {
      return {
        index: i,
        value: x
      };
    });
    eachfn(arr, function (x, callback) {
      iterator(x.value, function (v) {
        if (v) {
          results.push(x);
        }
        callback();
      });
    }, function (err) {
      callback(_map(results.sort(function (a, b) {
        return a.index - b.index;
      }), function (x) {
        return x.value;
      }));
    });
  };
  async.filter = doParallel(_filter);
  async.filterSeries = doSeries(_filter);
  async.select = async.filter;
  async.selectSeries = async.filterSeries;
  var _reject = function (eachfn, arr, iterator, callback) {
    var results = [];
    arr = _map(arr, function (x, i) {
      return {
        index: i,
        value: x
      };
    });
    eachfn(arr, function (x, callback) {
      iterator(x.value, function (v) {
        if (!v) {
          results.push(x);
        }
        callback();
      });
    }, function (err) {
      callback(_map(results.sort(function (a, b) {
        return a.index - b.index;
      }), function (x) {
        return x.value;
      }));
    });
  };
  async.reject = doParallel(_reject);
  async.rejectSeries = doSeries(_reject);
  var _detect = function (eachfn, arr, iterator, main_callback) {
    eachfn(arr, function (x, callback) {
      iterator(x, function (result) {
        if (result) {
          main_callback(x);
          main_callback = function () {
          };
        } else {
          callback();
        }
      });
    }, function (err) {
      main_callback();
    });
  };
  async.detect = doParallel(_detect);
  async.detectSeries = doSeries(_detect);
  async.some = function (arr, iterator, main_callback) {
    async.each(arr, function (x, callback) {
      iterator(x, function (v) {
        if (v) {
          main_callback(true);
          main_callback = function () {
          };
        }
        callback();
      });
    }, function (err) {
      main_callback(false);
    });
  };
  async.any = async.some;
  async.every = function (arr, iterator, main_callback) {
    async.each(arr, function (x, callback) {
      iterator(x, function (v) {
        if (!v) {
          main_callback(false);
          main_callback = function () {
          };
        }
        callback();
      });
    }, function (err) {
      main_callback(true);
    });
  };
  async.all = async.every;
  async.sortBy = function (arr, iterator, callback) {
    async.map(arr, function (x, callback) {
      iterator(x, function (err, criteria) {
        if (err) {
          callback(err);
        } else {
          callback(null, {
            value: x,
            criteria: criteria
          });
        }
      });
    }, function (err, results) {
      if (err) {
        return callback(err);
      } else {
        var fn = function (left, right) {
          var a = left.criteria, b = right.criteria;
          return a < b ? -1 : a > b ? 1 : 0;
        };
        callback(null, _map(results.sort(fn), function (x) {
          return x.value;
        }));
      }
    });
  };
  async.auto = function (tasks, callback) {
    callback = callback || function () {
    };
    var keys = _keys(tasks);
    if (!keys.length) {
      return callback(null);
    }
    var results = {};
    var listeners = [];
    var addListener = function (fn) {
      listeners.unshift(fn);
    };
    var removeListener = function (fn) {
      for (var i = 0; i < listeners.length; i += 1) {
        if (listeners[i] === fn) {
          listeners.splice(i, 1);
          return;
        }
      }
    };
    var taskComplete = function () {
      _each(listeners.slice(0), function (fn) {
        fn();
      });
    };
    addListener(function () {
      if (_keys(results).length === keys.length) {
        callback(null, results);
        callback = function () {
        };
      }
    });
    _each(keys, function (k) {
      var task = tasks[k] instanceof Function ? [tasks[k]] : tasks[k];
      var taskCallback = function (err) {
        var args = Array.prototype.slice.call(arguments, 1);
        if (args.length <= 1) {
          args = args[0];
        }
        if (err) {
          var safeResults = {};
          _each(_keys(results), function (rkey) {
            safeResults[rkey] = results[rkey];
          });
          safeResults[k] = args;
          callback(err, safeResults);
          callback = function () {
          };
        } else {
          results[k] = args;
          async.setImmediate(taskComplete);
        }
      };
      var requires = task.slice(0, Math.abs(task.length - 1)) || [];
      var ready = function () {
        return _reduce(requires, function (a, x) {
          return a && results.hasOwnProperty(x);
        }, true) && !results.hasOwnProperty(k);
      };
      if (ready()) {
        task[task.length - 1](taskCallback, results);
      } else {
        var listener = function () {
          if (ready()) {
            removeListener(listener);
            task[task.length - 1](taskCallback, results);
          }
        };
        addListener(listener);
      }
    });
  };
  async.waterfall = function (tasks, callback) {
    callback = callback || function () {
    };
    if (tasks.constructor !== Array) {
      var err = new Error('First argument to waterfall must be an array of functions');
      return callback(err);
    }
    if (!tasks.length) {
      return callback();
    }
    var wrapIterator = function (iterator) {
      return function (err) {
        if (err) {
          callback.apply(null, arguments);
          callback = function () {
          };
        } else {
          var args = Array.prototype.slice.call(arguments, 1);
          var next = iterator.next();
          if (next) {
            args.push(wrapIterator(next));
          } else {
            args.push(callback);
          }
          async.setImmediate(function () {
            iterator.apply(null, args);
          });
        }
      };
    };
    wrapIterator(async.iterator(tasks))();
  };
  var _parallel = function (eachfn, tasks, callback) {
    callback = callback || function () {
    };
    if (tasks.constructor === Array) {
      eachfn.map(tasks, function (fn, callback) {
        if (fn) {
          fn(function (err) {
            var args = Array.prototype.slice.call(arguments, 1);
            if (args.length <= 1) {
              args = args[0];
            }
            callback.call(null, err, args);
          });
        }
      }, callback);
    } else {
      var results = {};
      eachfn.each(_keys(tasks), function (k, callback) {
        tasks[k](function (err) {
          var args = Array.prototype.slice.call(arguments, 1);
          if (args.length <= 1) {
            args = args[0];
          }
          results[k] = args;
          callback(err);
        });
      }, function (err) {
        callback(err, results);
      });
    }
  };
  async.parallel = function (tasks, callback) {
    _parallel({
      map: async.map,
      each: async.each
    }, tasks, callback);
  };
  async.parallelLimit = function (tasks, limit, callback) {
    _parallel({
      map: _mapLimit(limit),
      each: _eachLimit(limit)
    }, tasks, callback);
  };
  async.series = function (tasks, callback) {
    callback = callback || function () {
    };
    if (tasks.constructor === Array) {
      async.mapSeries(tasks, function (fn, callback) {
        if (fn) {
          fn(function (err) {
            var args = Array.prototype.slice.call(arguments, 1);
            if (args.length <= 1) {
              args = args[0];
            }
            callback.call(null, err, args);
          });
        }
      }, callback);
    } else {
      var results = {};
      async.eachSeries(_keys(tasks), function (k, callback) {
        tasks[k](function (err) {
          var args = Array.prototype.slice.call(arguments, 1);
          if (args.length <= 1) {
            args = args[0];
          }
          results[k] = args;
          callback(err);
        });
      }, function (err) {
        callback(err, results);
      });
    }
  };
  async.iterator = function (tasks) {
    var makeCallback = function (index) {
      var fn = function () {
        if (tasks.length) {
          tasks[index].apply(null, arguments);
        }
        return fn.next();
      };
      fn.next = function () {
        return index < tasks.length - 1 ? makeCallback(index + 1) : null;
      };
      return fn;
    };
    return makeCallback(0);
  };
  async.apply = function (fn) {
    var args = Array.prototype.slice.call(arguments, 1);
    return function () {
      return fn.apply(null, args.concat(Array.prototype.slice.call(arguments)));
    };
  };
  var _concat = function (eachfn, arr, fn, callback) {
    var r = [];
    eachfn(arr, function (x, cb) {
      fn(x, function (err, y) {
        r = r.concat(y || []);
        cb(err);
      });
    }, function (err) {
      callback(err, r);
    });
  };
  async.concat = doParallel(_concat);
  async.concatSeries = doSeries(_concat);
  async.whilst = function (test, iterator, callback) {
    if (test()) {
      iterator(function (err) {
        if (err) {
          return callback(err);
        }
        async.whilst(test, iterator, callback);
      });
    } else {
      callback();
    }
  };
  async.doWhilst = function (iterator, test, callback) {
    iterator(function (err) {
      if (err) {
        return callback(err);
      }
      if (test()) {
        async.doWhilst(iterator, test, callback);
      } else {
        callback();
      }
    });
  };
  async.until = function (test, iterator, callback) {
    if (!test()) {
      iterator(function (err) {
        if (err) {
          return callback(err);
        }
        async.until(test, iterator, callback);
      });
    } else {
      callback();
    }
  };
  async.doUntil = function (iterator, test, callback) {
    iterator(function (err) {
      if (err) {
        return callback(err);
      }
      if (!test()) {
        async.doUntil(iterator, test, callback);
      } else {
        callback();
      }
    });
  };
  async.queue = function (worker, concurrency) {
    if (concurrency === undefined) {
      concurrency = 1;
    }
    function _insert(q, data, pos, callback) {
      if (data.constructor !== Array) {
        data = [data];
      }
      _each(data, function (task) {
        var item = {
            data: task,
            callback: typeof callback === 'function' ? callback : null
          };
        if (pos) {
          q.tasks.unshift(item);
        } else {
          q.tasks.push(item);
        }
        if (q.saturated && q.tasks.length === concurrency) {
          q.saturated();
        }
        async.setImmediate(q.process);
      });
    }
    var workers = 0;
    var q = {
        tasks: [],
        concurrency: concurrency,
        saturated: null,
        empty: null,
        drain: null,
        push: function (data, callback) {
          _insert(q, data, false, callback);
        },
        unshift: function (data, callback) {
          _insert(q, data, true, callback);
        },
        process: function () {
          if (workers < q.concurrency && q.tasks.length) {
            var task = q.tasks.shift();
            if (q.empty && q.tasks.length === 0) {
              q.empty();
            }
            workers += 1;
            var next = function () {
              workers -= 1;
              if (task.callback) {
                task.callback.apply(task, arguments);
              }
              if (q.drain && q.tasks.length + workers === 0) {
                q.drain();
              }
              q.process();
            };
            var cb = only_once(next);
            worker(task.data, cb);
          }
        },
        length: function () {
          return q.tasks.length;
        },
        running: function () {
          return workers;
        }
      };
    return q;
  };
  async.cargo = function (worker, payload) {
    var working = false, tasks = [];
    var cargo = {
        tasks: tasks,
        payload: payload,
        saturated: null,
        empty: null,
        drain: null,
        push: function (data, callback) {
          if (data.constructor !== Array) {
            data = [data];
          }
          _each(data, function (task) {
            tasks.push({
              data: task,
              callback: typeof callback === 'function' ? callback : null
            });
            if (cargo.saturated && tasks.length === payload) {
              cargo.saturated();
            }
          });
          async.setImmediate(cargo.process);
        },
        process: function process() {
          if (working)
            return;
          if (tasks.length === 0) {
            if (cargo.drain)
              cargo.drain();
            return;
          }
          var ts = typeof payload === 'number' ? tasks.splice(0, payload) : tasks.splice(0);
          var ds = _map(ts, function (task) {
              return task.data;
            });
          if (cargo.empty)
            cargo.empty();
          working = true;
          worker(ds, function () {
            working = false;
            var args = arguments;
            _each(ts, function (data) {
              if (data.callback) {
                data.callback.apply(null, args);
              }
            });
            process();
          });
        },
        length: function () {
          return tasks.length;
        },
        running: function () {
          return working;
        }
      };
    return cargo;
  };
  var _console_fn = function (name) {
    return function (fn) {
      var args = Array.prototype.slice.call(arguments, 1);
      fn.apply(null, args.concat([function (err) {
          var args = Array.prototype.slice.call(arguments, 1);
          if (typeof console !== 'undefined') {
            if (err) {
              if (console.error) {
                console.error(err);
              }
            } else if (console[name]) {
              _each(args, function (x) {
                console[name](x);
              });
            }
          }
        }]));
    };
  };
  async.log = _console_fn('log');
  async.dir = _console_fn('dir');
  async.memoize = function (fn, hasher) {
    var memo = {};
    var queues = {};
    hasher = hasher || function (x) {
      return x;
    };
    var memoized = function () {
      var args = Array.prototype.slice.call(arguments);
      var callback = args.pop();
      var key = hasher.apply(null, args);
      if (key in memo) {
        callback.apply(null, memo[key]);
      } else if (key in queues) {
        queues[key].push(callback);
      } else {
        queues[key] = [callback];
        fn.apply(null, args.concat([function () {
            memo[key] = arguments;
            var q = queues[key];
            delete queues[key];
            for (var i = 0, l = q.length; i < l; i++) {
              q[i].apply(null, arguments);
            }
          }]));
      }
    };
    memoized.memo = memo;
    memoized.unmemoized = fn;
    return memoized;
  };
  async.unmemoize = function (fn) {
    return function () {
      return (fn.unmemoized || fn).apply(null, arguments);
    };
  };
  async.times = function (count, iterator, callback) {
    var counter = [];
    for (var i = 0; i < count; i++) {
      counter.push(i);
    }
    return async.map(counter, iterator, callback);
  };
  async.timesSeries = function (count, iterator, callback) {
    var counter = [];
    for (var i = 0; i < count; i++) {
      counter.push(i);
    }
    return async.mapSeries(counter, iterator, callback);
  };
  async.compose = function () {
    var fns = Array.prototype.reverse.call(arguments);
    return function () {
      var that = this;
      var args = Array.prototype.slice.call(arguments);
      var callback = args.pop();
      async.reduce(fns, args, function (newargs, fn, cb) {
        fn.apply(that, newargs.concat([function () {
            var err = arguments[0];
            var nextargs = Array.prototype.slice.call(arguments, 1);
            cb(err, nextargs);
          }]));
      }, function (err, results) {
        callback.apply(that, [err].concat(results));
      });
    };
  };
  var _applyEach = function (eachfn, fns) {
    var go = function () {
      var that = this;
      var args = Array.prototype.slice.call(arguments);
      var callback = args.pop();
      return eachfn(fns, function (fn, cb) {
        fn.apply(that, args.concat([cb]));
      }, callback);
    };
    if (arguments.length > 2) {
      var args = Array.prototype.slice.call(arguments, 2);
      return go.apply(this, args);
    } else {
      return go;
    }
  };
  async.applyEach = doParallel(_applyEach);
  async.applyEachSeries = doSeries(_applyEach);
  async.forever = function (fn, callback) {
    function next(err) {
      if (err) {
        if (callback) {
          return callback(err);
        }
        throw err;
      }
      fn(next);
    }
    next();
  };
  if (typeof define !== 'undefined' && define.amd) {
    define([], function () {
      return async;
    });
  } else if (typeof module !== 'undefined' && module.exports) {
    module.exports = async;
  } else {
    root.async = async;
  }
}());
(function (window, undefined) {
  var rootjQuery, readyList, core_strundefined = typeof undefined, location = window.location, document = window.document, docElem = document.documentElement, _jQuery = window.jQuery, _$ = window.$, class2type = {}, core_deletedIds = [], core_version = '2.0.3', core_concat = core_deletedIds.concat, core_push = core_deletedIds.push, core_slice = core_deletedIds.slice, core_indexOf = core_deletedIds.indexOf, core_toString = class2type.toString, core_hasOwn = class2type.hasOwnProperty, core_trim = core_version.trim, jQuery = function (selector, context) {
      return new jQuery.fn.init(selector, context, rootjQuery);
    }, core_pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source, core_rnotwhite = /\S+/g, rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/, rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>|)$/, rmsPrefix = /^-ms-/, rdashAlpha = /-([\da-z])/gi, fcamelCase = function (all, letter) {
      return letter.toUpperCase();
    }, completed = function () {
      document.removeEventListener('DOMContentLoaded', completed, false);
      window.removeEventListener('load', completed, false);
      jQuery.ready();
    };
  jQuery.fn = jQuery.prototype = {
    jquery: core_version,
    constructor: jQuery,
    init: function (selector, context, rootjQuery) {
      var match, elem;
      if (!selector) {
        return this;
      }
      if (typeof selector === 'string') {
        if (selector.charAt(0) === '<' && selector.charAt(selector.length - 1) === '>' && selector.length >= 3) {
          match = [
            null,
            selector,
            null
          ];
        } else {
          match = rquickExpr.exec(selector);
        }
        if (match && (match[1] || !context)) {
          if (match[1]) {
            context = context instanceof jQuery ? context[0] : context;
            jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true));
            if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
              for (match in context) {
                if (jQuery.isFunction(this[match])) {
                  this[match](context[match]);
                } else {
                  this.attr(match, context[match]);
                }
              }
            }
            return this;
          } else {
            elem = document.getElementById(match[2]);
            if (elem && elem.parentNode) {
              this.length = 1;
              this[0] = elem;
            }
            this.context = document;
            this.selector = selector;
            return this;
          }
        } else if (!context || context.jquery) {
          return (context || rootjQuery).find(selector);
        } else {
          return this.constructor(context).find(selector);
        }
      } else if (selector.nodeType) {
        this.context = this[0] = selector;
        this.length = 1;
        return this;
      } else if (jQuery.isFunction(selector)) {
        return rootjQuery.ready(selector);
      }
      if (selector.selector !== undefined) {
        this.selector = selector.selector;
        this.context = selector.context;
      }
      return jQuery.makeArray(selector, this);
    },
    selector: '',
    length: 0,
    toArray: function () {
      return core_slice.call(this);
    },
    get: function (num) {
      return num == null ? this.toArray() : num < 0 ? this[this.length + num] : this[num];
    },
    pushStack: function (elems) {
      var ret = jQuery.merge(this.constructor(), elems);
      ret.prevObject = this;
      ret.context = this.context;
      return ret;
    },
    each: function (callback, args) {
      return jQuery.each(this, callback, args);
    },
    ready: function (fn) {
      jQuery.ready.promise().done(fn);
      return this;
    },
    slice: function () {
      return this.pushStack(core_slice.apply(this, arguments));
    },
    first: function () {
      return this.eq(0);
    },
    last: function () {
      return this.eq(-1);
    },
    eq: function (i) {
      var len = this.length, j = +i + (i < 0 ? len : 0);
      return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
    },
    map: function (callback) {
      return this.pushStack(jQuery.map(this, function (elem, i) {
        return callback.call(elem, i, elem);
      }));
    },
    end: function () {
      return this.prevObject || this.constructor(null);
    },
    push: core_push,
    sort: [].sort,
    splice: [].splice
  };
  jQuery.fn.init.prototype = jQuery.fn;
  jQuery.extend = jQuery.fn.extend = function () {
    var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false;
    if (typeof target === 'boolean') {
      deep = target;
      target = arguments[1] || {};
      i = 2;
    }
    if (typeof target !== 'object' && !jQuery.isFunction(target)) {
      target = {};
    }
    if (length === i) {
      target = this;
      --i;
    }
    for (; i < length; i++) {
      if ((options = arguments[i]) != null) {
        for (name in options) {
          src = target[name];
          copy = options[name];
          if (target === copy) {
            continue;
          }
          if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {
            if (copyIsArray) {
              copyIsArray = false;
              clone = src && jQuery.isArray(src) ? src : [];
            } else {
              clone = src && jQuery.isPlainObject(src) ? src : {};
            }
            target[name] = jQuery.extend(deep, clone, copy);
          } else if (copy !== undefined) {
            target[name] = copy;
          }
        }
      }
    }
    return target;
  };
  jQuery.extend({
    expando: 'jQuery' + (core_version + Math.random()).replace(/\D/g, ''),
    noConflict: function (deep) {
      if (window.$ === jQuery) {
        window.$ = _$;
      }
      if (deep && window.jQuery === jQuery) {
        window.jQuery = _jQuery;
      }
      return jQuery;
    },
    isReady: false,
    readyWait: 1,
    holdReady: function (hold) {
      if (hold) {
        jQuery.readyWait++;
      } else {
        jQuery.ready(true);
      }
    },
    ready: function (wait) {
      if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
        return;
      }
      jQuery.isReady = true;
      if (wait !== true && --jQuery.readyWait > 0) {
        return;
      }
      readyList.resolveWith(document, [jQuery]);
      if (jQuery.fn.trigger) {
        jQuery(document).trigger('ready').off('ready');
      }
    },
    isFunction: function (obj) {
      return jQuery.type(obj) === 'function';
    },
    isArray: Array.isArray,
    isWindow: function (obj) {
      return obj != null && obj === obj.window;
    },
    isNumeric: function (obj) {
      return !isNaN(parseFloat(obj)) && isFinite(obj);
    },
    type: function (obj) {
      if (obj == null) {
        return String(obj);
      }
      return typeof obj === 'object' || typeof obj === 'function' ? class2type[core_toString.call(obj)] || 'object' : typeof obj;
    },
    isPlainObject: function (obj) {
      if (jQuery.type(obj) !== 'object' || obj.nodeType || jQuery.isWindow(obj)) {
        return false;
      }
      try {
        if (obj.constructor && !core_hasOwn.call(obj.constructor.prototype, 'isPrototypeOf')) {
          return false;
        }
      } catch (e) {
        return false;
      }
      return true;
    },
    isEmptyObject: function (obj) {
      var name;
      for (name in obj) {
        return false;
      }
      return true;
    },
    error: function (msg) {
      throw new Error(msg);
    },
    parseHTML: function (data, context, keepScripts) {
      if (!data || typeof data !== 'string') {
        return null;
      }
      if (typeof context === 'boolean') {
        keepScripts = context;
        context = false;
      }
      context = context || document;
      var parsed = rsingleTag.exec(data), scripts = !keepScripts && [];
      if (parsed) {
        return [context.createElement(parsed[1])];
      }
      parsed = jQuery.buildFragment([data], context, scripts);
      if (scripts) {
        jQuery(scripts).remove();
      }
      return jQuery.merge([], parsed.childNodes);
    },
    parseJSON: JSON.parse,
    parseXML: function (data) {
      var xml, tmp;
      if (!data || typeof data !== 'string') {
        return null;
      }
      try {
        tmp = new DOMParser();
        xml = tmp.parseFromString(data, 'text/xml');
      } catch (e) {
        xml = undefined;
      }
      if (!xml || xml.getElementsByTagName('parsererror').length) {
        jQuery.error('Invalid XML: ' + data);
      }
      return xml;
    },
    noop: function () {
    },
    globalEval: function (code) {
      var script, indirect = eval;
      code = jQuery.trim(code);
      if (code) {
        if (code.indexOf('use strict') === 1) {
          script = document.createElement('script');
          script.text = code;
          document.head.appendChild(script).parentNode.removeChild(script);
        } else {
          indirect(code);
        }
      }
    },
    camelCase: function (string) {
      return string.replace(rmsPrefix, 'ms-').replace(rdashAlpha, fcamelCase);
    },
    nodeName: function (elem, name) {
      return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
    },
    each: function (obj, callback, args) {
      var value, i = 0, length = obj.length, isArray = isArraylike(obj);
      if (args) {
        if (isArray) {
          for (; i < length; i++) {
            value = callback.apply(obj[i], args);
            if (value === false) {
              break;
            }
          }
        } else {
          for (i in obj) {
            value = callback.apply(obj[i], args);
            if (value === false) {
              break;
            }
          }
        }
      } else {
        if (isArray) {
          for (; i < length; i++) {
            value = callback.call(obj[i], i, obj[i]);
            if (value === false) {
              break;
            }
          }
        } else {
          for (i in obj) {
            value = callback.call(obj[i], i, obj[i]);
            if (value === false) {
              break;
            }
          }
        }
      }
      return obj;
    },
    trim: function (text) {
      return text == null ? '' : core_trim.call(text);
    },
    makeArray: function (arr, results) {
      var ret = results || [];
      if (arr != null) {
        if (isArraylike(Object(arr))) {
          jQuery.merge(ret, typeof arr === 'string' ? [arr] : arr);
        } else {
          core_push.call(ret, arr);
        }
      }
      return ret;
    },
    inArray: function (elem, arr, i) {
      return arr == null ? -1 : core_indexOf.call(arr, elem, i);
    },
    merge: function (first, second) {
      var l = second.length, i = first.length, j = 0;
      if (typeof l === 'number') {
        for (; j < l; j++) {
          first[i++] = second[j];
        }
      } else {
        while (second[j] !== undefined) {
          first[i++] = second[j++];
        }
      }
      first.length = i;
      return first;
    },
    grep: function (elems, callback, inv) {
      var retVal, ret = [], i = 0, length = elems.length;
      inv = !!inv;
      for (; i < length; i++) {
        retVal = !!callback(elems[i], i);
        if (inv !== retVal) {
          ret.push(elems[i]);
        }
      }
      return ret;
    },
    map: function (elems, callback, arg) {
      var value, i = 0, length = elems.length, isArray = isArraylike(elems), ret = [];
      if (isArray) {
        for (; i < length; i++) {
          value = callback(elems[i], i, arg);
          if (value != null) {
            ret[ret.length] = value;
          }
        }
      } else {
        for (i in elems) {
          value = callback(elems[i], i, arg);
          if (value != null) {
            ret[ret.length] = value;
          }
        }
      }
      return core_concat.apply([], ret);
    },
    guid: 1,
    proxy: function (fn, context) {
      var tmp, args, proxy;
      if (typeof context === 'string') {
        tmp = fn[context];
        context = fn;
        fn = tmp;
      }
      if (!jQuery.isFunction(fn)) {
        return undefined;
      }
      args = core_slice.call(arguments, 2);
      proxy = function () {
        return fn.apply(context || this, args.concat(core_slice.call(arguments)));
      };
      proxy.guid = fn.guid = fn.guid || jQuery.guid++;
      return proxy;
    },
    access: function (elems, fn, key, value, chainable, emptyGet, raw) {
      var i = 0, length = elems.length, bulk = key == null;
      if (jQuery.type(key) === 'object') {
        chainable = true;
        for (i in key) {
          jQuery.access(elems, fn, i, key[i], true, emptyGet, raw);
        }
      } else if (value !== undefined) {
        chainable = true;
        if (!jQuery.isFunction(value)) {
          raw = true;
        }
        if (bulk) {
          if (raw) {
            fn.call(elems, value);
            fn = null;
          } else {
            bulk = fn;
            fn = function (elem, key, value) {
              return bulk.call(jQuery(elem), value);
            };
          }
        }
        if (fn) {
          for (; i < length; i++) {
            fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
          }
        }
      }
      return chainable ? elems : bulk ? fn.call(elems) : length ? fn(elems[0], key) : emptyGet;
    },
    now: Date.now,
    swap: function (elem, options, callback, args) {
      var ret, name, old = {};
      for (name in options) {
        old[name] = elem.style[name];
        elem.style[name] = options[name];
      }
      ret = callback.apply(elem, args || []);
      for (name in options) {
        elem.style[name] = old[name];
      }
      return ret;
    }
  });
  jQuery.ready.promise = function (obj) {
    if (!readyList) {
      readyList = jQuery.Deferred();
      if (document.readyState === 'complete') {
        setTimeout(jQuery.ready);
      } else {
        document.addEventListener('DOMContentLoaded', completed, false);
        window.addEventListener('load', completed, false);
      }
    }
    return readyList.promise(obj);
  };
  jQuery.each('Boolean Number String Function Array Date RegExp Object Error'.split(' '), function (i, name) {
    class2type['[object ' + name + ']'] = name.toLowerCase();
  });
  function isArraylike(obj) {
    var length = obj.length, type = jQuery.type(obj);
    if (jQuery.isWindow(obj)) {
      return false;
    }
    if (obj.nodeType === 1 && length) {
      return true;
    }
    return type === 'array' || type !== 'function' && (length === 0 || typeof length === 'number' && length > 0 && length - 1 in obj);
  }
  rootjQuery = jQuery(document);
  (function (window, undefined) {
    var i, support, cachedruns, Expr, getText, isXML, compile, outermostContext, sortInput, setDocument, document, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains, expando = 'sizzle' + -new Date(), preferredDoc = window.document, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), hasDuplicate = false, sortOrder = function (a, b) {
        if (a === b) {
          hasDuplicate = true;
          return 0;
        }
        return 0;
      }, strundefined = typeof undefined, MAX_NEGATIVE = 1 << 31, hasOwn = {}.hasOwnProperty, arr = [], pop = arr.pop, push_native = arr.push, push = arr.push, slice = arr.slice, indexOf = arr.indexOf || function (elem) {
        var i = 0, len = this.length;
        for (; i < len; i++) {
          if (this[i] === elem) {
            return i;
          }
        }
        return -1;
      }, booleans = 'checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped', whitespace = '[\\x20\\t\\r\\n\\f]', characterEncoding = '(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+', identifier = characterEncoding.replace('w', 'w#'), attributes = '\\[' + whitespace + '*(' + characterEncoding + ')' + whitespace + '*(?:([*^$|!~]?=)' + whitespace + '*(?:([\'"])((?:\\\\.|[^\\\\])*?)\\3|(' + identifier + ')|)|)' + whitespace + '*\\]', pseudos = ':(' + characterEncoding + ')(?:\\((([\'"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|' + attributes.replace(3, 8) + ')*)|.*)\\)|)', rtrim = new RegExp('^' + whitespace + '+|((?:^|[^\\\\])(?:\\\\.)*)' + whitespace + '+$', 'g'), rcomma = new RegExp('^' + whitespace + '*,' + whitespace + '*'), rcombinators = new RegExp('^' + whitespace + '*([>+~]|' + whitespace + ')' + whitespace + '*'), rsibling = new RegExp(whitespace + '*[+~]'), rattributeQuotes = new RegExp('=' + whitespace + '*([^\\]\'"]*)' + whitespace + '*\\]', 'g'), rpseudo = new RegExp(pseudos), ridentifier = new RegExp('^' + identifier + '$'), matchExpr = {
        'ID': new RegExp('^#(' + characterEncoding + ')'),
        'CLASS': new RegExp('^\\.(' + characterEncoding + ')'),
        'TAG': new RegExp('^(' + characterEncoding.replace('w', 'w*') + ')'),
        'ATTR': new RegExp('^' + attributes),
        'PSEUDO': new RegExp('^' + pseudos),
        'CHILD': new RegExp('^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(' + whitespace + '*(even|odd|(([+-]|)(\\d*)n|)' + whitespace + '*(?:([+-]|)' + whitespace + '*(\\d+)|))' + whitespace + '*\\)|)', 'i'),
        'bool': new RegExp('^(?:' + booleans + ')$', 'i'),
        'needsContext': new RegExp('^' + whitespace + '*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(' + whitespace + '*((?:-\\d)?\\d*)' + whitespace + '*\\)|)(?=[^-]|$)', 'i')
      }, rnative = /^[^{]+\{\s*\[native \w/, rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rescape = /'|\\/g, runescape = new RegExp('\\\\([\\da-f]{1,6}' + whitespace + '?|(' + whitespace + ')|.)', 'ig'), funescape = function (_, escaped, escapedWhitespace) {
        var high = '0x' + escaped - 65536;
        return high !== high || escapedWhitespace ? escaped : high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320);
      };
    try {
      push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes);
      arr[preferredDoc.childNodes.length].nodeType;
    } catch (e) {
      push = {
        apply: arr.length ? function (target, els) {
          push_native.apply(target, slice.call(els));
        } : function (target, els) {
          var j = target.length, i = 0;
          while (target[j++] = els[i++]) {
          }
          target.length = j - 1;
        }
      };
    }
    function Sizzle(selector, context, results, seed) {
      var match, elem, m, nodeType, i, groups, old, nid, newContext, newSelector;
      if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
        setDocument(context);
      }
      context = context || document;
      results = results || [];
      if (!selector || typeof selector !== 'string') {
        return results;
      }
      if ((nodeType = context.nodeType) !== 1 && nodeType !== 9) {
        return [];
      }
      if (documentIsHTML && !seed) {
        if (match = rquickExpr.exec(selector)) {
          if (m = match[1]) {
            if (nodeType === 9) {
              elem = context.getElementById(m);
              if (elem && elem.parentNode) {
                if (elem.id === m) {
                  results.push(elem);
                  return results;
                }
              } else {
                return results;
              }
            } else {
              if (context.ownerDocument && (elem = context.ownerDocument.getElementById(m)) && contains(context, elem) && elem.id === m) {
                results.push(elem);
                return results;
              }
            }
          } else if (match[2]) {
            push.apply(results, context.getElementsByTagName(selector));
            return results;
          } else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {
            push.apply(results, context.getElementsByClassName(m));
            return results;
          }
        }
        if (support.qsa && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
          nid = old = expando;
          newContext = context;
          newSelector = nodeType === 9 && selector;
          if (nodeType === 1 && context.nodeName.toLowerCase() !== 'object') {
            groups = tokenize(selector);
            if (old = context.getAttribute('id')) {
              nid = old.replace(rescape, '\\$&');
            } else {
              context.setAttribute('id', nid);
            }
            nid = '[id=\'' + nid + '\'] ';
            i = groups.length;
            while (i--) {
              groups[i] = nid + toSelector(groups[i]);
            }
            newContext = rsibling.test(selector) && context.parentNode || context;
            newSelector = groups.join(',');
          }
          if (newSelector) {
            try {
              push.apply(results, newContext.querySelectorAll(newSelector));
              return results;
            } catch (qsaError) {
            } finally {
              if (!old) {
                context.removeAttribute('id');
              }
            }
          }
        }
      }
      return select(selector.replace(rtrim, '$1'), context, results, seed);
    }
    function createCache() {
      var keys = [];
      function cache(key, value) {
        if (keys.push(key += ' ') > Expr.cacheLength) {
          delete cache[keys.shift()];
        }
        return cache[key] = value;
      }
      return cache;
    }
    function markFunction(fn) {
      fn[expando] = true;
      return fn;
    }
    function assert(fn) {
      var div = document.createElement('div');
      try {
        return !!fn(div);
      } catch (e) {
        return false;
      } finally {
        if (div.parentNode) {
          div.parentNode.removeChild(div);
        }
        div = null;
      }
    }
    function addHandle(attrs, handler) {
      var arr = attrs.split('|'), i = attrs.length;
      while (i--) {
        Expr.attrHandle[arr[i]] = handler;
      }
    }
    function siblingCheck(a, b) {
      var cur = b && a, diff = cur && a.nodeType === 1 && b.nodeType === 1 && (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE);
      if (diff) {
        return diff;
      }
      if (cur) {
        while (cur = cur.nextSibling) {
          if (cur === b) {
            return -1;
          }
        }
      }
      return a ? 1 : -1;
    }
    function createInputPseudo(type) {
      return function (elem) {
        var name = elem.nodeName.toLowerCase();
        return name === 'input' && elem.type === type;
      };
    }
    function createButtonPseudo(type) {
      return function (elem) {
        var name = elem.nodeName.toLowerCase();
        return (name === 'input' || name === 'button') && elem.type === type;
      };
    }
    function createPositionalPseudo(fn) {
      return markFunction(function (argument) {
        argument = +argument;
        return markFunction(function (seed, matches) {
          var j, matchIndexes = fn([], seed.length, argument), i = matchIndexes.length;
          while (i--) {
            if (seed[j = matchIndexes[i]]) {
              seed[j] = !(matches[j] = seed[j]);
            }
          }
        });
      });
    }
    isXML = Sizzle.isXML = function (elem) {
      var documentElement = elem && (elem.ownerDocument || elem).documentElement;
      return documentElement ? documentElement.nodeName !== 'HTML' : false;
    };
    support = Sizzle.support = {};
    setDocument = Sizzle.setDocument = function (node) {
      var doc = node ? node.ownerDocument || node : preferredDoc, parent = doc.defaultView;
      if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
        return document;
      }
      document = doc;
      docElem = doc.documentElement;
      documentIsHTML = !isXML(doc);
      if (parent && parent.attachEvent && parent !== parent.top) {
        parent.attachEvent('onbeforeunload', function () {
          setDocument();
        });
      }
      support.attributes = assert(function (div) {
        div.className = 'i';
        return !div.getAttribute('className');
      });
      support.getElementsByTagName = assert(function (div) {
        div.appendChild(doc.createComment(''));
        return !div.getElementsByTagName('*').length;
      });
      support.getElementsByClassName = assert(function (div) {
        div.innerHTML = '<div class=\'a\'></div><div class=\'a i\'></div>';
        div.firstChild.className = 'i';
        return div.getElementsByClassName('i').length === 2;
      });
      support.getById = assert(function (div) {
        docElem.appendChild(div).id = expando;
        return !doc.getElementsByName || !doc.getElementsByName(expando).length;
      });
      if (support.getById) {
        Expr.find['ID'] = function (id, context) {
          if (typeof context.getElementById !== strundefined && documentIsHTML) {
            var m = context.getElementById(id);
            return m && m.parentNode ? [m] : [];
          }
        };
        Expr.filter['ID'] = function (id) {
          var attrId = id.replace(runescape, funescape);
          return function (elem) {
            return elem.getAttribute('id') === attrId;
          };
        };
      } else {
        delete Expr.find['ID'];
        Expr.filter['ID'] = function (id) {
          var attrId = id.replace(runescape, funescape);
          return function (elem) {
            var node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode('id');
            return node && node.value === attrId;
          };
        };
      }
      Expr.find['TAG'] = support.getElementsByTagName ? function (tag, context) {
        if (typeof context.getElementsByTagName !== strundefined) {
          return context.getElementsByTagName(tag);
        }
      } : function (tag, context) {
        var elem, tmp = [], i = 0, results = context.getElementsByTagName(tag);
        if (tag === '*') {
          while (elem = results[i++]) {
            if (elem.nodeType === 1) {
              tmp.push(elem);
            }
          }
          return tmp;
        }
        return results;
      };
      Expr.find['CLASS'] = support.getElementsByClassName && function (className, context) {
        if (typeof context.getElementsByClassName !== strundefined && documentIsHTML) {
          return context.getElementsByClassName(className);
        }
      };
      rbuggyMatches = [];
      rbuggyQSA = [];
      if (support.qsa = rnative.test(doc.querySelectorAll)) {
        assert(function (div) {
          div.innerHTML = '<select><option selected=\'\'></option></select>';
          if (!div.querySelectorAll('[selected]').length) {
            rbuggyQSA.push('\\[' + whitespace + '*(?:value|' + booleans + ')');
          }
          if (!div.querySelectorAll(':checked').length) {
            rbuggyQSA.push(':checked');
          }
        });
        assert(function (div) {
          var input = doc.createElement('input');
          input.setAttribute('type', 'hidden');
          div.appendChild(input).setAttribute('t', '');
          if (div.querySelectorAll('[t^=\'\']').length) {
            rbuggyQSA.push('[*^$]=' + whitespace + '*(?:\'\'|"")');
          }
          if (!div.querySelectorAll(':enabled').length) {
            rbuggyQSA.push(':enabled', ':disabled');
          }
          div.querySelectorAll('*,:x');
          rbuggyQSA.push(',.*:');
        });
      }
      if (support.matchesSelector = rnative.test(matches = docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {
        assert(function (div) {
          support.disconnectedMatch = matches.call(div, 'div');
          matches.call(div, '[s!=\'\']:x');
          rbuggyMatches.push('!=', pseudos);
        });
      }
      rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join('|'));
      rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join('|'));
      contains = rnative.test(docElem.contains) || docElem.compareDocumentPosition ? function (a, b) {
        var adown = a.nodeType === 9 ? a.documentElement : a, bup = b && b.parentNode;
        return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
      } : function (a, b) {
        if (b) {
          while (b = b.parentNode) {
            if (b === a) {
              return true;
            }
          }
        }
        return false;
      };
      sortOrder = docElem.compareDocumentPosition ? function (a, b) {
        if (a === b) {
          hasDuplicate = true;
          return 0;
        }
        var compare = b.compareDocumentPosition && a.compareDocumentPosition && a.compareDocumentPosition(b);
        if (compare) {
          if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {
            if (a === doc || contains(preferredDoc, a)) {
              return -1;
            }
            if (b === doc || contains(preferredDoc, b)) {
              return 1;
            }
            return sortInput ? indexOf.call(sortInput, a) - indexOf.call(sortInput, b) : 0;
          }
          return compare & 4 ? -1 : 1;
        }
        return a.compareDocumentPosition ? -1 : 1;
      } : function (a, b) {
        var cur, i = 0, aup = a.parentNode, bup = b.parentNode, ap = [a], bp = [b];
        if (a === b) {
          hasDuplicate = true;
          return 0;
        } else if (!aup || !bup) {
          return a === doc ? -1 : b === doc ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf.call(sortInput, a) - indexOf.call(sortInput, b) : 0;
        } else if (aup === bup) {
          return siblingCheck(a, b);
        }
        cur = a;
        while (cur = cur.parentNode) {
          ap.unshift(cur);
        }
        cur = b;
        while (cur = cur.parentNode) {
          bp.unshift(cur);
        }
        while (ap[i] === bp[i]) {
          i++;
        }
        return i ? siblingCheck(ap[i], bp[i]) : ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
      };
      return doc;
    };
    Sizzle.matches = function (expr, elements) {
      return Sizzle(expr, null, null, elements);
    };
    Sizzle.matchesSelector = function (elem, expr) {
      if ((elem.ownerDocument || elem) !== document) {
        setDocument(elem);
      }
      expr = expr.replace(rattributeQuotes, '=\'$1\']');
      if (support.matchesSelector && documentIsHTML && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
        try {
          var ret = matches.call(elem, expr);
          if (ret || support.disconnectedMatch || elem.document && elem.document.nodeType !== 11) {
            return ret;
          }
        } catch (e) {
        }
      }
      return Sizzle(expr, document, null, [elem]).length > 0;
    };
    Sizzle.contains = function (context, elem) {
      if ((context.ownerDocument || context) !== document) {
        setDocument(context);
      }
      return contains(context, elem);
    };
    Sizzle.attr = function (elem, name) {
      if ((elem.ownerDocument || elem) !== document) {
        setDocument(elem);
      }
      var fn = Expr.attrHandle[name.toLowerCase()], val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
      return val === undefined ? support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null : val;
    };
    Sizzle.error = function (msg) {
      throw new Error('Syntax error, unrecognized expression: ' + msg);
    };
    Sizzle.uniqueSort = function (results) {
      var elem, duplicates = [], j = 0, i = 0;
      hasDuplicate = !support.detectDuplicates;
      sortInput = !support.sortStable && results.slice(0);
      results.sort(sortOrder);
      if (hasDuplicate) {
        while (elem = results[i++]) {
          if (elem === results[i]) {
            j = duplicates.push(i);
          }
        }
        while (j--) {
          results.splice(duplicates[j], 1);
        }
      }
      return results;
    };
    getText = Sizzle.getText = function (elem) {
      var node, ret = '', i = 0, nodeType = elem.nodeType;
      if (!nodeType) {
        for (; node = elem[i]; i++) {
          ret += getText(node);
        }
      } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
        if (typeof elem.textContent === 'string') {
          return elem.textContent;
        } else {
          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
            ret += getText(elem);
          }
        }
      } else if (nodeType === 3 || nodeType === 4) {
        return elem.nodeValue;
      }
      return ret;
    };
    Expr = Sizzle.selectors = {
      cacheLength: 50,
      createPseudo: markFunction,
      match: matchExpr,
      attrHandle: {},
      find: {},
      relative: {
        '>': {
          dir: 'parentNode',
          first: true
        },
        ' ': { dir: 'parentNode' },
        '+': {
          dir: 'previousSibling',
          first: true
        },
        '~': { dir: 'previousSibling' }
      },
      preFilter: {
        'ATTR': function (match) {
          match[1] = match[1].replace(runescape, funescape);
          match[3] = (match[4] || match[5] || '').replace(runescape, funescape);
          if (match[2] === '~=') {
            match[3] = ' ' + match[3] + ' ';
          }
          return match.slice(0, 4);
        },
        'CHILD': function (match) {
          match[1] = match[1].toLowerCase();
          if (match[1].slice(0, 3) === 'nth') {
            if (!match[3]) {
              Sizzle.error(match[0]);
            }
            match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === 'even' || match[3] === 'odd'));
            match[5] = +(match[7] + match[8] || match[3] === 'odd');
          } else if (match[3]) {
            Sizzle.error(match[0]);
          }
          return match;
        },
        'PSEUDO': function (match) {
          var excess, unquoted = !match[5] && match[2];
          if (matchExpr['CHILD'].test(match[0])) {
            return null;
          }
          if (match[3] && match[4] !== undefined) {
            match[2] = match[4];
          } else if (unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, true)) && (excess = unquoted.indexOf(')', unquoted.length - excess) - unquoted.length)) {
            match[0] = match[0].slice(0, excess);
            match[2] = unquoted.slice(0, excess);
          }
          return match.slice(0, 3);
        }
      },
      filter: {
        'TAG': function (nodeNameSelector) {
          var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
          return nodeNameSelector === '*' ? function () {
            return true;
          } : function (elem) {
            return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
          };
        },
        'CLASS': function (className) {
          var pattern = classCache[className + ' '];
          return pattern || (pattern = new RegExp('(^|' + whitespace + ')' + className + '(' + whitespace + '|$)')) && classCache(className, function (elem) {
            return pattern.test(typeof elem.className === 'string' && elem.className || typeof elem.getAttribute !== strundefined && elem.getAttribute('class') || '');
          });
        },
        'ATTR': function (name, operator, check) {
          return function (elem) {
            var result = Sizzle.attr(elem, name);
            if (result == null) {
              return operator === '!=';
            }
            if (!operator) {
              return true;
            }
            result += '';
            return operator === '=' ? result === check : operator === '!=' ? result !== check : operator === '^=' ? check && result.indexOf(check) === 0 : operator === '*=' ? check && result.indexOf(check) > -1 : operator === '$=' ? check && result.slice(-check.length) === check : operator === '~=' ? (' ' + result + ' ').indexOf(check) > -1 : operator === '|=' ? result === check || result.slice(0, check.length + 1) === check + '-' : false;
          };
        },
        'CHILD': function (type, what, argument, first, last) {
          var simple = type.slice(0, 3) !== 'nth', forward = type.slice(-4) !== 'last', ofType = what === 'of-type';
          return first === 1 && last === 0 ? function (elem) {
            return !!elem.parentNode;
          } : function (elem, context, xml) {
            var cache, outerCache, node, diff, nodeIndex, start, dir = simple !== forward ? 'nextSibling' : 'previousSibling', parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType;
            if (parent) {
              if (simple) {
                while (dir) {
                  node = elem;
                  while (node = node[dir]) {
                    if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                      return false;
                    }
                  }
                  start = dir = type === 'only' && !start && 'nextSibling';
                }
                return true;
              }
              start = [forward ? parent.firstChild : parent.lastChild];
              if (forward && useCache) {
                outerCache = parent[expando] || (parent[expando] = {});
                cache = outerCache[type] || [];
                nodeIndex = cache[0] === dirruns && cache[1];
                diff = cache[0] === dirruns && cache[2];
                node = nodeIndex && parent.childNodes[nodeIndex];
                while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                  if (node.nodeType === 1 && ++diff && node === elem) {
                    outerCache[type] = [
                      dirruns,
                      nodeIndex,
                      diff
                    ];
                    break;
                  }
                }
              } else if (useCache && (cache = (elem[expando] || (elem[expando] = {}))[type]) && cache[0] === dirruns) {
                diff = cache[1];
              } else {
                while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                  if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                    if (useCache) {
                      (node[expando] || (node[expando] = {}))[type] = [
                        dirruns,
                        diff
                      ];
                    }
                    if (node === elem) {
                      break;
                    }
                  }
                }
              }
              diff -= last;
              return diff === first || diff % first === 0 && diff / first >= 0;
            }
          };
        },
        'PSEUDO': function (pseudo, argument) {
          var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error('unsupported pseudo: ' + pseudo);
          if (fn[expando]) {
            return fn(argument);
          }
          if (fn.length > 1) {
            args = [
              pseudo,
              pseudo,
              '',
              argument
            ];
            return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {
              var idx, matched = fn(seed, argument), i = matched.length;
              while (i--) {
                idx = indexOf.call(seed, matched[i]);
                seed[idx] = !(matches[idx] = matched[i]);
              }
            }) : function (elem) {
              return fn(elem, 0, args);
            };
          }
          return fn;
        }
      },
      pseudos: {
        'not': markFunction(function (selector) {
          var input = [], results = [], matcher = compile(selector.replace(rtrim, '$1'));
          return matcher[expando] ? markFunction(function (seed, matches, context, xml) {
            var elem, unmatched = matcher(seed, null, xml, []), i = seed.length;
            while (i--) {
              if (elem = unmatched[i]) {
                seed[i] = !(matches[i] = elem);
              }
            }
          }) : function (elem, context, xml) {
            input[0] = elem;
            matcher(input, null, xml, results);
            return !results.pop();
          };
        }),
        'has': markFunction(function (selector) {
          return function (elem) {
            return Sizzle(selector, elem).length > 0;
          };
        }),
        'contains': markFunction(function (text) {
          return function (elem) {
            return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
          };
        }),
        'lang': markFunction(function (lang) {
          if (!ridentifier.test(lang || '')) {
            Sizzle.error('unsupported lang: ' + lang);
          }
          lang = lang.replace(runescape, funescape).toLowerCase();
          return function (elem) {
            var elemLang;
            do {
              if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute('xml:lang') || elem.getAttribute('lang')) {
                elemLang = elemLang.toLowerCase();
                return elemLang === lang || elemLang.indexOf(lang + '-') === 0;
              }
            } while ((elem = elem.parentNode) && elem.nodeType === 1);
            return false;
          };
        }),
        'target': function (elem) {
          var hash = window.location && window.location.hash;
          return hash && hash.slice(1) === elem.id;
        },
        'root': function (elem) {
          return elem === docElem;
        },
        'focus': function (elem) {
          return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
        },
        'enabled': function (elem) {
          return elem.disabled === false;
        },
        'disabled': function (elem) {
          return elem.disabled === true;
        },
        'checked': function (elem) {
          var nodeName = elem.nodeName.toLowerCase();
          return nodeName === 'input' && !!elem.checked || nodeName === 'option' && !!elem.selected;
        },
        'selected': function (elem) {
          if (elem.parentNode) {
            elem.parentNode.selectedIndex;
          }
          return elem.selected === true;
        },
        'empty': function (elem) {
          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
            if (elem.nodeName > '@' || elem.nodeType === 3 || elem.nodeType === 4) {
              return false;
            }
          }
          return true;
        },
        'parent': function (elem) {
          return !Expr.pseudos['empty'](elem);
        },
        'header': function (elem) {
          return rheader.test(elem.nodeName);
        },
        'input': function (elem) {
          return rinputs.test(elem.nodeName);
        },
        'button': function (elem) {
          var name = elem.nodeName.toLowerCase();
          return name === 'input' && elem.type === 'button' || name === 'button';
        },
        'text': function (elem) {
          var attr;
          return elem.nodeName.toLowerCase() === 'input' && elem.type === 'text' && ((attr = elem.getAttribute('type')) == null || attr.toLowerCase() === elem.type);
        },
        'first': createPositionalPseudo(function () {
          return [0];
        }),
        'last': createPositionalPseudo(function (matchIndexes, length) {
          return [length - 1];
        }),
        'eq': createPositionalPseudo(function (matchIndexes, length, argument) {
          return [argument < 0 ? argument + length : argument];
        }),
        'even': createPositionalPseudo(function (matchIndexes, length) {
          var i = 0;
          for (; i < length; i += 2) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        }),
        'odd': createPositionalPseudo(function (matchIndexes, length) {
          var i = 1;
          for (; i < length; i += 2) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        }),
        'lt': createPositionalPseudo(function (matchIndexes, length, argument) {
          var i = argument < 0 ? argument + length : argument;
          for (; --i >= 0;) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        }),
        'gt': createPositionalPseudo(function (matchIndexes, length, argument) {
          var i = argument < 0 ? argument + length : argument;
          for (; ++i < length;) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        })
      }
    };
    Expr.pseudos['nth'] = Expr.pseudos['eq'];
    for (i in {
        radio: true,
        checkbox: true,
        file: true,
        password: true,
        image: true
      }) {
      Expr.pseudos[i] = createInputPseudo(i);
    }
    for (i in {
        submit: true,
        reset: true
      }) {
      Expr.pseudos[i] = createButtonPseudo(i);
    }
    function setFilters() {
    }
    setFilters.prototype = Expr.filters = Expr.pseudos;
    Expr.setFilters = new setFilters();
    function tokenize(selector, parseOnly) {
      var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + ' '];
      if (cached) {
        return parseOnly ? 0 : cached.slice(0);
      }
      soFar = selector;
      groups = [];
      preFilters = Expr.preFilter;
      while (soFar) {
        if (!matched || (match = rcomma.exec(soFar))) {
          if (match) {
            soFar = soFar.slice(match[0].length) || soFar;
          }
          groups.push(tokens = []);
        }
        matched = false;
        if (match = rcombinators.exec(soFar)) {
          matched = match.shift();
          tokens.push({
            value: matched,
            type: match[0].replace(rtrim, ' ')
          });
          soFar = soFar.slice(matched.length);
        }
        for (type in Expr.filter) {
          if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
            matched = match.shift();
            tokens.push({
              value: matched,
              type: type,
              matches: match
            });
            soFar = soFar.slice(matched.length);
          }
        }
        if (!matched) {
          break;
        }
      }
      return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : tokenCache(selector, groups).slice(0);
    }
    function toSelector(tokens) {
      var i = 0, len = tokens.length, selector = '';
      for (; i < len; i++) {
        selector += tokens[i].value;
      }
      return selector;
    }
    function addCombinator(matcher, combinator, base) {
      var dir = combinator.dir, checkNonElements = base && dir === 'parentNode', doneName = done++;
      return combinator.first ? function (elem, context, xml) {
        while (elem = elem[dir]) {
          if (elem.nodeType === 1 || checkNonElements) {
            return matcher(elem, context, xml);
          }
        }
      } : function (elem, context, xml) {
        var data, cache, outerCache, dirkey = dirruns + ' ' + doneName;
        if (xml) {
          while (elem = elem[dir]) {
            if (elem.nodeType === 1 || checkNonElements) {
              if (matcher(elem, context, xml)) {
                return true;
              }
            }
          }
        } else {
          while (elem = elem[dir]) {
            if (elem.nodeType === 1 || checkNonElements) {
              outerCache = elem[expando] || (elem[expando] = {});
              if ((cache = outerCache[dir]) && cache[0] === dirkey) {
                if ((data = cache[1]) === true || data === cachedruns) {
                  return data === true;
                }
              } else {
                cache = outerCache[dir] = [dirkey];
                cache[1] = matcher(elem, context, xml) || cachedruns;
                if (cache[1] === true) {
                  return true;
                }
              }
            }
          }
        }
      };
    }
    function elementMatcher(matchers) {
      return matchers.length > 1 ? function (elem, context, xml) {
        var i = matchers.length;
        while (i--) {
          if (!matchers[i](elem, context, xml)) {
            return false;
          }
        }
        return true;
      } : matchers[0];
    }
    function condense(unmatched, map, filter, context, xml) {
      var elem, newUnmatched = [], i = 0, len = unmatched.length, mapped = map != null;
      for (; i < len; i++) {
        if (elem = unmatched[i]) {
          if (!filter || filter(elem, context, xml)) {
            newUnmatched.push(elem);
            if (mapped) {
              map.push(i);
            }
          }
        }
      }
      return newUnmatched;
    }
    function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
      if (postFilter && !postFilter[expando]) {
        postFilter = setMatcher(postFilter);
      }
      if (postFinder && !postFinder[expando]) {
        postFinder = setMatcher(postFinder, postSelector);
      }
      return markFunction(function (seed, results, context, xml) {
        var temp, i, elem, preMap = [], postMap = [], preexisting = results.length, elems = seed || multipleContexts(selector || '*', context.nodeType ? [context] : context, []), matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems, matcherOut = matcher ? postFinder || (seed ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;
        if (matcher) {
          matcher(matcherIn, matcherOut, context, xml);
        }
        if (postFilter) {
          temp = condense(matcherOut, postMap);
          postFilter(temp, [], context, xml);
          i = temp.length;
          while (i--) {
            if (elem = temp[i]) {
              matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
            }
          }
        }
        if (seed) {
          if (postFinder || preFilter) {
            if (postFinder) {
              temp = [];
              i = matcherOut.length;
              while (i--) {
                if (elem = matcherOut[i]) {
                  temp.push(matcherIn[i] = elem);
                }
              }
              postFinder(null, matcherOut = [], temp, xml);
            }
            i = matcherOut.length;
            while (i--) {
              if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf.call(seed, elem) : preMap[i]) > -1) {
                seed[temp] = !(results[temp] = elem);
              }
            }
          }
        } else {
          matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
          if (postFinder) {
            postFinder(null, results, matcherOut, xml);
          } else {
            push.apply(results, matcherOut);
          }
        }
      });
    }
    function matcherFromTokens(tokens) {
      var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[' '], i = leadingRelative ? 1 : 0, matchContext = addCombinator(function (elem) {
          return elem === checkContext;
        }, implicitRelative, true), matchAnyContext = addCombinator(function (elem) {
          return indexOf.call(checkContext, elem) > -1;
        }, implicitRelative, true), matchers = [function (elem, context, xml) {
            return !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
          }];
      for (; i < len; i++) {
        if (matcher = Expr.relative[tokens[i].type]) {
          matchers = [addCombinator(elementMatcher(matchers), matcher)];
        } else {
          matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);
          if (matcher[expando]) {
            j = ++i;
            for (; j < len; j++) {
              if (Expr.relative[tokens[j].type]) {
                break;
              }
            }
            return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(tokens.slice(0, i - 1).concat({ value: tokens[i - 2].type === ' ' ? '*' : '' })).replace(rtrim, '$1'), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
          }
          matchers.push(matcher);
        }
      }
      return elementMatcher(matchers);
    }
    function matcherFromGroupMatchers(elementMatchers, setMatchers) {
      var matcherCachedRuns = 0, bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function (seed, context, xml, results, expandContext) {
          var elem, j, matcher, setMatched = [], matchedCount = 0, i = '0', unmatched = seed && [], outermost = expandContext != null, contextBackup = outermostContext, elems = seed || byElement && Expr.find['TAG']('*', expandContext && context.parentNode || context), dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1;
          if (outermost) {
            outermostContext = context !== document && context;
            cachedruns = matcherCachedRuns;
          }
          for (; (elem = elems[i]) != null; i++) {
            if (byElement && elem) {
              j = 0;
              while (matcher = elementMatchers[j++]) {
                if (matcher(elem, context, xml)) {
                  results.push(elem);
                  break;
                }
              }
              if (outermost) {
                dirruns = dirrunsUnique;
                cachedruns = ++matcherCachedRuns;
              }
            }
            if (bySet) {
              if (elem = !matcher && elem) {
                matchedCount--;
              }
              if (seed) {
                unmatched.push(elem);
              }
            }
          }
          matchedCount += i;
          if (bySet && i !== matchedCount) {
            j = 0;
            while (matcher = setMatchers[j++]) {
              matcher(unmatched, setMatched, context, xml);
            }
            if (seed) {
              if (matchedCount > 0) {
                while (i--) {
                  if (!(unmatched[i] || setMatched[i])) {
                    setMatched[i] = pop.call(results);
                  }
                }
              }
              setMatched = condense(setMatched);
            }
            push.apply(results, setMatched);
            if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
              Sizzle.uniqueSort(results);
            }
          }
          if (outermost) {
            dirruns = dirrunsUnique;
            outermostContext = contextBackup;
          }
          return unmatched;
        };
      return bySet ? markFunction(superMatcher) : superMatcher;
    }
    compile = Sizzle.compile = function (selector, group) {
      var i, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + ' '];
      if (!cached) {
        if (!group) {
          group = tokenize(selector);
        }
        i = group.length;
        while (i--) {
          cached = matcherFromTokens(group[i]);
          if (cached[expando]) {
            setMatchers.push(cached);
          } else {
            elementMatchers.push(cached);
          }
        }
        cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
      }
      return cached;
    };
    function multipleContexts(selector, contexts, results) {
      var i = 0, len = contexts.length;
      for (; i < len; i++) {
        Sizzle(selector, contexts[i], results);
      }
      return results;
    }
    function select(selector, context, results, seed) {
      var i, tokens, token, type, find, match = tokenize(selector);
      if (!seed) {
        if (match.length === 1) {
          tokens = match[0] = match[0].slice(0);
          if (tokens.length > 2 && (token = tokens[0]).type === 'ID' && support.getById && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
            context = (Expr.find['ID'](token.matches[0].replace(runescape, funescape), context) || [])[0];
            if (!context) {
              return results;
            }
            selector = selector.slice(tokens.shift().value.length);
          }
          i = matchExpr['needsContext'].test(selector) ? 0 : tokens.length;
          while (i--) {
            token = tokens[i];
            if (Expr.relative[type = token.type]) {
              break;
            }
            if (find = Expr.find[type]) {
              if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && context.parentNode || context)) {
                tokens.splice(i, 1);
                selector = seed.length && toSelector(tokens);
                if (!selector) {
                  push.apply(results, seed);
                  return results;
                }
                break;
              }
            }
          }
        }
      }
      compile(selector, match)(seed, context, !documentIsHTML, results, rsibling.test(selector));
      return results;
    }
    support.sortStable = expando.split('').sort(sortOrder).join('') === expando;
    support.detectDuplicates = hasDuplicate;
    setDocument();
    support.sortDetached = assert(function (div1) {
      return div1.compareDocumentPosition(document.createElement('div')) & 1;
    });
    if (!assert(function (div) {
        div.innerHTML = '<a href=\'#\'></a>';
        return div.firstChild.getAttribute('href') === '#';
      })) {
      addHandle('type|href|height|width', function (elem, name, isXML) {
        if (!isXML) {
          return elem.getAttribute(name, name.toLowerCase() === 'type' ? 1 : 2);
        }
      });
    }
    if (!support.attributes || !assert(function (div) {
        div.innerHTML = '<input/>';
        div.firstChild.setAttribute('value', '');
        return div.firstChild.getAttribute('value') === '';
      })) {
      addHandle('value', function (elem, name, isXML) {
        if (!isXML && elem.nodeName.toLowerCase() === 'input') {
          return elem.defaultValue;
        }
      });
    }
    if (!assert(function (div) {
        return div.getAttribute('disabled') == null;
      })) {
      addHandle(booleans, function (elem, name, isXML) {
        var val;
        if (!isXML) {
          return (val = elem.getAttributeNode(name)) && val.specified ? val.value : elem[name] === true ? name.toLowerCase() : null;
        }
      });
    }
    jQuery.find = Sizzle;
    jQuery.expr = Sizzle.selectors;
    jQuery.expr[':'] = jQuery.expr.pseudos;
    jQuery.unique = Sizzle.uniqueSort;
    jQuery.text = Sizzle.getText;
    jQuery.isXMLDoc = Sizzle.isXML;
    jQuery.contains = Sizzle.contains;
  }(window));
  var optionsCache = {};
  function createOptions(options) {
    var object = optionsCache[options] = {};
    jQuery.each(options.match(core_rnotwhite) || [], function (_, flag) {
      object[flag] = true;
    });
    return object;
  }
  jQuery.Callbacks = function (options) {
    options = typeof options === 'string' ? optionsCache[options] || createOptions(options) : jQuery.extend({}, options);
    var memory, fired, firing, firingStart, firingLength, firingIndex, list = [], stack = !options.once && [], fire = function (data) {
        memory = options.memory && data;
        fired = true;
        firingIndex = firingStart || 0;
        firingStart = 0;
        firingLength = list.length;
        firing = true;
        for (; list && firingIndex < firingLength; firingIndex++) {
          if (list[firingIndex].apply(data[0], data[1]) === false && options.stopOnFalse) {
            memory = false;
            break;
          }
        }
        firing = false;
        if (list) {
          if (stack) {
            if (stack.length) {
              fire(stack.shift());
            }
          } else if (memory) {
            list = [];
          } else {
            self.disable();
          }
        }
      }, self = {
        add: function () {
          if (list) {
            var start = list.length;
            (function add(args) {
              jQuery.each(args, function (_, arg) {
                var type = jQuery.type(arg);
                if (type === 'function') {
                  if (!options.unique || !self.has(arg)) {
                    list.push(arg);
                  }
                } else if (arg && arg.length && type !== 'string') {
                  add(arg);
                }
              });
            }(arguments));
            if (firing) {
              firingLength = list.length;
            } else if (memory) {
              firingStart = start;
              fire(memory);
            }
          }
          return this;
        },
        remove: function () {
          if (list) {
            jQuery.each(arguments, function (_, arg) {
              var index;
              while ((index = jQuery.inArray(arg, list, index)) > -1) {
                list.splice(index, 1);
                if (firing) {
                  if (index <= firingLength) {
                    firingLength--;
                  }
                  if (index <= firingIndex) {
                    firingIndex--;
                  }
                }
              }
            });
          }
          return this;
        },
        has: function (fn) {
          return fn ? jQuery.inArray(fn, list) > -1 : !!(list && list.length);
        },
        empty: function () {
          list = [];
          firingLength = 0;
          return this;
        },
        disable: function () {
          list = stack = memory = undefined;
          return this;
        },
        disabled: function () {
          return !list;
        },
        lock: function () {
          stack = undefined;
          if (!memory) {
            self.disable();
          }
          return this;
        },
        locked: function () {
          return !stack;
        },
        fireWith: function (context, args) {
          if (list && (!fired || stack)) {
            args = args || [];
            args = [
              context,
              args.slice ? args.slice() : args
            ];
            if (firing) {
              stack.push(args);
            } else {
              fire(args);
            }
          }
          return this;
        },
        fire: function () {
          self.fireWith(this, arguments);
          return this;
        },
        fired: function () {
          return !!fired;
        }
      };
    return self;
  };
  jQuery.extend({
    Deferred: function (func) {
      var tuples = [
          [
            'resolve',
            'done',
            jQuery.Callbacks('once memory'),
            'resolved'
          ],
          [
            'reject',
            'fail',
            jQuery.Callbacks('once memory'),
            'rejected'
          ],
          [
            'notify',
            'progress',
            jQuery.Callbacks('memory')
          ]
        ], state = 'pending', promise = {
          state: function () {
            return state;
          },
          always: function () {
            deferred.done(arguments).fail(arguments);
            return this;
          },
          then: function () {
            var fns = arguments;
            return jQuery.Deferred(function (newDefer) {
              jQuery.each(tuples, function (i, tuple) {
                var action = tuple[0], fn = jQuery.isFunction(fns[i]) && fns[i];
                deferred[tuple[1]](function () {
                  var returned = fn && fn.apply(this, arguments);
                  if (returned && jQuery.isFunction(returned.promise)) {
                    returned.promise().done(newDefer.resolve).fail(newDefer.reject).progress(newDefer.notify);
                  } else {
                    newDefer[action + 'With'](this === promise ? newDefer.promise() : this, fn ? [returned] : arguments);
                  }
                });
              });
              fns = null;
            }).promise();
          },
          promise: function (obj) {
            return obj != null ? jQuery.extend(obj, promise) : promise;
          }
        }, deferred = {};
      promise.pipe = promise.then;
      jQuery.each(tuples, function (i, tuple) {
        var list = tuple[2], stateString = tuple[3];
        promise[tuple[1]] = list.add;
        if (stateString) {
          list.add(function () {
            state = stateString;
          }, tuples[i ^ 1][2].disable, tuples[2][2].lock);
        }
        deferred[tuple[0]] = function () {
          deferred[tuple[0] + 'With'](this === deferred ? promise : this, arguments);
          return this;
        };
        deferred[tuple[0] + 'With'] = list.fireWith;
      });
      promise.promise(deferred);
      if (func) {
        func.call(deferred, deferred);
      }
      return deferred;
    },
    when: function (subordinate) {
      var i = 0, resolveValues = core_slice.call(arguments), length = resolveValues.length, remaining = length !== 1 || subordinate && jQuery.isFunction(subordinate.promise) ? length : 0, deferred = remaining === 1 ? subordinate : jQuery.Deferred(), updateFunc = function (i, contexts, values) {
          return function (value) {
            contexts[i] = this;
            values[i] = arguments.length > 1 ? core_slice.call(arguments) : value;
            if (values === progressValues) {
              deferred.notifyWith(contexts, values);
            } else if (!--remaining) {
              deferred.resolveWith(contexts, values);
            }
          };
        }, progressValues, progressContexts, resolveContexts;
      if (length > 1) {
        progressValues = new Array(length);
        progressContexts = new Array(length);
        resolveContexts = new Array(length);
        for (; i < length; i++) {
          if (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {
            resolveValues[i].promise().done(updateFunc(i, resolveContexts, resolveValues)).fail(deferred.reject).progress(updateFunc(i, progressContexts, progressValues));
          } else {
            --remaining;
          }
        }
      }
      if (!remaining) {
        deferred.resolveWith(resolveContexts, resolveValues);
      }
      return deferred.promise();
    }
  });
  jQuery.support = function (support) {
    var input = document.createElement('input'), fragment = document.createDocumentFragment(), div = document.createElement('div'), select = document.createElement('select'), opt = select.appendChild(document.createElement('option'));
    if (!input.type) {
      return support;
    }
    input.type = 'checkbox';
    support.checkOn = input.value !== '';
    support.optSelected = opt.selected;
    support.reliableMarginRight = true;
    support.boxSizingReliable = true;
    support.pixelPosition = false;
    input.checked = true;
    support.noCloneChecked = input.cloneNode(true).checked;
    select.disabled = true;
    support.optDisabled = !opt.disabled;
    input = document.createElement('input');
    input.value = 't';
    input.type = 'radio';
    support.radioValue = input.value === 't';
    input.setAttribute('checked', 't');
    input.setAttribute('name', 't');
    fragment.appendChild(input);
    support.checkClone = fragment.cloneNode(true).cloneNode(true).lastChild.checked;
    support.focusinBubbles = 'onfocusin' in window;
    div.style.backgroundClip = 'content-box';
    div.cloneNode(true).style.backgroundClip = '';
    support.clearCloneStyle = div.style.backgroundClip === 'content-box';
    jQuery(function () {
      var container, marginDiv, divReset = 'padding:0;margin:0;border:0;display:block;-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box', body = document.getElementsByTagName('body')[0];
      if (!body) {
        return;
      }
      container = document.createElement('div');
      container.style.cssText = 'border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px';
      body.appendChild(container).appendChild(div);
      div.innerHTML = '';
      div.style.cssText = '-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%';
      jQuery.swap(body, body.style.zoom != null ? { zoom: 1 } : {}, function () {
        support.boxSizing = div.offsetWidth === 4;
      });
      if (window.getComputedStyle) {
        support.pixelPosition = (window.getComputedStyle(div, null) || {}).top !== '1%';
        support.boxSizingReliable = (window.getComputedStyle(div, null) || { width: '4px' }).width === '4px';
        marginDiv = div.appendChild(document.createElement('div'));
        marginDiv.style.cssText = div.style.cssText = divReset;
        marginDiv.style.marginRight = marginDiv.style.width = '0';
        div.style.width = '1px';
        support.reliableMarginRight = !parseFloat((window.getComputedStyle(marginDiv, null) || {}).marginRight);
      }
      body.removeChild(container);
    });
    return support;
  }({});
  var data_user, data_priv, rbrace = /(?:\{[\s\S]*\}|\[[\s\S]*\])$/, rmultiDash = /([A-Z])/g;
  function Data() {
    Object.defineProperty(this.cache = {}, 0, {
      get: function () {
        return {};
      }
    });
    this.expando = jQuery.expando + Math.random();
  }
  Data.uid = 1;
  Data.accepts = function (owner) {
    return owner.nodeType ? owner.nodeType === 1 || owner.nodeType === 9 : true;
  };
  Data.prototype = {
    key: function (owner) {
      if (!Data.accepts(owner)) {
        return 0;
      }
      var descriptor = {}, unlock = owner[this.expando];
      if (!unlock) {
        unlock = Data.uid++;
        try {
          descriptor[this.expando] = { value: unlock };
          Object.defineProperties(owner, descriptor);
        } catch (e) {
          descriptor[this.expando] = unlock;
          jQuery.extend(owner, descriptor);
        }
      }
      if (!this.cache[unlock]) {
        this.cache[unlock] = {};
      }
      return unlock;
    },
    set: function (owner, data, value) {
      var prop, unlock = this.key(owner), cache = this.cache[unlock];
      if (typeof data === 'string') {
        cache[data] = value;
      } else {
        if (jQuery.isEmptyObject(cache)) {
          jQuery.extend(this.cache[unlock], data);
        } else {
          for (prop in data) {
            cache[prop] = data[prop];
          }
        }
      }
      return cache;
    },
    get: function (owner, key) {
      var cache = this.cache[this.key(owner)];
      return key === undefined ? cache : cache[key];
    },
    access: function (owner, key, value) {
      var stored;
      if (key === undefined || key && typeof key === 'string' && value === undefined) {
        stored = this.get(owner, key);
        return stored !== undefined ? stored : this.get(owner, jQuery.camelCase(key));
      }
      this.set(owner, key, value);
      return value !== undefined ? value : key;
    },
    remove: function (owner, key) {
      var i, name, camel, unlock = this.key(owner), cache = this.cache[unlock];
      if (key === undefined) {
        this.cache[unlock] = {};
      } else {
        if (jQuery.isArray(key)) {
          name = key.concat(key.map(jQuery.camelCase));
        } else {
          camel = jQuery.camelCase(key);
          if (key in cache) {
            name = [
              key,
              camel
            ];
          } else {
            name = camel;
            name = name in cache ? [name] : name.match(core_rnotwhite) || [];
          }
        }
        i = name.length;
        while (i--) {
          delete cache[name[i]];
        }
      }
    },
    hasData: function (owner) {
      return !jQuery.isEmptyObject(this.cache[owner[this.expando]] || {});
    },
    discard: function (owner) {
      if (owner[this.expando]) {
        delete this.cache[owner[this.expando]];
      }
    }
  };
  data_user = new Data();
  data_priv = new Data();
  jQuery.extend({
    acceptData: Data.accepts,
    hasData: function (elem) {
      return data_user.hasData(elem) || data_priv.hasData(elem);
    },
    data: function (elem, name, data) {
      return data_user.access(elem, name, data);
    },
    removeData: function (elem, name) {
      data_user.remove(elem, name);
    },
    _data: function (elem, name, data) {
      return data_priv.access(elem, name, data);
    },
    _removeData: function (elem, name) {
      data_priv.remove(elem, name);
    }
  });
  jQuery.fn.extend({
    data: function (key, value) {
      var attrs, name, elem = this[0], i = 0, data = null;
      if (key === undefined) {
        if (this.length) {
          data = data_user.get(elem);
          if (elem.nodeType === 1 && !data_priv.get(elem, 'hasDataAttrs')) {
            attrs = elem.attributes;
            for (; i < attrs.length; i++) {
              name = attrs[i].name;
              if (name.indexOf('data-') === 0) {
                name = jQuery.camelCase(name.slice(5));
                dataAttr(elem, name, data[name]);
              }
            }
            data_priv.set(elem, 'hasDataAttrs', true);
          }
        }
        return data;
      }
      if (typeof key === 'object') {
        return this.each(function () {
          data_user.set(this, key);
        });
      }
      return jQuery.access(this, function (value) {
        var data, camelKey = jQuery.camelCase(key);
        if (elem && value === undefined) {
          data = data_user.get(elem, key);
          if (data !== undefined) {
            return data;
          }
          data = data_user.get(elem, camelKey);
          if (data !== undefined) {
            return data;
          }
          data = dataAttr(elem, camelKey, undefined);
          if (data !== undefined) {
            return data;
          }
          return;
        }
        this.each(function () {
          var data = data_user.get(this, camelKey);
          data_user.set(this, camelKey, value);
          if (key.indexOf('-') !== -1 && data !== undefined) {
            data_user.set(this, key, value);
          }
        });
      }, null, value, arguments.length > 1, null, true);
    },
    removeData: function (key) {
      return this.each(function () {
        data_user.remove(this, key);
      });
    }
  });
  function dataAttr(elem, key, data) {
    var name;
    if (data === undefined && elem.nodeType === 1) {
      name = 'data-' + key.replace(rmultiDash, '-$1').toLowerCase();
      data = elem.getAttribute(name);
      if (typeof data === 'string') {
        try {
          data = data === 'true' ? true : data === 'false' ? false : data === 'null' ? null : +data + '' === data ? +data : rbrace.test(data) ? JSON.parse(data) : data;
        } catch (e) {
        }
        data_user.set(elem, key, data);
      } else {
        data = undefined;
      }
    }
    return data;
  }
  jQuery.extend({
    queue: function (elem, type, data) {
      var queue;
      if (elem) {
        type = (type || 'fx') + 'queue';
        queue = data_priv.get(elem, type);
        if (data) {
          if (!queue || jQuery.isArray(data)) {
            queue = data_priv.access(elem, type, jQuery.makeArray(data));
          } else {
            queue.push(data);
          }
        }
        return queue || [];
      }
    },
    dequeue: function (elem, type) {
      type = type || 'fx';
      var queue = jQuery.queue(elem, type), startLength = queue.length, fn = queue.shift(), hooks = jQuery._queueHooks(elem, type), next = function () {
          jQuery.dequeue(elem, type);
        };
      if (fn === 'inprogress') {
        fn = queue.shift();
        startLength--;
      }
      if (fn) {
        if (type === 'fx') {
          queue.unshift('inprogress');
        }
        delete hooks.stop;
        fn.call(elem, next, hooks);
      }
      if (!startLength && hooks) {
        hooks.empty.fire();
      }
    },
    _queueHooks: function (elem, type) {
      var key = type + 'queueHooks';
      return data_priv.get(elem, key) || data_priv.access(elem, key, {
        empty: jQuery.Callbacks('once memory').add(function () {
          data_priv.remove(elem, [
            type + 'queue',
            key
          ]);
        })
      });
    }
  });
  jQuery.fn.extend({
    queue: function (type, data) {
      var setter = 2;
      if (typeof type !== 'string') {
        data = type;
        type = 'fx';
        setter--;
      }
      if (arguments.length < setter) {
        return jQuery.queue(this[0], type);
      }
      return data === undefined ? this : this.each(function () {
        var queue = jQuery.queue(this, type, data);
        jQuery._queueHooks(this, type);
        if (type === 'fx' && queue[0] !== 'inprogress') {
          jQuery.dequeue(this, type);
        }
      });
    },
    dequeue: function (type) {
      return this.each(function () {
        jQuery.dequeue(this, type);
      });
    },
    delay: function (time, type) {
      time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
      type = type || 'fx';
      return this.queue(type, function (next, hooks) {
        var timeout = setTimeout(next, time);
        hooks.stop = function () {
          clearTimeout(timeout);
        };
      });
    },
    clearQueue: function (type) {
      return this.queue(type || 'fx', []);
    },
    promise: function (type, obj) {
      var tmp, count = 1, defer = jQuery.Deferred(), elements = this, i = this.length, resolve = function () {
          if (!--count) {
            defer.resolveWith(elements, [elements]);
          }
        };
      if (typeof type !== 'string') {
        obj = type;
        type = undefined;
      }
      type = type || 'fx';
      while (i--) {
        tmp = data_priv.get(elements[i], type + 'queueHooks');
        if (tmp && tmp.empty) {
          count++;
          tmp.empty.add(resolve);
        }
      }
      resolve();
      return defer.promise(obj);
    }
  });
  var nodeHook, boolHook, rclass = /[\t\r\n\f]/g, rreturn = /\r/g, rfocusable = /^(?:input|select|textarea|button)$/i;
  jQuery.fn.extend({
    attr: function (name, value) {
      return jQuery.access(this, jQuery.attr, name, value, arguments.length > 1);
    },
    removeAttr: function (name) {
      return this.each(function () {
        jQuery.removeAttr(this, name);
      });
    },
    prop: function (name, value) {
      return jQuery.access(this, jQuery.prop, name, value, arguments.length > 1);
    },
    removeProp: function (name) {
      return this.each(function () {
        delete this[jQuery.propFix[name] || name];
      });
    },
    addClass: function (value) {
      var classes, elem, cur, clazz, j, i = 0, len = this.length, proceed = typeof value === 'string' && value;
      if (jQuery.isFunction(value)) {
        return this.each(function (j) {
          jQuery(this).addClass(value.call(this, j, this.className));
        });
      }
      if (proceed) {
        classes = (value || '').match(core_rnotwhite) || [];
        for (; i < len; i++) {
          elem = this[i];
          cur = elem.nodeType === 1 && (elem.className ? (' ' + elem.className + ' ').replace(rclass, ' ') : ' ');
          if (cur) {
            j = 0;
            while (clazz = classes[j++]) {
              if (cur.indexOf(' ' + clazz + ' ') < 0) {
                cur += clazz + ' ';
              }
            }
            elem.className = jQuery.trim(cur);
          }
        }
      }
      return this;
    },
    removeClass: function (value) {
      var classes, elem, cur, clazz, j, i = 0, len = this.length, proceed = arguments.length === 0 || typeof value === 'string' && value;
      if (jQuery.isFunction(value)) {
        return this.each(function (j) {
          jQuery(this).removeClass(value.call(this, j, this.className));
        });
      }
      if (proceed) {
        classes = (value || '').match(core_rnotwhite) || [];
        for (; i < len; i++) {
          elem = this[i];
          cur = elem.nodeType === 1 && (elem.className ? (' ' + elem.className + ' ').replace(rclass, ' ') : '');
          if (cur) {
            j = 0;
            while (clazz = classes[j++]) {
              while (cur.indexOf(' ' + clazz + ' ') >= 0) {
                cur = cur.replace(' ' + clazz + ' ', ' ');
              }
            }
            elem.className = value ? jQuery.trim(cur) : '';
          }
        }
      }
      return this;
    },
    toggleClass: function (value, stateVal) {
      var type = typeof value;
      if (typeof stateVal === 'boolean' && type === 'string') {
        return stateVal ? this.addClass(value) : this.removeClass(value);
      }
      if (jQuery.isFunction(value)) {
        return this.each(function (i) {
          jQuery(this).toggleClass(value.call(this, i, this.className, stateVal), stateVal);
        });
      }
      return this.each(function () {
        if (type === 'string') {
          var className, i = 0, self = jQuery(this), classNames = value.match(core_rnotwhite) || [];
          while (className = classNames[i++]) {
            if (self.hasClass(className)) {
              self.removeClass(className);
            } else {
              self.addClass(className);
            }
          }
        } else if (type === core_strundefined || type === 'boolean') {
          if (this.className) {
            data_priv.set(this, '__className__', this.className);
          }
          this.className = this.className || value === false ? '' : data_priv.get(this, '__className__') || '';
        }
      });
    },
    hasClass: function (selector) {
      var className = ' ' + selector + ' ', i = 0, l = this.length;
      for (; i < l; i++) {
        if (this[i].nodeType === 1 && (' ' + this[i].className + ' ').replace(rclass, ' ').indexOf(className) >= 0) {
          return true;
        }
      }
      return false;
    },
    val: function (value) {
      var hooks, ret, isFunction, elem = this[0];
      if (!arguments.length) {
        if (elem) {
          hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];
          if (hooks && 'get' in hooks && (ret = hooks.get(elem, 'value')) !== undefined) {
            return ret;
          }
          ret = elem.value;
          return typeof ret === 'string' ? ret.replace(rreturn, '') : ret == null ? '' : ret;
        }
        return;
      }
      isFunction = jQuery.isFunction(value);
      return this.each(function (i) {
        var val;
        if (this.nodeType !== 1) {
          return;
        }
        if (isFunction) {
          val = value.call(this, i, jQuery(this).val());
        } else {
          val = value;
        }
        if (val == null) {
          val = '';
        } else if (typeof val === 'number') {
          val += '';
        } else if (jQuery.isArray(val)) {
          val = jQuery.map(val, function (value) {
            return value == null ? '' : value + '';
          });
        }
        hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];
        if (!hooks || !('set' in hooks) || hooks.set(this, val, 'value') === undefined) {
          this.value = val;
        }
      });
    }
  });
  jQuery.extend({
    valHooks: {
      option: {
        get: function (elem) {
          var val = elem.attributes.value;
          return !val || val.specified ? elem.value : elem.text;
        }
      },
      select: {
        get: function (elem) {
          var value, option, options = elem.options, index = elem.selectedIndex, one = elem.type === 'select-one' || index < 0, values = one ? null : [], max = one ? index + 1 : options.length, i = index < 0 ? max : one ? index : 0;
          for (; i < max; i++) {
            option = options[i];
            if ((option.selected || i === index) && (jQuery.support.optDisabled ? !option.disabled : option.getAttribute('disabled') === null) && (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, 'optgroup'))) {
              value = jQuery(option).val();
              if (one) {
                return value;
              }
              values.push(value);
            }
          }
          return values;
        },
        set: function (elem, value) {
          var optionSet, option, options = elem.options, values = jQuery.makeArray(value), i = options.length;
          while (i--) {
            option = options[i];
            if (option.selected = jQuery.inArray(jQuery(option).val(), values) >= 0) {
              optionSet = true;
            }
          }
          if (!optionSet) {
            elem.selectedIndex = -1;
          }
          return values;
        }
      }
    },
    attr: function (elem, name, value) {
      var hooks, ret, nType = elem.nodeType;
      if (!elem || nType === 3 || nType === 8 || nType === 2) {
        return;
      }
      if (typeof elem.getAttribute === core_strundefined) {
        return jQuery.prop(elem, name, value);
      }
      if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
        name = name.toLowerCase();
        hooks = jQuery.attrHooks[name] || (jQuery.expr.match.bool.test(name) ? boolHook : nodeHook);
      }
      if (value !== undefined) {
        if (value === null) {
          jQuery.removeAttr(elem, name);
        } else if (hooks && 'set' in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
          return ret;
        } else {
          elem.setAttribute(name, value + '');
          return value;
        }
      } else if (hooks && 'get' in hooks && (ret = hooks.get(elem, name)) !== null) {
        return ret;
      } else {
        ret = jQuery.find.attr(elem, name);
        return ret == null ? undefined : ret;
      }
    },
    removeAttr: function (elem, value) {
      var name, propName, i = 0, attrNames = value && value.match(core_rnotwhite);
      if (attrNames && elem.nodeType === 1) {
        while (name = attrNames[i++]) {
          propName = jQuery.propFix[name] || name;
          if (jQuery.expr.match.bool.test(name)) {
            elem[propName] = false;
          }
          elem.removeAttribute(name);
        }
      }
    },
    attrHooks: {
      type: {
        set: function (elem, value) {
          if (!jQuery.support.radioValue && value === 'radio' && jQuery.nodeName(elem, 'input')) {
            var val = elem.value;
            elem.setAttribute('type', value);
            if (val) {
              elem.value = val;
            }
            return value;
          }
        }
      }
    },
    propFix: {
      'for': 'htmlFor',
      'class': 'className'
    },
    prop: function (elem, name, value) {
      var ret, hooks, notxml, nType = elem.nodeType;
      if (!elem || nType === 3 || nType === 8 || nType === 2) {
        return;
      }
      notxml = nType !== 1 || !jQuery.isXMLDoc(elem);
      if (notxml) {
        name = jQuery.propFix[name] || name;
        hooks = jQuery.propHooks[name];
      }
      if (value !== undefined) {
        return hooks && 'set' in hooks && (ret = hooks.set(elem, value, name)) !== undefined ? ret : elem[name] = value;
      } else {
        return hooks && 'get' in hooks && (ret = hooks.get(elem, name)) !== null ? ret : elem[name];
      }
    },
    propHooks: {
      tabIndex: {
        get: function (elem) {
          return elem.hasAttribute('tabindex') || rfocusable.test(elem.nodeName) || elem.href ? elem.tabIndex : -1;
        }
      }
    }
  });
  boolHook = {
    set: function (elem, value, name) {
      if (value === false) {
        jQuery.removeAttr(elem, name);
      } else {
        elem.setAttribute(name, name);
      }
      return name;
    }
  };
  jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function (i, name) {
    var getter = jQuery.expr.attrHandle[name] || jQuery.find.attr;
    jQuery.expr.attrHandle[name] = function (elem, name, isXML) {
      var fn = jQuery.expr.attrHandle[name], ret = isXML ? undefined : (jQuery.expr.attrHandle[name] = undefined) != getter(elem, name, isXML) ? name.toLowerCase() : null;
      jQuery.expr.attrHandle[name] = fn;
      return ret;
    };
  });
  if (!jQuery.support.optSelected) {
    jQuery.propHooks.selected = {
      get: function (elem) {
        var parent = elem.parentNode;
        if (parent && parent.parentNode) {
          parent.parentNode.selectedIndex;
        }
        return null;
      }
    };
  }
  jQuery.each([
    'tabIndex',
    'readOnly',
    'maxLength',
    'cellSpacing',
    'cellPadding',
    'rowSpan',
    'colSpan',
    'useMap',
    'frameBorder',
    'contentEditable'
  ], function () {
    jQuery.propFix[this.toLowerCase()] = this;
  });
  jQuery.each([
    'radio',
    'checkbox'
  ], function () {
    jQuery.valHooks[this] = {
      set: function (elem, value) {
        if (jQuery.isArray(value)) {
          return elem.checked = jQuery.inArray(jQuery(elem).val(), value) >= 0;
        }
      }
    };
    if (!jQuery.support.checkOn) {
      jQuery.valHooks[this].get = function (elem) {
        return elem.getAttribute('value') === null ? 'on' : elem.value;
      };
    }
  });
  var rkeyEvent = /^key/, rmouseEvent = /^(?:mouse|contextmenu)|click/, rfocusMorph = /^(?:focusinfocus|focusoutblur)$/, rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;
  function returnTrue() {
    return true;
  }
  function returnFalse() {
    return false;
  }
  function safeActiveElement() {
    try {
      return document.activeElement;
    } catch (err) {
    }
  }
  jQuery.event = {
    global: {},
    add: function (elem, types, handler, data, selector) {
      var handleObjIn, eventHandle, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = data_priv.get(elem);
      if (!elemData) {
        return;
      }
      if (handler.handler) {
        handleObjIn = handler;
        handler = handleObjIn.handler;
        selector = handleObjIn.selector;
      }
      if (!handler.guid) {
        handler.guid = jQuery.guid++;
      }
      if (!(events = elemData.events)) {
        events = elemData.events = {};
      }
      if (!(eventHandle = elemData.handle)) {
        eventHandle = elemData.handle = function (e) {
          return typeof jQuery !== core_strundefined && (!e || jQuery.event.triggered !== e.type) ? jQuery.event.dispatch.apply(eventHandle.elem, arguments) : undefined;
        };
        eventHandle.elem = elem;
      }
      types = (types || '').match(core_rnotwhite) || [''];
      t = types.length;
      while (t--) {
        tmp = rtypenamespace.exec(types[t]) || [];
        type = origType = tmp[1];
        namespaces = (tmp[2] || '').split('.').sort();
        if (!type) {
          continue;
        }
        special = jQuery.event.special[type] || {};
        type = (selector ? special.delegateType : special.bindType) || type;
        special = jQuery.event.special[type] || {};
        handleObj = jQuery.extend({
          type: type,
          origType: origType,
          data: data,
          handler: handler,
          guid: handler.guid,
          selector: selector,
          needsContext: selector && jQuery.expr.match.needsContext.test(selector),
          namespace: namespaces.join('.')
        }, handleObjIn);
        if (!(handlers = events[type])) {
          handlers = events[type] = [];
          handlers.delegateCount = 0;
          if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
            if (elem.addEventListener) {
              elem.addEventListener(type, eventHandle, false);
            }
          }
        }
        if (special.add) {
          special.add.call(elem, handleObj);
          if (!handleObj.handler.guid) {
            handleObj.handler.guid = handler.guid;
          }
        }
        if (selector) {
          handlers.splice(handlers.delegateCount++, 0, handleObj);
        } else {
          handlers.push(handleObj);
        }
        jQuery.event.global[type] = true;
      }
      elem = null;
    },
    remove: function (elem, types, handler, selector, mappedTypes) {
      var j, origCount, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = data_priv.hasData(elem) && data_priv.get(elem);
      if (!elemData || !(events = elemData.events)) {
        return;
      }
      types = (types || '').match(core_rnotwhite) || [''];
      t = types.length;
      while (t--) {
        tmp = rtypenamespace.exec(types[t]) || [];
        type = origType = tmp[1];
        namespaces = (tmp[2] || '').split('.').sort();
        if (!type) {
          for (type in events) {
            jQuery.event.remove(elem, type + types[t], handler, selector, true);
          }
          continue;
        }
        special = jQuery.event.special[type] || {};
        type = (selector ? special.delegateType : special.bindType) || type;
        handlers = events[type] || [];
        tmp = tmp[2] && new RegExp('(^|\\.)' + namespaces.join('\\.(?:.*\\.|)') + '(\\.|$)');
        origCount = j = handlers.length;
        while (j--) {
          handleObj = handlers[j];
          if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === '**' && handleObj.selector)) {
            handlers.splice(j, 1);
            if (handleObj.selector) {
              handlers.delegateCount--;
            }
            if (special.remove) {
              special.remove.call(elem, handleObj);
            }
          }
        }
        if (origCount && !handlers.length) {
          if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
            jQuery.removeEvent(elem, type, elemData.handle);
          }
          delete events[type];
        }
      }
      if (jQuery.isEmptyObject(events)) {
        delete elemData.handle;
        data_priv.remove(elem, 'events');
      }
    },
    trigger: function (event, data, elem, onlyHandlers) {
      var i, cur, tmp, bubbleType, ontype, handle, special, eventPath = [elem || document], type = core_hasOwn.call(event, 'type') ? event.type : event, namespaces = core_hasOwn.call(event, 'namespace') ? event.namespace.split('.') : [];
      cur = tmp = elem = elem || document;
      if (elem.nodeType === 3 || elem.nodeType === 8) {
        return;
      }
      if (rfocusMorph.test(type + jQuery.event.triggered)) {
        return;
      }
      if (type.indexOf('.') >= 0) {
        namespaces = type.split('.');
        type = namespaces.shift();
        namespaces.sort();
      }
      ontype = type.indexOf(':') < 0 && 'on' + type;
      event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === 'object' && event);
      event.isTrigger = onlyHandlers ? 2 : 3;
      event.namespace = namespaces.join('.');
      event.namespace_re = event.namespace ? new RegExp('(^|\\.)' + namespaces.join('\\.(?:.*\\.|)') + '(\\.|$)') : null;
      event.result = undefined;
      if (!event.target) {
        event.target = elem;
      }
      data = data == null ? [event] : jQuery.makeArray(data, [event]);
      special = jQuery.event.special[type] || {};
      if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
        return;
      }
      if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {
        bubbleType = special.delegateType || type;
        if (!rfocusMorph.test(bubbleType + type)) {
          cur = cur.parentNode;
        }
        for (; cur; cur = cur.parentNode) {
          eventPath.push(cur);
          tmp = cur;
        }
        if (tmp === (elem.ownerDocument || document)) {
          eventPath.push(tmp.defaultView || tmp.parentWindow || window);
        }
      }
      i = 0;
      while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
        event.type = i > 1 ? bubbleType : special.bindType || type;
        handle = (data_priv.get(cur, 'events') || {})[event.type] && data_priv.get(cur, 'handle');
        if (handle) {
          handle.apply(cur, data);
        }
        handle = ontype && cur[ontype];
        if (handle && jQuery.acceptData(cur) && handle.apply && handle.apply(cur, data) === false) {
          event.preventDefault();
        }
      }
      event.type = type;
      if (!onlyHandlers && !event.isDefaultPrevented()) {
        if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && jQuery.acceptData(elem)) {
          if (ontype && jQuery.isFunction(elem[type]) && !jQuery.isWindow(elem)) {
            tmp = elem[ontype];
            if (tmp) {
              elem[ontype] = null;
            }
            jQuery.event.triggered = type;
            elem[type]();
            jQuery.event.triggered = undefined;
            if (tmp) {
              elem[ontype] = tmp;
            }
          }
        }
      }
      return event.result;
    },
    dispatch: function (event) {
      event = jQuery.event.fix(event);
      var i, j, ret, matched, handleObj, handlerQueue = [], args = core_slice.call(arguments), handlers = (data_priv.get(this, 'events') || {})[event.type] || [], special = jQuery.event.special[event.type] || {};
      args[0] = event;
      event.delegateTarget = this;
      if (special.preDispatch && special.preDispatch.call(this, event) === false) {
        return;
      }
      handlerQueue = jQuery.event.handlers.call(this, event, handlers);
      i = 0;
      while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
        event.currentTarget = matched.elem;
        j = 0;
        while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
          if (!event.namespace_re || event.namespace_re.test(handleObj.namespace)) {
            event.handleObj = handleObj;
            event.data = handleObj.data;
            ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
            if (ret !== undefined) {
              if ((event.result = ret) === false) {
                event.preventDefault();
                event.stopPropagation();
              }
            }
          }
        }
      }
      if (special.postDispatch) {
        special.postDispatch.call(this, event);
      }
      return event.result;
    },
    handlers: function (event, handlers) {
      var i, matches, sel, handleObj, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event.target;
      if (delegateCount && cur.nodeType && (!event.button || event.type !== 'click')) {
        for (; cur !== this; cur = cur.parentNode || this) {
          if (cur.disabled !== true || event.type !== 'click') {
            matches = [];
            for (i = 0; i < delegateCount; i++) {
              handleObj = handlers[i];
              sel = handleObj.selector + ' ';
              if (matches[sel] === undefined) {
                matches[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) >= 0 : jQuery.find(sel, this, null, [cur]).length;
              }
              if (matches[sel]) {
                matches.push(handleObj);
              }
            }
            if (matches.length) {
              handlerQueue.push({
                elem: cur,
                handlers: matches
              });
            }
          }
        }
      }
      if (delegateCount < handlers.length) {
        handlerQueue.push({
          elem: this,
          handlers: handlers.slice(delegateCount)
        });
      }
      return handlerQueue;
    },
    props: 'altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which'.split(' '),
    fixHooks: {},
    keyHooks: {
      props: 'char charCode key keyCode'.split(' '),
      filter: function (event, original) {
        if (event.which == null) {
          event.which = original.charCode != null ? original.charCode : original.keyCode;
        }
        return event;
      }
    },
    mouseHooks: {
      props: 'button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement'.split(' '),
      filter: function (event, original) {
        var eventDoc, doc, body, button = original.button;
        if (event.pageX == null && original.clientX != null) {
          eventDoc = event.target.ownerDocument || document;
          doc = eventDoc.documentElement;
          body = eventDoc.body;
          event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
          event.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
        }
        if (!event.which && button !== undefined) {
          event.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;
        }
        return event;
      }
    },
    fix: function (event) {
      if (event[jQuery.expando]) {
        return event;
      }
      var i, prop, copy, type = event.type, originalEvent = event, fixHook = this.fixHooks[type];
      if (!fixHook) {
        this.fixHooks[type] = fixHook = rmouseEvent.test(type) ? this.mouseHooks : rkeyEvent.test(type) ? this.keyHooks : {};
      }
      copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;
      event = new jQuery.Event(originalEvent);
      i = copy.length;
      while (i--) {
        prop = copy[i];
        event[prop] = originalEvent[prop];
      }
      if (!event.target) {
        event.target = document;
      }
      if (event.target.nodeType === 3) {
        event.target = event.target.parentNode;
      }
      return fixHook.filter ? fixHook.filter(event, originalEvent) : event;
    },
    special: {
      load: { noBubble: true },
      focus: {
        trigger: function () {
          if (this !== safeActiveElement() && this.focus) {
            this.focus();
            return false;
          }
        },
        delegateType: 'focusin'
      },
      blur: {
        trigger: function () {
          if (this === safeActiveElement() && this.blur) {
            this.blur();
            return false;
          }
        },
        delegateType: 'focusout'
      },
      click: {
        trigger: function () {
          if (this.type === 'checkbox' && this.click && jQuery.nodeName(this, 'input')) {
            this.click();
            return false;
          }
        },
        _default: function (event) {
          return jQuery.nodeName(event.target, 'a');
        }
      },
      beforeunload: {
        postDispatch: function (event) {
          if (event.result !== undefined) {
            event.originalEvent.returnValue = event.result;
          }
        }
      }
    },
    simulate: function (type, elem, event, bubble) {
      var e = jQuery.extend(new jQuery.Event(), event, {
          type: type,
          isSimulated: true,
          originalEvent: {}
        });
      if (bubble) {
        jQuery.event.trigger(e, null, elem);
      } else {
        jQuery.event.dispatch.call(elem, e);
      }
      if (e.isDefaultPrevented()) {
        event.preventDefault();
      }
    }
  };
  jQuery.removeEvent = function (elem, type, handle) {
    if (elem.removeEventListener) {
      elem.removeEventListener(type, handle, false);
    }
  };
  jQuery.Event = function (src, props) {
    if (!(this instanceof jQuery.Event)) {
      return new jQuery.Event(src, props);
    }
    if (src && src.type) {
      this.originalEvent = src;
      this.type = src.type;
      this.isDefaultPrevented = src.defaultPrevented || src.getPreventDefault && src.getPreventDefault() ? returnTrue : returnFalse;
    } else {
      this.type = src;
    }
    if (props) {
      jQuery.extend(this, props);
    }
    this.timeStamp = src && src.timeStamp || jQuery.now();
    this[jQuery.expando] = true;
  };
  jQuery.Event.prototype = {
    isDefaultPrevented: returnFalse,
    isPropagationStopped: returnFalse,
    isImmediatePropagationStopped: returnFalse,
    preventDefault: function () {
      var e = this.originalEvent;
      this.isDefaultPrevented = returnTrue;
      if (e && e.preventDefault) {
        e.preventDefault();
      }
    },
    stopPropagation: function () {
      var e = this.originalEvent;
      this.isPropagationStopped = returnTrue;
      if (e && e.stopPropagation) {
        e.stopPropagation();
      }
    },
    stopImmediatePropagation: function () {
      this.isImmediatePropagationStopped = returnTrue;
      this.stopPropagation();
    }
  };
  jQuery.each({
    mouseenter: 'mouseover',
    mouseleave: 'mouseout'
  }, function (orig, fix) {
    jQuery.event.special[orig] = {
      delegateType: fix,
      bindType: fix,
      handle: function (event) {
        var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj;
        if (!related || related !== target && !jQuery.contains(target, related)) {
          event.type = handleObj.origType;
          ret = handleObj.handler.apply(this, arguments);
          event.type = fix;
        }
        return ret;
      }
    };
  });
  if (!jQuery.support.focusinBubbles) {
    jQuery.each({
      focus: 'focusin',
      blur: 'focusout'
    }, function (orig, fix) {
      var attaches = 0, handler = function (event) {
          jQuery.event.simulate(fix, event.target, jQuery.event.fix(event), true);
        };
      jQuery.event.special[fix] = {
        setup: function () {
          if (attaches++ === 0) {
            document.addEventListener(orig, handler, true);
          }
        },
        teardown: function () {
          if (--attaches === 0) {
            document.removeEventListener(orig, handler, true);
          }
        }
      };
    });
  }
  jQuery.fn.extend({
    on: function (types, selector, data, fn, one) {
      var origFn, type;
      if (typeof types === 'object') {
        if (typeof selector !== 'string') {
          data = data || selector;
          selector = undefined;
        }
        for (type in types) {
          this.on(type, selector, data, types[type], one);
        }
        return this;
      }
      if (data == null && fn == null) {
        fn = selector;
        data = selector = undefined;
      } else if (fn == null) {
        if (typeof selector === 'string') {
          fn = data;
          data = undefined;
        } else {
          fn = data;
          data = selector;
          selector = undefined;
        }
      }
      if (fn === false) {
        fn = returnFalse;
      } else if (!fn) {
        return this;
      }
      if (one === 1) {
        origFn = fn;
        fn = function (event) {
          jQuery().off(event);
          return origFn.apply(this, arguments);
        };
        fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
      }
      return this.each(function () {
        jQuery.event.add(this, types, fn, data, selector);
      });
    },
    one: function (types, selector, data, fn) {
      return this.on(types, selector, data, fn, 1);
    },
    off: function (types, selector, fn) {
      var handleObj, type;
      if (types && types.preventDefault && types.handleObj) {
        handleObj = types.handleObj;
        jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + '.' + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
        return this;
      }
      if (typeof types === 'object') {
        for (type in types) {
          this.off(type, selector, types[type]);
        }
        return this;
      }
      if (selector === false || typeof selector === 'function') {
        fn = selector;
        selector = undefined;
      }
      if (fn === false) {
        fn = returnFalse;
      }
      return this.each(function () {
        jQuery.event.remove(this, types, fn, selector);
      });
    },
    trigger: function (type, data) {
      return this.each(function () {
        jQuery.event.trigger(type, data, this);
      });
    },
    triggerHandler: function (type, data) {
      var elem = this[0];
      if (elem) {
        return jQuery.event.trigger(type, data, elem, true);
      }
    }
  });
  var isSimple = /^.[^:#\[\.,]*$/, rparentsprev = /^(?:parents|prev(?:Until|All))/, rneedsContext = jQuery.expr.match.needsContext, guaranteedUnique = {
      children: true,
      contents: true,
      next: true,
      prev: true
    };
  jQuery.fn.extend({
    find: function (selector) {
      var i, ret = [], self = this, len = self.length;
      if (typeof selector !== 'string') {
        return this.pushStack(jQuery(selector).filter(function () {
          for (i = 0; i < len; i++) {
            if (jQuery.contains(self[i], this)) {
              return true;
            }
          }
        }));
      }
      for (i = 0; i < len; i++) {
        jQuery.find(selector, self[i], ret);
      }
      ret = this.pushStack(len > 1 ? jQuery.unique(ret) : ret);
      ret.selector = this.selector ? this.selector + ' ' + selector : selector;
      return ret;
    },
    has: function (target) {
      var targets = jQuery(target, this), l = targets.length;
      return this.filter(function () {
        var i = 0;
        for (; i < l; i++) {
          if (jQuery.contains(this, targets[i])) {
            return true;
          }
        }
      });
    },
    not: function (selector) {
      return this.pushStack(winnow(this, selector || [], true));
    },
    filter: function (selector) {
      return this.pushStack(winnow(this, selector || [], false));
    },
    is: function (selector) {
      return !!winnow(this, typeof selector === 'string' && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
    },
    closest: function (selectors, context) {
      var cur, i = 0, l = this.length, matched = [], pos = rneedsContext.test(selectors) || typeof selectors !== 'string' ? jQuery(selectors, context || this.context) : 0;
      for (; i < l; i++) {
        for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
          if (cur.nodeType < 11 && (pos ? pos.index(cur) > -1 : cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {
            cur = matched.push(cur);
            break;
          }
        }
      }
      return this.pushStack(matched.length > 1 ? jQuery.unique(matched) : matched);
    },
    index: function (elem) {
      if (!elem) {
        return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
      }
      if (typeof elem === 'string') {
        return core_indexOf.call(jQuery(elem), this[0]);
      }
      return core_indexOf.call(this, elem.jquery ? elem[0] : elem);
    },
    add: function (selector, context) {
      var set = typeof selector === 'string' ? jQuery(selector, context) : jQuery.makeArray(selector && selector.nodeType ? [selector] : selector), all = jQuery.merge(this.get(), set);
      return this.pushStack(jQuery.unique(all));
    },
    addBack: function (selector) {
      return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
    }
  });
  function sibling(cur, dir) {
    while ((cur = cur[dir]) && cur.nodeType !== 1) {
    }
    return cur;
  }
  jQuery.each({
    parent: function (elem) {
      var parent = elem.parentNode;
      return parent && parent.nodeType !== 11 ? parent : null;
    },
    parents: function (elem) {
      return jQuery.dir(elem, 'parentNode');
    },
    parentsUntil: function (elem, i, until) {
      return jQuery.dir(elem, 'parentNode', until);
    },
    next: function (elem) {
      return sibling(elem, 'nextSibling');
    },
    prev: function (elem) {
      return sibling(elem, 'previousSibling');
    },
    nextAll: function (elem) {
      return jQuery.dir(elem, 'nextSibling');
    },
    prevAll: function (elem) {
      return jQuery.dir(elem, 'previousSibling');
    },
    nextUntil: function (elem, i, until) {
      return jQuery.dir(elem, 'nextSibling', until);
    },
    prevUntil: function (elem, i, until) {
      return jQuery.dir(elem, 'previousSibling', until);
    },
    siblings: function (elem) {
      return jQuery.sibling((elem.parentNode || {}).firstChild, elem);
    },
    children: function (elem) {
      return jQuery.sibling(elem.firstChild);
    },
    contents: function (elem) {
      return elem.contentDocument || jQuery.merge([], elem.childNodes);
    }
  }, function (name, fn) {
    jQuery.fn[name] = function (until, selector) {
      var matched = jQuery.map(this, fn, until);
      if (name.slice(-5) !== 'Until') {
        selector = until;
      }
      if (selector && typeof selector === 'string') {
        matched = jQuery.filter(selector, matched);
      }
      if (this.length > 1) {
        if (!guaranteedUnique[name]) {
          jQuery.unique(matched);
        }
        if (rparentsprev.test(name)) {
          matched.reverse();
        }
      }
      return this.pushStack(matched);
    };
  });
  jQuery.extend({
    filter: function (expr, elems, not) {
      var elem = elems[0];
      if (not) {
        expr = ':not(' + expr + ')';
      }
      return elems.length === 1 && elem.nodeType === 1 ? jQuery.find.matchesSelector(elem, expr) ? [elem] : [] : jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {
        return elem.nodeType === 1;
      }));
    },
    dir: function (elem, dir, until) {
      var matched = [], truncate = until !== undefined;
      while ((elem = elem[dir]) && elem.nodeType !== 9) {
        if (elem.nodeType === 1) {
          if (truncate && jQuery(elem).is(until)) {
            break;
          }
          matched.push(elem);
        }
      }
      return matched;
    },
    sibling: function (n, elem) {
      var matched = [];
      for (; n; n = n.nextSibling) {
        if (n.nodeType === 1 && n !== elem) {
          matched.push(n);
        }
      }
      return matched;
    }
  });
  function winnow(elements, qualifier, not) {
    if (jQuery.isFunction(qualifier)) {
      return jQuery.grep(elements, function (elem, i) {
        return !!qualifier.call(elem, i, elem) !== not;
      });
    }
    if (qualifier.nodeType) {
      return jQuery.grep(elements, function (elem) {
        return elem === qualifier !== not;
      });
    }
    if (typeof qualifier === 'string') {
      if (isSimple.test(qualifier)) {
        return jQuery.filter(qualifier, elements, not);
      }
      qualifier = jQuery.filter(qualifier, elements);
    }
    return jQuery.grep(elements, function (elem) {
      return core_indexOf.call(qualifier, elem) >= 0 !== not;
    });
  }
  var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi, rtagName = /<([\w:]+)/, rhtml = /<|&#?\w+;/, rnoInnerhtml = /<(?:script|style|link)/i, manipulation_rcheckableType = /^(?:checkbox|radio)$/i, rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i, rscriptType = /^$|\/(?:java|ecma)script/i, rscriptTypeMasked = /^true\/(.*)/, rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g, wrapMap = {
      option: [
        1,
        '<select multiple=\'multiple\'>',
        '</select>'
      ],
      thead: [
        1,
        '<table>',
        '</table>'
      ],
      col: [
        2,
        '<table><colgroup>',
        '</colgroup></table>'
      ],
      tr: [
        2,
        '<table><tbody>',
        '</tbody></table>'
      ],
      td: [
        3,
        '<table><tbody><tr>',
        '</tr></tbody></table>'
      ],
      _default: [
        0,
        '',
        ''
      ]
    };
  wrapMap.optgroup = wrapMap.option;
  wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
  wrapMap.th = wrapMap.td;
  jQuery.fn.extend({
    text: function (value) {
      return jQuery.access(this, function (value) {
        return value === undefined ? jQuery.text(this) : this.empty().append((this[0] && this[0].ownerDocument || document).createTextNode(value));
      }, null, value, arguments.length);
    },
    append: function () {
      return this.domManip(arguments, function (elem) {
        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
          var target = manipulationTarget(this, elem);
          target.appendChild(elem);
        }
      });
    },
    prepend: function () {
      return this.domManip(arguments, function (elem) {
        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
          var target = manipulationTarget(this, elem);
          target.insertBefore(elem, target.firstChild);
        }
      });
    },
    before: function () {
      return this.domManip(arguments, function (elem) {
        if (this.parentNode) {
          this.parentNode.insertBefore(elem, this);
        }
      });
    },
    after: function () {
      return this.domManip(arguments, function (elem) {
        if (this.parentNode) {
          this.parentNode.insertBefore(elem, this.nextSibling);
        }
      });
    },
    remove: function (selector, keepData) {
      var elem, elems = selector ? jQuery.filter(selector, this) : this, i = 0;
      for (; (elem = elems[i]) != null; i++) {
        if (!keepData && elem.nodeType === 1) {
          jQuery.cleanData(getAll(elem));
        }
        if (elem.parentNode) {
          if (keepData && jQuery.contains(elem.ownerDocument, elem)) {
            setGlobalEval(getAll(elem, 'script'));
          }
          elem.parentNode.removeChild(elem);
        }
      }
      return this;
    },
    empty: function () {
      var elem, i = 0;
      for (; (elem = this[i]) != null; i++) {
        if (elem.nodeType === 1) {
          jQuery.cleanData(getAll(elem, false));
          elem.textContent = '';
        }
      }
      return this;
    },
    clone: function (dataAndEvents, deepDataAndEvents) {
      dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
      deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
      return this.map(function () {
        return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
      });
    },
    html: function (value) {
      return jQuery.access(this, function (value) {
        var elem = this[0] || {}, i = 0, l = this.length;
        if (value === undefined && elem.nodeType === 1) {
          return elem.innerHTML;
        }
        if (typeof value === 'string' && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || [
            '',
            ''
          ])[1].toLowerCase()]) {
          value = value.replace(rxhtmlTag, '<$1></$2>');
          try {
            for (; i < l; i++) {
              elem = this[i] || {};
              if (elem.nodeType === 1) {
                jQuery.cleanData(getAll(elem, false));
                elem.innerHTML = value;
              }
            }
            elem = 0;
          } catch (e) {
          }
        }
        if (elem) {
          this.empty().append(value);
        }
      }, null, value, arguments.length);
    },
    replaceWith: function () {
      var args = jQuery.map(this, function (elem) {
          return [
            elem.nextSibling,
            elem.parentNode
          ];
        }), i = 0;
      this.domManip(arguments, function (elem) {
        var next = args[i++], parent = args[i++];
        if (parent) {
          if (next && next.parentNode !== parent) {
            next = this.nextSibling;
          }
          jQuery(this).remove();
          parent.insertBefore(elem, next);
        }
      }, true);
      return i ? this : this.remove();
    },
    detach: function (selector) {
      return this.remove(selector, true);
    },
    domManip: function (args, callback, allowIntersection) {
      args = core_concat.apply([], args);
      var fragment, first, scripts, hasScripts, node, doc, i = 0, l = this.length, set = this, iNoClone = l - 1, value = args[0], isFunction = jQuery.isFunction(value);
      if (isFunction || !(l <= 1 || typeof value !== 'string' || jQuery.support.checkClone || !rchecked.test(value))) {
        return this.each(function (index) {
          var self = set.eq(index);
          if (isFunction) {
            args[0] = value.call(this, index, self.html());
          }
          self.domManip(args, callback, allowIntersection);
        });
      }
      if (l) {
        fragment = jQuery.buildFragment(args, this[0].ownerDocument, false, !allowIntersection && this);
        first = fragment.firstChild;
        if (fragment.childNodes.length === 1) {
          fragment = first;
        }
        if (first) {
          scripts = jQuery.map(getAll(fragment, 'script'), disableScript);
          hasScripts = scripts.length;
          for (; i < l; i++) {
            node = fragment;
            if (i !== iNoClone) {
              node = jQuery.clone(node, true, true);
              if (hasScripts) {
                jQuery.merge(scripts, getAll(node, 'script'));
              }
            }
            callback.call(this[i], node, i);
          }
          if (hasScripts) {
            doc = scripts[scripts.length - 1].ownerDocument;
            jQuery.map(scripts, restoreScript);
            for (i = 0; i < hasScripts; i++) {
              node = scripts[i];
              if (rscriptType.test(node.type || '') && !data_priv.access(node, 'globalEval') && jQuery.contains(doc, node)) {
                if (node.src) {
                  jQuery._evalUrl(node.src);
                } else {
                  jQuery.globalEval(node.textContent.replace(rcleanScript, ''));
                }
              }
            }
          }
        }
      }
      return this;
    }
  });
  jQuery.each({
    appendTo: 'append',
    prependTo: 'prepend',
    insertBefore: 'before',
    insertAfter: 'after',
    replaceAll: 'replaceWith'
  }, function (name, original) {
    jQuery.fn[name] = function (selector) {
      var elems, ret = [], insert = jQuery(selector), last = insert.length - 1, i = 0;
      for (; i <= last; i++) {
        elems = i === last ? this : this.clone(true);
        jQuery(insert[i])[original](elems);
        core_push.apply(ret, elems.get());
      }
      return this.pushStack(ret);
    };
  });
  jQuery.extend({
    clone: function (elem, dataAndEvents, deepDataAndEvents) {
      var i, l, srcElements, destElements, clone = elem.cloneNode(true), inPage = jQuery.contains(elem.ownerDocument, elem);
      if (!jQuery.support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
        destElements = getAll(clone);
        srcElements = getAll(elem);
        for (i = 0, l = srcElements.length; i < l; i++) {
          fixInput(srcElements[i], destElements[i]);
        }
      }
      if (dataAndEvents) {
        if (deepDataAndEvents) {
          srcElements = srcElements || getAll(elem);
          destElements = destElements || getAll(clone);
          for (i = 0, l = srcElements.length; i < l; i++) {
            cloneCopyEvent(srcElements[i], destElements[i]);
          }
        } else {
          cloneCopyEvent(elem, clone);
        }
      }
      destElements = getAll(clone, 'script');
      if (destElements.length > 0) {
        setGlobalEval(destElements, !inPage && getAll(elem, 'script'));
      }
      return clone;
    },
    buildFragment: function (elems, context, scripts, selection) {
      var elem, tmp, tag, wrap, contains, j, i = 0, l = elems.length, fragment = context.createDocumentFragment(), nodes = [];
      for (; i < l; i++) {
        elem = elems[i];
        if (elem || elem === 0) {
          if (jQuery.type(elem) === 'object') {
            jQuery.merge(nodes, elem.nodeType ? [elem] : elem);
          } else if (!rhtml.test(elem)) {
            nodes.push(context.createTextNode(elem));
          } else {
            tmp = tmp || fragment.appendChild(context.createElement('div'));
            tag = (rtagName.exec(elem) || [
              '',
              ''
            ])[1].toLowerCase();
            wrap = wrapMap[tag] || wrapMap._default;
            tmp.innerHTML = wrap[1] + elem.replace(rxhtmlTag, '<$1></$2>') + wrap[2];
            j = wrap[0];
            while (j--) {
              tmp = tmp.lastChild;
            }
            jQuery.merge(nodes, tmp.childNodes);
            tmp = fragment.firstChild;
            tmp.textContent = '';
          }
        }
      }
      fragment.textContent = '';
      i = 0;
      while (elem = nodes[i++]) {
        if (selection && jQuery.inArray(elem, selection) !== -1) {
          continue;
        }
        contains = jQuery.contains(elem.ownerDocument, elem);
        tmp = getAll(fragment.appendChild(elem), 'script');
        if (contains) {
          setGlobalEval(tmp);
        }
        if (scripts) {
          j = 0;
          while (elem = tmp[j++]) {
            if (rscriptType.test(elem.type || '')) {
              scripts.push(elem);
            }
          }
        }
      }
      return fragment;
    },
    cleanData: function (elems) {
      var data, elem, events, type, key, j, special = jQuery.event.special, i = 0;
      for (; (elem = elems[i]) !== undefined; i++) {
        if (Data.accepts(elem)) {
          key = elem[data_priv.expando];
          if (key && (data = data_priv.cache[key])) {
            events = Object.keys(data.events || {});
            if (events.length) {
              for (j = 0; (type = events[j]) !== undefined; j++) {
                if (special[type]) {
                  jQuery.event.remove(elem, type);
                } else {
                  jQuery.removeEvent(elem, type, data.handle);
                }
              }
            }
            if (data_priv.cache[key]) {
              delete data_priv.cache[key];
            }
          }
        }
        delete data_user.cache[elem[data_user.expando]];
      }
    },
    _evalUrl: function (url) {
      return jQuery.ajax({
        url: url,
        type: 'GET',
        dataType: 'script',
        async: false,
        global: false,
        'throws': true
      });
    }
  });
  function manipulationTarget(elem, content) {
    return jQuery.nodeName(elem, 'table') && jQuery.nodeName(content.nodeType === 1 ? content : content.firstChild, 'tr') ? elem.getElementsByTagName('tbody')[0] || elem.appendChild(elem.ownerDocument.createElement('tbody')) : elem;
  }
  function disableScript(elem) {
    elem.type = (elem.getAttribute('type') !== null) + '/' + elem.type;
    return elem;
  }
  function restoreScript(elem) {
    var match = rscriptTypeMasked.exec(elem.type);
    if (match) {
      elem.type = match[1];
    } else {
      elem.removeAttribute('type');
    }
    return elem;
  }
  function setGlobalEval(elems, refElements) {
    var l = elems.length, i = 0;
    for (; i < l; i++) {
      data_priv.set(elems[i], 'globalEval', !refElements || data_priv.get(refElements[i], 'globalEval'));
    }
  }
  function cloneCopyEvent(src, dest) {
    var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;
    if (dest.nodeType !== 1) {
      return;
    }
    if (data_priv.hasData(src)) {
      pdataOld = data_priv.access(src);
      pdataCur = data_priv.set(dest, pdataOld);
      events = pdataOld.events;
      if (events) {
        delete pdataCur.handle;
        pdataCur.events = {};
        for (type in events) {
          for (i = 0, l = events[type].length; i < l; i++) {
            jQuery.event.add(dest, type, events[type][i]);
          }
        }
      }
    }
    if (data_user.hasData(src)) {
      udataOld = data_user.access(src);
      udataCur = jQuery.extend({}, udataOld);
      data_user.set(dest, udataCur);
    }
  }
  function getAll(context, tag) {
    var ret = context.getElementsByTagName ? context.getElementsByTagName(tag || '*') : context.querySelectorAll ? context.querySelectorAll(tag || '*') : [];
    return tag === undefined || tag && jQuery.nodeName(context, tag) ? jQuery.merge([context], ret) : ret;
  }
  function fixInput(src, dest) {
    var nodeName = dest.nodeName.toLowerCase();
    if (nodeName === 'input' && manipulation_rcheckableType.test(src.type)) {
      dest.checked = src.checked;
    } else if (nodeName === 'input' || nodeName === 'textarea') {
      dest.defaultValue = src.defaultValue;
    }
  }
  jQuery.fn.extend({
    wrapAll: function (html) {
      var wrap;
      if (jQuery.isFunction(html)) {
        return this.each(function (i) {
          jQuery(this).wrapAll(html.call(this, i));
        });
      }
      if (this[0]) {
        wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);
        if (this[0].parentNode) {
          wrap.insertBefore(this[0]);
        }
        wrap.map(function () {
          var elem = this;
          while (elem.firstElementChild) {
            elem = elem.firstElementChild;
          }
          return elem;
        }).append(this);
      }
      return this;
    },
    wrapInner: function (html) {
      if (jQuery.isFunction(html)) {
        return this.each(function (i) {
          jQuery(this).wrapInner(html.call(this, i));
        });
      }
      return this.each(function () {
        var self = jQuery(this), contents = self.contents();
        if (contents.length) {
          contents.wrapAll(html);
        } else {
          self.append(html);
        }
      });
    },
    wrap: function (html) {
      var isFunction = jQuery.isFunction(html);
      return this.each(function (i) {
        jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
      });
    },
    unwrap: function () {
      return this.parent().each(function () {
        if (!jQuery.nodeName(this, 'body')) {
          jQuery(this).replaceWith(this.childNodes);
        }
      }).end();
    }
  });
  var curCSS, iframe, rdisplayswap = /^(none|table(?!-c[ea]).+)/, rmargin = /^margin/, rnumsplit = new RegExp('^(' + core_pnum + ')(.*)$', 'i'), rnumnonpx = new RegExp('^(' + core_pnum + ')(?!px)[a-z%]+$', 'i'), rrelNum = new RegExp('^([+-])=(' + core_pnum + ')', 'i'), elemdisplay = { BODY: 'block' }, cssShow = {
      position: 'absolute',
      visibility: 'hidden',
      display: 'block'
    }, cssNormalTransform = {
      letterSpacing: 0,
      fontWeight: 400
    }, cssExpand = [
      'Top',
      'Right',
      'Bottom',
      'Left'
    ], cssPrefixes = [
      'Webkit',
      'O',
      'Moz',
      'ms'
    ];
  function vendorPropName(style, name) {
    if (name in style) {
      return name;
    }
    var capName = name.charAt(0).toUpperCase() + name.slice(1), origName = name, i = cssPrefixes.length;
    while (i--) {
      name = cssPrefixes[i] + capName;
      if (name in style) {
        return name;
      }
    }
    return origName;
  }
  function isHidden(elem, el) {
    elem = el || elem;
    return jQuery.css(elem, 'display') === 'none' || !jQuery.contains(elem.ownerDocument, elem);
  }
  function getStyles(elem) {
    return window.getComputedStyle(elem, null);
  }
  function showHide(elements, show) {
    var display, elem, hidden, values = [], index = 0, length = elements.length;
    for (; index < length; index++) {
      elem = elements[index];
      if (!elem.style) {
        continue;
      }
      values[index] = data_priv.get(elem, 'olddisplay');
      display = elem.style.display;
      if (show) {
        if (!values[index] && display === 'none') {
          elem.style.display = '';
        }
        if (elem.style.display === '' && isHidden(elem)) {
          values[index] = data_priv.access(elem, 'olddisplay', css_defaultDisplay(elem.nodeName));
        }
      } else {
        if (!values[index]) {
          hidden = isHidden(elem);
          if (display && display !== 'none' || !hidden) {
            data_priv.set(elem, 'olddisplay', hidden ? display : jQuery.css(elem, 'display'));
          }
        }
      }
    }
    for (index = 0; index < length; index++) {
      elem = elements[index];
      if (!elem.style) {
        continue;
      }
      if (!show || elem.style.display === 'none' || elem.style.display === '') {
        elem.style.display = show ? values[index] || '' : 'none';
      }
    }
    return elements;
  }
  jQuery.fn.extend({
    css: function (name, value) {
      return jQuery.access(this, function (elem, name, value) {
        var styles, len, map = {}, i = 0;
        if (jQuery.isArray(name)) {
          styles = getStyles(elem);
          len = name.length;
          for (; i < len; i++) {
            map[name[i]] = jQuery.css(elem, name[i], false, styles);
          }
          return map;
        }
        return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
      }, name, value, arguments.length > 1);
    },
    show: function () {
      return showHide(this, true);
    },
    hide: function () {
      return showHide(this);
    },
    toggle: function (state) {
      if (typeof state === 'boolean') {
        return state ? this.show() : this.hide();
      }
      return this.each(function () {
        if (isHidden(this)) {
          jQuery(this).show();
        } else {
          jQuery(this).hide();
        }
      });
    }
  });
  jQuery.extend({
    cssHooks: {
      opacity: {
        get: function (elem, computed) {
          if (computed) {
            var ret = curCSS(elem, 'opacity');
            return ret === '' ? '1' : ret;
          }
        }
      }
    },
    cssNumber: {
      'columnCount': true,
      'fillOpacity': true,
      'fontWeight': true,
      'lineHeight': true,
      'opacity': true,
      'order': true,
      'orphans': true,
      'widows': true,
      'zIndex': true,
      'zoom': true
    },
    cssProps: { 'float': 'cssFloat' },
    style: function (elem, name, value, extra) {
      if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
        return;
      }
      var ret, type, hooks, origName = jQuery.camelCase(name), style = elem.style;
      name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(style, origName));
      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
      if (value !== undefined) {
        type = typeof value;
        if (type === 'string' && (ret = rrelNum.exec(value))) {
          value = (ret[1] + 1) * ret[2] + parseFloat(jQuery.css(elem, name));
          type = 'number';
        }
        if (value == null || type === 'number' && isNaN(value)) {
          return;
        }
        if (type === 'number' && !jQuery.cssNumber[origName]) {
          value += 'px';
        }
        if (!jQuery.support.clearCloneStyle && value === '' && name.indexOf('background') === 0) {
          style[name] = 'inherit';
        }
        if (!hooks || !('set' in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
          style[name] = value;
        }
      } else {
        if (hooks && 'get' in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
          return ret;
        }
        return style[name];
      }
    },
    css: function (elem, name, extra, styles) {
      var val, num, hooks, origName = jQuery.camelCase(name);
      name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(elem.style, origName));
      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
      if (hooks && 'get' in hooks) {
        val = hooks.get(elem, true, extra);
      }
      if (val === undefined) {
        val = curCSS(elem, name, styles);
      }
      if (val === 'normal' && name in cssNormalTransform) {
        val = cssNormalTransform[name];
      }
      if (extra === '' || extra) {
        num = parseFloat(val);
        return extra === true || jQuery.isNumeric(num) ? num || 0 : val;
      }
      return val;
    }
  });
  curCSS = function (elem, name, _computed) {
    var width, minWidth, maxWidth, computed = _computed || getStyles(elem), ret = computed ? computed.getPropertyValue(name) || computed[name] : undefined, style = elem.style;
    if (computed) {
      if (ret === '' && !jQuery.contains(elem.ownerDocument, elem)) {
        ret = jQuery.style(elem, name);
      }
      if (rnumnonpx.test(ret) && rmargin.test(name)) {
        width = style.width;
        minWidth = style.minWidth;
        maxWidth = style.maxWidth;
        style.minWidth = style.maxWidth = style.width = ret;
        ret = computed.width;
        style.width = width;
        style.minWidth = minWidth;
        style.maxWidth = maxWidth;
      }
    }
    return ret;
  };
  function setPositiveNumber(elem, value, subtract) {
    var matches = rnumsplit.exec(value);
    return matches ? Math.max(0, matches[1] - (subtract || 0)) + (matches[2] || 'px') : value;
  }
  function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
    var i = extra === (isBorderBox ? 'border' : 'content') ? 4 : name === 'width' ? 1 : 0, val = 0;
    for (; i < 4; i += 2) {
      if (extra === 'margin') {
        val += jQuery.css(elem, extra + cssExpand[i], true, styles);
      }
      if (isBorderBox) {
        if (extra === 'content') {
          val -= jQuery.css(elem, 'padding' + cssExpand[i], true, styles);
        }
        if (extra !== 'margin') {
          val -= jQuery.css(elem, 'border' + cssExpand[i] + 'Width', true, styles);
        }
      } else {
        val += jQuery.css(elem, 'padding' + cssExpand[i], true, styles);
        if (extra !== 'padding') {
          val += jQuery.css(elem, 'border' + cssExpand[i] + 'Width', true, styles);
        }
      }
    }
    return val;
  }
  function getWidthOrHeight(elem, name, extra) {
    var valueIsBorderBox = true, val = name === 'width' ? elem.offsetWidth : elem.offsetHeight, styles = getStyles(elem), isBorderBox = jQuery.support.boxSizing && jQuery.css(elem, 'boxSizing', false, styles) === 'border-box';
    if (val <= 0 || val == null) {
      val = curCSS(elem, name, styles);
      if (val < 0 || val == null) {
        val = elem.style[name];
      }
      if (rnumnonpx.test(val)) {
        return val;
      }
      valueIsBorderBox = isBorderBox && (jQuery.support.boxSizingReliable || val === elem.style[name]);
      val = parseFloat(val) || 0;
    }
    return val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? 'border' : 'content'), valueIsBorderBox, styles) + 'px';
  }
  function css_defaultDisplay(nodeName) {
    var doc = document, display = elemdisplay[nodeName];
    if (!display) {
      display = actualDisplay(nodeName, doc);
      if (display === 'none' || !display) {
        iframe = (iframe || jQuery('<iframe frameborder=\'0\' width=\'0\' height=\'0\'/>').css('cssText', 'display:block !important')).appendTo(doc.documentElement);
        doc = (iframe[0].contentWindow || iframe[0].contentDocument).document;
        doc.write('<!doctype html><html><body>');
        doc.close();
        display = actualDisplay(nodeName, doc);
        iframe.detach();
      }
      elemdisplay[nodeName] = display;
    }
    return display;
  }
  function actualDisplay(name, doc) {
    var elem = jQuery(doc.createElement(name)).appendTo(doc.body), display = jQuery.css(elem[0], 'display');
    elem.remove();
    return display;
  }
  jQuery.each([
    'height',
    'width'
  ], function (i, name) {
    jQuery.cssHooks[name] = {
      get: function (elem, computed, extra) {
        if (computed) {
          return elem.offsetWidth === 0 && rdisplayswap.test(jQuery.css(elem, 'display')) ? jQuery.swap(elem, cssShow, function () {
            return getWidthOrHeight(elem, name, extra);
          }) : getWidthOrHeight(elem, name, extra);
        }
      },
      set: function (elem, value, extra) {
        var styles = extra && getStyles(elem);
        return setPositiveNumber(elem, value, extra ? augmentWidthOrHeight(elem, name, extra, jQuery.support.boxSizing && jQuery.css(elem, 'boxSizing', false, styles) === 'border-box', styles) : 0);
      }
    };
  });
  jQuery(function () {
    if (!jQuery.support.reliableMarginRight) {
      jQuery.cssHooks.marginRight = {
        get: function (elem, computed) {
          if (computed) {
            return jQuery.swap(elem, { 'display': 'inline-block' }, curCSS, [
              elem,
              'marginRight'
            ]);
          }
        }
      };
    }
    if (!jQuery.support.pixelPosition && jQuery.fn.position) {
      jQuery.each([
        'top',
        'left'
      ], function (i, prop) {
        jQuery.cssHooks[prop] = {
          get: function (elem, computed) {
            if (computed) {
              computed = curCSS(elem, prop);
              return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + 'px' : computed;
            }
          }
        };
      });
    }
  });
  if (jQuery.expr && jQuery.expr.filters) {
    jQuery.expr.filters.hidden = function (elem) {
      return elem.offsetWidth <= 0 && elem.offsetHeight <= 0;
    };
    jQuery.expr.filters.visible = function (elem) {
      return !jQuery.expr.filters.hidden(elem);
    };
  }
  jQuery.each({
    margin: '',
    padding: '',
    border: 'Width'
  }, function (prefix, suffix) {
    jQuery.cssHooks[prefix + suffix] = {
      expand: function (value) {
        var i = 0, expanded = {}, parts = typeof value === 'string' ? value.split(' ') : [value];
        for (; i < 4; i++) {
          expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
        }
        return expanded;
      }
    };
    if (!rmargin.test(prefix)) {
      jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
    }
  });
  var r20 = /%20/g, rbracket = /\[\]$/, rCRLF = /\r?\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i, rsubmittable = /^(?:input|select|textarea|keygen)/i;
  jQuery.fn.extend({
    serialize: function () {
      return jQuery.param(this.serializeArray());
    },
    serializeArray: function () {
      return this.map(function () {
        var elements = jQuery.prop(this, 'elements');
        return elements ? jQuery.makeArray(elements) : this;
      }).filter(function () {
        var type = this.type;
        return this.name && !jQuery(this).is(':disabled') && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !manipulation_rcheckableType.test(type));
      }).map(function (i, elem) {
        var val = jQuery(this).val();
        return val == null ? null : jQuery.isArray(val) ? jQuery.map(val, function (val) {
          return {
            name: elem.name,
            value: val.replace(rCRLF, '\r\n')
          };
        }) : {
          name: elem.name,
          value: val.replace(rCRLF, '\r\n')
        };
      }).get();
    }
  });
  jQuery.param = function (a, traditional) {
    var prefix, s = [], add = function (key, value) {
        value = jQuery.isFunction(value) ? value() : value == null ? '' : value;
        s[s.length] = encodeURIComponent(key) + '=' + encodeURIComponent(value);
      };
    if (traditional === undefined) {
      traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
    }
    if (jQuery.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {
      jQuery.each(a, function () {
        add(this.name, this.value);
      });
    } else {
      for (prefix in a) {
        buildParams(prefix, a[prefix], traditional, add);
      }
    }
    return s.join('&').replace(r20, '+');
  };
  function buildParams(prefix, obj, traditional, add) {
    var name;
    if (jQuery.isArray(obj)) {
      jQuery.each(obj, function (i, v) {
        if (traditional || rbracket.test(prefix)) {
          add(prefix, v);
        } else {
          buildParams(prefix + '[' + (typeof v === 'object' ? i : '') + ']', v, traditional, add);
        }
      });
    } else if (!traditional && jQuery.type(obj) === 'object') {
      for (name in obj) {
        buildParams(prefix + '[' + name + ']', obj[name], traditional, add);
      }
    } else {
      add(prefix, obj);
    }
  }
  jQuery.each(('blur focus focusin focusout load resize scroll unload click dblclick ' + 'mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave ' + 'change select submit keydown keypress keyup error contextmenu').split(' '), function (i, name) {
    jQuery.fn[name] = function (data, fn) {
      return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
    };
  });
  jQuery.fn.extend({
    hover: function (fnOver, fnOut) {
      return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
    },
    bind: function (types, data, fn) {
      return this.on(types, null, data, fn);
    },
    unbind: function (types, fn) {
      return this.off(types, null, fn);
    },
    delegate: function (selector, types, data, fn) {
      return this.on(types, selector, data, fn);
    },
    undelegate: function (selector, types, fn) {
      return arguments.length === 1 ? this.off(selector, '**') : this.off(types, selector || '**', fn);
    }
  });
  var ajaxLocParts, ajaxLocation, ajax_nonce = jQuery.now(), ajax_rquery = /\?/, rhash = /#.*$/, rts = /([?&])_=[^&]*/, rheaders = /^(.*?):[ \t]*([^\r\n]*)$/gm, rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/, rprotocol = /^\/\//, rurl = /^([\w.+-]+:)(?:\/\/([^\/?#:]*)(?::(\d+)|)|)/, _load = jQuery.fn.load, prefilters = {}, transports = {}, allTypes = '*/'.concat('*');
  try {
    ajaxLocation = location.href;
  } catch (e) {
    ajaxLocation = document.createElement('a');
    ajaxLocation.href = '';
    ajaxLocation = ajaxLocation.href;
  }
  ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [];
  function addToPrefiltersOrTransports(structure) {
    return function (dataTypeExpression, func) {
      if (typeof dataTypeExpression !== 'string') {
        func = dataTypeExpression;
        dataTypeExpression = '*';
      }
      var dataType, i = 0, dataTypes = dataTypeExpression.toLowerCase().match(core_rnotwhite) || [];
      if (jQuery.isFunction(func)) {
        while (dataType = dataTypes[i++]) {
          if (dataType[0] === '+') {
            dataType = dataType.slice(1) || '*';
            (structure[dataType] = structure[dataType] || []).unshift(func);
          } else {
            (structure[dataType] = structure[dataType] || []).push(func);
          }
        }
      }
    };
  }
  function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
    var inspected = {}, seekingTransport = structure === transports;
    function inspect(dataType) {
      var selected;
      inspected[dataType] = true;
      jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {
        var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
        if (typeof dataTypeOrTransport === 'string' && !seekingTransport && !inspected[dataTypeOrTransport]) {
          options.dataTypes.unshift(dataTypeOrTransport);
          inspect(dataTypeOrTransport);
          return false;
        } else if (seekingTransport) {
          return !(selected = dataTypeOrTransport);
        }
      });
      return selected;
    }
    return inspect(options.dataTypes[0]) || !inspected['*'] && inspect('*');
  }
  function ajaxExtend(target, src) {
    var key, deep, flatOptions = jQuery.ajaxSettings.flatOptions || {};
    for (key in src) {
      if (src[key] !== undefined) {
        (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
      }
    }
    if (deep) {
      jQuery.extend(true, target, deep);
    }
    return target;
  }
  jQuery.fn.load = function (url, params, callback) {
    if (typeof url !== 'string' && _load) {
      return _load.apply(this, arguments);
    }
    var selector, type, response, self = this, off = url.indexOf(' ');
    if (off >= 0) {
      selector = url.slice(off);
      url = url.slice(0, off);
    }
    if (jQuery.isFunction(params)) {
      callback = params;
      params = undefined;
    } else if (params && typeof params === 'object') {
      type = 'POST';
    }
    if (self.length > 0) {
      jQuery.ajax({
        url: url,
        type: type,
        dataType: 'html',
        data: params
      }).done(function (responseText) {
        response = arguments;
        self.html(selector ? jQuery('<div>').append(jQuery.parseHTML(responseText)).find(selector) : responseText);
      }).complete(callback && function (jqXHR, status) {
        self.each(callback, response || [
          jqXHR.responseText,
          status,
          jqXHR
        ]);
      });
    }
    return this;
  };
  jQuery.each([
    'ajaxStart',
    'ajaxStop',
    'ajaxComplete',
    'ajaxError',
    'ajaxSuccess',
    'ajaxSend'
  ], function (i, type) {
    jQuery.fn[type] = function (fn) {
      return this.on(type, fn);
    };
  });
  jQuery.extend({
    active: 0,
    lastModified: {},
    etag: {},
    ajaxSettings: {
      url: ajaxLocation,
      type: 'GET',
      isLocal: rlocalProtocol.test(ajaxLocParts[1]),
      global: true,
      processData: true,
      async: true,
      contentType: 'application/x-www-form-urlencoded; charset=UTF-8',
      accepts: {
        '*': allTypes,
        text: 'text/plain',
        html: 'text/html',
        xml: 'application/xml, text/xml',
        json: 'application/json, text/javascript'
      },
      contents: {
        xml: /xml/,
        html: /html/,
        json: /json/
      },
      responseFields: {
        xml: 'responseXML',
        text: 'responseText',
        json: 'responseJSON'
      },
      converters: {
        '* text': String,
        'text html': true,
        'text json': jQuery.parseJSON,
        'text xml': jQuery.parseXML
      },
      flatOptions: {
        url: true,
        context: true
      }
    },
    ajaxSetup: function (target, settings) {
      return settings ? ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : ajaxExtend(jQuery.ajaxSettings, target);
    },
    ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
    ajaxTransport: addToPrefiltersOrTransports(transports),
    ajax: function (url, options) {
      if (typeof url === 'object') {
        options = url;
        url = undefined;
      }
      options = options || {};
      var transport, cacheURL, responseHeadersString, responseHeaders, timeoutTimer, parts, fireGlobals, i, s = jQuery.ajaxSetup({}, options), callbackContext = s.context || s, globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event, deferred = jQuery.Deferred(), completeDeferred = jQuery.Callbacks('once memory'), statusCode = s.statusCode || {}, requestHeaders = {}, requestHeadersNames = {}, state = 0, strAbort = 'canceled', jqXHR = {
          readyState: 0,
          getResponseHeader: function (key) {
            var match;
            if (state === 2) {
              if (!responseHeaders) {
                responseHeaders = {};
                while (match = rheaders.exec(responseHeadersString)) {
                  responseHeaders[match[1].toLowerCase()] = match[2];
                }
              }
              match = responseHeaders[key.toLowerCase()];
            }
            return match == null ? null : match;
          },
          getAllResponseHeaders: function () {
            return state === 2 ? responseHeadersString : null;
          },
          setRequestHeader: function (name, value) {
            var lname = name.toLowerCase();
            if (!state) {
              name = requestHeadersNames[lname] = requestHeadersNames[lname] || name;
              requestHeaders[name] = value;
            }
            return this;
          },
          overrideMimeType: function (type) {
            if (!state) {
              s.mimeType = type;
            }
            return this;
          },
          statusCode: function (map) {
            var code;
            if (map) {
              if (state < 2) {
                for (code in map) {
                  statusCode[code] = [
                    statusCode[code],
                    map[code]
                  ];
                }
              } else {
                jqXHR.always(map[jqXHR.status]);
              }
            }
            return this;
          },
          abort: function (statusText) {
            var finalText = statusText || strAbort;
            if (transport) {
              transport.abort(finalText);
            }
            done(0, finalText);
            return this;
          }
        };
      deferred.promise(jqXHR).complete = completeDeferred.add;
      jqXHR.success = jqXHR.done;
      jqXHR.error = jqXHR.fail;
      s.url = ((url || s.url || ajaxLocation) + '').replace(rhash, '').replace(rprotocol, ajaxLocParts[1] + '//');
      s.type = options.method || options.type || s.method || s.type;
      s.dataTypes = jQuery.trim(s.dataType || '*').toLowerCase().match(core_rnotwhite) || [''];
      if (s.crossDomain == null) {
        parts = rurl.exec(s.url.toLowerCase());
        s.crossDomain = !!(parts && (parts[1] !== ajaxLocParts[1] || parts[2] !== ajaxLocParts[2] || (parts[3] || (parts[1] === 'http:' ? '80' : '443')) !== (ajaxLocParts[3] || (ajaxLocParts[1] === 'http:' ? '80' : '443'))));
      }
      if (s.data && s.processData && typeof s.data !== 'string') {
        s.data = jQuery.param(s.data, s.traditional);
      }
      inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);
      if (state === 2) {
        return jqXHR;
      }
      fireGlobals = s.global;
      if (fireGlobals && jQuery.active++ === 0) {
        jQuery.event.trigger('ajaxStart');
      }
      s.type = s.type.toUpperCase();
      s.hasContent = !rnoContent.test(s.type);
      cacheURL = s.url;
      if (!s.hasContent) {
        if (s.data) {
          cacheURL = s.url += (ajax_rquery.test(cacheURL) ? '&' : '?') + s.data;
          delete s.data;
        }
        if (s.cache === false) {
          s.url = rts.test(cacheURL) ? cacheURL.replace(rts, '$1_=' + ajax_nonce++) : cacheURL + (ajax_rquery.test(cacheURL) ? '&' : '?') + '_=' + ajax_nonce++;
        }
      }
      if (s.ifModified) {
        if (jQuery.lastModified[cacheURL]) {
          jqXHR.setRequestHeader('If-Modified-Since', jQuery.lastModified[cacheURL]);
        }
        if (jQuery.etag[cacheURL]) {
          jqXHR.setRequestHeader('If-None-Match', jQuery.etag[cacheURL]);
        }
      }
      if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
        jqXHR.setRequestHeader('Content-Type', s.contentType);
      }
      jqXHR.setRequestHeader('Accept', s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== '*' ? ', ' + allTypes + '; q=0.01' : '') : s.accepts['*']);
      for (i in s.headers) {
        jqXHR.setRequestHeader(i, s.headers[i]);
      }
      if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {
        return jqXHR.abort();
      }
      strAbort = 'abort';
      for (i in {
          success: 1,
          error: 1,
          complete: 1
        }) {
        jqXHR[i](s[i]);
      }
      transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);
      if (!transport) {
        done(-1, 'No Transport');
      } else {
        jqXHR.readyState = 1;
        if (fireGlobals) {
          globalEventContext.trigger('ajaxSend', [
            jqXHR,
            s
          ]);
        }
        if (s.async && s.timeout > 0) {
          timeoutTimer = setTimeout(function () {
            jqXHR.abort('timeout');
          }, s.timeout);
        }
        try {
          state = 1;
          transport.send(requestHeaders, done);
        } catch (e) {
          if (state < 2) {
            done(-1, e);
          } else {
            throw e;
          }
        }
      }
      function done(status, nativeStatusText, responses, headers) {
        var isSuccess, success, error, response, modified, statusText = nativeStatusText;
        if (state === 2) {
          return;
        }
        state = 2;
        if (timeoutTimer) {
          clearTimeout(timeoutTimer);
        }
        transport = undefined;
        responseHeadersString = headers || '';
        jqXHR.readyState = status > 0 ? 4 : 0;
        isSuccess = status >= 200 && status < 300 || status === 304;
        if (responses) {
          response = ajaxHandleResponses(s, jqXHR, responses);
        }
        response = ajaxConvert(s, response, jqXHR, isSuccess);
        if (isSuccess) {
          if (s.ifModified) {
            modified = jqXHR.getResponseHeader('Last-Modified');
            if (modified) {
              jQuery.lastModified[cacheURL] = modified;
            }
            modified = jqXHR.getResponseHeader('etag');
            if (modified) {
              jQuery.etag[cacheURL] = modified;
            }
          }
          if (status === 204 || s.type === 'HEAD') {
            statusText = 'nocontent';
          } else if (status === 304) {
            statusText = 'notmodified';
          } else {
            statusText = response.state;
            success = response.data;
            error = response.error;
            isSuccess = !error;
          }
        } else {
          error = statusText;
          if (status || !statusText) {
            statusText = 'error';
            if (status < 0) {
              status = 0;
            }
          }
        }
        jqXHR.status = status;
        jqXHR.statusText = (nativeStatusText || statusText) + '';
        if (isSuccess) {
          deferred.resolveWith(callbackContext, [
            success,
            statusText,
            jqXHR
          ]);
        } else {
          deferred.rejectWith(callbackContext, [
            jqXHR,
            statusText,
            error
          ]);
        }
        jqXHR.statusCode(statusCode);
        statusCode = undefined;
        if (fireGlobals) {
          globalEventContext.trigger(isSuccess ? 'ajaxSuccess' : 'ajaxError', [
            jqXHR,
            s,
            isSuccess ? success : error
          ]);
        }
        completeDeferred.fireWith(callbackContext, [
          jqXHR,
          statusText
        ]);
        if (fireGlobals) {
          globalEventContext.trigger('ajaxComplete', [
            jqXHR,
            s
          ]);
          if (!--jQuery.active) {
            jQuery.event.trigger('ajaxStop');
          }
        }
      }
      return jqXHR;
    },
    getJSON: function (url, data, callback) {
      return jQuery.get(url, data, callback, 'json');
    },
    getScript: function (url, callback) {
      return jQuery.get(url, undefined, callback, 'script');
    }
  });
  jQuery.each([
    'get',
    'post'
  ], function (i, method) {
    jQuery[method] = function (url, data, callback, type) {
      if (jQuery.isFunction(data)) {
        type = type || callback;
        callback = data;
        data = undefined;
      }
      return jQuery.ajax({
        url: url,
        type: method,
        dataType: type,
        data: data,
        success: callback
      });
    };
  });
  function ajaxHandleResponses(s, jqXHR, responses) {
    var ct, type, finalDataType, firstDataType, contents = s.contents, dataTypes = s.dataTypes;
    while (dataTypes[0] === '*') {
      dataTypes.shift();
      if (ct === undefined) {
        ct = s.mimeType || jqXHR.getResponseHeader('Content-Type');
      }
    }
    if (ct) {
      for (type in contents) {
        if (contents[type] && contents[type].test(ct)) {
          dataTypes.unshift(type);
          break;
        }
      }
    }
    if (dataTypes[0] in responses) {
      finalDataType = dataTypes[0];
    } else {
      for (type in responses) {
        if (!dataTypes[0] || s.converters[type + ' ' + dataTypes[0]]) {
          finalDataType = type;
          break;
        }
        if (!firstDataType) {
          firstDataType = type;
        }
      }
      finalDataType = finalDataType || firstDataType;
    }
    if (finalDataType) {
      if (finalDataType !== dataTypes[0]) {
        dataTypes.unshift(finalDataType);
      }
      return responses[finalDataType];
    }
  }
  function ajaxConvert(s, response, jqXHR, isSuccess) {
    var conv2, current, conv, tmp, prev, converters = {}, dataTypes = s.dataTypes.slice();
    if (dataTypes[1]) {
      for (conv in s.converters) {
        converters[conv.toLowerCase()] = s.converters[conv];
      }
    }
    current = dataTypes.shift();
    while (current) {
      if (s.responseFields[current]) {
        jqXHR[s.responseFields[current]] = response;
      }
      if (!prev && isSuccess && s.dataFilter) {
        response = s.dataFilter(response, s.dataType);
      }
      prev = current;
      current = dataTypes.shift();
      if (current) {
        if (current === '*') {
          current = prev;
        } else if (prev !== '*' && prev !== current) {
          conv = converters[prev + ' ' + current] || converters['* ' + current];
          if (!conv) {
            for (conv2 in converters) {
              tmp = conv2.split(' ');
              if (tmp[1] === current) {
                conv = converters[prev + ' ' + tmp[0]] || converters['* ' + tmp[0]];
                if (conv) {
                  if (conv === true) {
                    conv = converters[conv2];
                  } else if (converters[conv2] !== true) {
                    current = tmp[0];
                    dataTypes.unshift(tmp[1]);
                  }
                  break;
                }
              }
            }
          }
          if (conv !== true) {
            if (conv && s['throws']) {
              response = conv(response);
            } else {
              try {
                response = conv(response);
              } catch (e) {
                return {
                  state: 'parsererror',
                  error: conv ? e : 'No conversion from ' + prev + ' to ' + current
                };
              }
            }
          }
        }
      }
    }
    return {
      state: 'success',
      data: response
    };
  }
  jQuery.ajaxSetup({
    accepts: { script: 'text/javascript, application/javascript, application/ecmascript, application/x-ecmascript' },
    contents: { script: /(?:java|ecma)script/ },
    converters: {
      'text script': function (text) {
        jQuery.globalEval(text);
        return text;
      }
    }
  });
  jQuery.ajaxPrefilter('script', function (s) {
    if (s.cache === undefined) {
      s.cache = false;
    }
    if (s.crossDomain) {
      s.type = 'GET';
    }
  });
  jQuery.ajaxTransport('script', function (s) {
    if (s.crossDomain) {
      var script, callback;
      return {
        send: function (_, complete) {
          script = jQuery('<script>').prop({
            async: true,
            charset: s.scriptCharset,
            src: s.url
          }).on('load error', callback = function (evt) {
            script.remove();
            callback = null;
            if (evt) {
              complete(evt.type === 'error' ? 404 : 200, evt.type);
            }
          });
          document.head.appendChild(script[0]);
        },
        abort: function () {
          if (callback) {
            callback();
          }
        }
      };
    }
  });
  var oldCallbacks = [], rjsonp = /(=)\?(?=&|$)|\?\?/;
  jQuery.ajaxSetup({
    jsonp: 'callback',
    jsonpCallback: function () {
      var callback = oldCallbacks.pop() || jQuery.expando + '_' + ajax_nonce++;
      this[callback] = true;
      return callback;
    }
  });
  jQuery.ajaxPrefilter('json jsonp', function (s, originalSettings, jqXHR) {
    var callbackName, overwritten, responseContainer, jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? 'url' : typeof s.data === 'string' && !(s.contentType || '').indexOf('application/x-www-form-urlencoded') && rjsonp.test(s.data) && 'data');
    if (jsonProp || s.dataTypes[0] === 'jsonp') {
      callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;
      if (jsonProp) {
        s[jsonProp] = s[jsonProp].replace(rjsonp, '$1' + callbackName);
      } else if (s.jsonp !== false) {
        s.url += (ajax_rquery.test(s.url) ? '&' : '?') + s.jsonp + '=' + callbackName;
      }
      s.converters['script json'] = function () {
        if (!responseContainer) {
          jQuery.error(callbackName + ' was not called');
        }
        return responseContainer[0];
      };
      s.dataTypes[0] = 'json';
      overwritten = window[callbackName];
      window[callbackName] = function () {
        responseContainer = arguments;
      };
      jqXHR.always(function () {
        window[callbackName] = overwritten;
        if (s[callbackName]) {
          s.jsonpCallback = originalSettings.jsonpCallback;
          oldCallbacks.push(callbackName);
        }
        if (responseContainer && jQuery.isFunction(overwritten)) {
          overwritten(responseContainer[0]);
        }
        responseContainer = overwritten = undefined;
      });
      return 'script';
    }
  });
  jQuery.ajaxSettings.xhr = function () {
    try {
      return new XMLHttpRequest();
    } catch (e) {
    }
  };
  var xhrSupported = jQuery.ajaxSettings.xhr(), xhrSuccessStatus = {
      0: 200,
      1223: 204
    }, xhrId = 0, xhrCallbacks = {};
  if (window.ActiveXObject) {
    jQuery(window).on('unload', function () {
      for (var key in xhrCallbacks) {
        xhrCallbacks[key]();
      }
      xhrCallbacks = undefined;
    });
  }
  jQuery.support.cors = !!xhrSupported && 'withCredentials' in xhrSupported;
  jQuery.support.ajax = xhrSupported = !!xhrSupported;
  jQuery.ajaxTransport(function (options) {
    var callback;
    if (jQuery.support.cors || xhrSupported && !options.crossDomain) {
      return {
        send: function (headers, complete) {
          var i, id, xhr = options.xhr();
          xhr.open(options.type, options.url, options.async, options.username, options.password);
          if (options.xhrFields) {
            for (i in options.xhrFields) {
              xhr[i] = options.xhrFields[i];
            }
          }
          if (options.mimeType && xhr.overrideMimeType) {
            xhr.overrideMimeType(options.mimeType);
          }
          if (!options.crossDomain && !headers['X-Requested-With']) {
            headers['X-Requested-With'] = 'XMLHttpRequest';
          }
          for (i in headers) {
            xhr.setRequestHeader(i, headers[i]);
          }
          callback = function (type) {
            return function () {
              if (callback) {
                delete xhrCallbacks[id];
                callback = xhr.onload = xhr.onerror = null;
                if (type === 'abort') {
                  xhr.abort();
                } else if (type === 'error') {
                  complete(xhr.status || 404, xhr.statusText);
                } else {
                  complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, typeof xhr.responseText === 'string' ? { text: xhr.responseText } : undefined, xhr.getAllResponseHeaders());
                }
              }
            };
          };
          xhr.onload = callback();
          xhr.onerror = callback('error');
          callback = xhrCallbacks[id = xhrId++] = callback('abort');
          xhr.send(options.hasContent && options.data || null);
        },
        abort: function () {
          if (callback) {
            callback();
          }
        }
      };
    }
  });
  var fxNow, timerId, rfxtypes = /^(?:toggle|show|hide)$/, rfxnum = new RegExp('^(?:([+-])=|)(' + core_pnum + ')([a-z%]*)$', 'i'), rrun = /queueHooks$/, animationPrefilters = [defaultPrefilter], tweeners = {
      '*': [function (prop, value) {
          var tween = this.createTween(prop, value), target = tween.cur(), parts = rfxnum.exec(value), unit = parts && parts[3] || (jQuery.cssNumber[prop] ? '' : 'px'), start = (jQuery.cssNumber[prop] || unit !== 'px' && +target) && rfxnum.exec(jQuery.css(tween.elem, prop)), scale = 1, maxIterations = 20;
          if (start && start[3] !== unit) {
            unit = unit || start[3];
            parts = parts || [];
            start = +target || 1;
            do {
              scale = scale || '.5';
              start = start / scale;
              jQuery.style(tween.elem, prop, start + unit);
            } while (scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations);
          }
          if (parts) {
            start = tween.start = +start || +target || 0;
            tween.unit = unit;
            tween.end = parts[1] ? start + (parts[1] + 1) * parts[2] : +parts[2];
          }
          return tween;
        }]
    };
  function createFxNow() {
    setTimeout(function () {
      fxNow = undefined;
    });
    return fxNow = jQuery.now();
  }
  function createTween(value, prop, animation) {
    var tween, collection = (tweeners[prop] || []).concat(tweeners['*']), index = 0, length = collection.length;
    for (; index < length; index++) {
      if (tween = collection[index].call(animation, prop, value)) {
        return tween;
      }
    }
  }
  function Animation(elem, properties, options) {
    var result, stopped, index = 0, length = animationPrefilters.length, deferred = jQuery.Deferred().always(function () {
        delete tick.elem;
      }), tick = function () {
        if (stopped) {
          return false;
        }
        var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), temp = remaining / animation.duration || 0, percent = 1 - temp, index = 0, length = animation.tweens.length;
        for (; index < length; index++) {
          animation.tweens[index].run(percent);
        }
        deferred.notifyWith(elem, [
          animation,
          percent,
          remaining
        ]);
        if (percent < 1 && length) {
          return remaining;
        } else {
          deferred.resolveWith(elem, [animation]);
          return false;
        }
      }, animation = deferred.promise({
        elem: elem,
        props: jQuery.extend({}, properties),
        opts: jQuery.extend(true, { specialEasing: {} }, options),
        originalProperties: properties,
        originalOptions: options,
        startTime: fxNow || createFxNow(),
        duration: options.duration,
        tweens: [],
        createTween: function (prop, end) {
          var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
          animation.tweens.push(tween);
          return tween;
        },
        stop: function (gotoEnd) {
          var index = 0, length = gotoEnd ? animation.tweens.length : 0;
          if (stopped) {
            return this;
          }
          stopped = true;
          for (; index < length; index++) {
            animation.tweens[index].run(1);
          }
          if (gotoEnd) {
            deferred.resolveWith(elem, [
              animation,
              gotoEnd
            ]);
          } else {
            deferred.rejectWith(elem, [
              animation,
              gotoEnd
            ]);
          }
          return this;
        }
      }), props = animation.props;
    propFilter(props, animation.opts.specialEasing);
    for (; index < length; index++) {
      result = animationPrefilters[index].call(animation, elem, props, animation.opts);
      if (result) {
        return result;
      }
    }
    jQuery.map(props, createTween, animation);
    if (jQuery.isFunction(animation.opts.start)) {
      animation.opts.start.call(elem, animation);
    }
    jQuery.fx.timer(jQuery.extend(tick, {
      elem: elem,
      anim: animation,
      queue: animation.opts.queue
    }));
    return animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
  }
  function propFilter(props, specialEasing) {
    var index, name, easing, value, hooks;
    for (index in props) {
      name = jQuery.camelCase(index);
      easing = specialEasing[name];
      value = props[index];
      if (jQuery.isArray(value)) {
        easing = value[1];
        value = props[index] = value[0];
      }
      if (index !== name) {
        props[name] = value;
        delete props[index];
      }
      hooks = jQuery.cssHooks[name];
      if (hooks && 'expand' in hooks) {
        value = hooks.expand(value);
        delete props[name];
        for (index in value) {
          if (!(index in props)) {
            props[index] = value[index];
            specialEasing[index] = easing;
          }
        }
      } else {
        specialEasing[name] = easing;
      }
    }
  }
  jQuery.Animation = jQuery.extend(Animation, {
    tweener: function (props, callback) {
      if (jQuery.isFunction(props)) {
        callback = props;
        props = ['*'];
      } else {
        props = props.split(' ');
      }
      var prop, index = 0, length = props.length;
      for (; index < length; index++) {
        prop = props[index];
        tweeners[prop] = tweeners[prop] || [];
        tweeners[prop].unshift(callback);
      }
    },
    prefilter: function (callback, prepend) {
      if (prepend) {
        animationPrefilters.unshift(callback);
      } else {
        animationPrefilters.push(callback);
      }
    }
  });
  function defaultPrefilter(elem, props, opts) {
    var prop, value, toggle, tween, hooks, oldfire, anim = this, orig = {}, style = elem.style, hidden = elem.nodeType && isHidden(elem), dataShow = data_priv.get(elem, 'fxshow');
    if (!opts.queue) {
      hooks = jQuery._queueHooks(elem, 'fx');
      if (hooks.unqueued == null) {
        hooks.unqueued = 0;
        oldfire = hooks.empty.fire;
        hooks.empty.fire = function () {
          if (!hooks.unqueued) {
            oldfire();
          }
        };
      }
      hooks.unqueued++;
      anim.always(function () {
        anim.always(function () {
          hooks.unqueued--;
          if (!jQuery.queue(elem, 'fx').length) {
            hooks.empty.fire();
          }
        });
      });
    }
    if (elem.nodeType === 1 && ('height' in props || 'width' in props)) {
      opts.overflow = [
        style.overflow,
        style.overflowX,
        style.overflowY
      ];
      if (jQuery.css(elem, 'display') === 'inline' && jQuery.css(elem, 'float') === 'none') {
        style.display = 'inline-block';
      }
    }
    if (opts.overflow) {
      style.overflow = 'hidden';
      anim.always(function () {
        style.overflow = opts.overflow[0];
        style.overflowX = opts.overflow[1];
        style.overflowY = opts.overflow[2];
      });
    }
    for (prop in props) {
      value = props[prop];
      if (rfxtypes.exec(value)) {
        delete props[prop];
        toggle = toggle || value === 'toggle';
        if (value === (hidden ? 'hide' : 'show')) {
          if (value === 'show' && dataShow && dataShow[prop] !== undefined) {
            hidden = true;
          } else {
            continue;
          }
        }
        orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
      }
    }
    if (!jQuery.isEmptyObject(orig)) {
      if (dataShow) {
        if ('hidden' in dataShow) {
          hidden = dataShow.hidden;
        }
      } else {
        dataShow = data_priv.access(elem, 'fxshow', {});
      }
      if (toggle) {
        dataShow.hidden = !hidden;
      }
      if (hidden) {
        jQuery(elem).show();
      } else {
        anim.done(function () {
          jQuery(elem).hide();
        });
      }
      anim.done(function () {
        var prop;
        data_priv.remove(elem, 'fxshow');
        for (prop in orig) {
          jQuery.style(elem, prop, orig[prop]);
        }
      });
      for (prop in orig) {
        tween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
        if (!(prop in dataShow)) {
          dataShow[prop] = tween.start;
          if (hidden) {
            tween.end = tween.start;
            tween.start = prop === 'width' || prop === 'height' ? 1 : 0;
          }
        }
      }
    }
  }
  function Tween(elem, options, prop, end, easing) {
    return new Tween.prototype.init(elem, options, prop, end, easing);
  }
  jQuery.Tween = Tween;
  Tween.prototype = {
    constructor: Tween,
    init: function (elem, options, prop, end, easing, unit) {
      this.elem = elem;
      this.prop = prop;
      this.easing = easing || 'swing';
      this.options = options;
      this.start = this.now = this.cur();
      this.end = end;
      this.unit = unit || (jQuery.cssNumber[prop] ? '' : 'px');
    },
    cur: function () {
      var hooks = Tween.propHooks[this.prop];
      return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
    },
    run: function (percent) {
      var eased, hooks = Tween.propHooks[this.prop];
      if (this.options.duration) {
        this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
      } else {
        this.pos = eased = percent;
      }
      this.now = (this.end - this.start) * eased + this.start;
      if (this.options.step) {
        this.options.step.call(this.elem, this.now, this);
      }
      if (hooks && hooks.set) {
        hooks.set(this);
      } else {
        Tween.propHooks._default.set(this);
      }
      return this;
    }
  };
  Tween.prototype.init.prototype = Tween.prototype;
  Tween.propHooks = {
    _default: {
      get: function (tween) {
        var result;
        if (tween.elem[tween.prop] != null && (!tween.elem.style || tween.elem.style[tween.prop] == null)) {
          return tween.elem[tween.prop];
        }
        result = jQuery.css(tween.elem, tween.prop, '');
        return !result || result === 'auto' ? 0 : result;
      },
      set: function (tween) {
        if (jQuery.fx.step[tween.prop]) {
          jQuery.fx.step[tween.prop](tween);
        } else if (tween.elem.style && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {
          jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
        } else {
          tween.elem[tween.prop] = tween.now;
        }
      }
    }
  };
  Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
    set: function (tween) {
      if (tween.elem.nodeType && tween.elem.parentNode) {
        tween.elem[tween.prop] = tween.now;
      }
    }
  };
  jQuery.each([
    'toggle',
    'show',
    'hide'
  ], function (i, name) {
    var cssFn = jQuery.fn[name];
    jQuery.fn[name] = function (speed, easing, callback) {
      return speed == null || typeof speed === 'boolean' ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
    };
  });
  jQuery.fn.extend({
    fadeTo: function (speed, to, easing, callback) {
      return this.filter(isHidden).css('opacity', 0).show().end().animate({ opacity: to }, speed, easing, callback);
    },
    animate: function (prop, speed, easing, callback) {
      var empty = jQuery.isEmptyObject(prop), optall = jQuery.speed(speed, easing, callback), doAnimation = function () {
          var anim = Animation(this, jQuery.extend({}, prop), optall);
          if (empty || data_priv.get(this, 'finish')) {
            anim.stop(true);
          }
        };
      doAnimation.finish = doAnimation;
      return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
    },
    stop: function (type, clearQueue, gotoEnd) {
      var stopQueue = function (hooks) {
        var stop = hooks.stop;
        delete hooks.stop;
        stop(gotoEnd);
      };
      if (typeof type !== 'string') {
        gotoEnd = clearQueue;
        clearQueue = type;
        type = undefined;
      }
      if (clearQueue && type !== false) {
        this.queue(type || 'fx', []);
      }
      return this.each(function () {
        var dequeue = true, index = type != null && type + 'queueHooks', timers = jQuery.timers, data = data_priv.get(this);
        if (index) {
          if (data[index] && data[index].stop) {
            stopQueue(data[index]);
          }
        } else {
          for (index in data) {
            if (data[index] && data[index].stop && rrun.test(index)) {
              stopQueue(data[index]);
            }
          }
        }
        for (index = timers.length; index--;) {
          if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
            timers[index].anim.stop(gotoEnd);
            dequeue = false;
            timers.splice(index, 1);
          }
        }
        if (dequeue || !gotoEnd) {
          jQuery.dequeue(this, type);
        }
      });
    },
    finish: function (type) {
      if (type !== false) {
        type = type || 'fx';
      }
      return this.each(function () {
        var index, data = data_priv.get(this), queue = data[type + 'queue'], hooks = data[type + 'queueHooks'], timers = jQuery.timers, length = queue ? queue.length : 0;
        data.finish = true;
        jQuery.queue(this, type, []);
        if (hooks && hooks.stop) {
          hooks.stop.call(this, true);
        }
        for (index = timers.length; index--;) {
          if (timers[index].elem === this && timers[index].queue === type) {
            timers[index].anim.stop(true);
            timers.splice(index, 1);
          }
        }
        for (index = 0; index < length; index++) {
          if (queue[index] && queue[index].finish) {
            queue[index].finish.call(this);
          }
        }
        delete data.finish;
      });
    }
  });
  function genFx(type, includeWidth) {
    var which, attrs = { height: type }, i = 0;
    includeWidth = includeWidth ? 1 : 0;
    for (; i < 4; i += 2 - includeWidth) {
      which = cssExpand[i];
      attrs['margin' + which] = attrs['padding' + which] = type;
    }
    if (includeWidth) {
      attrs.opacity = attrs.width = type;
    }
    return attrs;
  }
  jQuery.each({
    slideDown: genFx('show'),
    slideUp: genFx('hide'),
    slideToggle: genFx('toggle'),
    fadeIn: { opacity: 'show' },
    fadeOut: { opacity: 'hide' },
    fadeToggle: { opacity: 'toggle' }
  }, function (name, props) {
    jQuery.fn[name] = function (speed, easing, callback) {
      return this.animate(props, speed, easing, callback);
    };
  });
  jQuery.speed = function (speed, easing, fn) {
    var opt = speed && typeof speed === 'object' ? jQuery.extend({}, speed) : {
        complete: fn || !fn && easing || jQuery.isFunction(speed) && speed,
        duration: speed,
        easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
      };
    opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === 'number' ? opt.duration : opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default;
    if (opt.queue == null || opt.queue === true) {
      opt.queue = 'fx';
    }
    opt.old = opt.complete;
    opt.complete = function () {
      if (jQuery.isFunction(opt.old)) {
        opt.old.call(this);
      }
      if (opt.queue) {
        jQuery.dequeue(this, opt.queue);
      }
    };
    return opt;
  };
  jQuery.easing = {
    linear: function (p) {
      return p;
    },
    swing: function (p) {
      return 0.5 - Math.cos(p * Math.PI) / 2;
    }
  };
  jQuery.timers = [];
  jQuery.fx = Tween.prototype.init;
  jQuery.fx.tick = function () {
    var timer, timers = jQuery.timers, i = 0;
    fxNow = jQuery.now();
    for (; i < timers.length; i++) {
      timer = timers[i];
      if (!timer() && timers[i] === timer) {
        timers.splice(i--, 1);
      }
    }
    if (!timers.length) {
      jQuery.fx.stop();
    }
    fxNow = undefined;
  };
  jQuery.fx.timer = function (timer) {
    if (timer() && jQuery.timers.push(timer)) {
      jQuery.fx.start();
    }
  };
  jQuery.fx.interval = 13;
  jQuery.fx.start = function () {
    if (!timerId) {
      timerId = setInterval(jQuery.fx.tick, jQuery.fx.interval);
    }
  };
  jQuery.fx.stop = function () {
    clearInterval(timerId);
    timerId = null;
  };
  jQuery.fx.speeds = {
    slow: 600,
    fast: 200,
    _default: 400
  };
  jQuery.fx.step = {};
  if (jQuery.expr && jQuery.expr.filters) {
    jQuery.expr.filters.animated = function (elem) {
      return jQuery.grep(jQuery.timers, function (fn) {
        return elem === fn.elem;
      }).length;
    };
  }
  jQuery.fn.offset = function (options) {
    if (arguments.length) {
      return options === undefined ? this : this.each(function (i) {
        jQuery.offset.setOffset(this, options, i);
      });
    }
    var docElem, win, elem = this[0], box = {
        top: 0,
        left: 0
      }, doc = elem && elem.ownerDocument;
    if (!doc) {
      return;
    }
    docElem = doc.documentElement;
    if (!jQuery.contains(docElem, elem)) {
      return box;
    }
    if (typeof elem.getBoundingClientRect !== core_strundefined) {
      box = elem.getBoundingClientRect();
    }
    win = getWindow(doc);
    return {
      top: box.top + win.pageYOffset - docElem.clientTop,
      left: box.left + win.pageXOffset - docElem.clientLeft
    };
  };
  jQuery.offset = {
    setOffset: function (elem, options, i) {
      var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery.css(elem, 'position'), curElem = jQuery(elem), props = {};
      if (position === 'static') {
        elem.style.position = 'relative';
      }
      curOffset = curElem.offset();
      curCSSTop = jQuery.css(elem, 'top');
      curCSSLeft = jQuery.css(elem, 'left');
      calculatePosition = (position === 'absolute' || position === 'fixed') && (curCSSTop + curCSSLeft).indexOf('auto') > -1;
      if (calculatePosition) {
        curPosition = curElem.position();
        curTop = curPosition.top;
        curLeft = curPosition.left;
      } else {
        curTop = parseFloat(curCSSTop) || 0;
        curLeft = parseFloat(curCSSLeft) || 0;
      }
      if (jQuery.isFunction(options)) {
        options = options.call(elem, i, curOffset);
      }
      if (options.top != null) {
        props.top = options.top - curOffset.top + curTop;
      }
      if (options.left != null) {
        props.left = options.left - curOffset.left + curLeft;
      }
      if ('using' in options) {
        options.using.call(elem, props);
      } else {
        curElem.css(props);
      }
    }
  };
  jQuery.fn.extend({
    position: function () {
      if (!this[0]) {
        return;
      }
      var offsetParent, offset, elem = this[0], parentOffset = {
          top: 0,
          left: 0
        };
      if (jQuery.css(elem, 'position') === 'fixed') {
        offset = elem.getBoundingClientRect();
      } else {
        offsetParent = this.offsetParent();
        offset = this.offset();
        if (!jQuery.nodeName(offsetParent[0], 'html')) {
          parentOffset = offsetParent.offset();
        }
        parentOffset.top += jQuery.css(offsetParent[0], 'borderTopWidth', true);
        parentOffset.left += jQuery.css(offsetParent[0], 'borderLeftWidth', true);
      }
      return {
        top: offset.top - parentOffset.top - jQuery.css(elem, 'marginTop', true),
        left: offset.left - parentOffset.left - jQuery.css(elem, 'marginLeft', true)
      };
    },
    offsetParent: function () {
      return this.map(function () {
        var offsetParent = this.offsetParent || docElem;
        while (offsetParent && (!jQuery.nodeName(offsetParent, 'html') && jQuery.css(offsetParent, 'position') === 'static')) {
          offsetParent = offsetParent.offsetParent;
        }
        return offsetParent || docElem;
      });
    }
  });
  jQuery.each({
    scrollLeft: 'pageXOffset',
    scrollTop: 'pageYOffset'
  }, function (method, prop) {
    var top = 'pageYOffset' === prop;
    jQuery.fn[method] = function (val) {
      return jQuery.access(this, function (elem, method, val) {
        var win = getWindow(elem);
        if (val === undefined) {
          return win ? win[prop] : elem[method];
        }
        if (win) {
          win.scrollTo(!top ? val : window.pageXOffset, top ? val : window.pageYOffset);
        } else {
          elem[method] = val;
        }
      }, method, val, arguments.length, null);
    };
  });
  function getWindow(elem) {
    return jQuery.isWindow(elem) ? elem : elem.nodeType === 9 && elem.defaultView;
  }
  jQuery.each({
    Height: 'height',
    Width: 'width'
  }, function (name, type) {
    jQuery.each({
      padding: 'inner' + name,
      content: type,
      '': 'outer' + name
    }, function (defaultExtra, funcName) {
      jQuery.fn[funcName] = function (margin, value) {
        var chainable = arguments.length && (defaultExtra || typeof margin !== 'boolean'), extra = defaultExtra || (margin === true || value === true ? 'margin' : 'border');
        return jQuery.access(this, function (elem, type, value) {
          var doc;
          if (jQuery.isWindow(elem)) {
            return elem.document.documentElement['client' + name];
          }
          if (elem.nodeType === 9) {
            doc = elem.documentElement;
            return Math.max(elem.body['scroll' + name], doc['scroll' + name], elem.body['offset' + name], doc['offset' + name], doc['client' + name]);
          }
          return value === undefined ? jQuery.css(elem, type, extra) : jQuery.style(elem, type, value, extra);
        }, type, chainable ? margin : undefined, chainable, null);
      };
    });
  });
  jQuery.fn.size = function () {
    return this.length;
  };
  jQuery.fn.andSelf = jQuery.fn.addBack;
  if (typeof module === 'object' && module && typeof module.exports === 'object') {
    module.exports = jQuery;
  } else {
    if (typeof define === 'function' && define.amd) {
      define('jquery', [], function () {
        return jQuery;
      });
    }
  }
  if (typeof window === 'object' && typeof window.document === 'object') {
    window.jQuery = window.$ = jQuery;
  }
}(window));
(function ($, undefined) {
  var uuid = 0, runiqueId = /^ui-id-\d+$/;
  $.ui = $.ui || {};
  $.extend($.ui, {
    version: '1.10.4',
    keyCode: {
      BACKSPACE: 8,
      COMMA: 188,
      DELETE: 46,
      DOWN: 40,
      END: 35,
      ENTER: 13,
      ESCAPE: 27,
      HOME: 36,
      LEFT: 37,
      NUMPAD_ADD: 107,
      NUMPAD_DECIMAL: 110,
      NUMPAD_DIVIDE: 111,
      NUMPAD_ENTER: 108,
      NUMPAD_MULTIPLY: 106,
      NUMPAD_SUBTRACT: 109,
      PAGE_DOWN: 34,
      PAGE_UP: 33,
      PERIOD: 190,
      RIGHT: 39,
      SPACE: 32,
      TAB: 9,
      UP: 38
    }
  });
  $.fn.extend({
    focus: function (orig) {
      return function (delay, fn) {
        return typeof delay === 'number' ? this.each(function () {
          var elem = this;
          setTimeout(function () {
            $(elem).focus();
            if (fn) {
              fn.call(elem);
            }
          }, delay);
        }) : orig.apply(this, arguments);
      };
    }($.fn.focus),
    scrollParent: function () {
      var scrollParent;
      if ($.ui.ie && /(static|relative)/.test(this.css('position')) || /absolute/.test(this.css('position'))) {
        scrollParent = this.parents().filter(function () {
          return /(relative|absolute|fixed)/.test($.css(this, 'position')) && /(auto|scroll)/.test($.css(this, 'overflow') + $.css(this, 'overflow-y') + $.css(this, 'overflow-x'));
        }).eq(0);
      } else {
        scrollParent = this.parents().filter(function () {
          return /(auto|scroll)/.test($.css(this, 'overflow') + $.css(this, 'overflow-y') + $.css(this, 'overflow-x'));
        }).eq(0);
      }
      return /fixed/.test(this.css('position')) || !scrollParent.length ? $(document) : scrollParent;
    },
    zIndex: function (zIndex) {
      if (zIndex !== undefined) {
        return this.css('zIndex', zIndex);
      }
      if (this.length) {
        var elem = $(this[0]), position, value;
        while (elem.length && elem[0] !== document) {
          position = elem.css('position');
          if (position === 'absolute' || position === 'relative' || position === 'fixed') {
            value = parseInt(elem.css('zIndex'), 10);
            if (!isNaN(value) && value !== 0) {
              return value;
            }
          }
          elem = elem.parent();
        }
      }
      return 0;
    },
    uniqueId: function () {
      return this.each(function () {
        if (!this.id) {
          this.id = 'ui-id-' + ++uuid;
        }
      });
    },
    removeUniqueId: function () {
      return this.each(function () {
        if (runiqueId.test(this.id)) {
          $(this).removeAttr('id');
        }
      });
    }
  });
  function focusable(element, isTabIndexNotNaN) {
    var map, mapName, img, nodeName = element.nodeName.toLowerCase();
    if ('area' === nodeName) {
      map = element.parentNode;
      mapName = map.name;
      if (!element.href || !mapName || map.nodeName.toLowerCase() !== 'map') {
        return false;
      }
      img = $('img[usemap=#' + mapName + ']')[0];
      return !!img && visible(img);
    }
    return (/input|select|textarea|button|object/.test(nodeName) ? !element.disabled : 'a' === nodeName ? element.href || isTabIndexNotNaN : isTabIndexNotNaN) && visible(element);
  }
  function visible(element) {
    return $.expr.filters.visible(element) && !$(element).parents().addBack().filter(function () {
      return $.css(this, 'visibility') === 'hidden';
    }).length;
  }
  $.extend($.expr[':'], {
    data: $.expr.createPseudo ? $.expr.createPseudo(function (dataName) {
      return function (elem) {
        return !!$.data(elem, dataName);
      };
    }) : function (elem, i, match) {
      return !!$.data(elem, match[3]);
    },
    focusable: function (element) {
      return focusable(element, !isNaN($.attr(element, 'tabindex')));
    },
    tabbable: function (element) {
      var tabIndex = $.attr(element, 'tabindex'), isTabIndexNaN = isNaN(tabIndex);
      return (isTabIndexNaN || tabIndex >= 0) && focusable(element, !isTabIndexNaN);
    }
  });
  if (!$('<a>').outerWidth(1).jquery) {
    $.each([
      'Width',
      'Height'
    ], function (i, name) {
      var side = name === 'Width' ? [
          'Left',
          'Right'
        ] : [
          'Top',
          'Bottom'
        ], type = name.toLowerCase(), orig = {
          innerWidth: $.fn.innerWidth,
          innerHeight: $.fn.innerHeight,
          outerWidth: $.fn.outerWidth,
          outerHeight: $.fn.outerHeight
        };
      function reduce(elem, size, border, margin) {
        $.each(side, function () {
          size -= parseFloat($.css(elem, 'padding' + this)) || 0;
          if (border) {
            size -= parseFloat($.css(elem, 'border' + this + 'Width')) || 0;
          }
          if (margin) {
            size -= parseFloat($.css(elem, 'margin' + this)) || 0;
          }
        });
        return size;
      }
      $.fn['inner' + name] = function (size) {
        if (size === undefined) {
          return orig['inner' + name].call(this);
        }
        return this.each(function () {
          $(this).css(type, reduce(this, size) + 'px');
        });
      };
      $.fn['outer' + name] = function (size, margin) {
        if (typeof size !== 'number') {
          return orig['outer' + name].call(this, size);
        }
        return this.each(function () {
          $(this).css(type, reduce(this, size, true, margin) + 'px');
        });
      };
    });
  }
  if (!$.fn.addBack) {
    $.fn.addBack = function (selector) {
      return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
    };
  }
  if ($('<a>').data('a-b', 'a').removeData('a-b').data('a-b')) {
    $.fn.removeData = function (removeData) {
      return function (key) {
        if (arguments.length) {
          return removeData.call(this, $.camelCase(key));
        } else {
          return removeData.call(this);
        }
      };
    }($.fn.removeData);
  }
  $.ui.ie = !!/msie [\w.]+/.exec(navigator.userAgent.toLowerCase());
  $.support.selectstart = 'onselectstart' in document.createElement('div');
  $.fn.extend({
    disableSelection: function () {
      return this.bind(($.support.selectstart ? 'selectstart' : 'mousedown') + '.ui-disableSelection', function (event) {
        event.preventDefault();
      });
    },
    enableSelection: function () {
      return this.unbind('.ui-disableSelection');
    }
  });
  $.extend($.ui, {
    plugin: {
      add: function (module, option, set) {
        var i, proto = $.ui[module].prototype;
        for (i in set) {
          proto.plugins[i] = proto.plugins[i] || [];
          proto.plugins[i].push([
            option,
            set[i]
          ]);
        }
      },
      call: function (instance, name, args) {
        var i, set = instance.plugins[name];
        if (!set || !instance.element[0].parentNode || instance.element[0].parentNode.nodeType === 11) {
          return;
        }
        for (i = 0; i < set.length; i++) {
          if (instance.options[set[i][0]]) {
            set[i][1].apply(instance.element, args);
          }
        }
      }
    },
    hasScroll: function (el, a) {
      if ($(el).css('overflow') === 'hidden') {
        return false;
      }
      var scroll = a && a === 'left' ? 'scrollLeft' : 'scrollTop', has = false;
      if (el[scroll] > 0) {
        return true;
      }
      el[scroll] = 1;
      has = el[scroll] > 0;
      el[scroll] = 0;
      return has;
    }
  });
}(jQuery));
(function ($, undefined) {
  var uuid = 0, slice = Array.prototype.slice, _cleanData = $.cleanData;
  $.cleanData = function (elems) {
    for (var i = 0, elem; (elem = elems[i]) != null; i++) {
      try {
        $(elem).triggerHandler('remove');
      } catch (e) {
      }
    }
    _cleanData(elems);
  };
  $.widget = function (name, base, prototype) {
    var fullName, existingConstructor, constructor, basePrototype, proxiedPrototype = {}, namespace = name.split('.')[0];
    name = name.split('.')[1];
    fullName = namespace + '-' + name;
    if (!prototype) {
      prototype = base;
      base = $.Widget;
    }
    $.expr[':'][fullName.toLowerCase()] = function (elem) {
      return !!$.data(elem, fullName);
    };
    $[namespace] = $[namespace] || {};
    existingConstructor = $[namespace][name];
    constructor = $[namespace][name] = function (options, element) {
      if (!this._createWidget) {
        return new constructor(options, element);
      }
      if (arguments.length) {
        this._createWidget(options, element);
      }
    };
    $.extend(constructor, existingConstructor, {
      version: prototype.version,
      _proto: $.extend({}, prototype),
      _childConstructors: []
    });
    basePrototype = new base();
    basePrototype.options = $.widget.extend({}, basePrototype.options);
    $.each(prototype, function (prop, value) {
      if (!$.isFunction(value)) {
        proxiedPrototype[prop] = value;
        return;
      }
      proxiedPrototype[prop] = function () {
        var _super = function () {
            return base.prototype[prop].apply(this, arguments);
          }, _superApply = function (args) {
            return base.prototype[prop].apply(this, args);
          };
        return function () {
          var __super = this._super, __superApply = this._superApply, returnValue;
          this._super = _super;
          this._superApply = _superApply;
          returnValue = value.apply(this, arguments);
          this._super = __super;
          this._superApply = __superApply;
          return returnValue;
        };
      }();
    });
    constructor.prototype = $.widget.extend(basePrototype, { widgetEventPrefix: existingConstructor ? basePrototype.widgetEventPrefix || name : name }, proxiedPrototype, {
      constructor: constructor,
      namespace: namespace,
      widgetName: name,
      widgetFullName: fullName
    });
    if (existingConstructor) {
      $.each(existingConstructor._childConstructors, function (i, child) {
        var childPrototype = child.prototype;
        $.widget(childPrototype.namespace + '.' + childPrototype.widgetName, constructor, child._proto);
      });
      delete existingConstructor._childConstructors;
    } else {
      base._childConstructors.push(constructor);
    }
    $.widget.bridge(name, constructor);
  };
  $.widget.extend = function (target) {
    var input = slice.call(arguments, 1), inputIndex = 0, inputLength = input.length, key, value;
    for (; inputIndex < inputLength; inputIndex++) {
      for (key in input[inputIndex]) {
        value = input[inputIndex][key];
        if (input[inputIndex].hasOwnProperty(key) && value !== undefined) {
          if ($.isPlainObject(value)) {
            target[key] = $.isPlainObject(target[key]) ? $.widget.extend({}, target[key], value) : $.widget.extend({}, value);
          } else {
            target[key] = value;
          }
        }
      }
    }
    return target;
  };
  $.widget.bridge = function (name, object) {
    var fullName = object.prototype.widgetFullName || name;
    $.fn[name] = function (options) {
      var isMethodCall = typeof options === 'string', args = slice.call(arguments, 1), returnValue = this;
      options = !isMethodCall && args.length ? $.widget.extend.apply(null, [options].concat(args)) : options;
      if (isMethodCall) {
        this.each(function () {
          var methodValue, instance = $.data(this, fullName);
          if (!instance) {
            return $.error('cannot call methods on ' + name + ' prior to initialization; ' + 'attempted to call method \'' + options + '\'');
          }
          if (!$.isFunction(instance[options]) || options.charAt(0) === '_') {
            return $.error('no such method \'' + options + '\' for ' + name + ' widget instance');
          }
          methodValue = instance[options].apply(instance, args);
          if (methodValue !== instance && methodValue !== undefined) {
            returnValue = methodValue && methodValue.jquery ? returnValue.pushStack(methodValue.get()) : methodValue;
            return false;
          }
        });
      } else {
        this.each(function () {
          var instance = $.data(this, fullName);
          if (instance) {
            instance.option(options || {})._init();
          } else {
            $.data(this, fullName, new object(options, this));
          }
        });
      }
      return returnValue;
    };
  };
  $.Widget = function () {
  };
  $.Widget._childConstructors = [];
  $.Widget.prototype = {
    widgetName: 'widget',
    widgetEventPrefix: '',
    defaultElement: '<div>',
    options: {
      disabled: false,
      create: null
    },
    _createWidget: function (options, element) {
      element = $(element || this.defaultElement || this)[0];
      this.element = $(element);
      this.uuid = uuid++;
      this.eventNamespace = '.' + this.widgetName + this.uuid;
      this.options = $.widget.extend({}, this.options, this._getCreateOptions(), options);
      this.bindings = $();
      this.hoverable = $();
      this.focusable = $();
      if (element !== this) {
        $.data(element, this.widgetFullName, this);
        this._on(true, this.element, {
          remove: function (event) {
            if (event.target === element) {
              this.destroy();
            }
          }
        });
        this.document = $(element.style ? element.ownerDocument : element.document || element);
        this.window = $(this.document[0].defaultView || this.document[0].parentWindow);
      }
      this._create();
      this._trigger('create', null, this._getCreateEventData());
      this._init();
    },
    _getCreateOptions: $.noop,
    _getCreateEventData: $.noop,
    _create: $.noop,
    _init: $.noop,
    destroy: function () {
      this._destroy();
      this.element.unbind(this.eventNamespace).removeData(this.widgetName).removeData(this.widgetFullName).removeData($.camelCase(this.widgetFullName));
      this.widget().unbind(this.eventNamespace).removeAttr('aria-disabled').removeClass(this.widgetFullName + '-disabled ' + 'ui-state-disabled');
      this.bindings.unbind(this.eventNamespace);
      this.hoverable.removeClass('ui-state-hover');
      this.focusable.removeClass('ui-state-focus');
    },
    _destroy: $.noop,
    widget: function () {
      return this.element;
    },
    option: function (key, value) {
      var options = key, parts, curOption, i;
      if (arguments.length === 0) {
        return $.widget.extend({}, this.options);
      }
      if (typeof key === 'string') {
        options = {};
        parts = key.split('.');
        key = parts.shift();
        if (parts.length) {
          curOption = options[key] = $.widget.extend({}, this.options[key]);
          for (i = 0; i < parts.length - 1; i++) {
            curOption[parts[i]] = curOption[parts[i]] || {};
            curOption = curOption[parts[i]];
          }
          key = parts.pop();
          if (arguments.length === 1) {
            return curOption[key] === undefined ? null : curOption[key];
          }
          curOption[key] = value;
        } else {
          if (arguments.length === 1) {
            return this.options[key] === undefined ? null : this.options[key];
          }
          options[key] = value;
        }
      }
      this._setOptions(options);
      return this;
    },
    _setOptions: function (options) {
      var key;
      for (key in options) {
        this._setOption(key, options[key]);
      }
      return this;
    },
    _setOption: function (key, value) {
      this.options[key] = value;
      if (key === 'disabled') {
        this.widget().toggleClass(this.widgetFullName + '-disabled ui-state-disabled', !!value).attr('aria-disabled', value);
        this.hoverable.removeClass('ui-state-hover');
        this.focusable.removeClass('ui-state-focus');
      }
      return this;
    },
    enable: function () {
      return this._setOption('disabled', false);
    },
    disable: function () {
      return this._setOption('disabled', true);
    },
    _on: function (suppressDisabledCheck, element, handlers) {
      var delegateElement, instance = this;
      if (typeof suppressDisabledCheck !== 'boolean') {
        handlers = element;
        element = suppressDisabledCheck;
        suppressDisabledCheck = false;
      }
      if (!handlers) {
        handlers = element;
        element = this.element;
        delegateElement = this.widget();
      } else {
        element = delegateElement = $(element);
        this.bindings = this.bindings.add(element);
      }
      $.each(handlers, function (event, handler) {
        function handlerProxy() {
          if (!suppressDisabledCheck && (instance.options.disabled === true || $(this).hasClass('ui-state-disabled'))) {
            return;
          }
          return (typeof handler === 'string' ? instance[handler] : handler).apply(instance, arguments);
        }
        if (typeof handler !== 'string') {
          handlerProxy.guid = handler.guid = handler.guid || handlerProxy.guid || $.guid++;
        }
        var match = event.match(/^(\w+)\s*(.*)$/), eventName = match[1] + instance.eventNamespace, selector = match[2];
        if (selector) {
          delegateElement.delegate(selector, eventName, handlerProxy);
        } else {
          element.bind(eventName, handlerProxy);
        }
      });
    },
    _off: function (element, eventName) {
      eventName = (eventName || '').split(' ').join(this.eventNamespace + ' ') + this.eventNamespace;
      element.unbind(eventName).undelegate(eventName);
    },
    _delay: function (handler, delay) {
      function handlerProxy() {
        return (typeof handler === 'string' ? instance[handler] : handler).apply(instance, arguments);
      }
      var instance = this;
      return setTimeout(handlerProxy, delay || 0);
    },
    _hoverable: function (element) {
      this.hoverable = this.hoverable.add(element);
      this._on(element, {
        mouseenter: function (event) {
          $(event.currentTarget).addClass('ui-state-hover');
        },
        mouseleave: function (event) {
          $(event.currentTarget).removeClass('ui-state-hover');
        }
      });
    },
    _focusable: function (element) {
      this.focusable = this.focusable.add(element);
      this._on(element, {
        focusin: function (event) {
          $(event.currentTarget).addClass('ui-state-focus');
        },
        focusout: function (event) {
          $(event.currentTarget).removeClass('ui-state-focus');
        }
      });
    },
    _trigger: function (type, event, data) {
      var prop, orig, callback = this.options[type];
      data = data || {};
      event = $.Event(event);
      event.type = (type === this.widgetEventPrefix ? type : this.widgetEventPrefix + type).toLowerCase();
      event.target = this.element[0];
      orig = event.originalEvent;
      if (orig) {
        for (prop in orig) {
          if (!(prop in event)) {
            event[prop] = orig[prop];
          }
        }
      }
      this.element.trigger(event, data);
      return !($.isFunction(callback) && callback.apply(this.element[0], [event].concat(data)) === false || event.isDefaultPrevented());
    }
  };
  $.each({
    show: 'fadeIn',
    hide: 'fadeOut'
  }, function (method, defaultEffect) {
    $.Widget.prototype['_' + method] = function (element, options, callback) {
      if (typeof options === 'string') {
        options = { effect: options };
      }
      var hasOptions, effectName = !options ? method : options === true || typeof options === 'number' ? defaultEffect : options.effect || defaultEffect;
      options = options || {};
      if (typeof options === 'number') {
        options = { duration: options };
      }
      hasOptions = !$.isEmptyObject(options);
      options.complete = callback;
      if (options.delay) {
        element.delay(options.delay);
      }
      if (hasOptions && $.effects && $.effects.effect[effectName]) {
        element[method](options);
      } else if (effectName !== method && element[effectName]) {
        element[effectName](options.duration, options.easing, callback);
      } else {
        element.queue(function (next) {
          $(this)[method]();
          if (callback) {
            callback.call(element[0]);
          }
          next();
        });
      }
    };
  });
}(jQuery));
(function ($, undefined) {
  var mouseHandled = false;
  $(document).mouseup(function () {
    mouseHandled = false;
  });
  $.widget('ui.mouse', {
    version: '1.10.4',
    options: {
      cancel: 'input,textarea,button,select,option',
      distance: 1,
      delay: 0
    },
    _mouseInit: function () {
      var that = this;
      this.element.bind('mousedown.' + this.widgetName, function (event) {
        return that._mouseDown(event);
      }).bind('click.' + this.widgetName, function (event) {
        if (true === $.data(event.target, that.widgetName + '.preventClickEvent')) {
          $.removeData(event.target, that.widgetName + '.preventClickEvent');
          event.stopImmediatePropagation();
          return false;
        }
      });
      this.started = false;
    },
    _mouseDestroy: function () {
      this.element.unbind('.' + this.widgetName);
      if (this._mouseMoveDelegate) {
        $(document).unbind('mousemove.' + this.widgetName, this._mouseMoveDelegate).unbind('mouseup.' + this.widgetName, this._mouseUpDelegate);
      }
    },
    _mouseDown: function (event) {
      if (mouseHandled) {
        return;
      }
      this._mouseStarted && this._mouseUp(event);
      this._mouseDownEvent = event;
      var that = this, btnIsLeft = event.which === 1, elIsCancel = typeof this.options.cancel === 'string' && event.target.nodeName ? $(event.target).closest(this.options.cancel).length : false;
      if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {
        return true;
      }
      this.mouseDelayMet = !this.options.delay;
      if (!this.mouseDelayMet) {
        this._mouseDelayTimer = setTimeout(function () {
          that.mouseDelayMet = true;
        }, this.options.delay);
      }
      if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
        this._mouseStarted = this._mouseStart(event) !== false;
        if (!this._mouseStarted) {
          event.preventDefault();
          return true;
        }
      }
      if (true === $.data(event.target, this.widgetName + '.preventClickEvent')) {
        $.removeData(event.target, this.widgetName + '.preventClickEvent');
      }
      this._mouseMoveDelegate = function (event) {
        return that._mouseMove(event);
      };
      this._mouseUpDelegate = function (event) {
        return that._mouseUp(event);
      };
      $(document).bind('mousemove.' + this.widgetName, this._mouseMoveDelegate).bind('mouseup.' + this.widgetName, this._mouseUpDelegate);
      event.preventDefault();
      mouseHandled = true;
      return true;
    },
    _mouseMove: function (event) {
      if ($.ui.ie && (!document.documentMode || document.documentMode < 9) && !event.button) {
        return this._mouseUp(event);
      }
      if (this._mouseStarted) {
        this._mouseDrag(event);
        return event.preventDefault();
      }
      if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
        this._mouseStarted = this._mouseStart(this._mouseDownEvent, event) !== false;
        this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event);
      }
      return !this._mouseStarted;
    },
    _mouseUp: function (event) {
      $(document).unbind('mousemove.' + this.widgetName, this._mouseMoveDelegate).unbind('mouseup.' + this.widgetName, this._mouseUpDelegate);
      if (this._mouseStarted) {
        this._mouseStarted = false;
        if (event.target === this._mouseDownEvent.target) {
          $.data(event.target, this.widgetName + '.preventClickEvent', true);
        }
        this._mouseStop(event);
      }
      return false;
    },
    _mouseDistanceMet: function (event) {
      return Math.max(Math.abs(this._mouseDownEvent.pageX - event.pageX), Math.abs(this._mouseDownEvent.pageY - event.pageY)) >= this.options.distance;
    },
    _mouseDelayMet: function () {
      return this.mouseDelayMet;
    },
    _mouseStart: function () {
    },
    _mouseDrag: function () {
    },
    _mouseStop: function () {
    },
    _mouseCapture: function () {
      return true;
    }
  });
}(jQuery));
(function ($, undefined) {
  $.ui = $.ui || {};
  var cachedScrollbarWidth, max = Math.max, abs = Math.abs, round = Math.round, rhorizontal = /left|center|right/, rvertical = /top|center|bottom/, roffset = /[\+\-]\d+(\.[\d]+)?%?/, rposition = /^\w+/, rpercent = /%$/, _position = $.fn.position;
  function getOffsets(offsets, width, height) {
    return [
      parseFloat(offsets[0]) * (rpercent.test(offsets[0]) ? width / 100 : 1),
      parseFloat(offsets[1]) * (rpercent.test(offsets[1]) ? height / 100 : 1)
    ];
  }
  function parseCss(element, property) {
    return parseInt($.css(element, property), 10) || 0;
  }
  function getDimensions(elem) {
    var raw = elem[0];
    if (raw.nodeType === 9) {
      return {
        width: elem.width(),
        height: elem.height(),
        offset: {
          top: 0,
          left: 0
        }
      };
    }
    if ($.isWindow(raw)) {
      return {
        width: elem.width(),
        height: elem.height(),
        offset: {
          top: elem.scrollTop(),
          left: elem.scrollLeft()
        }
      };
    }
    if (raw.preventDefault) {
      return {
        width: 0,
        height: 0,
        offset: {
          top: raw.pageY,
          left: raw.pageX
        }
      };
    }
    return {
      width: elem.outerWidth(),
      height: elem.outerHeight(),
      offset: elem.offset()
    };
  }
  $.position = {
    scrollbarWidth: function () {
      if (cachedScrollbarWidth !== undefined) {
        return cachedScrollbarWidth;
      }
      var w1, w2, div = $('<div style=\'display:block;position:absolute;width:50px;height:50px;overflow:hidden;\'><div style=\'height:100px;width:auto;\'></div></div>'), innerDiv = div.children()[0];
      $('body').append(div);
      w1 = innerDiv.offsetWidth;
      div.css('overflow', 'scroll');
      w2 = innerDiv.offsetWidth;
      if (w1 === w2) {
        w2 = div[0].clientWidth;
      }
      div.remove();
      return cachedScrollbarWidth = w1 - w2;
    },
    getScrollInfo: function (within) {
      var overflowX = within.isWindow || within.isDocument ? '' : within.element.css('overflow-x'), overflowY = within.isWindow || within.isDocument ? '' : within.element.css('overflow-y'), hasOverflowX = overflowX === 'scroll' || overflowX === 'auto' && within.width < within.element[0].scrollWidth, hasOverflowY = overflowY === 'scroll' || overflowY === 'auto' && within.height < within.element[0].scrollHeight;
      return {
        width: hasOverflowY ? $.position.scrollbarWidth() : 0,
        height: hasOverflowX ? $.position.scrollbarWidth() : 0
      };
    },
    getWithinInfo: function (element) {
      var withinElement = $(element || window), isWindow = $.isWindow(withinElement[0]), isDocument = !!withinElement[0] && withinElement[0].nodeType === 9;
      return {
        element: withinElement,
        isWindow: isWindow,
        isDocument: isDocument,
        offset: withinElement.offset() || {
          left: 0,
          top: 0
        },
        scrollLeft: withinElement.scrollLeft(),
        scrollTop: withinElement.scrollTop(),
        width: isWindow ? withinElement.width() : withinElement.outerWidth(),
        height: isWindow ? withinElement.height() : withinElement.outerHeight()
      };
    }
  };
  $.fn.position = function (options) {
    if (!options || !options.of) {
      return _position.apply(this, arguments);
    }
    options = $.extend({}, options);
    var atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions, target = $(options.of), within = $.position.getWithinInfo(options.within), scrollInfo = $.position.getScrollInfo(within), collision = (options.collision || 'flip').split(' '), offsets = {};
    dimensions = getDimensions(target);
    if (target[0].preventDefault) {
      options.at = 'left top';
    }
    targetWidth = dimensions.width;
    targetHeight = dimensions.height;
    targetOffset = dimensions.offset;
    basePosition = $.extend({}, targetOffset);
    $.each([
      'my',
      'at'
    ], function () {
      var pos = (options[this] || '').split(' '), horizontalOffset, verticalOffset;
      if (pos.length === 1) {
        pos = rhorizontal.test(pos[0]) ? pos.concat(['center']) : rvertical.test(pos[0]) ? ['center'].concat(pos) : [
          'center',
          'center'
        ];
      }
      pos[0] = rhorizontal.test(pos[0]) ? pos[0] : 'center';
      pos[1] = rvertical.test(pos[1]) ? pos[1] : 'center';
      horizontalOffset = roffset.exec(pos[0]);
      verticalOffset = roffset.exec(pos[1]);
      offsets[this] = [
        horizontalOffset ? horizontalOffset[0] : 0,
        verticalOffset ? verticalOffset[0] : 0
      ];
      options[this] = [
        rposition.exec(pos[0])[0],
        rposition.exec(pos[1])[0]
      ];
    });
    if (collision.length === 1) {
      collision[1] = collision[0];
    }
    if (options.at[0] === 'right') {
      basePosition.left += targetWidth;
    } else if (options.at[0] === 'center') {
      basePosition.left += targetWidth / 2;
    }
    if (options.at[1] === 'bottom') {
      basePosition.top += targetHeight;
    } else if (options.at[1] === 'center') {
      basePosition.top += targetHeight / 2;
    }
    atOffset = getOffsets(offsets.at, targetWidth, targetHeight);
    basePosition.left += atOffset[0];
    basePosition.top += atOffset[1];
    return this.each(function () {
      var collisionPosition, using, elem = $(this), elemWidth = elem.outerWidth(), elemHeight = elem.outerHeight(), marginLeft = parseCss(this, 'marginLeft'), marginTop = parseCss(this, 'marginTop'), collisionWidth = elemWidth + marginLeft + parseCss(this, 'marginRight') + scrollInfo.width, collisionHeight = elemHeight + marginTop + parseCss(this, 'marginBottom') + scrollInfo.height, position = $.extend({}, basePosition), myOffset = getOffsets(offsets.my, elem.outerWidth(), elem.outerHeight());
      if (options.my[0] === 'right') {
        position.left -= elemWidth;
      } else if (options.my[0] === 'center') {
        position.left -= elemWidth / 2;
      }
      if (options.my[1] === 'bottom') {
        position.top -= elemHeight;
      } else if (options.my[1] === 'center') {
        position.top -= elemHeight / 2;
      }
      position.left += myOffset[0];
      position.top += myOffset[1];
      if (!$.support.offsetFractions) {
        position.left = round(position.left);
        position.top = round(position.top);
      }
      collisionPosition = {
        marginLeft: marginLeft,
        marginTop: marginTop
      };
      $.each([
        'left',
        'top'
      ], function (i, dir) {
        if ($.ui.position[collision[i]]) {
          $.ui.position[collision[i]][dir](position, {
            targetWidth: targetWidth,
            targetHeight: targetHeight,
            elemWidth: elemWidth,
            elemHeight: elemHeight,
            collisionPosition: collisionPosition,
            collisionWidth: collisionWidth,
            collisionHeight: collisionHeight,
            offset: [
              atOffset[0] + myOffset[0],
              atOffset[1] + myOffset[1]
            ],
            my: options.my,
            at: options.at,
            within: within,
            elem: elem
          });
        }
      });
      if (options.using) {
        using = function (props) {
          var left = targetOffset.left - position.left, right = left + targetWidth - elemWidth, top = targetOffset.top - position.top, bottom = top + targetHeight - elemHeight, feedback = {
              target: {
                element: target,
                left: targetOffset.left,
                top: targetOffset.top,
                width: targetWidth,
                height: targetHeight
              },
              element: {
                element: elem,
                left: position.left,
                top: position.top,
                width: elemWidth,
                height: elemHeight
              },
              horizontal: right < 0 ? 'left' : left > 0 ? 'right' : 'center',
              vertical: bottom < 0 ? 'top' : top > 0 ? 'bottom' : 'middle'
            };
          if (targetWidth < elemWidth && abs(left + right) < targetWidth) {
            feedback.horizontal = 'center';
          }
          if (targetHeight < elemHeight && abs(top + bottom) < targetHeight) {
            feedback.vertical = 'middle';
          }
          if (max(abs(left), abs(right)) > max(abs(top), abs(bottom))) {
            feedback.important = 'horizontal';
          } else {
            feedback.important = 'vertical';
          }
          options.using.call(this, props, feedback);
        };
      }
      elem.offset($.extend(position, { using: using }));
    });
  };
  $.ui.position = {
    fit: {
      left: function (position, data) {
        var within = data.within, withinOffset = within.isWindow ? within.scrollLeft : within.offset.left, outerWidth = within.width, collisionPosLeft = position.left - data.collisionPosition.marginLeft, overLeft = withinOffset - collisionPosLeft, overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset, newOverRight;
        if (data.collisionWidth > outerWidth) {
          if (overLeft > 0 && overRight <= 0) {
            newOverRight = position.left + overLeft + data.collisionWidth - outerWidth - withinOffset;
            position.left += overLeft - newOverRight;
          } else if (overRight > 0 && overLeft <= 0) {
            position.left = withinOffset;
          } else {
            if (overLeft > overRight) {
              position.left = withinOffset + outerWidth - data.collisionWidth;
            } else {
              position.left = withinOffset;
            }
          }
        } else if (overLeft > 0) {
          position.left += overLeft;
        } else if (overRight > 0) {
          position.left -= overRight;
        } else {
          position.left = max(position.left - collisionPosLeft, position.left);
        }
      },
      top: function (position, data) {
        var within = data.within, withinOffset = within.isWindow ? within.scrollTop : within.offset.top, outerHeight = data.within.height, collisionPosTop = position.top - data.collisionPosition.marginTop, overTop = withinOffset - collisionPosTop, overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset, newOverBottom;
        if (data.collisionHeight > outerHeight) {
          if (overTop > 0 && overBottom <= 0) {
            newOverBottom = position.top + overTop + data.collisionHeight - outerHeight - withinOffset;
            position.top += overTop - newOverBottom;
          } else if (overBottom > 0 && overTop <= 0) {
            position.top = withinOffset;
          } else {
            if (overTop > overBottom) {
              position.top = withinOffset + outerHeight - data.collisionHeight;
            } else {
              position.top = withinOffset;
            }
          }
        } else if (overTop > 0) {
          position.top += overTop;
        } else if (overBottom > 0) {
          position.top -= overBottom;
        } else {
          position.top = max(position.top - collisionPosTop, position.top);
        }
      }
    },
    flip: {
      left: function (position, data) {
        var within = data.within, withinOffset = within.offset.left + within.scrollLeft, outerWidth = within.width, offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left, collisionPosLeft = position.left - data.collisionPosition.marginLeft, overLeft = collisionPosLeft - offsetLeft, overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft, myOffset = data.my[0] === 'left' ? -data.elemWidth : data.my[0] === 'right' ? data.elemWidth : 0, atOffset = data.at[0] === 'left' ? data.targetWidth : data.at[0] === 'right' ? -data.targetWidth : 0, offset = -2 * data.offset[0], newOverRight, newOverLeft;
        if (overLeft < 0) {
          newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth - outerWidth - withinOffset;
          if (newOverRight < 0 || newOverRight < abs(overLeft)) {
            position.left += myOffset + atOffset + offset;
          }
        } else if (overRight > 0) {
          newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset + atOffset + offset - offsetLeft;
          if (newOverLeft > 0 || abs(newOverLeft) < overRight) {
            position.left += myOffset + atOffset + offset;
          }
        }
      },
      top: function (position, data) {
        var within = data.within, withinOffset = within.offset.top + within.scrollTop, outerHeight = within.height, offsetTop = within.isWindow ? within.scrollTop : within.offset.top, collisionPosTop = position.top - data.collisionPosition.marginTop, overTop = collisionPosTop - offsetTop, overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop, top = data.my[1] === 'top', myOffset = top ? -data.elemHeight : data.my[1] === 'bottom' ? data.elemHeight : 0, atOffset = data.at[1] === 'top' ? data.targetHeight : data.at[1] === 'bottom' ? -data.targetHeight : 0, offset = -2 * data.offset[1], newOverTop, newOverBottom;
        if (overTop < 0) {
          newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight - outerHeight - withinOffset;
          if (position.top + myOffset + atOffset + offset > overTop && (newOverBottom < 0 || newOverBottom < abs(overTop))) {
            position.top += myOffset + atOffset + offset;
          }
        } else if (overBottom > 0) {
          newOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset + offset - offsetTop;
          if (position.top + myOffset + atOffset + offset > overBottom && (newOverTop > 0 || abs(newOverTop) < overBottom)) {
            position.top += myOffset + atOffset + offset;
          }
        }
      }
    },
    flipfit: {
      left: function () {
        $.ui.position.flip.left.apply(this, arguments);
        $.ui.position.fit.left.apply(this, arguments);
      },
      top: function () {
        $.ui.position.flip.top.apply(this, arguments);
        $.ui.position.fit.top.apply(this, arguments);
      }
    }
  };
  (function () {
    var testElement, testElementParent, testElementStyle, offsetLeft, i, body = document.getElementsByTagName('body')[0], div = document.createElement('div');
    testElement = document.createElement(body ? 'div' : 'body');
    testElementStyle = {
      visibility: 'hidden',
      width: 0,
      height: 0,
      border: 0,
      margin: 0,
      background: 'none'
    };
    if (body) {
      $.extend(testElementStyle, {
        position: 'absolute',
        left: '-1000px',
        top: '-1000px'
      });
    }
    for (i in testElementStyle) {
      testElement.style[i] = testElementStyle[i];
    }
    testElement.appendChild(div);
    testElementParent = body || document.documentElement;
    testElementParent.insertBefore(testElement, testElementParent.firstChild);
    div.style.cssText = 'position: absolute; left: 10.7432222px;';
    offsetLeft = $(div).offset().left;
    $.support.offsetFractions = offsetLeft > 10 && offsetLeft < 11;
    testElement.innerHTML = '';
    testElementParent.removeChild(testElement);
  }());
}(jQuery));
(function ($, undefined) {
  var uid = 0, hideProps = {}, showProps = {};
  hideProps.height = hideProps.paddingTop = hideProps.paddingBottom = hideProps.borderTopWidth = hideProps.borderBottomWidth = 'hide';
  showProps.height = showProps.paddingTop = showProps.paddingBottom = showProps.borderTopWidth = showProps.borderBottomWidth = 'show';
  $.widget('ui.accordion', {
    version: '1.10.4',
    options: {
      active: 0,
      animate: {},
      collapsible: false,
      event: 'click',
      header: '> li > :first-child,> :not(li):even',
      heightStyle: 'auto',
      icons: {
        activeHeader: 'ui-icon-triangle-1-s',
        header: 'ui-icon-triangle-1-e'
      },
      activate: null,
      beforeActivate: null
    },
    _create: function () {
      var options = this.options;
      this.prevShow = this.prevHide = $();
      this.element.addClass('ui-accordion ui-widget ui-helper-reset').attr('role', 'tablist');
      if (!options.collapsible && (options.active === false || options.active == null)) {
        options.active = 0;
      }
      this._processPanels();
      if (options.active < 0) {
        options.active += this.headers.length;
      }
      this._refresh();
    },
    _getCreateEventData: function () {
      return {
        header: this.active,
        panel: !this.active.length ? $() : this.active.next(),
        content: !this.active.length ? $() : this.active.next()
      };
    },
    _createIcons: function () {
      var icons = this.options.icons;
      if (icons) {
        $('<span>').addClass('ui-accordion-header-icon ui-icon ' + icons.header).prependTo(this.headers);
        this.active.children('.ui-accordion-header-icon').removeClass(icons.header).addClass(icons.activeHeader);
        this.headers.addClass('ui-accordion-icons');
      }
    },
    _destroyIcons: function () {
      this.headers.removeClass('ui-accordion-icons').children('.ui-accordion-header-icon').remove();
    },
    _destroy: function () {
      var contents;
      this.element.removeClass('ui-accordion ui-widget ui-helper-reset').removeAttr('role');
      this.headers.removeClass('ui-accordion-header ui-accordion-header-active ui-helper-reset ui-state-default ui-corner-all ui-state-active ui-state-disabled ui-corner-top').removeAttr('role').removeAttr('aria-expanded').removeAttr('aria-selected').removeAttr('aria-controls').removeAttr('tabIndex').each(function () {
        if (/^ui-accordion/.test(this.id)) {
          this.removeAttribute('id');
        }
      });
      this._destroyIcons();
      contents = this.headers.next().css('display', '').removeAttr('role').removeAttr('aria-hidden').removeAttr('aria-labelledby').removeClass('ui-helper-reset ui-widget-content ui-corner-bottom ui-accordion-content ui-accordion-content-active ui-state-disabled').each(function () {
        if (/^ui-accordion/.test(this.id)) {
          this.removeAttribute('id');
        }
      });
      if (this.options.heightStyle !== 'content') {
        contents.css('height', '');
      }
    },
    _setOption: function (key, value) {
      if (key === 'active') {
        this._activate(value);
        return;
      }
      if (key === 'event') {
        if (this.options.event) {
          this._off(this.headers, this.options.event);
        }
        this._setupEvents(value);
      }
      this._super(key, value);
      if (key === 'collapsible' && !value && this.options.active === false) {
        this._activate(0);
      }
      if (key === 'icons') {
        this._destroyIcons();
        if (value) {
          this._createIcons();
        }
      }
      if (key === 'disabled') {
        this.headers.add(this.headers.next()).toggleClass('ui-state-disabled', !!value);
      }
    },
    _keydown: function (event) {
      if (event.altKey || event.ctrlKey) {
        return;
      }
      var keyCode = $.ui.keyCode, length = this.headers.length, currentIndex = this.headers.index(event.target), toFocus = false;
      switch (event.keyCode) {
      case keyCode.RIGHT:
      case keyCode.DOWN:
        toFocus = this.headers[(currentIndex + 1) % length];
        break;
      case keyCode.LEFT:
      case keyCode.UP:
        toFocus = this.headers[(currentIndex - 1 + length) % length];
        break;
      case keyCode.SPACE:
      case keyCode.ENTER:
        this._eventHandler(event);
        break;
      case keyCode.HOME:
        toFocus = this.headers[0];
        break;
      case keyCode.END:
        toFocus = this.headers[length - 1];
        break;
      }
      if (toFocus) {
        $(event.target).attr('tabIndex', -1);
        $(toFocus).attr('tabIndex', 0);
        toFocus.focus();
        event.preventDefault();
      }
    },
    _panelKeyDown: function (event) {
      if (event.keyCode === $.ui.keyCode.UP && event.ctrlKey) {
        $(event.currentTarget).prev().focus();
      }
    },
    refresh: function () {
      var options = this.options;
      this._processPanels();
      if (options.active === false && options.collapsible === true || !this.headers.length) {
        options.active = false;
        this.active = $();
      } else if (options.active === false) {
        this._activate(0);
      } else if (this.active.length && !$.contains(this.element[0], this.active[0])) {
        if (this.headers.length === this.headers.find('.ui-state-disabled').length) {
          options.active = false;
          this.active = $();
        } else {
          this._activate(Math.max(0, options.active - 1));
        }
      } else {
        options.active = this.headers.index(this.active);
      }
      this._destroyIcons();
      this._refresh();
    },
    _processPanels: function () {
      this.headers = this.element.find(this.options.header).addClass('ui-accordion-header ui-helper-reset ui-state-default ui-corner-all');
      this.headers.next().addClass('ui-accordion-content ui-helper-reset ui-widget-content ui-corner-bottom').filter(':not(.ui-accordion-content-active)').hide();
    },
    _refresh: function () {
      var maxHeight, options = this.options, heightStyle = options.heightStyle, parent = this.element.parent(), accordionId = this.accordionId = 'ui-accordion-' + (this.element.attr('id') || ++uid);
      this.active = this._findActive(options.active).addClass('ui-accordion-header-active ui-state-active ui-corner-top').removeClass('ui-corner-all');
      this.active.next().addClass('ui-accordion-content-active').show();
      this.headers.attr('role', 'tab').each(function (i) {
        var header = $(this), headerId = header.attr('id'), panel = header.next(), panelId = panel.attr('id');
        if (!headerId) {
          headerId = accordionId + '-header-' + i;
          header.attr('id', headerId);
        }
        if (!panelId) {
          panelId = accordionId + '-panel-' + i;
          panel.attr('id', panelId);
        }
        header.attr('aria-controls', panelId);
        panel.attr('aria-labelledby', headerId);
      }).next().attr('role', 'tabpanel');
      this.headers.not(this.active).attr({
        'aria-selected': 'false',
        'aria-expanded': 'false',
        tabIndex: -1
      }).next().attr({ 'aria-hidden': 'true' }).hide();
      if (!this.active.length) {
        this.headers.eq(0).attr('tabIndex', 0);
      } else {
        this.active.attr({
          'aria-selected': 'true',
          'aria-expanded': 'true',
          tabIndex: 0
        }).next().attr({ 'aria-hidden': 'false' });
      }
      this._createIcons();
      this._setupEvents(options.event);
      if (heightStyle === 'fill') {
        maxHeight = parent.height();
        this.element.siblings(':visible').each(function () {
          var elem = $(this), position = elem.css('position');
          if (position === 'absolute' || position === 'fixed') {
            return;
          }
          maxHeight -= elem.outerHeight(true);
        });
        this.headers.each(function () {
          maxHeight -= $(this).outerHeight(true);
        });
        this.headers.next().each(function () {
          $(this).height(Math.max(0, maxHeight - $(this).innerHeight() + $(this).height()));
        }).css('overflow', 'auto');
      } else if (heightStyle === 'auto') {
        maxHeight = 0;
        this.headers.next().each(function () {
          maxHeight = Math.max(maxHeight, $(this).css('height', '').height());
        }).height(maxHeight);
      }
    },
    _activate: function (index) {
      var active = this._findActive(index)[0];
      if (active === this.active[0]) {
        return;
      }
      active = active || this.active[0];
      this._eventHandler({
        target: active,
        currentTarget: active,
        preventDefault: $.noop
      });
    },
    _findActive: function (selector) {
      return typeof selector === 'number' ? this.headers.eq(selector) : $();
    },
    _setupEvents: function (event) {
      var events = { keydown: '_keydown' };
      if (event) {
        $.each(event.split(' '), function (index, eventName) {
          events[eventName] = '_eventHandler';
        });
      }
      this._off(this.headers.add(this.headers.next()));
      this._on(this.headers, events);
      this._on(this.headers.next(), { keydown: '_panelKeyDown' });
      this._hoverable(this.headers);
      this._focusable(this.headers);
    },
    _eventHandler: function (event) {
      var options = this.options, active = this.active, clicked = $(event.currentTarget), clickedIsActive = clicked[0] === active[0], collapsing = clickedIsActive && options.collapsible, toShow = collapsing ? $() : clicked.next(), toHide = active.next(), eventData = {
          oldHeader: active,
          oldPanel: toHide,
          newHeader: collapsing ? $() : clicked,
          newPanel: toShow
        };
      event.preventDefault();
      if (clickedIsActive && !options.collapsible || this._trigger('beforeActivate', event, eventData) === false) {
        return;
      }
      options.active = collapsing ? false : this.headers.index(clicked);
      this.active = clickedIsActive ? $() : clicked;
      this._toggle(eventData);
      active.removeClass('ui-accordion-header-active ui-state-active');
      if (options.icons) {
        active.children('.ui-accordion-header-icon').removeClass(options.icons.activeHeader).addClass(options.icons.header);
      }
      if (!clickedIsActive) {
        clicked.removeClass('ui-corner-all').addClass('ui-accordion-header-active ui-state-active ui-corner-top');
        if (options.icons) {
          clicked.children('.ui-accordion-header-icon').removeClass(options.icons.header).addClass(options.icons.activeHeader);
        }
        clicked.next().addClass('ui-accordion-content-active');
      }
    },
    _toggle: function (data) {
      var toShow = data.newPanel, toHide = this.prevShow.length ? this.prevShow : data.oldPanel;
      this.prevShow.add(this.prevHide).stop(true, true);
      this.prevShow = toShow;
      this.prevHide = toHide;
      if (this.options.animate) {
        this._animate(toShow, toHide, data);
      } else {
        toHide.hide();
        toShow.show();
        this._toggleComplete(data);
      }
      toHide.attr({ 'aria-hidden': 'true' });
      toHide.prev().attr('aria-selected', 'false');
      if (toShow.length && toHide.length) {
        toHide.prev().attr({
          'tabIndex': -1,
          'aria-expanded': 'false'
        });
      } else if (toShow.length) {
        this.headers.filter(function () {
          return $(this).attr('tabIndex') === 0;
        }).attr('tabIndex', -1);
      }
      toShow.attr('aria-hidden', 'false').prev().attr({
        'aria-selected': 'true',
        tabIndex: 0,
        'aria-expanded': 'true'
      });
    },
    _animate: function (toShow, toHide, data) {
      var total, easing, duration, that = this, adjust = 0, down = toShow.length && (!toHide.length || toShow.index() < toHide.index()), animate = this.options.animate || {}, options = down && animate.down || animate, complete = function () {
          that._toggleComplete(data);
        };
      if (typeof options === 'number') {
        duration = options;
      }
      if (typeof options === 'string') {
        easing = options;
      }
      easing = easing || options.easing || animate.easing;
      duration = duration || options.duration || animate.duration;
      if (!toHide.length) {
        return toShow.animate(showProps, duration, easing, complete);
      }
      if (!toShow.length) {
        return toHide.animate(hideProps, duration, easing, complete);
      }
      total = toShow.show().outerHeight();
      toHide.animate(hideProps, {
        duration: duration,
        easing: easing,
        step: function (now, fx) {
          fx.now = Math.round(now);
        }
      });
      toShow.hide().animate(showProps, {
        duration: duration,
        easing: easing,
        complete: complete,
        step: function (now, fx) {
          fx.now = Math.round(now);
          if (fx.prop !== 'height') {
            adjust += fx.now;
          } else if (that.options.heightStyle !== 'content') {
            fx.now = Math.round(total - toHide.outerHeight() - adjust);
            adjust = 0;
          }
        }
      });
    },
    _toggleComplete: function (data) {
      var toHide = data.oldPanel;
      toHide.removeClass('ui-accordion-content-active').prev().removeClass('ui-corner-top').addClass('ui-corner-all');
      if (toHide.length) {
        toHide.parent()[0].className = toHide.parent()[0].className;
      }
      this._trigger('activate', null, data);
    }
  });
}(jQuery));
(function ($, undefined) {
  $.widget('ui.autocomplete', {
    version: '1.10.4',
    defaultElement: '<input>',
    options: {
      appendTo: null,
      autoFocus: false,
      delay: 300,
      minLength: 1,
      position: {
        my: 'left top',
        at: 'left bottom',
        collision: 'none'
      },
      source: null,
      change: null,
      close: null,
      focus: null,
      open: null,
      response: null,
      search: null,
      select: null
    },
    requestIndex: 0,
    pending: 0,
    _create: function () {
      var suppressKeyPress, suppressKeyPressRepeat, suppressInput, nodeName = this.element[0].nodeName.toLowerCase(), isTextarea = nodeName === 'textarea', isInput = nodeName === 'input';
      this.isMultiLine = isTextarea ? true : isInput ? false : this.element.prop('isContentEditable');
      this.valueMethod = this.element[isTextarea || isInput ? 'val' : 'text'];
      this.isNewMenu = true;
      this.element.addClass('ui-autocomplete-input').attr('autocomplete', 'off');
      this._on(this.element, {
        keydown: function (event) {
          if (this.element.prop('readOnly')) {
            suppressKeyPress = true;
            suppressInput = true;
            suppressKeyPressRepeat = true;
            return;
          }
          suppressKeyPress = false;
          suppressInput = false;
          suppressKeyPressRepeat = false;
          var keyCode = $.ui.keyCode;
          switch (event.keyCode) {
          case keyCode.PAGE_UP:
            suppressKeyPress = true;
            this._move('previousPage', event);
            break;
          case keyCode.PAGE_DOWN:
            suppressKeyPress = true;
            this._move('nextPage', event);
            break;
          case keyCode.UP:
            suppressKeyPress = true;
            this._keyEvent('previous', event);
            break;
          case keyCode.DOWN:
            suppressKeyPress = true;
            this._keyEvent('next', event);
            break;
          case keyCode.ENTER:
          case keyCode.NUMPAD_ENTER:
            if (this.menu.active) {
              suppressKeyPress = true;
              event.preventDefault();
              this.menu.select(event);
            }
            break;
          case keyCode.TAB:
            if (this.menu.active) {
              this.menu.select(event);
            }
            break;
          case keyCode.ESCAPE:
            if (this.menu.element.is(':visible')) {
              this._value(this.term);
              this.close(event);
              event.preventDefault();
            }
            break;
          default:
            suppressKeyPressRepeat = true;
            this._searchTimeout(event);
            break;
          }
        },
        keypress: function (event) {
          if (suppressKeyPress) {
            suppressKeyPress = false;
            if (!this.isMultiLine || this.menu.element.is(':visible')) {
              event.preventDefault();
            }
            return;
          }
          if (suppressKeyPressRepeat) {
            return;
          }
          var keyCode = $.ui.keyCode;
          switch (event.keyCode) {
          case keyCode.PAGE_UP:
            this._move('previousPage', event);
            break;
          case keyCode.PAGE_DOWN:
            this._move('nextPage', event);
            break;
          case keyCode.UP:
            this._keyEvent('previous', event);
            break;
          case keyCode.DOWN:
            this._keyEvent('next', event);
            break;
          }
        },
        input: function (event) {
          if (suppressInput) {
            suppressInput = false;
            event.preventDefault();
            return;
          }
          this._searchTimeout(event);
        },
        focus: function () {
          this.selectedItem = null;
          this.previous = this._value();
        },
        blur: function (event) {
          if (this.cancelBlur) {
            delete this.cancelBlur;
            return;
          }
          clearTimeout(this.searching);
          this.close(event);
          this._change(event);
        }
      });
      this._initSource();
      this.menu = $('<ul>').addClass('ui-autocomplete ui-front').appendTo(this._appendTo()).menu({ role: null }).hide().data('ui-menu');
      this._on(this.menu.element, {
        mousedown: function (event) {
          event.preventDefault();
          this.cancelBlur = true;
          this._delay(function () {
            delete this.cancelBlur;
          });
          var menuElement = this.menu.element[0];
          if (!$(event.target).closest('.ui-menu-item').length) {
            this._delay(function () {
              var that = this;
              this.document.one('mousedown', function (event) {
                if (event.target !== that.element[0] && event.target !== menuElement && !$.contains(menuElement, event.target)) {
                  that.close();
                }
              });
            });
          }
        },
        menufocus: function (event, ui) {
          if (this.isNewMenu) {
            this.isNewMenu = false;
            if (event.originalEvent && /^mouse/.test(event.originalEvent.type)) {
              this.menu.blur();
              this.document.one('mousemove', function () {
                $(event.target).trigger(event.originalEvent);
              });
              return;
            }
          }
          var item = ui.item.data('ui-autocomplete-item');
          if (false !== this._trigger('focus', event, { item: item })) {
            if (event.originalEvent && /^key/.test(event.originalEvent.type)) {
              this._value(item.value);
            }
          } else {
            this.liveRegion.text(item.value);
          }
        },
        menuselect: function (event, ui) {
          var item = ui.item.data('ui-autocomplete-item'), previous = this.previous;
          if (this.element[0] !== this.document[0].activeElement) {
            this.element.focus();
            this.previous = previous;
            this._delay(function () {
              this.previous = previous;
              this.selectedItem = item;
            });
          }
          if (false !== this._trigger('select', event, { item: item })) {
            this._value(item.value);
          }
          this.term = this._value();
          this.close(event);
          this.selectedItem = item;
        }
      });
      this.liveRegion = $('<span>', {
        role: 'status',
        'aria-live': 'polite'
      }).addClass('ui-helper-hidden-accessible').insertBefore(this.element);
      this._on(this.window, {
        beforeunload: function () {
          this.element.removeAttr('autocomplete');
        }
      });
    },
    _destroy: function () {
      clearTimeout(this.searching);
      this.element.removeClass('ui-autocomplete-input').removeAttr('autocomplete');
      this.menu.element.remove();
      this.liveRegion.remove();
    },
    _setOption: function (key, value) {
      this._super(key, value);
      if (key === 'source') {
        this._initSource();
      }
      if (key === 'appendTo') {
        this.menu.element.appendTo(this._appendTo());
      }
      if (key === 'disabled' && value && this.xhr) {
        this.xhr.abort();
      }
    },
    _appendTo: function () {
      var element = this.options.appendTo;
      if (element) {
        element = element.jquery || element.nodeType ? $(element) : this.document.find(element).eq(0);
      }
      if (!element) {
        element = this.element.closest('.ui-front');
      }
      if (!element.length) {
        element = this.document[0].body;
      }
      return element;
    },
    _initSource: function () {
      var array, url, that = this;
      if ($.isArray(this.options.source)) {
        array = this.options.source;
        this.source = function (request, response) {
          response($.ui.autocomplete.filter(array, request.term));
        };
      } else if (typeof this.options.source === 'string') {
        url = this.options.source;
        this.source = function (request, response) {
          if (that.xhr) {
            that.xhr.abort();
          }
          that.xhr = $.ajax({
            url: url,
            data: request,
            dataType: 'json',
            success: function (data) {
              response(data);
            },
            error: function () {
              response([]);
            }
          });
        };
      } else {
        this.source = this.options.source;
      }
    },
    _searchTimeout: function (event) {
      clearTimeout(this.searching);
      this.searching = this._delay(function () {
        if (this.term !== this._value()) {
          this.selectedItem = null;
          this.search(null, event);
        }
      }, this.options.delay);
    },
    search: function (value, event) {
      value = value != null ? value : this._value();
      this.term = this._value();
      if (value.length < this.options.minLength) {
        return this.close(event);
      }
      if (this._trigger('search', event) === false) {
        return;
      }
      return this._search(value);
    },
    _search: function (value) {
      this.pending++;
      this.element.addClass('ui-autocomplete-loading');
      this.cancelSearch = false;
      this.source({ term: value }, this._response());
    },
    _response: function () {
      var index = ++this.requestIndex;
      return $.proxy(function (content) {
        if (index === this.requestIndex) {
          this.__response(content);
        }
        this.pending--;
        if (!this.pending) {
          this.element.removeClass('ui-autocomplete-loading');
        }
      }, this);
    },
    __response: function (content) {
      if (content) {
        content = this._normalize(content);
      }
      this._trigger('response', null, { content: content });
      if (!this.options.disabled && content && content.length && !this.cancelSearch) {
        this._suggest(content);
        this._trigger('open');
      } else {
        this._close();
      }
    },
    close: function (event) {
      this.cancelSearch = true;
      this._close(event);
    },
    _close: function (event) {
      if (this.menu.element.is(':visible')) {
        this.menu.element.hide();
        this.menu.blur();
        this.isNewMenu = true;
        this._trigger('close', event);
      }
    },
    _change: function (event) {
      if (this.previous !== this._value()) {
        this._trigger('change', event, { item: this.selectedItem });
      }
    },
    _normalize: function (items) {
      if (items.length && items[0].label && items[0].value) {
        return items;
      }
      return $.map(items, function (item) {
        if (typeof item === 'string') {
          return {
            label: item,
            value: item
          };
        }
        return $.extend({
          label: item.label || item.value,
          value: item.value || item.label
        }, item);
      });
    },
    _suggest: function (items) {
      var ul = this.menu.element.empty();
      this._renderMenu(ul, items);
      this.isNewMenu = true;
      this.menu.refresh();
      ul.show();
      this._resizeMenu();
      ul.position($.extend({ of: this.element }, this.options.position));
      if (this.options.autoFocus) {
        this.menu.next();
      }
    },
    _resizeMenu: function () {
      var ul = this.menu.element;
      ul.outerWidth(Math.max(ul.width('').outerWidth() + 1, this.element.outerWidth()));
    },
    _renderMenu: function (ul, items) {
      var that = this;
      $.each(items, function (index, item) {
        that._renderItemData(ul, item);
      });
    },
    _renderItemData: function (ul, item) {
      return this._renderItem(ul, item).data('ui-autocomplete-item', item);
    },
    _renderItem: function (ul, item) {
      return $('<li>').append($('<a>').text(item.label)).appendTo(ul);
    },
    _move: function (direction, event) {
      if (!this.menu.element.is(':visible')) {
        this.search(null, event);
        return;
      }
      if (this.menu.isFirstItem() && /^previous/.test(direction) || this.menu.isLastItem() && /^next/.test(direction)) {
        this._value(this.term);
        this.menu.blur();
        return;
      }
      this.menu[direction](event);
    },
    widget: function () {
      return this.menu.element;
    },
    _value: function () {
      return this.valueMethod.apply(this.element, arguments);
    },
    _keyEvent: function (keyEvent, event) {
      if (!this.isMultiLine || this.menu.element.is(':visible')) {
        this._move(keyEvent, event);
        event.preventDefault();
      }
    }
  });
  $.extend($.ui.autocomplete, {
    escapeRegex: function (value) {
      return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, '\\$&');
    },
    filter: function (array, term) {
      var matcher = new RegExp($.ui.autocomplete.escapeRegex(term), 'i');
      return $.grep(array, function (value) {
        return matcher.test(value.label || value.value || value);
      });
    }
  });
  $.widget('ui.autocomplete', $.ui.autocomplete, {
    options: {
      messages: {
        noResults: 'No search results.',
        results: function (amount) {
          return amount + (amount > 1 ? ' results are' : ' result is') + ' available, use up and down arrow keys to navigate.';
        }
      }
    },
    __response: function (content) {
      var message;
      this._superApply(arguments);
      if (this.options.disabled || this.cancelSearch) {
        return;
      }
      if (content && content.length) {
        message = this.options.messages.results(content.length);
      } else {
        message = this.options.messages.noResults;
      }
      this.liveRegion.text(message);
    }
  });
}(jQuery));
(function ($, undefined) {
  var lastActive, baseClasses = 'ui-button ui-widget ui-state-default ui-corner-all', typeClasses = 'ui-button-icons-only ui-button-icon-only ui-button-text-icons ui-button-text-icon-primary ui-button-text-icon-secondary ui-button-text-only', formResetHandler = function () {
      var form = $(this);
      setTimeout(function () {
        form.find(':ui-button').button('refresh');
      }, 1);
    }, radioGroup = function (radio) {
      var name = radio.name, form = radio.form, radios = $([]);
      if (name) {
        name = name.replace(/'/g, '\\\'');
        if (form) {
          radios = $(form).find('[name=\'' + name + '\']');
        } else {
          radios = $('[name=\'' + name + '\']', radio.ownerDocument).filter(function () {
            return !this.form;
          });
        }
      }
      return radios;
    };
  $.widget('ui.button', {
    version: '1.10.4',
    defaultElement: '<button>',
    options: {
      disabled: null,
      text: true,
      label: null,
      icons: {
        primary: null,
        secondary: null
      }
    },
    _create: function () {
      this.element.closest('form').unbind('reset' + this.eventNamespace).bind('reset' + this.eventNamespace, formResetHandler);
      if (typeof this.options.disabled !== 'boolean') {
        this.options.disabled = !!this.element.prop('disabled');
      } else {
        this.element.prop('disabled', this.options.disabled);
      }
      this._determineButtonType();
      this.hasTitle = !!this.buttonElement.attr('title');
      var that = this, options = this.options, toggleButton = this.type === 'checkbox' || this.type === 'radio', activeClass = !toggleButton ? 'ui-state-active' : '';
      if (options.label === null) {
        options.label = this.type === 'input' ? this.buttonElement.val() : this.buttonElement.html();
      }
      this._hoverable(this.buttonElement);
      this.buttonElement.addClass(baseClasses).attr('role', 'button').bind('mouseenter' + this.eventNamespace, function () {
        if (options.disabled) {
          return;
        }
        if (this === lastActive) {
          $(this).addClass('ui-state-active');
        }
      }).bind('mouseleave' + this.eventNamespace, function () {
        if (options.disabled) {
          return;
        }
        $(this).removeClass(activeClass);
      }).bind('click' + this.eventNamespace, function (event) {
        if (options.disabled) {
          event.preventDefault();
          event.stopImmediatePropagation();
        }
      });
      this._on({
        focus: function () {
          this.buttonElement.addClass('ui-state-focus');
        },
        blur: function () {
          this.buttonElement.removeClass('ui-state-focus');
        }
      });
      if (toggleButton) {
        this.element.bind('change' + this.eventNamespace, function () {
          that.refresh();
        });
      }
      if (this.type === 'checkbox') {
        this.buttonElement.bind('click' + this.eventNamespace, function () {
          if (options.disabled) {
            return false;
          }
        });
      } else if (this.type === 'radio') {
        this.buttonElement.bind('click' + this.eventNamespace, function () {
          if (options.disabled) {
            return false;
          }
          $(this).addClass('ui-state-active');
          that.buttonElement.attr('aria-pressed', 'true');
          var radio = that.element[0];
          radioGroup(radio).not(radio).map(function () {
            return $(this).button('widget')[0];
          }).removeClass('ui-state-active').attr('aria-pressed', 'false');
        });
      } else {
        this.buttonElement.bind('mousedown' + this.eventNamespace, function () {
          if (options.disabled) {
            return false;
          }
          $(this).addClass('ui-state-active');
          lastActive = this;
          that.document.one('mouseup', function () {
            lastActive = null;
          });
        }).bind('mouseup' + this.eventNamespace, function () {
          if (options.disabled) {
            return false;
          }
          $(this).removeClass('ui-state-active');
        }).bind('keydown' + this.eventNamespace, function (event) {
          if (options.disabled) {
            return false;
          }
          if (event.keyCode === $.ui.keyCode.SPACE || event.keyCode === $.ui.keyCode.ENTER) {
            $(this).addClass('ui-state-active');
          }
        }).bind('keyup' + this.eventNamespace + ' blur' + this.eventNamespace, function () {
          $(this).removeClass('ui-state-active');
        });
        if (this.buttonElement.is('a')) {
          this.buttonElement.keyup(function (event) {
            if (event.keyCode === $.ui.keyCode.SPACE) {
              $(this).click();
            }
          });
        }
      }
      this._setOption('disabled', options.disabled);
      this._resetButton();
    },
    _determineButtonType: function () {
      var ancestor, labelSelector, checked;
      if (this.element.is('[type=checkbox]')) {
        this.type = 'checkbox';
      } else if (this.element.is('[type=radio]')) {
        this.type = 'radio';
      } else if (this.element.is('input')) {
        this.type = 'input';
      } else {
        this.type = 'button';
      }
      if (this.type === 'checkbox' || this.type === 'radio') {
        ancestor = this.element.parents().last();
        labelSelector = 'label[for=\'' + this.element.attr('id') + '\']';
        this.buttonElement = ancestor.find(labelSelector);
        if (!this.buttonElement.length) {
          ancestor = ancestor.length ? ancestor.siblings() : this.element.siblings();
          this.buttonElement = ancestor.filter(labelSelector);
          if (!this.buttonElement.length) {
            this.buttonElement = ancestor.find(labelSelector);
          }
        }
        this.element.addClass('ui-helper-hidden-accessible');
        checked = this.element.is(':checked');
        if (checked) {
          this.buttonElement.addClass('ui-state-active');
        }
        this.buttonElement.prop('aria-pressed', checked);
      } else {
        this.buttonElement = this.element;
      }
    },
    widget: function () {
      return this.buttonElement;
    },
    _destroy: function () {
      this.element.removeClass('ui-helper-hidden-accessible');
      this.buttonElement.removeClass(baseClasses + ' ui-state-active ' + typeClasses).removeAttr('role').removeAttr('aria-pressed').html(this.buttonElement.find('.ui-button-text').html());
      if (!this.hasTitle) {
        this.buttonElement.removeAttr('title');
      }
    },
    _setOption: function (key, value) {
      this._super(key, value);
      if (key === 'disabled') {
        this.element.prop('disabled', !!value);
        if (value) {
          this.buttonElement.removeClass('ui-state-focus');
        }
        return;
      }
      this._resetButton();
    },
    refresh: function () {
      var isDisabled = this.element.is('input, button') ? this.element.is(':disabled') : this.element.hasClass('ui-button-disabled');
      if (isDisabled !== this.options.disabled) {
        this._setOption('disabled', isDisabled);
      }
      if (this.type === 'radio') {
        radioGroup(this.element[0]).each(function () {
          if ($(this).is(':checked')) {
            $(this).button('widget').addClass('ui-state-active').attr('aria-pressed', 'true');
          } else {
            $(this).button('widget').removeClass('ui-state-active').attr('aria-pressed', 'false');
          }
        });
      } else if (this.type === 'checkbox') {
        if (this.element.is(':checked')) {
          this.buttonElement.addClass('ui-state-active').attr('aria-pressed', 'true');
        } else {
          this.buttonElement.removeClass('ui-state-active').attr('aria-pressed', 'false');
        }
      }
    },
    _resetButton: function () {
      if (this.type === 'input') {
        if (this.options.label) {
          this.element.val(this.options.label);
        }
        return;
      }
      var buttonElement = this.buttonElement.removeClass(typeClasses), buttonText = $('<span></span>', this.document[0]).addClass('ui-button-text').html(this.options.label).appendTo(buttonElement.empty()).text(), icons = this.options.icons, multipleIcons = icons.primary && icons.secondary, buttonClasses = [];
      if (icons.primary || icons.secondary) {
        if (this.options.text) {
          buttonClasses.push('ui-button-text-icon' + (multipleIcons ? 's' : icons.primary ? '-primary' : '-secondary'));
        }
        if (icons.primary) {
          buttonElement.prepend('<span class=\'ui-button-icon-primary ui-icon ' + icons.primary + '\'></span>');
        }
        if (icons.secondary) {
          buttonElement.append('<span class=\'ui-button-icon-secondary ui-icon ' + icons.secondary + '\'></span>');
        }
        if (!this.options.text) {
          buttonClasses.push(multipleIcons ? 'ui-button-icons-only' : 'ui-button-icon-only');
          if (!this.hasTitle) {
            buttonElement.attr('title', $.trim(buttonText));
          }
        }
      } else {
        buttonClasses.push('ui-button-text-only');
      }
      buttonElement.addClass(buttonClasses.join(' '));
    }
  });
  $.widget('ui.buttonset', {
    version: '1.10.4',
    options: { items: 'button, input[type=button], input[type=submit], input[type=reset], input[type=checkbox], input[type=radio], a, :data(ui-button)' },
    _create: function () {
      this.element.addClass('ui-buttonset');
    },
    _init: function () {
      this.refresh();
    },
    _setOption: function (key, value) {
      if (key === 'disabled') {
        this.buttons.button('option', key, value);
      }
      this._super(key, value);
    },
    refresh: function () {
      var rtl = this.element.css('direction') === 'rtl';
      this.buttons = this.element.find(this.options.items).filter(':ui-button').button('refresh').end().not(':ui-button').button().end().map(function () {
        return $(this).button('widget')[0];
      }).removeClass('ui-corner-all ui-corner-left ui-corner-right').filter(':first').addClass(rtl ? 'ui-corner-right' : 'ui-corner-left').end().filter(':last').addClass(rtl ? 'ui-corner-left' : 'ui-corner-right').end().end();
    },
    _destroy: function () {
      this.element.removeClass('ui-buttonset');
      this.buttons.map(function () {
        return $(this).button('widget')[0];
      }).removeClass('ui-corner-left ui-corner-right').end().button('destroy');
    }
  });
}(jQuery));
(function ($, undefined) {
  $.extend($.ui, { datepicker: { version: '1.10.4' } });
  var PROP_NAME = 'datepicker', instActive;
  function Datepicker() {
    this._curInst = null;
    this._keyEvent = false;
    this._disabledInputs = [];
    this._datepickerShowing = false;
    this._inDialog = false;
    this._mainDivId = 'ui-datepicker-div';
    this._inlineClass = 'ui-datepicker-inline';
    this._appendClass = 'ui-datepicker-append';
    this._triggerClass = 'ui-datepicker-trigger';
    this._dialogClass = 'ui-datepicker-dialog';
    this._disableClass = 'ui-datepicker-disabled';
    this._unselectableClass = 'ui-datepicker-unselectable';
    this._currentClass = 'ui-datepicker-current-day';
    this._dayOverClass = 'ui-datepicker-days-cell-over';
    this.regional = [];
    this.regional[''] = {
      closeText: 'Done',
      prevText: 'Prev',
      nextText: 'Next',
      currentText: 'Today',
      monthNames: [
        'January',
        'February',
        'March',
        'April',
        'May',
        'June',
        'July',
        'August',
        'September',
        'October',
        'November',
        'December'
      ],
      monthNamesShort: [
        'Jan',
        'Feb',
        'Mar',
        'Apr',
        'May',
        'Jun',
        'Jul',
        'Aug',
        'Sep',
        'Oct',
        'Nov',
        'Dec'
      ],
      dayNames: [
        'Sunday',
        'Monday',
        'Tuesday',
        'Wednesday',
        'Thursday',
        'Friday',
        'Saturday'
      ],
      dayNamesShort: [
        'Sun',
        'Mon',
        'Tue',
        'Wed',
        'Thu',
        'Fri',
        'Sat'
      ],
      dayNamesMin: [
        'Su',
        'Mo',
        'Tu',
        'We',
        'Th',
        'Fr',
        'Sa'
      ],
      weekHeader: 'Wk',
      dateFormat: 'mm/dd/yy',
      firstDay: 0,
      isRTL: false,
      showMonthAfterYear: false,
      yearSuffix: ''
    };
    this._defaults = {
      showOn: 'focus',
      showAnim: 'fadeIn',
      showOptions: {},
      defaultDate: null,
      appendText: '',
      buttonText: '...',
      buttonImage: '',
      buttonImageOnly: false,
      hideIfNoPrevNext: false,
      navigationAsDateFormat: false,
      gotoCurrent: false,
      changeMonth: false,
      changeYear: false,
      yearRange: 'c-10:c+10',
      showOtherMonths: false,
      selectOtherMonths: false,
      showWeek: false,
      calculateWeek: this.iso8601Week,
      shortYearCutoff: '+10',
      minDate: null,
      maxDate: null,
      duration: 'fast',
      beforeShowDay: null,
      beforeShow: null,
      onSelect: null,
      onChangeMonthYear: null,
      onClose: null,
      numberOfMonths: 1,
      showCurrentAtPos: 0,
      stepMonths: 1,
      stepBigMonths: 12,
      altField: '',
      altFormat: '',
      constrainInput: true,
      showButtonPanel: false,
      autoSize: false,
      disabled: false
    };
    $.extend(this._defaults, this.regional['']);
    this.dpDiv = bindHover($('<div id=\'' + this._mainDivId + '\' class=\'ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all\'></div>'));
  }
  $.extend(Datepicker.prototype, {
    markerClassName: 'hasDatepicker',
    maxRows: 4,
    _widgetDatepicker: function () {
      return this.dpDiv;
    },
    setDefaults: function (settings) {
      extendRemove(this._defaults, settings || {});
      return this;
    },
    _attachDatepicker: function (target, settings) {
      var nodeName, inline, inst;
      nodeName = target.nodeName.toLowerCase();
      inline = nodeName === 'div' || nodeName === 'span';
      if (!target.id) {
        this.uuid += 1;
        target.id = 'dp' + this.uuid;
      }
      inst = this._newInst($(target), inline);
      inst.settings = $.extend({}, settings || {});
      if (nodeName === 'input') {
        this._connectDatepicker(target, inst);
      } else if (inline) {
        this._inlineDatepicker(target, inst);
      }
    },
    _newInst: function (target, inline) {
      var id = target[0].id.replace(/([^A-Za-z0-9_\-])/g, '\\\\$1');
      return {
        id: id,
        input: target,
        selectedDay: 0,
        selectedMonth: 0,
        selectedYear: 0,
        drawMonth: 0,
        drawYear: 0,
        inline: inline,
        dpDiv: !inline ? this.dpDiv : bindHover($('<div class=\'' + this._inlineClass + ' ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all\'></div>'))
      };
    },
    _connectDatepicker: function (target, inst) {
      var input = $(target);
      inst.append = $([]);
      inst.trigger = $([]);
      if (input.hasClass(this.markerClassName)) {
        return;
      }
      this._attachments(input, inst);
      input.addClass(this.markerClassName).keydown(this._doKeyDown).keypress(this._doKeyPress).keyup(this._doKeyUp);
      this._autoSize(inst);
      $.data(target, PROP_NAME, inst);
      if (inst.settings.disabled) {
        this._disableDatepicker(target);
      }
    },
    _attachments: function (input, inst) {
      var showOn, buttonText, buttonImage, appendText = this._get(inst, 'appendText'), isRTL = this._get(inst, 'isRTL');
      if (inst.append) {
        inst.append.remove();
      }
      if (appendText) {
        inst.append = $('<span class=\'' + this._appendClass + '\'>' + appendText + '</span>');
        input[isRTL ? 'before' : 'after'](inst.append);
      }
      input.unbind('focus', this._showDatepicker);
      if (inst.trigger) {
        inst.trigger.remove();
      }
      showOn = this._get(inst, 'showOn');
      if (showOn === 'focus' || showOn === 'both') {
        input.focus(this._showDatepicker);
      }
      if (showOn === 'button' || showOn === 'both') {
        buttonText = this._get(inst, 'buttonText');
        buttonImage = this._get(inst, 'buttonImage');
        inst.trigger = $(this._get(inst, 'buttonImageOnly') ? $('<img/>').addClass(this._triggerClass).attr({
          src: buttonImage,
          alt: buttonText,
          title: buttonText
        }) : $('<button type=\'button\'></button>').addClass(this._triggerClass).html(!buttonImage ? buttonText : $('<img/>').attr({
          src: buttonImage,
          alt: buttonText,
          title: buttonText
        })));
        input[isRTL ? 'before' : 'after'](inst.trigger);
        inst.trigger.click(function () {
          if ($.datepicker._datepickerShowing && $.datepicker._lastInput === input[0]) {
            $.datepicker._hideDatepicker();
          } else if ($.datepicker._datepickerShowing && $.datepicker._lastInput !== input[0]) {
            $.datepicker._hideDatepicker();
            $.datepicker._showDatepicker(input[0]);
          } else {
            $.datepicker._showDatepicker(input[0]);
          }
          return false;
        });
      }
    },
    _autoSize: function (inst) {
      if (this._get(inst, 'autoSize') && !inst.inline) {
        var findMax, max, maxI, i, date = new Date(2009, 12 - 1, 20), dateFormat = this._get(inst, 'dateFormat');
        if (dateFormat.match(/[DM]/)) {
          findMax = function (names) {
            max = 0;
            maxI = 0;
            for (i = 0; i < names.length; i++) {
              if (names[i].length > max) {
                max = names[i].length;
                maxI = i;
              }
            }
            return maxI;
          };
          date.setMonth(findMax(this._get(inst, dateFormat.match(/MM/) ? 'monthNames' : 'monthNamesShort')));
          date.setDate(findMax(this._get(inst, dateFormat.match(/DD/) ? 'dayNames' : 'dayNamesShort')) + 20 - date.getDay());
        }
        inst.input.attr('size', this._formatDate(inst, date).length);
      }
    },
    _inlineDatepicker: function (target, inst) {
      var divSpan = $(target);
      if (divSpan.hasClass(this.markerClassName)) {
        return;
      }
      divSpan.addClass(this.markerClassName).append(inst.dpDiv);
      $.data(target, PROP_NAME, inst);
      this._setDate(inst, this._getDefaultDate(inst), true);
      this._updateDatepicker(inst);
      this._updateAlternate(inst);
      if (inst.settings.disabled) {
        this._disableDatepicker(target);
      }
      inst.dpDiv.css('display', 'block');
    },
    _dialogDatepicker: function (input, date, onSelect, settings, pos) {
      var id, browserWidth, browserHeight, scrollX, scrollY, inst = this._dialogInst;
      if (!inst) {
        this.uuid += 1;
        id = 'dp' + this.uuid;
        this._dialogInput = $('<input type=\'text\' id=\'' + id + '\' style=\'position: absolute; top: -100px; width: 0px;\'/>');
        this._dialogInput.keydown(this._doKeyDown);
        $('body').append(this._dialogInput);
        inst = this._dialogInst = this._newInst(this._dialogInput, false);
        inst.settings = {};
        $.data(this._dialogInput[0], PROP_NAME, inst);
      }
      extendRemove(inst.settings, settings || {});
      date = date && date.constructor === Date ? this._formatDate(inst, date) : date;
      this._dialogInput.val(date);
      this._pos = pos ? pos.length ? pos : [
        pos.pageX,
        pos.pageY
      ] : null;
      if (!this._pos) {
        browserWidth = document.documentElement.clientWidth;
        browserHeight = document.documentElement.clientHeight;
        scrollX = document.documentElement.scrollLeft || document.body.scrollLeft;
        scrollY = document.documentElement.scrollTop || document.body.scrollTop;
        this._pos = [
          browserWidth / 2 - 100 + scrollX,
          browserHeight / 2 - 150 + scrollY
        ];
      }
      this._dialogInput.css('left', this._pos[0] + 20 + 'px').css('top', this._pos[1] + 'px');
      inst.settings.onSelect = onSelect;
      this._inDialog = true;
      this.dpDiv.addClass(this._dialogClass);
      this._showDatepicker(this._dialogInput[0]);
      if ($.blockUI) {
        $.blockUI(this.dpDiv);
      }
      $.data(this._dialogInput[0], PROP_NAME, inst);
      return this;
    },
    _destroyDatepicker: function (target) {
      var nodeName, $target = $(target), inst = $.data(target, PROP_NAME);
      if (!$target.hasClass(this.markerClassName)) {
        return;
      }
      nodeName = target.nodeName.toLowerCase();
      $.removeData(target, PROP_NAME);
      if (nodeName === 'input') {
        inst.append.remove();
        inst.trigger.remove();
        $target.removeClass(this.markerClassName).unbind('focus', this._showDatepicker).unbind('keydown', this._doKeyDown).unbind('keypress', this._doKeyPress).unbind('keyup', this._doKeyUp);
      } else if (nodeName === 'div' || nodeName === 'span') {
        $target.removeClass(this.markerClassName).empty();
      }
    },
    _enableDatepicker: function (target) {
      var nodeName, inline, $target = $(target), inst = $.data(target, PROP_NAME);
      if (!$target.hasClass(this.markerClassName)) {
        return;
      }
      nodeName = target.nodeName.toLowerCase();
      if (nodeName === 'input') {
        target.disabled = false;
        inst.trigger.filter('button').each(function () {
          this.disabled = false;
        }).end().filter('img').css({
          opacity: '1.0',
          cursor: ''
        });
      } else if (nodeName === 'div' || nodeName === 'span') {
        inline = $target.children('.' + this._inlineClass);
        inline.children().removeClass('ui-state-disabled');
        inline.find('select.ui-datepicker-month, select.ui-datepicker-year').prop('disabled', false);
      }
      this._disabledInputs = $.map(this._disabledInputs, function (value) {
        return value === target ? null : value;
      });
    },
    _disableDatepicker: function (target) {
      var nodeName, inline, $target = $(target), inst = $.data(target, PROP_NAME);
      if (!$target.hasClass(this.markerClassName)) {
        return;
      }
      nodeName = target.nodeName.toLowerCase();
      if (nodeName === 'input') {
        target.disabled = true;
        inst.trigger.filter('button').each(function () {
          this.disabled = true;
        }).end().filter('img').css({
          opacity: '0.5',
          cursor: 'default'
        });
      } else if (nodeName === 'div' || nodeName === 'span') {
        inline = $target.children('.' + this._inlineClass);
        inline.children().addClass('ui-state-disabled');
        inline.find('select.ui-datepicker-month, select.ui-datepicker-year').prop('disabled', true);
      }
      this._disabledInputs = $.map(this._disabledInputs, function (value) {
        return value === target ? null : value;
      });
      this._disabledInputs[this._disabledInputs.length] = target;
    },
    _isDisabledDatepicker: function (target) {
      if (!target) {
        return false;
      }
      for (var i = 0; i < this._disabledInputs.length; i++) {
        if (this._disabledInputs[i] === target) {
          return true;
        }
      }
      return false;
    },
    _getInst: function (target) {
      try {
        return $.data(target, PROP_NAME);
      } catch (err) {
        throw 'Missing instance data for this datepicker';
      }
    },
    _optionDatepicker: function (target, name, value) {
      var settings, date, minDate, maxDate, inst = this._getInst(target);
      if (arguments.length === 2 && typeof name === 'string') {
        return name === 'defaults' ? $.extend({}, $.datepicker._defaults) : inst ? name === 'all' ? $.extend({}, inst.settings) : this._get(inst, name) : null;
      }
      settings = name || {};
      if (typeof name === 'string') {
        settings = {};
        settings[name] = value;
      }
      if (inst) {
        if (this._curInst === inst) {
          this._hideDatepicker();
        }
        date = this._getDateDatepicker(target, true);
        minDate = this._getMinMaxDate(inst, 'min');
        maxDate = this._getMinMaxDate(inst, 'max');
        extendRemove(inst.settings, settings);
        if (minDate !== null && settings.dateFormat !== undefined && settings.minDate === undefined) {
          inst.settings.minDate = this._formatDate(inst, minDate);
        }
        if (maxDate !== null && settings.dateFormat !== undefined && settings.maxDate === undefined) {
          inst.settings.maxDate = this._formatDate(inst, maxDate);
        }
        if ('disabled' in settings) {
          if (settings.disabled) {
            this._disableDatepicker(target);
          } else {
            this._enableDatepicker(target);
          }
        }
        this._attachments($(target), inst);
        this._autoSize(inst);
        this._setDate(inst, date);
        this._updateAlternate(inst);
        this._updateDatepicker(inst);
      }
    },
    _changeDatepicker: function (target, name, value) {
      this._optionDatepicker(target, name, value);
    },
    _refreshDatepicker: function (target) {
      var inst = this._getInst(target);
      if (inst) {
        this._updateDatepicker(inst);
      }
    },
    _setDateDatepicker: function (target, date) {
      var inst = this._getInst(target);
      if (inst) {
        this._setDate(inst, date);
        this._updateDatepicker(inst);
        this._updateAlternate(inst);
      }
    },
    _getDateDatepicker: function (target, noDefault) {
      var inst = this._getInst(target);
      if (inst && !inst.inline) {
        this._setDateFromField(inst, noDefault);
      }
      return inst ? this._getDate(inst) : null;
    },
    _doKeyDown: function (event) {
      var onSelect, dateStr, sel, inst = $.datepicker._getInst(event.target), handled = true, isRTL = inst.dpDiv.is('.ui-datepicker-rtl');
      inst._keyEvent = true;
      if ($.datepicker._datepickerShowing) {
        switch (event.keyCode) {
        case 9:
          $.datepicker._hideDatepicker();
          handled = false;
          break;
        case 13:
          sel = $('td.' + $.datepicker._dayOverClass + ':not(.' + $.datepicker._currentClass + ')', inst.dpDiv);
          if (sel[0]) {
            $.datepicker._selectDay(event.target, inst.selectedMonth, inst.selectedYear, sel[0]);
          }
          onSelect = $.datepicker._get(inst, 'onSelect');
          if (onSelect) {
            dateStr = $.datepicker._formatDate(inst);
            onSelect.apply(inst.input ? inst.input[0] : null, [
              dateStr,
              inst
            ]);
          } else {
            $.datepicker._hideDatepicker();
          }
          return false;
        case 27:
          $.datepicker._hideDatepicker();
          break;
        case 33:
          $.datepicker._adjustDate(event.target, event.ctrlKey ? -$.datepicker._get(inst, 'stepBigMonths') : -$.datepicker._get(inst, 'stepMonths'), 'M');
          break;
        case 34:
          $.datepicker._adjustDate(event.target, event.ctrlKey ? +$.datepicker._get(inst, 'stepBigMonths') : +$.datepicker._get(inst, 'stepMonths'), 'M');
          break;
        case 35:
          if (event.ctrlKey || event.metaKey) {
            $.datepicker._clearDate(event.target);
          }
          handled = event.ctrlKey || event.metaKey;
          break;
        case 36:
          if (event.ctrlKey || event.metaKey) {
            $.datepicker._gotoToday(event.target);
          }
          handled = event.ctrlKey || event.metaKey;
          break;
        case 37:
          if (event.ctrlKey || event.metaKey) {
            $.datepicker._adjustDate(event.target, isRTL ? +1 : -1, 'D');
          }
          handled = event.ctrlKey || event.metaKey;
          if (event.originalEvent.altKey) {
            $.datepicker._adjustDate(event.target, event.ctrlKey ? -$.datepicker._get(inst, 'stepBigMonths') : -$.datepicker._get(inst, 'stepMonths'), 'M');
          }
          break;
        case 38:
          if (event.ctrlKey || event.metaKey) {
            $.datepicker._adjustDate(event.target, -7, 'D');
          }
          handled = event.ctrlKey || event.metaKey;
          break;
        case 39:
          if (event.ctrlKey || event.metaKey) {
            $.datepicker._adjustDate(event.target, isRTL ? -1 : +1, 'D');
          }
          handled = event.ctrlKey || event.metaKey;
          if (event.originalEvent.altKey) {
            $.datepicker._adjustDate(event.target, event.ctrlKey ? +$.datepicker._get(inst, 'stepBigMonths') : +$.datepicker._get(inst, 'stepMonths'), 'M');
          }
          break;
        case 40:
          if (event.ctrlKey || event.metaKey) {
            $.datepicker._adjustDate(event.target, +7, 'D');
          }
          handled = event.ctrlKey || event.metaKey;
          break;
        default:
          handled = false;
        }
      } else if (event.keyCode === 36 && event.ctrlKey) {
        $.datepicker._showDatepicker(this);
      } else {
        handled = false;
      }
      if (handled) {
        event.preventDefault();
        event.stopPropagation();
      }
    },
    _doKeyPress: function (event) {
      var chars, chr, inst = $.datepicker._getInst(event.target);
      if ($.datepicker._get(inst, 'constrainInput')) {
        chars = $.datepicker._possibleChars($.datepicker._get(inst, 'dateFormat'));
        chr = String.fromCharCode(event.charCode == null ? event.keyCode : event.charCode);
        return event.ctrlKey || event.metaKey || (chr < ' ' || !chars || chars.indexOf(chr) > -1);
      }
    },
    _doKeyUp: function (event) {
      var date, inst = $.datepicker._getInst(event.target);
      if (inst.input.val() !== inst.lastVal) {
        try {
          date = $.datepicker.parseDate($.datepicker._get(inst, 'dateFormat'), inst.input ? inst.input.val() : null, $.datepicker._getFormatConfig(inst));
          if (date) {
            $.datepicker._setDateFromField(inst);
            $.datepicker._updateAlternate(inst);
            $.datepicker._updateDatepicker(inst);
          }
        } catch (err) {
        }
      }
      return true;
    },
    _showDatepicker: function (input) {
      input = input.target || input;
      if (input.nodeName.toLowerCase() !== 'input') {
        input = $('input', input.parentNode)[0];
      }
      if ($.datepicker._isDisabledDatepicker(input) || $.datepicker._lastInput === input) {
        return;
      }
      var inst, beforeShow, beforeShowSettings, isFixed, offset, showAnim, duration;
      inst = $.datepicker._getInst(input);
      if ($.datepicker._curInst && $.datepicker._curInst !== inst) {
        $.datepicker._curInst.dpDiv.stop(true, true);
        if (inst && $.datepicker._datepickerShowing) {
          $.datepicker._hideDatepicker($.datepicker._curInst.input[0]);
        }
      }
      beforeShow = $.datepicker._get(inst, 'beforeShow');
      beforeShowSettings = beforeShow ? beforeShow.apply(input, [
        input,
        inst
      ]) : {};
      if (beforeShowSettings === false) {
        return;
      }
      extendRemove(inst.settings, beforeShowSettings);
      inst.lastVal = null;
      $.datepicker._lastInput = input;
      $.datepicker._setDateFromField(inst);
      if ($.datepicker._inDialog) {
        input.value = '';
      }
      if (!$.datepicker._pos) {
        $.datepicker._pos = $.datepicker._findPos(input);
        $.datepicker._pos[1] += input.offsetHeight;
      }
      isFixed = false;
      $(input).parents().each(function () {
        isFixed |= $(this).css('position') === 'fixed';
        return !isFixed;
      });
      offset = {
        left: $.datepicker._pos[0],
        top: $.datepicker._pos[1]
      };
      $.datepicker._pos = null;
      inst.dpDiv.empty();
      inst.dpDiv.css({
        position: 'absolute',
        display: 'block',
        top: '-1000px'
      });
      $.datepicker._updateDatepicker(inst);
      offset = $.datepicker._checkOffset(inst, offset, isFixed);
      inst.dpDiv.css({
        position: $.datepicker._inDialog && $.blockUI ? 'static' : isFixed ? 'fixed' : 'absolute',
        display: 'none',
        left: offset.left + 'px',
        top: offset.top + 'px'
      });
      if (!inst.inline) {
        showAnim = $.datepicker._get(inst, 'showAnim');
        duration = $.datepicker._get(inst, 'duration');
        inst.dpDiv.zIndex($(input).zIndex() + 1);
        $.datepicker._datepickerShowing = true;
        if ($.effects && $.effects.effect[showAnim]) {
          inst.dpDiv.show(showAnim, $.datepicker._get(inst, 'showOptions'), duration);
        } else {
          inst.dpDiv[showAnim || 'show'](showAnim ? duration : null);
        }
        if ($.datepicker._shouldFocusInput(inst)) {
          inst.input.focus();
        }
        $.datepicker._curInst = inst;
      }
    },
    _updateDatepicker: function (inst) {
      this.maxRows = 4;
      instActive = inst;
      inst.dpDiv.empty().append(this._generateHTML(inst));
      this._attachHandlers(inst);
      inst.dpDiv.find('.' + this._dayOverClass + ' a').mouseover();
      var origyearshtml, numMonths = this._getNumberOfMonths(inst), cols = numMonths[1], width = 17;
      inst.dpDiv.removeClass('ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4').width('');
      if (cols > 1) {
        inst.dpDiv.addClass('ui-datepicker-multi-' + cols).css('width', width * cols + 'em');
      }
      inst.dpDiv[(numMonths[0] !== 1 || numMonths[1] !== 1 ? 'add' : 'remove') + 'Class']('ui-datepicker-multi');
      inst.dpDiv[(this._get(inst, 'isRTL') ? 'add' : 'remove') + 'Class']('ui-datepicker-rtl');
      if (inst === $.datepicker._curInst && $.datepicker._datepickerShowing && $.datepicker._shouldFocusInput(inst)) {
        inst.input.focus();
      }
      if (inst.yearshtml) {
        origyearshtml = inst.yearshtml;
        setTimeout(function () {
          if (origyearshtml === inst.yearshtml && inst.yearshtml) {
            inst.dpDiv.find('select.ui-datepicker-year:first').replaceWith(inst.yearshtml);
          }
          origyearshtml = inst.yearshtml = null;
        }, 0);
      }
    },
    _shouldFocusInput: function (inst) {
      return inst.input && inst.input.is(':visible') && !inst.input.is(':disabled') && !inst.input.is(':focus');
    },
    _checkOffset: function (inst, offset, isFixed) {
      var dpWidth = inst.dpDiv.outerWidth(), dpHeight = inst.dpDiv.outerHeight(), inputWidth = inst.input ? inst.input.outerWidth() : 0, inputHeight = inst.input ? inst.input.outerHeight() : 0, viewWidth = document.documentElement.clientWidth + (isFixed ? 0 : $(document).scrollLeft()), viewHeight = document.documentElement.clientHeight + (isFixed ? 0 : $(document).scrollTop());
      offset.left -= this._get(inst, 'isRTL') ? dpWidth - inputWidth : 0;
      offset.left -= isFixed && offset.left === inst.input.offset().left ? $(document).scrollLeft() : 0;
      offset.top -= isFixed && offset.top === inst.input.offset().top + inputHeight ? $(document).scrollTop() : 0;
      offset.left -= Math.min(offset.left, offset.left + dpWidth > viewWidth && viewWidth > dpWidth ? Math.abs(offset.left + dpWidth - viewWidth) : 0);
      offset.top -= Math.min(offset.top, offset.top + dpHeight > viewHeight && viewHeight > dpHeight ? Math.abs(dpHeight + inputHeight) : 0);
      return offset;
    },
    _findPos: function (obj) {
      var position, inst = this._getInst(obj), isRTL = this._get(inst, 'isRTL');
      while (obj && (obj.type === 'hidden' || obj.nodeType !== 1 || $.expr.filters.hidden(obj))) {
        obj = obj[isRTL ? 'previousSibling' : 'nextSibling'];
      }
      position = $(obj).offset();
      return [
        position.left,
        position.top
      ];
    },
    _hideDatepicker: function (input) {
      var showAnim, duration, postProcess, onClose, inst = this._curInst;
      if (!inst || input && inst !== $.data(input, PROP_NAME)) {
        return;
      }
      if (this._datepickerShowing) {
        showAnim = this._get(inst, 'showAnim');
        duration = this._get(inst, 'duration');
        postProcess = function () {
          $.datepicker._tidyDialog(inst);
        };
        if ($.effects && ($.effects.effect[showAnim] || $.effects[showAnim])) {
          inst.dpDiv.hide(showAnim, $.datepicker._get(inst, 'showOptions'), duration, postProcess);
        } else {
          inst.dpDiv[showAnim === 'slideDown' ? 'slideUp' : showAnim === 'fadeIn' ? 'fadeOut' : 'hide'](showAnim ? duration : null, postProcess);
        }
        if (!showAnim) {
          postProcess();
        }
        this._datepickerShowing = false;
        onClose = this._get(inst, 'onClose');
        if (onClose) {
          onClose.apply(inst.input ? inst.input[0] : null, [
            inst.input ? inst.input.val() : '',
            inst
          ]);
        }
        this._lastInput = null;
        if (this._inDialog) {
          this._dialogInput.css({
            position: 'absolute',
            left: '0',
            top: '-100px'
          });
          if ($.blockUI) {
            $.unblockUI();
            $('body').append(this.dpDiv);
          }
        }
        this._inDialog = false;
      }
    },
    _tidyDialog: function (inst) {
      inst.dpDiv.removeClass(this._dialogClass).unbind('.ui-datepicker-calendar');
    },
    _checkExternalClick: function (event) {
      if (!$.datepicker._curInst) {
        return;
      }
      var $target = $(event.target), inst = $.datepicker._getInst($target[0]);
      if ($target[0].id !== $.datepicker._mainDivId && $target.parents('#' + $.datepicker._mainDivId).length === 0 && !$target.hasClass($.datepicker.markerClassName) && !$target.closest('.' + $.datepicker._triggerClass).length && $.datepicker._datepickerShowing && !($.datepicker._inDialog && $.blockUI) || $target.hasClass($.datepicker.markerClassName) && $.datepicker._curInst !== inst) {
        $.datepicker._hideDatepicker();
      }
    },
    _adjustDate: function (id, offset, period) {
      var target = $(id), inst = this._getInst(target[0]);
      if (this._isDisabledDatepicker(target[0])) {
        return;
      }
      this._adjustInstDate(inst, offset + (period === 'M' ? this._get(inst, 'showCurrentAtPos') : 0), period);
      this._updateDatepicker(inst);
    },
    _gotoToday: function (id) {
      var date, target = $(id), inst = this._getInst(target[0]);
      if (this._get(inst, 'gotoCurrent') && inst.currentDay) {
        inst.selectedDay = inst.currentDay;
        inst.drawMonth = inst.selectedMonth = inst.currentMonth;
        inst.drawYear = inst.selectedYear = inst.currentYear;
      } else {
        date = new Date();
        inst.selectedDay = date.getDate();
        inst.drawMonth = inst.selectedMonth = date.getMonth();
        inst.drawYear = inst.selectedYear = date.getFullYear();
      }
      this._notifyChange(inst);
      this._adjustDate(target);
    },
    _selectMonthYear: function (id, select, period) {
      var target = $(id), inst = this._getInst(target[0]);
      inst['selected' + (period === 'M' ? 'Month' : 'Year')] = inst['draw' + (period === 'M' ? 'Month' : 'Year')] = parseInt(select.options[select.selectedIndex].value, 10);
      this._notifyChange(inst);
      this._adjustDate(target);
    },
    _selectDay: function (id, month, year, td) {
      var inst, target = $(id);
      if ($(td).hasClass(this._unselectableClass) || this._isDisabledDatepicker(target[0])) {
        return;
      }
      inst = this._getInst(target[0]);
      inst.selectedDay = inst.currentDay = $('a', td).html();
      inst.selectedMonth = inst.currentMonth = month;
      inst.selectedYear = inst.currentYear = year;
      this._selectDate(id, this._formatDate(inst, inst.currentDay, inst.currentMonth, inst.currentYear));
    },
    _clearDate: function (id) {
      var target = $(id);
      this._selectDate(target, '');
    },
    _selectDate: function (id, dateStr) {
      var onSelect, target = $(id), inst = this._getInst(target[0]);
      dateStr = dateStr != null ? dateStr : this._formatDate(inst);
      if (inst.input) {
        inst.input.val(dateStr);
      }
      this._updateAlternate(inst);
      onSelect = this._get(inst, 'onSelect');
      if (onSelect) {
        onSelect.apply(inst.input ? inst.input[0] : null, [
          dateStr,
          inst
        ]);
      } else if (inst.input) {
        inst.input.trigger('change');
      }
      if (inst.inline) {
        this._updateDatepicker(inst);
      } else {
        this._hideDatepicker();
        this._lastInput = inst.input[0];
        if (typeof inst.input[0] !== 'object') {
          inst.input.focus();
        }
        this._lastInput = null;
      }
    },
    _updateAlternate: function (inst) {
      var altFormat, date, dateStr, altField = this._get(inst, 'altField');
      if (altField) {
        altFormat = this._get(inst, 'altFormat') || this._get(inst, 'dateFormat');
        date = this._getDate(inst);
        dateStr = this.formatDate(altFormat, date, this._getFormatConfig(inst));
        $(altField).each(function () {
          $(this).val(dateStr);
        });
      }
    },
    noWeekends: function (date) {
      var day = date.getDay();
      return [
        day > 0 && day < 6,
        ''
      ];
    },
    iso8601Week: function (date) {
      var time, checkDate = new Date(date.getTime());
      checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));
      time = checkDate.getTime();
      checkDate.setMonth(0);
      checkDate.setDate(1);
      return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
    },
    parseDate: function (format, value, settings) {
      if (format == null || value == null) {
        throw 'Invalid arguments';
      }
      value = typeof value === 'object' ? value.toString() : value + '';
      if (value === '') {
        return null;
      }
      var iFormat, dim, extra, iValue = 0, shortYearCutoffTemp = (settings ? settings.shortYearCutoff : null) || this._defaults.shortYearCutoff, shortYearCutoff = typeof shortYearCutoffTemp !== 'string' ? shortYearCutoffTemp : new Date().getFullYear() % 100 + parseInt(shortYearCutoffTemp, 10), dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort, dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames, monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort, monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames, year = -1, month = -1, day = -1, doy = -1, literal = false, date, lookAhead = function (match) {
          var matches = iFormat + 1 < format.length && format.charAt(iFormat + 1) === match;
          if (matches) {
            iFormat++;
          }
          return matches;
        }, getNumber = function (match) {
          var isDoubled = lookAhead(match), size = match === '@' ? 14 : match === '!' ? 20 : match === 'y' && isDoubled ? 4 : match === 'o' ? 3 : 2, digits = new RegExp('^\\d{1,' + size + '}'), num = value.substring(iValue).match(digits);
          if (!num) {
            throw 'Missing number at position ' + iValue;
          }
          iValue += num[0].length;
          return parseInt(num[0], 10);
        }, getName = function (match, shortNames, longNames) {
          var index = -1, names = $.map(lookAhead(match) ? longNames : shortNames, function (v, k) {
              return [[
                  k,
                  v
                ]];
            }).sort(function (a, b) {
              return -(a[1].length - b[1].length);
            });
          $.each(names, function (i, pair) {
            var name = pair[1];
            if (value.substr(iValue, name.length).toLowerCase() === name.toLowerCase()) {
              index = pair[0];
              iValue += name.length;
              return false;
            }
          });
          if (index !== -1) {
            return index + 1;
          } else {
            throw 'Unknown name at position ' + iValue;
          }
        }, checkLiteral = function () {
          if (value.charAt(iValue) !== format.charAt(iFormat)) {
            throw 'Unexpected literal at position ' + iValue;
          }
          iValue++;
        };
      for (iFormat = 0; iFormat < format.length; iFormat++) {
        if (literal) {
          if (format.charAt(iFormat) === '\'' && !lookAhead('\'')) {
            literal = false;
          } else {
            checkLiteral();
          }
        } else {
          switch (format.charAt(iFormat)) {
          case 'd':
            day = getNumber('d');
            break;
          case 'D':
            getName('D', dayNamesShort, dayNames);
            break;
          case 'o':
            doy = getNumber('o');
            break;
          case 'm':
            month = getNumber('m');
            break;
          case 'M':
            month = getName('M', monthNamesShort, monthNames);
            break;
          case 'y':
            year = getNumber('y');
            break;
          case '@':
            date = new Date(getNumber('@'));
            year = date.getFullYear();
            month = date.getMonth() + 1;
            day = date.getDate();
            break;
          case '!':
            date = new Date((getNumber('!') - this._ticksTo1970) / 10000);
            year = date.getFullYear();
            month = date.getMonth() + 1;
            day = date.getDate();
            break;
          case '\'':
            if (lookAhead('\'')) {
              checkLiteral();
            } else {
              literal = true;
            }
            break;
          default:
            checkLiteral();
          }
        }
      }
      if (iValue < value.length) {
        extra = value.substr(iValue);
        if (!/^\s+/.test(extra)) {
          throw 'Extra/unparsed characters found in date: ' + extra;
        }
      }
      if (year === -1) {
        year = new Date().getFullYear();
      } else if (year < 100) {
        year += new Date().getFullYear() - new Date().getFullYear() % 100 + (year <= shortYearCutoff ? 0 : -100);
      }
      if (doy > -1) {
        month = 1;
        day = doy;
        do {
          dim = this._getDaysInMonth(year, month - 1);
          if (day <= dim) {
            break;
          }
          month++;
          day -= dim;
        } while (true);
      }
      date = this._daylightSavingAdjust(new Date(year, month - 1, day));
      if (date.getFullYear() !== year || date.getMonth() + 1 !== month || date.getDate() !== day) {
        throw 'Invalid date';
      }
      return date;
    },
    ATOM: 'yy-mm-dd',
    COOKIE: 'D, dd M yy',
    ISO_8601: 'yy-mm-dd',
    RFC_822: 'D, d M y',
    RFC_850: 'DD, dd-M-y',
    RFC_1036: 'D, d M y',
    RFC_1123: 'D, d M yy',
    RFC_2822: 'D, d M yy',
    RSS: 'D, d M y',
    TICKS: '!',
    TIMESTAMP: '@',
    W3C: 'yy-mm-dd',
    _ticksTo1970: ((1970 - 1) * 365 + Math.floor(1970 / 4) - Math.floor(1970 / 100) + Math.floor(1970 / 400)) * 24 * 60 * 60 * 10000000,
    formatDate: function (format, date, settings) {
      if (!date) {
        return '';
      }
      var iFormat, dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort, dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames, monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort, monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames, lookAhead = function (match) {
          var matches = iFormat + 1 < format.length && format.charAt(iFormat + 1) === match;
          if (matches) {
            iFormat++;
          }
          return matches;
        }, formatNumber = function (match, value, len) {
          var num = '' + value;
          if (lookAhead(match)) {
            while (num.length < len) {
              num = '0' + num;
            }
          }
          return num;
        }, formatName = function (match, value, shortNames, longNames) {
          return lookAhead(match) ? longNames[value] : shortNames[value];
        }, output = '', literal = false;
      if (date) {
        for (iFormat = 0; iFormat < format.length; iFormat++) {
          if (literal) {
            if (format.charAt(iFormat) === '\'' && !lookAhead('\'')) {
              literal = false;
            } else {
              output += format.charAt(iFormat);
            }
          } else {
            switch (format.charAt(iFormat)) {
            case 'd':
              output += formatNumber('d', date.getDate(), 2);
              break;
            case 'D':
              output += formatName('D', date.getDay(), dayNamesShort, dayNames);
              break;
            case 'o':
              output += formatNumber('o', Math.round((new Date(date.getFullYear(), date.getMonth(), date.getDate()).getTime() - new Date(date.getFullYear(), 0, 0).getTime()) / 86400000), 3);
              break;
            case 'm':
              output += formatNumber('m', date.getMonth() + 1, 2);
              break;
            case 'M':
              output += formatName('M', date.getMonth(), monthNamesShort, monthNames);
              break;
            case 'y':
              output += lookAhead('y') ? date.getFullYear() : (date.getYear() % 100 < 10 ? '0' : '') + date.getYear() % 100;
              break;
            case '@':
              output += date.getTime();
              break;
            case '!':
              output += date.getTime() * 10000 + this._ticksTo1970;
              break;
            case '\'':
              if (lookAhead('\'')) {
                output += '\'';
              } else {
                literal = true;
              }
              break;
            default:
              output += format.charAt(iFormat);
            }
          }
        }
      }
      return output;
    },
    _possibleChars: function (format) {
      var iFormat, chars = '', literal = false, lookAhead = function (match) {
          var matches = iFormat + 1 < format.length && format.charAt(iFormat + 1) === match;
          if (matches) {
            iFormat++;
          }
          return matches;
        };
      for (iFormat = 0; iFormat < format.length; iFormat++) {
        if (literal) {
          if (format.charAt(iFormat) === '\'' && !lookAhead('\'')) {
            literal = false;
          } else {
            chars += format.charAt(iFormat);
          }
        } else {
          switch (format.charAt(iFormat)) {
          case 'd':
          case 'm':
          case 'y':
          case '@':
            chars += '0123456789';
            break;
          case 'D':
          case 'M':
            return null;
          case '\'':
            if (lookAhead('\'')) {
              chars += '\'';
            } else {
              literal = true;
            }
            break;
          default:
            chars += format.charAt(iFormat);
          }
        }
      }
      return chars;
    },
    _get: function (inst, name) {
      return inst.settings[name] !== undefined ? inst.settings[name] : this._defaults[name];
    },
    _setDateFromField: function (inst, noDefault) {
      if (inst.input.val() === inst.lastVal) {
        return;
      }
      var dateFormat = this._get(inst, 'dateFormat'), dates = inst.lastVal = inst.input ? inst.input.val() : null, defaultDate = this._getDefaultDate(inst), date = defaultDate, settings = this._getFormatConfig(inst);
      try {
        date = this.parseDate(dateFormat, dates, settings) || defaultDate;
      } catch (event) {
        dates = noDefault ? '' : dates;
      }
      inst.selectedDay = date.getDate();
      inst.drawMonth = inst.selectedMonth = date.getMonth();
      inst.drawYear = inst.selectedYear = date.getFullYear();
      inst.currentDay = dates ? date.getDate() : 0;
      inst.currentMonth = dates ? date.getMonth() : 0;
      inst.currentYear = dates ? date.getFullYear() : 0;
      this._adjustInstDate(inst);
    },
    _getDefaultDate: function (inst) {
      return this._restrictMinMax(inst, this._determineDate(inst, this._get(inst, 'defaultDate'), new Date()));
    },
    _determineDate: function (inst, date, defaultDate) {
      var offsetNumeric = function (offset) {
          var date = new Date();
          date.setDate(date.getDate() + offset);
          return date;
        }, offsetString = function (offset) {
          try {
            return $.datepicker.parseDate($.datepicker._get(inst, 'dateFormat'), offset, $.datepicker._getFormatConfig(inst));
          } catch (e) {
          }
          var date = (offset.toLowerCase().match(/^c/) ? $.datepicker._getDate(inst) : null) || new Date(), year = date.getFullYear(), month = date.getMonth(), day = date.getDate(), pattern = /([+\-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g, matches = pattern.exec(offset);
          while (matches) {
            switch (matches[2] || 'd') {
            case 'd':
            case 'D':
              day += parseInt(matches[1], 10);
              break;
            case 'w':
            case 'W':
              day += parseInt(matches[1], 10) * 7;
              break;
            case 'm':
            case 'M':
              month += parseInt(matches[1], 10);
              day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
              break;
            case 'y':
            case 'Y':
              year += parseInt(matches[1], 10);
              day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
              break;
            }
            matches = pattern.exec(offset);
          }
          return new Date(year, month, day);
        }, newDate = date == null || date === '' ? defaultDate : typeof date === 'string' ? offsetString(date) : typeof date === 'number' ? isNaN(date) ? defaultDate : offsetNumeric(date) : new Date(date.getTime());
      newDate = newDate && newDate.toString() === 'Invalid Date' ? defaultDate : newDate;
      if (newDate) {
        newDate.setHours(0);
        newDate.setMinutes(0);
        newDate.setSeconds(0);
        newDate.setMilliseconds(0);
      }
      return this._daylightSavingAdjust(newDate);
    },
    _daylightSavingAdjust: function (date) {
      if (!date) {
        return null;
      }
      date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);
      return date;
    },
    _setDate: function (inst, date, noChange) {
      var clear = !date, origMonth = inst.selectedMonth, origYear = inst.selectedYear, newDate = this._restrictMinMax(inst, this._determineDate(inst, date, new Date()));
      inst.selectedDay = inst.currentDay = newDate.getDate();
      inst.drawMonth = inst.selectedMonth = inst.currentMonth = newDate.getMonth();
      inst.drawYear = inst.selectedYear = inst.currentYear = newDate.getFullYear();
      if ((origMonth !== inst.selectedMonth || origYear !== inst.selectedYear) && !noChange) {
        this._notifyChange(inst);
      }
      this._adjustInstDate(inst);
      if (inst.input) {
        inst.input.val(clear ? '' : this._formatDate(inst));
      }
    },
    _getDate: function (inst) {
      var startDate = !inst.currentYear || inst.input && inst.input.val() === '' ? null : this._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay));
      return startDate;
    },
    _attachHandlers: function (inst) {
      var stepMonths = this._get(inst, 'stepMonths'), id = '#' + inst.id.replace(/\\\\/g, '\\');
      inst.dpDiv.find('[data-handler]').map(function () {
        var handler = {
            prev: function () {
              $.datepicker._adjustDate(id, -stepMonths, 'M');
            },
            next: function () {
              $.datepicker._adjustDate(id, +stepMonths, 'M');
            },
            hide: function () {
              $.datepicker._hideDatepicker();
            },
            today: function () {
              $.datepicker._gotoToday(id);
            },
            selectDay: function () {
              $.datepicker._selectDay(id, +this.getAttribute('data-month'), +this.getAttribute('data-year'), this);
              return false;
            },
            selectMonth: function () {
              $.datepicker._selectMonthYear(id, this, 'M');
              return false;
            },
            selectYear: function () {
              $.datepicker._selectMonthYear(id, this, 'Y');
              return false;
            }
          };
        $(this).bind(this.getAttribute('data-event'), handler[this.getAttribute('data-handler')]);
      });
    },
    _generateHTML: function (inst) {
      var maxDraw, prevText, prev, nextText, next, currentText, gotoDate, controls, buttonPanel, firstDay, showWeek, dayNames, dayNamesMin, monthNames, monthNamesShort, beforeShowDay, showOtherMonths, selectOtherMonths, defaultDate, html, dow, row, group, col, selectedDate, cornerClass, calender, thead, day, daysInMonth, leadDays, curRows, numRows, printDate, dRow, tbody, daySettings, otherMonth, unselectable, tempDate = new Date(), today = this._daylightSavingAdjust(new Date(tempDate.getFullYear(), tempDate.getMonth(), tempDate.getDate())), isRTL = this._get(inst, 'isRTL'), showButtonPanel = this._get(inst, 'showButtonPanel'), hideIfNoPrevNext = this._get(inst, 'hideIfNoPrevNext'), navigationAsDateFormat = this._get(inst, 'navigationAsDateFormat'), numMonths = this._getNumberOfMonths(inst), showCurrentAtPos = this._get(inst, 'showCurrentAtPos'), stepMonths = this._get(inst, 'stepMonths'), isMultiMonth = numMonths[0] !== 1 || numMonths[1] !== 1, currentDate = this._daylightSavingAdjust(!inst.currentDay ? new Date(9999, 9, 9) : new Date(inst.currentYear, inst.currentMonth, inst.currentDay)), minDate = this._getMinMaxDate(inst, 'min'), maxDate = this._getMinMaxDate(inst, 'max'), drawMonth = inst.drawMonth - showCurrentAtPos, drawYear = inst.drawYear;
      if (drawMonth < 0) {
        drawMonth += 12;
        drawYear--;
      }
      if (maxDate) {
        maxDraw = this._daylightSavingAdjust(new Date(maxDate.getFullYear(), maxDate.getMonth() - numMonths[0] * numMonths[1] + 1, maxDate.getDate()));
        maxDraw = minDate && maxDraw < minDate ? minDate : maxDraw;
        while (this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1)) > maxDraw) {
          drawMonth--;
          if (drawMonth < 0) {
            drawMonth = 11;
            drawYear--;
          }
        }
      }
      inst.drawMonth = drawMonth;
      inst.drawYear = drawYear;
      prevText = this._get(inst, 'prevText');
      prevText = !navigationAsDateFormat ? prevText : this.formatDate(prevText, this._daylightSavingAdjust(new Date(drawYear, drawMonth - stepMonths, 1)), this._getFormatConfig(inst));
      prev = this._canAdjustMonth(inst, -1, drawYear, drawMonth) ? '<a class=\'ui-datepicker-prev ui-corner-all\' data-handler=\'prev\' data-event=\'click\'' + ' title=\'' + prevText + '\'><span class=\'ui-icon ui-icon-circle-triangle-' + (isRTL ? 'e' : 'w') + '\'>' + prevText + '</span></a>' : hideIfNoPrevNext ? '' : '<a class=\'ui-datepicker-prev ui-corner-all ui-state-disabled\' title=\'' + prevText + '\'><span class=\'ui-icon ui-icon-circle-triangle-' + (isRTL ? 'e' : 'w') + '\'>' + prevText + '</span></a>';
      nextText = this._get(inst, 'nextText');
      nextText = !navigationAsDateFormat ? nextText : this.formatDate(nextText, this._daylightSavingAdjust(new Date(drawYear, drawMonth + stepMonths, 1)), this._getFormatConfig(inst));
      next = this._canAdjustMonth(inst, +1, drawYear, drawMonth) ? '<a class=\'ui-datepicker-next ui-corner-all\' data-handler=\'next\' data-event=\'click\'' + ' title=\'' + nextText + '\'><span class=\'ui-icon ui-icon-circle-triangle-' + (isRTL ? 'w' : 'e') + '\'>' + nextText + '</span></a>' : hideIfNoPrevNext ? '' : '<a class=\'ui-datepicker-next ui-corner-all ui-state-disabled\' title=\'' + nextText + '\'><span class=\'ui-icon ui-icon-circle-triangle-' + (isRTL ? 'w' : 'e') + '\'>' + nextText + '</span></a>';
      currentText = this._get(inst, 'currentText');
      gotoDate = this._get(inst, 'gotoCurrent') && inst.currentDay ? currentDate : today;
      currentText = !navigationAsDateFormat ? currentText : this.formatDate(currentText, gotoDate, this._getFormatConfig(inst));
      controls = !inst.inline ? '<button type=\'button\' class=\'ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all\' data-handler=\'hide\' data-event=\'click\'>' + this._get(inst, 'closeText') + '</button>' : '';
      buttonPanel = showButtonPanel ? '<div class=\'ui-datepicker-buttonpane ui-widget-content\'>' + (isRTL ? controls : '') + (this._isInRange(inst, gotoDate) ? '<button type=\'button\' class=\'ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all\' data-handler=\'today\' data-event=\'click\'' + '>' + currentText + '</button>' : '') + (isRTL ? '' : controls) + '</div>' : '';
      firstDay = parseInt(this._get(inst, 'firstDay'), 10);
      firstDay = isNaN(firstDay) ? 0 : firstDay;
      showWeek = this._get(inst, 'showWeek');
      dayNames = this._get(inst, 'dayNames');
      dayNamesMin = this._get(inst, 'dayNamesMin');
      monthNames = this._get(inst, 'monthNames');
      monthNamesShort = this._get(inst, 'monthNamesShort');
      beforeShowDay = this._get(inst, 'beforeShowDay');
      showOtherMonths = this._get(inst, 'showOtherMonths');
      selectOtherMonths = this._get(inst, 'selectOtherMonths');
      defaultDate = this._getDefaultDate(inst);
      html = '';
      dow;
      for (row = 0; row < numMonths[0]; row++) {
        group = '';
        this.maxRows = 4;
        for (col = 0; col < numMonths[1]; col++) {
          selectedDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, inst.selectedDay));
          cornerClass = ' ui-corner-all';
          calender = '';
          if (isMultiMonth) {
            calender += '<div class=\'ui-datepicker-group';
            if (numMonths[1] > 1) {
              switch (col) {
              case 0:
                calender += ' ui-datepicker-group-first';
                cornerClass = ' ui-corner-' + (isRTL ? 'right' : 'left');
                break;
              case numMonths[1] - 1:
                calender += ' ui-datepicker-group-last';
                cornerClass = ' ui-corner-' + (isRTL ? 'left' : 'right');
                break;
              default:
                calender += ' ui-datepicker-group-middle';
                cornerClass = '';
                break;
              }
            }
            calender += '\'>';
          }
          calender += '<div class=\'ui-datepicker-header ui-widget-header ui-helper-clearfix' + cornerClass + '\'>' + (/all|left/.test(cornerClass) && row === 0 ? isRTL ? next : prev : '') + (/all|right/.test(cornerClass) && row === 0 ? isRTL ? prev : next : '') + this._generateMonthYearHeader(inst, drawMonth, drawYear, minDate, maxDate, row > 0 || col > 0, monthNames, monthNamesShort) + '</div><table class=\'ui-datepicker-calendar\'><thead>' + '<tr>';
          thead = showWeek ? '<th class=\'ui-datepicker-week-col\'>' + this._get(inst, 'weekHeader') + '</th>' : '';
          for (dow = 0; dow < 7; dow++) {
            day = (dow + firstDay) % 7;
            thead += '<th' + ((dow + firstDay + 6) % 7 >= 5 ? ' class=\'ui-datepicker-week-end\'' : '') + '>' + '<span title=\'' + dayNames[day] + '\'>' + dayNamesMin[day] + '</span></th>';
          }
          calender += thead + '</tr></thead><tbody>';
          daysInMonth = this._getDaysInMonth(drawYear, drawMonth);
          if (drawYear === inst.selectedYear && drawMonth === inst.selectedMonth) {
            inst.selectedDay = Math.min(inst.selectedDay, daysInMonth);
          }
          leadDays = (this._getFirstDayOfMonth(drawYear, drawMonth) - firstDay + 7) % 7;
          curRows = Math.ceil((leadDays + daysInMonth) / 7);
          numRows = isMultiMonth ? this.maxRows > curRows ? this.maxRows : curRows : curRows;
          this.maxRows = numRows;
          printDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1 - leadDays));
          for (dRow = 0; dRow < numRows; dRow++) {
            calender += '<tr>';
            tbody = !showWeek ? '' : '<td class=\'ui-datepicker-week-col\'>' + this._get(inst, 'calculateWeek')(printDate) + '</td>';
            for (dow = 0; dow < 7; dow++) {
              daySettings = beforeShowDay ? beforeShowDay.apply(inst.input ? inst.input[0] : null, [printDate]) : [
                true,
                ''
              ];
              otherMonth = printDate.getMonth() !== drawMonth;
              unselectable = otherMonth && !selectOtherMonths || !daySettings[0] || minDate && printDate < minDate || maxDate && printDate > maxDate;
              tbody += '<td class=\'' + ((dow + firstDay + 6) % 7 >= 5 ? ' ui-datepicker-week-end' : '') + (otherMonth ? ' ui-datepicker-other-month' : '') + (printDate.getTime() === selectedDate.getTime() && drawMonth === inst.selectedMonth && inst._keyEvent || defaultDate.getTime() === printDate.getTime() && defaultDate.getTime() === selectedDate.getTime() ? ' ' + this._dayOverClass : '') + (unselectable ? ' ' + this._unselectableClass + ' ui-state-disabled' : '') + (otherMonth && !showOtherMonths ? '' : ' ' + daySettings[1] + (printDate.getTime() === currentDate.getTime() ? ' ' + this._currentClass : '') + (printDate.getTime() === today.getTime() ? ' ui-datepicker-today' : '')) + '\'' + ((!otherMonth || showOtherMonths) && daySettings[2] ? ' title=\'' + daySettings[2].replace(/'/g, '&#39;') + '\'' : '') + (unselectable ? '' : ' data-handler=\'selectDay\' data-event=\'click\' data-month=\'' + printDate.getMonth() + '\' data-year=\'' + printDate.getFullYear() + '\'') + '>' + (otherMonth && !showOtherMonths ? '&#xa0;' : unselectable ? '<span class=\'ui-state-default\'>' + printDate.getDate() + '</span>' : '<a class=\'ui-state-default' + (printDate.getTime() === today.getTime() ? ' ui-state-highlight' : '') + (printDate.getTime() === currentDate.getTime() ? ' ui-state-active' : '') + (otherMonth ? ' ui-priority-secondary' : '') + '\' href=\'#\'>' + printDate.getDate() + '</a>') + '</td>';
              printDate.setDate(printDate.getDate() + 1);
              printDate = this._daylightSavingAdjust(printDate);
            }
            calender += tbody + '</tr>';
          }
          drawMonth++;
          if (drawMonth > 11) {
            drawMonth = 0;
            drawYear++;
          }
          calender += '</tbody></table>' + (isMultiMonth ? '</div>' + (numMonths[0] > 0 && col === numMonths[1] - 1 ? '<div class=\'ui-datepicker-row-break\'></div>' : '') : '');
          group += calender;
        }
        html += group;
      }
      html += buttonPanel;
      inst._keyEvent = false;
      return html;
    },
    _generateMonthYearHeader: function (inst, drawMonth, drawYear, minDate, maxDate, secondary, monthNames, monthNamesShort) {
      var inMinYear, inMaxYear, month, years, thisYear, determineYear, year, endYear, changeMonth = this._get(inst, 'changeMonth'), changeYear = this._get(inst, 'changeYear'), showMonthAfterYear = this._get(inst, 'showMonthAfterYear'), html = '<div class=\'ui-datepicker-title\'>', monthHtml = '';
      if (secondary || !changeMonth) {
        monthHtml += '<span class=\'ui-datepicker-month\'>' + monthNames[drawMonth] + '</span>';
      } else {
        inMinYear = minDate && minDate.getFullYear() === drawYear;
        inMaxYear = maxDate && maxDate.getFullYear() === drawYear;
        monthHtml += '<select class=\'ui-datepicker-month\' data-handler=\'selectMonth\' data-event=\'change\'>';
        for (month = 0; month < 12; month++) {
          if ((!inMinYear || month >= minDate.getMonth()) && (!inMaxYear || month <= maxDate.getMonth())) {
            monthHtml += '<option value=\'' + month + '\'' + (month === drawMonth ? ' selected=\'selected\'' : '') + '>' + monthNamesShort[month] + '</option>';
          }
        }
        monthHtml += '</select>';
      }
      if (!showMonthAfterYear) {
        html += monthHtml + (secondary || !(changeMonth && changeYear) ? '&#xa0;' : '');
      }
      if (!inst.yearshtml) {
        inst.yearshtml = '';
        if (secondary || !changeYear) {
          html += '<span class=\'ui-datepicker-year\'>' + drawYear + '</span>';
        } else {
          years = this._get(inst, 'yearRange').split(':');
          thisYear = new Date().getFullYear();
          determineYear = function (value) {
            var year = value.match(/c[+\-].*/) ? drawYear + parseInt(value.substring(1), 10) : value.match(/[+\-].*/) ? thisYear + parseInt(value, 10) : parseInt(value, 10);
            return isNaN(year) ? thisYear : year;
          };
          year = determineYear(years[0]);
          endYear = Math.max(year, determineYear(years[1] || ''));
          year = minDate ? Math.max(year, minDate.getFullYear()) : year;
          endYear = maxDate ? Math.min(endYear, maxDate.getFullYear()) : endYear;
          inst.yearshtml += '<select class=\'ui-datepicker-year\' data-handler=\'selectYear\' data-event=\'change\'>';
          for (; year <= endYear; year++) {
            inst.yearshtml += '<option value=\'' + year + '\'' + (year === drawYear ? ' selected=\'selected\'' : '') + '>' + year + '</option>';
          }
          inst.yearshtml += '</select>';
          html += inst.yearshtml;
          inst.yearshtml = null;
        }
      }
      html += this._get(inst, 'yearSuffix');
      if (showMonthAfterYear) {
        html += (secondary || !(changeMonth && changeYear) ? '&#xa0;' : '') + monthHtml;
      }
      html += '</div>';
      return html;
    },
    _adjustInstDate: function (inst, offset, period) {
      var year = inst.drawYear + (period === 'Y' ? offset : 0), month = inst.drawMonth + (period === 'M' ? offset : 0), day = Math.min(inst.selectedDay, this._getDaysInMonth(year, month)) + (period === 'D' ? offset : 0), date = this._restrictMinMax(inst, this._daylightSavingAdjust(new Date(year, month, day)));
      inst.selectedDay = date.getDate();
      inst.drawMonth = inst.selectedMonth = date.getMonth();
      inst.drawYear = inst.selectedYear = date.getFullYear();
      if (period === 'M' || period === 'Y') {
        this._notifyChange(inst);
      }
    },
    _restrictMinMax: function (inst, date) {
      var minDate = this._getMinMaxDate(inst, 'min'), maxDate = this._getMinMaxDate(inst, 'max'), newDate = minDate && date < minDate ? minDate : date;
      return maxDate && newDate > maxDate ? maxDate : newDate;
    },
    _notifyChange: function (inst) {
      var onChange = this._get(inst, 'onChangeMonthYear');
      if (onChange) {
        onChange.apply(inst.input ? inst.input[0] : null, [
          inst.selectedYear,
          inst.selectedMonth + 1,
          inst
        ]);
      }
    },
    _getNumberOfMonths: function (inst) {
      var numMonths = this._get(inst, 'numberOfMonths');
      return numMonths == null ? [
        1,
        1
      ] : typeof numMonths === 'number' ? [
        1,
        numMonths
      ] : numMonths;
    },
    _getMinMaxDate: function (inst, minMax) {
      return this._determineDate(inst, this._get(inst, minMax + 'Date'), null);
    },
    _getDaysInMonth: function (year, month) {
      return 32 - this._daylightSavingAdjust(new Date(year, month, 32)).getDate();
    },
    _getFirstDayOfMonth: function (year, month) {
      return new Date(year, month, 1).getDay();
    },
    _canAdjustMonth: function (inst, offset, curYear, curMonth) {
      var numMonths = this._getNumberOfMonths(inst), date = this._daylightSavingAdjust(new Date(curYear, curMonth + (offset < 0 ? offset : numMonths[0] * numMonths[1]), 1));
      if (offset < 0) {
        date.setDate(this._getDaysInMonth(date.getFullYear(), date.getMonth()));
      }
      return this._isInRange(inst, date);
    },
    _isInRange: function (inst, date) {
      var yearSplit, currentYear, minDate = this._getMinMaxDate(inst, 'min'), maxDate = this._getMinMaxDate(inst, 'max'), minYear = null, maxYear = null, years = this._get(inst, 'yearRange');
      if (years) {
        yearSplit = years.split(':');
        currentYear = new Date().getFullYear();
        minYear = parseInt(yearSplit[0], 10);
        maxYear = parseInt(yearSplit[1], 10);
        if (yearSplit[0].match(/[+\-].*/)) {
          minYear += currentYear;
        }
        if (yearSplit[1].match(/[+\-].*/)) {
          maxYear += currentYear;
        }
      }
      return (!minDate || date.getTime() >= minDate.getTime()) && (!maxDate || date.getTime() <= maxDate.getTime()) && (!minYear || date.getFullYear() >= minYear) && (!maxYear || date.getFullYear() <= maxYear);
    },
    _getFormatConfig: function (inst) {
      var shortYearCutoff = this._get(inst, 'shortYearCutoff');
      shortYearCutoff = typeof shortYearCutoff !== 'string' ? shortYearCutoff : new Date().getFullYear() % 100 + parseInt(shortYearCutoff, 10);
      return {
        shortYearCutoff: shortYearCutoff,
        dayNamesShort: this._get(inst, 'dayNamesShort'),
        dayNames: this._get(inst, 'dayNames'),
        monthNamesShort: this._get(inst, 'monthNamesShort'),
        monthNames: this._get(inst, 'monthNames')
      };
    },
    _formatDate: function (inst, day, month, year) {
      if (!day) {
        inst.currentDay = inst.selectedDay;
        inst.currentMonth = inst.selectedMonth;
        inst.currentYear = inst.selectedYear;
      }
      var date = day ? typeof day === 'object' ? day : this._daylightSavingAdjust(new Date(year, month, day)) : this._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay));
      return this.formatDate(this._get(inst, 'dateFormat'), date, this._getFormatConfig(inst));
    }
  });
  function bindHover(dpDiv) {
    var selector = 'button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a';
    return dpDiv.delegate(selector, 'mouseout', function () {
      $(this).removeClass('ui-state-hover');
      if (this.className.indexOf('ui-datepicker-prev') !== -1) {
        $(this).removeClass('ui-datepicker-prev-hover');
      }
      if (this.className.indexOf('ui-datepicker-next') !== -1) {
        $(this).removeClass('ui-datepicker-next-hover');
      }
    }).delegate(selector, 'mouseover', function () {
      if (!$.datepicker._isDisabledDatepicker(instActive.inline ? dpDiv.parent()[0] : instActive.input[0])) {
        $(this).parents('.ui-datepicker-calendar').find('a').removeClass('ui-state-hover');
        $(this).addClass('ui-state-hover');
        if (this.className.indexOf('ui-datepicker-prev') !== -1) {
          $(this).addClass('ui-datepicker-prev-hover');
        }
        if (this.className.indexOf('ui-datepicker-next') !== -1) {
          $(this).addClass('ui-datepicker-next-hover');
        }
      }
    });
  }
  function extendRemove(target, props) {
    $.extend(target, props);
    for (var name in props) {
      if (props[name] == null) {
        target[name] = props[name];
      }
    }
    return target;
  }
  $.fn.datepicker = function (options) {
    if (!this.length) {
      return this;
    }
    if (!$.datepicker.initialized) {
      $(document).mousedown($.datepicker._checkExternalClick);
      $.datepicker.initialized = true;
    }
    if ($('#' + $.datepicker._mainDivId).length === 0) {
      $('body').append($.datepicker.dpDiv);
    }
    var otherArgs = Array.prototype.slice.call(arguments, 1);
    if (typeof options === 'string' && (options === 'isDisabled' || options === 'getDate' || options === 'widget')) {
      return $.datepicker['_' + options + 'Datepicker'].apply($.datepicker, [this[0]].concat(otherArgs));
    }
    if (options === 'option' && arguments.length === 2 && typeof arguments[1] === 'string') {
      return $.datepicker['_' + options + 'Datepicker'].apply($.datepicker, [this[0]].concat(otherArgs));
    }
    return this.each(function () {
      typeof options === 'string' ? $.datepicker['_' + options + 'Datepicker'].apply($.datepicker, [this].concat(otherArgs)) : $.datepicker._attachDatepicker(this, options);
    });
  };
  $.datepicker = new Datepicker();
  $.datepicker.initialized = false;
  $.datepicker.uuid = new Date().getTime();
  $.datepicker.version = '1.10.4';
}(jQuery));
(function ($, undefined) {
  var sizeRelatedOptions = {
      buttons: true,
      height: true,
      maxHeight: true,
      maxWidth: true,
      minHeight: true,
      minWidth: true,
      width: true
    }, resizableRelatedOptions = {
      maxHeight: true,
      maxWidth: true,
      minHeight: true,
      minWidth: true
    };
  $.widget('ui.dialog', {
    version: '1.10.4',
    options: {
      appendTo: 'body',
      autoOpen: true,
      buttons: [],
      closeOnEscape: true,
      closeText: 'close',
      dialogClass: '',
      draggable: true,
      hide: null,
      height: 'auto',
      maxHeight: null,
      maxWidth: null,
      minHeight: 150,
      minWidth: 150,
      modal: false,
      position: {
        my: 'center',
        at: 'center',
        of: window,
        collision: 'fit',
        using: function (pos) {
          var topOffset = $(this).css(pos).offset().top;
          if (topOffset < 0) {
            $(this).css('top', pos.top - topOffset);
          }
        }
      },
      resizable: true,
      show: null,
      title: null,
      width: 300,
      beforeClose: null,
      close: null,
      drag: null,
      dragStart: null,
      dragStop: null,
      focus: null,
      open: null,
      resize: null,
      resizeStart: null,
      resizeStop: null
    },
    _create: function () {
      this.originalCss = {
        display: this.element[0].style.display,
        width: this.element[0].style.width,
        minHeight: this.element[0].style.minHeight,
        maxHeight: this.element[0].style.maxHeight,
        height: this.element[0].style.height
      };
      this.originalPosition = {
        parent: this.element.parent(),
        index: this.element.parent().children().index(this.element)
      };
      this.originalTitle = this.element.attr('title');
      this.options.title = this.options.title || this.originalTitle;
      this._createWrapper();
      this.element.show().removeAttr('title').addClass('ui-dialog-content ui-widget-content').appendTo(this.uiDialog);
      this._createTitlebar();
      this._createButtonPane();
      if (this.options.draggable && $.fn.draggable) {
        this._makeDraggable();
      }
      if (this.options.resizable && $.fn.resizable) {
        this._makeResizable();
      }
      this._isOpen = false;
    },
    _init: function () {
      if (this.options.autoOpen) {
        this.open();
      }
    },
    _appendTo: function () {
      var element = this.options.appendTo;
      if (element && (element.jquery || element.nodeType)) {
        return $(element);
      }
      return this.document.find(element || 'body').eq(0);
    },
    _destroy: function () {
      var next, originalPosition = this.originalPosition;
      this._destroyOverlay();
      this.element.removeUniqueId().removeClass('ui-dialog-content ui-widget-content').css(this.originalCss).detach();
      this.uiDialog.stop(true, true).remove();
      if (this.originalTitle) {
        this.element.attr('title', this.originalTitle);
      }
      next = originalPosition.parent.children().eq(originalPosition.index);
      if (next.length && next[0] !== this.element[0]) {
        next.before(this.element);
      } else {
        originalPosition.parent.append(this.element);
      }
    },
    widget: function () {
      return this.uiDialog;
    },
    disable: $.noop,
    enable: $.noop,
    close: function (event) {
      var activeElement, that = this;
      if (!this._isOpen || this._trigger('beforeClose', event) === false) {
        return;
      }
      this._isOpen = false;
      this._destroyOverlay();
      if (!this.opener.filter(':focusable').focus().length) {
        try {
          activeElement = this.document[0].activeElement;
          if (activeElement && activeElement.nodeName.toLowerCase() !== 'body') {
            $(activeElement).blur();
          }
        } catch (error) {
        }
      }
      this._hide(this.uiDialog, this.options.hide, function () {
        that._trigger('close', event);
      });
    },
    isOpen: function () {
      return this._isOpen;
    },
    moveToTop: function () {
      this._moveToTop();
    },
    _moveToTop: function (event, silent) {
      var moved = !!this.uiDialog.nextAll(':visible').insertBefore(this.uiDialog).length;
      if (moved && !silent) {
        this._trigger('focus', event);
      }
      return moved;
    },
    open: function () {
      var that = this;
      if (this._isOpen) {
        if (this._moveToTop()) {
          this._focusTabbable();
        }
        return;
      }
      this._isOpen = true;
      this.opener = $(this.document[0].activeElement);
      this._size();
      this._position();
      this._createOverlay();
      this._moveToTop(null, true);
      this._show(this.uiDialog, this.options.show, function () {
        that._focusTabbable();
        that._trigger('focus');
      });
      this._trigger('open');
    },
    _focusTabbable: function () {
      var hasFocus = this.element.find('[autofocus]');
      if (!hasFocus.length) {
        hasFocus = this.element.find(':tabbable');
      }
      if (!hasFocus.length) {
        hasFocus = this.uiDialogButtonPane.find(':tabbable');
      }
      if (!hasFocus.length) {
        hasFocus = this.uiDialogTitlebarClose.filter(':tabbable');
      }
      if (!hasFocus.length) {
        hasFocus = this.uiDialog;
      }
      hasFocus.eq(0).focus();
    },
    _keepFocus: function (event) {
      function checkFocus() {
        var activeElement = this.document[0].activeElement, isActive = this.uiDialog[0] === activeElement || $.contains(this.uiDialog[0], activeElement);
        if (!isActive) {
          this._focusTabbable();
        }
      }
      event.preventDefault();
      checkFocus.call(this);
      this._delay(checkFocus);
    },
    _createWrapper: function () {
      this.uiDialog = $('<div>').addClass('ui-dialog ui-widget ui-widget-content ui-corner-all ui-front ' + this.options.dialogClass).hide().attr({
        tabIndex: -1,
        role: 'dialog'
      }).appendTo(this._appendTo());
      this._on(this.uiDialog, {
        keydown: function (event) {
          if (this.options.closeOnEscape && !event.isDefaultPrevented() && event.keyCode && event.keyCode === $.ui.keyCode.ESCAPE) {
            event.preventDefault();
            this.close(event);
            return;
          }
          if (event.keyCode !== $.ui.keyCode.TAB) {
            return;
          }
          var tabbables = this.uiDialog.find(':tabbable'), first = tabbables.filter(':first'), last = tabbables.filter(':last');
          if ((event.target === last[0] || event.target === this.uiDialog[0]) && !event.shiftKey) {
            first.focus(1);
            event.preventDefault();
          } else if ((event.target === first[0] || event.target === this.uiDialog[0]) && event.shiftKey) {
            last.focus(1);
            event.preventDefault();
          }
        },
        mousedown: function (event) {
          if (this._moveToTop(event)) {
            this._focusTabbable();
          }
        }
      });
      if (!this.element.find('[aria-describedby]').length) {
        this.uiDialog.attr({ 'aria-describedby': this.element.uniqueId().attr('id') });
      }
    },
    _createTitlebar: function () {
      var uiDialogTitle;
      this.uiDialogTitlebar = $('<div>').addClass('ui-dialog-titlebar ui-widget-header ui-corner-all ui-helper-clearfix').prependTo(this.uiDialog);
      this._on(this.uiDialogTitlebar, {
        mousedown: function (event) {
          if (!$(event.target).closest('.ui-dialog-titlebar-close')) {
            this.uiDialog.focus();
          }
        }
      });
      this.uiDialogTitlebarClose = $('<button type=\'button\'></button>').button({
        label: this.options.closeText,
        icons: { primary: 'ui-icon-closethick' },
        text: false
      }).addClass('ui-dialog-titlebar-close').appendTo(this.uiDialogTitlebar);
      this._on(this.uiDialogTitlebarClose, {
        click: function (event) {
          event.preventDefault();
          this.close(event);
        }
      });
      uiDialogTitle = $('<span>').uniqueId().addClass('ui-dialog-title').prependTo(this.uiDialogTitlebar);
      this._title(uiDialogTitle);
      this.uiDialog.attr({ 'aria-labelledby': uiDialogTitle.attr('id') });
    },
    _title: function (title) {
      if (!this.options.title) {
        title.html('&#160;');
      }
      title.text(this.options.title);
    },
    _createButtonPane: function () {
      this.uiDialogButtonPane = $('<div>').addClass('ui-dialog-buttonpane ui-widget-content ui-helper-clearfix');
      this.uiButtonSet = $('<div>').addClass('ui-dialog-buttonset').appendTo(this.uiDialogButtonPane);
      this._createButtons();
    },
    _createButtons: function () {
      var that = this, buttons = this.options.buttons;
      this.uiDialogButtonPane.remove();
      this.uiButtonSet.empty();
      if ($.isEmptyObject(buttons) || $.isArray(buttons) && !buttons.length) {
        this.uiDialog.removeClass('ui-dialog-buttons');
        return;
      }
      $.each(buttons, function (name, props) {
        var click, buttonOptions;
        props = $.isFunction(props) ? {
          click: props,
          text: name
        } : props;
        props = $.extend({ type: 'button' }, props);
        click = props.click;
        props.click = function () {
          click.apply(that.element[0], arguments);
        };
        buttonOptions = {
          icons: props.icons,
          text: props.showText
        };
        delete props.icons;
        delete props.showText;
        $('<button></button>', props).button(buttonOptions).appendTo(that.uiButtonSet);
      });
      this.uiDialog.addClass('ui-dialog-buttons');
      this.uiDialogButtonPane.appendTo(this.uiDialog);
    },
    _makeDraggable: function () {
      var that = this, options = this.options;
      function filteredUi(ui) {
        return {
          position: ui.position,
          offset: ui.offset
        };
      }
      this.uiDialog.draggable({
        cancel: '.ui-dialog-content, .ui-dialog-titlebar-close',
        handle: '.ui-dialog-titlebar',
        containment: 'document',
        start: function (event, ui) {
          $(this).addClass('ui-dialog-dragging');
          that._blockFrames();
          that._trigger('dragStart', event, filteredUi(ui));
        },
        drag: function (event, ui) {
          that._trigger('drag', event, filteredUi(ui));
        },
        stop: function (event, ui) {
          options.position = [
            ui.position.left - that.document.scrollLeft(),
            ui.position.top - that.document.scrollTop()
          ];
          $(this).removeClass('ui-dialog-dragging');
          that._unblockFrames();
          that._trigger('dragStop', event, filteredUi(ui));
        }
      });
    },
    _makeResizable: function () {
      var that = this, options = this.options, handles = options.resizable, position = this.uiDialog.css('position'), resizeHandles = typeof handles === 'string' ? handles : 'n,e,s,w,se,sw,ne,nw';
      function filteredUi(ui) {
        return {
          originalPosition: ui.originalPosition,
          originalSize: ui.originalSize,
          position: ui.position,
          size: ui.size
        };
      }
      this.uiDialog.resizable({
        cancel: '.ui-dialog-content',
        containment: 'document',
        alsoResize: this.element,
        maxWidth: options.maxWidth,
        maxHeight: options.maxHeight,
        minWidth: options.minWidth,
        minHeight: this._minHeight(),
        handles: resizeHandles,
        start: function (event, ui) {
          $(this).addClass('ui-dialog-resizing');
          that._blockFrames();
          that._trigger('resizeStart', event, filteredUi(ui));
        },
        resize: function (event, ui) {
          that._trigger('resize', event, filteredUi(ui));
        },
        stop: function (event, ui) {
          options.height = $(this).height();
          options.width = $(this).width();
          $(this).removeClass('ui-dialog-resizing');
          that._unblockFrames();
          that._trigger('resizeStop', event, filteredUi(ui));
        }
      }).css('position', position);
    },
    _minHeight: function () {
      var options = this.options;
      return options.height === 'auto' ? options.minHeight : Math.min(options.minHeight, options.height);
    },
    _position: function () {
      var isVisible = this.uiDialog.is(':visible');
      if (!isVisible) {
        this.uiDialog.show();
      }
      this.uiDialog.position(this.options.position);
      if (!isVisible) {
        this.uiDialog.hide();
      }
    },
    _setOptions: function (options) {
      var that = this, resize = false, resizableOptions = {};
      $.each(options, function (key, value) {
        that._setOption(key, value);
        if (key in sizeRelatedOptions) {
          resize = true;
        }
        if (key in resizableRelatedOptions) {
          resizableOptions[key] = value;
        }
      });
      if (resize) {
        this._size();
        this._position();
      }
      if (this.uiDialog.is(':data(ui-resizable)')) {
        this.uiDialog.resizable('option', resizableOptions);
      }
    },
    _setOption: function (key, value) {
      var isDraggable, isResizable, uiDialog = this.uiDialog;
      if (key === 'dialogClass') {
        uiDialog.removeClass(this.options.dialogClass).addClass(value);
      }
      if (key === 'disabled') {
        return;
      }
      this._super(key, value);
      if (key === 'appendTo') {
        this.uiDialog.appendTo(this._appendTo());
      }
      if (key === 'buttons') {
        this._createButtons();
      }
      if (key === 'closeText') {
        this.uiDialogTitlebarClose.button({ label: '' + value });
      }
      if (key === 'draggable') {
        isDraggable = uiDialog.is(':data(ui-draggable)');
        if (isDraggable && !value) {
          uiDialog.draggable('destroy');
        }
        if (!isDraggable && value) {
          this._makeDraggable();
        }
      }
      if (key === 'position') {
        this._position();
      }
      if (key === 'resizable') {
        isResizable = uiDialog.is(':data(ui-resizable)');
        if (isResizable && !value) {
          uiDialog.resizable('destroy');
        }
        if (isResizable && typeof value === 'string') {
          uiDialog.resizable('option', 'handles', value);
        }
        if (!isResizable && value !== false) {
          this._makeResizable();
        }
      }
      if (key === 'title') {
        this._title(this.uiDialogTitlebar.find('.ui-dialog-title'));
      }
    },
    _size: function () {
      var nonContentHeight, minContentHeight, maxContentHeight, options = this.options;
      this.element.show().css({
        width: 'auto',
        minHeight: 0,
        maxHeight: 'none',
        height: 0
      });
      if (options.minWidth > options.width) {
        options.width = options.minWidth;
      }
      nonContentHeight = this.uiDialog.css({
        height: 'auto',
        width: options.width
      }).outerHeight();
      minContentHeight = Math.max(0, options.minHeight - nonContentHeight);
      maxContentHeight = typeof options.maxHeight === 'number' ? Math.max(0, options.maxHeight - nonContentHeight) : 'none';
      if (options.height === 'auto') {
        this.element.css({
          minHeight: minContentHeight,
          maxHeight: maxContentHeight,
          height: 'auto'
        });
      } else {
        this.element.height(Math.max(0, options.height - nonContentHeight));
      }
      if (this.uiDialog.is(':data(ui-resizable)')) {
        this.uiDialog.resizable('option', 'minHeight', this._minHeight());
      }
    },
    _blockFrames: function () {
      this.iframeBlocks = this.document.find('iframe').map(function () {
        var iframe = $(this);
        return $('<div>').css({
          position: 'absolute',
          width: iframe.outerWidth(),
          height: iframe.outerHeight()
        }).appendTo(iframe.parent()).offset(iframe.offset())[0];
      });
    },
    _unblockFrames: function () {
      if (this.iframeBlocks) {
        this.iframeBlocks.remove();
        delete this.iframeBlocks;
      }
    },
    _allowInteraction: function (event) {
      if ($(event.target).closest('.ui-dialog').length) {
        return true;
      }
      return !!$(event.target).closest('.ui-datepicker').length;
    },
    _createOverlay: function () {
      if (!this.options.modal) {
        return;
      }
      var that = this, widgetFullName = this.widgetFullName;
      if (!$.ui.dialog.overlayInstances) {
        this._delay(function () {
          if ($.ui.dialog.overlayInstances) {
            this.document.bind('focusin.dialog', function (event) {
              if (!that._allowInteraction(event)) {
                event.preventDefault();
                $('.ui-dialog:visible:last .ui-dialog-content').data(widgetFullName)._focusTabbable();
              }
            });
          }
        });
      }
      this.overlay = $('<div>').addClass('ui-widget-overlay ui-front').appendTo(this._appendTo());
      this._on(this.overlay, { mousedown: '_keepFocus' });
      $.ui.dialog.overlayInstances++;
    },
    _destroyOverlay: function () {
      if (!this.options.modal) {
        return;
      }
      if (this.overlay) {
        $.ui.dialog.overlayInstances--;
        if (!$.ui.dialog.overlayInstances) {
          this.document.unbind('focusin.dialog');
        }
        this.overlay.remove();
        this.overlay = null;
      }
    }
  });
  $.ui.dialog.overlayInstances = 0;
  if ($.uiBackCompat !== false) {
    $.widget('ui.dialog', $.ui.dialog, {
      _position: function () {
        var position = this.options.position, myAt = [], offset = [
            0,
            0
          ], isVisible;
        if (position) {
          if (typeof position === 'string' || typeof position === 'object' && '0' in position) {
            myAt = position.split ? position.split(' ') : [
              position[0],
              position[1]
            ];
            if (myAt.length === 1) {
              myAt[1] = myAt[0];
            }
            $.each([
              'left',
              'top'
            ], function (i, offsetPosition) {
              if (+myAt[i] === myAt[i]) {
                offset[i] = myAt[i];
                myAt[i] = offsetPosition;
              }
            });
            position = {
              my: myAt[0] + (offset[0] < 0 ? offset[0] : '+' + offset[0]) + ' ' + myAt[1] + (offset[1] < 0 ? offset[1] : '+' + offset[1]),
              at: myAt.join(' ')
            };
          }
          position = $.extend({}, $.ui.dialog.prototype.options.position, position);
        } else {
          position = $.ui.dialog.prototype.options.position;
        }
        isVisible = this.uiDialog.is(':visible');
        if (!isVisible) {
          this.uiDialog.show();
        }
        this.uiDialog.position(position);
        if (!isVisible) {
          this.uiDialog.hide();
        }
      }
    });
  }
}(jQuery));
(function ($, undefined) {
  $.widget('ui.draggable', $.ui.mouse, {
    version: '1.10.4',
    widgetEventPrefix: 'drag',
    options: {
      addClasses: true,
      appendTo: 'parent',
      axis: false,
      connectToSortable: false,
      containment: false,
      cursor: 'auto',
      cursorAt: false,
      grid: false,
      handle: false,
      helper: 'original',
      iframeFix: false,
      opacity: false,
      refreshPositions: false,
      revert: false,
      revertDuration: 500,
      scope: 'default',
      scroll: true,
      scrollSensitivity: 20,
      scrollSpeed: 20,
      snap: false,
      snapMode: 'both',
      snapTolerance: 20,
      stack: false,
      zIndex: false,
      drag: null,
      start: null,
      stop: null
    },
    _create: function () {
      if (this.options.helper === 'original' && !/^(?:r|a|f)/.test(this.element.css('position'))) {
        this.element[0].style.position = 'relative';
      }
      if (this.options.addClasses) {
        this.element.addClass('ui-draggable');
      }
      if (this.options.disabled) {
        this.element.addClass('ui-draggable-disabled');
      }
      this._mouseInit();
    },
    _destroy: function () {
      this.element.removeClass('ui-draggable ui-draggable-dragging ui-draggable-disabled');
      this._mouseDestroy();
    },
    _mouseCapture: function (event) {
      var o = this.options;
      if (this.helper || o.disabled || $(event.target).closest('.ui-resizable-handle').length > 0) {
        return false;
      }
      this.handle = this._getHandle(event);
      if (!this.handle) {
        return false;
      }
      $(o.iframeFix === true ? 'iframe' : o.iframeFix).each(function () {
        $('<div class=\'ui-draggable-iframeFix\' style=\'background: #fff;\'></div>').css({
          width: this.offsetWidth + 'px',
          height: this.offsetHeight + 'px',
          position: 'absolute',
          opacity: '0.001',
          zIndex: 1000
        }).css($(this).offset()).appendTo('body');
      });
      return true;
    },
    _mouseStart: function (event) {
      var o = this.options;
      this.helper = this._createHelper(event);
      this.helper.addClass('ui-draggable-dragging');
      this._cacheHelperProportions();
      if ($.ui.ddmanager) {
        $.ui.ddmanager.current = this;
      }
      this._cacheMargins();
      this.cssPosition = this.helper.css('position');
      this.scrollParent = this.helper.scrollParent();
      this.offsetParent = this.helper.offsetParent();
      this.offsetParentCssPosition = this.offsetParent.css('position');
      this.offset = this.positionAbs = this.element.offset();
      this.offset = {
        top: this.offset.top - this.margins.top,
        left: this.offset.left - this.margins.left
      };
      this.offset.scroll = false;
      $.extend(this.offset, {
        click: {
          left: event.pageX - this.offset.left,
          top: event.pageY - this.offset.top
        },
        parent: this._getParentOffset(),
        relative: this._getRelativeOffset()
      });
      this.originalPosition = this.position = this._generatePosition(event);
      this.originalPageX = event.pageX;
      this.originalPageY = event.pageY;
      o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt);
      this._setContainment();
      if (this._trigger('start', event) === false) {
        this._clear();
        return false;
      }
      this._cacheHelperProportions();
      if ($.ui.ddmanager && !o.dropBehaviour) {
        $.ui.ddmanager.prepareOffsets(this, event);
      }
      this._mouseDrag(event, true);
      if ($.ui.ddmanager) {
        $.ui.ddmanager.dragStart(this, event);
      }
      return true;
    },
    _mouseDrag: function (event, noPropagation) {
      if (this.offsetParentCssPosition === 'fixed') {
        this.offset.parent = this._getParentOffset();
      }
      this.position = this._generatePosition(event);
      this.positionAbs = this._convertPositionTo('absolute');
      if (!noPropagation) {
        var ui = this._uiHash();
        if (this._trigger('drag', event, ui) === false) {
          this._mouseUp({});
          return false;
        }
        this.position = ui.position;
      }
      if (!this.options.axis || this.options.axis !== 'y') {
        this.helper[0].style.left = this.position.left + 'px';
      }
      if (!this.options.axis || this.options.axis !== 'x') {
        this.helper[0].style.top = this.position.top + 'px';
      }
      if ($.ui.ddmanager) {
        $.ui.ddmanager.drag(this, event);
      }
      return false;
    },
    _mouseStop: function (event) {
      var that = this, dropped = false;
      if ($.ui.ddmanager && !this.options.dropBehaviour) {
        dropped = $.ui.ddmanager.drop(this, event);
      }
      if (this.dropped) {
        dropped = this.dropped;
        this.dropped = false;
      }
      if (this.options.helper === 'original' && !$.contains(this.element[0].ownerDocument, this.element[0])) {
        return false;
      }
      if (this.options.revert === 'invalid' && !dropped || this.options.revert === 'valid' && dropped || this.options.revert === true || $.isFunction(this.options.revert) && this.options.revert.call(this.element, dropped)) {
        $(this.helper).animate(this.originalPosition, parseInt(this.options.revertDuration, 10), function () {
          if (that._trigger('stop', event) !== false) {
            that._clear();
          }
        });
      } else {
        if (this._trigger('stop', event) !== false) {
          this._clear();
        }
      }
      return false;
    },
    _mouseUp: function (event) {
      $('div.ui-draggable-iframeFix').each(function () {
        this.parentNode.removeChild(this);
      });
      if ($.ui.ddmanager) {
        $.ui.ddmanager.dragStop(this, event);
      }
      return $.ui.mouse.prototype._mouseUp.call(this, event);
    },
    cancel: function () {
      if (this.helper.is('.ui-draggable-dragging')) {
        this._mouseUp({});
      } else {
        this._clear();
      }
      return this;
    },
    _getHandle: function (event) {
      return this.options.handle ? !!$(event.target).closest(this.element.find(this.options.handle)).length : true;
    },
    _createHelper: function (event) {
      var o = this.options, helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event])) : o.helper === 'clone' ? this.element.clone().removeAttr('id') : this.element;
      if (!helper.parents('body').length) {
        helper.appendTo(o.appendTo === 'parent' ? this.element[0].parentNode : o.appendTo);
      }
      if (helper[0] !== this.element[0] && !/(fixed|absolute)/.test(helper.css('position'))) {
        helper.css('position', 'absolute');
      }
      return helper;
    },
    _adjustOffsetFromHelper: function (obj) {
      if (typeof obj === 'string') {
        obj = obj.split(' ');
      }
      if ($.isArray(obj)) {
        obj = {
          left: +obj[0],
          top: +obj[1] || 0
        };
      }
      if ('left' in obj) {
        this.offset.click.left = obj.left + this.margins.left;
      }
      if ('right' in obj) {
        this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
      }
      if ('top' in obj) {
        this.offset.click.top = obj.top + this.margins.top;
      }
      if ('bottom' in obj) {
        this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
      }
    },
    _getParentOffset: function () {
      var po = this.offsetParent.offset();
      if (this.cssPosition === 'absolute' && this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) {
        po.left += this.scrollParent.scrollLeft();
        po.top += this.scrollParent.scrollTop();
      }
      if (this.offsetParent[0] === document.body || this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() === 'html' && $.ui.ie) {
        po = {
          top: 0,
          left: 0
        };
      }
      return {
        top: po.top + (parseInt(this.offsetParent.css('borderTopWidth'), 10) || 0),
        left: po.left + (parseInt(this.offsetParent.css('borderLeftWidth'), 10) || 0)
      };
    },
    _getRelativeOffset: function () {
      if (this.cssPosition === 'relative') {
        var p = this.element.position();
        return {
          top: p.top - (parseInt(this.helper.css('top'), 10) || 0) + this.scrollParent.scrollTop(),
          left: p.left - (parseInt(this.helper.css('left'), 10) || 0) + this.scrollParent.scrollLeft()
        };
      } else {
        return {
          top: 0,
          left: 0
        };
      }
    },
    _cacheMargins: function () {
      this.margins = {
        left: parseInt(this.element.css('marginLeft'), 10) || 0,
        top: parseInt(this.element.css('marginTop'), 10) || 0,
        right: parseInt(this.element.css('marginRight'), 10) || 0,
        bottom: parseInt(this.element.css('marginBottom'), 10) || 0
      };
    },
    _cacheHelperProportions: function () {
      this.helperProportions = {
        width: this.helper.outerWidth(),
        height: this.helper.outerHeight()
      };
    },
    _setContainment: function () {
      var over, c, ce, o = this.options;
      if (!o.containment) {
        this.containment = null;
        return;
      }
      if (o.containment === 'window') {
        this.containment = [
          $(window).scrollLeft() - this.offset.relative.left - this.offset.parent.left,
          $(window).scrollTop() - this.offset.relative.top - this.offset.parent.top,
          $(window).scrollLeft() + $(window).width() - this.helperProportions.width - this.margins.left,
          $(window).scrollTop() + ($(window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top
        ];
        return;
      }
      if (o.containment === 'document') {
        this.containment = [
          0,
          0,
          $(document).width() - this.helperProportions.width - this.margins.left,
          ($(document).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top
        ];
        return;
      }
      if (o.containment.constructor === Array) {
        this.containment = o.containment;
        return;
      }
      if (o.containment === 'parent') {
        o.containment = this.helper[0].parentNode;
      }
      c = $(o.containment);
      ce = c[0];
      if (!ce) {
        return;
      }
      over = c.css('overflow') !== 'hidden';
      this.containment = [
        (parseInt(c.css('borderLeftWidth'), 10) || 0) + (parseInt(c.css('paddingLeft'), 10) || 0),
        (parseInt(c.css('borderTopWidth'), 10) || 0) + (parseInt(c.css('paddingTop'), 10) || 0),
        (over ? Math.max(ce.scrollWidth, ce.offsetWidth) : ce.offsetWidth) - (parseInt(c.css('borderRightWidth'), 10) || 0) - (parseInt(c.css('paddingRight'), 10) || 0) - this.helperProportions.width - this.margins.left - this.margins.right,
        (over ? Math.max(ce.scrollHeight, ce.offsetHeight) : ce.offsetHeight) - (parseInt(c.css('borderBottomWidth'), 10) || 0) - (parseInt(c.css('paddingBottom'), 10) || 0) - this.helperProportions.height - this.margins.top - this.margins.bottom
      ];
      this.relative_container = c;
    },
    _convertPositionTo: function (d, pos) {
      if (!pos) {
        pos = this.position;
      }
      var mod = d === 'absolute' ? 1 : -1, scroll = this.cssPosition === 'absolute' && !(this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent;
      if (!this.offset.scroll) {
        this.offset.scroll = {
          top: scroll.scrollTop(),
          left: scroll.scrollLeft()
        };
      }
      return {
        top: pos.top + this.offset.relative.top * mod + this.offset.parent.top * mod - (this.cssPosition === 'fixed' ? -this.scrollParent.scrollTop() : this.offset.scroll.top) * mod,
        left: pos.left + this.offset.relative.left * mod + this.offset.parent.left * mod - (this.cssPosition === 'fixed' ? -this.scrollParent.scrollLeft() : this.offset.scroll.left) * mod
      };
    },
    _generatePosition: function (event) {
      var containment, co, top, left, o = this.options, scroll = this.cssPosition === 'absolute' && !(this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, pageX = event.pageX, pageY = event.pageY;
      if (!this.offset.scroll) {
        this.offset.scroll = {
          top: scroll.scrollTop(),
          left: scroll.scrollLeft()
        };
      }
      if (this.originalPosition) {
        if (this.containment) {
          if (this.relative_container) {
            co = this.relative_container.offset();
            containment = [
              this.containment[0] + co.left,
              this.containment[1] + co.top,
              this.containment[2] + co.left,
              this.containment[3] + co.top
            ];
          } else {
            containment = this.containment;
          }
          if (event.pageX - this.offset.click.left < containment[0]) {
            pageX = containment[0] + this.offset.click.left;
          }
          if (event.pageY - this.offset.click.top < containment[1]) {
            pageY = containment[1] + this.offset.click.top;
          }
          if (event.pageX - this.offset.click.left > containment[2]) {
            pageX = containment[2] + this.offset.click.left;
          }
          if (event.pageY - this.offset.click.top > containment[3]) {
            pageY = containment[3] + this.offset.click.top;
          }
        }
        if (o.grid) {
          top = o.grid[1] ? this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1] : this.originalPageY;
          pageY = containment ? top - this.offset.click.top >= containment[1] || top - this.offset.click.top > containment[3] ? top : top - this.offset.click.top >= containment[1] ? top - o.grid[1] : top + o.grid[1] : top;
          left = o.grid[0] ? this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0] : this.originalPageX;
          pageX = containment ? left - this.offset.click.left >= containment[0] || left - this.offset.click.left > containment[2] ? left : left - this.offset.click.left >= containment[0] ? left - o.grid[0] : left + o.grid[0] : left;
        }
      }
      return {
        top: pageY - this.offset.click.top - this.offset.relative.top - this.offset.parent.top + (this.cssPosition === 'fixed' ? -this.scrollParent.scrollTop() : this.offset.scroll.top),
        left: pageX - this.offset.click.left - this.offset.relative.left - this.offset.parent.left + (this.cssPosition === 'fixed' ? -this.scrollParent.scrollLeft() : this.offset.scroll.left)
      };
    },
    _clear: function () {
      this.helper.removeClass('ui-draggable-dragging');
      if (this.helper[0] !== this.element[0] && !this.cancelHelperRemoval) {
        this.helper.remove();
      }
      this.helper = null;
      this.cancelHelperRemoval = false;
    },
    _trigger: function (type, event, ui) {
      ui = ui || this._uiHash();
      $.ui.plugin.call(this, type, [
        event,
        ui
      ]);
      if (type === 'drag') {
        this.positionAbs = this._convertPositionTo('absolute');
      }
      return $.Widget.prototype._trigger.call(this, type, event, ui);
    },
    plugins: {},
    _uiHash: function () {
      return {
        helper: this.helper,
        position: this.position,
        originalPosition: this.originalPosition,
        offset: this.positionAbs
      };
    }
  });
  $.ui.plugin.add('draggable', 'connectToSortable', {
    start: function (event, ui) {
      var inst = $(this).data('ui-draggable'), o = inst.options, uiSortable = $.extend({}, ui, { item: inst.element });
      inst.sortables = [];
      $(o.connectToSortable).each(function () {
        var sortable = $.data(this, 'ui-sortable');
        if (sortable && !sortable.options.disabled) {
          inst.sortables.push({
            instance: sortable,
            shouldRevert: sortable.options.revert
          });
          sortable.refreshPositions();
          sortable._trigger('activate', event, uiSortable);
        }
      });
    },
    stop: function (event, ui) {
      var inst = $(this).data('ui-draggable'), uiSortable = $.extend({}, ui, { item: inst.element });
      $.each(inst.sortables, function () {
        if (this.instance.isOver) {
          this.instance.isOver = 0;
          inst.cancelHelperRemoval = true;
          this.instance.cancelHelperRemoval = false;
          if (this.shouldRevert) {
            this.instance.options.revert = this.shouldRevert;
          }
          this.instance._mouseStop(event);
          this.instance.options.helper = this.instance.options._helper;
          if (inst.options.helper === 'original') {
            this.instance.currentItem.css({
              top: 'auto',
              left: 'auto'
            });
          }
        } else {
          this.instance.cancelHelperRemoval = false;
          this.instance._trigger('deactivate', event, uiSortable);
        }
      });
    },
    drag: function (event, ui) {
      var inst = $(this).data('ui-draggable'), that = this;
      $.each(inst.sortables, function () {
        var innermostIntersecting = false, thisSortable = this;
        this.instance.positionAbs = inst.positionAbs;
        this.instance.helperProportions = inst.helperProportions;
        this.instance.offset.click = inst.offset.click;
        if (this.instance._intersectsWith(this.instance.containerCache)) {
          innermostIntersecting = true;
          $.each(inst.sortables, function () {
            this.instance.positionAbs = inst.positionAbs;
            this.instance.helperProportions = inst.helperProportions;
            this.instance.offset.click = inst.offset.click;
            if (this !== thisSortable && this.instance._intersectsWith(this.instance.containerCache) && $.contains(thisSortable.instance.element[0], this.instance.element[0])) {
              innermostIntersecting = false;
            }
            return innermostIntersecting;
          });
        }
        if (innermostIntersecting) {
          if (!this.instance.isOver) {
            this.instance.isOver = 1;
            this.instance.currentItem = $(that).clone().removeAttr('id').appendTo(this.instance.element).data('ui-sortable-item', true);
            this.instance.options._helper = this.instance.options.helper;
            this.instance.options.helper = function () {
              return ui.helper[0];
            };
            event.target = this.instance.currentItem[0];
            this.instance._mouseCapture(event, true);
            this.instance._mouseStart(event, true, true);
            this.instance.offset.click.top = inst.offset.click.top;
            this.instance.offset.click.left = inst.offset.click.left;
            this.instance.offset.parent.left -= inst.offset.parent.left - this.instance.offset.parent.left;
            this.instance.offset.parent.top -= inst.offset.parent.top - this.instance.offset.parent.top;
            inst._trigger('toSortable', event);
            inst.dropped = this.instance.element;
            inst.currentItem = inst.element;
            this.instance.fromOutside = inst;
          }
          if (this.instance.currentItem) {
            this.instance._mouseDrag(event);
          }
        } else {
          if (this.instance.isOver) {
            this.instance.isOver = 0;
            this.instance.cancelHelperRemoval = true;
            this.instance.options.revert = false;
            this.instance._trigger('out', event, this.instance._uiHash(this.instance));
            this.instance._mouseStop(event, true);
            this.instance.options.helper = this.instance.options._helper;
            this.instance.currentItem.remove();
            if (this.instance.placeholder) {
              this.instance.placeholder.remove();
            }
            inst._trigger('fromSortable', event);
            inst.dropped = false;
          }
        }
      });
    }
  });
  $.ui.plugin.add('draggable', 'cursor', {
    start: function () {
      var t = $('body'), o = $(this).data('ui-draggable').options;
      if (t.css('cursor')) {
        o._cursor = t.css('cursor');
      }
      t.css('cursor', o.cursor);
    },
    stop: function () {
      var o = $(this).data('ui-draggable').options;
      if (o._cursor) {
        $('body').css('cursor', o._cursor);
      }
    }
  });
  $.ui.plugin.add('draggable', 'opacity', {
    start: function (event, ui) {
      var t = $(ui.helper), o = $(this).data('ui-draggable').options;
      if (t.css('opacity')) {
        o._opacity = t.css('opacity');
      }
      t.css('opacity', o.opacity);
    },
    stop: function (event, ui) {
      var o = $(this).data('ui-draggable').options;
      if (o._opacity) {
        $(ui.helper).css('opacity', o._opacity);
      }
    }
  });
  $.ui.plugin.add('draggable', 'scroll', {
    start: function () {
      var i = $(this).data('ui-draggable');
      if (i.scrollParent[0] !== document && i.scrollParent[0].tagName !== 'HTML') {
        i.overflowOffset = i.scrollParent.offset();
      }
    },
    drag: function (event) {
      var i = $(this).data('ui-draggable'), o = i.options, scrolled = false;
      if (i.scrollParent[0] !== document && i.scrollParent[0].tagName !== 'HTML') {
        if (!o.axis || o.axis !== 'x') {
          if (i.overflowOffset.top + i.scrollParent[0].offsetHeight - event.pageY < o.scrollSensitivity) {
            i.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop + o.scrollSpeed;
          } else if (event.pageY - i.overflowOffset.top < o.scrollSensitivity) {
            i.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop - o.scrollSpeed;
          }
        }
        if (!o.axis || o.axis !== 'y') {
          if (i.overflowOffset.left + i.scrollParent[0].offsetWidth - event.pageX < o.scrollSensitivity) {
            i.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft + o.scrollSpeed;
          } else if (event.pageX - i.overflowOffset.left < o.scrollSensitivity) {
            i.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft - o.scrollSpeed;
          }
        }
      } else {
        if (!o.axis || o.axis !== 'x') {
          if (event.pageY - $(document).scrollTop() < o.scrollSensitivity) {
            scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
          } else if ($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity) {
            scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);
          }
        }
        if (!o.axis || o.axis !== 'y') {
          if (event.pageX - $(document).scrollLeft() < o.scrollSensitivity) {
            scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
          } else if ($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity) {
            scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);
          }
        }
      }
      if (scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {
        $.ui.ddmanager.prepareOffsets(i, event);
      }
    }
  });
  $.ui.plugin.add('draggable', 'snap', {
    start: function () {
      var i = $(this).data('ui-draggable'), o = i.options;
      i.snapElements = [];
      $(o.snap.constructor !== String ? o.snap.items || ':data(ui-draggable)' : o.snap).each(function () {
        var $t = $(this), $o = $t.offset();
        if (this !== i.element[0]) {
          i.snapElements.push({
            item: this,
            width: $t.outerWidth(),
            height: $t.outerHeight(),
            top: $o.top,
            left: $o.left
          });
        }
      });
    },
    drag: function (event, ui) {
      var ts, bs, ls, rs, l, r, t, b, i, first, inst = $(this).data('ui-draggable'), o = inst.options, d = o.snapTolerance, x1 = ui.offset.left, x2 = x1 + inst.helperProportions.width, y1 = ui.offset.top, y2 = y1 + inst.helperProportions.height;
      for (i = inst.snapElements.length - 1; i >= 0; i--) {
        l = inst.snapElements[i].left;
        r = l + inst.snapElements[i].width;
        t = inst.snapElements[i].top;
        b = t + inst.snapElements[i].height;
        if (x2 < l - d || x1 > r + d || y2 < t - d || y1 > b + d || !$.contains(inst.snapElements[i].item.ownerDocument, inst.snapElements[i].item)) {
          if (inst.snapElements[i].snapping) {
            inst.options.snap.release && inst.options.snap.release.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item }));
          }
          inst.snapElements[i].snapping = false;
          continue;
        }
        if (o.snapMode !== 'inner') {
          ts = Math.abs(t - y2) <= d;
          bs = Math.abs(b - y1) <= d;
          ls = Math.abs(l - x2) <= d;
          rs = Math.abs(r - x1) <= d;
          if (ts) {
            ui.position.top = inst._convertPositionTo('relative', {
              top: t - inst.helperProportions.height,
              left: 0
            }).top - inst.margins.top;
          }
          if (bs) {
            ui.position.top = inst._convertPositionTo('relative', {
              top: b,
              left: 0
            }).top - inst.margins.top;
          }
          if (ls) {
            ui.position.left = inst._convertPositionTo('relative', {
              top: 0,
              left: l - inst.helperProportions.width
            }).left - inst.margins.left;
          }
          if (rs) {
            ui.position.left = inst._convertPositionTo('relative', {
              top: 0,
              left: r
            }).left - inst.margins.left;
          }
        }
        first = ts || bs || ls || rs;
        if (o.snapMode !== 'outer') {
          ts = Math.abs(t - y1) <= d;
          bs = Math.abs(b - y2) <= d;
          ls = Math.abs(l - x1) <= d;
          rs = Math.abs(r - x2) <= d;
          if (ts) {
            ui.position.top = inst._convertPositionTo('relative', {
              top: t,
              left: 0
            }).top - inst.margins.top;
          }
          if (bs) {
            ui.position.top = inst._convertPositionTo('relative', {
              top: b - inst.helperProportions.height,
              left: 0
            }).top - inst.margins.top;
          }
          if (ls) {
            ui.position.left = inst._convertPositionTo('relative', {
              top: 0,
              left: l
            }).left - inst.margins.left;
          }
          if (rs) {
            ui.position.left = inst._convertPositionTo('relative', {
              top: 0,
              left: r - inst.helperProportions.width
            }).left - inst.margins.left;
          }
        }
        if (!inst.snapElements[i].snapping && (ts || bs || ls || rs || first)) {
          inst.options.snap.snap && inst.options.snap.snap.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item }));
        }
        inst.snapElements[i].snapping = ts || bs || ls || rs || first;
      }
    }
  });
  $.ui.plugin.add('draggable', 'stack', {
    start: function () {
      var min, o = this.data('ui-draggable').options, group = $.makeArray($(o.stack)).sort(function (a, b) {
          return (parseInt($(a).css('zIndex'), 10) || 0) - (parseInt($(b).css('zIndex'), 10) || 0);
        });
      if (!group.length) {
        return;
      }
      min = parseInt($(group[0]).css('zIndex'), 10) || 0;
      $(group).each(function (i) {
        $(this).css('zIndex', min + i);
      });
      this.css('zIndex', min + group.length);
    }
  });
  $.ui.plugin.add('draggable', 'zIndex', {
    start: function (event, ui) {
      var t = $(ui.helper), o = $(this).data('ui-draggable').options;
      if (t.css('zIndex')) {
        o._zIndex = t.css('zIndex');
      }
      t.css('zIndex', o.zIndex);
    },
    stop: function (event, ui) {
      var o = $(this).data('ui-draggable').options;
      if (o._zIndex) {
        $(ui.helper).css('zIndex', o._zIndex);
      }
    }
  });
}(jQuery));
(function ($, undefined) {
  function isOverAxis(x, reference, size) {
    return x > reference && x < reference + size;
  }
  $.widget('ui.droppable', {
    version: '1.10.4',
    widgetEventPrefix: 'drop',
    options: {
      accept: '*',
      activeClass: false,
      addClasses: true,
      greedy: false,
      hoverClass: false,
      scope: 'default',
      tolerance: 'intersect',
      activate: null,
      deactivate: null,
      drop: null,
      out: null,
      over: null
    },
    _create: function () {
      var proportions, o = this.options, accept = o.accept;
      this.isover = false;
      this.isout = true;
      this.accept = $.isFunction(accept) ? accept : function (d) {
        return d.is(accept);
      };
      this.proportions = function () {
        if (arguments.length) {
          proportions = arguments[0];
        } else {
          return proportions ? proportions : proportions = {
            width: this.element[0].offsetWidth,
            height: this.element[0].offsetHeight
          };
        }
      };
      $.ui.ddmanager.droppables[o.scope] = $.ui.ddmanager.droppables[o.scope] || [];
      $.ui.ddmanager.droppables[o.scope].push(this);
      o.addClasses && this.element.addClass('ui-droppable');
    },
    _destroy: function () {
      var i = 0, drop = $.ui.ddmanager.droppables[this.options.scope];
      for (; i < drop.length; i++) {
        if (drop[i] === this) {
          drop.splice(i, 1);
        }
      }
      this.element.removeClass('ui-droppable ui-droppable-disabled');
    },
    _setOption: function (key, value) {
      if (key === 'accept') {
        this.accept = $.isFunction(value) ? value : function (d) {
          return d.is(value);
        };
      }
      $.Widget.prototype._setOption.apply(this, arguments);
    },
    _activate: function (event) {
      var draggable = $.ui.ddmanager.current;
      if (this.options.activeClass) {
        this.element.addClass(this.options.activeClass);
      }
      if (draggable) {
        this._trigger('activate', event, this.ui(draggable));
      }
    },
    _deactivate: function (event) {
      var draggable = $.ui.ddmanager.current;
      if (this.options.activeClass) {
        this.element.removeClass(this.options.activeClass);
      }
      if (draggable) {
        this._trigger('deactivate', event, this.ui(draggable));
      }
    },
    _over: function (event) {
      var draggable = $.ui.ddmanager.current;
      if (!draggable || (draggable.currentItem || draggable.element)[0] === this.element[0]) {
        return;
      }
      if (this.accept.call(this.element[0], draggable.currentItem || draggable.element)) {
        if (this.options.hoverClass) {
          this.element.addClass(this.options.hoverClass);
        }
        this._trigger('over', event, this.ui(draggable));
      }
    },
    _out: function (event) {
      var draggable = $.ui.ddmanager.current;
      if (!draggable || (draggable.currentItem || draggable.element)[0] === this.element[0]) {
        return;
      }
      if (this.accept.call(this.element[0], draggable.currentItem || draggable.element)) {
        if (this.options.hoverClass) {
          this.element.removeClass(this.options.hoverClass);
        }
        this._trigger('out', event, this.ui(draggable));
      }
    },
    _drop: function (event, custom) {
      var draggable = custom || $.ui.ddmanager.current, childrenIntersection = false;
      if (!draggable || (draggable.currentItem || draggable.element)[0] === this.element[0]) {
        return false;
      }
      this.element.find(':data(ui-droppable)').not('.ui-draggable-dragging').each(function () {
        var inst = $.data(this, 'ui-droppable');
        if (inst.options.greedy && !inst.options.disabled && inst.options.scope === draggable.options.scope && inst.accept.call(inst.element[0], draggable.currentItem || draggable.element) && $.ui.intersect(draggable, $.extend(inst, { offset: inst.element.offset() }), inst.options.tolerance)) {
          childrenIntersection = true;
          return false;
        }
      });
      if (childrenIntersection) {
        return false;
      }
      if (this.accept.call(this.element[0], draggable.currentItem || draggable.element)) {
        if (this.options.activeClass) {
          this.element.removeClass(this.options.activeClass);
        }
        if (this.options.hoverClass) {
          this.element.removeClass(this.options.hoverClass);
        }
        this._trigger('drop', event, this.ui(draggable));
        return this.element;
      }
      return false;
    },
    ui: function (c) {
      return {
        draggable: c.currentItem || c.element,
        helper: c.helper,
        position: c.position,
        offset: c.positionAbs
      };
    }
  });
  $.ui.intersect = function (draggable, droppable, toleranceMode) {
    if (!droppable.offset) {
      return false;
    }
    var draggableLeft, draggableTop, x1 = (draggable.positionAbs || draggable.position.absolute).left, y1 = (draggable.positionAbs || draggable.position.absolute).top, x2 = x1 + draggable.helperProportions.width, y2 = y1 + draggable.helperProportions.height, l = droppable.offset.left, t = droppable.offset.top, r = l + droppable.proportions().width, b = t + droppable.proportions().height;
    switch (toleranceMode) {
    case 'fit':
      return l <= x1 && x2 <= r && t <= y1 && y2 <= b;
    case 'intersect':
      return l < x1 + draggable.helperProportions.width / 2 && x2 - draggable.helperProportions.width / 2 < r && t < y1 + draggable.helperProportions.height / 2 && y2 - draggable.helperProportions.height / 2 < b;
    case 'pointer':
      draggableLeft = (draggable.positionAbs || draggable.position.absolute).left + (draggable.clickOffset || draggable.offset.click).left;
      draggableTop = (draggable.positionAbs || draggable.position.absolute).top + (draggable.clickOffset || draggable.offset.click).top;
      return isOverAxis(draggableTop, t, droppable.proportions().height) && isOverAxis(draggableLeft, l, droppable.proportions().width);
    case 'touch':
      return (y1 >= t && y1 <= b || y2 >= t && y2 <= b || y1 < t && y2 > b) && (x1 >= l && x1 <= r || x2 >= l && x2 <= r || x1 < l && x2 > r);
    default:
      return false;
    }
  };
  $.ui.ddmanager = {
    current: null,
    droppables: { 'default': [] },
    prepareOffsets: function (t, event) {
      var i, j, m = $.ui.ddmanager.droppables[t.options.scope] || [], type = event ? event.type : null, list = (t.currentItem || t.element).find(':data(ui-droppable)').addBack();
      droppablesLoop:
        for (i = 0; i < m.length; i++) {
          if (m[i].options.disabled || t && !m[i].accept.call(m[i].element[0], t.currentItem || t.element)) {
            continue;
          }
          for (j = 0; j < list.length; j++) {
            if (list[j] === m[i].element[0]) {
              m[i].proportions().height = 0;
              continue droppablesLoop;
            }
          }
          m[i].visible = m[i].element.css('display') !== 'none';
          if (!m[i].visible) {
            continue;
          }
          if (type === 'mousedown') {
            m[i]._activate.call(m[i], event);
          }
          m[i].offset = m[i].element.offset();
          m[i].proportions({
            width: m[i].element[0].offsetWidth,
            height: m[i].element[0].offsetHeight
          });
        }
    },
    drop: function (draggable, event) {
      var dropped = false;
      $.each(($.ui.ddmanager.droppables[draggable.options.scope] || []).slice(), function () {
        if (!this.options) {
          return;
        }
        if (!this.options.disabled && this.visible && $.ui.intersect(draggable, this, this.options.tolerance)) {
          dropped = this._drop.call(this, event) || dropped;
        }
        if (!this.options.disabled && this.visible && this.accept.call(this.element[0], draggable.currentItem || draggable.element)) {
          this.isout = true;
          this.isover = false;
          this._deactivate.call(this, event);
        }
      });
      return dropped;
    },
    dragStart: function (draggable, event) {
      draggable.element.parentsUntil('body').bind('scroll.droppable', function () {
        if (!draggable.options.refreshPositions) {
          $.ui.ddmanager.prepareOffsets(draggable, event);
        }
      });
    },
    drag: function (draggable, event) {
      if (draggable.options.refreshPositions) {
        $.ui.ddmanager.prepareOffsets(draggable, event);
      }
      $.each($.ui.ddmanager.droppables[draggable.options.scope] || [], function () {
        if (this.options.disabled || this.greedyChild || !this.visible) {
          return;
        }
        var parentInstance, scope, parent, intersects = $.ui.intersect(draggable, this, this.options.tolerance), c = !intersects && this.isover ? 'isout' : intersects && !this.isover ? 'isover' : null;
        if (!c) {
          return;
        }
        if (this.options.greedy) {
          scope = this.options.scope;
          parent = this.element.parents(':data(ui-droppable)').filter(function () {
            return $.data(this, 'ui-droppable').options.scope === scope;
          });
          if (parent.length) {
            parentInstance = $.data(parent[0], 'ui-droppable');
            parentInstance.greedyChild = c === 'isover';
          }
        }
        if (parentInstance && c === 'isover') {
          parentInstance.isover = false;
          parentInstance.isout = true;
          parentInstance._out.call(parentInstance, event);
        }
        this[c] = true;
        this[c === 'isout' ? 'isover' : 'isout'] = false;
        this[c === 'isover' ? '_over' : '_out'].call(this, event);
        if (parentInstance && c === 'isout') {
          parentInstance.isout = false;
          parentInstance.isover = true;
          parentInstance._over.call(parentInstance, event);
        }
      });
    },
    dragStop: function (draggable, event) {
      draggable.element.parentsUntil('body').unbind('scroll.droppable');
      if (!draggable.options.refreshPositions) {
        $.ui.ddmanager.prepareOffsets(draggable, event);
      }
    }
  };
}(jQuery));
(function ($, undefined) {
  var dataSpace = 'ui-effects-';
  $.effects = { effect: {} };
  (function (jQuery, undefined) {
    var stepHooks = 'backgroundColor borderBottomColor borderLeftColor borderRightColor borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor', rplusequals = /^([\-+])=\s*(\d+\.?\d*)/, stringParsers = [
        {
          re: /rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
          parse: function (execResult) {
            return [
              execResult[1],
              execResult[2],
              execResult[3],
              execResult[4]
            ];
          }
        },
        {
          re: /rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
          parse: function (execResult) {
            return [
              execResult[1] * 2.55,
              execResult[2] * 2.55,
              execResult[3] * 2.55,
              execResult[4]
            ];
          }
        },
        {
          re: /#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})/,
          parse: function (execResult) {
            return [
              parseInt(execResult[1], 16),
              parseInt(execResult[2], 16),
              parseInt(execResult[3], 16)
            ];
          }
        },
        {
          re: /#([a-f0-9])([a-f0-9])([a-f0-9])/,
          parse: function (execResult) {
            return [
              parseInt(execResult[1] + execResult[1], 16),
              parseInt(execResult[2] + execResult[2], 16),
              parseInt(execResult[3] + execResult[3], 16)
            ];
          }
        },
        {
          re: /hsla?\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
          space: 'hsla',
          parse: function (execResult) {
            return [
              execResult[1],
              execResult[2] / 100,
              execResult[3] / 100,
              execResult[4]
            ];
          }
        }
      ], color = jQuery.Color = function (color, green, blue, alpha) {
        return new jQuery.Color.fn.parse(color, green, blue, alpha);
      }, spaces = {
        rgba: {
          props: {
            red: {
              idx: 0,
              type: 'byte'
            },
            green: {
              idx: 1,
              type: 'byte'
            },
            blue: {
              idx: 2,
              type: 'byte'
            }
          }
        },
        hsla: {
          props: {
            hue: {
              idx: 0,
              type: 'degrees'
            },
            saturation: {
              idx: 1,
              type: 'percent'
            },
            lightness: {
              idx: 2,
              type: 'percent'
            }
          }
        }
      }, propTypes = {
        'byte': {
          floor: true,
          max: 255
        },
        'percent': { max: 1 },
        'degrees': {
          mod: 360,
          floor: true
        }
      }, support = color.support = {}, supportElem = jQuery('<p>')[0], colors, each = jQuery.each;
    supportElem.style.cssText = 'background-color:rgba(1,1,1,.5)';
    support.rgba = supportElem.style.backgroundColor.indexOf('rgba') > -1;
    each(spaces, function (spaceName, space) {
      space.cache = '_' + spaceName;
      space.props.alpha = {
        idx: 3,
        type: 'percent',
        def: 1
      };
    });
    function clamp(value, prop, allowEmpty) {
      var type = propTypes[prop.type] || {};
      if (value == null) {
        return allowEmpty || !prop.def ? null : prop.def;
      }
      value = type.floor ? ~~value : parseFloat(value);
      if (isNaN(value)) {
        return prop.def;
      }
      if (type.mod) {
        return (value + type.mod) % type.mod;
      }
      return 0 > value ? 0 : type.max < value ? type.max : value;
    }
    function stringParse(string) {
      var inst = color(), rgba = inst._rgba = [];
      string = string.toLowerCase();
      each(stringParsers, function (i, parser) {
        var parsed, match = parser.re.exec(string), values = match && parser.parse(match), spaceName = parser.space || 'rgba';
        if (values) {
          parsed = inst[spaceName](values);
          inst[spaces[spaceName].cache] = parsed[spaces[spaceName].cache];
          rgba = inst._rgba = parsed._rgba;
          return false;
        }
      });
      if (rgba.length) {
        if (rgba.join() === '0,0,0,0') {
          jQuery.extend(rgba, colors.transparent);
        }
        return inst;
      }
      return colors[string];
    }
    color.fn = jQuery.extend(color.prototype, {
      parse: function (red, green, blue, alpha) {
        if (red === undefined) {
          this._rgba = [
            null,
            null,
            null,
            null
          ];
          return this;
        }
        if (red.jquery || red.nodeType) {
          red = jQuery(red).css(green);
          green = undefined;
        }
        var inst = this, type = jQuery.type(red), rgba = this._rgba = [];
        if (green !== undefined) {
          red = [
            red,
            green,
            blue,
            alpha
          ];
          type = 'array';
        }
        if (type === 'string') {
          return this.parse(stringParse(red) || colors._default);
        }
        if (type === 'array') {
          each(spaces.rgba.props, function (key, prop) {
            rgba[prop.idx] = clamp(red[prop.idx], prop);
          });
          return this;
        }
        if (type === 'object') {
          if (red instanceof color) {
            each(spaces, function (spaceName, space) {
              if (red[space.cache]) {
                inst[space.cache] = red[space.cache].slice();
              }
            });
          } else {
            each(spaces, function (spaceName, space) {
              var cache = space.cache;
              each(space.props, function (key, prop) {
                if (!inst[cache] && space.to) {
                  if (key === 'alpha' || red[key] == null) {
                    return;
                  }
                  inst[cache] = space.to(inst._rgba);
                }
                inst[cache][prop.idx] = clamp(red[key], prop, true);
              });
              if (inst[cache] && jQuery.inArray(null, inst[cache].slice(0, 3)) < 0) {
                inst[cache][3] = 1;
                if (space.from) {
                  inst._rgba = space.from(inst[cache]);
                }
              }
            });
          }
          return this;
        }
      },
      is: function (compare) {
        var is = color(compare), same = true, inst = this;
        each(spaces, function (_, space) {
          var localCache, isCache = is[space.cache];
          if (isCache) {
            localCache = inst[space.cache] || space.to && space.to(inst._rgba) || [];
            each(space.props, function (_, prop) {
              if (isCache[prop.idx] != null) {
                same = isCache[prop.idx] === localCache[prop.idx];
                return same;
              }
            });
          }
          return same;
        });
        return same;
      },
      _space: function () {
        var used = [], inst = this;
        each(spaces, function (spaceName, space) {
          if (inst[space.cache]) {
            used.push(spaceName);
          }
        });
        return used.pop();
      },
      transition: function (other, distance) {
        var end = color(other), spaceName = end._space(), space = spaces[spaceName], startColor = this.alpha() === 0 ? color('transparent') : this, start = startColor[space.cache] || space.to(startColor._rgba), result = start.slice();
        end = end[space.cache];
        each(space.props, function (key, prop) {
          var index = prop.idx, startValue = start[index], endValue = end[index], type = propTypes[prop.type] || {};
          if (endValue === null) {
            return;
          }
          if (startValue === null) {
            result[index] = endValue;
          } else {
            if (type.mod) {
              if (endValue - startValue > type.mod / 2) {
                startValue += type.mod;
              } else if (startValue - endValue > type.mod / 2) {
                startValue -= type.mod;
              }
            }
            result[index] = clamp((endValue - startValue) * distance + startValue, prop);
          }
        });
        return this[spaceName](result);
      },
      blend: function (opaque) {
        if (this._rgba[3] === 1) {
          return this;
        }
        var rgb = this._rgba.slice(), a = rgb.pop(), blend = color(opaque)._rgba;
        return color(jQuery.map(rgb, function (v, i) {
          return (1 - a) * blend[i] + a * v;
        }));
      },
      toRgbaString: function () {
        var prefix = 'rgba(', rgba = jQuery.map(this._rgba, function (v, i) {
            return v == null ? i > 2 ? 1 : 0 : v;
          });
        if (rgba[3] === 1) {
          rgba.pop();
          prefix = 'rgb(';
        }
        return prefix + rgba.join() + ')';
      },
      toHslaString: function () {
        var prefix = 'hsla(', hsla = jQuery.map(this.hsla(), function (v, i) {
            if (v == null) {
              v = i > 2 ? 1 : 0;
            }
            if (i && i < 3) {
              v = Math.round(v * 100) + '%';
            }
            return v;
          });
        if (hsla[3] === 1) {
          hsla.pop();
          prefix = 'hsl(';
        }
        return prefix + hsla.join() + ')';
      },
      toHexString: function (includeAlpha) {
        var rgba = this._rgba.slice(), alpha = rgba.pop();
        if (includeAlpha) {
          rgba.push(~~(alpha * 255));
        }
        return '#' + jQuery.map(rgba, function (v) {
          v = (v || 0).toString(16);
          return v.length === 1 ? '0' + v : v;
        }).join('');
      },
      toString: function () {
        return this._rgba[3] === 0 ? 'transparent' : this.toRgbaString();
      }
    });
    color.fn.parse.prototype = color.fn;
    function hue2rgb(p, q, h) {
      h = (h + 1) % 1;
      if (h * 6 < 1) {
        return p + (q - p) * h * 6;
      }
      if (h * 2 < 1) {
        return q;
      }
      if (h * 3 < 2) {
        return p + (q - p) * (2 / 3 - h) * 6;
      }
      return p;
    }
    spaces.hsla.to = function (rgba) {
      if (rgba[0] == null || rgba[1] == null || rgba[2] == null) {
        return [
          null,
          null,
          null,
          rgba[3]
        ];
      }
      var r = rgba[0] / 255, g = rgba[1] / 255, b = rgba[2] / 255, a = rgba[3], max = Math.max(r, g, b), min = Math.min(r, g, b), diff = max - min, add = max + min, l = add * 0.5, h, s;
      if (min === max) {
        h = 0;
      } else if (r === max) {
        h = 60 * (g - b) / diff + 360;
      } else if (g === max) {
        h = 60 * (b - r) / diff + 120;
      } else {
        h = 60 * (r - g) / diff + 240;
      }
      if (diff === 0) {
        s = 0;
      } else if (l <= 0.5) {
        s = diff / add;
      } else {
        s = diff / (2 - add);
      }
      return [
        Math.round(h) % 360,
        s,
        l,
        a == null ? 1 : a
      ];
    };
    spaces.hsla.from = function (hsla) {
      if (hsla[0] == null || hsla[1] == null || hsla[2] == null) {
        return [
          null,
          null,
          null,
          hsla[3]
        ];
      }
      var h = hsla[0] / 360, s = hsla[1], l = hsla[2], a = hsla[3], q = l <= 0.5 ? l * (1 + s) : l + s - l * s, p = 2 * l - q;
      return [
        Math.round(hue2rgb(p, q, h + 1 / 3) * 255),
        Math.round(hue2rgb(p, q, h) * 255),
        Math.round(hue2rgb(p, q, h - 1 / 3) * 255),
        a
      ];
    };
    each(spaces, function (spaceName, space) {
      var props = space.props, cache = space.cache, to = space.to, from = space.from;
      color.fn[spaceName] = function (value) {
        if (to && !this[cache]) {
          this[cache] = to(this._rgba);
        }
        if (value === undefined) {
          return this[cache].slice();
        }
        var ret, type = jQuery.type(value), arr = type === 'array' || type === 'object' ? value : arguments, local = this[cache].slice();
        each(props, function (key, prop) {
          var val = arr[type === 'object' ? key : prop.idx];
          if (val == null) {
            val = local[prop.idx];
          }
          local[prop.idx] = clamp(val, prop);
        });
        if (from) {
          ret = color(from(local));
          ret[cache] = local;
          return ret;
        } else {
          return color(local);
        }
      };
      each(props, function (key, prop) {
        if (color.fn[key]) {
          return;
        }
        color.fn[key] = function (value) {
          var vtype = jQuery.type(value), fn = key === 'alpha' ? this._hsla ? 'hsla' : 'rgba' : spaceName, local = this[fn](), cur = local[prop.idx], match;
          if (vtype === 'undefined') {
            return cur;
          }
          if (vtype === 'function') {
            value = value.call(this, cur);
            vtype = jQuery.type(value);
          }
          if (value == null && prop.empty) {
            return this;
          }
          if (vtype === 'string') {
            match = rplusequals.exec(value);
            if (match) {
              value = cur + parseFloat(match[2]) * (match[1] === '+' ? 1 : -1);
            }
          }
          local[prop.idx] = value;
          return this[fn](local);
        };
      });
    });
    color.hook = function (hook) {
      var hooks = hook.split(' ');
      each(hooks, function (i, hook) {
        jQuery.cssHooks[hook] = {
          set: function (elem, value) {
            var parsed, curElem, backgroundColor = '';
            if (value !== 'transparent' && (jQuery.type(value) !== 'string' || (parsed = stringParse(value)))) {
              value = color(parsed || value);
              if (!support.rgba && value._rgba[3] !== 1) {
                curElem = hook === 'backgroundColor' ? elem.parentNode : elem;
                while ((backgroundColor === '' || backgroundColor === 'transparent') && curElem && curElem.style) {
                  try {
                    backgroundColor = jQuery.css(curElem, 'backgroundColor');
                    curElem = curElem.parentNode;
                  } catch (e) {
                  }
                }
                value = value.blend(backgroundColor && backgroundColor !== 'transparent' ? backgroundColor : '_default');
              }
              value = value.toRgbaString();
            }
            try {
              elem.style[hook] = value;
            } catch (e) {
            }
          }
        };
        jQuery.fx.step[hook] = function (fx) {
          if (!fx.colorInit) {
            fx.start = color(fx.elem, hook);
            fx.end = color(fx.end);
            fx.colorInit = true;
          }
          jQuery.cssHooks[hook].set(fx.elem, fx.start.transition(fx.end, fx.pos));
        };
      });
    };
    color.hook(stepHooks);
    jQuery.cssHooks.borderColor = {
      expand: function (value) {
        var expanded = {};
        each([
          'Top',
          'Right',
          'Bottom',
          'Left'
        ], function (i, part) {
          expanded['border' + part + 'Color'] = value;
        });
        return expanded;
      }
    };
    colors = jQuery.Color.names = {
      aqua: '#00ffff',
      black: '#000000',
      blue: '#0000ff',
      fuchsia: '#ff00ff',
      gray: '#808080',
      green: '#008000',
      lime: '#00ff00',
      maroon: '#800000',
      navy: '#000080',
      olive: '#808000',
      purple: '#800080',
      red: '#ff0000',
      silver: '#c0c0c0',
      teal: '#008080',
      white: '#ffffff',
      yellow: '#ffff00',
      transparent: [
        null,
        null,
        null,
        0
      ],
      _default: '#ffffff'
    };
  }(jQuery));
  (function () {
    var classAnimationActions = [
        'add',
        'remove',
        'toggle'
      ], shorthandStyles = {
        border: 1,
        borderBottom: 1,
        borderColor: 1,
        borderLeft: 1,
        borderRight: 1,
        borderTop: 1,
        borderWidth: 1,
        margin: 1,
        padding: 1
      };
    $.each([
      'borderLeftStyle',
      'borderRightStyle',
      'borderBottomStyle',
      'borderTopStyle'
    ], function (_, prop) {
      $.fx.step[prop] = function (fx) {
        if (fx.end !== 'none' && !fx.setAttr || fx.pos === 1 && !fx.setAttr) {
          jQuery.style(fx.elem, prop, fx.end);
          fx.setAttr = true;
        }
      };
    });
    function getElementStyles(elem) {
      var key, len, style = elem.ownerDocument.defaultView ? elem.ownerDocument.defaultView.getComputedStyle(elem, null) : elem.currentStyle, styles = {};
      if (style && style.length && style[0] && style[style[0]]) {
        len = style.length;
        while (len--) {
          key = style[len];
          if (typeof style[key] === 'string') {
            styles[$.camelCase(key)] = style[key];
          }
        }
      } else {
        for (key in style) {
          if (typeof style[key] === 'string') {
            styles[key] = style[key];
          }
        }
      }
      return styles;
    }
    function styleDifference(oldStyle, newStyle) {
      var diff = {}, name, value;
      for (name in newStyle) {
        value = newStyle[name];
        if (oldStyle[name] !== value) {
          if (!shorthandStyles[name]) {
            if ($.fx.step[name] || !isNaN(parseFloat(value))) {
              diff[name] = value;
            }
          }
        }
      }
      return diff;
    }
    if (!$.fn.addBack) {
      $.fn.addBack = function (selector) {
        return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
      };
    }
    $.effects.animateClass = function (value, duration, easing, callback) {
      var o = $.speed(duration, easing, callback);
      return this.queue(function () {
        var animated = $(this), baseClass = animated.attr('class') || '', applyClassChange, allAnimations = o.children ? animated.find('*').addBack() : animated;
        allAnimations = allAnimations.map(function () {
          var el = $(this);
          return {
            el: el,
            start: getElementStyles(this)
          };
        });
        applyClassChange = function () {
          $.each(classAnimationActions, function (i, action) {
            if (value[action]) {
              animated[action + 'Class'](value[action]);
            }
          });
        };
        applyClassChange();
        allAnimations = allAnimations.map(function () {
          this.end = getElementStyles(this.el[0]);
          this.diff = styleDifference(this.start, this.end);
          return this;
        });
        animated.attr('class', baseClass);
        allAnimations = allAnimations.map(function () {
          var styleInfo = this, dfd = $.Deferred(), opts = $.extend({}, o, {
              queue: false,
              complete: function () {
                dfd.resolve(styleInfo);
              }
            });
          this.el.animate(this.diff, opts);
          return dfd.promise();
        });
        $.when.apply($, allAnimations.get()).done(function () {
          applyClassChange();
          $.each(arguments, function () {
            var el = this.el;
            $.each(this.diff, function (key) {
              el.css(key, '');
            });
          });
          o.complete.call(animated[0]);
        });
      });
    };
    $.fn.extend({
      addClass: function (orig) {
        return function (classNames, speed, easing, callback) {
          return speed ? $.effects.animateClass.call(this, { add: classNames }, speed, easing, callback) : orig.apply(this, arguments);
        };
      }($.fn.addClass),
      removeClass: function (orig) {
        return function (classNames, speed, easing, callback) {
          return arguments.length > 1 ? $.effects.animateClass.call(this, { remove: classNames }, speed, easing, callback) : orig.apply(this, arguments);
        };
      }($.fn.removeClass),
      toggleClass: function (orig) {
        return function (classNames, force, speed, easing, callback) {
          if (typeof force === 'boolean' || force === undefined) {
            if (!speed) {
              return orig.apply(this, arguments);
            } else {
              return $.effects.animateClass.call(this, force ? { add: classNames } : { remove: classNames }, speed, easing, callback);
            }
          } else {
            return $.effects.animateClass.call(this, { toggle: classNames }, force, speed, easing);
          }
        };
      }($.fn.toggleClass),
      switchClass: function (remove, add, speed, easing, callback) {
        return $.effects.animateClass.call(this, {
          add: add,
          remove: remove
        }, speed, easing, callback);
      }
    });
  }());
  (function () {
    $.extend($.effects, {
      version: '1.10.4',
      save: function (element, set) {
        for (var i = 0; i < set.length; i++) {
          if (set[i] !== null) {
            element.data(dataSpace + set[i], element[0].style[set[i]]);
          }
        }
      },
      restore: function (element, set) {
        var val, i;
        for (i = 0; i < set.length; i++) {
          if (set[i] !== null) {
            val = element.data(dataSpace + set[i]);
            if (val === undefined) {
              val = '';
            }
            element.css(set[i], val);
          }
        }
      },
      setMode: function (el, mode) {
        if (mode === 'toggle') {
          mode = el.is(':hidden') ? 'show' : 'hide';
        }
        return mode;
      },
      getBaseline: function (origin, original) {
        var y, x;
        switch (origin[0]) {
        case 'top':
          y = 0;
          break;
        case 'middle':
          y = 0.5;
          break;
        case 'bottom':
          y = 1;
          break;
        default:
          y = origin[0] / original.height;
        }
        switch (origin[1]) {
        case 'left':
          x = 0;
          break;
        case 'center':
          x = 0.5;
          break;
        case 'right':
          x = 1;
          break;
        default:
          x = origin[1] / original.width;
        }
        return {
          x: x,
          y: y
        };
      },
      createWrapper: function (element) {
        if (element.parent().is('.ui-effects-wrapper')) {
          return element.parent();
        }
        var props = {
            width: element.outerWidth(true),
            height: element.outerHeight(true),
            'float': element.css('float')
          }, wrapper = $('<div></div>').addClass('ui-effects-wrapper').css({
            fontSize: '100%',
            background: 'transparent',
            border: 'none',
            margin: 0,
            padding: 0
          }), size = {
            width: element.width(),
            height: element.height()
          }, active = document.activeElement;
        try {
          active.id;
        } catch (e) {
          active = document.body;
        }
        element.wrap(wrapper);
        if (element[0] === active || $.contains(element[0], active)) {
          $(active).focus();
        }
        wrapper = element.parent();
        if (element.css('position') === 'static') {
          wrapper.css({ position: 'relative' });
          element.css({ position: 'relative' });
        } else {
          $.extend(props, {
            position: element.css('position'),
            zIndex: element.css('z-index')
          });
          $.each([
            'top',
            'left',
            'bottom',
            'right'
          ], function (i, pos) {
            props[pos] = element.css(pos);
            if (isNaN(parseInt(props[pos], 10))) {
              props[pos] = 'auto';
            }
          });
          element.css({
            position: 'relative',
            top: 0,
            left: 0,
            right: 'auto',
            bottom: 'auto'
          });
        }
        element.css(size);
        return wrapper.css(props).show();
      },
      removeWrapper: function (element) {
        var active = document.activeElement;
        if (element.parent().is('.ui-effects-wrapper')) {
          element.parent().replaceWith(element);
          if (element[0] === active || $.contains(element[0], active)) {
            $(active).focus();
          }
        }
        return element;
      },
      setTransition: function (element, list, factor, value) {
        value = value || {};
        $.each(list, function (i, x) {
          var unit = element.cssUnit(x);
          if (unit[0] > 0) {
            value[x] = unit[0] * factor + unit[1];
          }
        });
        return value;
      }
    });
    function _normalizeArguments(effect, options, speed, callback) {
      if ($.isPlainObject(effect)) {
        options = effect;
        effect = effect.effect;
      }
      effect = { effect: effect };
      if (options == null) {
        options = {};
      }
      if ($.isFunction(options)) {
        callback = options;
        speed = null;
        options = {};
      }
      if (typeof options === 'number' || $.fx.speeds[options]) {
        callback = speed;
        speed = options;
        options = {};
      }
      if ($.isFunction(speed)) {
        callback = speed;
        speed = null;
      }
      if (options) {
        $.extend(effect, options);
      }
      speed = speed || options.duration;
      effect.duration = $.fx.off ? 0 : typeof speed === 'number' ? speed : speed in $.fx.speeds ? $.fx.speeds[speed] : $.fx.speeds._default;
      effect.complete = callback || options.complete;
      return effect;
    }
    function standardAnimationOption(option) {
      if (!option || typeof option === 'number' || $.fx.speeds[option]) {
        return true;
      }
      if (typeof option === 'string' && !$.effects.effect[option]) {
        return true;
      }
      if ($.isFunction(option)) {
        return true;
      }
      if (typeof option === 'object' && !option.effect) {
        return true;
      }
      return false;
    }
    $.fn.extend({
      effect: function () {
        var args = _normalizeArguments.apply(this, arguments), mode = args.mode, queue = args.queue, effectMethod = $.effects.effect[args.effect];
        if ($.fx.off || !effectMethod) {
          if (mode) {
            return this[mode](args.duration, args.complete);
          } else {
            return this.each(function () {
              if (args.complete) {
                args.complete.call(this);
              }
            });
          }
        }
        function run(next) {
          var elem = $(this), complete = args.complete, mode = args.mode;
          function done() {
            if ($.isFunction(complete)) {
              complete.call(elem[0]);
            }
            if ($.isFunction(next)) {
              next();
            }
          }
          if (elem.is(':hidden') ? mode === 'hide' : mode === 'show') {
            elem[mode]();
            done();
          } else {
            effectMethod.call(elem[0], args, done);
          }
        }
        return queue === false ? this.each(run) : this.queue(queue || 'fx', run);
      },
      show: function (orig) {
        return function (option) {
          if (standardAnimationOption(option)) {
            return orig.apply(this, arguments);
          } else {
            var args = _normalizeArguments.apply(this, arguments);
            args.mode = 'show';
            return this.effect.call(this, args);
          }
        };
      }($.fn.show),
      hide: function (orig) {
        return function (option) {
          if (standardAnimationOption(option)) {
            return orig.apply(this, arguments);
          } else {
            var args = _normalizeArguments.apply(this, arguments);
            args.mode = 'hide';
            return this.effect.call(this, args);
          }
        };
      }($.fn.hide),
      toggle: function (orig) {
        return function (option) {
          if (standardAnimationOption(option) || typeof option === 'boolean') {
            return orig.apply(this, arguments);
          } else {
            var args = _normalizeArguments.apply(this, arguments);
            args.mode = 'toggle';
            return this.effect.call(this, args);
          }
        };
      }($.fn.toggle),
      cssUnit: function (key) {
        var style = this.css(key), val = [];
        $.each([
          'em',
          'px',
          '%',
          'pt'
        ], function (i, unit) {
          if (style.indexOf(unit) > 0) {
            val = [
              parseFloat(style),
              unit
            ];
          }
        });
        return val;
      }
    });
  }());
  (function () {
    var baseEasings = {};
    $.each([
      'Quad',
      'Cubic',
      'Quart',
      'Quint',
      'Expo'
    ], function (i, name) {
      baseEasings[name] = function (p) {
        return Math.pow(p, i + 2);
      };
    });
    $.extend(baseEasings, {
      Sine: function (p) {
        return 1 - Math.cos(p * Math.PI / 2);
      },
      Circ: function (p) {
        return 1 - Math.sqrt(1 - p * p);
      },
      Elastic: function (p) {
        return p === 0 || p === 1 ? p : -Math.pow(2, 8 * (p - 1)) * Math.sin(((p - 1) * 80 - 7.5) * Math.PI / 15);
      },
      Back: function (p) {
        return p * p * (3 * p - 2);
      },
      Bounce: function (p) {
        var pow2, bounce = 4;
        while (p < ((pow2 = Math.pow(2, --bounce)) - 1) / 11) {
        }
        return 1 / Math.pow(4, 3 - bounce) - 7.5625 * Math.pow((pow2 * 3 - 2) / 22 - p, 2);
      }
    });
    $.each(baseEasings, function (name, easeIn) {
      $.easing['easeIn' + name] = easeIn;
      $.easing['easeOut' + name] = function (p) {
        return 1 - easeIn(1 - p);
      };
      $.easing['easeInOut' + name] = function (p) {
        return p < 0.5 ? easeIn(p * 2) / 2 : 1 - easeIn(p * -2 + 2) / 2;
      };
    });
  }());
}(jQuery));
(function ($, undefined) {
  var rvertical = /up|down|vertical/, rpositivemotion = /up|left|vertical|horizontal/;
  $.effects.effect.blind = function (o, done) {
    var el = $(this), props = [
        'position',
        'top',
        'bottom',
        'left',
        'right',
        'height',
        'width'
      ], mode = $.effects.setMode(el, o.mode || 'hide'), direction = o.direction || 'up', vertical = rvertical.test(direction), ref = vertical ? 'height' : 'width', ref2 = vertical ? 'top' : 'left', motion = rpositivemotion.test(direction), animation = {}, show = mode === 'show', wrapper, distance, margin;
    if (el.parent().is('.ui-effects-wrapper')) {
      $.effects.save(el.parent(), props);
    } else {
      $.effects.save(el, props);
    }
    el.show();
    wrapper = $.effects.createWrapper(el).css({ overflow: 'hidden' });
    distance = wrapper[ref]();
    margin = parseFloat(wrapper.css(ref2)) || 0;
    animation[ref] = show ? distance : 0;
    if (!motion) {
      el.css(vertical ? 'bottom' : 'right', 0).css(vertical ? 'top' : 'left', 'auto').css({ position: 'absolute' });
      animation[ref2] = show ? margin : distance + margin;
    }
    if (show) {
      wrapper.css(ref, 0);
      if (!motion) {
        wrapper.css(ref2, margin + distance);
      }
    }
    wrapper.animate(animation, {
      duration: o.duration,
      easing: o.easing,
      queue: false,
      complete: function () {
        if (mode === 'hide') {
          el.hide();
        }
        $.effects.restore(el, props);
        $.effects.removeWrapper(el);
        done();
      }
    });
  };
}(jQuery));
(function ($, undefined) {
  $.effects.effect.bounce = function (o, done) {
    var el = $(this), props = [
        'position',
        'top',
        'bottom',
        'left',
        'right',
        'height',
        'width'
      ], mode = $.effects.setMode(el, o.mode || 'effect'), hide = mode === 'hide', show = mode === 'show', direction = o.direction || 'up', distance = o.distance, times = o.times || 5, anims = times * 2 + (show || hide ? 1 : 0), speed = o.duration / anims, easing = o.easing, ref = direction === 'up' || direction === 'down' ? 'top' : 'left', motion = direction === 'up' || direction === 'left', i, upAnim, downAnim, queue = el.queue(), queuelen = queue.length;
    if (show || hide) {
      props.push('opacity');
    }
    $.effects.save(el, props);
    el.show();
    $.effects.createWrapper(el);
    if (!distance) {
      distance = el[ref === 'top' ? 'outerHeight' : 'outerWidth']() / 3;
    }
    if (show) {
      downAnim = { opacity: 1 };
      downAnim[ref] = 0;
      el.css('opacity', 0).css(ref, motion ? -distance * 2 : distance * 2).animate(downAnim, speed, easing);
    }
    if (hide) {
      distance = distance / Math.pow(2, times - 1);
    }
    downAnim = {};
    downAnim[ref] = 0;
    for (i = 0; i < times; i++) {
      upAnim = {};
      upAnim[ref] = (motion ? '-=' : '+=') + distance;
      el.animate(upAnim, speed, easing).animate(downAnim, speed, easing);
      distance = hide ? distance * 2 : distance / 2;
    }
    if (hide) {
      upAnim = { opacity: 0 };
      upAnim[ref] = (motion ? '-=' : '+=') + distance;
      el.animate(upAnim, speed, easing);
    }
    el.queue(function () {
      if (hide) {
        el.hide();
      }
      $.effects.restore(el, props);
      $.effects.removeWrapper(el);
      done();
    });
    if (queuelen > 1) {
      queue.splice.apply(queue, [
        1,
        0
      ].concat(queue.splice(queuelen, anims + 1)));
    }
    el.dequeue();
  };
}(jQuery));
(function ($, undefined) {
  $.effects.effect.clip = function (o, done) {
    var el = $(this), props = [
        'position',
        'top',
        'bottom',
        'left',
        'right',
        'height',
        'width'
      ], mode = $.effects.setMode(el, o.mode || 'hide'), show = mode === 'show', direction = o.direction || 'vertical', vert = direction === 'vertical', size = vert ? 'height' : 'width', position = vert ? 'top' : 'left', animation = {}, wrapper, animate, distance;
    $.effects.save(el, props);
    el.show();
    wrapper = $.effects.createWrapper(el).css({ overflow: 'hidden' });
    animate = el[0].tagName === 'IMG' ? wrapper : el;
    distance = animate[size]();
    if (show) {
      animate.css(size, 0);
      animate.css(position, distance / 2);
    }
    animation[size] = show ? distance : 0;
    animation[position] = show ? 0 : distance / 2;
    animate.animate(animation, {
      queue: false,
      duration: o.duration,
      easing: o.easing,
      complete: function () {
        if (!show) {
          el.hide();
        }
        $.effects.restore(el, props);
        $.effects.removeWrapper(el);
        done();
      }
    });
  };
}(jQuery));
(function ($, undefined) {
  $.effects.effect.drop = function (o, done) {
    var el = $(this), props = [
        'position',
        'top',
        'bottom',
        'left',
        'right',
        'opacity',
        'height',
        'width'
      ], mode = $.effects.setMode(el, o.mode || 'hide'), show = mode === 'show', direction = o.direction || 'left', ref = direction === 'up' || direction === 'down' ? 'top' : 'left', motion = direction === 'up' || direction === 'left' ? 'pos' : 'neg', animation = { opacity: show ? 1 : 0 }, distance;
    $.effects.save(el, props);
    el.show();
    $.effects.createWrapper(el);
    distance = o.distance || el[ref === 'top' ? 'outerHeight' : 'outerWidth'](true) / 2;
    if (show) {
      el.css('opacity', 0).css(ref, motion === 'pos' ? -distance : distance);
    }
    animation[ref] = (show ? motion === 'pos' ? '+=' : '-=' : motion === 'pos' ? '-=' : '+=') + distance;
    el.animate(animation, {
      queue: false,
      duration: o.duration,
      easing: o.easing,
      complete: function () {
        if (mode === 'hide') {
          el.hide();
        }
        $.effects.restore(el, props);
        $.effects.removeWrapper(el);
        done();
      }
    });
  };
}(jQuery));
(function ($, undefined) {
  $.effects.effect.explode = function (o, done) {
    var rows = o.pieces ? Math.round(Math.sqrt(o.pieces)) : 3, cells = rows, el = $(this), mode = $.effects.setMode(el, o.mode || 'hide'), show = mode === 'show', offset = el.show().css('visibility', 'hidden').offset(), width = Math.ceil(el.outerWidth() / cells), height = Math.ceil(el.outerHeight() / rows), pieces = [], i, j, left, top, mx, my;
    function childComplete() {
      pieces.push(this);
      if (pieces.length === rows * cells) {
        animComplete();
      }
    }
    for (i = 0; i < rows; i++) {
      top = offset.top + i * height;
      my = i - (rows - 1) / 2;
      for (j = 0; j < cells; j++) {
        left = offset.left + j * width;
        mx = j - (cells - 1) / 2;
        el.clone().appendTo('body').wrap('<div></div>').css({
          position: 'absolute',
          visibility: 'visible',
          left: -j * width,
          top: -i * height
        }).parent().addClass('ui-effects-explode').css({
          position: 'absolute',
          overflow: 'hidden',
          width: width,
          height: height,
          left: left + (show ? mx * width : 0),
          top: top + (show ? my * height : 0),
          opacity: show ? 0 : 1
        }).animate({
          left: left + (show ? 0 : mx * width),
          top: top + (show ? 0 : my * height),
          opacity: show ? 1 : 0
        }, o.duration || 500, o.easing, childComplete);
      }
    }
    function animComplete() {
      el.css({ visibility: 'visible' });
      $(pieces).remove();
      if (!show) {
        el.hide();
      }
      done();
    }
  };
}(jQuery));
(function ($, undefined) {
  $.effects.effect.fade = function (o, done) {
    var el = $(this), mode = $.effects.setMode(el, o.mode || 'toggle');
    el.animate({ opacity: mode }, {
      queue: false,
      duration: o.duration,
      easing: o.easing,
      complete: done
    });
  };
}(jQuery));
(function ($, undefined) {
  $.effects.effect.fold = function (o, done) {
    var el = $(this), props = [
        'position',
        'top',
        'bottom',
        'left',
        'right',
        'height',
        'width'
      ], mode = $.effects.setMode(el, o.mode || 'hide'), show = mode === 'show', hide = mode === 'hide', size = o.size || 15, percent = /([0-9]+)%/.exec(size), horizFirst = !!o.horizFirst, widthFirst = show !== horizFirst, ref = widthFirst ? [
        'width',
        'height'
      ] : [
        'height',
        'width'
      ], duration = o.duration / 2, wrapper, distance, animation1 = {}, animation2 = {};
    $.effects.save(el, props);
    el.show();
    wrapper = $.effects.createWrapper(el).css({ overflow: 'hidden' });
    distance = widthFirst ? [
      wrapper.width(),
      wrapper.height()
    ] : [
      wrapper.height(),
      wrapper.width()
    ];
    if (percent) {
      size = parseInt(percent[1], 10) / 100 * distance[hide ? 0 : 1];
    }
    if (show) {
      wrapper.css(horizFirst ? {
        height: 0,
        width: size
      } : {
        height: size,
        width: 0
      });
    }
    animation1[ref[0]] = show ? distance[0] : size;
    animation2[ref[1]] = show ? distance[1] : 0;
    wrapper.animate(animation1, duration, o.easing).animate(animation2, duration, o.easing, function () {
      if (hide) {
        el.hide();
      }
      $.effects.restore(el, props);
      $.effects.removeWrapper(el);
      done();
    });
  };
}(jQuery));
(function ($, undefined) {
  $.effects.effect.highlight = function (o, done) {
    var elem = $(this), props = [
        'backgroundImage',
        'backgroundColor',
        'opacity'
      ], mode = $.effects.setMode(elem, o.mode || 'show'), animation = { backgroundColor: elem.css('backgroundColor') };
    if (mode === 'hide') {
      animation.opacity = 0;
    }
    $.effects.save(elem, props);
    elem.show().css({
      backgroundImage: 'none',
      backgroundColor: o.color || '#ffff99'
    }).animate(animation, {
      queue: false,
      duration: o.duration,
      easing: o.easing,
      complete: function () {
        if (mode === 'hide') {
          elem.hide();
        }
        $.effects.restore(elem, props);
        done();
      }
    });
  };
}(jQuery));
(function ($, undefined) {
  $.effects.effect.pulsate = function (o, done) {
    var elem = $(this), mode = $.effects.setMode(elem, o.mode || 'show'), show = mode === 'show', hide = mode === 'hide', showhide = show || mode === 'hide', anims = (o.times || 5) * 2 + (showhide ? 1 : 0), duration = o.duration / anims, animateTo = 0, queue = elem.queue(), queuelen = queue.length, i;
    if (show || !elem.is(':visible')) {
      elem.css('opacity', 0).show();
      animateTo = 1;
    }
    for (i = 1; i < anims; i++) {
      elem.animate({ opacity: animateTo }, duration, o.easing);
      animateTo = 1 - animateTo;
    }
    elem.animate({ opacity: animateTo }, duration, o.easing);
    elem.queue(function () {
      if (hide) {
        elem.hide();
      }
      done();
    });
    if (queuelen > 1) {
      queue.splice.apply(queue, [
        1,
        0
      ].concat(queue.splice(queuelen, anims + 1)));
    }
    elem.dequeue();
  };
}(jQuery));
(function ($, undefined) {
  $.effects.effect.puff = function (o, done) {
    var elem = $(this), mode = $.effects.setMode(elem, o.mode || 'hide'), hide = mode === 'hide', percent = parseInt(o.percent, 10) || 150, factor = percent / 100, original = {
        height: elem.height(),
        width: elem.width(),
        outerHeight: elem.outerHeight(),
        outerWidth: elem.outerWidth()
      };
    $.extend(o, {
      effect: 'scale',
      queue: false,
      fade: true,
      mode: mode,
      complete: done,
      percent: hide ? percent : 100,
      from: hide ? original : {
        height: original.height * factor,
        width: original.width * factor,
        outerHeight: original.outerHeight * factor,
        outerWidth: original.outerWidth * factor
      }
    });
    elem.effect(o);
  };
  $.effects.effect.scale = function (o, done) {
    var el = $(this), options = $.extend(true, {}, o), mode = $.effects.setMode(el, o.mode || 'effect'), percent = parseInt(o.percent, 10) || (parseInt(o.percent, 10) === 0 ? 0 : mode === 'hide' ? 0 : 100), direction = o.direction || 'both', origin = o.origin, original = {
        height: el.height(),
        width: el.width(),
        outerHeight: el.outerHeight(),
        outerWidth: el.outerWidth()
      }, factor = {
        y: direction !== 'horizontal' ? percent / 100 : 1,
        x: direction !== 'vertical' ? percent / 100 : 1
      };
    options.effect = 'size';
    options.queue = false;
    options.complete = done;
    if (mode !== 'effect') {
      options.origin = origin || [
        'middle',
        'center'
      ];
      options.restore = true;
    }
    options.from = o.from || (mode === 'show' ? {
      height: 0,
      width: 0,
      outerHeight: 0,
      outerWidth: 0
    } : original);
    options.to = {
      height: original.height * factor.y,
      width: original.width * factor.x,
      outerHeight: original.outerHeight * factor.y,
      outerWidth: original.outerWidth * factor.x
    };
    if (options.fade) {
      if (mode === 'show') {
        options.from.opacity = 0;
        options.to.opacity = 1;
      }
      if (mode === 'hide') {
        options.from.opacity = 1;
        options.to.opacity = 0;
      }
    }
    el.effect(options);
  };
  $.effects.effect.size = function (o, done) {
    var original, baseline, factor, el = $(this), props0 = [
        'position',
        'top',
        'bottom',
        'left',
        'right',
        'width',
        'height',
        'overflow',
        'opacity'
      ], props1 = [
        'position',
        'top',
        'bottom',
        'left',
        'right',
        'overflow',
        'opacity'
      ], props2 = [
        'width',
        'height',
        'overflow'
      ], cProps = ['fontSize'], vProps = [
        'borderTopWidth',
        'borderBottomWidth',
        'paddingTop',
        'paddingBottom'
      ], hProps = [
        'borderLeftWidth',
        'borderRightWidth',
        'paddingLeft',
        'paddingRight'
      ], mode = $.effects.setMode(el, o.mode || 'effect'), restore = o.restore || mode !== 'effect', scale = o.scale || 'both', origin = o.origin || [
        'middle',
        'center'
      ], position = el.css('position'), props = restore ? props0 : props1, zero = {
        height: 0,
        width: 0,
        outerHeight: 0,
        outerWidth: 0
      };
    if (mode === 'show') {
      el.show();
    }
    original = {
      height: el.height(),
      width: el.width(),
      outerHeight: el.outerHeight(),
      outerWidth: el.outerWidth()
    };
    if (o.mode === 'toggle' && mode === 'show') {
      el.from = o.to || zero;
      el.to = o.from || original;
    } else {
      el.from = o.from || (mode === 'show' ? zero : original);
      el.to = o.to || (mode === 'hide' ? zero : original);
    }
    factor = {
      from: {
        y: el.from.height / original.height,
        x: el.from.width / original.width
      },
      to: {
        y: el.to.height / original.height,
        x: el.to.width / original.width
      }
    };
    if (scale === 'box' || scale === 'both') {
      if (factor.from.y !== factor.to.y) {
        props = props.concat(vProps);
        el.from = $.effects.setTransition(el, vProps, factor.from.y, el.from);
        el.to = $.effects.setTransition(el, vProps, factor.to.y, el.to);
      }
      if (factor.from.x !== factor.to.x) {
        props = props.concat(hProps);
        el.from = $.effects.setTransition(el, hProps, factor.from.x, el.from);
        el.to = $.effects.setTransition(el, hProps, factor.to.x, el.to);
      }
    }
    if (scale === 'content' || scale === 'both') {
      if (factor.from.y !== factor.to.y) {
        props = props.concat(cProps).concat(props2);
        el.from = $.effects.setTransition(el, cProps, factor.from.y, el.from);
        el.to = $.effects.setTransition(el, cProps, factor.to.y, el.to);
      }
    }
    $.effects.save(el, props);
    el.show();
    $.effects.createWrapper(el);
    el.css('overflow', 'hidden').css(el.from);
    if (origin) {
      baseline = $.effects.getBaseline(origin, original);
      el.from.top = (original.outerHeight - el.outerHeight()) * baseline.y;
      el.from.left = (original.outerWidth - el.outerWidth()) * baseline.x;
      el.to.top = (original.outerHeight - el.to.outerHeight) * baseline.y;
      el.to.left = (original.outerWidth - el.to.outerWidth) * baseline.x;
    }
    el.css(el.from);
    if (scale === 'content' || scale === 'both') {
      vProps = vProps.concat([
        'marginTop',
        'marginBottom'
      ]).concat(cProps);
      hProps = hProps.concat([
        'marginLeft',
        'marginRight'
      ]);
      props2 = props0.concat(vProps).concat(hProps);
      el.find('*[width]').each(function () {
        var child = $(this), c_original = {
            height: child.height(),
            width: child.width(),
            outerHeight: child.outerHeight(),
            outerWidth: child.outerWidth()
          };
        if (restore) {
          $.effects.save(child, props2);
        }
        child.from = {
          height: c_original.height * factor.from.y,
          width: c_original.width * factor.from.x,
          outerHeight: c_original.outerHeight * factor.from.y,
          outerWidth: c_original.outerWidth * factor.from.x
        };
        child.to = {
          height: c_original.height * factor.to.y,
          width: c_original.width * factor.to.x,
          outerHeight: c_original.height * factor.to.y,
          outerWidth: c_original.width * factor.to.x
        };
        if (factor.from.y !== factor.to.y) {
          child.from = $.effects.setTransition(child, vProps, factor.from.y, child.from);
          child.to = $.effects.setTransition(child, vProps, factor.to.y, child.to);
        }
        if (factor.from.x !== factor.to.x) {
          child.from = $.effects.setTransition(child, hProps, factor.from.x, child.from);
          child.to = $.effects.setTransition(child, hProps, factor.to.x, child.to);
        }
        child.css(child.from);
        child.animate(child.to, o.duration, o.easing, function () {
          if (restore) {
            $.effects.restore(child, props2);
          }
        });
      });
    }
    el.animate(el.to, {
      queue: false,
      duration: o.duration,
      easing: o.easing,
      complete: function () {
        if (el.to.opacity === 0) {
          el.css('opacity', el.from.opacity);
        }
        if (mode === 'hide') {
          el.hide();
        }
        $.effects.restore(el, props);
        if (!restore) {
          if (position === 'static') {
            el.css({
              position: 'relative',
              top: el.to.top,
              left: el.to.left
            });
          } else {
            $.each([
              'top',
              'left'
            ], function (idx, pos) {
              el.css(pos, function (_, str) {
                var val = parseInt(str, 10), toRef = idx ? el.to.left : el.to.top;
                if (str === 'auto') {
                  return toRef + 'px';
                }
                return val + toRef + 'px';
              });
            });
          }
        }
        $.effects.removeWrapper(el);
        done();
      }
    });
  };
}(jQuery));
(function ($, undefined) {
  $.effects.effect.shake = function (o, done) {
    var el = $(this), props = [
        'position',
        'top',
        'bottom',
        'left',
        'right',
        'height',
        'width'
      ], mode = $.effects.setMode(el, o.mode || 'effect'), direction = o.direction || 'left', distance = o.distance || 20, times = o.times || 3, anims = times * 2 + 1, speed = Math.round(o.duration / anims), ref = direction === 'up' || direction === 'down' ? 'top' : 'left', positiveMotion = direction === 'up' || direction === 'left', animation = {}, animation1 = {}, animation2 = {}, i, queue = el.queue(), queuelen = queue.length;
    $.effects.save(el, props);
    el.show();
    $.effects.createWrapper(el);
    animation[ref] = (positiveMotion ? '-=' : '+=') + distance;
    animation1[ref] = (positiveMotion ? '+=' : '-=') + distance * 2;
    animation2[ref] = (positiveMotion ? '-=' : '+=') + distance * 2;
    el.animate(animation, speed, o.easing);
    for (i = 1; i < times; i++) {
      el.animate(animation1, speed, o.easing).animate(animation2, speed, o.easing);
    }
    el.animate(animation1, speed, o.easing).animate(animation, speed / 2, o.easing).queue(function () {
      if (mode === 'hide') {
        el.hide();
      }
      $.effects.restore(el, props);
      $.effects.removeWrapper(el);
      done();
    });
    if (queuelen > 1) {
      queue.splice.apply(queue, [
        1,
        0
      ].concat(queue.splice(queuelen, anims + 1)));
    }
    el.dequeue();
  };
}(jQuery));
(function ($, undefined) {
  $.effects.effect.slide = function (o, done) {
    var el = $(this), props = [
        'position',
        'top',
        'bottom',
        'left',
        'right',
        'width',
        'height'
      ], mode = $.effects.setMode(el, o.mode || 'show'), show = mode === 'show', direction = o.direction || 'left', ref = direction === 'up' || direction === 'down' ? 'top' : 'left', positiveMotion = direction === 'up' || direction === 'left', distance, animation = {};
    $.effects.save(el, props);
    el.show();
    distance = o.distance || el[ref === 'top' ? 'outerHeight' : 'outerWidth'](true);
    $.effects.createWrapper(el).css({ overflow: 'hidden' });
    if (show) {
      el.css(ref, positiveMotion ? isNaN(distance) ? '-' + distance : -distance : distance);
    }
    animation[ref] = (show ? positiveMotion ? '+=' : '-=' : positiveMotion ? '-=' : '+=') + distance;
    el.animate(animation, {
      queue: false,
      duration: o.duration,
      easing: o.easing,
      complete: function () {
        if (mode === 'hide') {
          el.hide();
        }
        $.effects.restore(el, props);
        $.effects.removeWrapper(el);
        done();
      }
    });
  };
}(jQuery));
(function ($, undefined) {
  $.effects.effect.transfer = function (o, done) {
    var elem = $(this), target = $(o.to), targetFixed = target.css('position') === 'fixed', body = $('body'), fixTop = targetFixed ? body.scrollTop() : 0, fixLeft = targetFixed ? body.scrollLeft() : 0, endPosition = target.offset(), animation = {
        top: endPosition.top - fixTop,
        left: endPosition.left - fixLeft,
        height: target.innerHeight(),
        width: target.innerWidth()
      }, startPosition = elem.offset(), transfer = $('<div class=\'ui-effects-transfer\'></div>').appendTo(document.body).addClass(o.className).css({
        top: startPosition.top - fixTop,
        left: startPosition.left - fixLeft,
        height: elem.innerHeight(),
        width: elem.innerWidth(),
        position: targetFixed ? 'fixed' : 'absolute'
      }).animate(animation, o.duration, o.easing, function () {
        transfer.remove();
        done();
      });
  };
}(jQuery));
(function ($, undefined) {
  $.widget('ui.menu', {
    version: '1.10.4',
    defaultElement: '<ul>',
    delay: 300,
    options: {
      icons: { submenu: 'ui-icon-carat-1-e' },
      menus: 'ul',
      position: {
        my: 'left top',
        at: 'right top'
      },
      role: 'menu',
      blur: null,
      focus: null,
      select: null
    },
    _create: function () {
      this.activeMenu = this.element;
      this.mouseHandled = false;
      this.element.uniqueId().addClass('ui-menu ui-widget ui-widget-content ui-corner-all').toggleClass('ui-menu-icons', !!this.element.find('.ui-icon').length).attr({
        role: this.options.role,
        tabIndex: 0
      }).bind('click' + this.eventNamespace, $.proxy(function (event) {
        if (this.options.disabled) {
          event.preventDefault();
        }
      }, this));
      if (this.options.disabled) {
        this.element.addClass('ui-state-disabled').attr('aria-disabled', 'true');
      }
      this._on({
        'mousedown .ui-menu-item > a': function (event) {
          event.preventDefault();
        },
        'click .ui-state-disabled > a': function (event) {
          event.preventDefault();
        },
        'click .ui-menu-item:has(a)': function (event) {
          var target = $(event.target).closest('.ui-menu-item');
          if (!this.mouseHandled && target.not('.ui-state-disabled').length) {
            this.select(event);
            if (!event.isPropagationStopped()) {
              this.mouseHandled = true;
            }
            if (target.has('.ui-menu').length) {
              this.expand(event);
            } else if (!this.element.is(':focus') && $(this.document[0].activeElement).closest('.ui-menu').length) {
              this.element.trigger('focus', [true]);
              if (this.active && this.active.parents('.ui-menu').length === 1) {
                clearTimeout(this.timer);
              }
            }
          }
        },
        'mouseenter .ui-menu-item': function (event) {
          var target = $(event.currentTarget);
          target.siblings().children('.ui-state-active').removeClass('ui-state-active');
          this.focus(event, target);
        },
        mouseleave: 'collapseAll',
        'mouseleave .ui-menu': 'collapseAll',
        focus: function (event, keepActiveItem) {
          var item = this.active || this.element.children('.ui-menu-item').eq(0);
          if (!keepActiveItem) {
            this.focus(event, item);
          }
        },
        blur: function (event) {
          this._delay(function () {
            if (!$.contains(this.element[0], this.document[0].activeElement)) {
              this.collapseAll(event);
            }
          });
        },
        keydown: '_keydown'
      });
      this.refresh();
      this._on(this.document, {
        click: function (event) {
          if (!$(event.target).closest('.ui-menu').length) {
            this.collapseAll(event);
          }
          this.mouseHandled = false;
        }
      });
    },
    _destroy: function () {
      this.element.removeAttr('aria-activedescendant').find('.ui-menu').addBack().removeClass('ui-menu ui-widget ui-widget-content ui-corner-all ui-menu-icons').removeAttr('role').removeAttr('tabIndex').removeAttr('aria-labelledby').removeAttr('aria-expanded').removeAttr('aria-hidden').removeAttr('aria-disabled').removeUniqueId().show();
      this.element.find('.ui-menu-item').removeClass('ui-menu-item').removeAttr('role').removeAttr('aria-disabled').children('a').removeUniqueId().removeClass('ui-corner-all ui-state-hover').removeAttr('tabIndex').removeAttr('role').removeAttr('aria-haspopup').children().each(function () {
        var elem = $(this);
        if (elem.data('ui-menu-submenu-carat')) {
          elem.remove();
        }
      });
      this.element.find('.ui-menu-divider').removeClass('ui-menu-divider ui-widget-content');
    },
    _keydown: function (event) {
      var match, prev, character, skip, regex, preventDefault = true;
      function escape(value) {
        return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, '\\$&');
      }
      switch (event.keyCode) {
      case $.ui.keyCode.PAGE_UP:
        this.previousPage(event);
        break;
      case $.ui.keyCode.PAGE_DOWN:
        this.nextPage(event);
        break;
      case $.ui.keyCode.HOME:
        this._move('first', 'first', event);
        break;
      case $.ui.keyCode.END:
        this._move('last', 'last', event);
        break;
      case $.ui.keyCode.UP:
        this.previous(event);
        break;
      case $.ui.keyCode.DOWN:
        this.next(event);
        break;
      case $.ui.keyCode.LEFT:
        this.collapse(event);
        break;
      case $.ui.keyCode.RIGHT:
        if (this.active && !this.active.is('.ui-state-disabled')) {
          this.expand(event);
        }
        break;
      case $.ui.keyCode.ENTER:
      case $.ui.keyCode.SPACE:
        this._activate(event);
        break;
      case $.ui.keyCode.ESCAPE:
        this.collapse(event);
        break;
      default:
        preventDefault = false;
        prev = this.previousFilter || '';
        character = String.fromCharCode(event.keyCode);
        skip = false;
        clearTimeout(this.filterTimer);
        if (character === prev) {
          skip = true;
        } else {
          character = prev + character;
        }
        regex = new RegExp('^' + escape(character), 'i');
        match = this.activeMenu.children('.ui-menu-item').filter(function () {
          return regex.test($(this).children('a').text());
        });
        match = skip && match.index(this.active.next()) !== -1 ? this.active.nextAll('.ui-menu-item') : match;
        if (!match.length) {
          character = String.fromCharCode(event.keyCode);
          regex = new RegExp('^' + escape(character), 'i');
          match = this.activeMenu.children('.ui-menu-item').filter(function () {
            return regex.test($(this).children('a').text());
          });
        }
        if (match.length) {
          this.focus(event, match);
          if (match.length > 1) {
            this.previousFilter = character;
            this.filterTimer = this._delay(function () {
              delete this.previousFilter;
            }, 1000);
          } else {
            delete this.previousFilter;
          }
        } else {
          delete this.previousFilter;
        }
      }
      if (preventDefault) {
        event.preventDefault();
      }
    },
    _activate: function (event) {
      if (!this.active.is('.ui-state-disabled')) {
        if (this.active.children('a[aria-haspopup=\'true\']').length) {
          this.expand(event);
        } else {
          this.select(event);
        }
      }
    },
    refresh: function () {
      var menus, icon = this.options.icons.submenu, submenus = this.element.find(this.options.menus);
      this.element.toggleClass('ui-menu-icons', !!this.element.find('.ui-icon').length);
      submenus.filter(':not(.ui-menu)').addClass('ui-menu ui-widget ui-widget-content ui-corner-all').hide().attr({
        role: this.options.role,
        'aria-hidden': 'true',
        'aria-expanded': 'false'
      }).each(function () {
        var menu = $(this), item = menu.prev('a'), submenuCarat = $('<span>').addClass('ui-menu-icon ui-icon ' + icon).data('ui-menu-submenu-carat', true);
        item.attr('aria-haspopup', 'true').prepend(submenuCarat);
        menu.attr('aria-labelledby', item.attr('id'));
      });
      menus = submenus.add(this.element);
      menus.children(':not(.ui-menu-item):has(a)').addClass('ui-menu-item').attr('role', 'presentation').children('a').uniqueId().addClass('ui-corner-all').attr({
        tabIndex: -1,
        role: this._itemRole()
      });
      menus.children(':not(.ui-menu-item)').each(function () {
        var item = $(this);
        if (!/[^\-\u2014\u2013\s]/.test(item.text())) {
          item.addClass('ui-widget-content ui-menu-divider');
        }
      });
      menus.children('.ui-state-disabled').attr('aria-disabled', 'true');
      if (this.active && !$.contains(this.element[0], this.active[0])) {
        this.blur();
      }
    },
    _itemRole: function () {
      return {
        menu: 'menuitem',
        listbox: 'option'
      }[this.options.role];
    },
    _setOption: function (key, value) {
      if (key === 'icons') {
        this.element.find('.ui-menu-icon').removeClass(this.options.icons.submenu).addClass(value.submenu);
      }
      this._super(key, value);
    },
    focus: function (event, item) {
      var nested, focused;
      this.blur(event, event && event.type === 'focus');
      this._scrollIntoView(item);
      this.active = item.first();
      focused = this.active.children('a').addClass('ui-state-focus');
      if (this.options.role) {
        this.element.attr('aria-activedescendant', focused.attr('id'));
      }
      this.active.parent().closest('.ui-menu-item').children('a:first').addClass('ui-state-active');
      if (event && event.type === 'keydown') {
        this._close();
      } else {
        this.timer = this._delay(function () {
          this._close();
        }, this.delay);
      }
      nested = item.children('.ui-menu');
      if (nested.length && event && /^mouse/.test(event.type)) {
        this._startOpening(nested);
      }
      this.activeMenu = item.parent();
      this._trigger('focus', event, { item: item });
    },
    _scrollIntoView: function (item) {
      var borderTop, paddingTop, offset, scroll, elementHeight, itemHeight;
      if (this._hasScroll()) {
        borderTop = parseFloat($.css(this.activeMenu[0], 'borderTopWidth')) || 0;
        paddingTop = parseFloat($.css(this.activeMenu[0], 'paddingTop')) || 0;
        offset = item.offset().top - this.activeMenu.offset().top - borderTop - paddingTop;
        scroll = this.activeMenu.scrollTop();
        elementHeight = this.activeMenu.height();
        itemHeight = item.height();
        if (offset < 0) {
          this.activeMenu.scrollTop(scroll + offset);
        } else if (offset + itemHeight > elementHeight) {
          this.activeMenu.scrollTop(scroll + offset - elementHeight + itemHeight);
        }
      }
    },
    blur: function (event, fromFocus) {
      if (!fromFocus) {
        clearTimeout(this.timer);
      }
      if (!this.active) {
        return;
      }
      this.active.children('a').removeClass('ui-state-focus');
      this.active = null;
      this._trigger('blur', event, { item: this.active });
    },
    _startOpening: function (submenu) {
      clearTimeout(this.timer);
      if (submenu.attr('aria-hidden') !== 'true') {
        return;
      }
      this.timer = this._delay(function () {
        this._close();
        this._open(submenu);
      }, this.delay);
    },
    _open: function (submenu) {
      var position = $.extend({ of: this.active }, this.options.position);
      clearTimeout(this.timer);
      this.element.find('.ui-menu').not(submenu.parents('.ui-menu')).hide().attr('aria-hidden', 'true');
      submenu.show().removeAttr('aria-hidden').attr('aria-expanded', 'true').position(position);
    },
    collapseAll: function (event, all) {
      clearTimeout(this.timer);
      this.timer = this._delay(function () {
        var currentMenu = all ? this.element : $(event && event.target).closest(this.element.find('.ui-menu'));
        if (!currentMenu.length) {
          currentMenu = this.element;
        }
        this._close(currentMenu);
        this.blur(event);
        this.activeMenu = currentMenu;
      }, this.delay);
    },
    _close: function (startMenu) {
      if (!startMenu) {
        startMenu = this.active ? this.active.parent() : this.element;
      }
      startMenu.find('.ui-menu').hide().attr('aria-hidden', 'true').attr('aria-expanded', 'false').end().find('a.ui-state-active').removeClass('ui-state-active');
    },
    collapse: function (event) {
      var newItem = this.active && this.active.parent().closest('.ui-menu-item', this.element);
      if (newItem && newItem.length) {
        this._close();
        this.focus(event, newItem);
      }
    },
    expand: function (event) {
      var newItem = this.active && this.active.children('.ui-menu ').children('.ui-menu-item').first();
      if (newItem && newItem.length) {
        this._open(newItem.parent());
        this._delay(function () {
          this.focus(event, newItem);
        });
      }
    },
    next: function (event) {
      this._move('next', 'first', event);
    },
    previous: function (event) {
      this._move('prev', 'last', event);
    },
    isFirstItem: function () {
      return this.active && !this.active.prevAll('.ui-menu-item').length;
    },
    isLastItem: function () {
      return this.active && !this.active.nextAll('.ui-menu-item').length;
    },
    _move: function (direction, filter, event) {
      var next;
      if (this.active) {
        if (direction === 'first' || direction === 'last') {
          next = this.active[direction === 'first' ? 'prevAll' : 'nextAll']('.ui-menu-item').eq(-1);
        } else {
          next = this.active[direction + 'All']('.ui-menu-item').eq(0);
        }
      }
      if (!next || !next.length || !this.active) {
        next = this.activeMenu.children('.ui-menu-item')[filter]();
      }
      this.focus(event, next);
    },
    nextPage: function (event) {
      var item, base, height;
      if (!this.active) {
        this.next(event);
        return;
      }
      if (this.isLastItem()) {
        return;
      }
      if (this._hasScroll()) {
        base = this.active.offset().top;
        height = this.element.height();
        this.active.nextAll('.ui-menu-item').each(function () {
          item = $(this);
          return item.offset().top - base - height < 0;
        });
        this.focus(event, item);
      } else {
        this.focus(event, this.activeMenu.children('.ui-menu-item')[!this.active ? 'first' : 'last']());
      }
    },
    previousPage: function (event) {
      var item, base, height;
      if (!this.active) {
        this.next(event);
        return;
      }
      if (this.isFirstItem()) {
        return;
      }
      if (this._hasScroll()) {
        base = this.active.offset().top;
        height = this.element.height();
        this.active.prevAll('.ui-menu-item').each(function () {
          item = $(this);
          return item.offset().top - base + height > 0;
        });
        this.focus(event, item);
      } else {
        this.focus(event, this.activeMenu.children('.ui-menu-item').first());
      }
    },
    _hasScroll: function () {
      return this.element.outerHeight() < this.element.prop('scrollHeight');
    },
    select: function (event) {
      this.active = this.active || $(event.target).closest('.ui-menu-item');
      var ui = { item: this.active };
      if (!this.active.has('.ui-menu').length) {
        this.collapseAll(event, true);
      }
      this._trigger('select', event, ui);
    }
  });
}(jQuery));
(function ($, undefined) {
  $.widget('ui.progressbar', {
    version: '1.10.4',
    options: {
      max: 100,
      value: 0,
      change: null,
      complete: null
    },
    min: 0,
    _create: function () {
      this.oldValue = this.options.value = this._constrainedValue();
      this.element.addClass('ui-progressbar ui-widget ui-widget-content ui-corner-all').attr({
        role: 'progressbar',
        'aria-valuemin': this.min
      });
      this.valueDiv = $('<div class=\'ui-progressbar-value ui-widget-header ui-corner-left\'></div>').appendTo(this.element);
      this._refreshValue();
    },
    _destroy: function () {
      this.element.removeClass('ui-progressbar ui-widget ui-widget-content ui-corner-all').removeAttr('role').removeAttr('aria-valuemin').removeAttr('aria-valuemax').removeAttr('aria-valuenow');
      this.valueDiv.remove();
    },
    value: function (newValue) {
      if (newValue === undefined) {
        return this.options.value;
      }
      this.options.value = this._constrainedValue(newValue);
      this._refreshValue();
    },
    _constrainedValue: function (newValue) {
      if (newValue === undefined) {
        newValue = this.options.value;
      }
      this.indeterminate = newValue === false;
      if (typeof newValue !== 'number') {
        newValue = 0;
      }
      return this.indeterminate ? false : Math.min(this.options.max, Math.max(this.min, newValue));
    },
    _setOptions: function (options) {
      var value = options.value;
      delete options.value;
      this._super(options);
      this.options.value = this._constrainedValue(value);
      this._refreshValue();
    },
    _setOption: function (key, value) {
      if (key === 'max') {
        value = Math.max(this.min, value);
      }
      this._super(key, value);
    },
    _percentage: function () {
      return this.indeterminate ? 100 : 100 * (this.options.value - this.min) / (this.options.max - this.min);
    },
    _refreshValue: function () {
      var value = this.options.value, percentage = this._percentage();
      this.valueDiv.toggle(this.indeterminate || value > this.min).toggleClass('ui-corner-right', value === this.options.max).width(percentage.toFixed(0) + '%');
      this.element.toggleClass('ui-progressbar-indeterminate', this.indeterminate);
      if (this.indeterminate) {
        this.element.removeAttr('aria-valuenow');
        if (!this.overlayDiv) {
          this.overlayDiv = $('<div class=\'ui-progressbar-overlay\'></div>').appendTo(this.valueDiv);
        }
      } else {
        this.element.attr({
          'aria-valuemax': this.options.max,
          'aria-valuenow': value
        });
        if (this.overlayDiv) {
          this.overlayDiv.remove();
          this.overlayDiv = null;
        }
      }
      if (this.oldValue !== value) {
        this.oldValue = value;
        this._trigger('change');
      }
      if (value === this.options.max) {
        this._trigger('complete');
      }
    }
  });
}(jQuery));
(function ($, undefined) {
  function num(v) {
    return parseInt(v, 10) || 0;
  }
  function isNumber(value) {
    return !isNaN(parseInt(value, 10));
  }
  $.widget('ui.resizable', $.ui.mouse, {
    version: '1.10.4',
    widgetEventPrefix: 'resize',
    options: {
      alsoResize: false,
      animate: false,
      animateDuration: 'slow',
      animateEasing: 'swing',
      aspectRatio: false,
      autoHide: false,
      containment: false,
      ghost: false,
      grid: false,
      handles: 'e,s,se',
      helper: false,
      maxHeight: null,
      maxWidth: null,
      minHeight: 10,
      minWidth: 10,
      zIndex: 90,
      resize: null,
      start: null,
      stop: null
    },
    _create: function () {
      var n, i, handle, axis, hname, that = this, o = this.options;
      this.element.addClass('ui-resizable');
      $.extend(this, {
        _aspectRatio: !!o.aspectRatio,
        aspectRatio: o.aspectRatio,
        originalElement: this.element,
        _proportionallyResizeElements: [],
        _helper: o.helper || o.ghost || o.animate ? o.helper || 'ui-resizable-helper' : null
      });
      if (this.element[0].nodeName.match(/canvas|textarea|input|select|button|img/i)) {
        this.element.wrap($('<div class=\'ui-wrapper\' style=\'overflow: hidden;\'></div>').css({
          position: this.element.css('position'),
          width: this.element.outerWidth(),
          height: this.element.outerHeight(),
          top: this.element.css('top'),
          left: this.element.css('left')
        }));
        this.element = this.element.parent().data('ui-resizable', this.element.data('ui-resizable'));
        this.elementIsWrapper = true;
        this.element.css({
          marginLeft: this.originalElement.css('marginLeft'),
          marginTop: this.originalElement.css('marginTop'),
          marginRight: this.originalElement.css('marginRight'),
          marginBottom: this.originalElement.css('marginBottom')
        });
        this.originalElement.css({
          marginLeft: 0,
          marginTop: 0,
          marginRight: 0,
          marginBottom: 0
        });
        this.originalResizeStyle = this.originalElement.css('resize');
        this.originalElement.css('resize', 'none');
        this._proportionallyResizeElements.push(this.originalElement.css({
          position: 'static',
          zoom: 1,
          display: 'block'
        }));
        this.originalElement.css({ margin: this.originalElement.css('margin') });
        this._proportionallyResize();
      }
      this.handles = o.handles || (!$('.ui-resizable-handle', this.element).length ? 'e,s,se' : {
        n: '.ui-resizable-n',
        e: '.ui-resizable-e',
        s: '.ui-resizable-s',
        w: '.ui-resizable-w',
        se: '.ui-resizable-se',
        sw: '.ui-resizable-sw',
        ne: '.ui-resizable-ne',
        nw: '.ui-resizable-nw'
      });
      if (this.handles.constructor === String) {
        if (this.handles === 'all') {
          this.handles = 'n,e,s,w,se,sw,ne,nw';
        }
        n = this.handles.split(',');
        this.handles = {};
        for (i = 0; i < n.length; i++) {
          handle = $.trim(n[i]);
          hname = 'ui-resizable-' + handle;
          axis = $('<div class=\'ui-resizable-handle ' + hname + '\'></div>');
          axis.css({ zIndex: o.zIndex });
          if ('se' === handle) {
            axis.addClass('ui-icon ui-icon-gripsmall-diagonal-se');
          }
          this.handles[handle] = '.ui-resizable-' + handle;
          this.element.append(axis);
        }
      }
      this._renderAxis = function (target) {
        var i, axis, padPos, padWrapper;
        target = target || this.element;
        for (i in this.handles) {
          if (this.handles[i].constructor === String) {
            this.handles[i] = $(this.handles[i], this.element).show();
          }
          if (this.elementIsWrapper && this.originalElement[0].nodeName.match(/textarea|input|select|button/i)) {
            axis = $(this.handles[i], this.element);
            padWrapper = /sw|ne|nw|se|n|s/.test(i) ? axis.outerHeight() : axis.outerWidth();
            padPos = [
              'padding',
              /ne|nw|n/.test(i) ? 'Top' : /se|sw|s/.test(i) ? 'Bottom' : /^e$/.test(i) ? 'Right' : 'Left'
            ].join('');
            target.css(padPos, padWrapper);
            this._proportionallyResize();
          }
          if (!$(this.handles[i]).length) {
            continue;
          }
        }
      };
      this._renderAxis(this.element);
      this._handles = $('.ui-resizable-handle', this.element).disableSelection();
      this._handles.mouseover(function () {
        if (!that.resizing) {
          if (this.className) {
            axis = this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i);
          }
          that.axis = axis && axis[1] ? axis[1] : 'se';
        }
      });
      if (o.autoHide) {
        this._handles.hide();
        $(this.element).addClass('ui-resizable-autohide').mouseenter(function () {
          if (o.disabled) {
            return;
          }
          $(this).removeClass('ui-resizable-autohide');
          that._handles.show();
        }).mouseleave(function () {
          if (o.disabled) {
            return;
          }
          if (!that.resizing) {
            $(this).addClass('ui-resizable-autohide');
            that._handles.hide();
          }
        });
      }
      this._mouseInit();
    },
    _destroy: function () {
      this._mouseDestroy();
      var wrapper, _destroy = function (exp) {
          $(exp).removeClass('ui-resizable ui-resizable-disabled ui-resizable-resizing').removeData('resizable').removeData('ui-resizable').unbind('.resizable').find('.ui-resizable-handle').remove();
        };
      if (this.elementIsWrapper) {
        _destroy(this.element);
        wrapper = this.element;
        this.originalElement.css({
          position: wrapper.css('position'),
          width: wrapper.outerWidth(),
          height: wrapper.outerHeight(),
          top: wrapper.css('top'),
          left: wrapper.css('left')
        }).insertAfter(wrapper);
        wrapper.remove();
      }
      this.originalElement.css('resize', this.originalResizeStyle);
      _destroy(this.originalElement);
      return this;
    },
    _mouseCapture: function (event) {
      var i, handle, capture = false;
      for (i in this.handles) {
        handle = $(this.handles[i])[0];
        if (handle === event.target || $.contains(handle, event.target)) {
          capture = true;
        }
      }
      return !this.options.disabled && capture;
    },
    _mouseStart: function (event) {
      var curleft, curtop, cursor, o = this.options, iniPos = this.element.position(), el = this.element;
      this.resizing = true;
      if (/absolute/.test(el.css('position'))) {
        el.css({
          position: 'absolute',
          top: el.css('top'),
          left: el.css('left')
        });
      } else if (el.is('.ui-draggable')) {
        el.css({
          position: 'absolute',
          top: iniPos.top,
          left: iniPos.left
        });
      }
      this._renderProxy();
      curleft = num(this.helper.css('left'));
      curtop = num(this.helper.css('top'));
      if (o.containment) {
        curleft += $(o.containment).scrollLeft() || 0;
        curtop += $(o.containment).scrollTop() || 0;
      }
      this.offset = this.helper.offset();
      this.position = {
        left: curleft,
        top: curtop
      };
      this.size = this._helper ? {
        width: this.helper.width(),
        height: this.helper.height()
      } : {
        width: el.width(),
        height: el.height()
      };
      this.originalSize = this._helper ? {
        width: el.outerWidth(),
        height: el.outerHeight()
      } : {
        width: el.width(),
        height: el.height()
      };
      this.originalPosition = {
        left: curleft,
        top: curtop
      };
      this.sizeDiff = {
        width: el.outerWidth() - el.width(),
        height: el.outerHeight() - el.height()
      };
      this.originalMousePosition = {
        left: event.pageX,
        top: event.pageY
      };
      this.aspectRatio = typeof o.aspectRatio === 'number' ? o.aspectRatio : this.originalSize.width / this.originalSize.height || 1;
      cursor = $('.ui-resizable-' + this.axis).css('cursor');
      $('body').css('cursor', cursor === 'auto' ? this.axis + '-resize' : cursor);
      el.addClass('ui-resizable-resizing');
      this._propagate('start', event);
      return true;
    },
    _mouseDrag: function (event) {
      var data, el = this.helper, props = {}, smp = this.originalMousePosition, a = this.axis, prevTop = this.position.top, prevLeft = this.position.left, prevWidth = this.size.width, prevHeight = this.size.height, dx = event.pageX - smp.left || 0, dy = event.pageY - smp.top || 0, trigger = this._change[a];
      if (!trigger) {
        return false;
      }
      data = trigger.apply(this, [
        event,
        dx,
        dy
      ]);
      this._updateVirtualBoundaries(event.shiftKey);
      if (this._aspectRatio || event.shiftKey) {
        data = this._updateRatio(data, event);
      }
      data = this._respectSize(data, event);
      this._updateCache(data);
      this._propagate('resize', event);
      if (this.position.top !== prevTop) {
        props.top = this.position.top + 'px';
      }
      if (this.position.left !== prevLeft) {
        props.left = this.position.left + 'px';
      }
      if (this.size.width !== prevWidth) {
        props.width = this.size.width + 'px';
      }
      if (this.size.height !== prevHeight) {
        props.height = this.size.height + 'px';
      }
      el.css(props);
      if (!this._helper && this._proportionallyResizeElements.length) {
        this._proportionallyResize();
      }
      if (!$.isEmptyObject(props)) {
        this._trigger('resize', event, this.ui());
      }
      return false;
    },
    _mouseStop: function (event) {
      this.resizing = false;
      var pr, ista, soffseth, soffsetw, s, left, top, o = this.options, that = this;
      if (this._helper) {
        pr = this._proportionallyResizeElements;
        ista = pr.length && /textarea/i.test(pr[0].nodeName);
        soffseth = ista && $.ui.hasScroll(pr[0], 'left') ? 0 : that.sizeDiff.height;
        soffsetw = ista ? 0 : that.sizeDiff.width;
        s = {
          width: that.helper.width() - soffsetw,
          height: that.helper.height() - soffseth
        };
        left = parseInt(that.element.css('left'), 10) + (that.position.left - that.originalPosition.left) || null;
        top = parseInt(that.element.css('top'), 10) + (that.position.top - that.originalPosition.top) || null;
        if (!o.animate) {
          this.element.css($.extend(s, {
            top: top,
            left: left
          }));
        }
        that.helper.height(that.size.height);
        that.helper.width(that.size.width);
        if (this._helper && !o.animate) {
          this._proportionallyResize();
        }
      }
      $('body').css('cursor', 'auto');
      this.element.removeClass('ui-resizable-resizing');
      this._propagate('stop', event);
      if (this._helper) {
        this.helper.remove();
      }
      return false;
    },
    _updateVirtualBoundaries: function (forceAspectRatio) {
      var pMinWidth, pMaxWidth, pMinHeight, pMaxHeight, b, o = this.options;
      b = {
        minWidth: isNumber(o.minWidth) ? o.minWidth : 0,
        maxWidth: isNumber(o.maxWidth) ? o.maxWidth : Infinity,
        minHeight: isNumber(o.minHeight) ? o.minHeight : 0,
        maxHeight: isNumber(o.maxHeight) ? o.maxHeight : Infinity
      };
      if (this._aspectRatio || forceAspectRatio) {
        pMinWidth = b.minHeight * this.aspectRatio;
        pMinHeight = b.minWidth / this.aspectRatio;
        pMaxWidth = b.maxHeight * this.aspectRatio;
        pMaxHeight = b.maxWidth / this.aspectRatio;
        if (pMinWidth > b.minWidth) {
          b.minWidth = pMinWidth;
        }
        if (pMinHeight > b.minHeight) {
          b.minHeight = pMinHeight;
        }
        if (pMaxWidth < b.maxWidth) {
          b.maxWidth = pMaxWidth;
        }
        if (pMaxHeight < b.maxHeight) {
          b.maxHeight = pMaxHeight;
        }
      }
      this._vBoundaries = b;
    },
    _updateCache: function (data) {
      this.offset = this.helper.offset();
      if (isNumber(data.left)) {
        this.position.left = data.left;
      }
      if (isNumber(data.top)) {
        this.position.top = data.top;
      }
      if (isNumber(data.height)) {
        this.size.height = data.height;
      }
      if (isNumber(data.width)) {
        this.size.width = data.width;
      }
    },
    _updateRatio: function (data) {
      var cpos = this.position, csize = this.size, a = this.axis;
      if (isNumber(data.height)) {
        data.width = data.height * this.aspectRatio;
      } else if (isNumber(data.width)) {
        data.height = data.width / this.aspectRatio;
      }
      if (a === 'sw') {
        data.left = cpos.left + (csize.width - data.width);
        data.top = null;
      }
      if (a === 'nw') {
        data.top = cpos.top + (csize.height - data.height);
        data.left = cpos.left + (csize.width - data.width);
      }
      return data;
    },
    _respectSize: function (data) {
      var o = this._vBoundaries, a = this.axis, ismaxw = isNumber(data.width) && o.maxWidth && o.maxWidth < data.width, ismaxh = isNumber(data.height) && o.maxHeight && o.maxHeight < data.height, isminw = isNumber(data.width) && o.minWidth && o.minWidth > data.width, isminh = isNumber(data.height) && o.minHeight && o.minHeight > data.height, dw = this.originalPosition.left + this.originalSize.width, dh = this.position.top + this.size.height, cw = /sw|nw|w/.test(a), ch = /nw|ne|n/.test(a);
      if (isminw) {
        data.width = o.minWidth;
      }
      if (isminh) {
        data.height = o.minHeight;
      }
      if (ismaxw) {
        data.width = o.maxWidth;
      }
      if (ismaxh) {
        data.height = o.maxHeight;
      }
      if (isminw && cw) {
        data.left = dw - o.minWidth;
      }
      if (ismaxw && cw) {
        data.left = dw - o.maxWidth;
      }
      if (isminh && ch) {
        data.top = dh - o.minHeight;
      }
      if (ismaxh && ch) {
        data.top = dh - o.maxHeight;
      }
      if (!data.width && !data.height && !data.left && data.top) {
        data.top = null;
      } else if (!data.width && !data.height && !data.top && data.left) {
        data.left = null;
      }
      return data;
    },
    _proportionallyResize: function () {
      if (!this._proportionallyResizeElements.length) {
        return;
      }
      var i, j, borders, paddings, prel, element = this.helper || this.element;
      for (i = 0; i < this._proportionallyResizeElements.length; i++) {
        prel = this._proportionallyResizeElements[i];
        if (!this.borderDif) {
          this.borderDif = [];
          borders = [
            prel.css('borderTopWidth'),
            prel.css('borderRightWidth'),
            prel.css('borderBottomWidth'),
            prel.css('borderLeftWidth')
          ];
          paddings = [
            prel.css('paddingTop'),
            prel.css('paddingRight'),
            prel.css('paddingBottom'),
            prel.css('paddingLeft')
          ];
          for (j = 0; j < borders.length; j++) {
            this.borderDif[j] = (parseInt(borders[j], 10) || 0) + (parseInt(paddings[j], 10) || 0);
          }
        }
        prel.css({
          height: element.height() - this.borderDif[0] - this.borderDif[2] || 0,
          width: element.width() - this.borderDif[1] - this.borderDif[3] || 0
        });
      }
    },
    _renderProxy: function () {
      var el = this.element, o = this.options;
      this.elementOffset = el.offset();
      if (this._helper) {
        this.helper = this.helper || $('<div style=\'overflow:hidden;\'></div>');
        this.helper.addClass(this._helper).css({
          width: this.element.outerWidth() - 1,
          height: this.element.outerHeight() - 1,
          position: 'absolute',
          left: this.elementOffset.left + 'px',
          top: this.elementOffset.top + 'px',
          zIndex: ++o.zIndex
        });
        this.helper.appendTo('body').disableSelection();
      } else {
        this.helper = this.element;
      }
    },
    _change: {
      e: function (event, dx) {
        return { width: this.originalSize.width + dx };
      },
      w: function (event, dx) {
        var cs = this.originalSize, sp = this.originalPosition;
        return {
          left: sp.left + dx,
          width: cs.width - dx
        };
      },
      n: function (event, dx, dy) {
        var cs = this.originalSize, sp = this.originalPosition;
        return {
          top: sp.top + dy,
          height: cs.height - dy
        };
      },
      s: function (event, dx, dy) {
        return { height: this.originalSize.height + dy };
      },
      se: function (event, dx, dy) {
        return $.extend(this._change.s.apply(this, arguments), this._change.e.apply(this, [
          event,
          dx,
          dy
        ]));
      },
      sw: function (event, dx, dy) {
        return $.extend(this._change.s.apply(this, arguments), this._change.w.apply(this, [
          event,
          dx,
          dy
        ]));
      },
      ne: function (event, dx, dy) {
        return $.extend(this._change.n.apply(this, arguments), this._change.e.apply(this, [
          event,
          dx,
          dy
        ]));
      },
      nw: function (event, dx, dy) {
        return $.extend(this._change.n.apply(this, arguments), this._change.w.apply(this, [
          event,
          dx,
          dy
        ]));
      }
    },
    _propagate: function (n, event) {
      $.ui.plugin.call(this, n, [
        event,
        this.ui()
      ]);
      n !== 'resize' && this._trigger(n, event, this.ui());
    },
    plugins: {},
    ui: function () {
      return {
        originalElement: this.originalElement,
        element: this.element,
        helper: this.helper,
        position: this.position,
        size: this.size,
        originalSize: this.originalSize,
        originalPosition: this.originalPosition
      };
    }
  });
  $.ui.plugin.add('resizable', 'animate', {
    stop: function (event) {
      var that = $(this).data('ui-resizable'), o = that.options, pr = that._proportionallyResizeElements, ista = pr.length && /textarea/i.test(pr[0].nodeName), soffseth = ista && $.ui.hasScroll(pr[0], 'left') ? 0 : that.sizeDiff.height, soffsetw = ista ? 0 : that.sizeDiff.width, style = {
          width: that.size.width - soffsetw,
          height: that.size.height - soffseth
        }, left = parseInt(that.element.css('left'), 10) + (that.position.left - that.originalPosition.left) || null, top = parseInt(that.element.css('top'), 10) + (that.position.top - that.originalPosition.top) || null;
      that.element.animate($.extend(style, top && left ? {
        top: top,
        left: left
      } : {}), {
        duration: o.animateDuration,
        easing: o.animateEasing,
        step: function () {
          var data = {
              width: parseInt(that.element.css('width'), 10),
              height: parseInt(that.element.css('height'), 10),
              top: parseInt(that.element.css('top'), 10),
              left: parseInt(that.element.css('left'), 10)
            };
          if (pr && pr.length) {
            $(pr[0]).css({
              width: data.width,
              height: data.height
            });
          }
          that._updateCache(data);
          that._propagate('resize', event);
        }
      });
    }
  });
  $.ui.plugin.add('resizable', 'containment', {
    start: function () {
      var element, p, co, ch, cw, width, height, that = $(this).data('ui-resizable'), o = that.options, el = that.element, oc = o.containment, ce = oc instanceof $ ? oc.get(0) : /parent/.test(oc) ? el.parent().get(0) : oc;
      if (!ce) {
        return;
      }
      that.containerElement = $(ce);
      if (/document/.test(oc) || oc === document) {
        that.containerOffset = {
          left: 0,
          top: 0
        };
        that.containerPosition = {
          left: 0,
          top: 0
        };
        that.parentData = {
          element: $(document),
          left: 0,
          top: 0,
          width: $(document).width(),
          height: $(document).height() || document.body.parentNode.scrollHeight
        };
      } else {
        element = $(ce);
        p = [];
        $([
          'Top',
          'Right',
          'Left',
          'Bottom'
        ]).each(function (i, name) {
          p[i] = num(element.css('padding' + name));
        });
        that.containerOffset = element.offset();
        that.containerPosition = element.position();
        that.containerSize = {
          height: element.innerHeight() - p[3],
          width: element.innerWidth() - p[1]
        };
        co = that.containerOffset;
        ch = that.containerSize.height;
        cw = that.containerSize.width;
        width = $.ui.hasScroll(ce, 'left') ? ce.scrollWidth : cw;
        height = $.ui.hasScroll(ce) ? ce.scrollHeight : ch;
        that.parentData = {
          element: ce,
          left: co.left,
          top: co.top,
          width: width,
          height: height
        };
      }
    },
    resize: function (event) {
      var woset, hoset, isParent, isOffsetRelative, that = $(this).data('ui-resizable'), o = that.options, co = that.containerOffset, cp = that.position, pRatio = that._aspectRatio || event.shiftKey, cop = {
          top: 0,
          left: 0
        }, ce = that.containerElement;
      if (ce[0] !== document && /static/.test(ce.css('position'))) {
        cop = co;
      }
      if (cp.left < (that._helper ? co.left : 0)) {
        that.size.width = that.size.width + (that._helper ? that.position.left - co.left : that.position.left - cop.left);
        if (pRatio) {
          that.size.height = that.size.width / that.aspectRatio;
        }
        that.position.left = o.helper ? co.left : 0;
      }
      if (cp.top < (that._helper ? co.top : 0)) {
        that.size.height = that.size.height + (that._helper ? that.position.top - co.top : that.position.top);
        if (pRatio) {
          that.size.width = that.size.height * that.aspectRatio;
        }
        that.position.top = that._helper ? co.top : 0;
      }
      that.offset.left = that.parentData.left + that.position.left;
      that.offset.top = that.parentData.top + that.position.top;
      woset = Math.abs((that._helper ? that.offset.left - cop.left : that.offset.left - cop.left) + that.sizeDiff.width);
      hoset = Math.abs((that._helper ? that.offset.top - cop.top : that.offset.top - co.top) + that.sizeDiff.height);
      isParent = that.containerElement.get(0) === that.element.parent().get(0);
      isOffsetRelative = /relative|absolute/.test(that.containerElement.css('position'));
      if (isParent && isOffsetRelative) {
        woset -= Math.abs(that.parentData.left);
      }
      if (woset + that.size.width >= that.parentData.width) {
        that.size.width = that.parentData.width - woset;
        if (pRatio) {
          that.size.height = that.size.width / that.aspectRatio;
        }
      }
      if (hoset + that.size.height >= that.parentData.height) {
        that.size.height = that.parentData.height - hoset;
        if (pRatio) {
          that.size.width = that.size.height * that.aspectRatio;
        }
      }
    },
    stop: function () {
      var that = $(this).data('ui-resizable'), o = that.options, co = that.containerOffset, cop = that.containerPosition, ce = that.containerElement, helper = $(that.helper), ho = helper.offset(), w = helper.outerWidth() - that.sizeDiff.width, h = helper.outerHeight() - that.sizeDiff.height;
      if (that._helper && !o.animate && /relative/.test(ce.css('position'))) {
        $(this).css({
          left: ho.left - cop.left - co.left,
          width: w,
          height: h
        });
      }
      if (that._helper && !o.animate && /static/.test(ce.css('position'))) {
        $(this).css({
          left: ho.left - cop.left - co.left,
          width: w,
          height: h
        });
      }
    }
  });
  $.ui.plugin.add('resizable', 'alsoResize', {
    start: function () {
      var that = $(this).data('ui-resizable'), o = that.options, _store = function (exp) {
          $(exp).each(function () {
            var el = $(this);
            el.data('ui-resizable-alsoresize', {
              width: parseInt(el.width(), 10),
              height: parseInt(el.height(), 10),
              left: parseInt(el.css('left'), 10),
              top: parseInt(el.css('top'), 10)
            });
          });
        };
      if (typeof o.alsoResize === 'object' && !o.alsoResize.parentNode) {
        if (o.alsoResize.length) {
          o.alsoResize = o.alsoResize[0];
          _store(o.alsoResize);
        } else {
          $.each(o.alsoResize, function (exp) {
            _store(exp);
          });
        }
      } else {
        _store(o.alsoResize);
      }
    },
    resize: function (event, ui) {
      var that = $(this).data('ui-resizable'), o = that.options, os = that.originalSize, op = that.originalPosition, delta = {
          height: that.size.height - os.height || 0,
          width: that.size.width - os.width || 0,
          top: that.position.top - op.top || 0,
          left: that.position.left - op.left || 0
        }, _alsoResize = function (exp, c) {
          $(exp).each(function () {
            var el = $(this), start = $(this).data('ui-resizable-alsoresize'), style = {}, css = c && c.length ? c : el.parents(ui.originalElement[0]).length ? [
                'width',
                'height'
              ] : [
                'width',
                'height',
                'top',
                'left'
              ];
            $.each(css, function (i, prop) {
              var sum = (start[prop] || 0) + (delta[prop] || 0);
              if (sum && sum >= 0) {
                style[prop] = sum || null;
              }
            });
            el.css(style);
          });
        };
      if (typeof o.alsoResize === 'object' && !o.alsoResize.nodeType) {
        $.each(o.alsoResize, function (exp, c) {
          _alsoResize(exp, c);
        });
      } else {
        _alsoResize(o.alsoResize);
      }
    },
    stop: function () {
      $(this).removeData('resizable-alsoresize');
    }
  });
  $.ui.plugin.add('resizable', 'ghost', {
    start: function () {
      var that = $(this).data('ui-resizable'), o = that.options, cs = that.size;
      that.ghost = that.originalElement.clone();
      that.ghost.css({
        opacity: 0.25,
        display: 'block',
        position: 'relative',
        height: cs.height,
        width: cs.width,
        margin: 0,
        left: 0,
        top: 0
      }).addClass('ui-resizable-ghost').addClass(typeof o.ghost === 'string' ? o.ghost : '');
      that.ghost.appendTo(that.helper);
    },
    resize: function () {
      var that = $(this).data('ui-resizable');
      if (that.ghost) {
        that.ghost.css({
          position: 'relative',
          height: that.size.height,
          width: that.size.width
        });
      }
    },
    stop: function () {
      var that = $(this).data('ui-resizable');
      if (that.ghost && that.helper) {
        that.helper.get(0).removeChild(that.ghost.get(0));
      }
    }
  });
  $.ui.plugin.add('resizable', 'grid', {
    resize: function () {
      var that = $(this).data('ui-resizable'), o = that.options, cs = that.size, os = that.originalSize, op = that.originalPosition, a = that.axis, grid = typeof o.grid === 'number' ? [
          o.grid,
          o.grid
        ] : o.grid, gridX = grid[0] || 1, gridY = grid[1] || 1, ox = Math.round((cs.width - os.width) / gridX) * gridX, oy = Math.round((cs.height - os.height) / gridY) * gridY, newWidth = os.width + ox, newHeight = os.height + oy, isMaxWidth = o.maxWidth && o.maxWidth < newWidth, isMaxHeight = o.maxHeight && o.maxHeight < newHeight, isMinWidth = o.minWidth && o.minWidth > newWidth, isMinHeight = o.minHeight && o.minHeight > newHeight;
      o.grid = grid;
      if (isMinWidth) {
        newWidth = newWidth + gridX;
      }
      if (isMinHeight) {
        newHeight = newHeight + gridY;
      }
      if (isMaxWidth) {
        newWidth = newWidth - gridX;
      }
      if (isMaxHeight) {
        newHeight = newHeight - gridY;
      }
      if (/^(se|s|e)$/.test(a)) {
        that.size.width = newWidth;
        that.size.height = newHeight;
      } else if (/^(ne)$/.test(a)) {
        that.size.width = newWidth;
        that.size.height = newHeight;
        that.position.top = op.top - oy;
      } else if (/^(sw)$/.test(a)) {
        that.size.width = newWidth;
        that.size.height = newHeight;
        that.position.left = op.left - ox;
      } else {
        if (newHeight - gridY > 0) {
          that.size.height = newHeight;
          that.position.top = op.top - oy;
        } else {
          that.size.height = gridY;
          that.position.top = op.top + os.height - gridY;
        }
        if (newWidth - gridX > 0) {
          that.size.width = newWidth;
          that.position.left = op.left - ox;
        } else {
          that.size.width = gridX;
          that.position.left = op.left + os.width - gridX;
        }
      }
    }
  });
}(jQuery));
(function ($, undefined) {
  $.widget('ui.selectable', $.ui.mouse, {
    version: '1.10.4',
    options: {
      appendTo: 'body',
      autoRefresh: true,
      distance: 0,
      filter: '*',
      tolerance: 'touch',
      selected: null,
      selecting: null,
      start: null,
      stop: null,
      unselected: null,
      unselecting: null
    },
    _create: function () {
      var selectees, that = this;
      this.element.addClass('ui-selectable');
      this.dragged = false;
      this.refresh = function () {
        selectees = $(that.options.filter, that.element[0]);
        selectees.addClass('ui-selectee');
        selectees.each(function () {
          var $this = $(this), pos = $this.offset();
          $.data(this, 'selectable-item', {
            element: this,
            $element: $this,
            left: pos.left,
            top: pos.top,
            right: pos.left + $this.outerWidth(),
            bottom: pos.top + $this.outerHeight(),
            startselected: false,
            selected: $this.hasClass('ui-selected'),
            selecting: $this.hasClass('ui-selecting'),
            unselecting: $this.hasClass('ui-unselecting')
          });
        });
      };
      this.refresh();
      this.selectees = selectees.addClass('ui-selectee');
      this._mouseInit();
      this.helper = $('<div class=\'ui-selectable-helper\'></div>');
    },
    _destroy: function () {
      this.selectees.removeClass('ui-selectee').removeData('selectable-item');
      this.element.removeClass('ui-selectable ui-selectable-disabled');
      this._mouseDestroy();
    },
    _mouseStart: function (event) {
      var that = this, options = this.options;
      this.opos = [
        event.pageX,
        event.pageY
      ];
      if (this.options.disabled) {
        return;
      }
      this.selectees = $(options.filter, this.element[0]);
      this._trigger('start', event);
      $(options.appendTo).append(this.helper);
      this.helper.css({
        'left': event.pageX,
        'top': event.pageY,
        'width': 0,
        'height': 0
      });
      if (options.autoRefresh) {
        this.refresh();
      }
      this.selectees.filter('.ui-selected').each(function () {
        var selectee = $.data(this, 'selectable-item');
        selectee.startselected = true;
        if (!event.metaKey && !event.ctrlKey) {
          selectee.$element.removeClass('ui-selected');
          selectee.selected = false;
          selectee.$element.addClass('ui-unselecting');
          selectee.unselecting = true;
          that._trigger('unselecting', event, { unselecting: selectee.element });
        }
      });
      $(event.target).parents().addBack().each(function () {
        var doSelect, selectee = $.data(this, 'selectable-item');
        if (selectee) {
          doSelect = !event.metaKey && !event.ctrlKey || !selectee.$element.hasClass('ui-selected');
          selectee.$element.removeClass(doSelect ? 'ui-unselecting' : 'ui-selected').addClass(doSelect ? 'ui-selecting' : 'ui-unselecting');
          selectee.unselecting = !doSelect;
          selectee.selecting = doSelect;
          selectee.selected = doSelect;
          if (doSelect) {
            that._trigger('selecting', event, { selecting: selectee.element });
          } else {
            that._trigger('unselecting', event, { unselecting: selectee.element });
          }
          return false;
        }
      });
    },
    _mouseDrag: function (event) {
      this.dragged = true;
      if (this.options.disabled) {
        return;
      }
      var tmp, that = this, options = this.options, x1 = this.opos[0], y1 = this.opos[1], x2 = event.pageX, y2 = event.pageY;
      if (x1 > x2) {
        tmp = x2;
        x2 = x1;
        x1 = tmp;
      }
      if (y1 > y2) {
        tmp = y2;
        y2 = y1;
        y1 = tmp;
      }
      this.helper.css({
        left: x1,
        top: y1,
        width: x2 - x1,
        height: y2 - y1
      });
      this.selectees.each(function () {
        var selectee = $.data(this, 'selectable-item'), hit = false;
        if (!selectee || selectee.element === that.element[0]) {
          return;
        }
        if (options.tolerance === 'touch') {
          hit = !(selectee.left > x2 || selectee.right < x1 || selectee.top > y2 || selectee.bottom < y1);
        } else if (options.tolerance === 'fit') {
          hit = selectee.left > x1 && selectee.right < x2 && selectee.top > y1 && selectee.bottom < y2;
        }
        if (hit) {
          if (selectee.selected) {
            selectee.$element.removeClass('ui-selected');
            selectee.selected = false;
          }
          if (selectee.unselecting) {
            selectee.$element.removeClass('ui-unselecting');
            selectee.unselecting = false;
          }
          if (!selectee.selecting) {
            selectee.$element.addClass('ui-selecting');
            selectee.selecting = true;
            that._trigger('selecting', event, { selecting: selectee.element });
          }
        } else {
          if (selectee.selecting) {
            if ((event.metaKey || event.ctrlKey) && selectee.startselected) {
              selectee.$element.removeClass('ui-selecting');
              selectee.selecting = false;
              selectee.$element.addClass('ui-selected');
              selectee.selected = true;
            } else {
              selectee.$element.removeClass('ui-selecting');
              selectee.selecting = false;
              if (selectee.startselected) {
                selectee.$element.addClass('ui-unselecting');
                selectee.unselecting = true;
              }
              that._trigger('unselecting', event, { unselecting: selectee.element });
            }
          }
          if (selectee.selected) {
            if (!event.metaKey && !event.ctrlKey && !selectee.startselected) {
              selectee.$element.removeClass('ui-selected');
              selectee.selected = false;
              selectee.$element.addClass('ui-unselecting');
              selectee.unselecting = true;
              that._trigger('unselecting', event, { unselecting: selectee.element });
            }
          }
        }
      });
      return false;
    },
    _mouseStop: function (event) {
      var that = this;
      this.dragged = false;
      $('.ui-unselecting', this.element[0]).each(function () {
        var selectee = $.data(this, 'selectable-item');
        selectee.$element.removeClass('ui-unselecting');
        selectee.unselecting = false;
        selectee.startselected = false;
        that._trigger('unselected', event, { unselected: selectee.element });
      });
      $('.ui-selecting', this.element[0]).each(function () {
        var selectee = $.data(this, 'selectable-item');
        selectee.$element.removeClass('ui-selecting').addClass('ui-selected');
        selectee.selecting = false;
        selectee.selected = true;
        selectee.startselected = true;
        that._trigger('selected', event, { selected: selectee.element });
      });
      this._trigger('stop', event);
      this.helper.remove();
      return false;
    }
  });
}(jQuery));
(function ($, undefined) {
  var numPages = 5;
  $.widget('ui.slider', $.ui.mouse, {
    version: '1.10.4',
    widgetEventPrefix: 'slide',
    options: {
      animate: false,
      distance: 0,
      max: 100,
      min: 0,
      orientation: 'horizontal',
      range: false,
      step: 1,
      value: 0,
      values: null,
      change: null,
      slide: null,
      start: null,
      stop: null
    },
    _create: function () {
      this._keySliding = false;
      this._mouseSliding = false;
      this._animateOff = true;
      this._handleIndex = null;
      this._detectOrientation();
      this._mouseInit();
      this.element.addClass('ui-slider' + ' ui-slider-' + this.orientation + ' ui-widget' + ' ui-widget-content' + ' ui-corner-all');
      this._refresh();
      this._setOption('disabled', this.options.disabled);
      this._animateOff = false;
    },
    _refresh: function () {
      this._createRange();
      this._createHandles();
      this._setupEvents();
      this._refreshValue();
    },
    _createHandles: function () {
      var i, handleCount, options = this.options, existingHandles = this.element.find('.ui-slider-handle').addClass('ui-state-default ui-corner-all'), handle = '<a class=\'ui-slider-handle ui-state-default ui-corner-all\' href=\'#\'></a>', handles = [];
      handleCount = options.values && options.values.length || 1;
      if (existingHandles.length > handleCount) {
        existingHandles.slice(handleCount).remove();
        existingHandles = existingHandles.slice(0, handleCount);
      }
      for (i = existingHandles.length; i < handleCount; i++) {
        handles.push(handle);
      }
      this.handles = existingHandles.add($(handles.join('')).appendTo(this.element));
      this.handle = this.handles.eq(0);
      this.handles.each(function (i) {
        $(this).data('ui-slider-handle-index', i);
      });
    },
    _createRange: function () {
      var options = this.options, classes = '';
      if (options.range) {
        if (options.range === true) {
          if (!options.values) {
            options.values = [
              this._valueMin(),
              this._valueMin()
            ];
          } else if (options.values.length && options.values.length !== 2) {
            options.values = [
              options.values[0],
              options.values[0]
            ];
          } else if ($.isArray(options.values)) {
            options.values = options.values.slice(0);
          }
        }
        if (!this.range || !this.range.length) {
          this.range = $('<div></div>').appendTo(this.element);
          classes = 'ui-slider-range' + ' ui-widget-header ui-corner-all';
        } else {
          this.range.removeClass('ui-slider-range-min ui-slider-range-max').css({
            'left': '',
            'bottom': ''
          });
        }
        this.range.addClass(classes + (options.range === 'min' || options.range === 'max' ? ' ui-slider-range-' + options.range : ''));
      } else {
        if (this.range) {
          this.range.remove();
        }
        this.range = null;
      }
    },
    _setupEvents: function () {
      var elements = this.handles.add(this.range).filter('a');
      this._off(elements);
      this._on(elements, this._handleEvents);
      this._hoverable(elements);
      this._focusable(elements);
    },
    _destroy: function () {
      this.handles.remove();
      if (this.range) {
        this.range.remove();
      }
      this.element.removeClass('ui-slider' + ' ui-slider-horizontal' + ' ui-slider-vertical' + ' ui-widget' + ' ui-widget-content' + ' ui-corner-all');
      this._mouseDestroy();
    },
    _mouseCapture: function (event) {
      var position, normValue, distance, closestHandle, index, allowed, offset, mouseOverHandle, that = this, o = this.options;
      if (o.disabled) {
        return false;
      }
      this.elementSize = {
        width: this.element.outerWidth(),
        height: this.element.outerHeight()
      };
      this.elementOffset = this.element.offset();
      position = {
        x: event.pageX,
        y: event.pageY
      };
      normValue = this._normValueFromMouse(position);
      distance = this._valueMax() - this._valueMin() + 1;
      this.handles.each(function (i) {
        var thisDistance = Math.abs(normValue - that.values(i));
        if (distance > thisDistance || distance === thisDistance && (i === that._lastChangedValue || that.values(i) === o.min)) {
          distance = thisDistance;
          closestHandle = $(this);
          index = i;
        }
      });
      allowed = this._start(event, index);
      if (allowed === false) {
        return false;
      }
      this._mouseSliding = true;
      this._handleIndex = index;
      closestHandle.addClass('ui-state-active').focus();
      offset = closestHandle.offset();
      mouseOverHandle = !$(event.target).parents().addBack().is('.ui-slider-handle');
      this._clickOffset = mouseOverHandle ? {
        left: 0,
        top: 0
      } : {
        left: event.pageX - offset.left - closestHandle.width() / 2,
        top: event.pageY - offset.top - closestHandle.height() / 2 - (parseInt(closestHandle.css('borderTopWidth'), 10) || 0) - (parseInt(closestHandle.css('borderBottomWidth'), 10) || 0) + (parseInt(closestHandle.css('marginTop'), 10) || 0)
      };
      if (!this.handles.hasClass('ui-state-hover')) {
        this._slide(event, index, normValue);
      }
      this._animateOff = true;
      return true;
    },
    _mouseStart: function () {
      return true;
    },
    _mouseDrag: function (event) {
      var position = {
          x: event.pageX,
          y: event.pageY
        }, normValue = this._normValueFromMouse(position);
      this._slide(event, this._handleIndex, normValue);
      return false;
    },
    _mouseStop: function (event) {
      this.handles.removeClass('ui-state-active');
      this._mouseSliding = false;
      this._stop(event, this._handleIndex);
      this._change(event, this._handleIndex);
      this._handleIndex = null;
      this._clickOffset = null;
      this._animateOff = false;
      return false;
    },
    _detectOrientation: function () {
      this.orientation = this.options.orientation === 'vertical' ? 'vertical' : 'horizontal';
    },
    _normValueFromMouse: function (position) {
      var pixelTotal, pixelMouse, percentMouse, valueTotal, valueMouse;
      if (this.orientation === 'horizontal') {
        pixelTotal = this.elementSize.width;
        pixelMouse = position.x - this.elementOffset.left - (this._clickOffset ? this._clickOffset.left : 0);
      } else {
        pixelTotal = this.elementSize.height;
        pixelMouse = position.y - this.elementOffset.top - (this._clickOffset ? this._clickOffset.top : 0);
      }
      percentMouse = pixelMouse / pixelTotal;
      if (percentMouse > 1) {
        percentMouse = 1;
      }
      if (percentMouse < 0) {
        percentMouse = 0;
      }
      if (this.orientation === 'vertical') {
        percentMouse = 1 - percentMouse;
      }
      valueTotal = this._valueMax() - this._valueMin();
      valueMouse = this._valueMin() + percentMouse * valueTotal;
      return this._trimAlignValue(valueMouse);
    },
    _start: function (event, index) {
      var uiHash = {
          handle: this.handles[index],
          value: this.value()
        };
      if (this.options.values && this.options.values.length) {
        uiHash.value = this.values(index);
        uiHash.values = this.values();
      }
      return this._trigger('start', event, uiHash);
    },
    _slide: function (event, index, newVal) {
      var otherVal, newValues, allowed;
      if (this.options.values && this.options.values.length) {
        otherVal = this.values(index ? 0 : 1);
        if (this.options.values.length === 2 && this.options.range === true && (index === 0 && newVal > otherVal || index === 1 && newVal < otherVal)) {
          newVal = otherVal;
        }
        if (newVal !== this.values(index)) {
          newValues = this.values();
          newValues[index] = newVal;
          allowed = this._trigger('slide', event, {
            handle: this.handles[index],
            value: newVal,
            values: newValues
          });
          otherVal = this.values(index ? 0 : 1);
          if (allowed !== false) {
            this.values(index, newVal);
          }
        }
      } else {
        if (newVal !== this.value()) {
          allowed = this._trigger('slide', event, {
            handle: this.handles[index],
            value: newVal
          });
          if (allowed !== false) {
            this.value(newVal);
          }
        }
      }
    },
    _stop: function (event, index) {
      var uiHash = {
          handle: this.handles[index],
          value: this.value()
        };
      if (this.options.values && this.options.values.length) {
        uiHash.value = this.values(index);
        uiHash.values = this.values();
      }
      this._trigger('stop', event, uiHash);
    },
    _change: function (event, index) {
      if (!this._keySliding && !this._mouseSliding) {
        var uiHash = {
            handle: this.handles[index],
            value: this.value()
          };
        if (this.options.values && this.options.values.length) {
          uiHash.value = this.values(index);
          uiHash.values = this.values();
        }
        this._lastChangedValue = index;
        this._trigger('change', event, uiHash);
      }
    },
    value: function (newValue) {
      if (arguments.length) {
        this.options.value = this._trimAlignValue(newValue);
        this._refreshValue();
        this._change(null, 0);
        return;
      }
      return this._value();
    },
    values: function (index, newValue) {
      var vals, newValues, i;
      if (arguments.length > 1) {
        this.options.values[index] = this._trimAlignValue(newValue);
        this._refreshValue();
        this._change(null, index);
        return;
      }
      if (arguments.length) {
        if ($.isArray(arguments[0])) {
          vals = this.options.values;
          newValues = arguments[0];
          for (i = 0; i < vals.length; i += 1) {
            vals[i] = this._trimAlignValue(newValues[i]);
            this._change(null, i);
          }
          this._refreshValue();
        } else {
          if (this.options.values && this.options.values.length) {
            return this._values(index);
          } else {
            return this.value();
          }
        }
      } else {
        return this._values();
      }
    },
    _setOption: function (key, value) {
      var i, valsLength = 0;
      if (key === 'range' && this.options.range === true) {
        if (value === 'min') {
          this.options.value = this._values(0);
          this.options.values = null;
        } else if (value === 'max') {
          this.options.value = this._values(this.options.values.length - 1);
          this.options.values = null;
        }
      }
      if ($.isArray(this.options.values)) {
        valsLength = this.options.values.length;
      }
      $.Widget.prototype._setOption.apply(this, arguments);
      switch (key) {
      case 'orientation':
        this._detectOrientation();
        this.element.removeClass('ui-slider-horizontal ui-slider-vertical').addClass('ui-slider-' + this.orientation);
        this._refreshValue();
        break;
      case 'value':
        this._animateOff = true;
        this._refreshValue();
        this._change(null, 0);
        this._animateOff = false;
        break;
      case 'values':
        this._animateOff = true;
        this._refreshValue();
        for (i = 0; i < valsLength; i += 1) {
          this._change(null, i);
        }
        this._animateOff = false;
        break;
      case 'min':
      case 'max':
        this._animateOff = true;
        this._refreshValue();
        this._animateOff = false;
        break;
      case 'range':
        this._animateOff = true;
        this._refresh();
        this._animateOff = false;
        break;
      }
    },
    _value: function () {
      var val = this.options.value;
      val = this._trimAlignValue(val);
      return val;
    },
    _values: function (index) {
      var val, vals, i;
      if (arguments.length) {
        val = this.options.values[index];
        val = this._trimAlignValue(val);
        return val;
      } else if (this.options.values && this.options.values.length) {
        vals = this.options.values.slice();
        for (i = 0; i < vals.length; i += 1) {
          vals[i] = this._trimAlignValue(vals[i]);
        }
        return vals;
      } else {
        return [];
      }
    },
    _trimAlignValue: function (val) {
      if (val <= this._valueMin()) {
        return this._valueMin();
      }
      if (val >= this._valueMax()) {
        return this._valueMax();
      }
      var step = this.options.step > 0 ? this.options.step : 1, valModStep = (val - this._valueMin()) % step, alignValue = val - valModStep;
      if (Math.abs(valModStep) * 2 >= step) {
        alignValue += valModStep > 0 ? step : -step;
      }
      return parseFloat(alignValue.toFixed(5));
    },
    _valueMin: function () {
      return this.options.min;
    },
    _valueMax: function () {
      return this.options.max;
    },
    _refreshValue: function () {
      var lastValPercent, valPercent, value, valueMin, valueMax, oRange = this.options.range, o = this.options, that = this, animate = !this._animateOff ? o.animate : false, _set = {};
      if (this.options.values && this.options.values.length) {
        this.handles.each(function (i) {
          valPercent = (that.values(i) - that._valueMin()) / (that._valueMax() - that._valueMin()) * 100;
          _set[that.orientation === 'horizontal' ? 'left' : 'bottom'] = valPercent + '%';
          $(this).stop(1, 1)[animate ? 'animate' : 'css'](_set, o.animate);
          if (that.options.range === true) {
            if (that.orientation === 'horizontal') {
              if (i === 0) {
                that.range.stop(1, 1)[animate ? 'animate' : 'css']({ left: valPercent + '%' }, o.animate);
              }
              if (i === 1) {
                that.range[animate ? 'animate' : 'css']({ width: valPercent - lastValPercent + '%' }, {
                  queue: false,
                  duration: o.animate
                });
              }
            } else {
              if (i === 0) {
                that.range.stop(1, 1)[animate ? 'animate' : 'css']({ bottom: valPercent + '%' }, o.animate);
              }
              if (i === 1) {
                that.range[animate ? 'animate' : 'css']({ height: valPercent - lastValPercent + '%' }, {
                  queue: false,
                  duration: o.animate
                });
              }
            }
          }
          lastValPercent = valPercent;
        });
      } else {
        value = this.value();
        valueMin = this._valueMin();
        valueMax = this._valueMax();
        valPercent = valueMax !== valueMin ? (value - valueMin) / (valueMax - valueMin) * 100 : 0;
        _set[this.orientation === 'horizontal' ? 'left' : 'bottom'] = valPercent + '%';
        this.handle.stop(1, 1)[animate ? 'animate' : 'css'](_set, o.animate);
        if (oRange === 'min' && this.orientation === 'horizontal') {
          this.range.stop(1, 1)[animate ? 'animate' : 'css']({ width: valPercent + '%' }, o.animate);
        }
        if (oRange === 'max' && this.orientation === 'horizontal') {
          this.range[animate ? 'animate' : 'css']({ width: 100 - valPercent + '%' }, {
            queue: false,
            duration: o.animate
          });
        }
        if (oRange === 'min' && this.orientation === 'vertical') {
          this.range.stop(1, 1)[animate ? 'animate' : 'css']({ height: valPercent + '%' }, o.animate);
        }
        if (oRange === 'max' && this.orientation === 'vertical') {
          this.range[animate ? 'animate' : 'css']({ height: 100 - valPercent + '%' }, {
            queue: false,
            duration: o.animate
          });
        }
      }
    },
    _handleEvents: {
      keydown: function (event) {
        var allowed, curVal, newVal, step, index = $(event.target).data('ui-slider-handle-index');
        switch (event.keyCode) {
        case $.ui.keyCode.HOME:
        case $.ui.keyCode.END:
        case $.ui.keyCode.PAGE_UP:
        case $.ui.keyCode.PAGE_DOWN:
        case $.ui.keyCode.UP:
        case $.ui.keyCode.RIGHT:
        case $.ui.keyCode.DOWN:
        case $.ui.keyCode.LEFT:
          event.preventDefault();
          if (!this._keySliding) {
            this._keySliding = true;
            $(event.target).addClass('ui-state-active');
            allowed = this._start(event, index);
            if (allowed === false) {
              return;
            }
          }
          break;
        }
        step = this.options.step;
        if (this.options.values && this.options.values.length) {
          curVal = newVal = this.values(index);
        } else {
          curVal = newVal = this.value();
        }
        switch (event.keyCode) {
        case $.ui.keyCode.HOME:
          newVal = this._valueMin();
          break;
        case $.ui.keyCode.END:
          newVal = this._valueMax();
          break;
        case $.ui.keyCode.PAGE_UP:
          newVal = this._trimAlignValue(curVal + (this._valueMax() - this._valueMin()) / numPages);
          break;
        case $.ui.keyCode.PAGE_DOWN:
          newVal = this._trimAlignValue(curVal - (this._valueMax() - this._valueMin()) / numPages);
          break;
        case $.ui.keyCode.UP:
        case $.ui.keyCode.RIGHT:
          if (curVal === this._valueMax()) {
            return;
          }
          newVal = this._trimAlignValue(curVal + step);
          break;
        case $.ui.keyCode.DOWN:
        case $.ui.keyCode.LEFT:
          if (curVal === this._valueMin()) {
            return;
          }
          newVal = this._trimAlignValue(curVal - step);
          break;
        }
        this._slide(event, index, newVal);
      },
      click: function (event) {
        event.preventDefault();
      },
      keyup: function (event) {
        var index = $(event.target).data('ui-slider-handle-index');
        if (this._keySliding) {
          this._keySliding = false;
          this._stop(event, index);
          this._change(event, index);
          $(event.target).removeClass('ui-state-active');
        }
      }
    }
  });
}(jQuery));
(function ($, undefined) {
  function isOverAxis(x, reference, size) {
    return x > reference && x < reference + size;
  }
  function isFloating(item) {
    return /left|right/.test(item.css('float')) || /inline|table-cell/.test(item.css('display'));
  }
  $.widget('ui.sortable', $.ui.mouse, {
    version: '1.10.4',
    widgetEventPrefix: 'sort',
    ready: false,
    options: {
      appendTo: 'parent',
      axis: false,
      connectWith: false,
      containment: false,
      cursor: 'auto',
      cursorAt: false,
      dropOnEmpty: true,
      forcePlaceholderSize: false,
      forceHelperSize: false,
      grid: false,
      handle: false,
      helper: 'original',
      items: '> *',
      opacity: false,
      placeholder: false,
      revert: false,
      scroll: true,
      scrollSensitivity: 20,
      scrollSpeed: 20,
      scope: 'default',
      tolerance: 'intersect',
      zIndex: 1000,
      activate: null,
      beforeStop: null,
      change: null,
      deactivate: null,
      out: null,
      over: null,
      receive: null,
      remove: null,
      sort: null,
      start: null,
      stop: null,
      update: null
    },
    _create: function () {
      var o = this.options;
      this.containerCache = {};
      this.element.addClass('ui-sortable');
      this.refresh();
      this.floating = this.items.length ? o.axis === 'x' || isFloating(this.items[0].item) : false;
      this.offset = this.element.offset();
      this._mouseInit();
      this.ready = true;
    },
    _destroy: function () {
      this.element.removeClass('ui-sortable ui-sortable-disabled');
      this._mouseDestroy();
      for (var i = this.items.length - 1; i >= 0; i--) {
        this.items[i].item.removeData(this.widgetName + '-item');
      }
      return this;
    },
    _setOption: function (key, value) {
      if (key === 'disabled') {
        this.options[key] = value;
        this.widget().toggleClass('ui-sortable-disabled', !!value);
      } else {
        $.Widget.prototype._setOption.apply(this, arguments);
      }
    },
    _mouseCapture: function (event, overrideHandle) {
      var currentItem = null, validHandle = false, that = this;
      if (this.reverting) {
        return false;
      }
      if (this.options.disabled || this.options.type === 'static') {
        return false;
      }
      this._refreshItems(event);
      $(event.target).parents().each(function () {
        if ($.data(this, that.widgetName + '-item') === that) {
          currentItem = $(this);
          return false;
        }
      });
      if ($.data(event.target, that.widgetName + '-item') === that) {
        currentItem = $(event.target);
      }
      if (!currentItem) {
        return false;
      }
      if (this.options.handle && !overrideHandle) {
        $(this.options.handle, currentItem).find('*').addBack().each(function () {
          if (this === event.target) {
            validHandle = true;
          }
        });
        if (!validHandle) {
          return false;
        }
      }
      this.currentItem = currentItem;
      this._removeCurrentsFromItems();
      return true;
    },
    _mouseStart: function (event, overrideHandle, noActivation) {
      var i, body, o = this.options;
      this.currentContainer = this;
      this.refreshPositions();
      this.helper = this._createHelper(event);
      this._cacheHelperProportions();
      this._cacheMargins();
      this.scrollParent = this.helper.scrollParent();
      this.offset = this.currentItem.offset();
      this.offset = {
        top: this.offset.top - this.margins.top,
        left: this.offset.left - this.margins.left
      };
      $.extend(this.offset, {
        click: {
          left: event.pageX - this.offset.left,
          top: event.pageY - this.offset.top
        },
        parent: this._getParentOffset(),
        relative: this._getRelativeOffset()
      });
      this.helper.css('position', 'absolute');
      this.cssPosition = this.helper.css('position');
      this.originalPosition = this._generatePosition(event);
      this.originalPageX = event.pageX;
      this.originalPageY = event.pageY;
      o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt);
      this.domPosition = {
        prev: this.currentItem.prev()[0],
        parent: this.currentItem.parent()[0]
      };
      if (this.helper[0] !== this.currentItem[0]) {
        this.currentItem.hide();
      }
      this._createPlaceholder();
      if (o.containment) {
        this._setContainment();
      }
      if (o.cursor && o.cursor !== 'auto') {
        body = this.document.find('body');
        this.storedCursor = body.css('cursor');
        body.css('cursor', o.cursor);
        this.storedStylesheet = $('<style>*{ cursor: ' + o.cursor + ' !important; }</style>').appendTo(body);
      }
      if (o.opacity) {
        if (this.helper.css('opacity')) {
          this._storedOpacity = this.helper.css('opacity');
        }
        this.helper.css('opacity', o.opacity);
      }
      if (o.zIndex) {
        if (this.helper.css('zIndex')) {
          this._storedZIndex = this.helper.css('zIndex');
        }
        this.helper.css('zIndex', o.zIndex);
      }
      if (this.scrollParent[0] !== document && this.scrollParent[0].tagName !== 'HTML') {
        this.overflowOffset = this.scrollParent.offset();
      }
      this._trigger('start', event, this._uiHash());
      if (!this._preserveHelperProportions) {
        this._cacheHelperProportions();
      }
      if (!noActivation) {
        for (i = this.containers.length - 1; i >= 0; i--) {
          this.containers[i]._trigger('activate', event, this._uiHash(this));
        }
      }
      if ($.ui.ddmanager) {
        $.ui.ddmanager.current = this;
      }
      if ($.ui.ddmanager && !o.dropBehaviour) {
        $.ui.ddmanager.prepareOffsets(this, event);
      }
      this.dragging = true;
      this.helper.addClass('ui-sortable-helper');
      this._mouseDrag(event);
      return true;
    },
    _mouseDrag: function (event) {
      var i, item, itemElement, intersection, o = this.options, scrolled = false;
      this.position = this._generatePosition(event);
      this.positionAbs = this._convertPositionTo('absolute');
      if (!this.lastPositionAbs) {
        this.lastPositionAbs = this.positionAbs;
      }
      if (this.options.scroll) {
        if (this.scrollParent[0] !== document && this.scrollParent[0].tagName !== 'HTML') {
          if (this.overflowOffset.top + this.scrollParent[0].offsetHeight - event.pageY < o.scrollSensitivity) {
            this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop + o.scrollSpeed;
          } else if (event.pageY - this.overflowOffset.top < o.scrollSensitivity) {
            this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop - o.scrollSpeed;
          }
          if (this.overflowOffset.left + this.scrollParent[0].offsetWidth - event.pageX < o.scrollSensitivity) {
            this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft + o.scrollSpeed;
          } else if (event.pageX - this.overflowOffset.left < o.scrollSensitivity) {
            this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft - o.scrollSpeed;
          }
        } else {
          if (event.pageY - $(document).scrollTop() < o.scrollSensitivity) {
            scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
          } else if ($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity) {
            scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);
          }
          if (event.pageX - $(document).scrollLeft() < o.scrollSensitivity) {
            scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
          } else if ($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity) {
            scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);
          }
        }
        if (scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {
          $.ui.ddmanager.prepareOffsets(this, event);
        }
      }
      this.positionAbs = this._convertPositionTo('absolute');
      if (!this.options.axis || this.options.axis !== 'y') {
        this.helper[0].style.left = this.position.left + 'px';
      }
      if (!this.options.axis || this.options.axis !== 'x') {
        this.helper[0].style.top = this.position.top + 'px';
      }
      for (i = this.items.length - 1; i >= 0; i--) {
        item = this.items[i];
        itemElement = item.item[0];
        intersection = this._intersectsWithPointer(item);
        if (!intersection) {
          continue;
        }
        if (item.instance !== this.currentContainer) {
          continue;
        }
        if (itemElement !== this.currentItem[0] && this.placeholder[intersection === 1 ? 'next' : 'prev']()[0] !== itemElement && !$.contains(this.placeholder[0], itemElement) && (this.options.type === 'semi-dynamic' ? !$.contains(this.element[0], itemElement) : true)) {
          this.direction = intersection === 1 ? 'down' : 'up';
          if (this.options.tolerance === 'pointer' || this._intersectsWithSides(item)) {
            this._rearrange(event, item);
          } else {
            break;
          }
          this._trigger('change', event, this._uiHash());
          break;
        }
      }
      this._contactContainers(event);
      if ($.ui.ddmanager) {
        $.ui.ddmanager.drag(this, event);
      }
      this._trigger('sort', event, this._uiHash());
      this.lastPositionAbs = this.positionAbs;
      return false;
    },
    _mouseStop: function (event, noPropagation) {
      if (!event) {
        return;
      }
      if ($.ui.ddmanager && !this.options.dropBehaviour) {
        $.ui.ddmanager.drop(this, event);
      }
      if (this.options.revert) {
        var that = this, cur = this.placeholder.offset(), axis = this.options.axis, animation = {};
        if (!axis || axis === 'x') {
          animation.left = cur.left - this.offset.parent.left - this.margins.left + (this.offsetParent[0] === document.body ? 0 : this.offsetParent[0].scrollLeft);
        }
        if (!axis || axis === 'y') {
          animation.top = cur.top - this.offset.parent.top - this.margins.top + (this.offsetParent[0] === document.body ? 0 : this.offsetParent[0].scrollTop);
        }
        this.reverting = true;
        $(this.helper).animate(animation, parseInt(this.options.revert, 10) || 500, function () {
          that._clear(event);
        });
      } else {
        this._clear(event, noPropagation);
      }
      return false;
    },
    cancel: function () {
      if (this.dragging) {
        this._mouseUp({ target: null });
        if (this.options.helper === 'original') {
          this.currentItem.css(this._storedCSS).removeClass('ui-sortable-helper');
        } else {
          this.currentItem.show();
        }
        for (var i = this.containers.length - 1; i >= 0; i--) {
          this.containers[i]._trigger('deactivate', null, this._uiHash(this));
          if (this.containers[i].containerCache.over) {
            this.containers[i]._trigger('out', null, this._uiHash(this));
            this.containers[i].containerCache.over = 0;
          }
        }
      }
      if (this.placeholder) {
        if (this.placeholder[0].parentNode) {
          this.placeholder[0].parentNode.removeChild(this.placeholder[0]);
        }
        if (this.options.helper !== 'original' && this.helper && this.helper[0].parentNode) {
          this.helper.remove();
        }
        $.extend(this, {
          helper: null,
          dragging: false,
          reverting: false,
          _noFinalSort: null
        });
        if (this.domPosition.prev) {
          $(this.domPosition.prev).after(this.currentItem);
        } else {
          $(this.domPosition.parent).prepend(this.currentItem);
        }
      }
      return this;
    },
    serialize: function (o) {
      var items = this._getItemsAsjQuery(o && o.connected), str = [];
      o = o || {};
      $(items).each(function () {
        var res = ($(o.item || this).attr(o.attribute || 'id') || '').match(o.expression || /(.+)[\-=_](.+)/);
        if (res) {
          str.push((o.key || res[1] + '[]') + '=' + (o.key && o.expression ? res[1] : res[2]));
        }
      });
      if (!str.length && o.key) {
        str.push(o.key + '=');
      }
      return str.join('&');
    },
    toArray: function (o) {
      var items = this._getItemsAsjQuery(o && o.connected), ret = [];
      o = o || {};
      items.each(function () {
        ret.push($(o.item || this).attr(o.attribute || 'id') || '');
      });
      return ret;
    },
    _intersectsWith: function (item) {
      var x1 = this.positionAbs.left, x2 = x1 + this.helperProportions.width, y1 = this.positionAbs.top, y2 = y1 + this.helperProportions.height, l = item.left, r = l + item.width, t = item.top, b = t + item.height, dyClick = this.offset.click.top, dxClick = this.offset.click.left, isOverElementHeight = this.options.axis === 'x' || y1 + dyClick > t && y1 + dyClick < b, isOverElementWidth = this.options.axis === 'y' || x1 + dxClick > l && x1 + dxClick < r, isOverElement = isOverElementHeight && isOverElementWidth;
      if (this.options.tolerance === 'pointer' || this.options.forcePointerForContainers || this.options.tolerance !== 'pointer' && this.helperProportions[this.floating ? 'width' : 'height'] > item[this.floating ? 'width' : 'height']) {
        return isOverElement;
      } else {
        return l < x1 + this.helperProportions.width / 2 && x2 - this.helperProportions.width / 2 < r && t < y1 + this.helperProportions.height / 2 && y2 - this.helperProportions.height / 2 < b;
      }
    },
    _intersectsWithPointer: function (item) {
      var isOverElementHeight = this.options.axis === 'x' || isOverAxis(this.positionAbs.top + this.offset.click.top, item.top, item.height), isOverElementWidth = this.options.axis === 'y' || isOverAxis(this.positionAbs.left + this.offset.click.left, item.left, item.width), isOverElement = isOverElementHeight && isOverElementWidth, verticalDirection = this._getDragVerticalDirection(), horizontalDirection = this._getDragHorizontalDirection();
      if (!isOverElement) {
        return false;
      }
      return this.floating ? horizontalDirection && horizontalDirection === 'right' || verticalDirection === 'down' ? 2 : 1 : verticalDirection && (verticalDirection === 'down' ? 2 : 1);
    },
    _intersectsWithSides: function (item) {
      var isOverBottomHalf = isOverAxis(this.positionAbs.top + this.offset.click.top, item.top + item.height / 2, item.height), isOverRightHalf = isOverAxis(this.positionAbs.left + this.offset.click.left, item.left + item.width / 2, item.width), verticalDirection = this._getDragVerticalDirection(), horizontalDirection = this._getDragHorizontalDirection();
      if (this.floating && horizontalDirection) {
        return horizontalDirection === 'right' && isOverRightHalf || horizontalDirection === 'left' && !isOverRightHalf;
      } else {
        return verticalDirection && (verticalDirection === 'down' && isOverBottomHalf || verticalDirection === 'up' && !isOverBottomHalf);
      }
    },
    _getDragVerticalDirection: function () {
      var delta = this.positionAbs.top - this.lastPositionAbs.top;
      return delta !== 0 && (delta > 0 ? 'down' : 'up');
    },
    _getDragHorizontalDirection: function () {
      var delta = this.positionAbs.left - this.lastPositionAbs.left;
      return delta !== 0 && (delta > 0 ? 'right' : 'left');
    },
    refresh: function (event) {
      this._refreshItems(event);
      this.refreshPositions();
      return this;
    },
    _connectWith: function () {
      var options = this.options;
      return options.connectWith.constructor === String ? [options.connectWith] : options.connectWith;
    },
    _getItemsAsjQuery: function (connected) {
      var i, j, cur, inst, items = [], queries = [], connectWith = this._connectWith();
      if (connectWith && connected) {
        for (i = connectWith.length - 1; i >= 0; i--) {
          cur = $(connectWith[i]);
          for (j = cur.length - 1; j >= 0; j--) {
            inst = $.data(cur[j], this.widgetFullName);
            if (inst && inst !== this && !inst.options.disabled) {
              queries.push([
                $.isFunction(inst.options.items) ? inst.options.items.call(inst.element) : $(inst.options.items, inst.element).not('.ui-sortable-helper').not('.ui-sortable-placeholder'),
                inst
              ]);
            }
          }
        }
      }
      queries.push([
        $.isFunction(this.options.items) ? this.options.items.call(this.element, null, {
          options: this.options,
          item: this.currentItem
        }) : $(this.options.items, this.element).not('.ui-sortable-helper').not('.ui-sortable-placeholder'),
        this
      ]);
      function addItems() {
        items.push(this);
      }
      for (i = queries.length - 1; i >= 0; i--) {
        queries[i][0].each(addItems);
      }
      return $(items);
    },
    _removeCurrentsFromItems: function () {
      var list = this.currentItem.find(':data(' + this.widgetName + '-item)');
      this.items = $.grep(this.items, function (item) {
        for (var j = 0; j < list.length; j++) {
          if (list[j] === item.item[0]) {
            return false;
          }
        }
        return true;
      });
    },
    _refreshItems: function (event) {
      this.items = [];
      this.containers = [this];
      var i, j, cur, inst, targetData, _queries, item, queriesLength, items = this.items, queries = [[
            $.isFunction(this.options.items) ? this.options.items.call(this.element[0], event, { item: this.currentItem }) : $(this.options.items, this.element),
            this
          ]], connectWith = this._connectWith();
      if (connectWith && this.ready) {
        for (i = connectWith.length - 1; i >= 0; i--) {
          cur = $(connectWith[i]);
          for (j = cur.length - 1; j >= 0; j--) {
            inst = $.data(cur[j], this.widgetFullName);
            if (inst && inst !== this && !inst.options.disabled) {
              queries.push([
                $.isFunction(inst.options.items) ? inst.options.items.call(inst.element[0], event, { item: this.currentItem }) : $(inst.options.items, inst.element),
                inst
              ]);
              this.containers.push(inst);
            }
          }
        }
      }
      for (i = queries.length - 1; i >= 0; i--) {
        targetData = queries[i][1];
        _queries = queries[i][0];
        for (j = 0, queriesLength = _queries.length; j < queriesLength; j++) {
          item = $(_queries[j]);
          item.data(this.widgetName + '-item', targetData);
          items.push({
            item: item,
            instance: targetData,
            width: 0,
            height: 0,
            left: 0,
            top: 0
          });
        }
      }
    },
    refreshPositions: function (fast) {
      if (this.offsetParent && this.helper) {
        this.offset.parent = this._getParentOffset();
      }
      var i, item, t, p;
      for (i = this.items.length - 1; i >= 0; i--) {
        item = this.items[i];
        if (item.instance !== this.currentContainer && this.currentContainer && item.item[0] !== this.currentItem[0]) {
          continue;
        }
        t = this.options.toleranceElement ? $(this.options.toleranceElement, item.item) : item.item;
        if (!fast) {
          item.width = t.outerWidth();
          item.height = t.outerHeight();
        }
        p = t.offset();
        item.left = p.left;
        item.top = p.top;
      }
      if (this.options.custom && this.options.custom.refreshContainers) {
        this.options.custom.refreshContainers.call(this);
      } else {
        for (i = this.containers.length - 1; i >= 0; i--) {
          p = this.containers[i].element.offset();
          this.containers[i].containerCache.left = p.left;
          this.containers[i].containerCache.top = p.top;
          this.containers[i].containerCache.width = this.containers[i].element.outerWidth();
          this.containers[i].containerCache.height = this.containers[i].element.outerHeight();
        }
      }
      return this;
    },
    _createPlaceholder: function (that) {
      that = that || this;
      var className, o = that.options;
      if (!o.placeholder || o.placeholder.constructor === String) {
        className = o.placeholder;
        o.placeholder = {
          element: function () {
            var nodeName = that.currentItem[0].nodeName.toLowerCase(), element = $('<' + nodeName + '>', that.document[0]).addClass(className || that.currentItem[0].className + ' ui-sortable-placeholder').removeClass('ui-sortable-helper');
            if (nodeName === 'tr') {
              that.currentItem.children().each(function () {
                $('<td>&#160;</td>', that.document[0]).attr('colspan', $(this).attr('colspan') || 1).appendTo(element);
              });
            } else if (nodeName === 'img') {
              element.attr('src', that.currentItem.attr('src'));
            }
            if (!className) {
              element.css('visibility', 'hidden');
            }
            return element;
          },
          update: function (container, p) {
            if (className && !o.forcePlaceholderSize) {
              return;
            }
            if (!p.height()) {
              p.height(that.currentItem.innerHeight() - parseInt(that.currentItem.css('paddingTop') || 0, 10) - parseInt(that.currentItem.css('paddingBottom') || 0, 10));
            }
            if (!p.width()) {
              p.width(that.currentItem.innerWidth() - parseInt(that.currentItem.css('paddingLeft') || 0, 10) - parseInt(that.currentItem.css('paddingRight') || 0, 10));
            }
          }
        };
      }
      that.placeholder = $(o.placeholder.element.call(that.element, that.currentItem));
      that.currentItem.after(that.placeholder);
      o.placeholder.update(that, that.placeholder);
    },
    _contactContainers: function (event) {
      var i, j, dist, itemWithLeastDistance, posProperty, sizeProperty, base, cur, nearBottom, floating, innermostContainer = null, innermostIndex = null;
      for (i = this.containers.length - 1; i >= 0; i--) {
        if ($.contains(this.currentItem[0], this.containers[i].element[0])) {
          continue;
        }
        if (this._intersectsWith(this.containers[i].containerCache)) {
          if (innermostContainer && $.contains(this.containers[i].element[0], innermostContainer.element[0])) {
            continue;
          }
          innermostContainer = this.containers[i];
          innermostIndex = i;
        } else {
          if (this.containers[i].containerCache.over) {
            this.containers[i]._trigger('out', event, this._uiHash(this));
            this.containers[i].containerCache.over = 0;
          }
        }
      }
      if (!innermostContainer) {
        return;
      }
      if (this.containers.length === 1) {
        if (!this.containers[innermostIndex].containerCache.over) {
          this.containers[innermostIndex]._trigger('over', event, this._uiHash(this));
          this.containers[innermostIndex].containerCache.over = 1;
        }
      } else {
        dist = 10000;
        itemWithLeastDistance = null;
        floating = innermostContainer.floating || isFloating(this.currentItem);
        posProperty = floating ? 'left' : 'top';
        sizeProperty = floating ? 'width' : 'height';
        base = this.positionAbs[posProperty] + this.offset.click[posProperty];
        for (j = this.items.length - 1; j >= 0; j--) {
          if (!$.contains(this.containers[innermostIndex].element[0], this.items[j].item[0])) {
            continue;
          }
          if (this.items[j].item[0] === this.currentItem[0]) {
            continue;
          }
          if (floating && !isOverAxis(this.positionAbs.top + this.offset.click.top, this.items[j].top, this.items[j].height)) {
            continue;
          }
          cur = this.items[j].item.offset()[posProperty];
          nearBottom = false;
          if (Math.abs(cur - base) > Math.abs(cur + this.items[j][sizeProperty] - base)) {
            nearBottom = true;
            cur += this.items[j][sizeProperty];
          }
          if (Math.abs(cur - base) < dist) {
            dist = Math.abs(cur - base);
            itemWithLeastDistance = this.items[j];
            this.direction = nearBottom ? 'up' : 'down';
          }
        }
        if (!itemWithLeastDistance && !this.options.dropOnEmpty) {
          return;
        }
        if (this.currentContainer === this.containers[innermostIndex]) {
          return;
        }
        itemWithLeastDistance ? this._rearrange(event, itemWithLeastDistance, null, true) : this._rearrange(event, null, this.containers[innermostIndex].element, true);
        this._trigger('change', event, this._uiHash());
        this.containers[innermostIndex]._trigger('change', event, this._uiHash(this));
        this.currentContainer = this.containers[innermostIndex];
        this.options.placeholder.update(this.currentContainer, this.placeholder);
        this.containers[innermostIndex]._trigger('over', event, this._uiHash(this));
        this.containers[innermostIndex].containerCache.over = 1;
      }
    },
    _createHelper: function (event) {
      var o = this.options, helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [
          event,
          this.currentItem
        ])) : o.helper === 'clone' ? this.currentItem.clone() : this.currentItem;
      if (!helper.parents('body').length) {
        $(o.appendTo !== 'parent' ? o.appendTo : this.currentItem[0].parentNode)[0].appendChild(helper[0]);
      }
      if (helper[0] === this.currentItem[0]) {
        this._storedCSS = {
          width: this.currentItem[0].style.width,
          height: this.currentItem[0].style.height,
          position: this.currentItem.css('position'),
          top: this.currentItem.css('top'),
          left: this.currentItem.css('left')
        };
      }
      if (!helper[0].style.width || o.forceHelperSize) {
        helper.width(this.currentItem.width());
      }
      if (!helper[0].style.height || o.forceHelperSize) {
        helper.height(this.currentItem.height());
      }
      return helper;
    },
    _adjustOffsetFromHelper: function (obj) {
      if (typeof obj === 'string') {
        obj = obj.split(' ');
      }
      if ($.isArray(obj)) {
        obj = {
          left: +obj[0],
          top: +obj[1] || 0
        };
      }
      if ('left' in obj) {
        this.offset.click.left = obj.left + this.margins.left;
      }
      if ('right' in obj) {
        this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
      }
      if ('top' in obj) {
        this.offset.click.top = obj.top + this.margins.top;
      }
      if ('bottom' in obj) {
        this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
      }
    },
    _getParentOffset: function () {
      this.offsetParent = this.helper.offsetParent();
      var po = this.offsetParent.offset();
      if (this.cssPosition === 'absolute' && this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) {
        po.left += this.scrollParent.scrollLeft();
        po.top += this.scrollParent.scrollTop();
      }
      if (this.offsetParent[0] === document.body || this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() === 'html' && $.ui.ie) {
        po = {
          top: 0,
          left: 0
        };
      }
      return {
        top: po.top + (parseInt(this.offsetParent.css('borderTopWidth'), 10) || 0),
        left: po.left + (parseInt(this.offsetParent.css('borderLeftWidth'), 10) || 0)
      };
    },
    _getRelativeOffset: function () {
      if (this.cssPosition === 'relative') {
        var p = this.currentItem.position();
        return {
          top: p.top - (parseInt(this.helper.css('top'), 10) || 0) + this.scrollParent.scrollTop(),
          left: p.left - (parseInt(this.helper.css('left'), 10) || 0) + this.scrollParent.scrollLeft()
        };
      } else {
        return {
          top: 0,
          left: 0
        };
      }
    },
    _cacheMargins: function () {
      this.margins = {
        left: parseInt(this.currentItem.css('marginLeft'), 10) || 0,
        top: parseInt(this.currentItem.css('marginTop'), 10) || 0
      };
    },
    _cacheHelperProportions: function () {
      this.helperProportions = {
        width: this.helper.outerWidth(),
        height: this.helper.outerHeight()
      };
    },
    _setContainment: function () {
      var ce, co, over, o = this.options;
      if (o.containment === 'parent') {
        o.containment = this.helper[0].parentNode;
      }
      if (o.containment === 'document' || o.containment === 'window') {
        this.containment = [
          0 - this.offset.relative.left - this.offset.parent.left,
          0 - this.offset.relative.top - this.offset.parent.top,
          $(o.containment === 'document' ? document : window).width() - this.helperProportions.width - this.margins.left,
          ($(o.containment === 'document' ? document : window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top
        ];
      }
      if (!/^(document|window|parent)$/.test(o.containment)) {
        ce = $(o.containment)[0];
        co = $(o.containment).offset();
        over = $(ce).css('overflow') !== 'hidden';
        this.containment = [
          co.left + (parseInt($(ce).css('borderLeftWidth'), 10) || 0) + (parseInt($(ce).css('paddingLeft'), 10) || 0) - this.margins.left,
          co.top + (parseInt($(ce).css('borderTopWidth'), 10) || 0) + (parseInt($(ce).css('paddingTop'), 10) || 0) - this.margins.top,
          co.left + (over ? Math.max(ce.scrollWidth, ce.offsetWidth) : ce.offsetWidth) - (parseInt($(ce).css('borderLeftWidth'), 10) || 0) - (parseInt($(ce).css('paddingRight'), 10) || 0) - this.helperProportions.width - this.margins.left,
          co.top + (over ? Math.max(ce.scrollHeight, ce.offsetHeight) : ce.offsetHeight) - (parseInt($(ce).css('borderTopWidth'), 10) || 0) - (parseInt($(ce).css('paddingBottom'), 10) || 0) - this.helperProportions.height - this.margins.top
        ];
      }
    },
    _convertPositionTo: function (d, pos) {
      if (!pos) {
        pos = this.position;
      }
      var mod = d === 'absolute' ? 1 : -1, scroll = this.cssPosition === 'absolute' && !(this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = /(html|body)/i.test(scroll[0].tagName);
      return {
        top: pos.top + this.offset.relative.top * mod + this.offset.parent.top * mod - (this.cssPosition === 'fixed' ? -this.scrollParent.scrollTop() : scrollIsRootNode ? 0 : scroll.scrollTop()) * mod,
        left: pos.left + this.offset.relative.left * mod + this.offset.parent.left * mod - (this.cssPosition === 'fixed' ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft()) * mod
      };
    },
    _generatePosition: function (event) {
      var top, left, o = this.options, pageX = event.pageX, pageY = event.pageY, scroll = this.cssPosition === 'absolute' && !(this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = /(html|body)/i.test(scroll[0].tagName);
      if (this.cssPosition === 'relative' && !(this.scrollParent[0] !== document && this.scrollParent[0] !== this.offsetParent[0])) {
        this.offset.relative = this._getRelativeOffset();
      }
      if (this.originalPosition) {
        if (this.containment) {
          if (event.pageX - this.offset.click.left < this.containment[0]) {
            pageX = this.containment[0] + this.offset.click.left;
          }
          if (event.pageY - this.offset.click.top < this.containment[1]) {
            pageY = this.containment[1] + this.offset.click.top;
          }
          if (event.pageX - this.offset.click.left > this.containment[2]) {
            pageX = this.containment[2] + this.offset.click.left;
          }
          if (event.pageY - this.offset.click.top > this.containment[3]) {
            pageY = this.containment[3] + this.offset.click.top;
          }
        }
        if (o.grid) {
          top = this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1];
          pageY = this.containment ? top - this.offset.click.top >= this.containment[1] && top - this.offset.click.top <= this.containment[3] ? top : top - this.offset.click.top >= this.containment[1] ? top - o.grid[1] : top + o.grid[1] : top;
          left = this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0];
          pageX = this.containment ? left - this.offset.click.left >= this.containment[0] && left - this.offset.click.left <= this.containment[2] ? left : left - this.offset.click.left >= this.containment[0] ? left - o.grid[0] : left + o.grid[0] : left;
        }
      }
      return {
        top: pageY - this.offset.click.top - this.offset.relative.top - this.offset.parent.top + (this.cssPosition === 'fixed' ? -this.scrollParent.scrollTop() : scrollIsRootNode ? 0 : scroll.scrollTop()),
        left: pageX - this.offset.click.left - this.offset.relative.left - this.offset.parent.left + (this.cssPosition === 'fixed' ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft())
      };
    },
    _rearrange: function (event, i, a, hardRefresh) {
      a ? a[0].appendChild(this.placeholder[0]) : i.item[0].parentNode.insertBefore(this.placeholder[0], this.direction === 'down' ? i.item[0] : i.item[0].nextSibling);
      this.counter = this.counter ? ++this.counter : 1;
      var counter = this.counter;
      this._delay(function () {
        if (counter === this.counter) {
          this.refreshPositions(!hardRefresh);
        }
      });
    },
    _clear: function (event, noPropagation) {
      this.reverting = false;
      var i, delayedTriggers = [];
      if (!this._noFinalSort && this.currentItem.parent().length) {
        this.placeholder.before(this.currentItem);
      }
      this._noFinalSort = null;
      if (this.helper[0] === this.currentItem[0]) {
        for (i in this._storedCSS) {
          if (this._storedCSS[i] === 'auto' || this._storedCSS[i] === 'static') {
            this._storedCSS[i] = '';
          }
        }
        this.currentItem.css(this._storedCSS).removeClass('ui-sortable-helper');
      } else {
        this.currentItem.show();
      }
      if (this.fromOutside && !noPropagation) {
        delayedTriggers.push(function (event) {
          this._trigger('receive', event, this._uiHash(this.fromOutside));
        });
      }
      if ((this.fromOutside || this.domPosition.prev !== this.currentItem.prev().not('.ui-sortable-helper')[0] || this.domPosition.parent !== this.currentItem.parent()[0]) && !noPropagation) {
        delayedTriggers.push(function (event) {
          this._trigger('update', event, this._uiHash());
        });
      }
      if (this !== this.currentContainer) {
        if (!noPropagation) {
          delayedTriggers.push(function (event) {
            this._trigger('remove', event, this._uiHash());
          });
          delayedTriggers.push(function (c) {
            return function (event) {
              c._trigger('receive', event, this._uiHash(this));
            };
          }.call(this, this.currentContainer));
          delayedTriggers.push(function (c) {
            return function (event) {
              c._trigger('update', event, this._uiHash(this));
            };
          }.call(this, this.currentContainer));
        }
      }
      function delayEvent(type, instance, container) {
        return function (event) {
          container._trigger(type, event, instance._uiHash(instance));
        };
      }
      for (i = this.containers.length - 1; i >= 0; i--) {
        if (!noPropagation) {
          delayedTriggers.push(delayEvent('deactivate', this, this.containers[i]));
        }
        if (this.containers[i].containerCache.over) {
          delayedTriggers.push(delayEvent('out', this, this.containers[i]));
          this.containers[i].containerCache.over = 0;
        }
      }
      if (this.storedCursor) {
        this.document.find('body').css('cursor', this.storedCursor);
        this.storedStylesheet.remove();
      }
      if (this._storedOpacity) {
        this.helper.css('opacity', this._storedOpacity);
      }
      if (this._storedZIndex) {
        this.helper.css('zIndex', this._storedZIndex === 'auto' ? '' : this._storedZIndex);
      }
      this.dragging = false;
      if (this.cancelHelperRemoval) {
        if (!noPropagation) {
          this._trigger('beforeStop', event, this._uiHash());
          for (i = 0; i < delayedTriggers.length; i++) {
            delayedTriggers[i].call(this, event);
          }
          this._trigger('stop', event, this._uiHash());
        }
        this.fromOutside = false;
        return false;
      }
      if (!noPropagation) {
        this._trigger('beforeStop', event, this._uiHash());
      }
      this.placeholder[0].parentNode.removeChild(this.placeholder[0]);
      if (this.helper[0] !== this.currentItem[0]) {
        this.helper.remove();
      }
      this.helper = null;
      if (!noPropagation) {
        for (i = 0; i < delayedTriggers.length; i++) {
          delayedTriggers[i].call(this, event);
        }
        this._trigger('stop', event, this._uiHash());
      }
      this.fromOutside = false;
      return true;
    },
    _trigger: function () {
      if ($.Widget.prototype._trigger.apply(this, arguments) === false) {
        this.cancel();
      }
    },
    _uiHash: function (_inst) {
      var inst = _inst || this;
      return {
        helper: inst.helper,
        placeholder: inst.placeholder || $([]),
        position: inst.position,
        originalPosition: inst.originalPosition,
        offset: inst.positionAbs,
        item: inst.currentItem,
        sender: _inst ? _inst.element : null
      };
    }
  });
}(jQuery));
(function ($) {
  function modifier(fn) {
    return function () {
      var previous = this.element.val();
      fn.apply(this, arguments);
      this._refresh();
      if (previous !== this.element.val()) {
        this._trigger('change');
      }
    };
  }
  $.widget('ui.spinner', {
    version: '1.10.4',
    defaultElement: '<input>',
    widgetEventPrefix: 'spin',
    options: {
      culture: null,
      icons: {
        down: 'ui-icon-triangle-1-s',
        up: 'ui-icon-triangle-1-n'
      },
      incremental: true,
      max: null,
      min: null,
      numberFormat: null,
      page: 10,
      step: 1,
      change: null,
      spin: null,
      start: null,
      stop: null
    },
    _create: function () {
      this._setOption('max', this.options.max);
      this._setOption('min', this.options.min);
      this._setOption('step', this.options.step);
      if (this.value() !== '') {
        this._value(this.element.val(), true);
      }
      this._draw();
      this._on(this._events);
      this._refresh();
      this._on(this.window, {
        beforeunload: function () {
          this.element.removeAttr('autocomplete');
        }
      });
    },
    _getCreateOptions: function () {
      var options = {}, element = this.element;
      $.each([
        'min',
        'max',
        'step'
      ], function (i, option) {
        var value = element.attr(option);
        if (value !== undefined && value.length) {
          options[option] = value;
        }
      });
      return options;
    },
    _events: {
      keydown: function (event) {
        if (this._start(event) && this._keydown(event)) {
          event.preventDefault();
        }
      },
      keyup: '_stop',
      focus: function () {
        this.previous = this.element.val();
      },
      blur: function (event) {
        if (this.cancelBlur) {
          delete this.cancelBlur;
          return;
        }
        this._stop();
        this._refresh();
        if (this.previous !== this.element.val()) {
          this._trigger('change', event);
        }
      },
      mousewheel: function (event, delta) {
        if (!delta) {
          return;
        }
        if (!this.spinning && !this._start(event)) {
          return false;
        }
        this._spin((delta > 0 ? 1 : -1) * this.options.step, event);
        clearTimeout(this.mousewheelTimer);
        this.mousewheelTimer = this._delay(function () {
          if (this.spinning) {
            this._stop(event);
          }
        }, 100);
        event.preventDefault();
      },
      'mousedown .ui-spinner-button': function (event) {
        var previous;
        previous = this.element[0] === this.document[0].activeElement ? this.previous : this.element.val();
        function checkFocus() {
          var isActive = this.element[0] === this.document[0].activeElement;
          if (!isActive) {
            this.element.focus();
            this.previous = previous;
            this._delay(function () {
              this.previous = previous;
            });
          }
        }
        event.preventDefault();
        checkFocus.call(this);
        this.cancelBlur = true;
        this._delay(function () {
          delete this.cancelBlur;
          checkFocus.call(this);
        });
        if (this._start(event) === false) {
          return;
        }
        this._repeat(null, $(event.currentTarget).hasClass('ui-spinner-up') ? 1 : -1, event);
      },
      'mouseup .ui-spinner-button': '_stop',
      'mouseenter .ui-spinner-button': function (event) {
        if (!$(event.currentTarget).hasClass('ui-state-active')) {
          return;
        }
        if (this._start(event) === false) {
          return false;
        }
        this._repeat(null, $(event.currentTarget).hasClass('ui-spinner-up') ? 1 : -1, event);
      },
      'mouseleave .ui-spinner-button': '_stop'
    },
    _draw: function () {
      var uiSpinner = this.uiSpinner = this.element.addClass('ui-spinner-input').attr('autocomplete', 'off').wrap(this._uiSpinnerHtml()).parent().append(this._buttonHtml());
      this.element.attr('role', 'spinbutton');
      this.buttons = uiSpinner.find('.ui-spinner-button').attr('tabIndex', -1).button().removeClass('ui-corner-all');
      if (this.buttons.height() > Math.ceil(uiSpinner.height() * 0.5) && uiSpinner.height() > 0) {
        uiSpinner.height(uiSpinner.height());
      }
      if (this.options.disabled) {
        this.disable();
      }
    },
    _keydown: function (event) {
      var options = this.options, keyCode = $.ui.keyCode;
      switch (event.keyCode) {
      case keyCode.UP:
        this._repeat(null, 1, event);
        return true;
      case keyCode.DOWN:
        this._repeat(null, -1, event);
        return true;
      case keyCode.PAGE_UP:
        this._repeat(null, options.page, event);
        return true;
      case keyCode.PAGE_DOWN:
        this._repeat(null, -options.page, event);
        return true;
      }
      return false;
    },
    _uiSpinnerHtml: function () {
      return '<span class=\'ui-spinner ui-widget ui-widget-content ui-corner-all\'></span>';
    },
    _buttonHtml: function () {
      return '' + '<a class=\'ui-spinner-button ui-spinner-up ui-corner-tr\'>' + '<span class=\'ui-icon ' + this.options.icons.up + '\'>&#9650;</span>' + '</a>' + '<a class=\'ui-spinner-button ui-spinner-down ui-corner-br\'>' + '<span class=\'ui-icon ' + this.options.icons.down + '\'>&#9660;</span>' + '</a>';
    },
    _start: function (event) {
      if (!this.spinning && this._trigger('start', event) === false) {
        return false;
      }
      if (!this.counter) {
        this.counter = 1;
      }
      this.spinning = true;
      return true;
    },
    _repeat: function (i, steps, event) {
      i = i || 500;
      clearTimeout(this.timer);
      this.timer = this._delay(function () {
        this._repeat(40, steps, event);
      }, i);
      this._spin(steps * this.options.step, event);
    },
    _spin: function (step, event) {
      var value = this.value() || 0;
      if (!this.counter) {
        this.counter = 1;
      }
      value = this._adjustValue(value + step * this._increment(this.counter));
      if (!this.spinning || this._trigger('spin', event, { value: value }) !== false) {
        this._value(value);
        this.counter++;
      }
    },
    _increment: function (i) {
      var incremental = this.options.incremental;
      if (incremental) {
        return $.isFunction(incremental) ? incremental(i) : Math.floor(i * i * i / 50000 - i * i / 500 + 17 * i / 200 + 1);
      }
      return 1;
    },
    _precision: function () {
      var precision = this._precisionOf(this.options.step);
      if (this.options.min !== null) {
        precision = Math.max(precision, this._precisionOf(this.options.min));
      }
      return precision;
    },
    _precisionOf: function (num) {
      var str = num.toString(), decimal = str.indexOf('.');
      return decimal === -1 ? 0 : str.length - decimal - 1;
    },
    _adjustValue: function (value) {
      var base, aboveMin, options = this.options;
      base = options.min !== null ? options.min : 0;
      aboveMin = value - base;
      aboveMin = Math.round(aboveMin / options.step) * options.step;
      value = base + aboveMin;
      value = parseFloat(value.toFixed(this._precision()));
      if (options.max !== null && value > options.max) {
        return options.max;
      }
      if (options.min !== null && value < options.min) {
        return options.min;
      }
      return value;
    },
    _stop: function (event) {
      if (!this.spinning) {
        return;
      }
      clearTimeout(this.timer);
      clearTimeout(this.mousewheelTimer);
      this.counter = 0;
      this.spinning = false;
      this._trigger('stop', event);
    },
    _setOption: function (key, value) {
      if (key === 'culture' || key === 'numberFormat') {
        var prevValue = this._parse(this.element.val());
        this.options[key] = value;
        this.element.val(this._format(prevValue));
        return;
      }
      if (key === 'max' || key === 'min' || key === 'step') {
        if (typeof value === 'string') {
          value = this._parse(value);
        }
      }
      if (key === 'icons') {
        this.buttons.first().find('.ui-icon').removeClass(this.options.icons.up).addClass(value.up);
        this.buttons.last().find('.ui-icon').removeClass(this.options.icons.down).addClass(value.down);
      }
      this._super(key, value);
      if (key === 'disabled') {
        if (value) {
          this.element.prop('disabled', true);
          this.buttons.button('disable');
        } else {
          this.element.prop('disabled', false);
          this.buttons.button('enable');
        }
      }
    },
    _setOptions: modifier(function (options) {
      this._super(options);
      this._value(this.element.val());
    }),
    _parse: function (val) {
      if (typeof val === 'string' && val !== '') {
        val = window.Globalize && this.options.numberFormat ? Globalize.parseFloat(val, 10, this.options.culture) : +val;
      }
      return val === '' || isNaN(val) ? null : val;
    },
    _format: function (value) {
      if (value === '') {
        return '';
      }
      return window.Globalize && this.options.numberFormat ? Globalize.format(value, this.options.numberFormat, this.options.culture) : value;
    },
    _refresh: function () {
      this.element.attr({
        'aria-valuemin': this.options.min,
        'aria-valuemax': this.options.max,
        'aria-valuenow': this._parse(this.element.val())
      });
    },
    _value: function (value, allowAny) {
      var parsed;
      if (value !== '') {
        parsed = this._parse(value);
        if (parsed !== null) {
          if (!allowAny) {
            parsed = this._adjustValue(parsed);
          }
          value = this._format(parsed);
        }
      }
      this.element.val(value);
      this._refresh();
    },
    _destroy: function () {
      this.element.removeClass('ui-spinner-input').prop('disabled', false).removeAttr('autocomplete').removeAttr('role').removeAttr('aria-valuemin').removeAttr('aria-valuemax').removeAttr('aria-valuenow');
      this.uiSpinner.replaceWith(this.element);
    },
    stepUp: modifier(function (steps) {
      this._stepUp(steps);
    }),
    _stepUp: function (steps) {
      if (this._start()) {
        this._spin((steps || 1) * this.options.step);
        this._stop();
      }
    },
    stepDown: modifier(function (steps) {
      this._stepDown(steps);
    }),
    _stepDown: function (steps) {
      if (this._start()) {
        this._spin((steps || 1) * -this.options.step);
        this._stop();
      }
    },
    pageUp: modifier(function (pages) {
      this._stepUp((pages || 1) * this.options.page);
    }),
    pageDown: modifier(function (pages) {
      this._stepDown((pages || 1) * this.options.page);
    }),
    value: function (newVal) {
      if (!arguments.length) {
        return this._parse(this.element.val());
      }
      modifier(this._value).call(this, newVal);
    },
    widget: function () {
      return this.uiSpinner;
    }
  });
}(jQuery));
(function ($, undefined) {
  var tabId = 0, rhash = /#.*$/;
  function getNextTabId() {
    return ++tabId;
  }
  function isLocal(anchor) {
    anchor = anchor.cloneNode(false);
    return anchor.hash.length > 1 && decodeURIComponent(anchor.href.replace(rhash, '')) === decodeURIComponent(location.href.replace(rhash, ''));
  }
  $.widget('ui.tabs', {
    version: '1.10.4',
    delay: 300,
    options: {
      active: null,
      collapsible: false,
      event: 'click',
      heightStyle: 'content',
      hide: null,
      show: null,
      activate: null,
      beforeActivate: null,
      beforeLoad: null,
      load: null
    },
    _create: function () {
      var that = this, options = this.options;
      this.running = false;
      this.element.addClass('ui-tabs ui-widget ui-widget-content ui-corner-all').toggleClass('ui-tabs-collapsible', options.collapsible).delegate('.ui-tabs-nav > li', 'mousedown' + this.eventNamespace, function (event) {
        if ($(this).is('.ui-state-disabled')) {
          event.preventDefault();
        }
      }).delegate('.ui-tabs-anchor', 'focus' + this.eventNamespace, function () {
        if ($(this).closest('li').is('.ui-state-disabled')) {
          this.blur();
        }
      });
      this._processTabs();
      options.active = this._initialActive();
      if ($.isArray(options.disabled)) {
        options.disabled = $.unique(options.disabled.concat($.map(this.tabs.filter('.ui-state-disabled'), function (li) {
          return that.tabs.index(li);
        }))).sort();
      }
      if (this.options.active !== false && this.anchors.length) {
        this.active = this._findActive(options.active);
      } else {
        this.active = $();
      }
      this._refresh();
      if (this.active.length) {
        this.load(options.active);
      }
    },
    _initialActive: function () {
      var active = this.options.active, collapsible = this.options.collapsible, locationHash = location.hash.substring(1);
      if (active === null) {
        if (locationHash) {
          this.tabs.each(function (i, tab) {
            if ($(tab).attr('aria-controls') === locationHash) {
              active = i;
              return false;
            }
          });
        }
        if (active === null) {
          active = this.tabs.index(this.tabs.filter('.ui-tabs-active'));
        }
        if (active === null || active === -1) {
          active = this.tabs.length ? 0 : false;
        }
      }
      if (active !== false) {
        active = this.tabs.index(this.tabs.eq(active));
        if (active === -1) {
          active = collapsible ? false : 0;
        }
      }
      if (!collapsible && active === false && this.anchors.length) {
        active = 0;
      }
      return active;
    },
    _getCreateEventData: function () {
      return {
        tab: this.active,
        panel: !this.active.length ? $() : this._getPanelForTab(this.active)
      };
    },
    _tabKeydown: function (event) {
      var focusedTab = $(this.document[0].activeElement).closest('li'), selectedIndex = this.tabs.index(focusedTab), goingForward = true;
      if (this._handlePageNav(event)) {
        return;
      }
      switch (event.keyCode) {
      case $.ui.keyCode.RIGHT:
      case $.ui.keyCode.DOWN:
        selectedIndex++;
        break;
      case $.ui.keyCode.UP:
      case $.ui.keyCode.LEFT:
        goingForward = false;
        selectedIndex--;
        break;
      case $.ui.keyCode.END:
        selectedIndex = this.anchors.length - 1;
        break;
      case $.ui.keyCode.HOME:
        selectedIndex = 0;
        break;
      case $.ui.keyCode.SPACE:
        event.preventDefault();
        clearTimeout(this.activating);
        this._activate(selectedIndex);
        return;
      case $.ui.keyCode.ENTER:
        event.preventDefault();
        clearTimeout(this.activating);
        this._activate(selectedIndex === this.options.active ? false : selectedIndex);
        return;
      default:
        return;
      }
      event.preventDefault();
      clearTimeout(this.activating);
      selectedIndex = this._focusNextTab(selectedIndex, goingForward);
      if (!event.ctrlKey) {
        focusedTab.attr('aria-selected', 'false');
        this.tabs.eq(selectedIndex).attr('aria-selected', 'true');
        this.activating = this._delay(function () {
          this.option('active', selectedIndex);
        }, this.delay);
      }
    },
    _panelKeydown: function (event) {
      if (this._handlePageNav(event)) {
        return;
      }
      if (event.ctrlKey && event.keyCode === $.ui.keyCode.UP) {
        event.preventDefault();
        this.active.focus();
      }
    },
    _handlePageNav: function (event) {
      if (event.altKey && event.keyCode === $.ui.keyCode.PAGE_UP) {
        this._activate(this._focusNextTab(this.options.active - 1, false));
        return true;
      }
      if (event.altKey && event.keyCode === $.ui.keyCode.PAGE_DOWN) {
        this._activate(this._focusNextTab(this.options.active + 1, true));
        return true;
      }
    },
    _findNextTab: function (index, goingForward) {
      var lastTabIndex = this.tabs.length - 1;
      function constrain() {
        if (index > lastTabIndex) {
          index = 0;
        }
        if (index < 0) {
          index = lastTabIndex;
        }
        return index;
      }
      while ($.inArray(constrain(), this.options.disabled) !== -1) {
        index = goingForward ? index + 1 : index - 1;
      }
      return index;
    },
    _focusNextTab: function (index, goingForward) {
      index = this._findNextTab(index, goingForward);
      this.tabs.eq(index).focus();
      return index;
    },
    _setOption: function (key, value) {
      if (key === 'active') {
        this._activate(value);
        return;
      }
      if (key === 'disabled') {
        this._setupDisabled(value);
        return;
      }
      this._super(key, value);
      if (key === 'collapsible') {
        this.element.toggleClass('ui-tabs-collapsible', value);
        if (!value && this.options.active === false) {
          this._activate(0);
        }
      }
      if (key === 'event') {
        this._setupEvents(value);
      }
      if (key === 'heightStyle') {
        this._setupHeightStyle(value);
      }
    },
    _tabId: function (tab) {
      return tab.attr('aria-controls') || 'ui-tabs-' + getNextTabId();
    },
    _sanitizeSelector: function (hash) {
      return hash ? hash.replace(/[!"$%&'()*+,.\/:;<=>?@\[\]\^`{|}~]/g, '\\$&') : '';
    },
    refresh: function () {
      var options = this.options, lis = this.tablist.children(':has(a[href])');
      options.disabled = $.map(lis.filter('.ui-state-disabled'), function (tab) {
        return lis.index(tab);
      });
      this._processTabs();
      if (options.active === false || !this.anchors.length) {
        options.active = false;
        this.active = $();
      } else if (this.active.length && !$.contains(this.tablist[0], this.active[0])) {
        if (this.tabs.length === options.disabled.length) {
          options.active = false;
          this.active = $();
        } else {
          this._activate(this._findNextTab(Math.max(0, options.active - 1), false));
        }
      } else {
        options.active = this.tabs.index(this.active);
      }
      this._refresh();
    },
    _refresh: function () {
      this._setupDisabled(this.options.disabled);
      this._setupEvents(this.options.event);
      this._setupHeightStyle(this.options.heightStyle);
      this.tabs.not(this.active).attr({
        'aria-selected': 'false',
        tabIndex: -1
      });
      this.panels.not(this._getPanelForTab(this.active)).hide().attr({
        'aria-expanded': 'false',
        'aria-hidden': 'true'
      });
      if (!this.active.length) {
        this.tabs.eq(0).attr('tabIndex', 0);
      } else {
        this.active.addClass('ui-tabs-active ui-state-active').attr({
          'aria-selected': 'true',
          tabIndex: 0
        });
        this._getPanelForTab(this.active).show().attr({
          'aria-expanded': 'true',
          'aria-hidden': 'false'
        });
      }
    },
    _processTabs: function () {
      var that = this;
      this.tablist = this._getList().addClass('ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all').attr('role', 'tablist');
      this.tabs = this.tablist.find('> li:has(a[href])').addClass('ui-state-default ui-corner-top').attr({
        role: 'tab',
        tabIndex: -1
      });
      this.anchors = this.tabs.map(function () {
        return $('a', this)[0];
      }).addClass('ui-tabs-anchor').attr({
        role: 'presentation',
        tabIndex: -1
      });
      this.panels = $();
      this.anchors.each(function (i, anchor) {
        var selector, panel, panelId, anchorId = $(anchor).uniqueId().attr('id'), tab = $(anchor).closest('li'), originalAriaControls = tab.attr('aria-controls');
        if (isLocal(anchor)) {
          selector = anchor.hash;
          panel = that.element.find(that._sanitizeSelector(selector));
        } else {
          panelId = that._tabId(tab);
          selector = '#' + panelId;
          panel = that.element.find(selector);
          if (!panel.length) {
            panel = that._createPanel(panelId);
            panel.insertAfter(that.panels[i - 1] || that.tablist);
          }
          panel.attr('aria-live', 'polite');
        }
        if (panel.length) {
          that.panels = that.panels.add(panel);
        }
        if (originalAriaControls) {
          tab.data('ui-tabs-aria-controls', originalAriaControls);
        }
        tab.attr({
          'aria-controls': selector.substring(1),
          'aria-labelledby': anchorId
        });
        panel.attr('aria-labelledby', anchorId);
      });
      this.panels.addClass('ui-tabs-panel ui-widget-content ui-corner-bottom').attr('role', 'tabpanel');
    },
    _getList: function () {
      return this.tablist || this.element.find('ol,ul').eq(0);
    },
    _createPanel: function (id) {
      return $('<div>').attr('id', id).addClass('ui-tabs-panel ui-widget-content ui-corner-bottom').data('ui-tabs-destroy', true);
    },
    _setupDisabled: function (disabled) {
      if ($.isArray(disabled)) {
        if (!disabled.length) {
          disabled = false;
        } else if (disabled.length === this.anchors.length) {
          disabled = true;
        }
      }
      for (var i = 0, li; li = this.tabs[i]; i++) {
        if (disabled === true || $.inArray(i, disabled) !== -1) {
          $(li).addClass('ui-state-disabled').attr('aria-disabled', 'true');
        } else {
          $(li).removeClass('ui-state-disabled').removeAttr('aria-disabled');
        }
      }
      this.options.disabled = disabled;
    },
    _setupEvents: function (event) {
      var events = {
          click: function (event) {
            event.preventDefault();
          }
        };
      if (event) {
        $.each(event.split(' '), function (index, eventName) {
          events[eventName] = '_eventHandler';
        });
      }
      this._off(this.anchors.add(this.tabs).add(this.panels));
      this._on(this.anchors, events);
      this._on(this.tabs, { keydown: '_tabKeydown' });
      this._on(this.panels, { keydown: '_panelKeydown' });
      this._focusable(this.tabs);
      this._hoverable(this.tabs);
    },
    _setupHeightStyle: function (heightStyle) {
      var maxHeight, parent = this.element.parent();
      if (heightStyle === 'fill') {
        maxHeight = parent.height();
        maxHeight -= this.element.outerHeight() - this.element.height();
        this.element.siblings(':visible').each(function () {
          var elem = $(this), position = elem.css('position');
          if (position === 'absolute' || position === 'fixed') {
            return;
          }
          maxHeight -= elem.outerHeight(true);
        });
        this.element.children().not(this.panels).each(function () {
          maxHeight -= $(this).outerHeight(true);
        });
        this.panels.each(function () {
          $(this).height(Math.max(0, maxHeight - $(this).innerHeight() + $(this).height()));
        }).css('overflow', 'auto');
      } else if (heightStyle === 'auto') {
        maxHeight = 0;
        this.panels.each(function () {
          maxHeight = Math.max(maxHeight, $(this).height('').height());
        }).height(maxHeight);
      }
    },
    _eventHandler: function (event) {
      var options = this.options, active = this.active, anchor = $(event.currentTarget), tab = anchor.closest('li'), clickedIsActive = tab[0] === active[0], collapsing = clickedIsActive && options.collapsible, toShow = collapsing ? $() : this._getPanelForTab(tab), toHide = !active.length ? $() : this._getPanelForTab(active), eventData = {
          oldTab: active,
          oldPanel: toHide,
          newTab: collapsing ? $() : tab,
          newPanel: toShow
        };
      event.preventDefault();
      if (tab.hasClass('ui-state-disabled') || tab.hasClass('ui-tabs-loading') || this.running || clickedIsActive && !options.collapsible || this._trigger('beforeActivate', event, eventData) === false) {
        return;
      }
      options.active = collapsing ? false : this.tabs.index(tab);
      this.active = clickedIsActive ? $() : tab;
      if (this.xhr) {
        this.xhr.abort();
      }
      if (!toHide.length && !toShow.length) {
        $.error('jQuery UI Tabs: Mismatching fragment identifier.');
      }
      if (toShow.length) {
        this.load(this.tabs.index(tab), event);
      }
      this._toggle(event, eventData);
    },
    _toggle: function (event, eventData) {
      var that = this, toShow = eventData.newPanel, toHide = eventData.oldPanel;
      this.running = true;
      function complete() {
        that.running = false;
        that._trigger('activate', event, eventData);
      }
      function show() {
        eventData.newTab.closest('li').addClass('ui-tabs-active ui-state-active');
        if (toShow.length && that.options.show) {
          that._show(toShow, that.options.show, complete);
        } else {
          toShow.show();
          complete();
        }
      }
      if (toHide.length && this.options.hide) {
        this._hide(toHide, this.options.hide, function () {
          eventData.oldTab.closest('li').removeClass('ui-tabs-active ui-state-active');
          show();
        });
      } else {
        eventData.oldTab.closest('li').removeClass('ui-tabs-active ui-state-active');
        toHide.hide();
        show();
      }
      toHide.attr({
        'aria-expanded': 'false',
        'aria-hidden': 'true'
      });
      eventData.oldTab.attr('aria-selected', 'false');
      if (toShow.length && toHide.length) {
        eventData.oldTab.attr('tabIndex', -1);
      } else if (toShow.length) {
        this.tabs.filter(function () {
          return $(this).attr('tabIndex') === 0;
        }).attr('tabIndex', -1);
      }
      toShow.attr({
        'aria-expanded': 'true',
        'aria-hidden': 'false'
      });
      eventData.newTab.attr({
        'aria-selected': 'true',
        tabIndex: 0
      });
    },
    _activate: function (index) {
      var anchor, active = this._findActive(index);
      if (active[0] === this.active[0]) {
        return;
      }
      if (!active.length) {
        active = this.active;
      }
      anchor = active.find('.ui-tabs-anchor')[0];
      this._eventHandler({
        target: anchor,
        currentTarget: anchor,
        preventDefault: $.noop
      });
    },
    _findActive: function (index) {
      return index === false ? $() : this.tabs.eq(index);
    },
    _getIndex: function (index) {
      if (typeof index === 'string') {
        index = this.anchors.index(this.anchors.filter('[href$=\'' + index + '\']'));
      }
      return index;
    },
    _destroy: function () {
      if (this.xhr) {
        this.xhr.abort();
      }
      this.element.removeClass('ui-tabs ui-widget ui-widget-content ui-corner-all ui-tabs-collapsible');
      this.tablist.removeClass('ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all').removeAttr('role');
      this.anchors.removeClass('ui-tabs-anchor').removeAttr('role').removeAttr('tabIndex').removeUniqueId();
      this.tabs.add(this.panels).each(function () {
        if ($.data(this, 'ui-tabs-destroy')) {
          $(this).remove();
        } else {
          $(this).removeClass('ui-state-default ui-state-active ui-state-disabled ' + 'ui-corner-top ui-corner-bottom ui-widget-content ui-tabs-active ui-tabs-panel').removeAttr('tabIndex').removeAttr('aria-live').removeAttr('aria-busy').removeAttr('aria-selected').removeAttr('aria-labelledby').removeAttr('aria-hidden').removeAttr('aria-expanded').removeAttr('role');
        }
      });
      this.tabs.each(function () {
        var li = $(this), prev = li.data('ui-tabs-aria-controls');
        if (prev) {
          li.attr('aria-controls', prev).removeData('ui-tabs-aria-controls');
        } else {
          li.removeAttr('aria-controls');
        }
      });
      this.panels.show();
      if (this.options.heightStyle !== 'content') {
        this.panels.css('height', '');
      }
    },
    enable: function (index) {
      var disabled = this.options.disabled;
      if (disabled === false) {
        return;
      }
      if (index === undefined) {
        disabled = false;
      } else {
        index = this._getIndex(index);
        if ($.isArray(disabled)) {
          disabled = $.map(disabled, function (num) {
            return num !== index ? num : null;
          });
        } else {
          disabled = $.map(this.tabs, function (li, num) {
            return num !== index ? num : null;
          });
        }
      }
      this._setupDisabled(disabled);
    },
    disable: function (index) {
      var disabled = this.options.disabled;
      if (disabled === true) {
        return;
      }
      if (index === undefined) {
        disabled = true;
      } else {
        index = this._getIndex(index);
        if ($.inArray(index, disabled) !== -1) {
          return;
        }
        if ($.isArray(disabled)) {
          disabled = $.merge([index], disabled).sort();
        } else {
          disabled = [index];
        }
      }
      this._setupDisabled(disabled);
    },
    load: function (index, event) {
      index = this._getIndex(index);
      var that = this, tab = this.tabs.eq(index), anchor = tab.find('.ui-tabs-anchor'), panel = this._getPanelForTab(tab), eventData = {
          tab: tab,
          panel: panel
        };
      if (isLocal(anchor[0])) {
        return;
      }
      this.xhr = $.ajax(this._ajaxSettings(anchor, event, eventData));
      if (this.xhr && this.xhr.statusText !== 'canceled') {
        tab.addClass('ui-tabs-loading');
        panel.attr('aria-busy', 'true');
        this.xhr.success(function (response) {
          setTimeout(function () {
            panel.html(response);
            that._trigger('load', event, eventData);
          }, 1);
        }).complete(function (jqXHR, status) {
          setTimeout(function () {
            if (status === 'abort') {
              that.panels.stop(false, true);
            }
            tab.removeClass('ui-tabs-loading');
            panel.removeAttr('aria-busy');
            if (jqXHR === that.xhr) {
              delete that.xhr;
            }
          }, 1);
        });
      }
    },
    _ajaxSettings: function (anchor, event, eventData) {
      var that = this;
      return {
        url: anchor.attr('href'),
        beforeSend: function (jqXHR, settings) {
          return that._trigger('beforeLoad', event, $.extend({
            jqXHR: jqXHR,
            ajaxSettings: settings
          }, eventData));
        }
      };
    },
    _getPanelForTab: function (tab) {
      var id = $(tab).attr('aria-controls');
      return this.element.find(this._sanitizeSelector('#' + id));
    }
  });
}(jQuery));
(function ($) {
  var increments = 0;
  function addDescribedBy(elem, id) {
    var describedby = (elem.attr('aria-describedby') || '').split(/\s+/);
    describedby.push(id);
    elem.data('ui-tooltip-id', id).attr('aria-describedby', $.trim(describedby.join(' ')));
  }
  function removeDescribedBy(elem) {
    var id = elem.data('ui-tooltip-id'), describedby = (elem.attr('aria-describedby') || '').split(/\s+/), index = $.inArray(id, describedby);
    if (index !== -1) {
      describedby.splice(index, 1);
    }
    elem.removeData('ui-tooltip-id');
    describedby = $.trim(describedby.join(' '));
    if (describedby) {
      elem.attr('aria-describedby', describedby);
    } else {
      elem.removeAttr('aria-describedby');
    }
  }
  $.widget('ui.tooltip', {
    version: '1.10.4',
    options: {
      content: function () {
        var title = $(this).attr('title') || '';
        return $('<a>').text(title).html();
      },
      hide: true,
      items: '[title]:not([disabled])',
      position: {
        my: 'left top+15',
        at: 'left bottom',
        collision: 'flipfit flip'
      },
      show: true,
      tooltipClass: null,
      track: false,
      close: null,
      open: null
    },
    _create: function () {
      this._on({
        mouseover: 'open',
        focusin: 'open'
      });
      this.tooltips = {};
      this.parents = {};
      if (this.options.disabled) {
        this._disable();
      }
    },
    _setOption: function (key, value) {
      var that = this;
      if (key === 'disabled') {
        this[value ? '_disable' : '_enable']();
        this.options[key] = value;
        return;
      }
      this._super(key, value);
      if (key === 'content') {
        $.each(this.tooltips, function (id, element) {
          that._updateContent(element);
        });
      }
    },
    _disable: function () {
      var that = this;
      $.each(this.tooltips, function (id, element) {
        var event = $.Event('blur');
        event.target = event.currentTarget = element[0];
        that.close(event, true);
      });
      this.element.find(this.options.items).addBack().each(function () {
        var element = $(this);
        if (element.is('[title]')) {
          element.data('ui-tooltip-title', element.attr('title')).attr('title', '');
        }
      });
    },
    _enable: function () {
      this.element.find(this.options.items).addBack().each(function () {
        var element = $(this);
        if (element.data('ui-tooltip-title')) {
          element.attr('title', element.data('ui-tooltip-title'));
        }
      });
    },
    open: function (event) {
      var that = this, target = $(event ? event.target : this.element).closest(this.options.items);
      if (!target.length || target.data('ui-tooltip-id')) {
        return;
      }
      if (target.attr('title')) {
        target.data('ui-tooltip-title', target.attr('title'));
      }
      target.data('ui-tooltip-open', true);
      if (event && event.type === 'mouseover') {
        target.parents().each(function () {
          var parent = $(this), blurEvent;
          if (parent.data('ui-tooltip-open')) {
            blurEvent = $.Event('blur');
            blurEvent.target = blurEvent.currentTarget = this;
            that.close(blurEvent, true);
          }
          if (parent.attr('title')) {
            parent.uniqueId();
            that.parents[this.id] = {
              element: this,
              title: parent.attr('title')
            };
            parent.attr('title', '');
          }
        });
      }
      this._updateContent(target, event);
    },
    _updateContent: function (target, event) {
      var content, contentOption = this.options.content, that = this, eventType = event ? event.type : null;
      if (typeof contentOption === 'string') {
        return this._open(event, target, contentOption);
      }
      content = contentOption.call(target[0], function (response) {
        if (!target.data('ui-tooltip-open')) {
          return;
        }
        that._delay(function () {
          if (event) {
            event.type = eventType;
          }
          this._open(event, target, response);
        });
      });
      if (content) {
        this._open(event, target, content);
      }
    },
    _open: function (event, target, content) {
      var tooltip, events, delayedShow, positionOption = $.extend({}, this.options.position);
      if (!content) {
        return;
      }
      tooltip = this._find(target);
      if (tooltip.length) {
        tooltip.find('.ui-tooltip-content').html(content);
        return;
      }
      if (target.is('[title]')) {
        if (event && event.type === 'mouseover') {
          target.attr('title', '');
        } else {
          target.removeAttr('title');
        }
      }
      tooltip = this._tooltip(target);
      addDescribedBy(target, tooltip.attr('id'));
      tooltip.find('.ui-tooltip-content').html(content);
      function position(event) {
        positionOption.of = event;
        if (tooltip.is(':hidden')) {
          return;
        }
        tooltip.position(positionOption);
      }
      if (this.options.track && event && /^mouse/.test(event.type)) {
        this._on(this.document, { mousemove: position });
        position(event);
      } else {
        tooltip.position($.extend({ of: target }, this.options.position));
      }
      tooltip.hide();
      this._show(tooltip, this.options.show);
      if (this.options.show && this.options.show.delay) {
        delayedShow = this.delayedShow = setInterval(function () {
          if (tooltip.is(':visible')) {
            position(positionOption.of);
            clearInterval(delayedShow);
          }
        }, $.fx.interval);
      }
      this._trigger('open', event, { tooltip: tooltip });
      events = {
        keyup: function (event) {
          if (event.keyCode === $.ui.keyCode.ESCAPE) {
            var fakeEvent = $.Event(event);
            fakeEvent.currentTarget = target[0];
            this.close(fakeEvent, true);
          }
        },
        remove: function () {
          this._removeTooltip(tooltip);
        }
      };
      if (!event || event.type === 'mouseover') {
        events.mouseleave = 'close';
      }
      if (!event || event.type === 'focusin') {
        events.focusout = 'close';
      }
      this._on(true, target, events);
    },
    close: function (event) {
      var that = this, target = $(event ? event.currentTarget : this.element), tooltip = this._find(target);
      if (this.closing) {
        return;
      }
      clearInterval(this.delayedShow);
      if (target.data('ui-tooltip-title')) {
        target.attr('title', target.data('ui-tooltip-title'));
      }
      removeDescribedBy(target);
      tooltip.stop(true);
      this._hide(tooltip, this.options.hide, function () {
        that._removeTooltip($(this));
      });
      target.removeData('ui-tooltip-open');
      this._off(target, 'mouseleave focusout keyup');
      if (target[0] !== this.element[0]) {
        this._off(target, 'remove');
      }
      this._off(this.document, 'mousemove');
      if (event && event.type === 'mouseleave') {
        $.each(this.parents, function (id, parent) {
          $(parent.element).attr('title', parent.title);
          delete that.parents[id];
        });
      }
      this.closing = true;
      this._trigger('close', event, { tooltip: tooltip });
      this.closing = false;
    },
    _tooltip: function (element) {
      var id = 'ui-tooltip-' + increments++, tooltip = $('<div>').attr({
          id: id,
          role: 'tooltip'
        }).addClass('ui-tooltip ui-widget ui-corner-all ui-widget-content ' + (this.options.tooltipClass || ''));
      $('<div>').addClass('ui-tooltip-content').appendTo(tooltip);
      tooltip.appendTo(this.document[0].body);
      this.tooltips[id] = element;
      return tooltip;
    },
    _find: function (target) {
      var id = target.data('ui-tooltip-id');
      return id ? $('#' + id) : $();
    },
    _removeTooltip: function (tooltip) {
      tooltip.remove();
      delete this.tooltips[tooltip.attr('id')];
    },
    _destroy: function () {
      var that = this;
      $.each(this.tooltips, function (id, element) {
        var event = $.Event('blur');
        event.target = event.currentTarget = element[0];
        that.close(event, true);
        $('#' + id).remove();
        if (element.data('ui-tooltip-title')) {
          element.attr('title', element.data('ui-tooltip-title'));
          element.removeData('ui-tooltip-title');
        }
      });
    }
  });
}(jQuery));
;
(function ($) {
  var min = Math.min, max = Math.max, round = Math.floor, isStr = function (v) {
      return $.type(v) === 'string';
    }, runPluginCallbacks = function (Instance, a_fn) {
      if ($.isArray(a_fn))
        for (var i = 0, c = a_fn.length; i < c; i++) {
          var fn = a_fn[i];
          try {
            if (isStr(fn))
              fn = eval(fn);
            if ($.isFunction(fn))
              g(fn)(Instance);
          } catch (ex) {
          }
        }
      function g(f) {
        return f;
      }
      ;
    };
  ;
  $.layout = {
    version: '1.3.rc30.79',
    revision: 0.033007,
    browser: {},
    effects: {
      slide: {
        all: { duration: 'fast' },
        north: { direction: 'up' },
        south: { direction: 'down' },
        east: { direction: 'right' },
        west: { direction: 'left' }
      },
      drop: {
        all: { duration: 'slow' },
        north: { direction: 'up' },
        south: { direction: 'down' },
        east: { direction: 'right' },
        west: { direction: 'left' }
      },
      scale: { all: { duration: 'fast' } },
      blind: {},
      clip: {},
      explode: {},
      fade: {},
      fold: {},
      puff: {},
      size: { all: { easing: 'swing' } }
    },
    config: {
      optionRootKeys: 'effects,panes,north,south,west,east,center'.split(','),
      allPanes: 'north,south,west,east,center'.split(','),
      borderPanes: 'north,south,west,east'.split(','),
      oppositeEdge: {
        north: 'south',
        south: 'north',
        east: 'west',
        west: 'east'
      },
      offscreenCSS: {
        left: '-99999px',
        right: 'auto'
      },
      offscreenReset: 'offscreenReset',
      hidden: { visibility: 'hidden' },
      visible: { visibility: 'visible' },
      resizers: {
        cssReq: {
          position: 'absolute',
          padding: 0,
          margin: 0,
          fontSize: '1px',
          textAlign: 'left',
          overflow: 'hidden'
        },
        cssDemo: {
          background: '#DDD',
          border: 'none'
        }
      },
      togglers: {
        cssReq: {
          position: 'absolute',
          display: 'block',
          padding: 0,
          margin: 0,
          overflow: 'hidden',
          textAlign: 'center',
          fontSize: '1px',
          cursor: 'pointer',
          zIndex: 1
        },
        cssDemo: { background: '#AAA' }
      },
      content: {
        cssReq: { position: 'relative' },
        cssDemo: {
          overflow: 'auto',
          padding: '10px'
        },
        cssDemoPane: {
          overflow: 'hidden',
          padding: 0
        }
      },
      panes: {
        cssReq: {
          position: 'absolute',
          margin: 0
        },
        cssDemo: {
          padding: '10px',
          background: '#FFF',
          border: '1px solid #BBB',
          overflow: 'auto'
        }
      },
      north: {
        side: 'top',
        sizeType: 'Height',
        dir: 'horz',
        cssReq: {
          top: 0,
          bottom: 'auto',
          left: 0,
          right: 0,
          width: 'auto'
        }
      },
      south: {
        side: 'bottom',
        sizeType: 'Height',
        dir: 'horz',
        cssReq: {
          top: 'auto',
          bottom: 0,
          left: 0,
          right: 0,
          width: 'auto'
        }
      },
      east: {
        side: 'right',
        sizeType: 'Width',
        dir: 'vert',
        cssReq: {
          left: 'auto',
          right: 0,
          top: 'auto',
          bottom: 'auto',
          height: 'auto'
        }
      },
      west: {
        side: 'left',
        sizeType: 'Width',
        dir: 'vert',
        cssReq: {
          left: 0,
          right: 'auto',
          top: 'auto',
          bottom: 'auto',
          height: 'auto'
        }
      },
      center: {
        dir: 'center',
        cssReq: {
          left: 'auto',
          right: 'auto',
          top: 'auto',
          bottom: 'auto',
          height: 'auto',
          width: 'auto'
        }
      }
    },
    callbacks: {},
    getParentPaneElem: function (el) {
      var $el = $(el), layout = $el.data('layout') || $el.data('parentLayout');
      if (layout) {
        var $cont = layout.container;
        if ($cont.data('layoutPane'))
          return $cont;
        var $pane = $cont.closest('.' + $.layout.defaults.panes.paneClass);
        if ($pane.data('layoutPane'))
          return $pane;
      }
      return null;
    },
    getParentPaneInstance: function (el) {
      var $pane = $.layout.getParentPaneElem(el);
      return $pane ? $pane.data('layoutPane') : null;
    },
    getParentLayoutInstance: function (el) {
      var $pane = $.layout.getParentPaneElem(el);
      return $pane ? $pane.data('parentLayout') : null;
    },
    getEventObject: function (evt) {
      return typeof evt === 'object' && evt.stopPropagation ? evt : null;
    },
    parsePaneName: function (evt_or_pane) {
      var evt = $.layout.getEventObject(evt_or_pane), pane = evt_or_pane;
      if (evt) {
        evt.stopPropagation();
        pane = $(this).data('layoutEdge');
      }
      if (pane && !/^(west|east|north|south|center)$/.test(pane)) {
        $.layout.msg('LAYOUT ERROR - Invalid pane-name: "' + pane + '"');
        pane = 'error';
      }
      return pane;
    },
    plugins: {
      draggable: !!$.fn.draggable,
      effects: {
        core: !!$.effects,
        slide: $.effects && ($.effects.slide || $.effects.effect && $.effects.effect.slide)
      }
    },
    onCreate: [],
    onLoad: [],
    onReady: [],
    onDestroy: [],
    onUnload: [],
    afterOpen: [],
    afterClose: [],
    scrollbarWidth: function () {
      return window.scrollbarWidth || $.layout.getScrollbarSize('width');
    },
    scrollbarHeight: function () {
      return window.scrollbarHeight || $.layout.getScrollbarSize('height');
    },
    getScrollbarSize: function (dim) {
      var $c = $('<div style="position: absolute; top: -10000px; left: -10000px; width: 100px; height: 100px; overflow: scroll;"></div>').appendTo('body');
      var d = {
          width: $c.css('width') - $c[0].clientWidth,
          height: $c.height() - $c[0].clientHeight
        };
      $c.remove();
      window.scrollbarWidth = d.width;
      window.scrollbarHeight = d.height;
      return dim.match(/^(width|height)$/) ? d[dim] : d;
    },
    showInvisibly: function ($E, force) {
      if ($E && $E.length && (force || $E.css('display') === 'none')) {
        var s = $E[0].style, CSS = {
            display: s.display || '',
            visibility: s.visibility || ''
          };
        $E.css({
          display: 'block',
          visibility: 'hidden'
        });
        return CSS;
      }
      return {};
    },
    getElementDimensions: function ($E, inset) {
      var d = {
          css: {},
          inset: {}
        }, x = d.css, i = { bottom: 0 }, N = $.layout.cssNum, off = $E.offset(), b, p, ei;
      ;
      d.offsetLeft = off.left;
      d.offsetTop = off.top;
      if (!inset)
        inset = {};
      $.each('Left,Right,Top,Bottom'.split(','), function (idx, e) {
        b = x['border' + e] = $.layout.borderWidth($E, e);
        p = x['padding' + e] = $.layout.cssNum($E, 'padding' + e);
        ei = e.toLowerCase();
        d.inset[ei] = inset[ei] >= 0 ? inset[ei] : p;
        i[ei] = d.inset[ei] + b;
      });
      x.width = $E.width();
      x.height = $E.height();
      x.top = N($E, 'top', true);
      x.bottom = N($E, 'bottom', true);
      x.left = N($E, 'left', true);
      x.right = N($E, 'right', true);
      d.outerWidth = $E.outerWidth();
      d.outerHeight = $E.outerHeight();
      d.innerWidth = max(0, d.outerWidth - i.left - i.right);
      d.innerHeight = max(0, d.outerHeight - i.top - i.bottom);
      d.layoutWidth = $E.innerWidth();
      d.layoutHeight = $E.innerHeight();
      return d;
    },
    getElementStyles: function ($E, list) {
      var CSS = {}, style = $E[0].style, props = list.split(','), sides = 'Top,Bottom,Left,Right'.split(','), attrs = 'Color,Style,Width'.split(','), p, s, a, i, j, k;
      ;
      for (i = 0; i < props.length; i++) {
        p = props[i];
        if (p.match(/(border|padding|margin)$/))
          for (j = 0; j < 4; j++) {
            s = sides[j];
            if (p === 'border')
              for (k = 0; k < 3; k++) {
                a = attrs[k];
                CSS[p + s + a] = style[p + s + a];
              }
            else
              CSS[p + s] = style[p + s];
          }
        else
          CSS[p] = style[p];
      }
      ;
      return CSS;
    },
    cssWidth: function ($E, outerWidth) {
      if (outerWidth <= 0)
        return 0;
      var bs = !$.layout.browser.boxModel ? 'border-box' : $.support.boxSizing ? $E.css('boxSizing') : 'content-box', b = $.layout.borderWidth, n = $.layout.cssNum, W = outerWidth;
      ;
      if (bs !== 'border-box')
        W -= b($E, 'Left') + b($E, 'Right');
      if (bs === 'content-box')
        W -= n($E, 'paddingLeft') + n($E, 'paddingRight');
      return max(0, W);
    },
    cssHeight: function ($E, outerHeight) {
      if (outerHeight <= 0)
        return 0;
      var bs = !$.layout.browser.boxModel ? 'border-box' : $.support.boxSizing ? $E.css('boxSizing') : 'content-box', b = $.layout.borderWidth, n = $.layout.cssNum, H = outerHeight;
      ;
      if (bs !== 'border-box')
        H -= b($E, 'Top') + b($E, 'Bottom');
      if (bs === 'content-box')
        H -= n($E, 'paddingTop') + n($E, 'paddingBottom');
      return max(0, H);
    },
    cssNum: function ($E, prop, allowAuto) {
      if (!$E.jquery)
        $E = $($E);
      var CSS = $.layout.showInvisibly($E), p = $.css($E[0], prop, true), v = allowAuto && p == 'auto' ? p : Math.round(parseFloat(p) || 0);
      $E.css(CSS);
      return v;
    },
    borderWidth: function (el, side) {
      if (el.jquery)
        el = el[0];
      var b = 'border' + side.substr(0, 1).toUpperCase() + side.substr(1);
      return $.css(el, b + 'Style', true) === 'none' ? 0 : Math.round(parseFloat($.css(el, b + 'Width', true)) || 0);
    },
    isMouseOverElem: function (evt, el) {
      var $E = $(el || this), d = $E.offset(), T = d.top, L = d.left, R = L + $E.outerWidth(), B = T + $E.outerHeight(), x = evt.pageX, y = evt.pageY;
      ;
      return $.layout.browser.msie && x < 0 && y < 0 || x >= L && x <= R && (y >= T && y <= B);
    },
    msg: function (info, popup, debugTitle, debugOpts) {
      if ($.isPlainObject(info) && window.debugData) {
        if (typeof popup === 'string') {
          debugOpts = debugTitle;
          debugTitle = popup;
        } else if (typeof debugTitle === 'object') {
          debugOpts = debugTitle;
          debugTitle = null;
        }
        var t = debugTitle || 'log( <object> )', o = $.extend({
            sort: false,
            returnHTML: false,
            display: false
          }, debugOpts);
        if (popup === true || o.display)
          debugData(info, t, o);
        else if (window.console)
          console.log(debugData(info, t, o));
      } else if (popup)
        alert(info);
      else if (window.console)
        console.log(info);
      else {
        var id = '#layoutLogger', $l = $(id);
        if (!$l.length)
          $l = createLog();
        $l.children('ul').append('<li style="padding: 4px 10px; margin: 0; border-top: 1px solid #CCC;">' + info.replace(/\</g, '&lt;').replace(/\>/g, '&gt;') + '</li>');
      }
      function createLog() {
        var pos = $.support.fixedPosition ? 'fixed' : 'absolute', $e = $('<div id="layoutLogger" style="position: ' + pos + '; top: 5px; z-index: 999999; max-width: 25%; overflow: hidden; border: 1px solid #000; border-radius: 5px; background: #FBFBFB; box-shadow: 0 2px 10px rgba(0,0,0,0.3);">' + '<div style="font-size: 13px; font-weight: bold; padding: 5px 10px; background: #F6F6F6; border-radius: 5px 5px 0 0; cursor: move;">' + '<span style="float: right; padding-left: 7px; cursor: pointer;" title="Remove Console" onclick="$(this).closest(\'#layoutLogger\').remove()">X</span>Layout console.log</div>' + '<ul style="font-size: 13px; font-weight: none; list-style: none; margin: 0; padding: 0 0 2px;"></ul>' + '</div>').appendTo('body');
        $e.css('left', $(window).width() - $e.outerWidth() - 5);
        if ($.ui.draggable)
          $e.draggable({ handle: ':first-child' });
        return $e;
      }
      ;
    }
  };
  var u = navigator.userAgent.toLowerCase(), m = /(chrome)[ \/]([\w.]+)/.exec(u) || /(webkit)[ \/]([\w.]+)/.exec(u) || /(opera)(?:.*version|)[ \/]([\w.]+)/.exec(u) || /(msie) ([\w.]+)/.exec(u) || u.indexOf('compatible') < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(u) || [], b = m[1] || '', v = m[2] || 0, ie = b === 'msie';
  ;
  $.layout.browser = {
    version: v,
    safari: b === 'webkit',
    webkit: b === 'chrome',
    msie: ie,
    isIE6: ie && v == 6,
    boxModel: !ie || $.support.boxModel !== false
  };
  if (b)
    $.layout.browser[b] = true;
  if (ie)
    $(function () {
      $.layout.browser.boxModel = $.support.boxModel;
    });
  $.layout.defaults = {
    name: '',
    containerClass: 'ui-layout-container',
    inset: null,
    scrollToBookmarkOnLoad: true,
    resizeWithWindow: true,
    resizeWithWindowDelay: 200,
    resizeWithWindowMaxDelay: 0,
    maskPanesEarly: false,
    onresizeall_start: null,
    onresizeall_end: null,
    onload_start: null,
    onload_end: null,
    onunload_start: null,
    onunload_end: null,
    initPanes: true,
    showErrorMessages: true,
    showDebugMessages: false,
    zIndex: null,
    zIndexes: {
      pane_normal: 0,
      content_mask: 1,
      resizer_normal: 2,
      pane_sliding: 100,
      pane_animate: 1000,
      resizer_drag: 10000
    },
    errors: {
      pane: 'pane',
      selector: 'selector',
      addButtonError: 'Error Adding Button\nInvalid ',
      containerMissing: 'UI Layout Initialization Error\nThe specified layout-container does not exist.',
      centerPaneMissing: 'UI Layout Initialization Error\nThe center-pane element does not exist.\nThe center-pane is a required element.',
      noContainerHeight: 'UI Layout Initialization Warning\nThe layout-container "CONTAINER" has no height.\nTherefore the layout is 0-height and hence \'invisible\'!',
      callbackError: 'UI Layout Callback Error\nThe EVENT callback is not a valid function.'
    },
    panes: {
      applyDemoStyles: false,
      closable: true,
      resizable: true,
      slidable: true,
      initClosed: false,
      initHidden: false,
      contentSelector: '.ui-layout-content',
      contentIgnoreSelector: '.ui-layout-ignore',
      findNestedContent: false,
      paneClass: 'ui-layout-pane',
      resizerClass: 'ui-layout-resizer',
      togglerClass: 'ui-layout-toggler',
      buttonClass: 'ui-layout-button',
      minSize: 0,
      maxSize: 0,
      spacing_open: 6,
      spacing_closed: 6,
      togglerLength_open: 50,
      togglerLength_closed: 50,
      togglerAlign_open: 'center',
      togglerAlign_closed: 'center',
      togglerContent_open: '',
      togglerContent_closed: '',
      resizerDblClickToggle: true,
      autoResize: true,
      autoReopen: true,
      resizerDragOpacity: 1,
      maskContents: false,
      maskObjects: false,
      maskZindex: null,
      resizingGrid: false,
      livePaneResizing: false,
      liveContentResizing: false,
      liveResizingTolerance: 1,
      sliderCursor: 'pointer',
      slideTrigger_open: 'click',
      slideTrigger_close: 'mouseleave',
      slideDelay_open: 300,
      slideDelay_close: 300,
      hideTogglerOnSlide: false,
      preventQuickSlideClose: $.layout.browser.webkit,
      preventPrematureSlideClose: false,
      tips: {
        Open: 'Open',
        Close: 'Close',
        Resize: 'Resize',
        Slide: 'Slide Open',
        Pin: 'Pin',
        Unpin: 'Un-Pin',
        noRoomToOpen: 'Not enough room to show this panel.',
        minSizeWarning: 'Panel has reached its minimum size',
        maxSizeWarning: 'Panel has reached its maximum size'
      },
      showOverflowOnHover: false,
      enableCursorHotkey: true,
      customHotkeyModifier: 'SHIFT',
      fxName: 'slide',
      fxSpeed: null,
      fxSettings: {},
      fxOpacityFix: true,
      animatePaneSizing: false,
      children: null,
      containerSelector: '',
      initChildren: true,
      destroyChildren: true,
      resizeChildren: true,
      triggerEventsOnLoad: false,
      triggerEventsDuringLiveResize: true,
      onshow_start: null,
      onshow_end: null,
      onhide_start: null,
      onhide_end: null,
      onopen_start: null,
      onopen_end: null,
      onclose_start: null,
      onclose_end: null,
      onresize_start: null,
      onresize_end: null,
      onsizecontent_start: null,
      onsizecontent_end: null,
      onswap_start: null,
      onswap_end: null,
      ondrag_start: null,
      ondrag_end: null
    },
    north: {
      paneSelector: '.ui-layout-north',
      size: 'auto',
      resizerCursor: 'n-resize',
      customHotkey: ''
    },
    south: {
      paneSelector: '.ui-layout-south',
      size: 'auto',
      resizerCursor: 's-resize',
      customHotkey: ''
    },
    east: {
      paneSelector: '.ui-layout-east',
      size: 200,
      resizerCursor: 'e-resize',
      customHotkey: ''
    },
    west: {
      paneSelector: '.ui-layout-west',
      size: 200,
      resizerCursor: 'w-resize',
      customHotkey: ''
    },
    center: {
      paneSelector: '.ui-layout-center',
      minWidth: 0,
      minHeight: 0
    }
  };
  $.layout.optionsMap = {
    layout: ('name,instanceKey,stateManagement,effects,inset,zIndexes,errors,' + 'zIndex,scrollToBookmarkOnLoad,showErrorMessages,maskPanesEarly,' + 'outset,resizeWithWindow,resizeWithWindowDelay,resizeWithWindowMaxDelay,' + 'onresizeall,onresizeall_start,onresizeall_end,onload,onload_start,onload_end,onunload,onunload_start,onunload_end').split(','),
    center: ('paneClass,contentSelector,contentIgnoreSelector,findNestedContent,applyDemoStyles,triggerEventsOnLoad,' + 'showOverflowOnHover,maskContents,maskObjects,liveContentResizing,' + 'containerSelector,children,initChildren,resizeChildren,destroyChildren,' + 'onresize,onresize_start,onresize_end,onsizecontent,onsizecontent_start,onsizecontent_end').split(','),
    noDefault: 'paneSelector,resizerCursor,customHotkey'.split(',')
  };
  $.layout.transformData = function (hash, addKeys) {
    var json = addKeys ? {
        panes: {},
        center: {}
      } : {}, branch, optKey, keys, key, val, i, c;
    if (typeof hash !== 'object')
      return json;
    for (optKey in hash) {
      branch = json;
      val = hash[optKey];
      keys = optKey.split('__');
      c = keys.length - 1;
      for (i = 0; i <= c; i++) {
        key = keys[i];
        if (i === c) {
          if ($.isPlainObject(val))
            branch[key] = $.layout.transformData(val);
          else
            branch[key] = val;
        } else {
          if (!branch[key])
            branch[key] = {};
          branch = branch[key];
        }
      }
    }
    return json;
  };
  $.layout.backwardCompatibility = {
    map: {
      applyDefaultStyles: 'applyDemoStyles',
      childOptions: 'children',
      initChildLayout: 'initChildren',
      destroyChildLayout: 'destroyChildren',
      resizeChildLayout: 'resizeChildren',
      resizeNestedLayout: 'resizeChildren',
      resizeWhileDragging: 'livePaneResizing',
      resizeContentWhileDragging: 'liveContentResizing',
      triggerEventsWhileDragging: 'triggerEventsDuringLiveResize',
      maskIframesOnResize: 'maskContents',
      useStateCookie: 'stateManagement.enabled',
      'cookie.autoLoad': 'stateManagement.autoLoad',
      'cookie.autoSave': 'stateManagement.autoSave',
      'cookie.keys': 'stateManagement.stateKeys',
      'cookie.name': 'stateManagement.cookie.name',
      'cookie.domain': 'stateManagement.cookie.domain',
      'cookie.path': 'stateManagement.cookie.path',
      'cookie.expires': 'stateManagement.cookie.expires',
      'cookie.secure': 'stateManagement.cookie.secure',
      noRoomToOpenTip: 'tips.noRoomToOpen',
      togglerTip_open: 'tips.Close',
      togglerTip_closed: 'tips.Open',
      resizerTip: 'tips.Resize',
      sliderTip: 'tips.Slide'
    },
    renameOptions: function (opts) {
      var map = $.layout.backwardCompatibility.map, oldData, newData, value;
      ;
      for (var itemPath in map) {
        oldData = getBranch(itemPath);
        value = oldData.branch[oldData.key];
        if (value !== undefined) {
          newData = getBranch(map[itemPath], true);
          newData.branch[newData.key] = value;
          delete oldData.branch[oldData.key];
        }
      }
      function getBranch(path, create) {
        var a = path.split('.'), c = a.length - 1, D = {
            branch: opts,
            key: a[c]
          }, i = 0, k, undef;
        for (; i < c; i++) {
          k = a[i];
          if (D.branch[k] == undefined) {
            if (create) {
              D.branch = D.branch[k] = {};
            } else
              D.branch = {};
          } else
            D.branch = D.branch[k];
        }
        return D;
      }
      ;
    },
    renameAllOptions: function (opts) {
      var ren = $.layout.backwardCompatibility.renameOptions;
      ren(opts);
      if (opts.defaults) {
        if (typeof opts.panes !== 'object')
          opts.panes = {};
        $.extend(true, opts.panes, opts.defaults);
        delete opts.defaults;
      }
      if (opts.panes)
        ren(opts.panes);
      $.each($.layout.config.allPanes, function (i, pane) {
        if (opts[pane])
          ren(opts[pane]);
      });
      return opts;
    }
  };
  $.fn.layout = function (opts) {
    var browser = $.layout.browser, _c = $.layout.config, cssW = $.layout.cssWidth, cssH = $.layout.cssHeight, elDims = $.layout.getElementDimensions, styles = $.layout.getElementStyles, evtObj = $.layout.getEventObject, evtPane = $.layout.parsePaneName, options = $.extend(true, {}, $.layout.defaults), effects = options.effects = $.extend(true, {}, $.layout.effects), state = {
        id: 'layout' + $.now(),
        initialized: false,
        paneResizing: false,
        panesSliding: {},
        container: {
          innerWidth: 0,
          innerHeight: 0,
          outerWidth: 0,
          outerHeight: 0,
          layoutWidth: 0,
          layoutHeight: 0
        },
        north: { childIdx: 0 },
        south: { childIdx: 0 },
        east: { childIdx: 0 },
        west: { childIdx: 0 },
        center: { childIdx: 0 }
      }, children = {
        north: null,
        south: null,
        east: null,
        west: null,
        center: null
      }, timer = {
        data: {},
        set: function (s, fn, ms) {
          timer.clear(s);
          timer.data[s] = setTimeout(fn, ms);
        },
        clear: function (s) {
          var t = timer.data;
          if (t[s]) {
            clearTimeout(t[s]);
            delete t[s];
          }
        }
      }, _log = function (msg, popup, debug) {
        var o = options;
        if (o.showErrorMessages && !debug || debug && o.showDebugMessages)
          $.layout.msg(o.name + ' / ' + msg, popup !== false);
        return false;
      }, _runCallbacks = function (evtName, pane, skipBoundEvents) {
        var hasPane = pane && isStr(pane), s = hasPane ? state[pane] : state, o = hasPane ? options[pane] : options, lName = options.name, lng = evtName + (evtName.match(/_/) ? '' : '_end'), shrt = lng.match(/_end$/) ? lng.substr(0, lng.length - 4) : '', fn = o[lng] || o[shrt], retVal = 'NC', args = [], $P;
        ;
        if (!hasPane && $.type(pane) === 'boolean') {
          skipBoundEvents = pane;
          pane = '';
        }
        if (fn) {
          try {
            if (isStr(fn)) {
              if (fn.match(/,/)) {
                args = fn.split(','), fn = eval(args[0]);
              } else
                fn = eval(fn);
            }
            if ($.isFunction(fn)) {
              if (args.length)
                retVal = g(fn)(args[1]);
              else if (hasPane)
                retVal = g(fn)(pane, $Ps[pane], s, o, lName);
              else
                retVal = g(fn)(Instance, s, o, lName);
            }
          } catch (ex) {
            _log(options.errors.callbackError.replace(/EVENT/, $.trim((pane || '') + ' ' + lng)), false);
            if ($.type(ex) === 'string' && string.length)
              _log('Exception:  ' + ex, false);
          }
        }
        if (!skipBoundEvents && retVal !== false) {
          if (hasPane) {
            $P = $Ps[pane];
            o = options[pane];
            s = state[pane];
            $P.triggerHandler('layoutpane' + lng, [
              pane,
              $P,
              s,
              o,
              lName
            ]);
            if (shrt)
              $P.triggerHandler('layoutpane' + shrt, [
                pane,
                $P,
                s,
                o,
                lName
              ]);
          } else {
            $N.triggerHandler('layout' + lng, [
              Instance,
              s,
              o,
              lName
            ]);
            if (shrt)
              $N.triggerHandler('layout' + shrt, [
                Instance,
                s,
                o,
                lName
              ]);
          }
        }
        if (hasPane && evtName === 'onresize_end')
          resizeChildren(pane + '', true);
        return retVal;
        function g(f) {
          return f;
        }
        ;
      }, _fixIframe = function (pane) {
        if (browser.mozilla)
          return;
        var $P = $Ps[pane];
        if (state[pane].tagName === 'IFRAME')
          $P.css(_c.hidden).css(_c.visible);
        else
          $P.find('IFRAME').css(_c.hidden).css(_c.visible);
      }, cssSize = function (pane, outerSize) {
        var fn = _c[pane].dir == 'horz' ? cssH : cssW;
        return fn($Ps[pane], outerSize);
      }, cssMinDims = function (pane) {
        var $P = $Ps[pane], dir = _c[pane].dir, d = {
            minWidth: 1001 - cssW($P, 1000),
            minHeight: 1001 - cssH($P, 1000)
          };
        ;
        if (dir === 'horz')
          d.minSize = d.minHeight;
        if (dir === 'vert')
          d.minSize = d.minWidth;
        return d;
      }, setOuterWidth = function (el, outerWidth, autoHide) {
        var $E = el, w;
        if (isStr(el))
          $E = $Ps[el];
        else if (!el.jquery)
          $E = $(el);
        w = cssW($E, outerWidth);
        $E.css({ width: w });
        if (w > 0) {
          if (autoHide && $E.data('autoHidden') && $E.innerHeight() > 0) {
            $E.show().data('autoHidden', false);
            if (!browser.mozilla)
              $E.css(_c.hidden).css(_c.visible);
          }
        } else if (autoHide && !$E.data('autoHidden'))
          $E.hide().data('autoHidden', true);
      }, setOuterHeight = function (el, outerHeight, autoHide) {
        var $E = el, h;
        if (isStr(el))
          $E = $Ps[el];
        else if (!el.jquery)
          $E = $(el);
        h = cssH($E, outerHeight);
        $E.css({
          height: h,
          visibility: 'visible'
        });
        if (h > 0 && $E.innerWidth() > 0) {
          if (autoHide && $E.data('autoHidden')) {
            $E.show().data('autoHidden', false);
            if (!browser.mozilla)
              $E.css(_c.hidden).css(_c.visible);
          }
        } else if (autoHide && !$E.data('autoHidden'))
          $E.hide().data('autoHidden', true);
      }, _parseSize = function (pane, size, dir) {
        if (!dir)
          dir = _c[pane].dir;
        if (isStr(size) && size.match(/%/))
          size = size === '100%' ? -1 : parseInt(size, 10) / 100;
        if (size === 0)
          return 0;
        else if (size >= 1)
          return parseInt(size, 10);
        var o = options, avail = 0;
        if (dir == 'horz')
          avail = sC.innerHeight - ($Ps.north ? o.north.spacing_open : 0) - ($Ps.south ? o.south.spacing_open : 0);
        else if (dir == 'vert')
          avail = sC.innerWidth - ($Ps.west ? o.west.spacing_open : 0) - ($Ps.east ? o.east.spacing_open : 0);
        if (size === -1)
          return avail;
        else if (size > 0)
          return round(avail * size);
        else if (pane == 'center')
          return 0;
        else {
          var dim = dir === 'horz' ? 'height' : 'width', $P = $Ps[pane], $C = dim === 'height' ? $Cs[pane] : false, vis = $.layout.showInvisibly($P), szP = $P.css(dim), szC = $C ? $C.css(dim) : 0;
          ;
          $P.css(dim, 'auto');
          if ($C)
            $C.css(dim, 'auto');
          size = dim === 'height' ? $P.outerHeight() : $P.outerWidth();
          $P.css(dim, szP).css(vis);
          if ($C)
            $C.css(dim, szC);
          return size;
        }
      }, getPaneSize = function (pane, inclSpace) {
        var $P = $Ps[pane], o = options[pane], s = state[pane], oSp = inclSpace ? o.spacing_open : 0, cSp = inclSpace ? o.spacing_closed : 0;
        ;
        if (!$P || s.isHidden)
          return 0;
        else if (s.isClosed || s.isSliding && inclSpace)
          return cSp;
        else if (_c[pane].dir === 'horz')
          return $P.outerHeight() + oSp;
        else
          return $P.outerWidth() + oSp;
      }, setSizeLimits = function (pane, slide) {
        if (!isInitialized())
          return;
        var o = options[pane], s = state[pane], c = _c[pane], dir = c.dir, type = c.sizeType.toLowerCase(), isSliding = slide != undefined ? slide : s.isSliding, $P = $Ps[pane], paneSpacing = o.spacing_open, altPane = _c.oppositeEdge[pane], altS = state[altPane], $altP = $Ps[altPane], altPaneSize = !$altP || altS.isVisible === false || altS.isSliding ? 0 : dir == 'horz' ? $altP.outerHeight() : $altP.outerWidth(), altPaneSpacing = (!$altP || altS.isHidden ? 0 : options[altPane][altS.isClosed !== false ? 'spacing_closed' : 'spacing_open']) || 0, containerSize = dir == 'horz' ? sC.innerHeight : sC.innerWidth, minCenterDims = cssMinDims('center'), minCenterSize = dir == 'horz' ? max(options.center.minHeight, minCenterDims.minHeight) : max(options.center.minWidth, minCenterDims.minWidth), limitSize = containerSize - paneSpacing - (isSliding ? 0 : _parseSize('center', minCenterSize, dir) + altPaneSize + altPaneSpacing), minSize = s.minSize = max(_parseSize(pane, o.minSize), cssMinDims(pane).minSize), maxSize = s.maxSize = min(o.maxSize ? _parseSize(pane, o.maxSize) : 100000, limitSize), r = s.resizerPosition = {}, top = sC.inset.top, left = sC.inset.left, W = sC.innerWidth, H = sC.innerHeight, rW = o.spacing_open;
        ;
        switch (pane) {
        case 'north':
          r.min = top + minSize;
          r.max = top + maxSize;
          break;
        case 'west':
          r.min = left + minSize;
          r.max = left + maxSize;
          break;
        case 'south':
          r.min = top + H - maxSize - rW;
          r.max = top + H - minSize - rW;
          break;
        case 'east':
          r.min = left + W - maxSize - rW;
          r.max = left + W - minSize - rW;
          break;
        }
        ;
      }, calcNewCenterPaneDims = function () {
        var d = {
            top: getPaneSize('north', true),
            bottom: getPaneSize('south', true),
            left: getPaneSize('west', true),
            right: getPaneSize('east', true),
            width: 0,
            height: 0
          };
        d.width = sC.innerWidth - d.left - d.right;
        d.height = sC.innerHeight - d.bottom - d.top;
        d.top += sC.inset.top;
        d.bottom += sC.inset.bottom;
        d.left += sC.inset.left;
        d.right += sC.inset.right;
        return d;
      }, getHoverClasses = function (el, allStates) {
        var $El = $(el), type = $El.data('layoutRole'), pane = $El.data('layoutEdge'), o = options[pane], root = o[type + 'Class'], _pane = '-' + pane, _open = '-open', _closed = '-closed', _slide = '-sliding', _hover = '-hover ', _state = $El.hasClass(root + _closed) ? _closed : _open, _alt = _state === _closed ? _open : _closed, classes = root + _hover + (root + _pane + _hover) + (root + _state + _hover) + (root + _pane + _state + _hover);
        ;
        if (allStates)
          classes += root + _alt + _hover + (root + _pane + _alt + _hover);
        if (type == 'resizer' && $El.hasClass(root + _slide))
          classes += root + _slide + _hover + (root + _pane + _slide + _hover);
        return $.trim(classes);
      }, addHover = function (evt, el) {
        var $E = $(el || this);
        if (evt && $E.data('layoutRole') === 'toggler')
          evt.stopPropagation();
        $E.addClass(getHoverClasses($E));
      }, removeHover = function (evt, el) {
        var $E = $(el || this);
        $E.removeClass(getHoverClasses($E, true));
      }, onResizerEnter = function (evt) {
        var pane = $(this).data('layoutEdge'), s = state[pane];
        ;
        if (s.isClosed || s.isResizing || state.paneResizing)
          return;
        if ($.fn.disableSelection)
          $('body').disableSelection();
        if (options.maskPanesEarly)
          showMasks(pane, { resizing: true });
      }, onResizerLeave = function (evt, el) {
        var e = el || this, pane = $(e).data('layoutEdge'), name = pane + 'ResizerLeave';
        ;
        timer.clear(pane + '_openSlider');
        timer.clear(name);
        if (!el)
          timer.set(name, function () {
            onResizerLeave(evt, e);
          }, 200);
        else if (!state.paneResizing) {
          if ($.fn.enableSelection)
            $('body').enableSelection();
          if (options.maskPanesEarly)
            hideMasks();
        }
      }, _create = function () {
        initOptions();
        var o = options, s = state;
        s.creatingLayout = true;
        runPluginCallbacks(Instance, $.layout.onCreate);
        if (false === _runCallbacks('onload_start'))
          return 'cancel';
        _initContainer();
        initHotkeys();
        $(window).bind('unload.' + sID, unload);
        runPluginCallbacks(Instance, $.layout.onLoad);
        if (o.initPanes)
          _initLayoutElements();
        delete s.creatingLayout;
        return state.initialized;
      }, isInitialized = function () {
        if (state.initialized || state.creatingLayout)
          return true;
        else
          return _initLayoutElements();
      }, _initLayoutElements = function (retry) {
        var o = options;
        if (!$N.is(':visible')) {
          if (!retry && browser.webkit && $N[0].tagName === 'BODY')
            setTimeout(function () {
              _initLayoutElements(true);
            }, 50);
          return false;
        }
        if (!getPane('center').length) {
          return _log(o.errors.centerPaneMissing);
        }
        state.creatingLayout = true;
        $.extend(sC, elDims($N, o.inset));
        initPanes();
        if (o.scrollToBookmarkOnLoad) {
          var l = self.location;
          if (l.hash)
            l.replace(l.hash);
        }
        if (Instance.hasParentLayout)
          o.resizeWithWindow = false;
        else if (o.resizeWithWindow)
          $(window).bind('resize.' + sID, windowResize);
        delete state.creatingLayout;
        state.initialized = true;
        runPluginCallbacks(Instance, $.layout.onReady);
        _runCallbacks('onload_end');
        return true;
      }, createChildren = function (evt_or_pane, opts) {
        var pane = evtPane.call(this, evt_or_pane), $P = $Ps[pane];
        ;
        if (!$P)
          return;
        var $C = $Cs[pane], s = state[pane], o = options[pane], sm = options.stateManagement || {}, cos = opts ? o.children = opts : o.children;
        ;
        if ($.isPlainObject(cos))
          cos = [cos];
        else if (!cos || !$.isArray(cos))
          return;
        $.each(cos, function (idx, co) {
          if (!$.isPlainObject(co))
            return;
          var $containers = co.containerSelector ? $P.find(co.containerSelector) : $C || $P;
          $containers.each(function () {
            var $cont = $(this), child = $cont.data('layout');
            ;
            if (!child) {
              setInstanceKey({
                container: $cont,
                options: co
              }, s);
              if (sm.includeChildren && state.stateData[pane]) {
                var paneChildren = state.stateData[pane].children || {}, childState = paneChildren[co.instanceKey], co_sm = co.stateManagement || (co.stateManagement = { autoLoad: true });
                ;
                if (co_sm.autoLoad === true && childState) {
                  co_sm.autoSave = false;
                  co_sm.includeChildren = true;
                  co_sm.autoLoad = $.extend(true, {}, childState);
                }
              }
              child = $cont.layout(co);
              if (child) {
                refreshChildren(pane, child);
              }
            }
          });
        });
      }, setInstanceKey = function (child, parentPaneState) {
        var $c = child.container, o = child.options, sm = o.stateManagement, key = o.instanceKey || $c.data('layoutInstanceKey');
        ;
        if (!key)
          key = (sm && sm.cookie ? sm.cookie.name : '') || o.name;
        if (!key)
          key = 'layout' + ++parentPaneState.childIdx;
        else
          key = key.replace(/[^\w-]/gi, '_').replace(/_{2,}/g, '_');
        o.instanceKey = key;
        $c.data('layoutInstanceKey', key);
        return key;
      }, refreshChildren = function (pane, newChild) {
        var $P = $Ps[pane], pC = children[pane], s = state[pane], o;
        ;
        if ($.isPlainObject(pC)) {
          $.each(pC, function (key, child) {
            if (child.destroyed)
              delete pC[key];
          });
          if ($.isEmptyObject(pC))
            pC = children[pane] = null;
        }
        if (!newChild && !pC) {
          newChild = $P.data('layout');
        }
        if (newChild) {
          newChild.hasParentLayout = true;
          o = newChild.options;
          setInstanceKey(newChild, s);
          if (!pC)
            pC = children[pane] = {};
          pC[o.instanceKey] = newChild.container.data('layout');
        }
        Instance[pane].children = children[pane];
        if (!newChild) {
          createChildren(pane);
        }
      }, windowResize = function () {
        var o = options, delay = Number(o.resizeWithWindowDelay);
        if (delay < 10)
          delay = 100;
        timer.clear('winResize');
        timer.set('winResize', function () {
          timer.clear('winResize');
          timer.clear('winResizeRepeater');
          var dims = elDims($N, o.inset);
          if (dims.innerWidth !== sC.innerWidth || dims.innerHeight !== sC.innerHeight)
            resizeAll();
        }, delay);
        if (!timer.data['winResizeRepeater'])
          setWindowResizeRepeater();
      }, setWindowResizeRepeater = function () {
        var delay = Number(options.resizeWithWindowMaxDelay);
        if (delay > 0)
          timer.set('winResizeRepeater', function () {
            setWindowResizeRepeater();
            resizeAll();
          }, delay);
      }, unload = function () {
        var o = options;
        _runCallbacks('onunload_start');
        runPluginCallbacks(Instance, $.layout.onUnload);
        _runCallbacks('onunload_end');
      }, _initContainer = function () {
        var N = $N[0], $H = $('html'), tag = sC.tagName = N.tagName, id = sC.id = N.id, cls = sC.className = N.className, o = options, name = o.name, props = 'position,margin,padding,border', css = 'layoutCSS', CSS = {}, hid = 'hidden', parent = $N.data('parentLayout'), pane = $N.data('layoutEdge'), isChild = parent && pane, num = $.layout.cssNum, $parent, n;
        ;
        sC.selector = $N.selector.split('.slice')[0];
        sC.ref = (o.name ? o.name + ' layout / ' : '') + tag + (id ? '#' + id : cls ? '.[' + cls + ']' : '');
        sC.isBody = tag === 'BODY';
        if (!isChild && !sC.isBody) {
          $parent = $N.closest('.' + $.layout.defaults.panes.paneClass);
          parent = $parent.data('parentLayout');
          pane = $parent.data('layoutEdge');
          isChild = parent && pane;
        }
        $N.data({
          layout: Instance,
          layoutContainer: sID
        }).addClass(o.containerClass);
        ;
        var layoutMethods = {
            destroy: '',
            initPanes: '',
            resizeAll: 'resizeAll',
            resize: 'resizeAll'
          };
        for (name in layoutMethods) {
          $N.bind('layout' + name.toLowerCase() + '.' + sID, Instance[layoutMethods[name] || name]);
        }
        if (isChild) {
          Instance.hasParentLayout = true;
          parent.refreshChildren(pane, Instance);
        }
        if (!$N.data(css)) {
          if (sC.isBody) {
            $N.data(css, $.extend(styles($N, props), {
              height: $N.css('height'),
              overflow: $N.css('overflow'),
              overflowX: $N.css('overflowX'),
              overflowY: $N.css('overflowY')
            }));
            $H.data(css, $.extend(styles($H, 'padding'), {
              height: 'auto',
              overflow: $H.css('overflow'),
              overflowX: $H.css('overflowX'),
              overflowY: $H.css('overflowY')
            }));
          } else
            $N.data(css, styles($N, props + ',top,bottom,left,right,width,height,overflow,overflowX,overflowY'));
        }
        try {
          CSS = {
            overflow: hid,
            overflowX: hid,
            overflowY: hid
          };
          $N.css(CSS);
          if (o.inset && !$.isPlainObject(o.inset)) {
            n = parseInt(o.inset, 10) || 0;
            o.inset = {
              top: n,
              bottom: n,
              left: n,
              right: n
            };
          }
          if (sC.isBody) {
            if (!o.outset) {
              o.outset = {
                top: num($H, 'paddingTop'),
                bottom: num($H, 'paddingBottom'),
                left: num($H, 'paddingLeft'),
                right: num($H, 'paddingRight')
              };
            } else if (!$.isPlainObject(o.outset)) {
              n = parseInt(o.outset, 10) || 0;
              o.outset = {
                top: n,
                bottom: n,
                left: n,
                right: n
              };
            }
            $H.css(CSS).css({
              height: '100%',
              border: 'none',
              padding: 0,
              margin: 0
            });
            if (browser.isIE6) {
              $N.css({
                width: '100%',
                height: '100%',
                border: 'none',
                padding: 0,
                margin: 0,
                position: 'relative'
              });
              if (!o.inset)
                o.inset = elDims($N).inset;
            } else {
              $N.css({
                width: 'auto',
                height: 'auto',
                margin: 0,
                position: 'absolute'
              });
              $N.css(o.outset);
            }
            $.extend(sC, elDims($N, o.inset));
          } else {
            var p = $N.css('position');
            if (!p || !p.match(/(fixed|absolute|relative)/))
              $N.css('position', 'relative');
            if ($N.is(':visible')) {
              $.extend(sC, elDims($N, o.inset));
              if (sC.innerHeight < 1)
                _log(o.errors.noContainerHeight.replace(/CONTAINER/, sC.ref));
            }
          }
          if (num($N, 'minWidth'))
            $N.parent().css('overflowX', 'auto');
          if (num($N, 'minHeight'))
            $N.parent().css('overflowY', 'auto');
        } catch (ex) {
        }
      }, initHotkeys = function (panes) {
        panes = panes ? panes.split(',') : _c.borderPanes;
        $.each(panes, function (i, pane) {
          var o = options[pane];
          if (o.enableCursorHotkey || o.customHotkey) {
            $(document).bind('keydown.' + sID, keyDown);
            return false;
          }
        });
      }, initOptions = function () {
        var data, d, pane, key, val, i, c, o;
        opts = $.layout.transformData(opts, true);
        opts = $.layout.backwardCompatibility.renameAllOptions(opts);
        if (!$.isEmptyObject(opts.panes)) {
          data = $.layout.optionsMap.noDefault;
          for (i = 0, c = data.length; i < c; i++) {
            key = data[i];
            delete opts.panes[key];
          }
          data = $.layout.optionsMap.layout;
          for (i = 0, c = data.length; i < c; i++) {
            key = data[i];
            delete opts.panes[key];
          }
        }
        data = $.layout.optionsMap.layout;
        var rootKeys = $.layout.config.optionRootKeys;
        for (key in opts) {
          val = opts[key];
          if ($.inArray(key, rootKeys) < 0 && $.inArray(key, data) < 0) {
            if (!opts.panes[key])
              opts.panes[key] = $.isPlainObject(val) ? $.extend(true, {}, val) : val;
            delete opts[key];
          }
        }
        $.extend(true, options, opts);
        $.each(_c.allPanes, function (i, pane) {
          _c[pane] = $.extend(true, {}, _c.panes, _c[pane]);
          d = options.panes;
          o = options[pane];
          if (pane === 'center') {
            data = $.layout.optionsMap.center;
            for (i = 0, c = data.length; i < c; i++) {
              key = data[i];
              if (!opts.center[key] && (opts.panes[key] || !o[key]))
                o[key] = d[key];
            }
          } else {
            o = options[pane] = $.extend(true, {}, d, o);
            createFxOptions(pane);
            if (!o.resizerClass)
              o.resizerClass = 'ui-layout-resizer';
            if (!o.togglerClass)
              o.togglerClass = 'ui-layout-toggler';
          }
          if (!o.paneClass)
            o.paneClass = 'ui-layout-pane';
        });
        var zo = opts.zIndex, z = options.zIndexes;
        if (zo > 0) {
          z.pane_normal = zo;
          z.content_mask = max(zo + 1, z.content_mask);
          z.resizer_normal = max(zo + 2, z.resizer_normal);
        }
        delete options.panes;
        function createFxOptions(pane) {
          var o = options[pane], d = options.panes;
          if (!o.fxSettings)
            o.fxSettings = {};
          if (!d.fxSettings)
            d.fxSettings = {};
          $.each([
            '_open',
            '_close',
            '_size'
          ], function (i, n) {
            var sName = 'fxName' + n, sSpeed = 'fxSpeed' + n, sSettings = 'fxSettings' + n, fxName = o[sName] = o[sName] || d[sName] || o.fxName || d.fxName || 'none', fxExists = $.effects && ($.effects[fxName] || $.effects.effect && $.effects.effect[fxName]);
            ;
            if (fxName === 'none' || !options.effects[fxName] || !fxExists)
              fxName = o[sName] = 'none';
            var fx = options.effects[fxName] || {}, fx_all = fx.all || null, fx_pane = fx[pane] || null;
            ;
            o[sSpeed] = o[sSpeed] || d[sSpeed] || o.fxSpeed || d.fxSpeed || null;
            ;
            o[sSettings] = $.extend(true, {}, fx_all, fx_pane, d.fxSettings, o.fxSettings, d[sSettings], o[sSettings]);
          });
          delete o.fxName;
          delete o.fxSpeed;
          delete o.fxSettings;
        }
      }, getPane = function (pane) {
        var sel = options[pane].paneSelector;
        if (sel.substr(0, 1) === '#')
          return $N.find(sel).eq(0);
        else {
          var $P = $N.children(sel).eq(0);
          return $P.length ? $P : $N.children('form:first').children(sel).eq(0);
        }
      }, initPanes = function (evt) {
        evtPane(evt);
        $.each(_c.allPanes, function (idx, pane) {
          addPane(pane, true);
        });
        initHandles();
        $.each(_c.borderPanes, function (i, pane) {
          if ($Ps[pane] && state[pane].isVisible) {
            setSizeLimits(pane);
            makePaneFit(pane);
          }
        });
        sizeMidPanes('center');
        $.each(_c.allPanes, function (idx, pane) {
          afterInitPane(pane);
        });
      }, addPane = function (pane, force) {
        if (!force && !isInitialized())
          return;
        var o = options[pane], s = state[pane], c = _c[pane], dir = c.dir, fx = s.fx, spacing = o.spacing_open || 0, isCenter = pane === 'center', CSS = {}, $P = $Ps[pane], size, minSize, maxSize, child;
        ;
        if ($P)
          removePane(pane, false, true, false);
        else
          $Cs[pane] = false;
        $P = $Ps[pane] = getPane(pane);
        if (!$P.length) {
          $Ps[pane] = false;
          return;
        }
        if (!$P.data('layoutCSS')) {
          var props = 'position,top,left,bottom,right,width,height,overflow,zIndex,display,backgroundColor,padding,margin,border';
          $P.data('layoutCSS', styles($P, props));
        }
        Instance[pane] = {
          name: pane,
          pane: $Ps[pane],
          content: $Cs[pane],
          options: options[pane],
          state: state[pane],
          children: children[pane]
        };
        $P.data({
          parentLayout: Instance,
          layoutPane: Instance[pane],
          layoutEdge: pane,
          layoutRole: 'pane'
        }).css(c.cssReq).css('zIndex', options.zIndexes.pane_normal).css(o.applyDemoStyles ? c.cssDemo : {}).addClass(o.paneClass + ' ' + o.paneClass + '-' + pane).bind('mouseenter.' + sID, addHover).bind('mouseleave.' + sID, removeHover);
        ;
        var paneMethods = {
            hide: '',
            show: '',
            toggle: '',
            close: '',
            open: '',
            slideOpen: '',
            slideClose: '',
            slideToggle: '',
            size: 'sizePane',
            sizePane: 'sizePane',
            sizeContent: '',
            sizeHandles: '',
            enableClosable: '',
            disableClosable: '',
            enableSlideable: '',
            disableSlideable: '',
            enableResizable: '',
            disableResizable: '',
            swapPanes: 'swapPanes',
            swap: 'swapPanes',
            move: 'swapPanes',
            removePane: 'removePane',
            remove: 'removePane',
            createChildren: '',
            resizeChildren: '',
            resizeAll: 'resizeAll',
            resizeLayout: 'resizeAll'
          }, name;
        for (name in paneMethods) {
          $P.bind('layoutpane' + name.toLowerCase() + '.' + sID, Instance[paneMethods[name] || name]);
        }
        initContent(pane, false);
        if (!isCenter) {
          size = s.size = _parseSize(pane, o.size);
          minSize = _parseSize(pane, o.minSize) || 1;
          maxSize = _parseSize(pane, o.maxSize) || 100000;
          if (size > 0)
            size = max(min(size, maxSize), minSize);
          s.autoResize = o.autoResize;
          s.isClosed = false;
          s.isSliding = false;
          s.isResizing = false;
          s.isHidden = false;
          if (!s.pins)
            s.pins = [];
        }
        s.tagName = $P[0].tagName;
        s.edge = pane;
        s.noRoom = false;
        s.isVisible = true;
        setPanePosition(pane);
        if (dir === 'horz')
          CSS.height = cssH($P, size);
        else if (dir === 'vert')
          CSS.width = cssW($P, size);
        $P.css(CSS);
        if (dir != 'horz')
          sizeMidPanes(pane, true);
        if (state.initialized) {
          initHandles(pane);
          initHotkeys(pane);
        }
        if (o.initClosed && o.closable && !o.initHidden)
          close(pane, true, true);
        else if (o.initHidden || o.initClosed)
          hide(pane);
        else if (!s.noRoom)
          $P.css('display', 'block');
        $P.css('visibility', 'visible');
        if (o.showOverflowOnHover)
          $P.hover(allowOverflow, resetOverflow);
        if (state.initialized) {
          afterInitPane(pane);
        }
      }, afterInitPane = function (pane) {
        var $P = $Ps[pane], s = state[pane], o = options[pane];
        ;
        if (!$P)
          return;
        if ($P.data('layout'))
          refreshChildren(pane, $P.data('layout'));
        if (s.isVisible) {
          if (state.initialized)
            resizeAll();
          else
            sizeContent(pane);
          if (o.triggerEventsOnLoad)
            _runCallbacks('onresize_end', pane);
          else
            resizeChildren(pane, true);
        }
        if (o.initChildren && o.children)
          createChildren(pane);
      }, setPanePosition = function (panes) {
        panes = panes ? panes.split(',') : _c.borderPanes;
        $.each(panes, function (i, pane) {
          var $P = $Ps[pane], $R = $Rs[pane], o = options[pane], s = state[pane], side = _c[pane].side, CSS = {};
          ;
          if (!$P)
            return;
          switch (pane) {
          case 'north':
            CSS.top = sC.inset.top;
            CSS.left = sC.inset.left;
            CSS.right = sC.inset.right;
            break;
          case 'south':
            CSS.bottom = sC.inset.bottom;
            CSS.left = sC.inset.left;
            CSS.right = sC.inset.right;
            break;
          case 'west':
            CSS.left = sC.inset.left;
            break;
          case 'east':
            CSS.right = sC.inset.right;
            break;
          case 'center':
          }
          $P.css(CSS);
          if ($R && s.isClosed)
            $R.css(side, sC.inset[side]);
          else if ($R && !s.isHidden)
            $R.css(side, sC.inset[side] + getPaneSize(pane));
        });
      }, initHandles = function (panes) {
        panes = panes ? panes.split(',') : _c.borderPanes;
        $.each(panes, function (i, pane) {
          var $P = $Ps[pane];
          $Rs[pane] = false;
          $Ts[pane] = false;
          if (!$P)
            return;
          var o = options[pane], s = state[pane], c = _c[pane], paneId = o.paneSelector.substr(0, 1) === '#' ? o.paneSelector.substr(1) : '', rClass = o.resizerClass, tClass = o.togglerClass, spacing = s.isVisible ? o.spacing_open : o.spacing_closed, _pane = '-' + pane, _state = s.isVisible ? '-open' : '-closed', I = Instance[pane], $R = I.resizer = $Rs[pane] = $('<div></div>'), $T = I.toggler = o.closable ? $Ts[pane] = $('<div></div>') : false;
          ;
          if (!s.isVisible && o.slidable)
            $R.attr('title', o.tips.Slide).css('cursor', o.sliderCursor);
          $R.attr('id', paneId ? paneId + '-resizer' : '').data({
            parentLayout: Instance,
            layoutPane: Instance[pane],
            layoutEdge: pane,
            layoutRole: 'resizer'
          }).css(_c.resizers.cssReq).css('zIndex', options.zIndexes.resizer_normal).css(o.applyDemoStyles ? _c.resizers.cssDemo : {}).addClass(rClass + ' ' + rClass + _pane).hover(addHover, removeHover).hover(onResizerEnter, onResizerLeave).appendTo($N);
          ;
          if (o.resizerDblClickToggle)
            $R.bind('dblclick.' + sID, toggle);
          if ($T) {
            $T.attr('id', paneId ? paneId + '-toggler' : '').data({
              parentLayout: Instance,
              layoutPane: Instance[pane],
              layoutEdge: pane,
              layoutRole: 'toggler'
            }).css(_c.togglers.cssReq).css(o.applyDemoStyles ? _c.togglers.cssDemo : {}).addClass(tClass + ' ' + tClass + _pane).hover(addHover, removeHover).bind('mouseenter', onResizerEnter).appendTo($R);
            ;
            if (o.togglerContent_open)
              $('<span>' + o.togglerContent_open + '</span>').data({
                layoutEdge: pane,
                layoutRole: 'togglerContent'
              }).data('layoutRole', 'togglerContent').data('layoutEdge', pane).addClass('content content-open').css('display', 'none').appendTo($T);
            ;
            if (o.togglerContent_closed)
              $('<span>' + o.togglerContent_closed + '</span>').data({
                layoutEdge: pane,
                layoutRole: 'togglerContent'
              }).addClass('content content-closed').css('display', 'none').appendTo($T);
            ;
            enableClosable(pane);
          }
          initResizable(pane);
          if (s.isVisible)
            setAsOpen(pane);
          else {
            setAsClosed(pane);
            bindStartSlidingEvents(pane, true);
          }
        });
        sizeHandles();
      }, initContent = function (pane, resize) {
        if (!isInitialized())
          return;
        var o = options[pane], sel = o.contentSelector, I = Instance[pane], $P = $Ps[pane], $C;
        ;
        if (sel)
          $C = I.content = $Cs[pane] = o.findNestedContent ? $P.find(sel).eq(0) : $P.children(sel).eq(0);
        ;
        if ($C && $C.length) {
          $C.data('layoutRole', 'content');
          if (!$C.data('layoutCSS'))
            $C.data('layoutCSS', styles($C, 'height'));
          $C.css(_c.content.cssReq);
          if (o.applyDemoStyles) {
            $C.css(_c.content.cssDemo);
            $P.css(_c.content.cssDemoPane);
          }
          if ($P.css('overflowX').match(/(scroll|auto)/)) {
            $P.css('overflow', 'hidden');
          }
          state[pane].content = {};
          if (resize !== false)
            sizeContent(pane);
        } else
          I.content = $Cs[pane] = false;
      }, initResizable = function (panes) {
        var draggingAvailable = $.layout.plugins.draggable, side;
        ;
        panes = panes ? panes.split(',') : _c.borderPanes;
        $.each(panes, function (idx, pane) {
          var o = options[pane];
          if (!draggingAvailable || !$Ps[pane] || !o.resizable) {
            o.resizable = false;
            return true;
          }
          var s = state[pane], z = options.zIndexes, c = _c[pane], side = c.dir == 'horz' ? 'top' : 'left', $P = $Ps[pane], $R = $Rs[pane], base = o.resizerClass, lastPos = 0, r, live, resizerClass = base + '-drag', resizerPaneClass = base + '-' + pane + '-drag', helperClass = base + '-dragging', helperPaneClass = base + '-' + pane + '-dragging', helperLimitClass = base + '-dragging-limit', helperPaneLimitClass = base + '-' + pane + '-dragging-limit', helperClassesSet = false;
          ;
          if (!s.isClosed)
            $R.attr('title', o.tips.Resize).css('cursor', o.resizerCursor);
          $R.draggable({
            containment: $N[0],
            axis: c.dir == 'horz' ? 'y' : 'x',
            delay: 0,
            distance: 1,
            grid: o.resizingGrid,
            helper: 'clone',
            opacity: o.resizerDragOpacity,
            addClasses: false,
            zIndex: z.resizer_drag,
            start: function (e, ui) {
              o = options[pane];
              s = state[pane];
              live = o.livePaneResizing;
              if (false === _runCallbacks('ondrag_start', pane))
                return false;
              s.isResizing = true;
              state.paneResizing = pane;
              timer.clear(pane + '_closeSlider');
              setSizeLimits(pane);
              r = s.resizerPosition;
              lastPos = ui.position[side];
              $R.addClass(resizerClass + ' ' + resizerPaneClass);
              helperClassesSet = false;
              $('body').disableSelection();
              showMasks(pane, { resizing: true });
            },
            drag: function (e, ui) {
              if (!helperClassesSet) {
                ui.helper.addClass(helperClass + ' ' + helperPaneClass).css({
                  right: 'auto',
                  bottom: 'auto'
                }).children().css('visibility', 'hidden');
                ;
                helperClassesSet = true;
                if (s.isSliding)
                  $Ps[pane].css('zIndex', z.pane_sliding);
              }
              var limit = 0;
              if (ui.position[side] < r.min) {
                ui.position[side] = r.min;
                limit = -1;
              } else if (ui.position[side] > r.max) {
                ui.position[side] = r.max;
                limit = 1;
              }
              if (limit) {
                ui.helper.addClass(helperLimitClass + ' ' + helperPaneLimitClass);
                window.defaultStatus = limit > 0 && pane.match(/(north|west)/) || limit < 0 && pane.match(/(south|east)/) ? o.tips.maxSizeWarning : o.tips.minSizeWarning;
              } else {
                ui.helper.removeClass(helperLimitClass + ' ' + helperPaneLimitClass);
                window.defaultStatus = '';
              }
              if (live && Math.abs(ui.position[side] - lastPos) >= o.liveResizingTolerance) {
                lastPos = ui.position[side];
                resizePanes(e, ui, pane);
              }
            },
            stop: function (e, ui) {
              $('body').enableSelection();
              window.defaultStatus = '';
              $R.removeClass(resizerClass + ' ' + resizerPaneClass);
              s.isResizing = false;
              state.paneResizing = false;
              resizePanes(e, ui, pane, true);
            }
          });
        });
        var resizePanes = function (evt, ui, pane, resizingDone) {
          var dragPos = ui.position, c = _c[pane], o = options[pane], s = state[pane], resizerPos;
          ;
          switch (pane) {
          case 'north':
            resizerPos = dragPos.top;
            break;
          case 'west':
            resizerPos = dragPos.left;
            break;
          case 'south':
            resizerPos = sC.layoutHeight - dragPos.top - o.spacing_open;
            break;
          case 'east':
            resizerPos = sC.layoutWidth - dragPos.left - o.spacing_open;
            break;
          }
          ;
          var newSize = resizerPos - sC.inset[c.side];
          if (!resizingDone) {
            if (Math.abs(newSize - s.size) < o.liveResizingTolerance)
              return;
            manualSizePane(pane, newSize, false, true);
            sizeMasks();
          } else {
            if (false !== _runCallbacks('ondrag_end', pane))
              manualSizePane(pane, newSize, false, true);
            hideMasks(true);
            if (s.isSliding)
              showMasks(pane, { resizing: true });
          }
        };
      }, sizeMask = function () {
        var $M = $(this), pane = $M.data('layoutMask'), s = state[pane];
        ;
        if (s.tagName == 'IFRAME' && s.isVisible)
          $M.css({
            top: s.offsetTop,
            left: s.offsetLeft,
            width: s.outerWidth,
            height: s.outerHeight
          });
      }, sizeMasks = function () {
        $Ms.each(sizeMask);
      }, showMasks = function (pane, args) {
        var c = _c[pane], panes = ['center'], z = options.zIndexes, a = $.extend({
            objectsOnly: false,
            animation: false,
            resizing: true,
            sliding: state[pane].isSliding
          }, args), o, s;
        ;
        if (a.resizing)
          panes.push(pane);
        if (a.sliding)
          panes.push(_c.oppositeEdge[pane]);
        if (c.dir === 'horz') {
          panes.push('west');
          panes.push('east');
        }
        $.each(panes, function (i, p) {
          s = state[p];
          o = options[p];
          if (s.isVisible && (o.maskObjects || !a.objectsOnly && o.maskContents)) {
            getMasks(p).each(function () {
              sizeMask.call(this);
              this.style.zIndex = s.isSliding ? z.pane_sliding + 1 : z.pane_normal + 1;
              this.style.display = 'block';
            });
          }
        });
      }, hideMasks = function (force) {
        if (force || !state.paneResizing) {
          $Ms.hide();
        } else if (!force && !$.isEmptyObject(state.panesSliding)) {
          var i = $Ms.length - 1, p, $M;
          for (; i >= 0; i--) {
            $M = $Ms.eq(i);
            p = $M.data('layoutMask');
            if (!options[p].maskObjects) {
              $M.hide();
            }
          }
        }
      }, getMasks = function (pane) {
        var $Masks = $([]), $M, i = 0, c = $Ms.length;
        ;
        for (; i < c; i++) {
          $M = $Ms.eq(i);
          if ($M.data('layoutMask') === pane)
            $Masks = $Masks.add($M);
        }
        if ($Masks.length)
          return $Masks;
        else
          return createMasks(pane);
      }, createMasks = function (pane) {
        var $P = $Ps[pane], s = state[pane], o = options[pane], z = options.zIndexes, $Masks = $([]), isIframe, el, $M, css, i;
        ;
        if (!o.maskContents && !o.maskObjects)
          return $Masks;
        for (i = 0; i < (o.maskObjects ? 2 : 1); i++) {
          isIframe = o.maskObjects && i == 0;
          el = document.createElement(isIframe ? 'iframe' : 'div');
          $M = $(el).data('layoutMask', pane);
          el.className = 'ui-layout-mask ui-layout-mask-' + pane;
          css = el.style;
          css.display = 'block';
          css.position = 'absolute';
          css.background = '#FFF';
          if (isIframe) {
            el.frameborder = 0;
            el.src = 'about:blank';
            css.opacity = 0;
            css.filter = 'Alpha(Opacity=\'0\')';
            css.border = 0;
          }
          if (s.tagName == 'IFRAME') {
            css.zIndex = z.pane_normal + 1;
            $N.append(el);
          } else {
            $M.addClass('ui-layout-mask-inside-pane');
            css.zIndex = o.maskZindex || z.content_mask;
            css.top = 0;
            css.left = 0;
            css.width = '100%';
            css.height = '100%';
            $P.append(el);
          }
          $Masks = $Masks.add(el);
          $Ms = $Ms.add(el);
        }
        return $Masks;
      }, destroy = function (evt_or_destroyChildren, destroyChildren) {
        $(window).unbind('.' + sID);
        $(document).unbind('.' + sID);
        if (typeof evt_or_destroyChildren === 'object')
          evtPane(evt_or_destroyChildren);
        else
          destroyChildren = evt_or_destroyChildren;
        $N.clearQueue().removeData('layout').removeData('layoutContainer').removeClass(options.containerClass).unbind('.' + sID);
        ;
        $Ms.remove();
        $.each(_c.allPanes, function (i, pane) {
          removePane(pane, false, true, destroyChildren);
        });
        var css = 'layoutCSS';
        if ($N.data(css) && !$N.data('layoutRole'))
          $N.css($N.data(css)).removeData(css);
        if (sC.tagName === 'BODY' && ($N = $('html')).data(css))
          $N.css($N.data(css)).removeData(css);
        runPluginCallbacks(Instance, $.layout.onDestroy);
        unload();
        for (var n in Instance)
          if (!n.match(/^(container|options)$/))
            delete Instance[n];
        Instance.destroyed = true;
        return Instance;
      }, removePane = function (evt_or_pane, remove, skipResize, destroyChild) {
        if (!isInitialized())
          return;
        var pane = evtPane.call(this, evt_or_pane), $P = $Ps[pane], $C = $Cs[pane], $R = $Rs[pane], $T = $Ts[pane];
        ;
        if ($P && $.isEmptyObject($P.data()))
          $P = false;
        if ($C && $.isEmptyObject($C.data()))
          $C = false;
        if ($R && $.isEmptyObject($R.data()))
          $R = false;
        if ($T && $.isEmptyObject($T.data()))
          $T = false;
        if ($P)
          $P.stop(true, true);
        var o = options[pane], s = state[pane], d = 'layout', css = 'layoutCSS', pC = children[pane], hasChildren = $.isPlainObject(pC) && !$.isEmptyObject(pC), destroy = destroyChild !== undefined ? destroyChild : o.destroyChildren;
        ;
        if (hasChildren && destroy) {
          $.each(pC, function (key, child) {
            if (!child.destroyed)
              child.destroy(true);
            if (child.destroyed)
              delete pC[key];
          });
          if ($.isEmptyObject(pC)) {
            pC = children[pane] = null;
            hasChildren = false;
          }
        }
        if ($P && remove && !hasChildren)
          $P.remove();
        else if ($P && $P[0]) {
          var root = o.paneClass, pRoot = root + '-' + pane, _open = '-open', _sliding = '-sliding', _closed = '-closed', classes = [
              root,
              root + _open,
              root + _closed,
              root + _sliding,
              pRoot,
              pRoot + _open,
              pRoot + _closed,
              pRoot + _sliding
            ];
          ;
          $.merge(classes, getHoverClasses($P, true));
          $P.removeClass(classes.join(' ')).removeData('parentLayout').removeData('layoutPane').removeData('layoutRole').removeData('layoutEdge').removeData('autoHidden').unbind('.' + sID);
          ;
          if (hasChildren && $C) {
            $C.width($C.width());
            $.each(pC, function (key, child) {
              child.resizeAll();
            });
          } else if ($C)
            $C.css($C.data(css)).removeData(css).removeData('layoutRole');
          if (!$P.data(d))
            $P.css($P.data(css)).removeData(css);
        }
        if ($T)
          $T.remove();
        if ($R)
          $R.remove();
        Instance[pane] = $Ps[pane] = $Cs[pane] = $Rs[pane] = $Ts[pane] = false;
        s = { removed: true };
        if (!skipResize)
          resizeAll();
      }, _hidePane = function (pane) {
        var $P = $Ps[pane], o = options[pane], s = $P[0].style;
        ;
        if (o.useOffscreenClose) {
          if (!$P.data(_c.offscreenReset))
            $P.data(_c.offscreenReset, {
              left: s.left,
              right: s.right
            });
          $P.css(_c.offscreenCSS);
        } else
          $P.hide().removeData(_c.offscreenReset);
      }, _showPane = function (pane) {
        var $P = $Ps[pane], o = options[pane], off = _c.offscreenCSS, old = $P.data(_c.offscreenReset), s = $P[0].style;
        ;
        $P.show().removeData(_c.offscreenReset);
        if (o.useOffscreenClose && old) {
          if (s.left == off.left)
            s.left = old.left;
          if (s.right == off.right)
            s.right = old.right;
        }
      }, hide = function (evt_or_pane, noAnimation) {
        if (!isInitialized())
          return;
        var pane = evtPane.call(this, evt_or_pane), o = options[pane], s = state[pane], $P = $Ps[pane], $R = $Rs[pane];
        ;
        if (!$P || s.isHidden)
          return;
        if (state.initialized && false === _runCallbacks('onhide_start', pane))
          return;
        s.isSliding = false;
        delete state.panesSliding[pane];
        if ($R)
          $R.hide();
        if (!state.initialized || s.isClosed) {
          s.isClosed = true;
          s.isHidden = true;
          s.isVisible = false;
          if (!state.initialized)
            _hidePane(pane);
          sizeMidPanes(_c[pane].dir === 'horz' ? '' : 'center');
          if (state.initialized || o.triggerEventsOnLoad)
            _runCallbacks('onhide_end', pane);
        } else {
          s.isHiding = true;
          close(pane, false, noAnimation);
        }
      }, show = function (evt_or_pane, openPane, noAnimation, noAlert) {
        if (!isInitialized())
          return;
        var pane = evtPane.call(this, evt_or_pane), o = options[pane], s = state[pane], $P = $Ps[pane], $R = $Rs[pane];
        ;
        if (!$P || !s.isHidden)
          return;
        if (false === _runCallbacks('onshow_start', pane))
          return;
        s.isShowing = true;
        s.isSliding = false;
        delete state.panesSliding[pane];
        if (openPane === false)
          close(pane, true);
        else
          open(pane, false, noAnimation, noAlert);
      }, toggle = function (evt_or_pane, slide) {
        if (!isInitialized())
          return;
        var evt = evtObj(evt_or_pane), pane = evtPane.call(this, evt_or_pane), s = state[pane];
        ;
        if (evt)
          evt.stopImmediatePropagation();
        if (s.isHidden)
          show(pane);
        else if (s.isClosed)
          open(pane, !!slide);
        else
          close(pane);
      }, _closePane = function (pane, setHandles) {
        var $P = $Ps[pane], s = state[pane];
        ;
        _hidePane(pane);
        s.isClosed = true;
        s.isVisible = false;
        if (setHandles)
          setAsClosed(pane);
      }, close = function (evt_or_pane, force, noAnimation, skipCallback) {
        var pane = evtPane.call(this, evt_or_pane);
        if (!state.initialized && $Ps[pane]) {
          _closePane(pane, true);
          return;
        }
        if (!isInitialized())
          return;
        var $P = $Ps[pane], $R = $Rs[pane], $T = $Ts[pane], o = options[pane], s = state[pane], c = _c[pane], doFX, isShowing, isHiding, wasSliding;
        $N.queue(function (queueNext) {
          if (!$P || !o.closable && !s.isShowing && !s.isHiding || !force && s.isClosed && !s.isShowing)
            return queueNext();
          var abort = !s.isShowing && false === _runCallbacks('onclose_start', pane);
          isShowing = s.isShowing;
          isHiding = s.isHiding;
          wasSliding = s.isSliding;
          delete s.isShowing;
          delete s.isHiding;
          if (abort)
            return queueNext();
          doFX = !noAnimation && !s.isClosed && o.fxName_close != 'none';
          s.isMoving = true;
          s.isClosed = true;
          s.isVisible = false;
          if (isHiding)
            s.isHidden = true;
          else if (isShowing)
            s.isHidden = false;
          if (s.isSliding)
            bindStopSlidingEvents(pane, false);
          else
            sizeMidPanes(_c[pane].dir === 'horz' ? '' : 'center', false);
          setAsClosed(pane);
          if (doFX) {
            lockPaneForFX(pane, true);
            $P.hide(o.fxName_close, o.fxSettings_close, o.fxSpeed_close, function () {
              lockPaneForFX(pane, false);
              if (s.isClosed)
                close_2();
              queueNext();
            });
          } else {
            _hidePane(pane);
            close_2();
            queueNext();
          }
          ;
        });
        function close_2() {
          s.isMoving = false;
          bindStartSlidingEvents(pane, true);
          var altPane = _c.oppositeEdge[pane];
          if (state[altPane].noRoom) {
            setSizeLimits(altPane);
            makePaneFit(altPane);
          }
          if (!skipCallback && (state.initialized || o.triggerEventsOnLoad)) {
            if (!isShowing)
              _runCallbacks('onclose_end', pane);
            if (isShowing)
              _runCallbacks('onshow_end', pane);
            if (isHiding)
              _runCallbacks('onhide_end', pane);
          }
        }
      }, setAsClosed = function (pane) {
        if (!$Rs[pane])
          return;
        var $P = $Ps[pane], $R = $Rs[pane], $T = $Ts[pane], o = options[pane], s = state[pane], side = _c[pane].side, rClass = o.resizerClass, tClass = o.togglerClass, _pane = '-' + pane, _open = '-open', _sliding = '-sliding', _closed = '-closed';
        ;
        $R.css(side, sC.inset[side]).removeClass(rClass + _open + ' ' + rClass + _pane + _open).removeClass(rClass + _sliding + ' ' + rClass + _pane + _sliding).addClass(rClass + _closed + ' ' + rClass + _pane + _closed);
        ;
        if (o.resizable && $.layout.plugins.draggable)
          $R.draggable('disable').removeClass('ui-state-disabled').css('cursor', 'default').attr('title', '');
        ;
        if ($T) {
          $T.removeClass(tClass + _open + ' ' + tClass + _pane + _open).addClass(tClass + _closed + ' ' + tClass + _pane + _closed).attr('title', o.tips.Open);
          ;
          $T.children('.content-open').hide();
          $T.children('.content-closed').css('display', 'block');
        }
        syncPinBtns(pane, false);
        if (state.initialized) {
          sizeHandles();
        }
      }, open = function (evt_or_pane, slide, noAnimation, noAlert) {
        if (!isInitialized())
          return;
        var pane = evtPane.call(this, evt_or_pane), $P = $Ps[pane], $R = $Rs[pane], $T = $Ts[pane], o = options[pane], s = state[pane], c = _c[pane], doFX, isShowing;
        ;
        $N.queue(function (queueNext) {
          if (!$P || !o.resizable && !o.closable && !s.isShowing || s.isVisible && !s.isSliding)
            return queueNext();
          if (s.isHidden && !s.isShowing) {
            queueNext();
            show(pane, true);
            return;
          }
          if (s.autoResize && s.size != o.size)
            sizePane(pane, o.size, true, true, true);
          else
            setSizeLimits(pane, slide);
          var cbReturn = _runCallbacks('onopen_start', pane);
          if (cbReturn === 'abort')
            return queueNext();
          if (cbReturn !== 'NC')
            setSizeLimits(pane, slide);
          if (s.minSize > s.maxSize) {
            syncPinBtns(pane, false);
            if (!noAlert && o.tips.noRoomToOpen)
              alert(o.tips.noRoomToOpen);
            return queueNext();
          }
          if (slide)
            bindStopSlidingEvents(pane, true);
          else if (s.isSliding)
            bindStopSlidingEvents(pane, false);
          else if (o.slidable)
            bindStartSlidingEvents(pane, false);
          s.noRoom = false;
          makePaneFit(pane);
          isShowing = s.isShowing;
          delete s.isShowing;
          doFX = !noAnimation && s.isClosed && o.fxName_open != 'none';
          s.isMoving = true;
          s.isVisible = true;
          s.isClosed = false;
          if (isShowing)
            s.isHidden = false;
          if (doFX) {
            lockPaneForFX(pane, true);
            $P.show(o.fxName_open, o.fxSettings_open, o.fxSpeed_open, function () {
              lockPaneForFX(pane, false);
              if (s.isVisible)
                open_2();
              queueNext();
            });
          } else {
            _showPane(pane);
            open_2();
            queueNext();
          }
          ;
        });
        function open_2() {
          s.isMoving = false;
          _fixIframe(pane);
          if (!s.isSliding) {
            sizeMidPanes(_c[pane].dir == 'vert' ? 'center' : '', false);
          }
          setAsOpen(pane);
        }
        ;
      }, setAsOpen = function (pane, skipCallback) {
        var $P = $Ps[pane], $R = $Rs[pane], $T = $Ts[pane], o = options[pane], s = state[pane], side = _c[pane].side, rClass = o.resizerClass, tClass = o.togglerClass, _pane = '-' + pane, _open = '-open', _closed = '-closed', _sliding = '-sliding';
        ;
        $R.css(side, sC.inset[side] + getPaneSize(pane)).removeClass(rClass + _closed + ' ' + rClass + _pane + _closed).addClass(rClass + _open + ' ' + rClass + _pane + _open);
        ;
        if (s.isSliding)
          $R.addClass(rClass + _sliding + ' ' + rClass + _pane + _sliding);
        else
          $R.removeClass(rClass + _sliding + ' ' + rClass + _pane + _sliding);
        removeHover(0, $R);
        if (o.resizable && $.layout.plugins.draggable)
          $R.draggable('enable').css('cursor', o.resizerCursor).attr('title', o.tips.Resize);
        else if (!s.isSliding)
          $R.css('cursor', 'default');
        if ($T) {
          $T.removeClass(tClass + _closed + ' ' + tClass + _pane + _closed).addClass(tClass + _open + ' ' + tClass + _pane + _open).attr('title', o.tips.Close);
          removeHover(0, $T);
          $T.children('.content-closed').hide();
          $T.children('.content-open').css('display', 'block');
        }
        syncPinBtns(pane, !s.isSliding);
        $.extend(s, elDims($P));
        if (state.initialized) {
          sizeHandles();
          sizeContent(pane, true);
        }
        if (!skipCallback && (state.initialized || o.triggerEventsOnLoad) && $P.is(':visible')) {
          _runCallbacks('onopen_end', pane);
          if (s.isShowing)
            _runCallbacks('onshow_end', pane);
          if (state.initialized)
            _runCallbacks('onresize_end', pane);
        }
      }, slideOpen = function (evt_or_pane) {
        if (!isInitialized())
          return;
        var evt = evtObj(evt_or_pane), pane = evtPane.call(this, evt_or_pane), s = state[pane], delay = options[pane].slideDelay_open;
        ;
        if (evt)
          evt.stopImmediatePropagation();
        if (s.isClosed && evt && evt.type === 'mouseenter' && delay > 0)
          timer.set(pane + '_openSlider', open_NOW, delay);
        else
          open_NOW();
        function open_NOW() {
          if (!s.isClosed)
            bindStopSlidingEvents(pane, true);
          else if (!s.isMoving)
            open(pane, true);
        }
        ;
      }, slideClose = function (evt_or_pane) {
        if (!isInitialized())
          return;
        var evt = evtObj(evt_or_pane), pane = evtPane.call(this, evt_or_pane), o = options[pane], s = state[pane], delay = s.isMoving ? 1000 : 300;
        ;
        if (s.isClosed || s.isResizing)
          return;
        else if (o.slideTrigger_close === 'click')
          close_NOW();
        else if (o.preventQuickSlideClose && s.isMoving)
          return;
        else if (o.preventPrematureSlideClose && evt && $.layout.isMouseOverElem(evt, $Ps[pane]))
          return;
        else if (evt)
          timer.set(pane + '_closeSlider', close_NOW, max(o.slideDelay_close, delay));
        else
          close_NOW();
        function close_NOW() {
          if (s.isClosed)
            bindStopSlidingEvents(pane, false);
          else if (!s.isMoving)
            close(pane);
        }
        ;
      }, slideToggle = function (evt_or_pane) {
        var pane = evtPane.call(this, evt_or_pane);
        toggle(pane, true);
      }, lockPaneForFX = function (pane, doLock) {
        var $P = $Ps[pane], s = state[pane], o = options[pane], z = options.zIndexes;
        ;
        if (doLock) {
          showMasks(pane, {
            animation: true,
            objectsOnly: true
          });
          $P.css({ zIndex: z.pane_animate });
          if (pane == 'south')
            $P.css({ top: sC.inset.top + sC.innerHeight - $P.outerHeight() });
          else if (pane == 'east')
            $P.css({ left: sC.inset.left + sC.innerWidth - $P.outerWidth() });
        } else {
          hideMasks();
          $P.css({ zIndex: s.isSliding ? z.pane_sliding : z.pane_normal });
          if (pane == 'south')
            $P.css({ top: 'auto' });
          else if (pane == 'east' && !$P.css('left').match(/\-99999/))
            $P.css({ left: 'auto' });
          if (browser.msie && o.fxOpacityFix && o.fxName_open != 'slide' && $P.css('filter') && $P.css('opacity') == 1)
            $P[0].style.removeAttribute('filter');
        }
      }, bindStartSlidingEvents = function (pane, enable) {
        var o = options[pane], $P = $Ps[pane], $R = $Rs[pane], evtName = o.slideTrigger_open.toLowerCase();
        ;
        if (!$R || enable && !o.slidable)
          return;
        if (evtName.match(/mouseover/))
          evtName = o.slideTrigger_open = 'mouseenter';
        else if (!evtName.match(/(click|dblclick|mouseenter)/))
          evtName = o.slideTrigger_open = 'click';
        if (o.resizerDblClickToggle && evtName.match(/click/)) {
          $R[enable ? 'unbind' : 'bind']('dblclick.' + sID, toggle);
        }
        $R[enable ? 'bind' : 'unbind'](evtName + '.' + sID, slideOpen).css('cursor', enable ? o.sliderCursor : 'default').attr('title', enable ? o.tips.Slide : '');
        ;
      }, bindStopSlidingEvents = function (pane, enable) {
        var o = options[pane], s = state[pane], c = _c[pane], z = options.zIndexes, evtName = o.slideTrigger_close.toLowerCase(), action = enable ? 'bind' : 'unbind', $P = $Ps[pane], $R = $Rs[pane];
        ;
        timer.clear(pane + '_closeSlider');
        if (enable) {
          s.isSliding = true;
          state.panesSliding[pane] = true;
          bindStartSlidingEvents(pane, false);
        } else {
          s.isSliding = false;
          delete state.panesSliding[pane];
        }
        $P.css('zIndex', enable ? z.pane_sliding : z.pane_normal);
        $R.css('zIndex', enable ? z.pane_sliding + 2 : z.resizer_normal);
        if (!evtName.match(/(click|mouseleave)/))
          evtName = o.slideTrigger_close = 'mouseleave';
        $R[action](evtName, slideClose);
        if (evtName === 'mouseleave') {
          $P[action]('mouseleave.' + sID, slideClose);
          $R[action]('mouseenter.' + sID, cancelMouseOut);
          $P[action]('mouseenter.' + sID, cancelMouseOut);
        }
        if (!enable)
          timer.clear(pane + '_closeSlider');
        else if (evtName === 'click' && !o.resizable) {
          $R.css('cursor', enable ? o.sliderCursor : 'default');
          $R.attr('title', enable ? o.tips.Close : '');
        }
        function cancelMouseOut(evt) {
          timer.clear(pane + '_closeSlider');
          evt.stopPropagation();
        }
      }, makePaneFit = function (pane, isOpening, skipCallback, force) {
        var o = options[pane], s = state[pane], c = _c[pane], $P = $Ps[pane], $R = $Rs[pane], isSidePane = c.dir === 'vert', hasRoom = false;
        ;
        if (pane === 'center' || isSidePane && s.noVerticalRoom) {
          hasRoom = s.maxHeight >= 0;
          if (hasRoom && s.noRoom) {
            _showPane(pane);
            if ($R)
              $R.show();
            s.isVisible = true;
            s.noRoom = false;
            if (isSidePane)
              s.noVerticalRoom = false;
            _fixIframe(pane);
          } else if (!hasRoom && !s.noRoom) {
            _hidePane(pane);
            if ($R)
              $R.hide();
            s.isVisible = false;
            s.noRoom = true;
          }
        }
        if (pane === 'center') {
        } else if (s.minSize <= s.maxSize) {
          hasRoom = true;
          if (s.size > s.maxSize)
            sizePane(pane, s.maxSize, skipCallback, true, force);
          else if (s.size < s.minSize)
            sizePane(pane, s.minSize, skipCallback, true, force);
          else if ($R && s.isVisible && $P.is(':visible')) {
            var pos = s.size + sC.inset[c.side];
            if ($.layout.cssNum($R, c.side) != pos)
              $R.css(c.side, pos);
          }
          if (s.noRoom) {
            if (s.wasOpen && o.closable) {
              if (o.autoReopen)
                open(pane, false, true, true);
              else
                s.noRoom = false;
            } else
              show(pane, s.wasOpen, true, true);
          }
        } else {
          if (!s.noRoom) {
            s.noRoom = true;
            s.wasOpen = !s.isClosed && !s.isSliding;
            if (s.isClosed) {
            } else if (o.closable)
              close(pane, true, true);
            else
              hide(pane, true);
          }
        }
      }, manualSizePane = function (evt_or_pane, size, skipCallback, noAnimation, force) {
        if (!isInitialized())
          return;
        var pane = evtPane.call(this, evt_or_pane), o = options[pane], s = state[pane], forceResize = force || o.livePaneResizing && !s.isResizing;
        ;
        s.autoResize = false;
        sizePane(pane, size, skipCallback, noAnimation, forceResize);
      }, sizePane = function (evt_or_pane, size, skipCallback, noAnimation, force) {
        if (!isInitialized())
          return;
        var pane = evtPane.call(this, evt_or_pane), o = options[pane], s = state[pane], $P = $Ps[pane], $R = $Rs[pane], side = _c[pane].side, dimName = _c[pane].sizeType.toLowerCase(), skipResizeWhileDragging = s.isResizing && !o.triggerEventsDuringLiveResize, doFX = noAnimation !== true && o.animatePaneSizing, oldSize, newSize;
        ;
        $N.queue(function (queueNext) {
          setSizeLimits(pane);
          oldSize = s.size;
          size = _parseSize(pane, size);
          size = max(size, _parseSize(pane, o.minSize));
          size = min(size, s.maxSize);
          if (size < s.minSize) {
            queueNext();
            makePaneFit(pane, false, skipCallback);
            return;
          }
          if (!force && size === oldSize)
            return queueNext();
          s.newSize = size;
          if (!skipCallback && state.initialized && s.isVisible)
            _runCallbacks('onresize_start', pane);
          newSize = cssSize(pane, size);
          if (doFX && $P.is(':visible')) {
            var fx = $.layout.effects.size[pane] || $.layout.effects.size.all, easing = o.fxSettings_size.easing || fx.easing, z = options.zIndexes, props = {};
            props[dimName] = newSize + 'px';
            s.isMoving = true;
            $P.css({ zIndex: z.pane_animate }).show().animate(props, o.fxSpeed_size, easing, function () {
              $P.css({ zIndex: s.isSliding ? z.pane_sliding : z.pane_normal });
              s.isMoving = false;
              delete s.newSize;
              sizePane_2();
              queueNext();
            });
          } else {
            $P.css(dimName, newSize);
            delete s.newSize;
            if ($P.is(':visible'))
              sizePane_2();
            else {
              s.size = size;
              $.extend(s, elDims($P));
            }
            queueNext();
          }
          ;
        });
        function sizePane_2() {
          var actual = dimName === 'width' ? $P.outerWidth() : $P.outerHeight(), tries = [{
                pane: pane,
                count: 1,
                target: size,
                actual: actual,
                correct: size === actual,
                attempt: size,
                cssSize: newSize
              }], lastTry = tries[0], thisTry = {}, msg = 'Inaccurate size after resizing the ' + pane + '-pane.';
          ;
          while (!lastTry.correct) {
            thisTry = {
              pane: pane,
              count: lastTry.count + 1,
              target: size
            };
            if (lastTry.actual > size)
              thisTry.attempt = max(0, lastTry.attempt - (lastTry.actual - size));
            else
              thisTry.attempt = max(0, lastTry.attempt + (size - lastTry.actual));
            thisTry.cssSize = cssSize(pane, thisTry.attempt);
            $P.css(dimName, thisTry.cssSize);
            thisTry.actual = dimName == 'width' ? $P.outerWidth() : $P.outerHeight();
            thisTry.correct = size === thisTry.actual;
            if (tries.length === 1) {
              _log(msg, false, true);
              _log(lastTry, false, true);
            }
            _log(thisTry, false, true);
            if (tries.length > 3)
              break;
            tries.push(thisTry);
            lastTry = tries[tries.length - 1];
          }
          s.size = size;
          $.extend(s, elDims($P));
          if (s.isVisible && $P.is(':visible')) {
            if ($R)
              $R.css(side, size + sC.inset[side]);
            sizeContent(pane);
          }
          if (!skipCallback && !skipResizeWhileDragging && state.initialized && s.isVisible)
            _runCallbacks('onresize_end', pane);
          if (!skipCallback) {
            if (!s.isSliding)
              sizeMidPanes(_c[pane].dir == 'horz' ? '' : 'center', skipResizeWhileDragging, force);
            sizeHandles();
          }
          var altPane = _c.oppositeEdge[pane];
          if (size < oldSize && state[altPane].noRoom) {
            setSizeLimits(altPane);
            makePaneFit(altPane, false, skipCallback);
          }
          if (tries.length > 1)
            _log(msg + '\nSee the Error Console for details.', true, true);
        }
      }, sizeMidPanes = function (panes, skipCallback, force) {
        panes = (panes ? panes : 'east,west,center').split(',');
        $.each(panes, function (i, pane) {
          if (!$Ps[pane])
            return;
          var o = options[pane], s = state[pane], $P = $Ps[pane], $R = $Rs[pane], isCenter = pane == 'center', hasRoom = true, CSS = {}, visCSS = $.layout.showInvisibly($P), newCenter = calcNewCenterPaneDims();
          ;
          $.extend(s, elDims($P));
          if (pane === 'center') {
            if (!force && s.isVisible && newCenter.width === s.outerWidth && newCenter.height === s.outerHeight) {
              $P.css(visCSS);
              return true;
            }
            $.extend(s, cssMinDims(pane), {
              maxWidth: newCenter.width,
              maxHeight: newCenter.height
            });
            CSS = newCenter;
            s.newWidth = CSS.width;
            s.newHeight = CSS.height;
            CSS.width = cssW($P, CSS.width);
            CSS.height = cssH($P, CSS.height);
            hasRoom = CSS.width >= 0 && CSS.height >= 0;
            if (!state.initialized && o.minWidth > newCenter.width) {
              var reqPx = o.minWidth - s.outerWidth, minE = options.east.minSize || 0, minW = options.west.minSize || 0, sizeE = state.east.size, sizeW = state.west.size, newE = sizeE, newW = sizeW;
              ;
              if (reqPx > 0 && state.east.isVisible && sizeE > minE) {
                newE = max(sizeE - minE, sizeE - reqPx);
                reqPx -= sizeE - newE;
              }
              if (reqPx > 0 && state.west.isVisible && sizeW > minW) {
                newW = max(sizeW - minW, sizeW - reqPx);
                reqPx -= sizeW - newW;
              }
              if (reqPx === 0) {
                if (sizeE && sizeE != minE)
                  sizePane('east', newE, true, true, force);
                if (sizeW && sizeW != minW)
                  sizePane('west', newW, true, true, force);
                sizeMidPanes('center', skipCallback, force);
                $P.css(visCSS);
                return;
              }
            }
          } else {
            if (s.isVisible && !s.noVerticalRoom)
              $.extend(s, elDims($P), cssMinDims(pane));
            if (!force && !s.noVerticalRoom && newCenter.height === s.outerHeight) {
              $P.css(visCSS);
              return true;
            }
            CSS.top = newCenter.top;
            CSS.bottom = newCenter.bottom;
            s.newSize = newCenter.height;
            CSS.height = cssH($P, newCenter.height);
            s.maxHeight = CSS.height;
            hasRoom = s.maxHeight >= 0;
            if (!hasRoom)
              s.noVerticalRoom = true;
          }
          if (hasRoom) {
            if (!skipCallback && state.initialized)
              _runCallbacks('onresize_start', pane);
            $P.css(CSS);
            if (pane !== 'center')
              sizeHandles(pane);
            if (s.noRoom && !s.isClosed && !s.isHidden)
              makePaneFit(pane);
            if (s.isVisible) {
              $.extend(s, elDims($P));
              if (state.initialized)
                sizeContent(pane);
            }
          } else if (!s.noRoom && s.isVisible)
            makePaneFit(pane);
          $P.css(visCSS);
          delete s.newSize;
          delete s.newWidth;
          delete s.newHeight;
          if (!s.isVisible)
            return true;
          if (pane === 'center') {
            var fix = browser.isIE6 || !browser.boxModel;
            if ($Ps.north && (fix || state.north.tagName == 'IFRAME'))
              $Ps.north.css('width', cssW($Ps.north, sC.innerWidth));
            if ($Ps.south && (fix || state.south.tagName == 'IFRAME'))
              $Ps.south.css('width', cssW($Ps.south, sC.innerWidth));
          }
          if (!skipCallback && state.initialized)
            _runCallbacks('onresize_end', pane);
        });
      }, resizeAll = function (evt_or_refresh) {
        var oldW = sC.innerWidth, oldH = sC.innerHeight;
        ;
        evtPane(evt_or_refresh);
        if (!$N.is(':visible'))
          return;
        if (!state.initialized) {
          _initLayoutElements();
          return;
        }
        if (evt_or_refresh === true && $.isPlainObject(options.outset)) {
          $N.css(options.outset);
        }
        $.extend(sC, elDims($N, options.inset));
        if (!sC.outerHeight)
          return;
        if (evt_or_refresh === true) {
          setPanePosition();
        }
        if (false === _runCallbacks('onresizeall_start'))
          return false;
        var shrunkH = sC.innerHeight < oldH, shrunkW = sC.innerWidth < oldW, $P, o, s;
        ;
        $.each([
          'south',
          'north',
          'east',
          'west'
        ], function (i, pane) {
          if (!$Ps[pane])
            return;
          o = options[pane];
          s = state[pane];
          if (s.autoResize && s.size != o.size)
            sizePane(pane, o.size, true, true, true);
          else {
            setSizeLimits(pane);
            makePaneFit(pane, false, true, true);
          }
        });
        sizeMidPanes('', true, true);
        sizeHandles();
        $.each(_c.allPanes, function (i, pane) {
          $P = $Ps[pane];
          if (!$P)
            return;
          if (state[pane].isVisible)
            _runCallbacks('onresize_end', pane);
        });
        _runCallbacks('onresizeall_end');
      }, resizeChildren = function (evt_or_pane, skipRefresh) {
        var pane = evtPane.call(this, evt_or_pane);
        if (!options[pane].resizeChildren)
          return;
        if (!skipRefresh)
          refreshChildren(pane);
        var pC = children[pane];
        if ($.isPlainObject(pC)) {
          $.each(pC, function (key, child) {
            if (!child.destroyed)
              child.resizeAll();
          });
        }
      }, sizeContent = function (evt_or_panes, remeasure) {
        if (!isInitialized())
          return;
        var panes = evtPane.call(this, evt_or_panes);
        panes = panes ? panes.split(',') : _c.allPanes;
        $.each(panes, function (idx, pane) {
          var $P = $Ps[pane], $C = $Cs[pane], o = options[pane], s = state[pane], m = s.content;
          ;
          if (!$P || !$C || !$P.is(':visible'))
            return true;
          if (!$C.length) {
            initContent(pane, false);
            if (!$C)
              return;
          }
          if (false === _runCallbacks('onsizecontent_start', pane))
            return;
          if (!s.isMoving && !s.isResizing || o.liveContentResizing || remeasure || m.top == undefined) {
            _measure();
            if (m.hiddenFooters > 0 && $P.css('overflow') === 'hidden') {
              $P.css('overflow', 'visible');
              _measure();
              $P.css('overflow', 'hidden');
            }
          }
          var newH = s.innerHeight - (m.spaceAbove - s.css.paddingTop) - (m.spaceBelow - s.css.paddingBottom);
          if (!$C.is(':visible') || m.height != newH) {
            setOuterHeight($C, newH, true);
            m.height = newH;
          }
          ;
          if (state.initialized)
            _runCallbacks('onsizecontent_end', pane);
          function _below($E) {
            return max(s.css.paddingBottom, parseInt($E.css('marginBottom'), 10) || 0);
          }
          ;
          function _measure() {
            var ignore = options[pane].contentIgnoreSelector, $Fs = $C.nextAll().not('.ui-layout-mask').not(ignore || ':lt(0)'), $Fs_vis = $Fs.filter(':visible'), $F = $Fs_vis.filter(':last');
            ;
            m = {
              top: $C[0].offsetTop,
              height: $C.outerHeight(),
              numFooters: $Fs.length,
              hiddenFooters: $Fs.length - $Fs_vis.length,
              spaceBelow: 0
            };
            m.spaceAbove = m.top;
            m.bottom = m.top + m.height;
            if ($F.length)
              m.spaceBelow = $F[0].offsetTop + $F.outerHeight() - m.bottom + _below($F);
            else
              m.spaceBelow = _below($C);
          }
          ;
        });
      }, sizeHandles = function (evt_or_panes) {
        var panes = evtPane.call(this, evt_or_panes);
        panes = panes ? panes.split(',') : _c.borderPanes;
        $.each(panes, function (i, pane) {
          var o = options[pane], s = state[pane], $P = $Ps[pane], $R = $Rs[pane], $T = $Ts[pane], $TC;
          ;
          if (!$P || !$R)
            return;
          var dir = _c[pane].dir, _state = s.isClosed ? '_closed' : '_open', spacing = o['spacing' + _state], togAlign = o['togglerAlign' + _state], togLen = o['togglerLength' + _state], paneLen, left, offset, CSS = {};
          ;
          if (spacing === 0) {
            $R.hide();
            return;
          } else if (!s.noRoom && !s.isHidden)
            $R.show();
          if (dir === 'horz') {
            paneLen = sC.innerWidth;
            s.resizerLength = paneLen;
            left = $.layout.cssNum($P, 'left');
            $R.css({
              width: cssW($R, paneLen),
              height: cssH($R, spacing),
              left: left > -9999 ? left : sC.inset.left
            });
          } else {
            paneLen = $P.outerHeight();
            s.resizerLength = paneLen;
            $R.css({
              height: cssH($R, paneLen),
              width: cssW($R, spacing),
              top: sC.inset.top + getPaneSize('north', true)
            });
          }
          removeHover(o, $R);
          if ($T) {
            if (togLen === 0 || s.isSliding && o.hideTogglerOnSlide) {
              $T.hide();
              return;
            } else
              $T.show();
            if (!(togLen > 0) || togLen === '100%' || togLen > paneLen) {
              togLen = paneLen;
              offset = 0;
            } else {
              if (isStr(togAlign)) {
                switch (togAlign) {
                case 'top':
                case 'left':
                  offset = 0;
                  break;
                case 'bottom':
                case 'right':
                  offset = paneLen - togLen;
                  break;
                case 'middle':
                case 'center':
                default:
                  offset = round((paneLen - togLen) / 2);
                }
              } else {
                var x = parseInt(togAlign, 10);
                if (togAlign >= 0)
                  offset = x;
                else
                  offset = paneLen - togLen + x;
              }
            }
            if (dir === 'horz') {
              var width = cssW($T, togLen);
              $T.css({
                width: width,
                height: cssH($T, spacing),
                left: offset,
                top: 0
              });
              $T.children('.content').each(function () {
                $TC = $(this);
                $TC.css('marginLeft', round((width - $TC.outerWidth()) / 2));
              });
            } else {
              var height = cssH($T, togLen);
              $T.css({
                height: height,
                width: cssW($T, spacing),
                top: offset,
                left: 0
              });
              $T.children('.content').each(function () {
                $TC = $(this);
                $TC.css('marginTop', round((height - $TC.outerHeight()) / 2));
              });
            }
            removeHover(0, $T);
          }
          if (!state.initialized && (o.initHidden || s.isHidden)) {
            $R.hide();
            if ($T)
              $T.hide();
          }
        });
      }, enableClosable = function (evt_or_pane) {
        if (!isInitialized())
          return;
        var pane = evtPane.call(this, evt_or_pane), $T = $Ts[pane], o = options[pane];
        ;
        if (!$T)
          return;
        o.closable = true;
        $T.bind('click.' + sID, function (evt) {
          evt.stopPropagation();
          toggle(pane);
        }).css('visibility', 'visible').css('cursor', 'pointer').attr('title', state[pane].isClosed ? o.tips.Open : o.tips.Close).show();
      }, disableClosable = function (evt_or_pane, hide) {
        if (!isInitialized())
          return;
        var pane = evtPane.call(this, evt_or_pane), $T = $Ts[pane];
        ;
        if (!$T)
          return;
        options[pane].closable = false;
        if (state[pane].isClosed)
          open(pane, false, true);
        $T.unbind('.' + sID).css('visibility', hide ? 'hidden' : 'visible').css('cursor', 'default').attr('title', '');
      }, enableSlidable = function (evt_or_pane) {
        if (!isInitialized())
          return;
        var pane = evtPane.call(this, evt_or_pane), $R = $Rs[pane];
        ;
        if (!$R || !$R.data('draggable'))
          return;
        options[pane].slidable = true;
        if (state[pane].isClosed)
          bindStartSlidingEvents(pane, true);
      }, disableSlidable = function (evt_or_pane) {
        if (!isInitialized())
          return;
        var pane = evtPane.call(this, evt_or_pane), $R = $Rs[pane];
        ;
        if (!$R)
          return;
        options[pane].slidable = false;
        if (state[pane].isSliding)
          close(pane, false, true);
        else {
          bindStartSlidingEvents(pane, false);
          $R.css('cursor', 'default').attr('title', '');
          removeHover(null, $R[0]);
        }
      }, enableResizable = function (evt_or_pane) {
        if (!isInitialized())
          return;
        var pane = evtPane.call(this, evt_or_pane), $R = $Rs[pane], o = options[pane];
        ;
        if (!$R || !$R.data('draggable'))
          return;
        o.resizable = true;
        $R.draggable('enable');
        if (!state[pane].isClosed)
          $R.css('cursor', o.resizerCursor).attr('title', o.tips.Resize);
      }, disableResizable = function (evt_or_pane) {
        if (!isInitialized())
          return;
        var pane = evtPane.call(this, evt_or_pane), $R = $Rs[pane];
        ;
        if (!$R || !$R.data('draggable'))
          return;
        options[pane].resizable = false;
        $R.draggable('disable').css('cursor', 'default').attr('title', '');
        removeHover(null, $R[0]);
      }, swapPanes = function (evt_or_pane1, pane2) {
        if (!isInitialized())
          return;
        var pane1 = evtPane.call(this, evt_or_pane1);
        state[pane1].edge = pane2;
        state[pane2].edge = pane1;
        if (false === _runCallbacks('onswap_start', pane1) || false === _runCallbacks('onswap_start', pane2)) {
          state[pane1].edge = pane1;
          state[pane2].edge = pane2;
          return;
        }
        var oPane1 = copy(pane1), oPane2 = copy(pane2), sizes = {};
        ;
        sizes[pane1] = oPane1 ? oPane1.state.size : 0;
        sizes[pane2] = oPane2 ? oPane2.state.size : 0;
        $Ps[pane1] = false;
        $Ps[pane2] = false;
        state[pane1] = {};
        state[pane2] = {};
        if ($Ts[pane1])
          $Ts[pane1].remove();
        if ($Ts[pane2])
          $Ts[pane2].remove();
        if ($Rs[pane1])
          $Rs[pane1].remove();
        if ($Rs[pane2])
          $Rs[pane2].remove();
        $Rs[pane1] = $Rs[pane2] = $Ts[pane1] = $Ts[pane2] = false;
        move(oPane1, pane2);
        move(oPane2, pane1);
        oPane1 = oPane2 = sizes = null;
        if ($Ps[pane1])
          $Ps[pane1].css(_c.visible);
        if ($Ps[pane2])
          $Ps[pane2].css(_c.visible);
        resizeAll();
        _runCallbacks('onswap_end', pane1);
        _runCallbacks('onswap_end', pane2);
        return;
        function copy(n) {
          var $P = $Ps[n], $C = $Cs[n];
          ;
          return !$P ? false : {
            pane: n,
            P: $P ? $P[0] : false,
            C: $C ? $C[0] : false,
            state: $.extend(true, {}, state[n]),
            options: $.extend(true, {}, options[n])
          };
        }
        ;
        function move(oPane, pane) {
          if (!oPane)
            return;
          var P = oPane.P, C = oPane.C, oldPane = oPane.pane, c = _c[pane], s = $.extend(true, {}, state[pane]), o = options[pane], fx = { resizerCursor: o.resizerCursor }, re, size, pos;
          ;
          $.each('fxName,fxSpeed,fxSettings'.split(','), function (i, k) {
            fx[k + '_open'] = o[k + '_open'];
            fx[k + '_close'] = o[k + '_close'];
            fx[k + '_size'] = o[k + '_size'];
          });
          $Ps[pane] = $(P).data({
            layoutPane: Instance[pane],
            layoutEdge: pane
          }).css(_c.hidden).css(c.cssReq);
          ;
          $Cs[pane] = C ? $(C) : false;
          options[pane] = $.extend(true, {}, oPane.options, fx);
          state[pane] = $.extend(true, {}, oPane.state);
          re = new RegExp(o.paneClass + '-' + oldPane, 'g');
          P.className = P.className.replace(re, o.paneClass + '-' + pane);
          initHandles(pane);
          if (c.dir != _c[oldPane].dir) {
            size = sizes[pane] || 0;
            setSizeLimits(pane);
            size = max(size, state[pane].minSize);
            manualSizePane(pane, size, true, true);
          } else
            $Rs[pane].css(c.side, sC.inset[c.side] + (state[pane].isVisible ? getPaneSize(pane) : 0));
          if (oPane.state.isVisible && !s.isVisible)
            setAsOpen(pane, true);
          else {
            setAsClosed(pane);
            bindStartSlidingEvents(pane, true);
          }
          oPane = null;
        }
        ;
      }, syncPinBtns = function (pane, doPin) {
        if ($.layout.plugins.buttons)
          $.each(state[pane].pins, function (i, selector) {
            $.layout.buttons.setPinState(Instance, $(selector), pane, doPin);
          });
      };
    ;
    function keyDown(evt) {
      if (!evt)
        return true;
      var code = evt.keyCode;
      if (code < 33)
        return true;
      var PANE = {
          38: 'north',
          40: 'south',
          37: 'west',
          39: 'east'
        }, ALT = evt.altKey, SHIFT = evt.shiftKey, CTRL = evt.ctrlKey, CURSOR = CTRL && code >= 37 && code <= 40, o, k, m, pane;
      ;
      if (CURSOR && options[PANE[code]].enableCursorHotkey)
        pane = PANE[code];
      else if (CTRL || SHIFT)
        $.each(_c.borderPanes, function (i, p) {
          o = options[p];
          k = o.customHotkey;
          m = o.customHotkeyModifier;
          if (SHIFT && m == 'SHIFT' || CTRL && m == 'CTRL' || CTRL && SHIFT) {
            if (k && code === (isNaN(k) || k <= 9 ? k.toUpperCase().charCodeAt(0) : k)) {
              pane = p;
              return false;
            }
          }
        });
      if (!pane || !$Ps[pane] || !options[pane].closable || state[pane].isHidden)
        return true;
      toggle(pane);
      evt.stopPropagation();
      evt.returnValue = false;
      return false;
    }
    ;
    function allowOverflow(el) {
      if (!isInitialized())
        return;
      if (this && this.tagName)
        el = this;
      var $P;
      if (isStr(el))
        $P = $Ps[el];
      else if ($(el).data('layoutRole'))
        $P = $(el);
      else
        $(el).parents().each(function () {
          if ($(this).data('layoutRole')) {
            $P = $(this);
            return false;
          }
        });
      if (!$P || !$P.length)
        return;
      var pane = $P.data('layoutEdge'), s = state[pane];
      ;
      if (s.cssSaved)
        resetOverflow(pane);
      if (s.isSliding || s.isResizing || s.isClosed) {
        s.cssSaved = false;
        return;
      }
      var newCSS = { zIndex: options.zIndexes.resizer_normal + 1 }, curCSS = {}, of = $P.css('overflow'), ofX = $P.css('overflowX'), ofY = $P.css('overflowY');
      ;
      if (of != 'visible') {
        curCSS.overflow = of;
        newCSS.overflow = 'visible';
      }
      if (ofX && !ofX.match(/(visible|auto)/)) {
        curCSS.overflowX = ofX;
        newCSS.overflowX = 'visible';
      }
      if (ofY && !ofY.match(/(visible|auto)/)) {
        curCSS.overflowY = ofX;
        newCSS.overflowY = 'visible';
      }
      s.cssSaved = curCSS;
      $P.css(newCSS);
      $.each(_c.allPanes, function (i, p) {
        if (p != pane)
          resetOverflow(p);
      });
    }
    ;
    function resetOverflow(el) {
      if (!isInitialized())
        return;
      if (this && this.tagName)
        el = this;
      var $P;
      if (isStr(el))
        $P = $Ps[el];
      else if ($(el).data('layoutRole'))
        $P = $(el);
      else
        $(el).parents().each(function () {
          if ($(this).data('layoutRole')) {
            $P = $(this);
            return false;
          }
        });
      if (!$P || !$P.length)
        return;
      var pane = $P.data('layoutEdge'), s = state[pane], CSS = s.cssSaved || {};
      ;
      if (!s.isSliding && !s.isResizing)
        $P.css('zIndex', options.zIndexes.pane_normal);
      $P.css(CSS);
      s.cssSaved = false;
    }
    ;
    var $N = $(this).eq(0);
    if (!$N.length) {
      return _log(options.errors.containerMissing);
    }
    ;
    if ($N.data('layoutContainer') && $N.data('layout'))
      return $N.data('layout');
    var $Ps = {}, $Cs = {}, $Rs = {}, $Ts = {}, $Ms = $([]), sC = state.container, sID = state.id;
    ;
    var Instance = {
        options: options,
        state: state,
        container: $N,
        panes: $Ps,
        contents: $Cs,
        resizers: $Rs,
        togglers: $Ts,
        hide: hide,
        show: show,
        toggle: toggle,
        open: open,
        close: close,
        slideOpen: slideOpen,
        slideClose: slideClose,
        slideToggle: slideToggle,
        setSizeLimits: setSizeLimits,
        _sizePane: sizePane,
        sizePane: manualSizePane,
        sizeContent: sizeContent,
        swapPanes: swapPanes,
        showMasks: showMasks,
        hideMasks: hideMasks,
        initContent: initContent,
        addPane: addPane,
        removePane: removePane,
        createChildren: createChildren,
        refreshChildren: refreshChildren,
        enableClosable: enableClosable,
        disableClosable: disableClosable,
        enableSlidable: enableSlidable,
        disableSlidable: disableSlidable,
        enableResizable: enableResizable,
        disableResizable: disableResizable,
        allowOverflow: allowOverflow,
        resetOverflow: resetOverflow,
        destroy: destroy,
        initPanes: isInitialized,
        resizeAll: resizeAll,
        runCallbacks: _runCallbacks,
        hasParentLayout: false,
        children: children,
        north: false,
        south: false,
        west: false,
        east: false,
        center: false
      };
    if (_create() === 'cancel')
      return null;
    else
      return Instance;
  };
}(jQuery));
(function ($) {
  if (!$.ui)
    $.ui = {};
  $.ui.cookie = {
    acceptsCookies: !!navigator.cookieEnabled,
    read: function (name) {
      var c = document.cookie, cs = c ? c.split(';') : [], pair;
      ;
      for (var i = 0, n = cs.length; i < n; i++) {
        pair = $.trim(cs[i]).split('=');
        if (pair[0] == name)
          return decodeURIComponent(pair[1]);
      }
      return null;
    },
    write: function (name, val, cookieOpts) {
      var params = '', date = '', clear = false, o = cookieOpts || {}, x = o.expires || null, t = $.type(x);
      ;
      if (t === 'date')
        date = x;
      else if (t === 'string' && x > 0) {
        x = parseInt(x, 10);
        t = 'number';
      }
      if (t === 'number') {
        date = new Date();
        if (x > 0)
          date.setDate(date.getDate() + x);
        else {
          date.setFullYear(1970);
          clear = true;
        }
      }
      if (date)
        params += ';expires=' + date.toUTCString();
      if (o.path)
        params += ';path=' + o.path;
      if (o.domain)
        params += ';domain=' + o.domain;
      if (o.secure)
        params += ';secure';
      document.cookie = name + '=' + (clear ? '' : encodeURIComponent(val)) + params;
    },
    clear: function (name) {
      $.ui.cookie.write(name, '', { expires: -1 });
    }
  };
  if (!$.cookie)
    $.cookie = function (k, v, o) {
      var C = $.ui.cookie;
      if (v === null)
        C.clear(k);
      else if (v === undefined)
        return C.read(k);
      else
        C.write(k, v, o);
    };
  $.layout.plugins.stateManagement = true;
  $.layout.config.optionRootKeys.push('stateManagement');
  $.layout.defaults.stateManagement = {
    enabled: false,
    autoSave: true,
    autoLoad: true,
    animateLoad: true,
    includeChildren: true,
    stateKeys: 'north.size,south.size,east.size,west.size,' + 'north.isClosed,south.isClosed,east.isClosed,west.isClosed,' + 'north.isHidden,south.isHidden,east.isHidden,west.isHidden',
    cookie: {
      name: '',
      domain: '',
      path: '',
      expires: '',
      secure: false
    }
  };
  $.layout.optionsMap.layout.push('stateManagement');
  $.layout.state = {
    saveCookie: function (inst, keys, cookieOpts) {
      var o = inst.options, sm = o.stateManagement, oC = $.extend(true, {}, sm.cookie, cookieOpts || null), data = inst.state.stateData = inst.readState(keys || sm.stateKeys);
      ;
      $.ui.cookie.write(oC.name || o.name || 'Layout', $.layout.state.encodeJSON(data), oC);
      return $.extend(true, {}, data);
    },
    deleteCookie: function (inst) {
      var o = inst.options;
      $.ui.cookie.clear(o.stateManagement.cookie.name || o.name || 'Layout');
    },
    readCookie: function (inst) {
      var o = inst.options;
      var c = $.ui.cookie.read(o.stateManagement.cookie.name || o.name || 'Layout');
      return c ? $.layout.state.decodeJSON(c) : {};
    },
    loadCookie: function (inst) {
      var c = $.layout.state.readCookie(inst);
      if (c) {
        inst.state.stateData = $.extend(true, {}, c);
        inst.loadState(c);
      }
      return c;
    },
    loadState: function (inst, data, opts) {
      if (!$.isPlainObject(data) || $.isEmptyObject(data))
        return;
      data = inst.state.stateData = $.layout.transformData(data);
      var smo = inst.options.stateManagement;
      opts = $.extend({
        animateLoad: false,
        includeChildren: smo.includeChildren
      }, opts);
      if (!inst.state.initialized) {
        var o = $.extend(true, {}, data);
        $.each($.layout.config.allPanes, function (idx, pane) {
          if (o[pane])
            delete o[pane].children;
        });
        $.extend(true, inst.options, o);
      } else {
        var noAnimate = !opts.animateLoad, o, c, h, state, open;
        ;
        $.each($.layout.config.borderPanes, function (idx, pane) {
          o = data[pane];
          if (!$.isPlainObject(o))
            return;
          s = o.size;
          c = o.initClosed;
          h = o.initHidden;
          ar = o.autoResize;
          state = inst.state[pane];
          open = state.isVisible;
          if (ar)
            state.autoResize = ar;
          if (!open)
            inst._sizePane(pane, s, false, false, false);
          if (h === true)
            inst.hide(pane, noAnimate);
          else if (c === true)
            inst.close(pane, false, noAnimate);
          else if (c === false)
            inst.open(pane, false, noAnimate);
          else if (h === false)
            inst.show(pane, false, noAnimate);
          if (open)
            inst._sizePane(pane, s, false, false, noAnimate);
        });
        if (opts.includeChildren) {
          var paneStateChildren, childState;
          $.each(inst.children, function (pane, paneChildren) {
            paneStateChildren = data[pane] ? data[pane].children : 0;
            if (paneStateChildren && paneChildren) {
              $.each(paneChildren, function (stateKey, child) {
                childState = paneStateChildren[stateKey];
                if (child && childState)
                  child.loadState(childState);
              });
            }
          });
        }
      }
    },
    readState: function (inst, opts) {
      if ($.type(opts) === 'string')
        opts = { keys: opts };
      if (!opts)
        opts = {};
      var sm = inst.options.stateManagement, ic = opts.includeChildren, recurse = ic !== undefined ? ic : sm.includeChildren, keys = opts.stateKeys || sm.stateKeys, alt = {
          isClosed: 'initClosed',
          isHidden: 'initHidden'
        }, state = inst.state, panes = $.layout.config.allPanes, data = {}, pair, pane, key, val, ps, pC, child, array, count, branch;
      ;
      if ($.isArray(keys))
        keys = keys.join(',');
      keys = keys.replace(/__/g, '.').split(',');
      for (var i = 0, n = keys.length; i < n; i++) {
        pair = keys[i].split('.');
        pane = pair[0];
        key = pair[1];
        if ($.inArray(pane, panes) < 0)
          continue;
        val = state[pane][key];
        if (val == undefined)
          continue;
        if (key == 'isClosed' && state[pane]['isSliding'])
          val = true;
        (data[pane] || (data[pane] = {}))[alt[key] ? alt[key] : key] = val;
      }
      if (recurse) {
        $.each(panes, function (idx, pane) {
          pC = inst.children[pane];
          ps = state.stateData[pane];
          if ($.isPlainObject(pC) && !$.isEmptyObject(pC)) {
            branch = data[pane] || (data[pane] = {});
            if (!branch.children)
              branch.children = {};
            $.each(pC, function (key, child) {
              if (child.state.initialized)
                branch.children[key] = $.layout.state.readState(child);
              else if (ps && ps.children && ps.children[key]) {
                branch.children[key] = $.extend(true, {}, ps.children[key]);
              }
            });
          }
        });
      }
      return data;
    },
    encodeJSON: function (JSON) {
      return parse(JSON);
      function parse(h) {
        var D = [], i = 0, k, v, t, a = $.isArray(h);
        ;
        for (k in h) {
          v = h[k];
          t = typeof v;
          if (t == 'string')
            v = '"' + v + '"';
          else if (t == 'object')
            v = parse(v);
          D[i++] = (!a ? '"' + k + '":' : '') + v;
        }
        return (a ? '[' : '{') + D.join(',') + (a ? ']' : '}');
      }
      ;
    },
    decodeJSON: function (str) {
      try {
        return $.parseJSON ? $.parseJSON(str) : window['eval']('(' + str + ')') || {};
      } catch (e) {
        return {};
      }
    },
    _create: function (inst) {
      var _ = $.layout.state, o = inst.options, sm = o.stateManagement;
      ;
      $.extend(inst, {
        readCookie: function () {
          return _.readCookie(inst);
        },
        deleteCookie: function () {
          _.deleteCookie(inst);
        },
        saveCookie: function (keys, cookieOpts) {
          return _.saveCookie(inst, keys, cookieOpts);
        },
        loadCookie: function () {
          return _.loadCookie(inst);
        },
        loadState: function (stateData, opts) {
          _.loadState(inst, stateData, opts);
        },
        readState: function (keys) {
          return _.readState(inst, keys);
        },
        encodeJSON: _.encodeJSON,
        decodeJSON: _.decodeJSON
      });
      inst.state.stateData = {};
      if (!sm.autoLoad)
        return;
      if ($.isPlainObject(sm.autoLoad)) {
        if (!$.isEmptyObject(sm.autoLoad)) {
          inst.loadState(sm.autoLoad);
        }
      } else if (sm.enabled) {
        if ($.isFunction(sm.autoLoad)) {
          var d = {};
          try {
            d = sm.autoLoad(inst, inst.state, inst.options, inst.options.name || '');
          } catch (e) {
          }
          if (d && $.isPlainObject(d) && !$.isEmptyObject(d))
            inst.loadState(d);
        } else
          inst.loadCookie();
      }
    },
    _unload: function (inst) {
      var sm = inst.options.stateManagement;
      if (sm.enabled && sm.autoSave) {
        if ($.isFunction(sm.autoSave)) {
          try {
            sm.autoSave(inst, inst.state, inst.options, inst.options.name || '');
          } catch (e) {
          }
        } else
          inst.saveCookie();
      }
    }
  };
  $.layout.onCreate.push($.layout.state._create);
  $.layout.onUnload.push($.layout.state._unload);
  $.layout.plugins.buttons = true;
  $.layout.defaults.autoBindCustomButtons = false;
  $.layout.optionsMap.layout.push('autoBindCustomButtons');
  $.layout.buttons = {
    init: function (inst) {
      var pre = 'ui-layout-button-', layout = inst.options.name || '', name;
      $.each('toggle,open,close,pin,toggle-slide,open-slide'.split(','), function (i, action) {
        $.each($.layout.config.borderPanes, function (ii, pane) {
          $('.' + pre + action + '-' + pane).each(function () {
            name = $(this).data('layoutName') || $(this).attr('layoutName');
            if (name == undefined || name === layout)
              inst.bindButton(this, action, pane);
          });
        });
      });
    },
    get: function (inst, selector, pane, action) {
      var $E = $(selector), o = inst.options, err = o.errors.addButtonError;
      ;
      if (!$E.length) {
        $.layout.msg(err + ' ' + o.errors.selector + ': ' + selector, true);
      } else if ($.inArray(pane, $.layout.config.borderPanes) < 0) {
        $.layout.msg(err + ' ' + o.errors.pane + ': ' + pane, true);
        $E = $('');
      } else {
        var btn = o[pane].buttonClass + '-' + action;
        $E.addClass(btn + ' ' + btn + '-' + pane).data('layoutName', o.name);
      }
      return $E;
    },
    bind: function (inst, selector, action, pane) {
      var _ = $.layout.buttons;
      switch (action.toLowerCase()) {
      case 'toggle':
        _.addToggle(inst, selector, pane);
        break;
      case 'open':
        _.addOpen(inst, selector, pane);
        break;
      case 'close':
        _.addClose(inst, selector, pane);
        break;
      case 'pin':
        _.addPin(inst, selector, pane);
        break;
      case 'toggle-slide':
        _.addToggle(inst, selector, pane, true);
        break;
      case 'open-slide':
        _.addOpen(inst, selector, pane, true);
        break;
      }
      return inst;
    },
    addToggle: function (inst, selector, pane, slide) {
      $.layout.buttons.get(inst, selector, pane, 'toggle').click(function (evt) {
        inst.toggle(pane, !!slide);
        evt.stopPropagation();
      });
      return inst;
    },
    addOpen: function (inst, selector, pane, slide) {
      $.layout.buttons.get(inst, selector, pane, 'open').attr('title', inst.options[pane].tips.Open).click(function (evt) {
        inst.open(pane, !!slide);
        evt.stopPropagation();
      });
      return inst;
    },
    addClose: function (inst, selector, pane) {
      $.layout.buttons.get(inst, selector, pane, 'close').attr('title', inst.options[pane].tips.Close).click(function (evt) {
        inst.close(pane);
        evt.stopPropagation();
      });
      return inst;
    },
    addPin: function (inst, selector, pane) {
      var _ = $.layout.buttons, $E = _.get(inst, selector, pane, 'pin');
      if ($E.length) {
        var s = inst.state[pane];
        $E.click(function (evt) {
          _.setPinState(inst, $(this), pane, s.isSliding || s.isClosed);
          if (s.isSliding || s.isClosed)
            inst.open(pane);
          else
            inst.close(pane);
          evt.stopPropagation();
        });
        _.setPinState(inst, $E, pane, !s.isClosed && !s.isSliding);
        s.pins.push(selector);
      }
      return inst;
    },
    setPinState: function (inst, $Pin, pane, doPin) {
      var updown = $Pin.attr('pin');
      if (updown && doPin === (updown == 'down'))
        return;
      var o = inst.options[pane], pin = o.buttonClass + '-pin', side = pin + '-' + pane, UP = pin + '-up ' + side + '-up', DN = pin + '-down ' + side + '-down';
      ;
      $Pin.attr('pin', doPin ? 'down' : 'up').attr('title', doPin ? o.tips.Unpin : o.tips.Pin).removeClass(doPin ? UP : DN).addClass(doPin ? DN : UP);
      ;
    },
    syncPinBtns: function (inst, pane, doPin) {
      $.each(inst.state[pane].pins, function (i, selector) {
        $.layout.buttons.setPinState(inst, $(selector), pane, doPin);
      });
    },
    _load: function (inst) {
      var _ = $.layout.buttons;
      $.extend(inst, {
        bindButton: function (sel, action, pane) {
          return _.bind(inst, sel, action, pane);
        },
        addToggleBtn: function (sel, pane, slide) {
          return _.addToggle(inst, sel, pane, slide);
        },
        addOpenBtn: function (sel, pane, slide) {
          return _.addOpen(inst, sel, pane, slide);
        },
        addCloseBtn: function (sel, pane) {
          return _.addClose(inst, sel, pane);
        },
        addPinBtn: function (sel, pane) {
          return _.addPin(inst, sel, pane);
        }
      });
      for (var i = 0; i < 4; i++) {
        var pane = $.layout.config.borderPanes[i];
        inst.state[pane].pins = [];
      }
      if (inst.options.autoBindCustomButtons)
        _.init(inst);
    },
    _unload: function (inst) {
    }
  };
  $.layout.onLoad.push($.layout.buttons._load);
  $.layout.plugins.browserZoom = true;
  $.layout.defaults.browserZoomCheckInterval = 1000;
  $.layout.optionsMap.layout.push('browserZoomCheckInterval');
  $.layout.browserZoom = {
    _init: function (inst) {
      if ($.layout.browserZoom.ratio() !== false)
        $.layout.browserZoom._setTimer(inst);
    },
    _setTimer: function (inst) {
      if (inst.destroyed)
        return;
      var o = inst.options, s = inst.state, ms = inst.hasParentLayout ? 5000 : Math.max(o.browserZoomCheckInterval, 100);
      ;
      setTimeout(function () {
        if (inst.destroyed || !o.resizeWithWindow)
          return;
        var d = $.layout.browserZoom.ratio();
        if (d !== s.browserZoom) {
          s.browserZoom = d;
          inst.resizeAll();
        }
        $.layout.browserZoom._setTimer(inst);
      }, ms);
    },
    ratio: function () {
      var w = window, s = screen, d = document, dE = d.documentElement || d.body, b = $.layout.browser, v = b.version, r, sW, cW;
      ;
      if (b.msie && v > 8 || !b.msie)
        return false;
      if (s.deviceXDPI && s.systemXDPI)
        return calc(s.deviceXDPI, s.systemXDPI);
      if (b.webkit && (r = d.body.getBoundingClientRect))
        return calc(r.left - r.right, d.body.offsetWidth);
      if (b.webkit && (sW = w.outerWidth))
        return calc(sW, w.innerWidth);
      if ((sW = s.width) && (cW = dE.clientWidth))
        return calc(sW, cW);
      return false;
      function calc(x, y) {
        return (parseInt(x, 10) / parseInt(y, 10) * 100).toFixed();
      }
    }
  };
  $.layout.onReady.push($.layout.browserZoom._init);
}(jQuery));
(function () {
  var COMPILED = !0, goog = goog || {};
  goog.global = this;
  goog.exportPath_ = function (a, b, c) {
    a = a.split('.');
    c = c || goog.global;
    a[0] in c || !c.execScript || c.execScript('var ' + a[0]);
    for (var d; a.length && (d = a.shift());)
      a.length || void 0 === b ? c = c[d] ? c[d] : c[d] = {} : c[d] = b;
  };
  goog.define = function (a, b) {
    var c = b;
    COMPILED || goog.global.CLOSURE_DEFINES && Object.prototype.hasOwnProperty.call(goog.global.CLOSURE_DEFINES, a) && (c = goog.global.CLOSURE_DEFINES[a]);
    goog.exportPath_(a, c);
  };
  goog.DEBUG = !1;
  goog.LOCALE = 'en';
  goog.TRUSTED_SITE = !0;
  goog.provide = function (a) {
    if (!COMPILED) {
      if (goog.isProvided_(a))
        throw Error('Namespace "' + a + '" already declared.');
      delete goog.implicitNamespaces_[a];
      for (var b = a; (b = b.substring(0, b.lastIndexOf('.'))) && !goog.getObjectByName(b);)
        goog.implicitNamespaces_[b] = !0;
    }
    goog.exportPath_(a);
  };
  goog.setTestOnly = function (a) {
    if (COMPILED && !goog.DEBUG)
      throw a = a || '', Error('Importing test-only code into non-debug environment' + a ? ': ' + a : '.');
  };
  COMPILED || (goog.isProvided_ = function (a) {
    return !goog.implicitNamespaces_[a] && !!goog.getObjectByName(a);
  }, goog.implicitNamespaces_ = {});
  goog.getObjectByName = function (a, b) {
    for (var c = a.split('.'), d = b || goog.global, e; e = c.shift();)
      if (goog.isDefAndNotNull(d[e]))
        d = d[e];
      else
        return null;
    return d;
  };
  goog.globalize = function (a, b) {
    var c = b || goog.global, d;
    for (d in a)
      c[d] = a[d];
  };
  goog.addDependency = function (a, b, c) {
    if (goog.DEPENDENCIES_ENABLED) {
      var d;
      a = a.replace(/\\/g, '/');
      for (var e = goog.dependencies_, f = 0; d = b[f]; f++)
        e.nameToPath[d] = a, a in e.pathToNames || (e.pathToNames[a] = {}), e.pathToNames[a][d] = !0;
      for (d = 0; b = c[d]; d++)
        a in e.requires || (e.requires[a] = {}), e.requires[a][b] = !0;
    }
  };
  goog.ENABLE_DEBUG_LOADER = !0;
  goog.require = function (a) {
    if (!COMPILED && !goog.isProvided_(a)) {
      if (goog.ENABLE_DEBUG_LOADER) {
        var b = goog.getPathFromDeps_(a);
        if (b) {
          goog.included_[b] = !0;
          goog.writeScripts_();
          return;
        }
      }
      a = 'goog.require could not find: ' + a;
      goog.global.console && goog.global.console.error(a);
      throw Error(a);
    }
  };
  goog.basePath = '';
  goog.nullFunction = function () {
  };
  goog.identityFunction = function (a, b) {
    return a;
  };
  goog.abstractMethod = function () {
    throw Error('unimplemented abstract method');
  };
  goog.addSingletonGetter = function (a) {
    a.getInstance = function () {
      if (a.instance_)
        return a.instance_;
      goog.DEBUG && (goog.instantiatedSingletons_[goog.instantiatedSingletons_.length] = a);
      return a.instance_ = new a();
    };
  };
  goog.instantiatedSingletons_ = [];
  goog.DEPENDENCIES_ENABLED = !COMPILED && goog.ENABLE_DEBUG_LOADER;
  goog.DEPENDENCIES_ENABLED && (goog.included_ = {}, goog.dependencies_ = {
    pathToNames: {},
    nameToPath: {},
    requires: {},
    visited: {},
    written: {}
  }, goog.inHtmlDocument_ = function () {
    var a = goog.global.document;
    return 'undefined' != typeof a && 'write' in a;
  }, goog.findBasePath_ = function () {
    if (goog.global.CLOSURE_BASE_PATH)
      goog.basePath = goog.global.CLOSURE_BASE_PATH;
    else if (goog.inHtmlDocument_())
      for (var a = goog.global.document.getElementsByTagName('script'), b = a.length - 1; 0 <= b; --b) {
        var c = a[b].src, d = c.lastIndexOf('?'), d = -1 == d ? c.length : d;
        if ('base.js' == c.substr(d - 7, 7)) {
          goog.basePath = c.substr(0, d - 7);
          break;
        }
      }
  }, goog.importScript_ = function (a) {
    var b = goog.global.CLOSURE_IMPORT_SCRIPT || goog.writeScriptTag_;
    !goog.dependencies_.written[a] && b(a) && (goog.dependencies_.written[a] = !0);
  }, goog.writeScriptTag_ = function (a) {
    if (goog.inHtmlDocument_()) {
      var b = goog.global.document;
      if ('complete' == b.readyState) {
        if (/\bdeps.js$/.test(a))
          return !1;
        throw Error('Cannot write "' + a + '" after document load');
      }
      b.write('<script type="text/javascript" src="' + a + '"></script>');
      return !0;
    }
    return !1;
  }, goog.writeScripts_ = function () {
    function a(e) {
      if (!(e in d.written)) {
        if (!(e in d.visited) && (d.visited[e] = !0, e in d.requires))
          for (var g in d.requires[e])
            if (!goog.isProvided_(g))
              if (g in d.nameToPath)
                a(d.nameToPath[g]);
              else
                throw Error('Undefined nameToPath for ' + g);
        e in c || (c[e] = !0, b.push(e));
      }
    }
    var b = [], c = {}, d = goog.dependencies_, e;
    for (e in goog.included_)
      d.written[e] || a(e);
    for (e = 0; e < b.length; e++)
      if (b[e])
        goog.importScript_(goog.basePath + b[e]);
      else
        throw Error('Undefined script input');
  }, goog.getPathFromDeps_ = function (a) {
    return a in goog.dependencies_.nameToPath ? goog.dependencies_.nameToPath[a] : null;
  }, goog.findBasePath_(), goog.global.CLOSURE_NO_DEPS || goog.importScript_(goog.basePath + 'deps.js'));
  goog.typeOf = function (a) {
    var b = typeof a;
    if ('object' == b)
      if (a) {
        if (a instanceof Array)
          return 'array';
        if (a instanceof Object)
          return b;
        var c = Object.prototype.toString.call(a);
        if ('[object Window]' == c)
          return 'object';
        if ('[object Array]' == c || 'number' == typeof a.length && 'undefined' != typeof a.splice && 'undefined' != typeof a.propertyIsEnumerable && !a.propertyIsEnumerable('splice'))
          return 'array';
        if ('[object Function]' == c || 'undefined' != typeof a.call && 'undefined' != typeof a.propertyIsEnumerable && !a.propertyIsEnumerable('call'))
          return 'function';
      } else
        return 'null';
    else if ('function' == b && 'undefined' == typeof a.call)
      return 'object';
    return b;
  };
  goog.isDef = function (a) {
    return void 0 !== a;
  };
  goog.isNull = function (a) {
    return null === a;
  };
  goog.isDefAndNotNull = function (a) {
    return null != a;
  };
  goog.isArray = function (a) {
    return 'array' == goog.typeOf(a);
  };
  goog.isArrayLike = function (a) {
    var b = goog.typeOf(a);
    return 'array' == b || 'object' == b && 'number' == typeof a.length;
  };
  goog.isDateLike = function (a) {
    return goog.isObject(a) && 'function' == typeof a.getFullYear;
  };
  goog.isString = function (a) {
    return 'string' == typeof a;
  };
  goog.isBoolean = function (a) {
    return 'boolean' == typeof a;
  };
  goog.isNumber = function (a) {
    return 'number' == typeof a;
  };
  goog.isFunction = function (a) {
    return 'function' == goog.typeOf(a);
  };
  goog.isObject = function (a) {
    var b = typeof a;
    return 'object' == b && null != a || 'function' == b;
  };
  goog.getUid = function (a) {
    return a[goog.UID_PROPERTY_] || (a[goog.UID_PROPERTY_] = ++goog.uidCounter_);
  };
  goog.removeUid = function (a) {
    'removeAttribute' in a && a.removeAttribute(goog.UID_PROPERTY_);
    try {
      delete a[goog.UID_PROPERTY_];
    } catch (b) {
    }
  };
  goog.UID_PROPERTY_ = 'closure_uid_' + (1000000000 * Math.random() >>> 0);
  goog.uidCounter_ = 0;
  goog.getHashCode = goog.getUid;
  goog.removeHashCode = goog.removeUid;
  goog.cloneObject = function (a) {
    var b = goog.typeOf(a);
    if ('object' == b || 'array' == b) {
      if (a.clone)
        return a.clone();
      var b = 'array' == b ? [] : {}, c;
      for (c in a)
        b[c] = goog.cloneObject(a[c]);
      return b;
    }
    return a;
  };
  goog.bindNative_ = function (a, b, c) {
    return a.call.apply(a.bind, arguments);
  };
  goog.bindJs_ = function (a, b, c) {
    if (!a)
      throw Error();
    if (2 < arguments.length) {
      var d = Array.prototype.slice.call(arguments, 2);
      return function () {
        var c = Array.prototype.slice.call(arguments);
        Array.prototype.unshift.apply(c, d);
        return a.apply(b, c);
      };
    }
    return function () {
      return a.apply(b, arguments);
    };
  };
  goog.bind = function (a, b, c) {
    Function.prototype.bind && -1 != Function.prototype.bind.toString().indexOf('native code') ? goog.bind = goog.bindNative_ : goog.bind = goog.bindJs_;
    return goog.bind.apply(null, arguments);
  };
  goog.partial = function (a, b) {
    var c = Array.prototype.slice.call(arguments, 1);
    return function () {
      var b = Array.prototype.slice.call(arguments);
      b.unshift.apply(b, c);
      return a.apply(this, b);
    };
  };
  goog.mixin = function (a, b) {
    for (var c in b)
      a[c] = b[c];
  };
  goog.now = goog.TRUSTED_SITE && Date.now || function () {
    return +new Date();
  };
  goog.globalEval = function (a) {
    if (goog.global.execScript)
      goog.global.execScript(a, 'JavaScript');
    else if (goog.global.eval)
      if (null == goog.evalWorksForGlobals_ && (goog.global.eval('var _et_ = 1;'), 'undefined' != typeof goog.global._et_ ? (delete goog.global._et_, goog.evalWorksForGlobals_ = !0) : goog.evalWorksForGlobals_ = !1), goog.evalWorksForGlobals_)
        goog.global.eval(a);
      else {
        var b = goog.global.document, c = b.createElement('script');
        c.type = 'text/javascript';
        c.defer = !1;
        c.appendChild(b.createTextNode(a));
        b.body.appendChild(c);
        b.body.removeChild(c);
      }
    else
      throw Error('goog.globalEval not available');
  };
  goog.evalWorksForGlobals_ = null;
  goog.getCssName = function (a, b) {
    var c = function (a) {
        return goog.cssNameMapping_[a] || a;
      }, d = function (a) {
        a = a.split('-');
        for (var b = [], d = 0; d < a.length; d++)
          b.push(c(a[d]));
        return b.join('-');
      }, d = goog.cssNameMapping_ ? 'BY_WHOLE' == goog.cssNameMappingStyle_ ? c : d : function (a) {
        return a;
      };
    return b ? a + '-' + d(b) : d(a);
  };
  goog.setCssNameMapping = function (a, b) {
    goog.cssNameMapping_ = a;
    goog.cssNameMappingStyle_ = b;
  };
  !COMPILED && goog.global.CLOSURE_CSS_NAME_MAPPING && (goog.cssNameMapping_ = goog.global.CLOSURE_CSS_NAME_MAPPING);
  goog.getMsg = function (a, b) {
    var c = b || {}, d;
    for (d in c) {
      var e = ('' + c[d]).replace(/\$/g, '$$$$');
      a = a.replace(RegExp('\\{\\$' + d + '\\}', 'gi'), e);
    }
    return a;
  };
  goog.getMsgWithFallback = function (a, b) {
    return a;
  };
  goog.exportSymbol = function (a, b, c) {
    goog.exportPath_(a, b, c);
  };
  goog.exportProperty = function (a, b, c) {
    a[b] = c;
  };
  goog.inherits = function (a, b) {
    function c() {
    }
    c.prototype = b.prototype;
    a.superClass_ = b.prototype;
    a.prototype = new c();
    a.prototype.constructor = a;
  };
  goog.base = function (a, b, c) {
    var d = arguments.callee.caller;
    if (goog.DEBUG && !d)
      throw Error('arguments.caller not defined.  goog.base() expects not to be running in strict mode. See http://www.ecma-international.org/ecma-262/5.1/#sec-C');
    if (d.superClass_)
      return d.superClass_.constructor.apply(a, Array.prototype.slice.call(arguments, 1));
    for (var e = Array.prototype.slice.call(arguments, 2), f = !1, g = a.constructor; g; g = g.superClass_ && g.superClass_.constructor)
      if (g.prototype[b] === d)
        f = !0;
      else if (f)
        return g.prototype[b].apply(a, e);
    if (a[b] === d)
      return a.constructor.prototype[b].apply(a, e);
    throw Error('goog.base called from a method of one name to a method of a different name');
  };
  goog.scope = function (a) {
    a.call(goog.global);
  };
  goog.string = {};
  goog.string.Unicode = { NBSP: '\xa0' };
  goog.string.startsWith = function (a, b) {
    return 0 == a.lastIndexOf(b, 0);
  };
  goog.string.endsWith = function (a, b) {
    var c = a.length - b.length;
    return 0 <= c && a.indexOf(b, c) == c;
  };
  goog.string.caseInsensitiveStartsWith = function (a, b) {
    return 0 == goog.string.caseInsensitiveCompare(b, a.substr(0, b.length));
  };
  goog.string.caseInsensitiveEndsWith = function (a, b) {
    return 0 == goog.string.caseInsensitiveCompare(b, a.substr(a.length - b.length, b.length));
  };
  goog.string.caseInsensitiveEquals = function (a, b) {
    return a.toLowerCase() == b.toLowerCase();
  };
  goog.string.subs = function (a, b) {
    for (var c = a.split('%s'), d = '', e = Array.prototype.slice.call(arguments, 1); e.length && 1 < c.length;)
      d += c.shift() + e.shift();
    return d + c.join('%s');
  };
  goog.string.collapseWhitespace = function (a) {
    return a.replace(/[\s\xa0]+/g, ' ').replace(/^\s+|\s+$/g, '');
  };
  goog.string.isEmpty = function (a) {
    return /^[\s\xa0]*$/.test(a);
  };
  goog.string.isEmptySafe = function (a) {
    return goog.string.isEmpty(goog.string.makeSafe(a));
  };
  goog.string.isBreakingWhitespace = function (a) {
    return !/[^\t\n\r ]/.test(a);
  };
  goog.string.isAlpha = function (a) {
    return !/[^a-zA-Z]/.test(a);
  };
  goog.string.isNumeric = function (a) {
    return !/[^0-9]/.test(a);
  };
  goog.string.isAlphaNumeric = function (a) {
    return !/[^a-zA-Z0-9]/.test(a);
  };
  goog.string.isSpace = function (a) {
    return ' ' == a;
  };
  goog.string.isUnicodeChar = function (a) {
    return 1 == a.length && ' ' <= a && '~' >= a || '\x80' <= a && '\ufffd' >= a;
  };
  goog.string.stripNewlines = function (a) {
    return a.replace(/(\r\n|\r|\n)+/g, ' ');
  };
  goog.string.canonicalizeNewlines = function (a) {
    return a.replace(/(\r\n|\r|\n)/g, '\n');
  };
  goog.string.normalizeWhitespace = function (a) {
    return a.replace(/\xa0|\s/g, ' ');
  };
  goog.string.normalizeSpaces = function (a) {
    return a.replace(/\xa0|[ \t]+/g, ' ');
  };
  goog.string.collapseBreakingSpaces = function (a) {
    return a.replace(/[\t\r\n ]+/g, ' ').replace(/^[\t\r\n ]+|[\t\r\n ]+$/g, '');
  };
  goog.string.trim = function (a) {
    return a.replace(/^[\s\xa0]+|[\s\xa0]+$/g, '');
  };
  goog.string.trimLeft = function (a) {
    return a.replace(/^[\s\xa0]+/, '');
  };
  goog.string.trimRight = function (a) {
    return a.replace(/[\s\xa0]+$/, '');
  };
  goog.string.caseInsensitiveCompare = function (a, b) {
    var c = String(a).toLowerCase(), d = String(b).toLowerCase();
    return c < d ? -1 : c == d ? 0 : 1;
  };
  goog.string.numerateCompareRegExp_ = /(\.\d+)|(\d+)|(\D+)/g;
  goog.string.numerateCompare = function (a, b) {
    if (a == b)
      return 0;
    if (!a)
      return -1;
    if (!b)
      return 1;
    for (var c = a.toLowerCase().match(goog.string.numerateCompareRegExp_), d = b.toLowerCase().match(goog.string.numerateCompareRegExp_), e = Math.min(c.length, d.length), f = 0; f < e; f++) {
      var g = c[f], h = d[f];
      if (g != h)
        return c = parseInt(g, 10), !isNaN(c) && (d = parseInt(h, 10), !isNaN(d) && c - d) ? c - d : g < h ? -1 : 1;
    }
    return c.length != d.length ? c.length - d.length : a < b ? -1 : 1;
  };
  goog.string.urlEncode = function (a) {
    return encodeURIComponent(String(a));
  };
  goog.string.urlDecode = function (a) {
    return decodeURIComponent(a.replace(/\+/g, ' '));
  };
  goog.string.newLineToBr = function (a, b) {
    return a.replace(/(\r\n|\r|\n)/g, b ? '<br />' : '<br>');
  };
  goog.string.htmlEscape = function (a, b) {
    if (b)
      return a.replace(goog.string.amperRe_, '&amp;').replace(goog.string.ltRe_, '&lt;').replace(goog.string.gtRe_, '&gt;').replace(goog.string.quotRe_, '&quot;');
    if (!goog.string.allRe_.test(a))
      return a;
    -1 != a.indexOf('&') && (a = a.replace(goog.string.amperRe_, '&amp;'));
    -1 != a.indexOf('<') && (a = a.replace(goog.string.ltRe_, '&lt;'));
    -1 != a.indexOf('>') && (a = a.replace(goog.string.gtRe_, '&gt;'));
    -1 != a.indexOf('"') && (a = a.replace(goog.string.quotRe_, '&quot;'));
    return a;
  };
  goog.string.amperRe_ = /&/g;
  goog.string.ltRe_ = /</g;
  goog.string.gtRe_ = />/g;
  goog.string.quotRe_ = /\"/g;
  goog.string.allRe_ = /[&<>\"]/;
  goog.string.unescapeEntities = function (a) {
    return goog.string.contains(a, '&') ? 'document' in goog.global ? goog.string.unescapeEntitiesUsingDom_(a) : goog.string.unescapePureXmlEntities_(a) : a;
  };
  goog.string.unescapeEntitiesUsingDom_ = function (a) {
    var b = {
        '&amp;': '&',
        '&lt;': '<',
        '&gt;': '>',
        '&quot;': '"'
      }, c = document.createElement('div');
    return a.replace(goog.string.HTML_ENTITY_PATTERN_, function (a, e) {
      var f = b[a];
      if (f)
        return f;
      if ('#' == e.charAt(0)) {
        var g = Number('0' + e.substr(1));
        isNaN(g) || (f = String.fromCharCode(g));
      }
      f || (c.innerHTML = a + ' ', f = c.firstChild.nodeValue.slice(0, -1));
      return b[a] = f;
    });
  };
  goog.string.unescapePureXmlEntities_ = function (a) {
    return a.replace(/&([^;]+);/g, function (a, c) {
      switch (c) {
      case 'amp':
        return '&';
      case 'lt':
        return '<';
      case 'gt':
        return '>';
      case 'quot':
        return '"';
      default:
        if ('#' == c.charAt(0)) {
          var d = Number('0' + c.substr(1));
          if (!isNaN(d))
            return String.fromCharCode(d);
        }
        return a;
      }
    });
  };
  goog.string.HTML_ENTITY_PATTERN_ = /&([^;\s<&]+);?/g;
  goog.string.whitespaceEscape = function (a, b) {
    return goog.string.newLineToBr(a.replace(/  /g, ' &#160;'), b);
  };
  goog.string.stripQuotes = function (a, b) {
    for (var c = b.length, d = 0; d < c; d++) {
      var e = 1 == c ? b : b.charAt(d);
      if (a.charAt(0) == e && a.charAt(a.length - 1) == e)
        return a.substring(1, a.length - 1);
    }
    return a;
  };
  goog.string.truncate = function (a, b, c) {
    c && (a = goog.string.unescapeEntities(a));
    a.length > b && (a = a.substring(0, b - 3) + '...');
    c && (a = goog.string.htmlEscape(a));
    return a;
  };
  goog.string.truncateMiddle = function (a, b, c, d) {
    c && (a = goog.string.unescapeEntities(a));
    if (d && a.length > b) {
      d > b && (d = b);
      var e = a.length - d;
      a = a.substring(0, b - d) + '...' + a.substring(e);
    } else
      a.length > b && (d = Math.floor(b / 2), e = a.length - d, a = a.substring(0, d + b % 2) + '...' + a.substring(e));
    c && (a = goog.string.htmlEscape(a));
    return a;
  };
  goog.string.specialEscapeChars_ = {
    '\0': '\\0',
    '\b': '\\b',
    '\f': '\\f',
    '\n': '\\n',
    '\r': '\\r',
    '\t': '\\t',
    '\x0B': '\\x0B',
    '"': '\\"',
    '\\': '\\\\'
  };
  goog.string.jsEscapeCache_ = { '\'': '\\\'' };
  goog.string.quote = function (a) {
    a = String(a);
    if (a.quote)
      return a.quote();
    for (var b = ['"'], c = 0; c < a.length; c++) {
      var d = a.charAt(c), e = d.charCodeAt(0);
      b[c + 1] = goog.string.specialEscapeChars_[d] || (31 < e && 127 > e ? d : goog.string.escapeChar(d));
    }
    b.push('"');
    return b.join('');
  };
  goog.string.escapeString = function (a) {
    for (var b = [], c = 0; c < a.length; c++)
      b[c] = goog.string.escapeChar(a.charAt(c));
    return b.join('');
  };
  goog.string.escapeChar = function (a) {
    if (a in goog.string.jsEscapeCache_)
      return goog.string.jsEscapeCache_[a];
    if (a in goog.string.specialEscapeChars_)
      return goog.string.jsEscapeCache_[a] = goog.string.specialEscapeChars_[a];
    var b = a, c = a.charCodeAt(0);
    if (31 < c && 127 > c)
      b = a;
    else {
      if (256 > c) {
        if (b = '\\x', 16 > c || 256 < c)
          b += '0';
      } else
        b = '\\u', 4096 > c && (b += '0');
      b += c.toString(16).toUpperCase();
    }
    return goog.string.jsEscapeCache_[a] = b;
  };
  goog.string.toMap = function (a) {
    for (var b = {}, c = 0; c < a.length; c++)
      b[a.charAt(c)] = !0;
    return b;
  };
  goog.string.contains = function (a, b) {
    return -1 != a.indexOf(b);
  };
  goog.string.countOf = function (a, b) {
    return a && b ? a.split(b).length - 1 : 0;
  };
  goog.string.removeAt = function (a, b, c) {
    var d = a;
    0 <= b && (b < a.length && 0 < c) && (d = a.substr(0, b) + a.substr(b + c, a.length - b - c));
    return d;
  };
  goog.string.remove = function (a, b) {
    var c = RegExp(goog.string.regExpEscape(b), '');
    return a.replace(c, '');
  };
  goog.string.removeAll = function (a, b) {
    var c = RegExp(goog.string.regExpEscape(b), 'g');
    return a.replace(c, '');
  };
  goog.string.regExpEscape = function (a) {
    return String(a).replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, '\\$1').replace(/\x08/g, '\\x08');
  };
  goog.string.repeat = function (a, b) {
    return Array(b + 1).join(a);
  };
  goog.string.padNumber = function (a, b, c) {
    a = goog.isDef(c) ? a.toFixed(c) : String(a);
    c = a.indexOf('.');
    -1 == c && (c = a.length);
    return goog.string.repeat('0', Math.max(0, b - c)) + a;
  };
  goog.string.makeSafe = function (a) {
    return null == a ? '' : String(a);
  };
  goog.string.buildString = function (a) {
    return Array.prototype.join.call(arguments, '');
  };
  goog.string.getRandomString = function () {
    return Math.floor(2147483648 * Math.random()).toString(36) + Math.abs(Math.floor(2147483648 * Math.random()) ^ goog.now()).toString(36);
  };
  goog.string.compareVersions = function (a, b) {
    for (var c = 0, d = goog.string.trim(String(a)).split('.'), e = goog.string.trim(String(b)).split('.'), f = Math.max(d.length, e.length), g = 0; 0 == c && g < f; g++) {
      var h = d[g] || '', l = e[g] || '', k = /(\d*)(\D*)/g, m = /(\d*)(\D*)/g;
      do {
        var p = k.exec(h) || [
            '',
            '',
            ''
          ], n = m.exec(l) || [
            '',
            '',
            ''
          ];
        if (0 == p[0].length && 0 == n[0].length)
          break;
        var c = 0 == p[1].length ? 0 : parseInt(p[1], 10), q = 0 == n[1].length ? 0 : parseInt(n[1], 10), c = goog.string.compareElements_(c, q) || goog.string.compareElements_(0 == p[2].length, 0 == n[2].length) || goog.string.compareElements_(p[2], n[2]);
      } while (0 == c);
    }
    return c;
  };
  goog.string.compareElements_ = function (a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
  };
  goog.string.HASHCODE_MAX_ = 4294967296;
  goog.string.hashCode = function (a) {
    for (var b = 0, c = 0; c < a.length; ++c)
      b = 31 * b + a.charCodeAt(c), b %= goog.string.HASHCODE_MAX_;
    return b;
  };
  goog.string.uniqueStringCounter_ = 2147483648 * Math.random() | 0;
  goog.string.createUniqueString = function () {
    return 'goog_' + goog.string.uniqueStringCounter_++;
  };
  goog.string.toNumber = function (a) {
    var b = Number(a);
    return 0 == b && goog.string.isEmpty(a) ? NaN : b;
  };
  goog.string.isLowerCamelCase = function (a) {
    return /^[a-z]+([A-Z][a-z]*)*$/.test(a);
  };
  goog.string.isUpperCamelCase = function (a) {
    return /^([A-Z][a-z]*)+$/.test(a);
  };
  goog.string.toCamelCase = function (a) {
    return String(a).replace(/\-([a-z])/g, function (a, c) {
      return c.toUpperCase();
    });
  };
  goog.string.toSelectorCase = function (a) {
    return String(a).replace(/([A-Z])/g, '-$1').toLowerCase();
  };
  goog.string.toTitleCase = function (a, b) {
    var c = goog.isString(b) ? goog.string.regExpEscape(b) : '\\s';
    return a.replace(RegExp('(^' + (c ? '|[' + c + ']+' : '') + ')([a-z])', 'g'), function (a, b, c) {
      return b + c.toUpperCase();
    });
  };
  goog.string.parseInt = function (a) {
    isFinite(a) && (a = String(a));
    return goog.isString(a) ? /^\s*-?0x/i.test(a) ? parseInt(a, 16) : parseInt(a, 10) : NaN;
  };
  goog.string.splitLimit = function (a, b, c) {
    a = a.split(b);
    for (var d = []; 0 < c && a.length;)
      d.push(a.shift()), c--;
    a.length && d.push(a.join(b));
    return d;
  };
  goog.debug = {};
  goog.debug.Error = function (a) {
    Error.captureStackTrace ? Error.captureStackTrace(this, goog.debug.Error) : this.stack = Error().stack || '';
    a && (this.message = String(a));
  };
  goog.inherits(goog.debug.Error, Error);
  goog.debug.Error.prototype.name = 'CustomError';
  goog.asserts = {};
  goog.asserts.ENABLE_ASSERTS = goog.DEBUG;
  goog.asserts.AssertionError = function (a, b) {
    b.unshift(a);
    goog.debug.Error.call(this, goog.string.subs.apply(null, b));
    b.shift();
    this.messagePattern = a;
  };
  goog.inherits(goog.asserts.AssertionError, goog.debug.Error);
  goog.asserts.AssertionError.prototype.name = 'AssertionError';
  goog.asserts.doAssertFailure_ = function (a, b, c, d) {
    var e = 'Assertion failed';
    if (c)
      var e = e + (': ' + c), f = d;
    else
      a && (e += ': ' + a, f = b);
    throw new goog.asserts.AssertionError('' + e, f || []);
  };
  goog.asserts.assert = function (a, b, c) {
    goog.asserts.ENABLE_ASSERTS && !a && goog.asserts.doAssertFailure_('', null, b, Array.prototype.slice.call(arguments, 2));
    return a;
  };
  goog.asserts.fail = function (a, b) {
    if (goog.asserts.ENABLE_ASSERTS)
      throw new goog.asserts.AssertionError('Failure' + (a ? ': ' + a : ''), Array.prototype.slice.call(arguments, 1));
  };
  goog.asserts.assertNumber = function (a, b, c) {
    goog.asserts.ENABLE_ASSERTS && !goog.isNumber(a) && goog.asserts.doAssertFailure_('Expected number but got %s: %s.', [
      goog.typeOf(a),
      a
    ], b, Array.prototype.slice.call(arguments, 2));
    return a;
  };
  goog.asserts.assertString = function (a, b, c) {
    goog.asserts.ENABLE_ASSERTS && !goog.isString(a) && goog.asserts.doAssertFailure_('Expected string but got %s: %s.', [
      goog.typeOf(a),
      a
    ], b, Array.prototype.slice.call(arguments, 2));
    return a;
  };
  goog.asserts.assertFunction = function (a, b, c) {
    goog.asserts.ENABLE_ASSERTS && !goog.isFunction(a) && goog.asserts.doAssertFailure_('Expected function but got %s: %s.', [
      goog.typeOf(a),
      a
    ], b, Array.prototype.slice.call(arguments, 2));
    return a;
  };
  goog.asserts.assertObject = function (a, b, c) {
    goog.asserts.ENABLE_ASSERTS && !goog.isObject(a) && goog.asserts.doAssertFailure_('Expected object but got %s: %s.', [
      goog.typeOf(a),
      a
    ], b, Array.prototype.slice.call(arguments, 2));
    return a;
  };
  goog.asserts.assertArray = function (a, b, c) {
    goog.asserts.ENABLE_ASSERTS && !goog.isArray(a) && goog.asserts.doAssertFailure_('Expected array but got %s: %s.', [
      goog.typeOf(a),
      a
    ], b, Array.prototype.slice.call(arguments, 2));
    return a;
  };
  goog.asserts.assertBoolean = function (a, b, c) {
    goog.asserts.ENABLE_ASSERTS && !goog.isBoolean(a) && goog.asserts.doAssertFailure_('Expected boolean but got %s: %s.', [
      goog.typeOf(a),
      a
    ], b, Array.prototype.slice.call(arguments, 2));
    return a;
  };
  goog.asserts.assertInstanceof = function (a, b, c, d) {
    !goog.asserts.ENABLE_ASSERTS || a instanceof b || goog.asserts.doAssertFailure_('instanceof check failed.', null, c, Array.prototype.slice.call(arguments, 3));
    return a;
  };
  goog.asserts.assertObjectPrototypeIsIntact = function () {
    for (var a in Object.prototype)
      goog.asserts.fail(a + ' should not be enumerable in Object.prototype.');
  };
  var Sk = {
      configure: function (a) {
        Sk.output = a.output || Sk.output;
        goog.asserts.assert('function' === typeof Sk.output);
        Sk.debugout = a.debugout || Sk.debugout;
        goog.asserts.assert('function' === typeof Sk.debugout);
        Sk.read = a.read || Sk.read;
        goog.asserts.assert('function' === typeof Sk.read);
        Sk.timeoutMsg = a.timeoutMsg || Sk.timeoutMsg;
        goog.asserts.assert('function' === typeof Sk.timeoutMsg);
        goog.exportSymbol('Sk.timeoutMsg', Sk.timeoutMsg);
        Sk.sysargv = a.sysargv || Sk.sysargv;
        goog.asserts.assert(goog.isArrayLike(Sk.sysargv));
        Sk.snapToAngle = a.snapToAngle || Sk.snapToAngle;
        goog.asserts.assertBoolean(Sk.snapToAngle, 'Sk.snapToAngle');
        Sk.physics = a.physics || Sk.physics;
        goog.asserts.assertBoolean(Sk.physics, 'Sk.physics');
        Sk.flyweight = a.flyweight || Sk.flyweight;
        goog.asserts.assertBoolean(Sk.flyweight, 'Sk.flyweight');
        Sk.python3 = a.python3 || Sk.python3;
        goog.asserts.assertBoolean(Sk.python3);
        Sk.inputfun = a.inputfun || Sk.inputfun;
        goog.asserts.assert('function' === typeof Sk.inputfun);
        Sk.throwSystemExit = a.systemexit || !1;
        goog.asserts.assert('boolean' === typeof Sk.throwSystemExit);
        a.syspath && (Sk.syspath = a.syspath, goog.asserts.assert(goog.isArrayLike(Sk.syspath)), Sk.realsyspath = void 0);
      }
    };
  goog.exportSymbol('Sk.configure', Sk.configure);
  Sk.timeoutMsg = function () {
    return 'Program exceeded run time limit.';
  };
  goog.exportSymbol('Sk.timeoutMsg', Sk.timeoutMsg);
  Sk.output = function (a) {
  };
  Sk.read = function (a) {
    throw 'Sk.read has not been implemented';
  };
  Sk.sysargv = [];
  Sk.getSysArgv = function () {
    return Sk.sysargv;
  };
  goog.exportSymbol('Sk.getSysArgv', Sk.getSysArgv);
  Sk.syspath = [];
  Sk.inBrowser = void 0 !== goog.global.document;
  Sk.debugout = function (a) {
  };
  (function () {
    void 0 !== goog.global.write ? Sk.output = goog.global.write : void 0 !== goog.global.console && void 0 !== goog.global.console.log ? Sk.output = function (a) {
      goog.global.console.log(a);
    } : void 0 !== goog.global.print && (Sk.output = goog.global.print);
    void 0 !== goog.global.print && (Sk.debugout = goog.global.print);
  }());
  if (!Sk.inBrowser) {
    var importScript = function (a) {
      a = goog.global.read('support/closure-library/closure/goog/' + a);
      goog.global.eval(a);
      return !0;
    };
    goog.global.CLOSURE_IMPORT_SCRIPT = importScript;
  }
  Sk.snapToAngle = !0;
  goog.exportSymbol('Sk.snapToAngle', Sk.snapToAngle);
  Sk.physics = !1;
  goog.exportSymbol('Sk.physics', Sk.physics);
  Sk.flyweight = !1;
  goog.exportSymbol('Sk.flyweight', Sk.flyweight);
  Sk.softSpace = !1;
  Sk.flyString = !0;
  goog.exportSymbol('Sk.flyString', Sk.flyString);
  Sk.python3 = !1;
  goog.exportSymbol('Sk.python3', Sk.python3);
  Sk.inputfun = function (a) {
    return window.prompt(a);
  };
  goog.exportSymbol('Sk.inputfun', Sk.inputfun);
  Sk.builtin = {};
  Sk.builtin.range = function (a, b, c) {
    var d = [], e;
    Sk.ffi.checkFunctionArgs('range(stop) or range(start, stop[, step])', arguments, 1, 3);
    Sk.builtin.pyCheckType('start', 'integer', Sk.builtin.checkInt(a));
    void 0 !== b && Sk.builtin.pyCheckType('stop', 'integer', Sk.builtin.checkInt(b));
    void 0 !== c && Sk.builtin.pyCheckType('step', 'integer', Sk.builtin.checkInt(c));
    a = Sk.ffi.remapToJs(a);
    b = Sk.ffi.remapToJs(b);
    c = Sk.ffi.remapToJs(c);
    void 0 === b && void 0 === c ? (b = a, a = 0, c = 1) : void 0 === c && (c = 1);
    if (0 === c)
      throw new Sk.builtin.ValueError('range() step argument must not be zero');
    if (0 < c)
      for (e = a; e < b; e += c)
        d.push(Sk.ffi.numberToIntPy(e));
    else
      for (e = a; e > b; e += c)
        d.push(Sk.ffi.numberToIntPy(e));
    return new Sk.builtin.list(d);
  };
  Sk.builtin.asnum$ = function (a) {
    return void 0 === a || null === a ? a : a === Sk.builtin.none.none$ ? null : a.constructor === Sk.builtin.bool ? a.v ? 1 : 0 : 'number' === typeof a ? a : 'string' === typeof a ? a : a.constructor === Sk.builtin.NumberPy ? a.v : a.constructor === Sk.builtin.lng ? a.cantBeInt() ? a.str$(10, !0) : a.toInt$() : a.constructor === Sk.builtin.biginteger ? 0 < a.trueCompare(new Sk.builtin.biginteger(Sk.builtin.lng.threshold$)) || 0 > a.trueCompare(new Sk.builtin.biginteger(-Sk.builtin.lng.threshold$)) ? a.toString() : a.intValue() : a;
  };
  goog.exportSymbol('Sk.builtin.asnum$', Sk.builtin.asnum$);
  Sk.builtin.asnum$nofloat = function (a) {
    if (void 0 === a || null === a)
      return a;
    if (a === Sk.builtin.none.none$)
      return null;
    if (a.constructor === Sk.builtin.bool)
      return a.v ? 1 : 0;
    'number' === typeof a && (a = a.toString());
    Sk.ffi.isFloat(a) && (a = Sk.ffi.remapToJs(a).toString());
    Sk.ffi.isInt(a) && (a = Sk.ffi.remapToJs(a).toString());
    a.constructor === Sk.builtin.lng && (a = a.str$(10, !0));
    a.constructor === Sk.builtin.biginteger && (a = a.toString());
    if (0 > a.indexOf('.') && 0 > a.indexOf('e') && 0 > a.indexOf('E'))
      return a;
    var b = 0, c;
    0 <= a.indexOf('e') ? (c = a.substr(0, a.indexOf('e')), b = a.substr(a.indexOf('e') + 1)) : 0 <= a.indexOf('E') ? (c = a.substr(0, a.indexOf('e')), b = a.substr(a.indexOf('E') + 1)) : c = a;
    b = parseInt(b, 10);
    a = c.indexOf('.');
    if (0 > a) {
      if (0 <= b) {
        for (; 0 < b--;)
          c += '0';
        return c;
      }
      return c.length > -b ? c.substr(0, c.length + b) : 0;
    }
    c = 0 == a ? c.substr(1) : a < c.length ? c.substr(0, a) + c.substr(a + 1) : c.substr(0, a);
    for (a += b; a > c.length;)
      c += '0';
    return c = 0 >= a ? 0 : c.substr(0, a);
  };
  goog.exportSymbol('Sk.builtin.asnum$nofloat', Sk.builtin.asnum$nofloat);
  Sk.builtin.round = function (a, b) {
    var c;
    Sk.builtin.pyCheckArgs('round', arguments, 1, 2);
    if (!Sk.builtin.checkNumber(a))
      throw new Sk.builtin.TypeError('a float is required');
    if (void 0 !== b && !Sk.misceval.isIndex(b))
      throw new Sk.builtin.TypeError('\'' + Sk.ffi.typeName(b) + '\' object cannot be interpreted as an index');
    void 0 === b && (b = 0);
    a = Sk.ffi.remapToJs(a);
    b = Sk.misceval.asIndex(b);
    c = Math.pow(10, b);
    c = Math.round(a * c) / c;
    return Sk.builtin.numberToPy(c);
  };
  Sk.builtin.len = function (a) {
    Sk.builtin.pyCheckArgs('len', arguments, 1, 1);
    if (a.sq$length)
      return Sk.ffi.numberToIntPy(a.sq$length());
    if (a.mp$length)
      return Sk.ffi.numberToIntPy(a.mp$length());
    if (a.tp$length)
      return a.tp$length();
    throw new Sk.builtin.TypeError('object of type \'' + Sk.ffi.typeName(a) + '\' has no len()');
  };
  Sk.builtin.min = function () {
    Sk.builtin.pyCheckArgs('min', arguments, 1);
    for (var a = Sk.misceval.arrayFromArguments(arguments), b = a[0], c = 1; c < a.length; ++c)
      Sk.misceval.richCompareBool(a[c], b, Sk.misceval.compareOp.Lt) && (b = a[c]);
    return b;
  };
  Sk.builtin.max = function () {
    Sk.builtin.pyCheckArgs('max', arguments, 1);
    for (var a = Sk.misceval.arrayFromArguments(arguments), b = a[0], c = 1; c < a.length; ++c)
      Sk.misceval.richCompareBool(a[c], b, Sk.misceval.compareOp.Gt) && (b = a[c]);
    return b;
  };
  Sk.builtin.any = function (a) {
    var b, c;
    Sk.builtin.pyCheckArgs('any', arguments, 1);
    if (!Sk.builtin.checkIterable(a))
      throw new Sk.builtin.TypeError('\'' + Sk.ffi.typeName(a) + '\' object is not iterable');
    b = a.tp$iter();
    for (c = b.tp$iternext(); void 0 !== c; c = b.tp$iternext())
      if (Sk.misceval.isTrue(c))
        return !0;
    return !1;
  };
  Sk.builtin.all = function (a) {
    var b, c;
    Sk.builtin.pyCheckArgs('all', arguments, 1);
    if (!Sk.builtin.checkIterable(a))
      throw new Sk.builtin.TypeError('\'' + Sk.ffi.typeName(a) + '\' object is not iterable');
    b = a.tp$iter();
    for (c = b.tp$iternext(); void 0 !== c; c = b.tp$iternext())
      if (!Sk.misceval.isTrue(c))
        return !1;
    return !0;
  };
  Sk.builtin.sum = function (a, b) {
    var c, d, e, f;
    Sk.builtin.pyCheckArgs('sum', arguments, 1, 2);
    Sk.builtin.pyCheckType('iter', 'iterable', Sk.builtin.checkIterable(a));
    if (void 0 !== b && Sk.builtin.isStringPy(b))
      throw new Sk.builtin.TypeError('sum() can\'t sum strings [use \'\'.join(seq) instead]');
    c = void 0 === b ? Sk.ffi.numberToIntPy(0) : b;
    d = a.tp$iter();
    for (e = d.tp$iternext(); void 0 !== e; e = d.tp$iternext())
      if (Sk.ffi.isFloat(e) ? (f = !0, Sk.ffi.isFloat(c) || (c = Sk.builtin.numberToPy(Sk.builtin.asnum$(c)))) : e instanceof Sk.builtin.lng && (f || c instanceof Sk.builtin.lng || (c = new Sk.builtin.lng(c))), void 0 !== c.nb$add(e))
        c = c.nb$add(e);
      else
        throw new Sk.builtin.TypeError('unsupported operand type(s) for +: \'' + Sk.ffi.typeName(c) + '\' and \'' + Sk.ffi.typeName(e) + '\'');
    return c;
  };
  Sk.builtin.zip = function () {
    if (0 === arguments.length)
      return new Sk.builtin.list([]);
    for (var a = [], b = 0; b < arguments.length; b++)
      if (arguments[b].tp$iter)
        a.push(arguments[b].tp$iter());
      else
        throw 'TypeError: argument ' + b + ' must support iteration';
    for (var c = [], d = !1; !d;) {
      for (var e = [], b = 0; b < arguments.length; b++) {
        var f = a[b].tp$iternext();
        if (void 0 === f) {
          d = !0;
          break;
        }
        e.push(f);
      }
      d || c.push(new Sk.builtin.tuple(e));
    }
    return new Sk.builtin.list(c);
  };
  Sk.builtin.abs = function (a) {
    return Sk.ffh.abs(a);
  };
  Sk.builtin.ord = function (a) {
    Sk.builtin.pyCheckArgs('ord', arguments, 1, 1);
    if (!Sk.builtin.isStringPy(a))
      throw new Sk.builtin.TypeError('ord() expected a string of length 1, but ' + Sk.ffi.typeName(a) + ' found');
    if (1 !== Sk.builtin.stringToJs(a).length)
      throw new Sk.builtin.TypeError('ord() expected a character, but string of length ' + Sk.builtin.stringToJs(a).length + ' found');
    return Sk.ffi.numberToIntPy(Sk.builtin.stringToJs(a).charCodeAt(0));
  };
  Sk.builtin.chr = function (a) {
    Sk.builtin.pyCheckArgs('chr', arguments, 1, 1);
    if (!Sk.builtin.checkInt(a))
      throw new Sk.builtin.TypeError('an integer is required');
    var b = Sk.builtin.asnum$(a);
    if (0 > b || 255 < b)
      throw new Sk.builtin.ValueError('chr() arg not in range(256)');
    return Sk.builtin.stringToPy(String.fromCharCode(b));
  };
  Sk.builtin.int2str_ = function (a, b, c) {
    var d = '';
    if (Sk.ffi.isLong(a)) {
      var e = '';
      2 !== b && (e = 'L');
      d = a.str$(b, !1);
      return a.nb$isnegative() ? Sk.builtin.stringToPy('-' + c + d + e) : Sk.builtin.stringToPy(c + d + e);
    }
    a = Sk.misceval.asIndex(a);
    d = a.toString(b);
    return 0 > a ? Sk.builtin.stringToPy('-' + c + d.slice(1)) : Sk.builtin.stringToPy(c + d);
  };
  Sk.builtin.hex = function (a) {
    Sk.builtin.pyCheckArgs('hex', arguments, 1, 1);
    if (!Sk.misceval.isIndex(a))
      throw new Sk.builtin.TypeError('hex() argument can\'t be converted to hex');
    return Sk.builtin.int2str_(a, 16, '0x');
  };
  Sk.builtin.oct = function (a) {
    Sk.builtin.pyCheckArgs('oct', arguments, 1, 1);
    if (!Sk.misceval.isIndex(a))
      throw new Sk.builtin.TypeError('oct() argument can\'t be converted to hex');
    return Sk.builtin.int2str_(a, 8, '0');
  };
  Sk.builtin.bin = function (a) {
    Sk.builtin.pyCheckArgs('bin', arguments, 1, 1);
    if (!Sk.misceval.isIndex(a))
      throw new Sk.builtin.TypeError('\'' + Sk.ffi.typeName(a) + '\' object can\'t be interpreted as an index');
    return Sk.builtin.int2str_(a, 2, '0b');
  };
  Sk.builtin.dir = function (a) {
    Sk.builtin.pyCheckArgs('dir', arguments, 1, 1);
    var b = function (a) {
        goog.asserts.assertString(a);
        var b = null;
        if (-1 !== [
            '__bases__',
            '__mro__',
            '__class__'
          ].indexOf(a))
          return null;
        -1 !== a.indexOf('$') ? b = Sk.builtin.dir.slotNameToRichName(a) : '_' !== a.charAt(a.length - 1) ? b = a : '_' === a.charAt(0) && (b = a);
        return b;
      }, c = [], d, e, f, g, h;
    for (d in a.constructor.prototype)
      (e = b(d)) && c.push(Sk.builtin.stringToPy(e));
    if (a.$d)
      if (a.$d.tp$iter)
        for (f = a.$d.tp$iter(), d = f.tp$iternext(); void 0 !== d; d = f.tp$iternext())
          (e = b(Sk.ffi.remapToJs(new Sk.builtin.StringPy(d)))) && c.push(Sk.builtin.stringToPy(e));
      else
        for (e in a.$d)
          c.push(new Sk.builtin.StringPy(e));
    if (f = a.tp$mro)
      for (f = a.tp$mro, d = 0; d < f.v.length; ++d)
        for (h in g = f.v[d], g)
          g.hasOwnProperty(h) && (e = b(h)) && c.push(Sk.builtin.stringToPy(e));
    c.sort(function (a, b) {
      return (a.v > b.v) - (a.v < b.v);
    });
    return new Sk.builtin.list(c.filter(function (a, b, c) {
      return a !== c[b + 1];
    }));
  };
  Sk.builtin.dir.slotNameToRichName = function (a) {
  };
  Sk.builtin.repr = function (a) {
    Sk.builtin.pyCheckArgs('repr', arguments, 1, 1);
    return Sk.misceval.objectRepr(a);
  };
  Sk.builtin.open = function (a, b, c) {
    Sk.builtin.pyCheckArgs('open', arguments, 1, 3);
    void 0 === b && (b = Sk.builtin.stringToPy('r'));
    if ('r' !== b.v && 'rb' !== b.v)
      throw 'todo; haven\'t implemented non-read opens';
    return new Sk.builtin.file(a, b, c);
  };
  Sk.builtin.isinstance = function (a, b) {
    Sk.builtin.pyCheckArgs('isinstance', arguments, 2, 2);
    if (!(Sk.builtin.checkClass(b) || b instanceof Sk.builtin.tuple))
      throw new Sk.builtin.TypeError('isinstance() arg 2 must be a class, type, or tuple of classes and types');
    if (b === Sk.builtin.int_.prototype.ob$type)
      return 'number' === a.tp$name && a.skType === Sk.builtin.NumberPy.int$;
    if (b === Sk.builtin.float_.prototype.ob$type)
      return 'number' === a.tp$name && Sk.ffi.isFloat(a);
    if (b === Sk.builtin.none.none$.ob$type)
      return a === Sk.builtin.none.none$;
    if (a.ob$type === b)
      return !0;
    if (b instanceof Sk.builtin.tuple) {
      for (var c = 0; c < b.v.length; ++c)
        if (Sk.builtin.isinstance(a, b.v[c]))
          return !0;
      return !1;
    }
    var d = function (a, b) {
      if (a === b)
        return !0;
      if (void 0 === a.$d)
        return !1;
      for (var c = a.$d.mp$subscript(Sk.builtin.type.basesStr_), h = 0; h < c.v.length; ++h)
        if (d(c.v[h], b))
          return !0;
      return !1;
    };
    return d(a.ob$type, b);
  };
  Sk.builtin.hashCount = 0;
  Sk.builtin.hash = function (a) {
    Sk.builtin.pyCheckArgs('hash', arguments, 1, 1);
    if (a instanceof Object && void 0 !== a.tp$hash) {
      if (a.$savedHash_)
        return a.$savedHash_;
      a.$savedHash_ = a.tp$hash();
      return a.$savedHash_;
    }
    return a instanceof Object && void 0 !== a.__hash__ ? Sk.misceval.callsim(a.__hash__, a) : a instanceof Sk.builtin.bool ? a.v ? 1 : 0 : a === Sk.builtin.none.none$ ? 0 : a instanceof Object ? (void 0 === a.__id && (Sk.builtin.hashCount += 1, a.__id = Sk.builtin.hashCount), a.__id) : 'number' === typeof a ? a : null === a ? 0 : !0 === a ? 1 : !1 === a ? 0 : typeof a + ' ' + String(a);
  };
  Sk.builtin.getattr = function (a, b, c) {
    Sk.builtin.pyCheckArgs('getattr', arguments, 2, 3);
    if (!Sk.builtin.isStringPy(b))
      throw new Sk.builtin.TypeError('attribute name must be string');
    var d = a.tp$getattr(Sk.builtin.stringToJs(b));
    if (void 0 === d) {
      if (void 0 !== c)
        return c;
      throw new Sk.builtin.AttributeError('\'' + Sk.ffi.typeName(a) + '\' object has no attribute \'' + Sk.builtin.stringToJs(b) + '\'');
    }
    return d;
  };
  Sk.builtin.raw_input = function (a, b, c) {
    a = Sk.inputfun(a.v);
    return new Sk.builtin.StringPy(a);
  };
  Sk.builtin.input = function (a, b, c) {
    Sk.ffi.checkFunctionArgs('input', arguments, 0, 1);
    if (Sk.ffi.isDefined(a)) {
      Sk.ffi.checkArgType('prompt', Sk.ffi.PyType.STR, Sk.builtin.isStringPy(a), a);
      var d = Sk.inputfun(Sk.builtin.stringToJs(a));
    } else
      d = Sk.inputfun('');
    return Sk.builtin.stringToPy(d);
  };
  Sk.builtin.jseval = function (a) {
    goog.global.eval(a);
  };
  Sk.builtin.jsmillis = function () {
    return new Date().valueOf();
  };
  Sk.builtin.superbi = function () {
    throw new Sk.builtin.NotImplementedError('super is not yet implemented, please report your use case as a github issue.');
  };
  Sk.builtin.eval_ = function () {
    throw new Sk.builtin.NotImplementedError('eval is not yet implemented');
  };
  Sk.builtin.map = function (a, b) {
    Sk.ffi.checkFunctionArgs('map(function, iterable, ...)', arguments, 2);
    if (2 < arguments.length) {
      var c = [], d = Array.prototype.slice.apply(arguments).slice(1), e;
      for (e in d) {
        if (void 0 === d[e].tp$iter)
          throw c = parseInt(e, 10) + 2, new Sk.builtin.TypeError('argument ' + c + ' to map() must support iteration');
        d[e] = d[e].tp$iter();
      }
      for (;;) {
        var f = [], g = 0;
        for (e in d) {
          var h = d[e].tp$iternext();
          void 0 === h ? (f.push(Sk.builtin.none.none$), g++) : f.push(h);
        }
        if (g !== d.length)
          c.push(f);
        else
          break;
      }
      b = new Sk.builtin.list(c);
    }
    if (void 0 === b.tp$iter)
      throw new Sk.builtin.TypeError('\'' + Sk.ffi.typeName(b) + '\' object is not iterable');
    c = [];
    d = b.tp$iter();
    for (e = d.tp$iternext(); void 0 !== e; e = d.tp$iternext())
      a === Sk.builtin.none.none$ ? (e instanceof Array && (e = new Sk.builtin.tuple(e)), c.push(e)) : (e instanceof Array || (e = [e]), c.push(Sk.misceval.apply(a, void 0, void 0, void 0, e)));
    return new Sk.builtin.list(c);
  };
  Sk.builtin.reduce = function (a, b, c) {
    Sk.builtin.pyCheckArgs('reduce', arguments, 2, 3);
    var d = b.tp$iter();
    if (void 0 === c && (c = d.tp$iternext(), void 0 === c))
      throw new Sk.builtin.TypeError('reduce() of empty sequence with no initial value');
    for (var e = c, f = d.tp$iternext(); void 0 !== f;)
      e = a.func_code(e, f), f = d.tp$iternext();
    return e;
  };
  Sk.builtin.filter = function (a, b) {
    Sk.builtin.pyCheckArgs('filter', arguments, 2, 2);
    if (void 0 === b.tp$iter)
      throw new Sk.builtin.TypeError('\'' + Sk.ffi.typeName(b) + '\' object is not iterable');
    a === Sk.builtin.none.none$ && (a = {
      func_code: function (a) {
        return Sk.builtin.bool(a);
      }
    });
    var c = function () {
        return [];
      }, d = function (a, b) {
        a.push(b);
        return a;
      }, e = function (a) {
        return new Sk.builtin.list(a);
      };
    Sk.builtin.isStringPy(b) ? (c = function () {
      return Sk.builtin.stringToPy('');
    }, d = function (a, b) {
      return a.sq$concat(b);
    }, e = function (a) {
      return a;
    }) : b.__class__ === Sk.builtin.tuple && (e = function (a) {
      return new Sk.builtin.tuple(a);
    });
    var f = b.tp$iter(), g = f.tp$iternext(), c = c();
    if (void 0 === g)
      return e(c);
    for (; void 0 !== g;)
      Sk.misceval.isTrue(a.func_code(g)) && (c = d(c, g)), g = f.tp$iternext();
    return e(c);
  };
  Sk.builtin.hasattr = function (a, b) {
    Sk.builtin.pyCheckArgs('hasattr', arguments, 2, 2);
    if (!Sk.builtin.isStringPy(b))
      throw new Sk.builtin.TypeError('hasattr(): attribute name must be string');
    if (a.tp$getattr)
      return a.tp$getattr(b.v) ? !0 : !1;
    throw new Sk.builtin.AttributeError('Object has no tp$getattr method');
  };
  Sk.builtin.pow = function (a, b, c) {
    Sk.builtin.pyCheckArgs('pow', arguments, 2, 3);
    var d = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(b);
    Sk.ffi.remapToJs(c);
    if (!Sk.builtin.checkNumber(a) || !Sk.builtin.checkNumber(b)) {
      if (void 0 === c)
        throw new Sk.builtin.TypeError('unsupported operand type(s) for pow(): \'' + Sk.ffi.typeName(a) + '\' and \'' + Sk.ffi.typeName(b) + '\'');
      throw new Sk.builtin.TypeError('unsupported operand type(s) for pow(): \'' + Sk.ffi.typeName(a) + '\', \'' + Sk.ffi.typeName(b) + '\', \'' + Sk.ffi.typeName(c) + '\'');
    }
    if (0 > d && Sk.ffi.isFloat(b))
      throw new Sk.builtin.ValueError('negative number cannot be raised to a fractional power');
    if (void 0 === c)
      return d = Math.pow(d, e), Sk.ffi.isFloat(a) || Sk.ffi.isFloat(b) || 0 > e ? Sk.builtin.numberToPy(d) : Sk.ffi.isLong(a) || Sk.ffi.isLong(b) ? new Sk.builtin.lng(d) : Sk.ffi.numberToIntPy(d);
    if (!Sk.builtin.checkInt(a) || !Sk.builtin.checkInt(b) || !Sk.builtin.checkInt(c))
      throw new Sk.builtin.TypeError('pow() 3rd argument not allowed unless all arguments are integers');
    if (0 > e)
      throw new Sk.builtin.TypeError('pow() 2nd argument cannot be negative when 3rd argument specified');
    return a instanceof Sk.builtin.lng || (b instanceof Sk.builtin.lng || c instanceof Sk.builtin.lng) || Infinity === Math.pow(d, e) ? new Sk.builtin.lng(a).nb$power(b, c) : Sk.ffi.numberToIntPy(Math.pow(d, e)).nb$remainder(c);
  };
  Sk.builtin.quit = function (a) {
    a = Sk.builtin.stringToJs(new Sk.builtin.StringPy(a));
    throw new Sk.builtin.SystemExit(a);
  };
  Sk.builtin.sorted = function (a, b, c, d) {
    var e;
    if (void 0 !== c && c !== Sk.builtin.none.none$) {
      e = b === Sk.builtin.none.none$ ? {
        func_code: function (a, b) {
          return Sk.misceval.richCompareBool(a[0], b[0], Sk.misceval.compareOp.Lt) ? Sk.ffi.numberToIntPy(-1) : Sk.ffi.numberToIntPy(0);
        }
      } : {
        func_code: function (a, c) {
          return b.func_code(a[0], c[0]);
        }
      };
      a = a.tp$iter();
      for (var f = a.tp$iternext(), g = []; void 0 !== f;)
        g.push([
          c.func_code(f),
          f
        ]), f = a.tp$iternext();
      a = new Sk.builtin.list(g);
    } else
      b !== Sk.builtin.none.none$ && void 0 !== b && (e = b), a = new Sk.builtin.list(a);
    void 0 !== e ? a.list_sort_(a, e) : a.list_sort_(a);
    d && a.list_reverse_(a);
    if (void 0 !== c && c !== Sk.builtin.none.none$) {
      a = a.tp$iter();
      f = a.tp$iternext();
      for (g = []; void 0 !== f;)
        g.push(f[1]), f = a.tp$iternext();
      a = new Sk.builtin.list(g);
    }
    return a;
  };
  Sk.builtin.bytearray = function () {
    throw new Sk.builtin.NotImplementedError('bytearray is not yet implemented');
  };
  Sk.builtin.callable = function () {
    throw new Sk.builtin.NotImplementedError('callable is not yet implemented');
  };
  Sk.builtin.delattr = function () {
    throw new Sk.builtin.NotImplementedError('delattr is not yet implemented');
  };
  Sk.builtin.divmod = function () {
    throw new Sk.builtin.NotImplementedError('divmod is not yet implemented');
  };
  Sk.builtin.execfile = function () {
    throw new Sk.builtin.NotImplementedError('execfile is not yet implemented');
  };
  Sk.builtin.format = function () {
    throw new Sk.builtin.NotImplementedError('format is not yet implemented');
  };
  Sk.builtin.frozenset = function () {
    throw new Sk.builtin.NotImplementedError('frozenset is not yet implemented');
  };
  Sk.builtin.globals = function () {
    throw new Sk.builtin.NotImplementedError('globals is not yet implemented');
  };
  Sk.builtin.help = function () {
    throw new Sk.builtin.NotImplementedError('help is not yet implemented');
  };
  Sk.builtin.issubclass = function () {
    throw new Sk.builtin.NotImplementedError('issubclass is not yet implemented');
  };
  Sk.builtin.iter = function () {
    throw new Sk.builtin.NotImplementedError('iter is not yet implemented');
  };
  Sk.builtin.locals = function () {
    throw new Sk.builtin.NotImplementedError('locals is not yet implemented');
  };
  Sk.builtin.memoryview = function () {
    throw new Sk.builtin.NotImplementedError('memoryview is not yet implemented');
  };
  Sk.builtin.next_ = function () {
    throw new Sk.builtin.NotImplementedError('next is not yet implemented');
  };
  Sk.builtin.property = function () {
    throw new Sk.builtin.NotImplementedError('property is not yet implemented');
  };
  Sk.builtin.reload = function () {
    throw new Sk.builtin.NotImplementedError('reload is not yet implemented');
  };
  Sk.builtin.reversed = function () {
    throw new Sk.builtin.NotImplementedError('reversed is not yet implemented');
  };
  Sk.builtin.unichr = function () {
    throw new Sk.builtin.NotImplementedError('unichr is not yet implemented');
  };
  Sk.builtin.vars = function () {
    throw new Sk.builtin.NotImplementedError('vars is not yet implemented');
  };
  Sk.builtin.xrange = Sk.builtin.range;
  Sk.builtin.apply_ = function () {
    throw new Sk.builtin.NotImplementedError('apply is not yet implemented');
  };
  Sk.builtin.buffer = function () {
    throw new Sk.builtin.NotImplementedError('buffer is not yet implemented');
  };
  Sk.builtin.coerce = function () {
    throw new Sk.builtin.NotImplementedError('coerce is not yet implemented');
  };
  Sk.builtin.intern = function () {
    throw new Sk.builtin.NotImplementedError('intern is not yet implemented');
  };
  Sk.builtin.Exception = function (a) {
    a = Array.prototype.slice.call(arguments);
    for (var b = 0; b < a.length; ++b)
      'string' === typeof a[b] && (a[b] = Sk.builtin.stringToPy(a[b]));
    this.args = new Sk.builtin.tuple(a);
    Sk.currFilename ? this.filename = Sk.currFilename : 3 <= this.args.sq$length() ? this.filename = this.args.v[1].v ? this.args.v[1].v : '<unknown>' : this.filename = '<unknown>';
    3 <= this.args.sq$length() ? this.lineno = this.args.v[2] : this.lineno = 0 < Sk.currLineNo ? Sk.currLineNo : '<unknown>';
    this.colno = 0 < Sk.currColNo ? Sk.currColNo : '<unknown>';
  };
  Sk.builtin.Exception.prototype.tp$name = 'Exception';
  Sk.builtin.Exception.prototype.tp$str = function () {
    var a;
    a = '' + this.tp$name;
    this.args && (a += ': ' + (0 < this.args.v.length ? this.args.v[0].v : ''));
    a += ' on line ' + this.lineno;
    if (4 < this.args.v.length) {
      a += '\n' + this.args.v[4].v + '\n';
      for (var b = 0; b < this.args.v[3]; ++b)
        a += ' ';
      a += '^\n';
    }
    return Sk.builtin.stringToPy(a);
  };
  Sk.builtin.Exception.prototype.toString = function () {
    return this.tp$str().v;
  };
  goog.exportSymbol('Sk.builtin.Exception', Sk.builtin.Exception);
  Sk.builtin.AssertionError = function (a) {
    if (!(this instanceof Sk.builtin.AssertionError)) {
      var b = Object.create(Sk.builtin.AssertionError.prototype);
      b.constructor.apply(b, arguments);
      return b;
    }
    Sk.builtin.Exception.apply(this, arguments);
  };
  goog.inherits(Sk.builtin.AssertionError, Sk.builtin.Exception);
  Sk.builtin.AssertionError.prototype.tp$name = 'AssertionError';
  goog.exportSymbol('Sk.builtin.AssertionError', Sk.builtin.AssertionError);
  Sk.builtin.AttributeError = function (a) {
    if (!(this instanceof Sk.builtin.AttributeError)) {
      var b = Object.create(Sk.builtin.AttributeError.prototype);
      b.constructor.apply(b, arguments);
      return b;
    }
    Sk.builtin.Exception.apply(this, arguments);
  };
  goog.inherits(Sk.builtin.AttributeError, Sk.builtin.Exception);
  Sk.builtin.AttributeError.prototype.tp$name = 'AttributeError';
  Sk.builtin.ImportError = function (a) {
    if (!(this instanceof Sk.builtin.ImportError)) {
      var b = Object.create(Sk.builtin.ImportError.prototype);
      b.constructor.apply(b, arguments);
      return b;
    }
    Sk.builtin.Exception.apply(this, arguments);
  };
  goog.inherits(Sk.builtin.ImportError, Sk.builtin.Exception);
  Sk.builtin.ImportError.prototype.tp$name = 'ImportError';
  Sk.builtin.IndentationError = function (a) {
    if (!(this instanceof Sk.builtin.IndentationError)) {
      var b = Object.create(Sk.builtin.IndentationError.prototype);
      b.constructor.apply(b, arguments);
      return b;
    }
    Sk.builtin.Exception.apply(this, arguments);
  };
  goog.inherits(Sk.builtin.IndentationError, Sk.builtin.Exception);
  Sk.builtin.IndentationError.prototype.tp$name = 'IndentationError';
  Sk.builtin.IndexError = function (a) {
    if (!(this instanceof Sk.builtin.IndexError)) {
      var b = Object.create(Sk.builtin.IndexError.prototype);
      b.constructor.apply(b, arguments);
      return b;
    }
    Sk.builtin.Exception.apply(this, arguments);
  };
  goog.inherits(Sk.builtin.IndexError, Sk.builtin.Exception);
  Sk.builtin.IndexError.prototype.tp$name = 'IndexError';
  Sk.builtin.KeyError = function (a) {
    if (!(this instanceof Sk.builtin.KeyError)) {
      var b = Object.create(Sk.builtin.KeyError.prototype);
      b.constructor.apply(b, arguments);
      return b;
    }
    Sk.builtin.Exception.apply(this, arguments);
  };
  goog.inherits(Sk.builtin.KeyError, Sk.builtin.Exception);
  Sk.builtin.KeyError.prototype.tp$name = 'KeyError';
  Sk.builtin.NameError = function (a) {
    if (!(this instanceof Sk.builtin.NameError)) {
      var b = Object.create(Sk.builtin.NameError.prototype);
      b.constructor.apply(b, arguments);
      return b;
    }
    Sk.builtin.Exception.apply(this, arguments);
  };
  goog.inherits(Sk.builtin.NameError, Sk.builtin.Exception);
  Sk.builtin.NameError.prototype.tp$name = 'NameError';
  Sk.builtin.OverflowError = function (a) {
    if (!(this instanceof Sk.builtin.OverflowError)) {
      var b = Object.create(Sk.builtin.OverflowError.prototype);
      b.constructor.apply(b, arguments);
      return b;
    }
    Sk.builtin.Exception.apply(this, arguments);
  };
  goog.inherits(Sk.builtin.OverflowError, Sk.builtin.Exception);
  Sk.builtin.OverflowError.prototype.tp$name = 'OverflowError';
  Sk.builtin.ParseError = function (a) {
    if (!(this instanceof Sk.builtin.ParseError)) {
      var b = Object.create(Sk.builtin.ParseError.prototype);
      b.constructor.apply(b, arguments);
      return b;
    }
    Sk.builtin.Exception.apply(this, arguments);
  };
  goog.inherits(Sk.builtin.ParseError, Sk.builtin.Exception);
  Sk.builtin.ParseError.prototype.tp$name = 'ParseError';
  Sk.builtin.SystemExit = function (a) {
    if (!(this instanceof Sk.builtin.SystemExit)) {
      var b = Object.create(Sk.builtin.SystemExit.prototype);
      b.constructor.apply(b, arguments);
      return b;
    }
    Sk.builtin.Exception.apply(this, arguments);
  };
  goog.inherits(Sk.builtin.SystemExit, Sk.builtin.Exception);
  Sk.builtin.SystemExit.prototype.tp$name = 'SystemExit';
  goog.exportSymbol('Sk.builtin.SystemExit', Sk.builtin.SystemExit);
  Sk.builtin.SyntaxError = function (a) {
    if (!(this instanceof Sk.builtin.SyntaxError)) {
      var b = Object.create(Sk.builtin.SyntaxError.prototype);
      b.constructor.apply(b, arguments);
      return b;
    }
    Sk.builtin.Exception.apply(this, arguments);
  };
  goog.inherits(Sk.builtin.SyntaxError, Sk.builtin.Exception);
  Sk.builtin.SyntaxError.prototype.tp$name = 'SyntaxError';
  Sk.builtin.TokenError = function (a) {
    if (!(this instanceof Sk.builtin.TokenError)) {
      var b = Object.create(Sk.builtin.TokenError.prototype);
      b.constructor.apply(b, arguments);
      return b;
    }
    Sk.builtin.Exception.apply(this, arguments);
  };
  goog.inherits(Sk.builtin.TokenError, Sk.builtin.Exception);
  Sk.builtin.TokenError.prototype.tp$name = 'TokenError';
  Sk.builtin.TypeError = function (a) {
    if (!(this instanceof Sk.builtin.TypeError)) {
      var b = Object.create(Sk.builtin.TypeError.prototype);
      b.constructor.apply(b, arguments);
      return b;
    }
    Sk.builtin.Exception.apply(this, arguments);
  };
  goog.inherits(Sk.builtin.TypeError, Sk.builtin.Exception);
  Sk.builtin.TypeError.prototype.tp$name = 'TypeError';
  goog.exportSymbol('Sk.builtin.TypeError', Sk.builtin.TypeError);
  Sk.builtin.ValueError = function (a) {
    if (!(this instanceof Sk.builtin.ValueError)) {
      var b = Object.create(Sk.builtin.ValueError.prototype);
      b.constructor.apply(b, arguments);
      return b;
    }
    Sk.builtin.Exception.apply(this, arguments);
  };
  goog.inherits(Sk.builtin.ValueError, Sk.builtin.Exception);
  Sk.builtin.ValueError.prototype.tp$name = 'ValueError';
  goog.exportSymbol('Sk.builtin.ValueError', Sk.builtin.ValueError);
  Sk.builtin.ZeroDivisionError = function (a) {
    if (!(this instanceof Sk.builtin.ZeroDivisionError)) {
      var b = Object.create(Sk.builtin.ZeroDivisionError.prototype);
      b.constructor.apply(b, arguments);
      return b;
    }
    Sk.builtin.Exception.apply(this, arguments);
  };
  goog.inherits(Sk.builtin.ZeroDivisionError, Sk.builtin.Exception);
  Sk.builtin.ZeroDivisionError.prototype.tp$name = 'ZeroDivisionError';
  Sk.builtin.TimeLimitError = function (a) {
    if (!(this instanceof Sk.builtin.TimeLimitError)) {
      var b = Object.create(Sk.builtin.TimeLimitError.prototype);
      b.constructor.apply(b, arguments);
      return b;
    }
    Sk.builtin.Exception.apply(this, arguments);
  };
  goog.inherits(Sk.builtin.TimeLimitError, Sk.builtin.Exception);
  Sk.builtin.TimeLimitError.prototype.tp$name = 'TimeLimitError';
  goog.exportSymbol('Sk.builtin.TimeLimitError', Sk.builtin.TimeLimitError);
  Sk.builtin.IOError = function (a) {
    if (!(this instanceof Sk.builtin.IOError)) {
      var b = Object.create(Sk.builtin.IOError.prototype);
      b.constructor.apply(b, arguments);
      return b;
    }
    Sk.builtin.Exception.apply(this, arguments);
  };
  goog.inherits(Sk.builtin.IOError, Sk.builtin.Exception);
  Sk.builtin.IOError.prototype.tp$name = 'IOError';
  goog.exportSymbol('Sk.builtin.IOError', Sk.builtin.IOError);
  Sk.builtin.NotImplementedError = function (a) {
    if (!(this instanceof Sk.builtin.NotImplementedError)) {
      var b = Object.create(Sk.builtin.NotImplementedError.prototype);
      b.constructor.apply(b, arguments);
      return b;
    }
    Sk.builtin.Exception.apply(this, arguments);
  };
  goog.inherits(Sk.builtin.NotImplementedError, Sk.builtin.Exception);
  Sk.builtin.NotImplementedError.prototype.tp$name = 'NotImplementedError';
  goog.exportSymbol('Sk.builtin.NotImplementedError', Sk.builtin.NotImplementedError);
  Sk.builtin.NegativePowerError = function (a) {
    if (!(this instanceof Sk.builtin.NegativePowerError)) {
      var b = Object.create(Sk.builtin.NegativePowerError.prototype);
      b.constructor.apply(b, arguments);
      return b;
    }
    Sk.builtin.Exception.apply(this, arguments);
  };
  goog.inherits(Sk.builtin.NegativePowerError, Sk.builtin.Exception);
  Sk.builtin.NegativePowerError.prototype.tp$name = 'NegativePowerError';
  goog.exportSymbol('Sk.builtin.NegativePowerError', Sk.builtin.NegativePowerError);
  Sk.builtin.OperationError = function (a) {
    if (!(this instanceof Sk.builtin.OperationError)) {
      var b = Object.create(Sk.builtin.OperationError.prototype);
      b.constructor.apply(b, arguments);
      return b;
    }
    Sk.builtin.Exception.apply(this, arguments);
  };
  goog.inherits(Sk.builtin.OperationError, Sk.builtin.Exception);
  Sk.builtin.OperationError.prototype.tp$name = 'OperationError';
  goog.exportSymbol('Sk.builtin.OperationError', Sk.builtin.OperationError);
  Sk.builtin.SystemError = function (a) {
    if (!(this instanceof Sk.builtin.SystemError)) {
      var b = Object.create(Sk.builtin.SystemError.prototype);
      b.constructor.apply(b, arguments);
      return b;
    }
    Sk.builtin.Exception.apply(this, arguments);
  };
  goog.inherits(Sk.builtin.SystemError, Sk.builtin.Exception);
  Sk.builtin.SystemError.prototype.tp$name = 'SystemError';
  goog.exportSymbol('Sk.builtin.SystemError', Sk.builtin.SystemError);
  Sk.currLineNo = -1;
  Sk.currColNo = -1;
  Sk.currFilename = '';
  goog.exportSymbol('Sk', Sk);
  goog.exportProperty(Sk, 'currLineNo', Sk.currLineNo);
  goog.exportProperty(Sk, 'currColNo', Sk.currColNo);
  goog.exportProperty(Sk, 'currFilename', Sk.currFilename);
  Sk.builtin.type = function (a, b, c) {
    if (void 0 === b && void 0 === c)
      return Sk.ffi.type(a);
    var d = function (a, b, c, e) {
        if (!(this instanceof d))
          return new d(a, b, c, e);
        e = e || [];
        this.$d = new Sk.builtin.dict([]);
        var k = Sk.builtin.type.typeLookup(this.ob$type, '__init__');
        void 0 !== k && (e.unshift(this), Sk.misceval.apply(k, a, b, c, e));
        return this;
      }, e;
    for (e in c)
      d.prototype[e] = c[e], d[e] = c[e];
    d.__class__ = d;
    d.sk$klass = !0;
    d.prototype.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;
    d.prototype.tp$setattr = Sk.builtin.object.prototype.GenericSetAttr;
    d.prototype.tp$descr_get = function () {
      goog.asserts.fail('in type tp$descr_get');
    };
    d.prototype.tp$repr = function () {
      var b = this.tp$getattr('__repr__');
      if (void 0 !== b)
        return Sk.misceval.apply(b, void 0, void 0, void 0, []);
      var b = c.__module__, d = '';
      b && (d = b.v + '.');
      return Sk.builtin.stringToPy('<' + d + a + ' object>');
    };
    d.prototype.tp$str = function () {
      var a = this.tp$getattr('__str__');
      return void 0 !== a ? Sk.misceval.apply(a, void 0, void 0, void 0, []) : this.tp$repr();
    };
    d.prototype.tp$length = function () {
      var a = this.tp$getattr('__len__');
      if (void 0 !== a)
        return Sk.misceval.apply(a, void 0, void 0, void 0, []);
      a = Sk.ffi.typeName(this);
      throw new Sk.builtin.AttributeError(a + ' instance has no attribute \'__len__\'');
    };
    d.prototype.tp$call = function (a, b) {
      var c = this.tp$getattr('__call__');
      if (c)
        return Sk.misceval.apply(c, void 0, void 0, b, a);
      throw new Sk.builtin.TypeError('\'' + Sk.ffi.typeName(this) + '\' object is not callable');
    };
    d.prototype.tp$iter = function () {
      var a = this.tp$getattr('__iter__'), b = Sk.ffi.typeName(this);
      if (a)
        return Sk.misceval.callsim(a);
      throw new Sk.builtin.TypeError('\'' + b + '\' object is not iterable');
    };
    d.prototype.tp$iternext = function () {
      var a = this.tp$getattr('next');
      goog.asserts.assert(void 0 !== a, 'iter() should have caught this');
      return Sk.misceval.callsim(a);
    };
    d.prototype.tp$getitem = function (a) {
      var b = this.tp$getattr('__getitem__');
      if (void 0 !== b)
        return Sk.misceval.apply(b, void 0, void 0, void 0, [a]);
      throw new Sk.builtin.TypeError('\'' + Sk.ffi.typeName(this) + '\' object does not support indexing');
    };
    d.prototype.tp$setitem = function (a, b) {
      var c = this.tp$getattr('__setitem__');
      if (void 0 !== c)
        return Sk.misceval.apply(c, void 0, void 0, void 0, [
          a,
          b
        ]);
      throw new Sk.builtin.TypeError('\'' + Sk.ffi.typeName(this) + '\' object does not support item assignment');
    };
    d.prototype.tp$name = a;
    b && (d.$d = new Sk.builtin.dict([]), d.$d.mp$ass_subscript(Sk.builtin.type.basesStr_, new Sk.builtin.tuple(b)), b = Sk.builtin.type.buildMRO(d), d.$d.mp$ass_subscript(Sk.builtin.type.mroStr_, b), d.tp$mro = b);
    d.prototype.ob$type = d;
    Sk.builtin.type.makeIntoTypeObj(a, d);
    d.tp$setattr = Sk.builtin.type.prototype.tp$setattr;
    return d;
  };
  Sk.builtin.type.makeTypeObj = function (a, b) {
    Sk.builtin.type.makeIntoTypeObj(a, b);
    return b;
  };
  Sk.builtin.type.makeIntoTypeObj = function (a, b) {
    goog.asserts.assert(void 0 !== a);
    goog.asserts.assert(void 0 !== b);
    b.ob$type = Sk.builtin.type;
    b.tp$name = a;
    b.tp$repr = function () {
      var a = b.__module__, d = '';
      a && (d = a.v + '.');
      var e = 'class';
      a || b.sk$klass || (e = 'type');
      return Sk.builtin.stringToPy('<' + e + ' \'' + d + b.tp$name + '\'>');
    };
    b.tp$str = void 0;
    b.tp$getattr = Sk.builtin.type.prototype.tp$getattr;
    b.tp$setattr = Sk.builtin.object.prototype.GenericSetAttr;
    b.tp$richcompare = Sk.builtin.type.prototype.tp$richcompare;
    b.sk$type = !0;
    return b;
  };
  Sk.builtin.type.ob$type = Sk.builtin.type;
  Sk.builtin.type.tp$name = 'type';
  Sk.builtin.type.tp$repr = function () {
    return Sk.builtin.stringToPy('<type \'type\'>');
  };
  Sk.builtin.type.prototype.tp$getattr = function (a) {
    var b = Sk.builtin.type.typeLookup(this, a), c;
    void 0 !== b && (null !== b && void 0 !== b.ob$type) && (c = b.ob$type.tp$descr_get);
    if (this.$d && (a = this.$d.mp$lookup(Sk.builtin.stringToPy(a)), void 0 !== a))
      return a;
    if (c)
      return c.call(b, null, this);
    if (void 0 !== b)
      return b;
  };
  Sk.builtin.type.prototype.tp$setattr = function (a, b) {
    this[a] = b;
  };
  Sk.builtin.type.typeLookup = function (a, b) {
    var c = a.tp$mro, d = Sk.builtin.stringToPy(b), e, f;
    if (!c)
      return a.prototype[b];
    for (f = 0; f < c.v.length; ++f) {
      e = c.v[f];
      if (e.hasOwnProperty(b))
        return e[b];
      e = e.$d.mp$lookup(d);
      if (void 0 !== e)
        return e;
    }
  };
  Sk.builtin.type.mroMerge_ = function (a) {
    for (var b = [];;) {
      for (var c = 0; c < a.length; ++c) {
        var d = a[c];
        if (0 !== d.length)
          break;
      }
      if (c === a.length)
        return b;
      for (var e = [], c = 0; c < a.length; ++c)
        if (d = a[c], 0 !== d.length) {
          var d = d[0], f = 0;
          a:
            for (; f < a.length; ++f)
              for (var g = a[f], h = 1; h < g.length; ++h)
                if (g[h] === d)
                  break a;
          f === a.length && e.push(d);
        }
      if (0 === e.length)
        throw new Sk.builtin.TypeError('Inconsistent precedences in type hierarchy');
      e = e[0];
      b.push(e);
      for (c = 0; c < a.length; ++c)
        d = a[c], 0 < d.length && d[0] === e && d.splice(0, 1);
    }
  };
  Sk.builtin.type.buildMRO_ = function (a) {
    var b = [[a]];
    a = a.$d.mp$subscript(Sk.builtin.type.basesStr_);
    for (var c = 0; c < a.v.length; ++c)
      b.push(Sk.builtin.type.buildMRO_(a.v[c]));
    for (var d = [], c = 0; c < a.v.length; ++c)
      d.push(a.v[c]);
    b.push(d);
    return Sk.builtin.type.mroMerge_(b);
  };
  Sk.builtin.type.buildMRO = function (a) {
    return new Sk.builtin.tuple(Sk.builtin.type.buildMRO_(a));
  };
  Sk.builtin.type.prototype.tp$richcompare = function (a, b) {
    if (a.ob$type == Sk.builtin.type && this.tp$repr && a.tp$repr) {
      var c = this.tp$repr(), d = a.tp$repr();
      return c.tp$richcompare(d, b);
    }
  };
  Sk.builtin.object = function () {
    if (!(this instanceof Sk.builtin.object))
      return new Sk.builtin.object();
    this.$d = new Sk.builtin.dict([]);
    return this;
  };
  Sk.builtin.object.prototype.GenericGetAttr = function (a) {
    goog.asserts.assert('string' === typeof a);
    var b = this.ob$type;
    goog.asserts.assert(void 0 !== b, 'object has no ob$type!');
    var b = Sk.builtin.type.typeLookup(b, a), c;
    void 0 !== b && (null !== b && void 0 !== b.ob$type) && (c = b.ob$type.tp$descr_get);
    if (this.$d) {
      var d;
      if (this.$d.mp$lookup)
        d = this.$d.mp$lookup(Sk.builtin.stringToPy(a));
      else if (this.$d.mp$subscript)
        try {
          d = this.$d.mp$subscript(Sk.builtin.stringToPy(a));
        } catch (e) {
          d = void 0;
        }
      else
        'object' === typeof this.$d && (d = this.$d[a]);
      if (void 0 !== d)
        return d;
    }
    if (c)
      return c.call(b, this, this.ob$type);
    if (void 0 !== b)
      return b;
  };
  goog.exportSymbol('Sk.builtin.object.prototype.GenericGetAttr', Sk.builtin.object.prototype.GenericGetAttr);
  Sk.builtin.object.prototype.GenericSetAttr = function (a, b) {
    goog.asserts.assert('string' === typeof a);
    this.$d.mp$ass_subscript ? this.$d.mp$ass_subscript(Sk.builtin.stringToPy(a), b) : 'object' === typeof this.$d && (this.$d[a] = b);
  };
  goog.exportSymbol('Sk.builtin.object.prototype.GenericSetAttr', Sk.builtin.object.prototype.GenericSetAttr);
  Sk.builtin.object.prototype.HashNotImplemented = function () {
    throw new Sk.builtin.TypeError('unhashable type: \'' + Sk.ffi.typeName(this) + '\'');
  };
  Sk.builtin.object.prototype.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;
  Sk.builtin.object.prototype.tp$setattr = Sk.builtin.object.prototype.GenericSetAttr;
  Sk.builtin.object.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj('object', Sk.builtin.object);
  Sk.builtin.none = {
    none$: function () {
      var a = function () {
      };
      a.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj('NoneType', a);
      a.prototype.tp$name = 'NoneType';
      a.prototype.tp$repr = function () {
        return Sk.builtin.stringToPy('None');
      };
      a.prototype.tp$str = function () {
        return Sk.builtin.stringToPy('None');
      };
      a.prototype.u$acos = function () {
        return this;
      };
      a.prototype.u$asin = function () {
        return this;
      };
      a.prototype.u$atan = function () {
        return this;
      };
      return Object.create(a.prototype, {
        v: {
          value: null,
          enumerable: !0
        }
      });
    }()
  };
  goog.exportSymbol('Sk.builtin.none', Sk.builtin.none);
  Sk.builtin.bool = function (a) {
    Sk.ffi.checkFunctionArgs('bool', arguments, 1);
    return Sk.misceval.isTrue(a) ? Sk.builtin.bool.true$ : Sk.builtin.bool.false$;
  };
  Sk.builtin.bool.prototype.tp$name = 'bool';
  Sk.builtin.bool.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj('bool', Sk.builtin.bool);
  Sk.builtin.bool.true$ = Object.create(Sk.builtin.bool.prototype, {
    v: {
      value: !0,
      enumerable: !0
    }
  });
  Sk.builtin.bool.false$ = Object.create(Sk.builtin.bool.prototype, {
    v: {
      value: !1,
      enumerable: !0
    }
  });
  Sk.builtin.bool.prototype.tp$str = function () {
    return Sk.ffi.remapToJs(this) ? Sk.builtin.stringToPy('True') : Sk.builtin.stringToPy('False');
  };
  Sk.builtin.bool.prototype.tp$repr = function () {
    return Sk.ffi.remapToJs(this) ? Sk.builtin.stringToPy('True') : Sk.builtin.stringToPy('False');
  };
  goog.exportSymbol('Sk.builtin.bool', Sk.builtin.bool);
  Sk.builtin.pyCheckArgs = function (a, b, c, d, e, f) {
    b = b.length;
    var g = '';
    void 0 === d && (d = Infinity);
    e && (b -= 1);
    f && (b -= 1);
    if (b < c || b > d)
      throw g = (c === d ? a + '() takes exactly ' + c + ' arguments' : b < c ? a + '() takes at least ' + c + ' arguments' : a + '() takes at most ' + d + ' arguments') + (' (' + b + ' given)'), new Sk.builtin.TypeError(g);
  };
  goog.exportSymbol('Sk.builtin.pyCheckArgs', Sk.builtin.pyCheckArgs);
  Sk.builtin.pyCheckType = function (a, b, c) {
    if (!c)
      throw new Sk.builtin.TypeError(a + ' must be a ' + b);
  };
  goog.exportSymbol('Sk.builtin.pyCheckType', Sk.builtin.pyCheckType);
  Sk.builtin.checkSequence = function (a) {
    return null !== a && void 0 !== a.mp$subscript;
  };
  goog.exportSymbol('Sk.builtin.checkSequence', Sk.builtin.checkSequence);
  Sk.builtin.checkIterable = function (a) {
    return null !== a && void 0 !== a.tp$iter;
  };
  goog.exportSymbol('Sk.builtin.checkIterable', Sk.builtin.checkIterable);
  Sk.builtin.checkNumber = function (a) {
    return null !== a && ('number' === typeof a || a instanceof Sk.builtin.NumberPy || a instanceof Sk.builtin.lng);
  };
  goog.exportSymbol('Sk.builtin.checkNumber', Sk.builtin.checkNumber);
  Sk.builtin.checkInt = function (a) {
    return a instanceof Sk.builtin.NumberPy ? a.skType === Sk.builtin.NumberPy.int$ : a instanceof Sk.builtin.lng ? !0 : 'number' === typeof a ? !0 : !1;
  };
  goog.exportSymbol('Sk.builtin.checkInt', Sk.builtin.checkInt);
  Sk.builtin.checkClass = function (a) {
    return null !== a && a.sk$type;
  };
  goog.exportSymbol('Sk.builtin.checkClass', Sk.builtin.checkClass);
  Sk.builtin.checkBool = function (a) {
    return a instanceof Sk.builtin.bool;
  };
  goog.exportSymbol('Sk.builtin.checkBool', Sk.builtin.checkBool);
  Sk.builtin.checkFunction = function (a) {
    return null !== a && void 0 !== a.tp$call;
  };
  goog.exportSymbol('Sk.builtin.checkFunction', Sk.builtin.checkFunction);
  Sk.builtin.func = function (a, b, c, d) {
    this.func_code = a;
    this.func_globals = b || null;
    if (void 0 !== d)
      for (var e in d)
        c[e] = d[e];
    this.func_closure = c;
    return this;
  };
  goog.exportSymbol('Sk.builtin.func', Sk.builtin.func);
  Sk.builtin.func.prototype.tp$name = 'function';
  Sk.builtin.func.prototype.tp$descr_get = function (a, b) {
    goog.asserts.assert(void 0 !== a && void 0 !== b);
    return null == a ? this : new Sk.builtin.method(this, a);
  };
  Sk.builtin.func.prototype.tp$call = function (a, b) {
    var c;
    this.func_closure && a.push(this.func_closure);
    c = this.func_code.co_kwargs;
    var d = [];
    if (this.func_code.no_kw && b)
      throw c = this.func_code && this.func_code.co_name && this.func_code.co_name.v || '<native JS>', new Sk.builtin.TypeError(c + '() takes no keyword arguments');
    if (b)
      for (var e = b.length, f = this.func_code.co_varnames, g = f && f.length, h = 0; h < e; h += 2) {
        for (var l = 0; l < g && b[h] !== f[l]; ++l);
        if (f && l !== g)
          a[l] = b[h + 1];
        else if (c)
          d.push(Sk.builtin.stringToPy(b[h])), d.push(b[h + 1]);
        else
          throw c = this.func_code && this.func_code.co_name && Sk.ffi.remapToJs(this.func_code.co_name) || '<native JS>', new Sk.builtin.TypeError(c + '() got an unexpected keyword argument \'' + b[h] + '\'');
      }
    c && a.unshift(d);
    return this.func_code.apply(this.func_globals, a);
  };
  Sk.builtin.func.prototype.tp$getattr = function (a) {
    return this[a];
  };
  Sk.builtin.func.prototype.tp$setattr = function (a, b) {
    this[a] = b;
  };
  Sk.builtin.func.prototype.ob$type = Sk.builtin.type.makeTypeObj('function', new Sk.builtin.func(null, null));
  Sk.builtin.func.prototype.tp$repr = function () {
    var a = this.func_code && this.func_code.co_name && Sk.ffi.remapToJs(this.func_code.co_name) || '<native JS>';
    return Sk.builtin.stringToPy('<function ' + a + '>');
  };
  Sk.nativejs = {
    FN_ARGS: /^function\s*[^\(]*\(\s*([^\)]*)\)/m,
    FN_ARG_SPLIT: /,/,
    FN_ARG: /^\s*(_?)(\S+?)\1\s*$/,
    STRIP_COMMENTS: /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm,
    formalParameterList: function (a) {
      var b = [];
      a = a.toString().replace(this.STRIP_COMMENTS, '').match(this.FN_ARGS)[1].split(this.FN_ARG_SPLIT);
      for (var c in a)
        a[c].replace(this.FN_ARG, function (a, c, f) {
          b.push(f);
        });
      return b;
    },
    func: function (a) {
      a.co_name = Sk.builtin.stringToPy(a.name);
      a.co_varnames = Sk.nativejs.formalParameterList(a);
      return new Sk.builtin.func(a);
    },
    func_nokw: function (a) {
      a.co_name = Sk.builtin.stringToPy(a.name);
      a.co_varnames = Sk.nativejs.formalParameterList(a);
      a.no_kw = !0;
      return new Sk.builtin.func(a);
    }
  };
  goog.exportSymbol('Sk.nativejs.func', Sk.nativejs.func);
  goog.exportSymbol('Sk.nativejs.func_nokw', Sk.nativejs.func_nokw);
  Sk.builtin.method = function (a, b) {
    this.im_func = a;
    this.im_self = b;
  };
  goog.exportSymbol('Sk.builtin.method', Sk.builtin.method);
  Sk.builtin.method.prototype.tp$call = function (a, b) {
    goog.asserts.assert(this.im_self, 'should just be a function, not a method since there\'s no self?');
    goog.asserts.assert(this.im_func instanceof Sk.builtin.func);
    a.unshift(this.im_self);
    if (b)
      for (var c = b.length, d = 0; d < c; d += 2) {
        for (var e = this.im_func.func_code.co_varnames, f = e && e.length, g = 0; g < f && b[d] !== e[g]; ++g);
        a[g] = b[d + 1];
      }
    return this.im_func.func_code.apply(this.im_func.func_globals, a);
  };
  Sk.builtin.method.prototype.tp$repr = function () {
    var a = this.im_func.func_code && this.im_func.func_code.co_name && Sk.ffi.remapToJs(this.im_func.func_code.co_name) || '<native JS>';
    return Sk.builtin.stringToPy('<bound method ' + this.im_self.ob$type.tp$name + '.' + a + ' of ' + Sk.ffi.remapToJs(this.im_self.tp$repr()) + '>');
  };
  Sk.misceval = {};
  Sk.misceval.isIndex = function (a) {
    return null === a || a.constructor === Sk.builtin.lng || a.tp$index || !0 === a || !1 === a ? !0 : Sk.builtin.checkInt(a);
  };
  goog.exportSymbol('Sk.misceval.isIndex', Sk.misceval.isIndex);
  Sk.misceval.asIndex = function (a) {
    if (Sk.misceval.isIndex(a) && null !== a) {
      if (!0 === a)
        return 1;
      if (!1 === a)
        return 0;
      if ('number' === typeof a)
        return a;
      if (a.constructor === Sk.builtin.NumberPy)
        return a.v;
      if (a.constructor === Sk.builtin.lng)
        return a.tp$index();
      goog.asserts.fail('todo;');
    }
  };
  Sk.misceval.applySlice = function (a, b, c) {
    return a.sq$slice && Sk.misceval.isIndex(b) && Sk.misceval.isIndex(c) ? (b = Sk.misceval.asIndex(b), void 0 === b && (b = 0), c = Sk.misceval.asIndex(c), void 0 === c && (c = 1e+100), Sk.abstr.sequenceGetSlice(a, b, c)) : Sk.abstr.objectGetItem(a, new Sk.builtin.slice(b, c, null));
  };
  goog.exportSymbol('Sk.misceval.applySlice', Sk.misceval.applySlice);
  Sk.misceval.assignSlice = function (a, b, c, d) {
    if (a.sq$ass_slice && Sk.misceval.isIndex(b) && Sk.misceval.isIndex(c))
      b = Sk.misceval.asIndex(b) || 0, c = Sk.misceval.asIndex(c) || 1e+100, null === d ? Sk.abstr.sequenceDelSlice(a, b, c) : Sk.abstr.sequenceSetSlice(a, b, c, d);
    else
      return c = new Sk.builtin.slice(b, c), null === d ? Sk.abstr.objectDelItem(a, c) : Sk.abstr.objectSetItem(a, c, d);
  };
  goog.exportSymbol('Sk.misceval.assignSlice', Sk.misceval.assignSlice);
  Sk.misceval.arrayFromArguments = function (a) {
    if (1 != a.length)
      return a;
    var b = a[0];
    if (b instanceof Sk.builtin.set)
      b = b.tp$iter().$obj;
    else if (b instanceof Sk.builtin.dict)
      b = Sk.builtin.dict.prototype.keys.func_code(b);
    else if (Sk.builtin.isStringPy(b)) {
      a = [];
      for (var b = b.tp$iter(), c = b.tp$iternext(); void 0 !== c; c = b.tp$iternext())
        a.push(c);
      return a;
    }
    return b instanceof Sk.builtin.list || b instanceof Sk.builtin.tuple ? b.v : a;
  };
  goog.exportSymbol('Sk.misceval.arrayFromArguments', Sk.misceval.arrayFromArguments);
  Sk.misceval.compareOp = {
    Eq: 'Eq',
    NotEq: 'NotEq',
    Lt: 'Lt',
    LtE: 'LtE',
    Gt: 'Gt',
    GtE: 'GtE',
    Is: 'Is',
    IsNot: 'IsNot',
    In_: 'In_',
    NotIn: 'NotIn'
  };
  goog.exportSymbol('Sk.misceval.compareOp', Sk.misceval.compareOp);
  Sk.misceval.swappedOp_ = {};
  Sk.misceval.swappedOp_[Sk.misceval.compareOp.Eq] = Sk.misceval.compareOp.Eq;
  Sk.misceval.swappedOp_[Sk.misceval.compareOp.NotEq] = Sk.misceval.compareOp.NotEq;
  Sk.misceval.swappedOp_[Sk.misceval.compareOp.Lt] = Sk.misceval.compareOp.GtE;
  Sk.misceval.swappedOp_[Sk.misceval.compareOp.LtE] = Sk.misceval.compareOp.Gt;
  Sk.misceval.swappedOp_[Sk.misceval.compareOp.Gt] = Sk.misceval.compareOp.LtE;
  Sk.misceval.swappedOp_[Sk.misceval.compareOp.GtE] = Sk.misceval.compareOp.Lt;
  Sk.misceval.swappedOp_[Sk.misceval.compareOp.Is] = Sk.misceval.compareOp.IsNot;
  Sk.misceval.swappedOp_[Sk.misceval.compareOp.IsNot] = Sk.misceval.compareOp.Is;
  Sk.misceval.swappedOp_[Sk.misceval.compareOp.In_] = Sk.misceval.compareOp.NotIn;
  Sk.misceval.swappedOp_[Sk.misceval.compareOp.NotIn] = Sk.misceval.compareOp.In_;
  Sk.misceval.richCompareBool = function (a, b, c) {
    goog.asserts.assert(null !== a && void 0 !== a, 'passed undefined or null parameter to Sk.misceval.richCompareBool');
    goog.asserts.assert(null !== b && void 0 !== b, 'passed undefined or null parameter to Sk.misceval.richCompareBool');
    var d = new Sk.builtin.type(a), e = new Sk.builtin.type(b);
    if (d !== e && (c === Sk.misceval.compareOp.GtE || c === Sk.misceval.compareOp.Gt || 'LtE' === c || c === Sk.misceval.compareOp.Lt)) {
      var f = [
          Sk.builtin.float_.prototype.ob$type,
          Sk.builtin.int_.prototype.ob$type,
          Sk.builtin.lng.prototype.ob$type,
          Sk.builtin.bool.prototype.ob$type
        ], g = [
          Sk.builtin.dict.prototype.ob$type,
          Sk.builtin.enumerate.prototype.ob$type,
          Sk.builtin.list.prototype.ob$type,
          Sk.builtin.StringPy.prototype.ob$type,
          Sk.builtin.tuple.prototype.ob$type
        ], h = f.indexOf(d), l = g.indexOf(d), f = f.indexOf(e), g = g.indexOf(e);
      if (d === Sk.builtin.none.none$.ob$type)
        switch (c) {
        case Sk.misceval.compareOp.Lt:
          return !0;
        case 'LtE':
          return !0;
        case Sk.misceval.compareOp.Gt:
          return !1;
        case Sk.misceval.compareOp.GtE:
          return !1;
        }
      if (e === Sk.builtin.none.none$.ob$type)
        switch (c) {
        case Sk.misceval.compareOp.Lt:
          return !1;
        case 'LtE':
          return !1;
        case Sk.misceval.compareOp.Gt:
          return !0;
        case Sk.misceval.compareOp.GtE:
          return !0;
        }
      if (-1 !== h && -1 !== g)
        switch (c) {
        case Sk.misceval.compareOp.Lt:
          return !0;
        case 'LtE':
          return !0;
        case Sk.misceval.compareOp.Gt:
          return !1;
        case Sk.misceval.compareOp.GtE:
          return !1;
        }
      if (-1 !== l && -1 !== f)
        switch (c) {
        case Sk.misceval.compareOp.Lt:
          return !1;
        case 'LtE':
          return !1;
        case Sk.misceval.compareOp.Gt:
          return !0;
        case Sk.misceval.compareOp.GtE:
          return !0;
        }
      if (-1 !== l && -1 !== g)
        switch (c) {
        case Sk.misceval.compareOp.Lt:
          return l < g;
        case 'LtE':
          return l <= g;
        case Sk.misceval.compareOp.Gt:
          return l > g;
        case Sk.misceval.compareOp.GtE:
          return l >= g;
        }
    }
    if (c === Sk.misceval.compareOp.Is)
      return a instanceof Sk.builtin.NumberPy && b instanceof Sk.builtin.NumberPy ? 0 === a.numberCompare(b) && a.skType === b.skType : a instanceof Sk.builtin.lng && b instanceof Sk.builtin.lng ? 0 === a.longCompare(b) : a === b;
    if (c === Sk.misceval.compareOp.IsNot)
      return a instanceof Sk.builtin.NumberPy && b instanceof Sk.builtin.NumberPy ? 0 !== a.numberCompare(b) || a.skType !== b.skType : a instanceof Sk.builtin.lng && b instanceof Sk.builtin.lng ? 0 !== a.longCompare(b) : a !== b;
    if ('In' === c)
      return Sk.abstr.sequenceContains(b, a);
    if ('NotIn' === c)
      return !Sk.abstr.sequenceContains(b, a);
    var k;
    if (a.tp$richcompare && void 0 !== (k = a.tp$richcompare(b, c)) || b.tp$richcompare && void 0 !== (k = b.tp$richcompare(a, Sk.misceval.swappedOp_[c])))
      return k;
    e = {};
    e[Sk.misceval.compareOp.Eq] = '__eq__';
    e[Sk.misceval.compareOp.NotEq] = '__ne__';
    e[Sk.misceval.compareOp.Gt] = '__gt__';
    e[Sk.misceval.compareOp.GtE] = '__ge__';
    e[Sk.misceval.compareOp.Lt] = '__lt__';
    e[Sk.misceval.compareOp.LtE] = '__le__';
    d = e[c];
    e = e[Sk.misceval.swappedOp_[c]];
    if (a[d])
      return Sk.misceval.callsim(a[d], a, b);
    if (b[e])
      return Sk.misceval.callsim(b[e], b, a);
    if (a.__cmp__) {
      d = Sk.misceval.callsim(a.__cmp__, a, b);
      d = Sk.builtin.asnum$(d);
      if (c === Sk.misceval.compareOp.Eq)
        return 0 === d;
      if (c === Sk.misceval.compareOp.NotEq)
        return 0 !== d;
      if (c === Sk.misceval.compareOp.Lt)
        return 0 > d;
      if (c === Sk.misceval.compareOp.Gt)
        return 0 < d;
      if ('LtE' === c)
        return 0 >= d;
      if (c === Sk.misceval.compareOp.GtE)
        return 0 <= d;
    }
    if (b.__cmp__) {
      d = Sk.misceval.callsim(b.__cmp__, b, a);
      d = Sk.builtin.asnum$(d);
      if (c === Sk.misceval.compareOp.Eq)
        return 0 === d;
      if (c === Sk.misceval.compareOp.NotEq)
        return 0 !== d;
      if (c === Sk.misceval.compareOp.Lt)
        return 0 < d;
      if (c === Sk.misceval.compareOp.Gt)
        return 0 > d;
      if ('LtE' === c)
        return 0 <= d;
      if (c === Sk.misceval.compareOp.GtE)
        return 0 >= d;
    }
    if (a === Sk.builtin.none.none$ && b === Sk.builtin.none.none$ || a instanceof Sk.builtin.bool && b instanceof Sk.builtin.bool) {
      if (c === Sk.misceval.compareOp.Eq)
        return a.v === b.v;
      if (c === Sk.misceval.compareOp.NotEq)
        return a.v !== b.v;
      if (c === Sk.misceval.compareOp.Gt)
        return a.v > b.v;
      if (c === Sk.misceval.compareOp.GtE)
        return a.v >= b.v;
      if (c === Sk.misceval.compareOp.Lt)
        return a.v < b.v;
      if ('LtE' === c)
        return a.v <= b.v;
    }
    if (c === Sk.misceval.compareOp.Eq)
      return Sk.builtin.isStringPy(a) && Sk.builtin.isStringPy(b) ? Sk.builtin.stringToJs(a) === Sk.builtin.stringToJs(b) : a === b;
    if (c === Sk.misceval.compareOp.Lt)
      return a < b;
    if ('LtE' === c)
      return a <= b;
    if (c === Sk.misceval.compareOp.Gt)
      return a > b;
    if (c === Sk.misceval.compareOp.GtE)
      return a >= b;
    if (c === Sk.misceval.compareOp.NotEq)
      return Sk.builtin.isStringPy(a) && Sk.builtin.isStringPy(b) ? Sk.builtin.stringToJs(a) !== Sk.builtin.stringToJs(b) : a !== b;
    a = Sk.ffi.typeName(a);
    b = Sk.ffi.typeName(b);
    throw new Sk.builtin.ValueError('don\'t know how to compare \'' + a + '\' and \'' + b + '\'');
  };
  goog.exportSymbol('Sk.misceval.richCompareBool', Sk.misceval.richCompareBool);
  Sk.misceval.objectRepr = function (a) {
    goog.asserts.assert(void 0 !== a, 'trying to repr undefined');
    return null === a || a === Sk.builtin.none.none$ ? Sk.builtin.stringToPy('None') : !0 === a ? Sk.builtin.stringToPy('True') : !1 === a ? Sk.builtin.stringToPy('False') : 'number' === typeof a ? Sk.builtin.stringToPy('' + a) : a.tp$repr ? a.constructor === Sk.builtin.NumberPy ? Infinity === a.v ? Sk.builtin.stringToPy('inf') : -Infinity === a.v ? Sk.builtin.stringToPy('-inf') : Sk.builtin.stringToPy('' + a.v) : a.tp$repr() : a.tp$name ? Sk.builtin.stringToPy('<' + a.tp$name + ' object>') : Sk.builtin.stringToPy('<unknown>');
  };
  goog.exportSymbol('Sk.misceval.objectRepr', Sk.misceval.objectRepr);
  Sk.misceval.opAllowsEquality = function (a) {
    switch (a) {
    case 'LtE':
    case Sk.misceval.compareOp.Eq:
    case Sk.misceval.compareOp.GtE:
      return !0;
    }
    return !1;
  };
  goog.exportSymbol('Sk.misceval.opAllowsEquality', Sk.misceval.opAllowsEquality);
  Sk.misceval.isTrue = function (a) {
    return !0 === a ? !0 : !1 === a || null === a || a === Sk.builtin.none.none$ ? !1 : a.constructor === Sk.builtin.bool ? a.v : 'number' === typeof a ? 0 !== a : a instanceof Sk.builtin.lng ? a.nb$nonzero() : a.constructor === Sk.builtin.NumberPy ? 0 !== a.v : a.mp$length ? 0 !== a.mp$length() : a.sq$length ? 0 !== a.sq$length() : !0;
  };
  goog.exportSymbol('Sk.misceval.isTrue', Sk.misceval.isTrue);
  Sk.misceval.print_ = function (a) {
    goog.asserts.assertString(a);
    Sk.softSpace && ('\n' !== a && Sk.output(' '), Sk.softSpace = !1);
    Sk.output(a);
    if (0 === a.length || '\n' !== a[a.length - 1] && '\t' !== a[a.length - 1] && '\r' !== a[a.length - 1] || ' ' === a[a.length - 1])
      Sk.softSpace = !0;
  };
  goog.exportSymbol('Sk.misceval.print_', Sk.misceval.print_);
  Sk.misceval.loadname = function (a, b) {
    var c = b[a];
    if (void 0 !== c)
      return c;
    c = Sk.builtins[a];
    if (void 0 !== c)
      return c;
    a = a.replace('_$rw$', '');
    a = a.replace('_$rn$', '');
    throw new Sk.builtin.NameError('name \'' + a + '\' is not defined');
  };
  goog.exportSymbol('Sk.misceval.loadname', Sk.misceval.loadname);
  Sk.misceval.call = function (a, b, c, d, e) {
    e = Array.prototype.slice.call(arguments, 4);
    return Sk.misceval.apply(a, b, c, d, e);
  };
  goog.exportSymbol('Sk.misceval.call', Sk.misceval.call);
  Sk.misceval.callsim = function (a, b) {
    b = Array.prototype.slice.call(arguments, 1);
    return Sk.misceval.apply(a, void 0, void 0, void 0, b);
  };
  goog.exportSymbol('Sk.misceval.callsim', Sk.misceval.callsim);
  Sk.misceval.apply = function (a, b, c, d, e) {
    if (null === a || a === Sk.builtin.none.none$)
      throw new Sk.builtin.TypeError('\'' + Sk.ffi.typeName(a) + '\' object is not callable');
    if ('function' === typeof a) {
      if (a.sk$klass)
        return a.apply(null, [
          b,
          c,
          d,
          e
        ]);
      if (c) {
        c = c.tp$iter();
        for (var f = c.tp$iternext(); void 0 !== f; f = c.tp$iternext())
          e.push(f);
      }
      b && goog.asserts.fail('kwdict not implemented;');
      goog.asserts.assert(void 0 === d || 0 === d.length);
      return a.apply(null, e);
    }
    var g = a.tp$call;
    if (void 0 !== g) {
      if (c)
        for (c = c.tp$iter(), f = c.tp$iternext(); void 0 !== f; f = c.tp$iternext())
          e.push(f);
      b && goog.asserts.fail('kwdict not implemented;');
      return g.call(a, e, d, b);
    }
    g = a.__call__;
    if (void 0 !== g)
      return e.unshift(a), Sk.misceval.apply(g, d, e, b, c);
    throw new Sk.builtin.TypeError('\'' + Sk.ffi.typeName(a) + '\' object is not callable');
  };
  goog.exportSymbol('Sk.misceval.apply', Sk.misceval.apply);
  Sk.misceval.buildClass = function (a, b, c, d) {
    var e = Sk.builtin.type, f = {};
    b(a, f, []);
    f.__module__ = a.__name__;
    return Sk.misceval.callsim(e, c, d, f);
  };
  goog.exportSymbol('Sk.misceval.buildClass', Sk.misceval.buildClass);
  Sk.abstr = {};
  Sk.abstr.binop_type_error = function (a, b, c) {
    a = Sk.ffi.typeName(a);
    b = Sk.ffi.typeName(b);
    throw new Sk.builtin.TypeError('unsupported operand type(s) for ' + c + ': \'' + a + '\' and \'' + b + '\'');
  };
  Sk.abstr.boNameToSlotFuncLhs_ = function (a, b) {
    if (null !== a)
      switch (b) {
      case 'Add':
        return a.nb$add ? a.nb$add : a.__add__;
      case 'Sub':
        return a.nb$sub ? a.nb$sub : a.__sub__;
      case 'Mult':
        return a.nb$mul ? a.nb$mul : a.__mul__;
      case 'Div':
        return a.nb$div ? a.nb$div : a.__div__;
      case 'FloorDiv':
        return a.nb$floor_divide ? a.nb$floor_divide : a.__floordiv__;
      case 'Mod':
        return a.nb$remainder ? a.nb$remainder : a.__mod__;
      case 'Pow':
        return a.nb$power ? a.nb$power : a.__pow__;
      case 'LShift':
        return a.nb$lshift ? a.nb$lshift : a.__lshift__;
      case 'RShift':
        return a.nb$rshift ? a.nb$rshift : a.__rshift__;
      case 'BitAnd':
        return a.nb$and ? a.nb$and : a.__and__;
      case 'BitXor':
        return a.nb$xor ? a.nb$xor : a.__xor__;
      case 'BitOr':
        return a.nb$or ? a.nb$or : a.__or__;
      }
  };
  Sk.abstr.boNameToSlotFuncRhs_ = function (a, b) {
    if (null !== a)
      switch (b) {
      case 'Add':
        return a.nb$add ? a.nb$add : a.__radd__;
      case 'Sub':
        return a.nb$sub ? a.nb$sub : a.__rsub__;
      case 'Mult':
        return a.nb$mul ? a.nb$mul : a.__rmul__;
      case 'Div':
        return a.nb$div ? a.nb$div : a.__rdiv__;
      case 'FloorDiv':
        return a.nb$floor_divide ? a.nb$floor_divide : a.__rfloordiv__;
      case 'Mod':
        return a.nb$remainder ? a.nb$remainder : a.__rmod__;
      case 'Pow':
        return a.nb$power ? a.nb$power : a.__rpow__;
      case 'LShift':
        return a.nb$lshift ? a.nb$lshift : a.__rlshift__;
      case 'RShift':
        return a.nb$rshift ? a.nb$rshift : a.__rrshift__;
      case 'BitAnd':
        return a.nb$and ? a.nb$and : a.__rand__;
      case 'BitXor':
        return a.nb$xor ? a.nb$xor : a.__rxor__;
      case 'BitOr':
        return a.nb$or ? a.nb$or : a.__ror__;
      }
  };
  Sk.abstr.iboNameToSlotFunc_ = function (a, b) {
    if (null !== a)
      switch (b) {
      case 'Add':
        return a.nb$inplace_add ? a.nb$inplace_add : a.__iadd__;
      case 'Sub':
        return a.nb$inplace_subtract ? a.nb$inplace_subtract : a.__isub__;
      case 'Mult':
        return a.nb$inplace_multiply ? a.nb$inplace_multiply : a.__imul__;
      case 'Div':
        return a.nb$inplace_divide ? a.nb$inplace_divide : a.__idiv__;
      case 'FloorDiv':
        return a.nb$inplace_floor_divide ? a.nb$inplace_floor_divide : a.__ifloordiv__;
      case 'Mod':
        return a.nb$inplace_remainder;
      case 'Pow':
        return a.nb$inplace_power;
      case 'LShift':
        return a.nb$inplace_lshift ? a.nb$inplace_lshift : a.__ilshift__;
      case 'RShift':
        return a.nb$inplace_rshift ? a.nb$inplace_rshift : a.__irshift__;
      case 'BitAnd':
        return a.nb$inplace_and;
      case 'BitOr':
        return a.nb$inplace_or;
      case 'BitXor':
        return a.nb$inplace_xor ? a.nb$inplace_xor : a.__ixor__;
      }
  };
  Sk.abstr.binary_op_ = function (a, b, c) {
    var d;
    d = Sk.abstr.boNameToSlotFuncLhs_(a, c);
    if (void 0 !== d && (d = d.call ? d.call(a, b) : Sk.misceval.callsim(d, a, b), void 0 !== d))
      return d;
    d = Sk.abstr.boNameToSlotFuncRhs_(b, c);
    if (void 0 !== d && (d = d.call ? d.call(b, a) : Sk.misceval.callsim(d, b, a), void 0 !== d))
      return d;
    Sk.abstr.binop_type_error(a, b, c);
  };
  Sk.abstr.binary_iop_ = function (a, b, c) {
    var d;
    d = Sk.abstr.iboNameToSlotFunc_(a, c);
    if (void 0 !== d && (d = d.call ? d.call(a, b) : Sk.misceval.callsim(d, a, b), void 0 !== d))
      return d;
    d = Sk.abstr.iboNameToSlotFunc_(b, c);
    if (void 0 !== d && (d = d.call ? d.call(b, a) : Sk.misceval.callsim(d, b, a), void 0 !== d))
      return d;
    Sk.abstr.binop_type_error(a, b, c);
  };
  Sk.abstr.numOpAndPromote = function (a, b, c) {
    if (null !== a && null !== b) {
      if ('number' === typeof a && 'number' === typeof b)
        return c = c(a, b), (c > Sk.builtin.lng.threshold$ || c < -Sk.builtin.lng.threshold$) && Math.floor(c) === c ? [
          Sk.builtin.lng.fromInt$(a),
          Sk.builtin.lng.fromInt$(b)
        ] : c;
      if (void 0 === a || void 0 === b)
        throw new Sk.builtin.NameError('Undefined variable in expression');
      if (a.constructor === Sk.builtin.lng || a.constructor === Sk.builtin.NumberPy)
        return [
          a,
          b
        ];
      if ('number' === typeof a)
        return [
          Sk.builtin.numberPy(a, void 0),
          b
        ];
    }
  };
  Sk.abstr.boNumPromote_ = {
    Add: function (a, b) {
      return a + b;
    },
    Sub: function (a, b) {
      return a - b;
    },
    Mult: function (a, b) {
      return a * b;
    },
    Mod: function (a, b) {
      if (0 === b)
        throw new Sk.builtin.ZeroDivisionError('division or modulo by zero');
      var c = a % b;
      return 0 > c * b ? c + b : c;
    },
    Div: function (a, b) {
      if (0 === b)
        throw new Sk.builtin.ZeroDivisionError('division or modulo by zero');
      return a / b;
    },
    FloorDiv: function (a, b) {
      if (0 === b)
        throw new Sk.builtin.ZeroDivisionError('division or modulo by zero');
      return Math.floor(a / b);
    },
    Pow: Math.pow,
    BitAnd: function (a, b) {
      var c = a & b;
      0 > c && (c += 4294967296);
      return c;
    },
    BitOr: function (a, b) {
      var c = a | b;
      0 > c && (c += 4294967296);
      return c;
    },
    BitXor: function (a, b) {
      var c = a ^ b;
      0 > c && (c += 4294967296);
      return c;
    },
    LShift: function (a, b) {
      if (0 > b)
        throw new Sk.builtin.ValueError('negative shift count');
      var c = a << b;
      return c > a ? c : a * Math.pow(2, b);
    },
    RShift: function (a, b) {
      if (0 > b)
        throw new Sk.builtin.ValueError('negative shift count');
      var c = a >> b;
      0 < a && 0 > c && (c &= Math.pow(2, 32 - b) - 1);
      return c;
    }
  };
  Sk.abstr.numberBinOp = function (a, b, c) {
    var d = Sk.abstr.boNumPromote_[c];
    if (void 0 !== d) {
      d = Sk.abstr.numOpAndPromote(a, b, d);
      if ('number' === typeof d)
        return d;
      if (void 0 !== d && d.constructor === Sk.builtin.NumberPy || void 0 !== d && d.constructor === Sk.builtin.lng)
        return d;
      void 0 !== d && (a = d[0], b = d[1]);
    }
    return Sk.abstr.binary_op_(a, b, c);
  };
  goog.exportSymbol('Sk.abstr.numberBinOp', Sk.abstr.numberBinOp);
  Sk.abstr.numberInplaceBinOp = function (a, b, c) {
    var d = Sk.abstr.boNumPromote_[c];
    if (void 0 !== d) {
      d = Sk.abstr.numOpAndPromote(a, b, d);
      if ('number' === typeof d)
        return d;
      if (void 0 !== d && d.constructor === Sk.builtin.NumberPy || void 0 !== d && d.constructor === Sk.builtin.lng)
        return d;
      void 0 !== d && (a = d[0], b = d[1]);
    }
    return Sk.abstr.binary_iop_(a, b, c);
  };
  goog.exportSymbol('Sk.abstr.numberInplaceBinOp', Sk.abstr.numberInplaceBinOp);
  Sk.abstr.uoNameToSlotFunc_ = function (a, b) {
    if (null !== a)
      switch (b) {
      case Sk.abstr.unaryOp.USub:
        return a.u$negative ? a.u$negative : a.__neg__;
      case Sk.abstr.unaryOp.UAdd:
        return a.u$positive ? a.u$positive : a.__pos__;
      case Sk.abstr.unaryOp.Invert:
        return a.nb$invert ? a.nb$invert : a.__invert__;
      default:
        throw new Sk.builtin.AssertionError('7fb8237f-879b-4192-89ce-13ad6fa3b2d8 ' + b);
      }
  };
  Sk.abstr.unaryOp = {
    Not: 'Not',
    USub: 'USub',
    Invert: 'Invert',
    UAdd: 'UAdd'
  };
  goog.exportSymbol('Sk.abstr.unaryOp', Sk.abstr.unaryOp);
  Sk.abstr.numberUnaryOp = function (a, b) {
    goog.asserts.assertString(b, 'op must be a string');
    if (b === Sk.abstr.unaryOp.Not)
      return Sk.misceval.isTrue(a) ? Sk.builtin.bool.false$ : Sk.builtin.bool.true$;
    if (Sk.ffi.isFloat(a) || Sk.ffi.isInt(a) || Sk.ffi.isBool(a)) {
      var c = Sk.ffi.remapToJs(a);
      if (b === Sk.abstr.unaryOp.USub)
        return Sk.builtin.numberPy(-c, c.skType);
      if (b === Sk.abstr.unaryOp.Invert)
        return Sk.builtin.numberPy(~c, c.skType);
      if (b === Sk.abstr.unaryOp.UAdd)
        return Sk.builtin.numberPy(c, c.skType);
    } else if (c = Sk.abstr.uoNameToSlotFunc_(a, b), void 0 != c)
      return c.call ? c.call(a) : Sk.misceval.callsim(c, a);
    c = Sk.ffi.typeName(a);
    throw new Sk.builtin.TypeError('unsupported operand type for ' + b + ' \'' + c + '\'');
  };
  goog.exportSymbol('Sk.abstr.numberUnaryOp', Sk.abstr.numberUnaryOp);
  Sk.abstr.fixSeqIndex_ = function (a, b) {
    b = Sk.ffi.remapToJs(b);
    0 > b && a.sq$length && (b += a.sq$length());
    return b;
  };
  Sk.abstr.sequenceContains = function (a, b) {
    if (a.sq$contains)
      return a.sq$contains(b);
    var c = Sk.ffi.typeName(a);
    if (!a.tp$iter)
      throw new Sk.builtin.TypeError('argument of type \'' + c + '\' is not iterable');
    for (var c = a.tp$iter(), d = c.tp$iternext(); void 0 !== d; d = c.tp$iternext())
      if (Sk.misceval.richCompareBool(d, b, Sk.misceval.compareOp.Eq))
        return !0;
    return !1;
  };
  Sk.abstr.sequenceGetItem = function (a, b) {
    goog.asserts.fail();
  };
  Sk.abstr.sequenceSetItem = function (a, b, c) {
    goog.asserts.fail();
  };
  Sk.abstr.sequenceDelItem = function (a, b) {
    if (a.sq$del_item)
      b = Sk.abstr.fixSeqIndex_(a, b), a.sq$del_item(b);
    else {
      var c = Sk.ffi.typeName(a);
      throw new Sk.builtin.TypeError('\'' + c + '\' object does not support item deletion');
    }
  };
  Sk.abstr.sequenceRepeat = function (a, b, c) {
    c = Sk.ffi.remapToJs(c);
    if (void 0 === Sk.misceval.asIndex(c))
      throw a = Sk.ffi.typeName(c), new Sk.builtin.TypeError('can\'t multiply sequence by non-int of type \'' + a + '\'');
    return a.call(b, c);
  };
  Sk.abstr.sequenceGetSlice = function (a, b, c) {
    if (a.sq$slice)
      return b = Sk.abstr.fixSeqIndex_(a, b), c = Sk.abstr.fixSeqIndex_(a, c), a.sq$slice(b, c);
    if (a.mp$subscript)
      return a.mp$subscript(new Sk.builtin.slice(b, c));
    a = Sk.ffi.typeName(a);
    throw new Sk.builtin.TypeError('\'' + a + '\' object is unsliceable');
  };
  Sk.abstr.sequenceDelSlice = function (a, b, c) {
    if (a.sq$del_slice)
      b = Sk.abstr.fixSeqIndex_(a, b), c = Sk.abstr.fixSeqIndex_(a, c), a.sq$del_slice(b, c);
    else
      throw a = Sk.ffi.typeName(a), new Sk.builtin.TypeError('\'' + a + '\' doesn\'t support slice deletion');
  };
  Sk.abstr.sequenceSetSlice = function (a, b, c, d) {
    if (a.sq$ass_slice)
      b = Sk.abstr.fixSeqIndex_(a, b), c = Sk.abstr.fixSeqIndex_(a, c), a.sq$ass_slice(b, c, d);
    else if (a.mp$ass_subscript)
      a.mp$ass_subscript(new Sk.builtin.slice(b, c), d);
    else
      throw a = Sk.ffi.typeName(a), new Sk.builtin.TypeError('\'' + a + '\' object doesn\'t support slice assignment');
  };
  Sk.abstr.objectDelItem = function (a, b) {
    if (null !== a) {
      if (a.mp$del_subscript) {
        a.mp$del_subscript(b);
        return;
      }
      if (a.sq$ass_item) {
        var c = Sk.misceval.asIndex(b);
        if (void 0 === c)
          throw c = Sk.ffi.typeName(b), new Sk.builtin.TypeError('sequence index must be integer, not \'' + c + '\'');
        Sk.abstr.sequenceDelItem(a, c);
        return;
      }
    }
    c = Sk.ffi.typeName(a);
    throw new Sk.builtin.TypeError('\'' + c + '\' object does not support item deletion');
  };
  goog.exportSymbol('Sk.abstr.objectDelItem', Sk.abstr.objectDelItem);
  Sk.abstr.objectGetItem = function (a, b) {
    if (null !== a) {
      if (a.mp$subscript)
        return a.mp$subscript(b);
      if (Sk.misceval.isIndex(b) && a.sq$item)
        return Sk.abstr.sequenceGetItem(a, Sk.misceval.asIndex(b));
      if (a.tp$getitem)
        return a.tp$getitem(b);
    }
    var c = Sk.ffi.typeName(a);
    throw new Sk.builtin.TypeError('\'' + c + '\' does not support indexing');
  };
  goog.exportSymbol('Sk.abstr.objectGetItem', Sk.abstr.objectGetItem);
  Sk.abstr.objectSetItem = function (a, b, c) {
    if (null !== a) {
      if (a.mp$ass_subscript)
        return a.mp$ass_subscript(b, c);
      if (Sk.misceval.isIndex(b) && a.sq$ass_item)
        return Sk.abstr.sequenceSetItem(a, Sk.misceval.asIndex(b), c);
      if (a.tp$setitem)
        return a.tp$setitem(b, c);
    }
    a = Sk.ffi.typeName(a);
    throw new Sk.builtin.TypeError('\'' + a + '\' does not support item assignment');
  };
  goog.exportSymbol('Sk.abstr.objectSetItem', Sk.abstr.objectSetItem);
  Sk.abstr.gattr = function (a, b) {
    var c = Sk.ffi.typeName(a);
    if (null === a)
      throw new Sk.builtin.AttributeError('\'' + c + '\' object has no attribute \'' + b + '\'');
    var d = void 0;
    a.__getattr__ ? d = Sk.misceval.callsim(a.__getattr__, a, b) : void 0 !== a.tp$getattr && (d = a.tp$getattr(b));
    if (void 0 === d)
      throw new Sk.builtin.AttributeError('\'' + c + '\' object has no attribute \'' + b + '\'');
    return d;
  };
  goog.exportSymbol('Sk.abstr.gattr', Sk.abstr.gattr);
  Sk.abstr.sattr = function (a, b, c) {
    var d = Sk.ffi.typeName(a);
    if (null === a)
      throw new Sk.builtin.AttributeError('\'' + d + '\' object has no attribute \'' + b + '\'');
    if (a.__setattr__)
      Sk.misceval.callsim(a.__setattr__, a, b, c);
    else if (void 0 !== a.tp$setattr)
      a.tp$setattr(b, c);
    else
      throw new Sk.builtin.AttributeError('\'' + d + '\' object has no attribute \'' + b + '\'');
  };
  goog.exportSymbol('Sk.abstr.sattr', Sk.abstr.sattr);
  Sk.abstr.iter = function (a) {
    if (a.tp$iter)
      return a.tp$iter();
    throw new Sk.builtin.TypeError('\'' + Sk.ffi.typeName(a) + '\' object is not iterable');
  };
  goog.exportSymbol('Sk.abstr.iter', Sk.abstr.iter);
  Sk.abstr.iternext = function (a) {
    return a.tp$iternext();
  };
  goog.exportSymbol('Sk.abstr.iternext', Sk.abstr.iternext);
  Sk.mergeSort = function (a, b, c, d) {
    Sk.quickSort(a, b, c, d);
  };
  Sk.quickSort = function (a, b, c, d) {
    goog.asserts.assert(!c, 'todo;');
    b || (b = Sk.mergeSort.stdCmp);
    var e = function (a, c, d, l) {
      if (d - 1 > c) {
        var k = c + Math.floor(Math.random() * (d - c)), m, p = a[k];
        m = a[k];
        a[k] = a[d - 1];
        a[d - 1] = m;
        var k = c, n;
        for (n = c; n < d - 1; ++n)
          m = l ? Sk.misceval.callsim(b, p, a[n]) : Sk.misceval.callsim(b, a[n], p), 0 > Sk.builtin.asnum$(m) && (m = a[k], a[k] = a[n], a[n] = m, ++k);
        m = a[d - 1];
        a[d - 1] = a[k];
        a[k] = m;
        e(a, c, k, l);
        e(a, k + 1, d, l);
      }
    };
    e(a, 0, a.length, d);
    return null;
  };
  Sk.mergeSort.stdCmp = new Sk.builtin.func(function (a, b) {
    return Sk.misceval.richCompareBool(a, b, Sk.misceval.compareOp.Lt) ? -1 : 0;
  });
  Sk.builtin.list = function (a) {
    if (!(this instanceof Sk.builtin.list))
      return new Sk.builtin.list(a);
    if (void 0 === a)
      this.v = [];
    else if ('[object Array]' === Object.prototype.toString.apply(a))
      this.v = a;
    else if (a.tp$iter) {
      this.v = [];
      a = a.tp$iter();
      for (var b = a.tp$iternext(); void 0 !== b; b = a.tp$iternext())
        this.v.push(b);
    } else
      throw new Sk.builtin.ValueError('expecting Array or iterable');
    this.__class__ = Sk.builtin.list;
    this.v = this.v;
    return this;
  };
  Sk.builtin.list.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj('list', Sk.builtin.list);
  Sk.builtin.list.prototype.list_iter_ = function () {
    var a = {
        tp$iter: function () {
          return a;
        },
        $obj: this,
        $index: 0,
        tp$iternext: function () {
          return a.$index >= a.$obj.v.length ? void 0 : a.$obj.v[a.$index++];
        }
      };
    return a;
  };
  Sk.builtin.list.prototype.list_concat_ = function (a) {
    if (!a.__class__ || a.__class__ != Sk.builtin.list)
      throw new Sk.builtin.TypeError('can only concatenate list to list');
    for (var b = this.v.slice(), c = 0; c < a.v.length; ++c)
      b.push(a.v[c]);
    return new Sk.builtin.list(b);
  };
  Sk.builtin.list.prototype.list_del_item_ = function (a) {
    a = Sk.builtin.asnum$(a);
    if (0 > a || a >= this.v.length)
      throw new Sk.builtin.IndexError('list assignment index out of range');
    this.list_del_slice_(a, a + 1);
  };
  Sk.builtin.list.prototype.list_del_slice_ = function (a, b) {
    a = Sk.builtin.asnum$(a);
    b = Sk.builtin.asnum$(b);
    var c = [];
    c.unshift(b - a);
    c.unshift(a);
    this.v.splice.apply(this.v, c);
  };
  Sk.builtin.list.prototype.list_ass_item_ = function (a, b) {
    a = Sk.builtin.asnum$(a);
    if (0 > a || a >= this.v.length)
      throw new Sk.builtin.IndexError('list assignment index out of range');
    this.v[a] = b;
  };
  Sk.builtin.list.prototype.list_ass_slice_ = function (a, b, c) {
    a = Sk.builtin.asnum$(a);
    b = Sk.builtin.asnum$(b);
    c = c.v.slice(0);
    c.unshift(b - a);
    c.unshift(a);
    this.v.splice.apply(this.v, c);
  };
  Sk.builtin.list.prototype.tp$name = 'list';
  Sk.builtin.list.prototype.tp$str = function () {
    for (var a = [], b = this.tp$iter(), c = b.tp$iternext(); void 0 !== c; c = b.tp$iternext())
      a.push(Sk.ffi.remapToJs(Sk.misceval.objectRepr(c)));
    return Sk.builtin.stringToPy('[' + a.join(', ') + ']');
  };
  Sk.builtin.list.prototype.tp$repr = function () {
    for (var a = [], b = this.tp$iter(), c = b.tp$iternext(); void 0 !== c; c = b.tp$iternext())
      a.push(Sk.misceval.objectRepr(c).v);
    return Sk.builtin.stringToPy('[' + a.join(', ') + ']');
  };
  Sk.builtin.list.prototype.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;
  Sk.builtin.list.prototype.tp$hash = Sk.builtin.object.prototype.HashNotImplemented;
  Sk.builtin.list.prototype.tp$richcompare = function (a, b) {
    if (this === a && Sk.misceval.opAllowsEquality(b))
      return !0;
    if (!a.__class__ || a.__class__ != Sk.builtin.list)
      return b === Sk.misceval.compareOp.Eq ? !1 : b === Sk.misceval.compareOp.NotEq ? !0 : !1;
    var c = this.v;
    a = a.v;
    var d = c.length, e = a.length, f;
    for (f = 0; f < d && f < e && Sk.misceval.richCompareBool(c[f], a[f], Sk.misceval.compareOp.Eq); ++f);
    if (f >= d || f >= e)
      switch (b) {
      case Sk.misceval.compareOp.Lt:
        return d < e;
      case 'LtE':
        return d <= e;
      case Sk.misceval.compareOp.Eq:
        return d === e;
      case Sk.misceval.compareOp.NotEq:
        return d !== e;
      case Sk.misceval.compareOp.Gt:
        return d > e;
      case Sk.misceval.compareOp.GtE:
        return d >= e;
      default:
        goog.asserts.fail();
      }
    return b === Sk.misceval.compareOp.Eq ? !1 : b === Sk.misceval.compareOp.NotEq ? !0 : Sk.misceval.richCompareBool(c[f], a[f], b);
  };
  Sk.builtin.list.prototype.tp$iter = Sk.builtin.list.prototype.list_iter_;
  Sk.builtin.list.prototype.sq$length = function () {
    return this.v.length;
  };
  Sk.builtin.list.prototype.sq$concat = Sk.builtin.list.prototype.list_concat_;
  Sk.builtin.list.prototype.nb$add = Sk.builtin.list.prototype.list_concat_;
  Sk.builtin.list.prototype.nb$inplace_add = Sk.builtin.list.prototype.list_concat_;
  Sk.builtin.list.prototype.sq$repeat = function (a) {
    if (!Sk.builtin.checkInt(a))
      throw new Sk.builtin.TypeError('can\'t multiply sequence by non-int of type \'' + Sk.ffi.typeName(a) + '\'');
    a = Sk.builtin.asnum$(a);
    for (var b = [], c = 0; c < a; ++c)
      for (var d = 0; d < this.v.length; ++d)
        b.push(this.v[d]);
    return new Sk.builtin.list(b);
  };
  Sk.builtin.list.prototype.nb$mul = Sk.builtin.list.prototype.sq$repeat;
  Sk.builtin.list.prototype.nb$inplace_multiply = Sk.builtin.list.prototype.sq$repeat;
  Sk.builtin.list.prototype.sq$ass_item = Sk.builtin.list.prototype.list_ass_item_;
  Sk.builtin.list.prototype.sq$del_item = Sk.builtin.list.prototype.list_del_item_;
  Sk.builtin.list.prototype.sq$ass_slice = Sk.builtin.list.prototype.list_ass_slice_;
  Sk.builtin.list.prototype.sq$del_slice = Sk.builtin.list.prototype.list_del_slice_;
  Sk.builtin.list.prototype.list_subscript_ = function (a) {
    if (Sk.misceval.isIndex(a)) {
      var b = Sk.misceval.asIndex(a);
      if (void 0 !== b) {
        0 > b && (b = this.v.length + b);
        if (0 > b || b >= this.v.length)
          throw new Sk.builtin.IndexError('list index out of range');
        return this.v[b];
      }
    } else if (a instanceof Sk.builtin.slice) {
      var c = [];
      a.sssiter$(this, function (a, b) {
        c.push(b.v[a]);
      });
      return new Sk.builtin.list(c);
    }
    throw new Sk.builtin.TypeError('list indices must be integers, not ' + Sk.ffi.typeName(a));
  };
  Sk.builtin.list.prototype.list_ass_subscript_ = function (a, b) {
    if (Sk.misceval.isIndex(a)) {
      var c = Sk.misceval.asIndex(a);
      if (void 0 !== c) {
        0 > c && (c = this.v.length + c);
        this.list_ass_item_(c, b);
        return;
      }
    } else if (a instanceof Sk.builtin.slice) {
      if (1 === (null !== a.step ? a.step : 1))
        this.list_ass_slice_(a.start, a.stop, b);
      else {
        var d = [];
        a.sssiter$(this, function (a, b) {
          d.push(a);
        });
        var e = 0;
        if (d.length !== b.v.length)
          throw new Sk.builtin.ValueError('attempt to assign sequence of size ' + b.v.length + ' to extended slice of size ' + d.length);
        for (c = 0; c < d.length; ++c)
          this.v.splice(d[c], 1, b.v[e]), e += 1;
      }
      return;
    }
    throw new Sk.builtin.TypeError('list indices must be integers, not ' + Sk.ffi.typeName(a));
  };
  Sk.builtin.list.prototype.list_del_subscript_ = function (a) {
    if (Sk.misceval.isIndex(a)) {
      var b = Sk.misceval.asIndex(a);
      if (void 0 !== b) {
        0 > b && (b = this.v.length + b);
        this.list_del_item_(b);
        return;
      }
    } else if (a instanceof Sk.builtin.slice) {
      if (1 === a.step)
        this.list_del_slice_(a.start, a.stop);
      else {
        var c = this, d = 0, e = 0 < (null === a.step ? 1 : a.step) ? 1 : 0;
        a.sssiter$(this, function (a, b) {
          c.v.splice(a - d, 1);
          d += e;
        });
      }
      return;
    }
    throw new Sk.builtin.TypeError('list indices must be integers, not ' + typeof a);
  };
  Sk.builtin.list.prototype.mp$subscript = Sk.builtin.list.prototype.list_subscript_;
  Sk.builtin.list.prototype.mp$ass_subscript = Sk.builtin.list.prototype.list_ass_subscript_;
  Sk.builtin.list.prototype.mp$del_subscript = Sk.builtin.list.prototype.list_del_subscript_;
  Sk.builtin.list.prototype.__getitem__ = new Sk.builtin.func(function (a, b) {
    return Sk.builtin.list.prototype.list_subscript_.call(a, b);
  });
  Sk.builtin.list.prototype.list_sort_ = function (a, b, c, d) {
    var e = void 0 !== c && null !== c, f = void 0 !== b && null !== b;
    void 0 == d && (d = !1);
    var g = new Sk.builtin.timSort(a);
    a.v = [];
    var h = Sk.ffi.numberToIntPy(0);
    if (e) {
      g.lt = f ? function (a, c) {
        return Sk.misceval.richCompareBool(b.func_code(a[0], c[0]), h, Sk.misceval.compareOp.Lt);
      } : function (a, b) {
        return Sk.misceval.richCompareBool(a[0], b[0], Sk.misceval.compareOp.Lt);
      };
      for (var l = 0; l < g.listlength; l++) {
        var f = g.list.v[l], k = c.func_code(f);
        g.list.v[l] = [
          k,
          f
        ];
      }
    } else
      f && (g.lt = function (a, c) {
        return Sk.misceval.richCompareBool(b.func_code(a, c), h, Sk.misceval.compareOp.Lt);
      });
    d && g.list.list_reverse_(g.list);
    g.sort();
    d && g.list.list_reverse_(g.list);
    if (e)
      for (c = 0; c < g.listlength; c++)
        f = g.list.v[c][1], g.list.v[c] = f;
    c = 0 < a.sq$length();
    a.v = g.list.v;
    if (c)
      throw new Sk.builtin.OperationError('list modified during sort');
  };
  Sk.builtin.list.prototype.list_reverse_ = function (a) {
    Sk.builtin.pyCheckArgs('reverse', arguments, 1, 1);
    for (var b = a.v, c = [], d = a.v.length - 1; -1 < d; --d)
      c.push(b[d]);
    a.v = c;
    return null;
  };
  Sk.builtin.list.prototype.__iter__ = new Sk.builtin.func(function (a) {
    Sk.builtin.pyCheckArgs('__iter__', arguments, 1, 1);
    return a.list_iter_();
  });
  Sk.builtin.list.prototype.append = new Sk.builtin.func(function (a, b) {
    Sk.builtin.pyCheckArgs('append', arguments, 2, 2);
    a.v.push(b);
    return null;
  });
  Sk.builtin.list.prototype.insert = new Sk.builtin.func(function (a, b, c) {
    Sk.builtin.pyCheckArgs('insert', arguments, 3, 3);
    if (!Sk.builtin.checkNumber(b))
      throw new Sk.builtin.TypeError('an integer is required');
    b = Sk.builtin.asnum$(b);
    0 > b ? b = 0 : b > a.v.length && (b = a.v.length);
    a.v.splice(b, 0, c);
  });
  Sk.builtin.list.prototype.extend = new Sk.builtin.func(function (a, b) {
    Sk.builtin.pyCheckArgs('extend', arguments, 2, 2);
    if (!Sk.builtin.checkIterable(b))
      throw new Sk.builtin.TypeError('\'' + Sk.ffi.typeName(b) + '\' object is not iterable');
    if (a == b) {
      for (var c = [], d = b.tp$iter(), e = d.tp$iternext(); void 0 !== e; e = d.tp$iternext())
        c.push(e);
      a.v.push.apply(a.v, c);
      return null;
    }
    d = b.tp$iter();
    for (e = d.tp$iternext(); void 0 !== e; e = d.tp$iternext())
      a.v.push(e);
    return null;
  });
  Sk.builtin.list.prototype.pop = new Sk.builtin.func(function (a, b) {
    Sk.builtin.pyCheckArgs('pop', arguments, 1, 2);
    void 0 === b && (b = a.v.length - 1);
    if (!Sk.builtin.checkNumber(b))
      throw new Sk.builtin.TypeError('an integer is required');
    b = Sk.builtin.asnum$(b);
    if (0 > b || b >= a.v.length)
      throw new Sk.builtin.IndexError('pop index out of range');
    var c = a.v[b];
    a.v.splice(b, 1);
    return c;
  });
  Sk.builtin.list.prototype.remove = new Sk.builtin.func(function (a, b) {
    Sk.builtin.pyCheckArgs('remove', arguments, 2, 2);
    var c = Sk.builtin.list.prototype.index.func_code(a, b);
    a.v.splice(c, 1);
    return null;
  });
  Sk.builtin.list.prototype.index = new Sk.builtin.func(function (a, b) {
    Sk.builtin.pyCheckArgs('index', arguments, 2, 2);
    for (var c = a.v.length, d = a.v, e = 0; e < c; ++e)
      if (Sk.misceval.richCompareBool(d[e], b, Sk.misceval.compareOp.Eq))
        return e;
    throw new Sk.builtin.ValueError('list.index(x): x not in list');
  });
  Sk.builtin.list.prototype.count = new Sk.builtin.func(function (a, b) {
    Sk.ffi.checkMethodArgs('count()', arguments, 1, 1);
    for (var c = a.v.length, d = a.v, e = 0, f = 0; f < c; ++f)
      Sk.misceval.richCompareBool(d[f], b, Sk.misceval.compareOp.Eq) && (e += 1);
    return e;
  });
  Sk.builtin.list.prototype.reverse = new Sk.builtin.func(Sk.builtin.list.prototype.list_reverse_);
  Sk.builtin.list.prototype.sort = new Sk.builtin.func(Sk.builtin.list.prototype.list_sort_);
  Sk.builtin.list.prototype.sort.func_code.co_varnames = [
    '__self__',
    'cmp',
    'key',
    'reverse'
  ];
  goog.exportSymbol('Sk.builtin.list', Sk.builtin.list);
  var interned = {};
  Sk.builtin.JsType = {
    UNDEFINED: 'undefined',
    OBJECT: 'object',
    STRING: 'string',
    NUMBER: 'number',
    BOOLEAN: 'boolean',
    FUNCTION: 'function'
  };
  Sk.builtin.stringToPy = function (a, b) {
    var c = typeof a;
    if (c === Sk.builtin.JsType.STRING)
      return 0 < a.length ? new Sk.builtin.StringPy(a) : Sk.builtin.StringPy.$emptystr;
    if (c === Sk.builtin.JsType.OBJECT && null === a)
      return Sk.builtin.none.none$;
    if (c === Sk.builtin.JsType.UNDEFINED) {
      c = typeof b;
      if (c === Sk.builtin.JsType.STRING)
        return Sk.builtin.stringToPy(b.toString());
      if (c === Sk.builtin.JsType.UNDEFINED)
        return;
      if (c === Sk.builtin.JsType.OBJECT && null === b)
        return Sk.builtin.none.none$;
      throw Sk.ffi.err.argument('defaultJs').inFunction('Sk.builtin.stringToPy').mustHaveType([
        Sk.builtin.JsType.STRING,
        Sk.builtin.JsType.UNDEFINED,
        'null'
      ].join(' or '));
    }
    throw Sk.ffi.err.argument('valueJs').inFunction('Sk.builtin.stringToPy').mustHaveType([
      Sk.builtin.JsType.STRING,
      'null',
      Sk.builtin.JsType.UNDEFINED
    ].join(' or '));
  };
  goog.exportSymbol('Sk.builtin.stringToPy', Sk.builtin.stringToPy);
  Sk.builtin.stringToJs = function (a) {
    return a.v;
  };
  goog.exportSymbol('Sk.builtin.stringToJs', Sk.builtin.stringToJs);
  Sk.builtin.isStringPy = function (a) {
    return a instanceof Sk.builtin.StringPy;
  };
  goog.exportSymbol('Sk.builtin.isStringPy', Sk.builtin.isStringPy);
  Sk.builtin.StringPy = function (a) {
    void 0 === a && (a = '');
    if (a instanceof Sk.builtin.StringPy && a !== Sk.builtin.StringPy.prototype.ob$type)
      return a;
    if (!Sk.builtin.isStringPy(this))
      return new Sk.builtin.StringPy(a);
    if (!0 === a)
      a = 'True';
    else if (!1 === a)
      a = 'False';
    else if (null === a || a === Sk.builtin.none.none$)
      a = 'None';
    else if (a instanceof Sk.builtin.bool)
      a = a.v ? 'True' : 'False';
    else if ('number' === typeof a)
      a = a.toString(), 'Infinity' === a ? a = 'inf' : '-Infinity' === a && (a = '-inf');
    else if ('string' !== typeof a) {
      if (void 0 !== a.tp$str) {
        a = a.tp$str();
        if (!Sk.builtin.isStringPy(a))
          throw new Sk.builtin.ValueError('__str__ didn\'t return a str');
        return a;
      }
      return Sk.misceval.objectRepr(a);
    }
    if (Object.prototype.hasOwnProperty.call(interned, '1' + a))
      return interned['1' + a];
    this.__class__ = Sk.builtin.StringPy;
    this.v = this.v = a;
    interned['1' + a] = this;
    return this;
  };
  goog.exportSymbol('Sk.builtin.StringPy', Sk.builtin.StringPy);
  Sk.builtin.StringPy.$emptystr = new Sk.builtin.StringPy('');
  Sk.builtin.StringPy.prototype.mp$subscript = function (a) {
    a = Sk.builtin.asnum$(a);
    if ('number' === typeof a && Math.floor(a) === a) {
      0 > a && (a = this.v.length + a);
      if (0 > a || a >= this.v.length)
        throw new Sk.builtin.IndexError('string index out of range');
      return Sk.builtin.stringToPy(this.v.charAt(a));
    }
    if (a instanceof Sk.builtin.slice) {
      var b = '';
      a.sssiter$(this, function (a, d) {
        0 <= a && a < Sk.ffi.remapToJs(d).length && (b += Sk.ffi.remapToJs(d).charAt(a));
      });
      return Sk.builtin.stringToPy(b);
    }
    throw new Sk.builtin.TypeError('string indices must be numbers, not ' + typeof a);
  };
  Sk.builtin.StringPy.prototype.sq$length = function () {
    return this.v.length;
  };
  Sk.builtin.StringPy.prototype.sq$concat = function (a) {
    if (!a || !Sk.builtin.isStringPy(a))
      throw a = Sk.ffi.typeName(a), new Sk.builtin.TypeError('cannot concatenate \'str\' and \'' + a + '\' objects');
    return Sk.builtin.stringToPy(Sk.ffi.remapToJs(this) + Sk.ffi.remapToJs(a));
  };
  Sk.builtin.StringPy.prototype.nb$add = Sk.builtin.StringPy.prototype.sq$concat;
  Sk.builtin.StringPy.prototype.nb$inplace_add = Sk.builtin.StringPy.prototype.sq$concat;
  Sk.builtin.StringPy.prototype.sq$repeat = function (a) {
    a = Sk.builtin.asnum$(a);
    for (var b = '', c = 0; c < a; ++c)
      b += Sk.ffi.remapToJs(this);
    return Sk.builtin.stringToPy(b);
  };
  Sk.builtin.StringPy.prototype.nb$mul = Sk.builtin.StringPy.prototype.sq$repeat;
  Sk.builtin.StringPy.prototype.nb$inplace_multiply = Sk.builtin.StringPy.prototype.sq$repeat;
  Sk.builtin.StringPy.prototype.sq$item = function () {
    goog.asserts.fail();
  };
  Sk.builtin.StringPy.prototype.sq$slice = function (a, b) {
    a = Sk.builtin.asnum$(a);
    b = Sk.builtin.asnum$(b);
    0 > a && (a = 0);
    return Sk.builtin.stringToPy(Sk.ffi.remapToJs(this).substr(a, b - a));
  };
  Sk.builtin.StringPy.prototype.sq$contains = function (a) {
    if (void 0 === Sk.ffi.remapToJs(a) || Sk.ffi.remapToJs(a).constructor != String)
      throw new Sk.builtin.TypeError('TypeError: \'In <string> requires string as left operand');
    return -1 != this.v.indexOf(Sk.ffi.remapToJs(a)) ? !0 : !1;
  };
  Sk.builtin.StringPy.prototype.tp$name = 'str';
  Sk.builtin.StringPy.prototype.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;
  Sk.builtin.StringPy.prototype.tp$iter = function () {
    var a = {
        tp$iter: function () {
          return a;
        },
        $obj: this,
        $index: 0,
        tp$iternext: function () {
          return a.$index >= a.$obj.v.length ? void 0 : Sk.builtin.stringToPy(a.$obj.v.substr(a.$index++, 1));
        }
      };
    return a;
  };
  Sk.builtin.StringPy.prototype.tp$richcompare = function (a, b) {
    if (Sk.builtin.isStringPy(a)) {
      if (this === a)
        switch (b) {
        case Sk.misceval.compareOp.Eq:
        case 'LtE':
        case Sk.misceval.compareOp.GtE:
          return !0;
        case Sk.misceval.compareOp.NotEq:
        case Sk.misceval.compareOp.Lt:
        case Sk.misceval.compareOp.Gt:
          return !1;
        }
      var c = this.v.length, d = a.v.length, e = Math.min(c, d), f = 0;
      if (0 < e)
        for (var g = 0; g < e; ++g) {
          if (this.v[g] != a.v[g]) {
            f = this.v[g].charCodeAt(0) - a.v[g].charCodeAt(0);
            break;
          }
        }
      else
        f = 0;
      0 == f && (f = c < d ? -1 : c > d ? 1 : 0);
      switch (b) {
      case Sk.misceval.compareOp.Lt:
        return 0 > f;
      case 'LtE':
        return 0 >= f;
      case Sk.misceval.compareOp.Eq:
        return 0 == f;
      case Sk.misceval.compareOp.NotEq:
        return 0 != f;
      case Sk.misceval.compareOp.Gt:
        return 0 < f;
      case Sk.misceval.compareOp.GtE:
        return 0 <= f;
      default:
        goog.asserts.fail();
      }
    }
  };
  Sk.builtin.StringPy.prototype.tp$repr = function () {
    var a = '\'';
    -1 !== this.v.indexOf('\'') && -1 === this.v.indexOf('"') && (a = '"');
    for (var b = this.v.length, c = a, d = 0; d < b; ++d) {
      var e = this.v.charAt(d);
      e === a || '\\' === e ? c += '\\' + e : '\t' === e ? c += '\\t' : '\n' === e ? c += '\\n' : '\r' === e ? c += '\\r' : ' ' > e || 127 <= e ? (e = e.charCodeAt(0).toString(16), 2 > e.length && (e = '0' + e), c += '\\x' + e) : c += e;
    }
    return Sk.builtin.stringToPy(c + a);
  };
  Sk.builtin.StringPy.re_escape_ = function (a) {
    for (var b = [], c = /^[A-Za-z0-9]+$/, d = 0; d < a.length; ++d) {
      var e = a.charAt(d);
      c.test(e) ? b.push(e) : '\\000' === e ? b.push('\\000') : b.push('\\' + e);
    }
    return b.join('');
  };
  Sk.builtin.StringPy.prototype.lower = new Sk.builtin.func(function (a) {
    Sk.builtin.pyCheckArgs('lower', arguments, 1, 1);
    return Sk.builtin.stringToPy(a.v.toLowerCase());
  });
  Sk.builtin.StringPy.prototype.upper = new Sk.builtin.func(function (a) {
    Sk.builtin.pyCheckArgs('upper', arguments, 1, 1);
    return Sk.builtin.stringToPy(a.v.toUpperCase());
  });
  Sk.builtin.StringPy.prototype.capitalize = new Sk.builtin.func(function (a) {
    Sk.builtin.pyCheckArgs('capitalize', arguments, 1, 1);
    var b = a.v, c, d;
    if (0 === b.length)
      return Sk.builtin.stringToPy('');
    c = b.charAt(0).toUpperCase();
    for (d = 1; d < b.length; d++)
      c += b.charAt(d).toLowerCase();
    return Sk.builtin.stringToPy(c);
  });
  Sk.builtin.StringPy.prototype.join = new Sk.builtin.func(function (a, b) {
    Sk.builtin.pyCheckArgs('join', arguments, 2, 2);
    Sk.builtin.pyCheckType('seq', 'iterable', Sk.builtin.checkIterable(b));
    for (var c = [], d = b.tp$iter(), e = d.tp$iternext(); void 0 !== e; e = d.tp$iternext()) {
      if (e.constructor !== Sk.builtin.StringPy)
        throw 'TypeError: sequence item ' + c.length + ': expected string, ' + typeof e + ' found';
      c.push(e.v);
    }
    return Sk.builtin.stringToPy(c.join(a.v));
  });
  Sk.builtin.StringPy.prototype.split = new Sk.builtin.func(function (a, b, c) {
    Sk.builtin.pyCheckArgs('split', arguments, 1, 3);
    if (void 0 === b || b === Sk.builtin.none.none$)
      b = null;
    if (null !== b && !Sk.builtin.isStringPy(b))
      throw new Sk.builtin.TypeError('expected a string');
    if (null !== b && '' === b.v)
      throw new Sk.builtin.ValueError('empty separator');
    if (void 0 !== c && !Sk.builtin.checkInt(c))
      throw new Sk.builtin.TypeError('an integer is required');
    c = Sk.builtin.asnum$(c);
    var d = /[\s]+/g, e = a.v;
    null === b ? e = e.trimLeft() : (d = b.v.replace(/([.*+?=|\\\/()\[\]\{\}^$])/g, '\\$1'), d = RegExp(d, 'g'));
    for (var f = [], g, h = 0, l = 0; null != (g = d.exec(e)) && g.index !== d.lastIndex && !(f.push(Sk.builtin.stringToPy(e.substring(h, g.index))), h = d.lastIndex, l += 1, c && l >= c););
    e = e.substring(h);
    (null !== b || 0 < e.length) && f.push(Sk.builtin.stringToPy(e));
    return new Sk.builtin.list(f);
  });
  Sk.builtin.StringPy.prototype.strip = new Sk.builtin.func(function (a, b) {
    Sk.builtin.pyCheckArgs('strip', arguments, 1, 2);
    if (void 0 !== b && !Sk.builtin.isStringPy(b))
      throw new Sk.builtin.TypeError('strip arg must be None or str');
    var c;
    void 0 === b ? c = /^\s+|\s+$/g : (c = Sk.builtin.StringPy.re_escape_(Sk.builtin.stringToJs(b)), c = RegExp('^[' + c + ']+|[' + c + ']+$', 'g'));
    return Sk.builtin.stringToPy(a.v.replace(c, ''));
  });
  Sk.builtin.StringPy.prototype.lstrip = new Sk.builtin.func(function (a, b) {
    Sk.builtin.pyCheckArgs('lstrip', arguments, 1, 2);
    if (void 0 !== b && !Sk.builtin.isStringPy(b))
      throw new Sk.builtin.TypeError('lstrip arg must be None or str');
    var c;
    void 0 === b ? c = /^\s+/g : (c = Sk.builtin.StringPy.re_escape_(Sk.builtin.stringToJs(b)), c = RegExp('^[' + c + ']+', 'g'));
    return Sk.builtin.stringToPy(a.v.replace(c, ''));
  });
  Sk.builtin.StringPy.prototype.rstrip = new Sk.builtin.func(function (a, b) {
    Sk.builtin.pyCheckArgs('rstrip', arguments, 1, 2);
    if (void 0 !== b && !Sk.builtin.isStringPy(b))
      throw new Sk.builtin.TypeError('rstrip arg must be None or str');
    var c;
    void 0 === b ? c = /\s+$/g : (c = Sk.builtin.StringPy.re_escape_(Sk.builtin.stringToJs(b)), c = RegExp('[' + c + ']+$', 'g'));
    return Sk.builtin.stringToPy(a.v.replace(c, ''));
  });
  Sk.builtin.StringPy.prototype.partition = new Sk.builtin.func(function (a, b) {
    Sk.builtin.pyCheckArgs('partition', arguments, 2, 2);
    Sk.builtin.pyCheckType('sep', 'string', Sk.builtin.isStringPy(b));
    var c = Sk.builtin.stringToJs(b), d = a.v.indexOf(c);
    return 0 > d ? new Sk.builtin.tuple([
      a,
      Sk.builtin.StringPy.$emptystr,
      Sk.builtin.StringPy.$emptystr
    ]) : new Sk.builtin.tuple([
      Sk.builtin.stringToPy(a.v.substring(0, d)),
      b,
      Sk.builtin.stringToPy(a.v.substring(d + c.length))
    ]);
  });
  Sk.builtin.StringPy.prototype.rpartition = new Sk.builtin.func(function (a, b) {
    Sk.builtin.pyCheckArgs('rpartition', arguments, 2, 2);
    Sk.ffi.checkArgType('sep', Sk.ffi.PyType.STR, Sk.builtin.isStringPy(b), b);
    var c = Sk.builtin.stringToJs(b), d = a.v.lastIndexOf(c);
    return 0 > d ? new Sk.builtin.tuple([
      Sk.builtin.StringPy.$emptystr,
      Sk.builtin.StringPy.$emptystr,
      a
    ]) : new Sk.builtin.tuple([
      Sk.builtin.stringToPy(a.v.substring(0, d)),
      b,
      Sk.builtin.stringToPy(a.v.substring(d + c.length))
    ]);
  });
  Sk.builtin.StringPy.prototype.count = new Sk.builtin.func(function (a, b, c, d) {
    Sk.builtin.pyCheckArgs('count', arguments, 2, 4);
    if (!Sk.builtin.isStringPy(b))
      throw new Sk.builtin.TypeError('expected a character buffer object');
    if (void 0 !== c && !Sk.builtin.checkInt(c))
      throw new Sk.builtin.TypeError('slice indices must be integers or None or have an __index__ method');
    if (void 0 !== d && !Sk.builtin.checkInt(d))
      throw new Sk.builtin.TypeError('slice indices must be integers or None or have an __index__ method');
    void 0 === c ? c = 0 : (c = Sk.builtin.asnum$(c), c = 0 <= c ? c : a.v.length + c);
    void 0 === d ? d = a.v.length : (d = Sk.builtin.asnum$(d), d = 0 <= d ? d : a.v.length + d);
    var e = RegExp(Sk.builtin.stringToJs(b), 'g');
    return (e = a.v.slice(c, d).match(e)) ? e.length : 0;
  });
  Sk.builtin.StringPy.prototype.ljust = new Sk.builtin.func(function (a, b, c) {
    Sk.builtin.pyCheckArgs('ljust', arguments, 2, 3);
    if (!Sk.builtin.checkInt(b))
      throw new Sk.builtin.TypeError('integer argument expected, got ' + Sk.ffi.typeName(b));
    if (void 0 !== c && (!Sk.builtin.isStringPy(c) || 1 !== Sk.ffi.remapToJs(c).length))
      throw new Sk.builtin.TypeError('must be char, not ' + Sk.ffi.typeName(c));
    c = void 0 === c ? ' ' : Sk.builtin.stringToJs(c);
    b = Sk.builtin.asnum$(b);
    if (a.v.length >= b)
      return a;
    var d = Array.prototype.join.call({ length: Math.floor(b - a.v.length) + 1 }, c);
    return Sk.builtin.stringToPy(a.v + d);
  });
  Sk.builtin.StringPy.prototype.rjust = new Sk.builtin.func(function (a, b, c) {
    Sk.builtin.pyCheckArgs('rjust', arguments, 2, 3);
    if (!Sk.builtin.checkInt(b))
      throw new Sk.builtin.TypeError('integer argument exepcted, got ' + Sk.ffi.typeName(b));
    if (void 0 !== c && (!Sk.builtin.isStringPy(c) || 1 !== Sk.ffi.remapToJs(c).length))
      throw new Sk.builtin.TypeError('must be char, not ' + Sk.ffi.typeName(c));
    c = void 0 === c ? ' ' : Sk.builtin.stringToJs(c);
    b = Sk.builtin.asnum$(b);
    if (a.v.length >= b)
      return a;
    var d = Array.prototype.join.call({ length: Math.floor(b - a.v.length) + 1 }, c);
    return Sk.builtin.stringToPy(d + a.v);
  });
  Sk.builtin.StringPy.prototype.center = new Sk.builtin.func(function (a, b, c) {
    Sk.builtin.pyCheckArgs('center', arguments, 2, 3);
    if (!Sk.builtin.checkInt(b))
      throw new Sk.builtin.TypeError('integer argument exepcted, got ' + Sk.ffi.typeName(b));
    if (void 0 !== c && (!Sk.builtin.isStringPy(c) || 1 !== Sk.ffi.remapToJs(c).length))
      throw new Sk.builtin.TypeError('must be char, not ' + Sk.ffi.typeName(c));
    c = void 0 === c ? ' ' : Sk.builtin.stringToJs(c);
    b = Sk.builtin.asnum$(b);
    if (a.v.length >= b)
      return a;
    var d = Array.prototype.join.call({ length: Math.floor((b - a.v.length) / 2) + 1 }, c), d = d + a.v + d;
    d.length < b && (d += c);
    return Sk.builtin.stringToPy(d);
  });
  Sk.builtin.StringPy.prototype.find = new Sk.builtin.func(function (a, b, c, d) {
    Sk.builtin.pyCheckArgs('find', arguments, 2, 4);
    if (!Sk.builtin.isStringPy(b))
      throw new Sk.builtin.TypeError('expected a character buffer object');
    if (void 0 !== c && !Sk.builtin.checkInt(c))
      throw new Sk.builtin.TypeError('slice indices must be integers or None or have an __index__ method');
    if (void 0 !== d && !Sk.builtin.checkInt(d))
      throw new Sk.builtin.TypeError('slice indices must be integers or None or have an __index__ method');
    void 0 === c ? c = 0 : (c = Sk.builtin.asnum$(c), c = 0 <= c ? c : a.v.length + c);
    void 0 === d ? d = a.v.length : (d = Sk.builtin.asnum$(d), d = 0 <= d ? d : a.v.length + d);
    var e = a.v.indexOf(Sk.builtin.stringToJs(b), c);
    return Sk.ffi.numberToIntPy(e >= c && e < d ? e : -1);
  });
  Sk.builtin.StringPy.prototype.index = new Sk.builtin.func(function (a, b, c, d) {
    Sk.builtin.pyCheckArgs('index', arguments, 2, 4);
    var e = Sk.misceval.callsim(a.find, a, b, c, d);
    if (-1 === Sk.builtin.asnum$(e))
      throw new Sk.builtin.ValueError('substring not found');
    return e;
  });
  Sk.builtin.StringPy.prototype.rfind = new Sk.builtin.func(function (a, b, c, d) {
    Sk.builtin.pyCheckArgs('rfind', arguments, 2, 4);
    if (!Sk.builtin.isStringPy(b))
      throw new Sk.builtin.TypeError('expected a character buffer object');
    if (void 0 !== c && !Sk.builtin.checkInt(c))
      throw new Sk.builtin.TypeError('slice indices must be integers or None or have an __index__ method');
    if (void 0 !== d && !Sk.builtin.checkInt(d))
      throw new Sk.builtin.TypeError('slice indices must be integers or None or have an __index__ method');
    void 0 === c ? c = 0 : (c = Sk.builtin.asnum$(c), c = 0 <= c ? c : a.v.length + c);
    void 0 === d ? d = a.v.length : (d = Sk.builtin.asnum$(d), d = 0 <= d ? d : a.v.length + d);
    var e = a.v.lastIndexOf(Sk.builtin.stringToJs(b), d), e = e !== d ? e : a.v.lastIndexOf(Sk.builtin.stringToJs(b), d - 1);
    return Sk.ffi.numberToIntPy(e >= c && e < d ? e : -1);
  });
  Sk.builtin.StringPy.prototype.rindex = new Sk.builtin.func(function (a, b, c, d) {
    Sk.builtin.pyCheckArgs('rindex', arguments, 2, 4);
    var e = Sk.misceval.callsim(a.rfind, a, b, c, d);
    if (-1 === Sk.builtin.asnum$(e))
      throw new Sk.builtin.ValueError('substring not found');
    return e;
  });
  Sk.builtin.StringPy.prototype.startswith = new Sk.builtin.func(function (a, b) {
    Sk.builtin.pyCheckArgs('startswith', arguments, 2, 2);
    Sk.builtin.pyCheckType('tgt', 'string', Sk.builtin.isStringPy(b));
    return Sk.builtin.bool(0 == a.v.indexOf(Sk.builtin.stringToJs(b)));
  });
  Sk.builtin.StringPy.prototype.endswith = new Sk.builtin.func(function (a, b) {
    Sk.builtin.pyCheckArgs('endswith', arguments, 2, 2);
    Sk.builtin.pyCheckType('tgt', 'string', Sk.builtin.isStringPy(b));
    var c = Sk.builtin.stringToJs(b);
    return Sk.builtin.bool(-1 !== a.v.indexOf(c, a.v.length - c.length));
  });
  Sk.builtin.StringPy.prototype.replace = new Sk.builtin.func(function (a, b, c, d) {
    Sk.builtin.pyCheckArgs('replace', arguments, 3, 4);
    Sk.builtin.pyCheckType('oldS', 'string', Sk.builtin.isStringPy(b));
    Sk.builtin.pyCheckType('newS', 'string', Sk.builtin.isStringPy(c));
    if (void 0 !== d && !Sk.builtin.checkInt(d))
      throw new Sk.builtin.TypeError('integer argument expected, got ' + Sk.ffi.typeName(d));
    var e = Sk.builtin.stringToJs(b), f = Sk.builtin.stringToJs(c);
    d = Sk.builtin.asnum$(d);
    e = RegExp(Sk.builtin.StringPy.re_escape_(e), 'g');
    if (void 0 === d || 0 > d)
      return Sk.builtin.stringToPy(a.v.replace(e, f));
    var g = 0;
    return Sk.builtin.stringToPy(a.v.replace(e, function (a) {
      g++;
      return g <= d ? f : a;
    }));
  });
  Sk.builtin.StringPy.prototype.isdigit = new Sk.builtin.func(function (a) {
    Sk.builtin.pyCheckArgs('isdigit', arguments, 1, 1);
    if (0 === a.v.length)
      return Sk.builtin.bool(!1);
    var b;
    for (b = 0; b < a.v.length; b++) {
      var c = a.v.charAt(b);
      if ('0' > c || '9' < c)
        return Sk.builtin.bool(!1);
    }
    return Sk.builtin.bool(!0);
  });
  Sk.builtin.StringPy.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj('str', Sk.builtin.StringPy);
  Sk.builtin.StringPy.prototype.nb$remainder = function (a) {
    a.constructor === Sk.builtin.tuple || void 0 !== a.mp$subscript && a.constructor !== Sk.builtin.StringPy || (a = new Sk.builtin.tuple([a]));
    var b = 0, c = this.v.replace(/%(\([a-zA-Z0-9]+\))?([#0 +\-]+)?(\*|[0-9]+)?(\.(\*|[0-9]+))?[hlL]?([diouxXeEfFgGcrs%])/g, function (c, e, f, g, h, l, k) {
        g = Sk.builtin.asnum$(g);
        h = Sk.builtin.asnum$(h);
        var m;
        if (void 0 === e || '' === e)
          m = b++;
        var p = !1, n = !1, q = !1, x = !1, D = !1;
        f && (-1 !== f.indexOf('-') ? n = !0 : -1 !== f.indexOf('0') && (p = !0), -1 !== f.indexOf('+') ? x = !0 : -1 !== f.indexOf(' ') && (q = !0), D = -1 !== f.indexOf('#'));
        h && (h = parseInt(h.substr(1), 10));
        f = function (a, b) {
          b = Sk.builtin.asnum$(b);
          var c, d, e = !1;
          'number' === typeof a ? (0 > a && (a = -a, e = !0), d = a.toString(b)) : Sk.ffi.isFloat(a) || Sk.ffi.isInt(a) ? (d = a.str$(b, !1), 2 < d.length && '.0' === d.substr(-2) && (d = d.substr(0, d.length - 2)), e = a.nb$isnegative()) : Sk.ffi.isLong(a) && (d = a.str$(b, !1), e = a.nb$isnegative());
          goog.asserts.assert(void 0 !== d, 'unhandled number format');
          var f = !1;
          if (h)
            for (c = d.length; c < h; ++c)
              d = '0' + d, f = !0;
          c = '';
          e ? c = '-' : x ? c = '+' + c : q && (c = ' ' + c);
          D && (16 === b ? c += '0x' : 8 !== b || (f || '0' === d) || (c += '0'));
          return [
            c,
            d
          ];
        };
        c = function (a) {
          var b = a[0];
          a = a[1];
          var c;
          if (g)
            if (g = parseInt(g, 10), c = a.length + b.length, p)
              for (; c < g; ++c)
                a = '0' + a;
            else if (n)
              for (; c < g; ++c)
                a += ' ';
            else
              for (; c < g; ++c)
                b = ' ' + b;
          return b + a;
        };
        if (a.constructor === Sk.builtin.tuple)
          e = a.v[m];
        else if (void 0 !== a.mp$subscript)
          e = e.substring(1, e.length - 1), e = a.mp$subscript(Sk.builtin.stringToPy(e));
        else
          throw new Sk.builtin.AttributeError(a.tp$name + ' instance has no attribute \'mp$subscript\'');
        switch (k) {
        case 'd':
        case 'i':
          return c(f(e, 10));
        case 'o':
          return c(f(e, 8));
        case 'x':
          return c(f(e, 16));
        case 'X':
          return c(f(e, 16)).toUpperCase();
        case 'f':
        case 'F':
        case 'e':
        case 'E':
        case 'g':
        case 'G':
          e = Sk.builtin.asnum$(e);
          'string' === typeof e && (e = Number(e));
          if (Infinity === e)
            return 'inf';
          if (-Infinity === e)
            return '-inf';
          if (isNaN(e))
            return 'nan';
          m = [
            'toExponential',
            'toFixed',
            'toPrecision'
          ]['efg'.indexOf(k.toLowerCase())];
          if (void 0 === h || '' === h)
            if ('e' === k || 'E' === k)
              h = 6;
            else if ('f' === k || 'F' === k)
              h = 7;
          e = e[m](h);
          -1 !== 'EFG'.indexOf(k) && (e = e.toUpperCase());
          return c([
            '',
            e
          ]);
        case 'c':
          if ('number' === typeof e)
            return String.fromCharCode(e);
          if (Sk.ffi.isFloat(e) || Sk.ffi.isInt(e))
            return String.fromCharCode(Sk.ffi.remapToJs(e));
          if (Sk.ffi.isLong(e))
            return String.fromCharCode(e.str$(10, !1)[0]);
          if (Sk.builtin.isStringPy(e))
            return Sk.builtin.stringToJs(e).substr(0, 1);
          throw new Sk.builtin.TypeError('an integer is required');
        case 'r':
          return k = Sk.builtin.repr(e), h ? Sk.builtin.stringToJs(k).substr(0, h) : Sk.ffi.remapToJs(k);
        case 's':
          return k = new Sk.builtin.StringPy(e), h ? Sk.builtin.stringToJs(k).substr(0, h) : Sk.ffi.remapToJs(k);
        case '%':
          return '%';
        }
      });
    return Sk.builtin.stringToPy(c);
  };
  Sk.builtin.tuple = function (a) {
    if (!(this instanceof Sk.builtin.tuple))
      return new Sk.builtin.tuple(a);
    void 0 === a && (a = []);
    if ('[object Array]' === Object.prototype.toString.apply(a))
      this.v = a;
    else if (a.tp$iter) {
      this.v = [];
      a = a.tp$iter();
      for (var b = a.tp$iternext(); void 0 !== b; b = a.tp$iternext())
        this.v.push(b);
    } else
      throw new Sk.builtin.ValueError('expecting Array or iterable');
    this.__class__ = Sk.builtin.tuple;
    this.v = this.v;
    return this;
  };
  Sk.builtin.tuple.prototype.tp$name = 'tuple';
  Sk.builtin.tuple.prototype.tp$str = function () {
    if (0 === this.v.length)
      return Sk.builtin.stringToPy('()');
    for (var a = [], b = 0; b < this.v.length; ++b)
      a[b] = Sk.ffi.remapToJs(Sk.ffh.str(this.v[b]));
    a = a.join(', ');
    1 === this.v.length && (a += ',');
    return Sk.builtin.stringToPy('(' + a + ')');
  };
  Sk.builtin.tuple.prototype.tp$repr = function () {
    if (0 === this.v.length)
      return Sk.builtin.stringToPy('()');
    for (var a = [], b = 0; b < this.v.length; ++b)
      a[b] = Sk.misceval.objectRepr(this.v[b]).v;
    a = a.join(', ');
    1 === this.v.length && (a += ',');
    return Sk.builtin.stringToPy('(' + a + ')');
  };
  Sk.builtin.tuple.prototype.mp$subscript = function (a) {
    if (Sk.misceval.isIndex(a)) {
      var b = Sk.misceval.asIndex(a);
      if (void 0 !== b) {
        0 > b && (b = this.v.length + b);
        if (0 > b || b >= this.v.length)
          throw new Sk.builtin.IndexError('tuple index out of range');
        return this.v[b];
      }
    } else if (a instanceof Sk.builtin.slice) {
      var c = [];
      a.sssiter$(this, function (a, b) {
        c.push(b.v[a]);
      });
      return new Sk.builtin.tuple(c);
    }
    throw new Sk.builtin.TypeError('tuple indices must be integers, not ' + Sk.ffi.typeName(a));
  };
  Sk.builtin.tuple.prototype.tp$hash = function () {
    for (var a = 1000003, b = 3430008, c = this.v.length, d = 0; d < c; ++d) {
      var e = Sk.builtin.hash(this.v[d]);
      if (-1 === e)
        return -1;
      b = (b ^ e) * a;
      a += 82520 + c + c;
    }
    b += 97531;
    -1 === b && (b = -2);
    return b;
  };
  Sk.builtin.tuple.prototype.sq$repeat = function (a) {
    a = Sk.builtin.asnum$(a);
    for (var b = [], c = 0; c < a; ++c)
      for (var d = 0; d < this.v.length; ++d)
        b.push(this.v[d]);
    return new Sk.builtin.tuple(b);
  };
  Sk.builtin.tuple.prototype.nb$mul = Sk.builtin.tuple.prototype.sq$repeat;
  Sk.builtin.tuple.prototype.nb$inplace_multiply = Sk.builtin.tuple.prototype.sq$repeat;
  Sk.builtin.tuple.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj('tuple', Sk.builtin.tuple);
  Sk.builtin.tuple.prototype.tp$iter = function () {
    var a = {
        tp$iter: function () {
          return a;
        },
        $obj: this,
        $index: 0,
        tp$iternext: function () {
          return a.$index >= a.$obj.v.length ? void 0 : a.$obj.v[a.$index++];
        }
      };
    return a;
  };
  Sk.builtin.tuple.prototype.__iter__ = new Sk.builtin.func(function (a) {
    Sk.builtin.pyCheckArgs('__iter__', arguments, 1, 1);
    return a.tp$iter();
  });
  Sk.builtin.tuple.prototype.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;
  Sk.builtin.tuple.prototype.tp$richcompare = function (a, b) {
    if (!a.__class__ || a.__class__ != Sk.builtin.tuple)
      return b === Sk.misceval.compareOp.Eq ? !1 : b === Sk.misceval.compareOp.NotEq ? !0 : !1;
    var c = this.v;
    a = a.v;
    var d = c.length, e = a.length, f;
    for (f = 0; f < d && f < e && Sk.misceval.richCompareBool(c[f], a[f], Sk.misceval.compareOp.Eq); ++f);
    if (f >= d || f >= e)
      switch (b) {
      case Sk.misceval.compareOp.Lt:
        return d < e;
      case 'LtE':
        return d <= e;
      case Sk.misceval.compareOp.Eq:
        return d === e;
      case Sk.misceval.compareOp.NotEq:
        return d !== e;
      case Sk.misceval.compareOp.Gt:
        return d > e;
      case Sk.misceval.compareOp.GtE:
        return d >= e;
      default:
        goog.asserts.fail();
      }
    return b === Sk.misceval.compareOp.Eq ? !1 : b === Sk.misceval.compareOp.NotEq ? !0 : Sk.misceval.richCompareBool(c[f], a[f], b);
  };
  Sk.builtin.tuple.prototype.sq$concat = function (a) {
    return new Sk.builtin.tuple(this.v.concat(a.v));
  };
  Sk.builtin.tuple.prototype.nb$add = Sk.builtin.tuple.prototype.sq$concat;
  Sk.builtin.tuple.prototype.nb$inplace_add = Sk.builtin.tuple.prototype.sq$concat;
  Sk.builtin.tuple.prototype.sq$length = function () {
    return this.v.length;
  };
  Sk.builtin.tuple.prototype.index = new Sk.builtin.func(function (a, b) {
    for (var c = a.v.length, d = a.v, e = 0; e < c; ++e)
      if (Sk.misceval.richCompareBool(d[e], b, Sk.misceval.compareOp.Eq))
        return e;
    throw new Sk.builtin.ValueError('tuple.index(x): x not in tuple');
  });
  Sk.builtin.tuple.prototype.count = new Sk.builtin.func(function (a, b) {
    for (var c = a.v.length, d = a.v, e = 0, f = 0; f < c; ++f)
      Sk.misceval.richCompareBool(d[f], b, Sk.misceval.compareOp.Eq) && (e += 1);
    return e;
  });
  goog.exportSymbol('Sk.builtin.tuple', Sk.builtin.tuple);
  Sk.builtin.dict = function (a) {
    if (!(this instanceof Sk.builtin.dict))
      return new Sk.builtin.dict(a);
    void 0 === a && (a = []);
    this.size = 0;
    if ('[object Array]' === Object.prototype.toString.apply(a))
      for (var b = 0; b < a.length; b += 2)
        this.mp$ass_subscript(a[b], a[b + 1]);
    else if (a instanceof Sk.builtin.dict)
      for (var c = a.tp$iter(), b = c.tp$iternext(); void 0 !== b; b = c.tp$iternext()) {
        var d = a.mp$subscript(b);
        void 0 === d ? this.mp$ass_subscript(b, Sk.builtin.none.none$) : this.mp$ass_subscript(b, d);
      }
    else if (a.tp$iter)
      for (c = a.tp$iter(), b = c.tp$iternext(); void 0 !== b; b = c.tp$iternext())
        if (b.mp$subscript)
          this.mp$ass_subscript(b.mp$subscript(0), b.mp$subscript(1));
        else
          throw new Sk.builtin.TypeError('element ' + this.size + ' is not a sequence');
    else
      throw new Sk.builtin.TypeError('object is not iterable');
    this.__class__ = Sk.builtin.dict;
    return this;
  };
  Sk.builtin.dict.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj('dict', Sk.builtin.dict);
  var kf = Sk.builtin.hash;
  Sk.builtin.dict.prototype.key$lookup = function (a, b) {
    for (var c = 0; c < a.items.length; c++) {
      var d = a.items[c];
      if (Sk.misceval.richCompareBool(d.lhs, b, Sk.misceval.compareOp.Eq))
        return d;
    }
  };
  Sk.builtin.dict.prototype.key$pop = function (a, b) {
    var c, d, e;
    for (e = 0; e < a.items.length; e++)
      if (c = a.items[e], d = Sk.misceval.richCompareBool(c.lhs, b, Sk.misceval.compareOp.Eq))
        return a.items.splice(e, 1), this.size -= 1, c;
  };
  Sk.builtin.dict.prototype.mp$lookup = function (a) {
    var b = this[kf(a)];
    if (void 0 !== b && (a = this.key$lookup(b, a)))
      return a.rhs;
  };
  Sk.builtin.dict.prototype.mp$subscript = function (a) {
    var b = this.mp$lookup(a);
    if (void 0 !== b)
      return b;
    throw new Sk.builtin.KeyError(Sk.ffi.remapToJs(Sk.ffh.str(a)));
  };
  Sk.builtin.dict.prototype.sq$contains = function (a) {
    return void 0 !== this.mp$lookup(a);
  };
  Sk.builtin.dict.prototype.mp$ass_subscript = function (a, b) {
    var c = kf(a), d = this[c];
    void 0 === d ? (this[c] = {
      $hash: c,
      items: [{
          lhs: a,
          rhs: b
        }]
    }, this.size += 1) : (c = this.key$lookup(d, a)) ? c.rhs = b : (d.items.push({
      lhs: a,
      rhs: b
    }), this.size += 1);
  };
  Sk.builtin.dict.prototype.mp$del_subscript = function (a) {
    var b = this[kf(a)];
    if (void 0 !== b && (b = this.key$pop(b, a), void 0 !== b))
      return;
    throw new Sk.builtin.KeyError(Sk.ffi.remapToJs(Sk.ffh.str(a)));
  };
  Sk.builtin.dict.prototype.tp$iter = function () {
    var a = [], b;
    for (b in this)
      if (this.hasOwnProperty(b)) {
        var c = this[b];
        if (c && void 0 !== c.$hash)
          for (var d = 0; d < c.items.length; d++)
            a.push(c.items[d].lhs);
      }
    var e = {
        tp$iter: function () {
          return e;
        },
        $obj: this,
        $index: 0,
        $keys: a,
        tp$iternext: function () {
          return e.$index >= e.$keys.length ? void 0 : e.$keys[e.$index++];
        }
      };
    return e;
  };
  Sk.builtin.dict.prototype.__iter__ = new Sk.builtin.func(function (a) {
    Sk.builtin.pyCheckArgs('__iter__', arguments, 1, 1);
    return a.tp$iter();
  });
  Sk.builtin.dict.prototype.tp$repr = function () {
    for (var a = [], b = this.tp$iter(), c = b.tp$iternext(); void 0 !== c; c = b.tp$iternext()) {
      var d = Sk.ffi.remapToJs(Sk.misceval.objectRepr(c)), c = this.mp$subscript(c), c = Sk.ffi.remapToJs(Sk.misceval.objectRepr(void 0 !== c ? c : Sk.builtin.none.none$));
      a.push(d + ': ' + c);
    }
    return Sk.builtin.stringToPy('{' + a.join(', ') + '}');
  };
  Sk.builtin.dict.prototype.mp$length = function () {
    return this.size;
  };
  Sk.builtin.dict.prototype.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;
  Sk.builtin.dict.prototype.tp$hash = Sk.builtin.object.prototype.HashNotImplemented;
  Sk.builtin.dict.prototype.tp$richcompare = function (a, b) {
    if (this === a && Sk.misceval.opAllowsEquality(b))
      return !0;
    switch (b) {
    case Sk.misceval.compareOp.Lt:
      return;
    case Sk.misceval.compareOp.LtE:
      return;
    case Sk.misceval.compareOp.Eq:
      break;
    case Sk.misceval.compareOp.NotEq:
      break;
    case Sk.misceval.compareOp.Gt:
      return;
    case Sk.misceval.compareOp.GtE:
      return;
    default:
      goog.asserts.fail();
    }
    if (!(a instanceof Sk.builtin.dict) || this.size !== a.size)
      return b === Sk.misceval.compareOp.Eq ? !1 : !0;
    for (var c = this.tp$iter(), d = c.tp$iternext(); void 0 !== d; d = c.tp$iternext()) {
      var e = this.mp$subscript(d), d = a.mp$subscript(d);
      if (!Sk.misceval.richCompareBool(e, d, Sk.misceval.compareOp.Eq))
        return b === Sk.misceval.compareOp.Eq ? !1 : !0;
    }
    return b === Sk.misceval.compareOp.Eq ? !0 : !1;
  };
  Sk.builtin.dict.prototype.get = new Sk.builtin.func(function (a, b, c) {
    a = a.mp$lookup(b);
    return void 0 === a ? void 0 === c ? Sk.builtin.none.none$ : c : a;
  });
  Sk.builtin.dict.prototype.has_key = new Sk.builtin.func(function (a, b) {
    return Sk.ffi.booleanToPy(a.sq$contains(b));
  });
  Sk.builtin.dict.prototype.items = new Sk.builtin.func(function (a) {
    for (var b = [], c = a.tp$iter(), d = c.tp$iternext(); void 0 !== d; d = c.tp$iternext()) {
      var e = a.mp$subscript(d);
      void 0 === e ? b.push(new Sk.builtin.tuple([
        d,
        Sk.builtin.none.none$
      ])) : b.push(new Sk.builtin.tuple([
        d,
        e
      ]));
    }
    return new Sk.builtin.list(b);
  });
  Sk.builtin.dict.prototype.keys = new Sk.builtin.func(function (a) {
    var b = [];
    a = a.tp$iter();
    for (var c = a.tp$iternext(); void 0 !== c; c = a.tp$iternext())
      b.push(c);
    return new Sk.builtin.list(b);
  });
  Sk.builtin.dict.prototype.values = new Sk.builtin.func(function (a) {
    for (var b = [], c = a.tp$iter(), d = c.tp$iternext(); void 0 !== d; d = c.tp$iternext())
      d = a.mp$subscript(d), void 0 === d ? b.push(Sk.builtin.none.none$) : b.push(d);
    return new Sk.builtin.list(b);
  });
  Sk.builtin.dict.prototype.tp$name = 'dict';
  goog.exportSymbol('Sk.builtin.dict', Sk.builtin.dict);
  Sk.builtin.biginteger = function (a, b, c) {
    null != a && ('number' == typeof a ? this.fromNumber(a, b, c) : null == b && 'string' != typeof a ? this.fromString(a, 256) : this.fromString(a, b));
  };
  Sk.builtin.biginteger.canary = 244837814094590;
  Sk.builtin.biginteger.j_lm = 15715070 == (Sk.builtin.biginteger.canary & 16777215);
  Sk.builtin.biginteger.nbi = function () {
    return new Sk.builtin.biginteger(null);
  };
  Sk.builtin.biginteger.prototype.am1 = function (a, b, c, d, e, f) {
    for (; 0 <= --f;) {
      var g = b * this[a++] + c[d] + e;
      e = Math.floor(g / 67108864);
      c[d++] = g & 67108863;
    }
    return e;
  };
  Sk.builtin.biginteger.prototype.am2 = function (a, b, c, d, e, f) {
    var g = b & 32767;
    for (b >>= 15; 0 <= --f;) {
      var h = this[a] & 32767, l = this[a++] >> 15, k = b * h + l * g, h = g * h + ((k & 32767) << 15) + c[d] + (e & 1073741823);
      e = (h >>> 30) + (k >>> 15) + b * l + (e >>> 30);
      c[d++] = h & 1073741823;
    }
    return e;
  };
  Sk.builtin.biginteger.prototype.am3 = function (a, b, c, d, e, f) {
    var g = b & 16383;
    for (b >>= 14; 0 <= --f;) {
      var h = this[a] & 16383, l = this[a++] >> 14, k = b * h + l * g, h = g * h + ((k & 16383) << 14) + c[d] + e;
      e = (h >> 28) + (k >> 14) + b * l;
      c[d++] = h & 268435455;
    }
    return e;
  };
  Sk.builtin.biginteger.prototype.am = Sk.builtin.biginteger.prototype.am3;
  Sk.builtin.biginteger.dbits = 28;
  Sk.builtin.biginteger.prototype.DB = Sk.builtin.biginteger.dbits;
  Sk.builtin.biginteger.prototype.DM = (1 << Sk.builtin.biginteger.dbits) - 1;
  Sk.builtin.biginteger.prototype.DV = 1 << Sk.builtin.biginteger.dbits;
  Sk.builtin.biginteger.BI_FP = 52;
  Sk.builtin.biginteger.prototype.FV = Math.pow(2, Sk.builtin.biginteger.BI_FP);
  Sk.builtin.biginteger.prototype.F1 = Sk.builtin.biginteger.BI_FP - Sk.builtin.biginteger.dbits;
  Sk.builtin.biginteger.prototype.F2 = 2 * Sk.builtin.biginteger.dbits - Sk.builtin.biginteger.BI_FP;
  Sk.builtin.biginteger.BI_RM = '0123456789abcdefghijklmnopqrstuvwxyz';
  Sk.builtin.biginteger.BI_RC = [];
  var rr, vv;
  rr = 48;
  for (vv = 0; 9 >= vv; ++vv)
    Sk.builtin.biginteger.BI_RC[rr++] = vv;
  rr = 97;
  for (vv = 10; 36 > vv; ++vv)
    Sk.builtin.biginteger.BI_RC[rr++] = vv;
  rr = 65;
  for (vv = 10; 36 > vv; ++vv)
    Sk.builtin.biginteger.BI_RC[rr++] = vv;
  Sk.builtin.biginteger.int2char = function (a) {
    return Sk.builtin.biginteger.BI_RM.charAt(a);
  };
  Sk.builtin.biginteger.intAt = function (a, b) {
    var c = Sk.builtin.biginteger.BI_RC[a.charCodeAt(b)];
    return null == c ? -1 : c;
  };
  Sk.builtin.biginteger.prototype.bnpCopyTo = function (a) {
    for (var b = this.t - 1; 0 <= b; --b)
      a[b] = this[b];
    a.t = this.t;
    a.s = this.s;
  };
  Sk.builtin.biginteger.prototype.bnpFromInt = function (a) {
    this.t = 1;
    this.s = 0 > a ? -1 : 0;
    0 < a ? this[0] = a : -1 > a ? this[0] = a + this.DV : this.t = 0;
  };
  Sk.builtin.biginteger.nbv = function (a) {
    var b = new Sk.builtin.biginteger(null);
    b.bnpFromInt(a);
    return b;
  };
  Sk.builtin.biginteger.prototype.bnpFromString = function (a, b) {
    var c;
    if (16 == b)
      c = 4;
    else if (8 == b)
      c = 3;
    else if (256 == b)
      c = 8;
    else if (2 == b)
      c = 1;
    else if (32 == b)
      c = 5;
    else if (4 == b)
      c = 2;
    else {
      this.fromRadix(a, b);
      return;
    }
    this.s = this.t = 0;
    for (var d = a.length, e = !1, f = 0; 0 <= --d;) {
      var g = 8 == c ? a[d] & 255 : Sk.builtin.biginteger.intAt(a, d);
      0 > g ? '-' == a.charAt(d) && (e = !0) : (e = !1, 0 == f ? this[this.t++] = g : f + c > this.DB ? (this[this.t - 1] |= (g & (1 << this.DB - f) - 1) << f, this[this.t++] = g >> this.DB - f) : this[this.t - 1] |= g << f, f += c, f >= this.DB && (f -= this.DB));
    }
    8 == c && 0 != (a[0] & 128) && (this.s = -1, 0 < f && (this[this.t - 1] |= (1 << this.DB - f) - 1 << f));
    this.clamp();
    e && Sk.builtin.biginteger.ZERO.subTo(this, this);
  };
  Sk.builtin.biginteger.prototype.bnpClamp = function () {
    for (var a = this.s & this.DM; 0 < this.t && this[this.t - 1] == a;)
      --this.t;
  };
  Sk.builtin.biginteger.prototype.bnToString = function (a) {
    if (0 > this.s)
      return '-' + this.negate().toString(a);
    if (16 == a)
      a = 4;
    else if (8 == a)
      a = 3;
    else if (2 == a)
      a = 1;
    else if (32 == a)
      a = 5;
    else if (4 == a)
      a = 2;
    else
      return this.toRadix(a);
    var b = (1 << a) - 1, c, d = !1, e = '', f = this.t, g = this.DB - f * this.DB % a;
    if (0 < f--)
      for (g < this.DB && 0 < (c = this[f] >> g) && (d = !0, e = Sk.builtin.biginteger.int2char(c)); 0 <= f;)
        g < a ? (c = (this[f] & (1 << g) - 1) << a - g, c |= this[--f] >> (g += this.DB - a)) : (c = this[f] >> (g -= a) & b, 0 >= g && (g += this.DB, --f)), 0 < c && (d = !0), d && (e += Sk.builtin.biginteger.int2char(c));
    return d ? e : '0';
  };
  Sk.builtin.biginteger.prototype.bnNegate = function () {
    var a = Sk.builtin.biginteger.nbi();
    Sk.builtin.biginteger.ZERO.subTo(this, a);
    return a;
  };
  Sk.builtin.biginteger.prototype.bnAbs = function () {
    return 0 > this.s ? this.negate() : this;
  };
  Sk.builtin.biginteger.prototype.bnCompareTo = function (a) {
    var b = this.s - a.s;
    if (0 != b)
      return b;
    var c = this.t, b = c - a.t;
    if (0 != b)
      return 0 > this.s ? -b : b;
    for (; 0 <= --c;)
      if (0 != (b = this[c] - a[c]))
        return b;
    return 0;
  };
  Sk.builtin.biginteger.nbits = function (a) {
    var b = 1, c;
    0 != (c = a >>> 16) && (a = c, b += 16);
    0 != (c = a >> 8) && (a = c, b += 8);
    0 != (c = a >> 4) && (a = c, b += 4);
    0 != (c = a >> 2) && (a = c, b += 2);
    0 != a >> 1 && (b += 1);
    return b;
  };
  Sk.builtin.biginteger.prototype.bnBitLength = function () {
    return 0 >= this.t ? 0 : this.DB * (this.t - 1) + Sk.builtin.biginteger.nbits(this[this.t - 1] ^ this.s & this.DM);
  };
  Sk.builtin.biginteger.prototype.bnpDLShiftTo = function (a, b) {
    var c;
    for (c = this.t - 1; 0 <= c; --c)
      b[c + a] = this[c];
    for (c = a - 1; 0 <= c; --c)
      b[c] = 0;
    b.t = this.t + a;
    b.s = this.s;
  };
  Sk.builtin.biginteger.prototype.bnpDRShiftTo = function (a, b) {
    for (var c = a; c < this.t; ++c)
      b[c - a] = this[c];
    b.t = Math.max(this.t - a, 0);
    b.s = this.s;
  };
  Sk.builtin.biginteger.prototype.bnpLShiftTo = function (a, b) {
    var c = a % this.DB, d = this.DB - c, e = (1 << d) - 1, f = Math.floor(a / this.DB), g = this.s << c & this.DM, h;
    for (h = this.t - 1; 0 <= h; --h)
      b[h + f + 1] = this[h] >> d | g, g = (this[h] & e) << c;
    for (h = f - 1; 0 <= h; --h)
      b[h] = 0;
    b[f] = g;
    b.t = this.t + f + 1;
    b.s = this.s;
    b.clamp();
  };
  Sk.builtin.biginteger.prototype.bnpRShiftTo = function (a, b) {
    b.s = this.s;
    var c = Math.floor(a / this.DB);
    if (c >= this.t)
      b.t = 0;
    else {
      var d = a % this.DB, e = this.DB - d, f = (1 << d) - 1;
      b[0] = this[c] >> d;
      for (var g = c + 1; g < this.t; ++g)
        b[g - c - 1] |= (this[g] & f) << e, b[g - c] = this[g] >> d;
      0 < d && (b[this.t - c - 1] |= (this.s & f) << e);
      b.t = this.t - c;
      b.clamp();
    }
  };
  Sk.builtin.biginteger.prototype.bnpSubTo = function (a, b) {
    for (var c = 0, d = 0, e = Math.min(a.t, this.t); c < e;)
      d += this[c] - a[c], b[c++] = d & this.DM, d >>= this.DB;
    if (a.t < this.t) {
      for (d -= a.s; c < this.t;)
        d += this[c], b[c++] = d & this.DM, d >>= this.DB;
      d += this.s;
    } else {
      for (d += this.s; c < a.t;)
        d -= a[c], b[c++] = d & this.DM, d >>= this.DB;
      d -= a.s;
    }
    b.s = 0 > d ? -1 : 0;
    -1 > d ? b[c++] = this.DV + d : 0 < d && (b[c++] = d);
    b.t = c;
    b.clamp();
  };
  Sk.builtin.biginteger.prototype.bnpMultiplyTo = function (a, b) {
    var c = this.abs(), d = a.abs(), e = c.t;
    for (b.t = e + d.t; 0 <= --e;)
      b[e] = 0;
    for (e = 0; e < d.t; ++e)
      b[e + c.t] = c.am(0, d[e], b, e, 0, c.t);
    b.s = 0;
    b.clamp();
    this.s != a.s && Sk.builtin.biginteger.ZERO.subTo(b, b);
  };
  Sk.builtin.biginteger.prototype.bnpSquareTo = function (a) {
    for (var b = this.abs(), c = a.t = 2 * b.t; 0 <= --c;)
      a[c] = 0;
    for (c = 0; c < b.t - 1; ++c) {
      var d = b.am(c, b[c], a, 2 * c, 0, 1);
      (a[c + b.t] += b.am(c + 1, 2 * b[c], a, 2 * c + 1, d, b.t - c - 1)) >= b.DV && (a[c + b.t] -= b.DV, a[c + b.t + 1] = 1);
    }
    0 < a.t && (a[a.t - 1] += b.am(c, b[c], a, 2 * c, 0, 1));
    a.s = 0;
    a.clamp();
  };
  Sk.builtin.biginteger.prototype.bnpDivRemTo = function (a, b, c) {
    var d = a.abs();
    if (!(0 >= d.t)) {
      var e = this.abs();
      if (e.t < d.t)
        null != b && b.fromInt(0), null != c && this.copyTo(c);
      else {
        null == c && (c = Sk.builtin.biginteger.nbi());
        var f = Sk.builtin.biginteger.nbi(), g = this.s;
        a = a.s;
        var h = this.DB - Sk.builtin.biginteger.nbits(d[d.t - 1]);
        0 < h ? (d.lShiftTo(h, f), e.lShiftTo(h, c)) : (d.copyTo(f), e.copyTo(c));
        d = f.t;
        e = f[d - 1];
        if (0 != e) {
          var l = e * (1 << this.F1) + (1 < d ? f[d - 2] >> this.F2 : 0), k = this.FV / l, l = (1 << this.F1) / l, m = 1 << this.F2, p = c.t, n = p - d, q = null == b ? Sk.builtin.biginteger.nbi() : b;
          f.dlShiftTo(n, q);
          0 <= c.compareTo(q) && (c[c.t++] = 1, c.subTo(q, c));
          Sk.builtin.biginteger.ONE.dlShiftTo(d, q);
          for (q.subTo(f, f); f.t < d;)
            f[f.t++] = 0;
          for (; 0 <= --n;) {
            var x = c[--p] == e ? this.DM : Math.floor(c[p] * k + (c[p - 1] + m) * l);
            if ((c[p] += f.am(0, x, c, n, 0, d)) < x)
              for (f.dlShiftTo(n, q), c.subTo(q, c); c[p] < --x;)
                c.subTo(q, c);
          }
          null != b && (c.drShiftTo(d, b), g != a && Sk.builtin.biginteger.ZERO.subTo(b, b));
          c.t = d;
          c.clamp();
          0 < h && c.rShiftTo(h, c);
          0 > g && Sk.builtin.biginteger.ZERO.subTo(c, c);
        }
      }
    }
  };
  Sk.builtin.biginteger.prototype.bnMod = function (a) {
    var b = Sk.builtin.biginteger.nbi();
    this.abs().divRemTo(a, null, b);
    0 > this.s && 0 < b.compareTo(Sk.builtin.biginteger.ZERO) && a.subTo(b, b);
    return b;
  };
  Sk.builtin.biginteger.Classic = function (a) {
    this.m = a;
  };
  Sk.builtin.biginteger.prototype.cConvert = function (a) {
    return 0 > a.s || 0 <= a.compareTo(this.m) ? a.mod(this.m) : a;
  };
  Sk.builtin.biginteger.prototype.cRevert = function (a) {
    return a;
  };
  Sk.builtin.biginteger.prototype.cReduce = function (a) {
    a.divRemTo(this.m, null, a);
  };
  Sk.builtin.biginteger.prototype.cMulTo = function (a, b, c) {
    a.multiplyTo(b, c);
    this.reduce(c);
  };
  Sk.builtin.biginteger.prototype.cSqrTo = function (a, b) {
    a.squareTo(b);
    this.reduce(b);
  };
  Sk.builtin.biginteger.Classic.prototype.convert = Sk.builtin.biginteger.prototype.cConvert;
  Sk.builtin.biginteger.Classic.prototype.revert = Sk.builtin.biginteger.prototype.cRevert;
  Sk.builtin.biginteger.Classic.prototype.reduce = Sk.builtin.biginteger.prototype.cReduce;
  Sk.builtin.biginteger.Classic.prototype.mulTo = Sk.builtin.biginteger.prototype.cMulTo;
  Sk.builtin.biginteger.Classic.prototype.sqrTo = Sk.builtin.biginteger.prototype.cSqrTo;
  Sk.builtin.biginteger.prototype.bnpInvDigit = function () {
    if (1 > this.t)
      return 0;
    var a = this[0];
    if (0 == (a & 1))
      return 0;
    var b = a & 3, b = b * (2 - (a & 15) * b) & 15, b = b * (2 - (a & 255) * b) & 255, b = b * (2 - ((a & 65535) * b & 65535)) & 65535, b = b * (2 - a * b % this.DV) % this.DV;
    return 0 < b ? this.DV - b : -b;
  };
  Sk.builtin.biginteger.Montgomery = function (a) {
    this.m = a;
    this.mp = a.invDigit();
    this.mpl = this.mp & 32767;
    this.mph = this.mp >> 15;
    this.um = (1 << a.DB - 15) - 1;
    this.mt2 = 2 * a.t;
  };
  Sk.builtin.biginteger.prototype.montConvert = function (a) {
    var b = Sk.builtin.biginteger.nbi();
    a.abs().dlShiftTo(this.m.t, b);
    b.divRemTo(this.m, null, b);
    0 > a.s && 0 < b.compareTo(Sk.builtin.biginteger.ZERO) && this.m.subTo(b, b);
    return b;
  };
  Sk.builtin.biginteger.prototype.montRevert = function (a) {
    var b = Sk.builtin.biginteger.nbi();
    a.copyTo(b);
    this.reduce(b);
    return b;
  };
  Sk.builtin.biginteger.prototype.montReduce = function (a) {
    for (; a.t <= this.mt2;)
      a[a.t++] = 0;
    for (var b = 0; b < this.m.t; ++b) {
      var c = a[b] & 32767, d = c * this.mpl + ((c * this.mph + (a[b] >> 15) * this.mpl & this.um) << 15) & a.DM, c = b + this.m.t;
      for (a[c] += this.m.am(0, d, a, b, 0, this.m.t); a[c] >= a.DV;)
        a[c] -= a.DV, a[++c]++;
    }
    a.clamp();
    a.drShiftTo(this.m.t, a);
    0 <= a.compareTo(this.m) && a.subTo(this.m, a);
  };
  Sk.builtin.biginteger.prototype.montSqrTo = function (a, b) {
    a.squareTo(b);
    this.reduce(b);
  };
  Sk.builtin.biginteger.prototype.montMulTo = function (a, b, c) {
    a.multiplyTo(b, c);
    this.reduce(c);
  };
  Sk.builtin.biginteger.Montgomery.prototype.convert = Sk.builtin.biginteger.prototype.montConvert;
  Sk.builtin.biginteger.Montgomery.prototype.revert = Sk.builtin.biginteger.prototype.montRevert;
  Sk.builtin.biginteger.Montgomery.prototype.reduce = Sk.builtin.biginteger.prototype.montReduce;
  Sk.builtin.biginteger.Montgomery.prototype.mulTo = Sk.builtin.biginteger.prototype.montMulTo;
  Sk.builtin.biginteger.Montgomery.prototype.sqrTo = Sk.builtin.biginteger.prototype.montSqrTo;
  Sk.builtin.biginteger.prototype.bnpIsEven = function () {
    return 0 == (0 < this.t ? this[0] & 1 : this.s);
  };
  Sk.builtin.biginteger.prototype.bnpExp = function (a, b) {
    if (4294967295 < a || 1 > a)
      return Sk.builtin.biginteger.ONE;
    var c = Sk.builtin.biginteger.nbi(), d = Sk.builtin.biginteger.nbi(), e = b.convert(this), f = Sk.builtin.biginteger.nbits(a) - 1;
    for (e.copyTo(c); 0 <= --f;)
      if (b.sqrTo(c, d), 0 < (a & 1 << f))
        b.mulTo(d, e, c);
      else
        var g = c, c = d, d = g;
    return b.revert(c);
  };
  Sk.builtin.biginteger.prototype.bnModPowInt = function (a, b) {
    var c;
    c = 256 > a || b.isEven() ? new Sk.builtin.biginteger.Classic(b) : new Sk.builtin.biginteger.Montgomery(b);
    return this.exp(a, c);
  };
  Sk.builtin.biginteger.prototype.copyTo = Sk.builtin.biginteger.prototype.bnpCopyTo;
  Sk.builtin.biginteger.prototype.fromInt = Sk.builtin.biginteger.prototype.bnpFromInt;
  Sk.builtin.biginteger.prototype.fromString = Sk.builtin.biginteger.prototype.bnpFromString;
  Sk.builtin.biginteger.prototype.clamp = Sk.builtin.biginteger.prototype.bnpClamp;
  Sk.builtin.biginteger.prototype.dlShiftTo = Sk.builtin.biginteger.prototype.bnpDLShiftTo;
  Sk.builtin.biginteger.prototype.drShiftTo = Sk.builtin.biginteger.prototype.bnpDRShiftTo;
  Sk.builtin.biginteger.prototype.lShiftTo = Sk.builtin.biginteger.prototype.bnpLShiftTo;
  Sk.builtin.biginteger.prototype.rShiftTo = Sk.builtin.biginteger.prototype.bnpRShiftTo;
  Sk.builtin.biginteger.prototype.subTo = Sk.builtin.biginteger.prototype.bnpSubTo;
  Sk.builtin.biginteger.prototype.multiplyTo = Sk.builtin.biginteger.prototype.bnpMultiplyTo;
  Sk.builtin.biginteger.prototype.squareTo = Sk.builtin.biginteger.prototype.bnpSquareTo;
  Sk.builtin.biginteger.prototype.divRemTo = Sk.builtin.biginteger.prototype.bnpDivRemTo;
  Sk.builtin.biginteger.prototype.invDigit = Sk.builtin.biginteger.prototype.bnpInvDigit;
  Sk.builtin.biginteger.prototype.isEven = Sk.builtin.biginteger.prototype.bnpIsEven;
  Sk.builtin.biginteger.prototype.exp = Sk.builtin.biginteger.prototype.bnpExp;
  Sk.builtin.biginteger.prototype.toString = Sk.builtin.biginteger.prototype.bnToString;
  Sk.builtin.biginteger.prototype.negate = Sk.builtin.biginteger.prototype.bnNegate;
  Sk.builtin.biginteger.prototype.abs = Sk.builtin.biginteger.prototype.bnAbs;
  Sk.builtin.biginteger.prototype.compareTo = Sk.builtin.biginteger.prototype.bnCompareTo;
  Sk.builtin.biginteger.prototype.bitLength = Sk.builtin.biginteger.prototype.bnBitLength;
  Sk.builtin.biginteger.prototype.mod = Sk.builtin.biginteger.prototype.bnMod;
  Sk.builtin.biginteger.prototype.modPowInt = Sk.builtin.biginteger.prototype.bnModPowInt;
  Sk.builtin.biginteger.ZERO = Sk.builtin.biginteger.nbv(0);
  Sk.builtin.biginteger.ONE = Sk.builtin.biginteger.nbv(1);
  Sk.builtin.biginteger.prototype.bnClone = function () {
    var a = Sk.builtin.biginteger.nbi();
    this.copyTo(a);
    return a;
  };
  Sk.builtin.biginteger.prototype.bnIntValue = function () {
    if (0 > this.s) {
      if (1 == this.t)
        return this[0] - this.DV;
      if (0 == this.t)
        return -1;
    } else {
      if (1 == this.t)
        return this[0];
      if (0 == this.t)
        return 0;
    }
    return (this[1] & (1 << 32 - this.DB) - 1) << this.DB | this[0];
  };
  Sk.builtin.biginteger.prototype.bnByteValue = function () {
    return 0 == this.t ? this.s : this[0] << 24 >> 24;
  };
  Sk.builtin.biginteger.prototype.bnShortValue = function () {
    return 0 == this.t ? this.s : this[0] << 16 >> 16;
  };
  Sk.builtin.biginteger.prototype.bnpChunkSize = function (a) {
    return Math.floor(Math.LN2 * this.DB / Math.log(a));
  };
  Sk.builtin.biginteger.prototype.bnSigNum = function () {
    return 0 > this.s ? -1 : 0 >= this.t || 1 == this.t && 0 >= this[0] ? 0 : 1;
  };
  Sk.builtin.biginteger.prototype.bnpToRadix = function (a) {
    null == a && (a = 10);
    if (0 == this.signum() || 2 > a || 36 < a)
      return '0';
    var b = this.chunkSize(a), b = Math.pow(a, b), c = Sk.builtin.biginteger.nbv(b), d = Sk.builtin.biginteger.nbi(), e = Sk.builtin.biginteger.nbi(), f = '';
    for (this.divRemTo(c, d, e); 0 < d.signum();)
      f = (b + e.intValue()).toString(a).substr(1) + f, d.divRemTo(c, d, e);
    return e.intValue().toString(a) + f;
  };
  Sk.builtin.biginteger.prototype.bnpFromRadix = function (a, b) {
    this.fromInt(0);
    null == b && (b = 10);
    for (var c = this.chunkSize(b), d = Math.pow(b, c), e = !1, f = 0, g = 0, h = 0; h < a.length; ++h) {
      var l = Sk.builtin.biginteger.intAt(a, h);
      if (0 > l) {
        if ('-' == a.charAt(h) && 0 == this.signum() && (e = !0), '.' == a.charAt(h))
          break;
      } else
        g = b * g + l, ++f >= c && (this.dMultiply(d), this.dAddOffset(g, 0), g = f = 0);
    }
    0 < f && (this.dMultiply(Math.pow(b, f)), this.dAddOffset(g, 0));
    e && Sk.builtin.biginteger.ZERO.subTo(this, this);
  };
  Sk.builtin.biginteger.prototype.bnpFromNumber = function (a, b, c) {
    if ('number' == typeof b)
      if (2 > a)
        this.fromInt(1);
      else
        for (this.fromNumber(a, c), this.testBit(a - 1) || this.bitwiseTo(Sk.builtin.biginteger.ONE.shiftLeft(a - 1), Sk.builtin.biginteger.op_or, this), this.isEven() && this.dAddOffset(1, 0); !this.isProbablePrime(b);)
          this.dAddOffset(2, 0), this.bitLength() > a && this.subTo(Sk.builtin.biginteger.ONE.shiftLeft(a - 1), this);
    this.fromString(a + '');
  };
  Sk.builtin.biginteger.prototype.bnToByteArray = function () {
    var a = this.t, b = [];
    b[0] = this.s;
    var c = this.DB - a * this.DB % 8, d, e = 0;
    if (0 < a--)
      for (c < this.DB && (d = this[a] >> c) != (this.s & this.DM) >> c && (b[e++] = d | this.s << this.DB - c); 0 <= a;)
        if (8 > c ? (d = (this[a] & (1 << c) - 1) << 8 - c, d |= this[--a] >> (c += this.DB - 8)) : (d = this[a] >> (c -= 8) & 255, 0 >= c && (c += this.DB, --a)), 0 != (d & 128) && (d |= -256), 0 == e && (this.s & 128) != (d & 128) && ++e, 0 < e || d != this.s)
          b[e++] = d;
    return b;
  };
  Sk.builtin.biginteger.prototype.bnEquals = function (a) {
    return 0 == this.compareTo(a);
  };
  Sk.builtin.biginteger.prototype.bnMin = function (a) {
    return 0 > this.compareTo(a) ? this : a;
  };
  Sk.builtin.biginteger.prototype.bnMax = function (a) {
    return 0 < this.compareTo(a) ? this : a;
  };
  Sk.builtin.biginteger.prototype.bnpBitwiseTo = function (a, b, c) {
    var d, e, f = Math.min(a.t, this.t);
    for (d = 0; d < f; ++d)
      c[d] = b(this[d], a[d]);
    if (a.t < this.t) {
      e = a.s & this.DM;
      for (d = f; d < this.t; ++d)
        c[d] = b(this[d], e);
      c.t = this.t;
    } else {
      e = this.s & this.DM;
      for (d = f; d < a.t; ++d)
        c[d] = b(e, a[d]);
      c.t = a.t;
    }
    c.s = b(this.s, a.s);
    c.clamp();
  };
  Sk.builtin.biginteger.op_and = function (a, b) {
    return a & b;
  };
  Sk.builtin.biginteger.prototype.bnAnd = function (a) {
    var b = Sk.builtin.biginteger.nbi();
    this.bitwiseTo(a, Sk.builtin.biginteger.op_and, b);
    return b;
  };
  Sk.builtin.biginteger.op_or = function (a, b) {
    return a | b;
  };
  Sk.builtin.biginteger.prototype.bnOr = function (a) {
    var b = Sk.builtin.biginteger.nbi();
    this.bitwiseTo(a, Sk.builtin.biginteger.op_or, b);
    return b;
  };
  Sk.builtin.biginteger.op_xor = function (a, b) {
    return a ^ b;
  };
  Sk.builtin.biginteger.prototype.bnXor = function (a) {
    var b = Sk.builtin.biginteger.nbi();
    this.bitwiseTo(a, Sk.builtin.biginteger.op_xor, b);
    return b;
  };
  Sk.builtin.biginteger.op_andnot = function (a, b) {
    return a & ~b;
  };
  Sk.builtin.biginteger.prototype.bnAndNot = function (a) {
    var b = Sk.builtin.biginteger.nbi();
    this.bitwiseTo(a, Sk.builtin.biginteger.op_andnot, b);
    return b;
  };
  Sk.builtin.biginteger.prototype.bnNot = function () {
    for (var a = Sk.builtin.biginteger.nbi(), b = 0; b < this.t; ++b)
      a[b] = this.DM & ~this[b];
    a.t = this.t;
    a.s = ~this.s;
    return a;
  };
  Sk.builtin.biginteger.prototype.bnShiftLeft = function (a) {
    var b = Sk.builtin.biginteger.nbi();
    0 > a ? this.rShiftTo(-a, b) : this.lShiftTo(a, b);
    return b;
  };
  Sk.builtin.biginteger.prototype.bnShiftRight = function (a) {
    var b = Sk.builtin.biginteger.nbi();
    0 > a ? this.lShiftTo(-a, b) : this.rShiftTo(a, b);
    return b;
  };
  Sk.builtin.biginteger.lbit = function (a) {
    if (0 == a)
      return -1;
    var b = 0;
    0 == (a & 65535) && (a >>= 16, b += 16);
    0 == (a & 255) && (a >>= 8, b += 8);
    0 == (a & 15) && (a >>= 4, b += 4);
    0 == (a & 3) && (a >>= 2, b += 2);
    0 == (a & 1) && ++b;
    return b;
  };
  Sk.builtin.biginteger.prototype.bnGetLowestSetBit = function () {
    for (var a = 0; a < this.t; ++a)
      if (0 != this[a])
        return a * this.DB + Sk.builtin.biginteger.lbit(this[a]);
    return 0 > this.s ? this.t * this.DB : -1;
  };
  Sk.builtin.biginteger.cbit = function (a) {
    for (var b = 0; 0 != a;)
      a &= a - 1, ++b;
    return b;
  };
  Sk.builtin.biginteger.prototype.bnBitCount = function () {
    for (var a = 0, b = this.s & this.DM, c = 0; c < this.t; ++c)
      a += Sk.builtin.biginteger.cbit(this[c] ^ b);
    return a;
  };
  Sk.builtin.biginteger.prototype.bnTestBit = function (a) {
    var b = Math.floor(a / this.DB);
    return b >= this.t ? 0 != this.s : 0 != (this[b] & 1 << a % this.DB);
  };
  Sk.builtin.biginteger.prototype.bnpChangeBit = function (a, b) {
    var c = Sk.builtin.biginteger.ONE.shiftLeft(a);
    this.bitwiseTo(c, b, c);
    return c;
  };
  Sk.builtin.biginteger.prototype.bnSetBit = function (a) {
    return this.changeBit(a, Sk.builtin.biginteger.op_or);
  };
  Sk.builtin.biginteger.prototype.bnClearBit = function (a) {
    return this.changeBit(a, Sk.builtin.biginteger.op_andnot);
  };
  Sk.builtin.biginteger.prototype.bnFlipBit = function (a) {
    return this.changeBit(a, Sk.builtin.biginteger.op_xor);
  };
  Sk.builtin.biginteger.prototype.bnpAddTo = function (a, b) {
    for (var c = 0, d = 0, e = Math.min(a.t, this.t); c < e;)
      d += this[c] + a[c], b[c++] = d & this.DM, d >>= this.DB;
    if (a.t < this.t) {
      for (d += a.s; c < this.t;)
        d += this[c], b[c++] = d & this.DM, d >>= this.DB;
      d += this.s;
    } else {
      for (d += this.s; c < a.t;)
        d += a[c], b[c++] = d & this.DM, d >>= this.DB;
      d += a.s;
    }
    b.s = 0 > d ? -1 : 0;
    0 < d ? b[c++] = d : -1 > d && (b[c++] = this.DV + d);
    b.t = c;
    b.clamp();
  };
  Sk.builtin.biginteger.prototype.bnAdd = function (a) {
    var b = Sk.builtin.biginteger.nbi();
    this.addTo(a, b);
    return b;
  };
  Sk.builtin.biginteger.prototype.bnSubtract = function (a) {
    var b = Sk.builtin.biginteger.nbi();
    this.subTo(a, b);
    return b;
  };
  Sk.builtin.biginteger.prototype.bnMultiply = function (a) {
    var b = Sk.builtin.biginteger.nbi();
    this.multiplyTo(a, b);
    return b;
  };
  Sk.builtin.biginteger.prototype.bnDivide = function (a) {
    var b = Sk.builtin.biginteger.nbi();
    this.divRemTo(a, b, null);
    return b;
  };
  Sk.builtin.biginteger.prototype.bnRemainder = function (a) {
    var b = Sk.builtin.biginteger.nbi();
    this.divRemTo(a, null, b);
    return b;
  };
  Sk.builtin.biginteger.prototype.bnDivideAndRemainder = function (a) {
    var b = Sk.builtin.biginteger.nbi(), c = Sk.builtin.biginteger.nbi();
    this.divRemTo(a, b, c);
    return [
      b,
      c
    ];
  };
  Sk.builtin.biginteger.prototype.bnpDMultiply = function (a) {
    this[this.t] = this.am(0, a - 1, this, 0, 0, this.t);
    ++this.t;
    this.clamp();
  };
  Sk.builtin.biginteger.prototype.bnpDAddOffset = function (a, b) {
    if (0 != a) {
      for (; this.t <= b;)
        this[this.t++] = 0;
      for (this[b] += a; this[b] >= this.DV;)
        this[b] -= this.DV, ++b >= this.t && (this[this.t++] = 0), ++this[b];
    }
  };
  Sk.builtin.biginteger.NullExp = function () {
  };
  Sk.builtin.biginteger.prototype.nNop = function (a) {
    return a;
  };
  Sk.builtin.biginteger.prototype.nMulTo = function (a, b, c) {
    a.multiplyTo(b, c);
  };
  Sk.builtin.biginteger.prototype.nSqrTo = function (a, b) {
    a.squareTo(b);
  };
  Sk.builtin.biginteger.NullExp.prototype.convert = Sk.builtin.biginteger.prototype.nNop;
  Sk.builtin.biginteger.NullExp.prototype.revert = Sk.builtin.biginteger.prototype.nNop;
  Sk.builtin.biginteger.NullExp.prototype.mulTo = Sk.builtin.biginteger.prototype.nMulTo;
  Sk.builtin.biginteger.NullExp.prototype.sqrTo = Sk.builtin.biginteger.prototype.nSqrTo;
  Sk.builtin.biginteger.prototype.bnPow = function (a) {
    return this.exp(a, new Sk.builtin.biginteger.NullExp());
  };
  Sk.builtin.biginteger.prototype.bnpMultiplyLowerTo = function (a, b, c) {
    var d = Math.min(this.t + a.t, b);
    c.s = 0;
    for (c.t = d; 0 < d;)
      c[--d] = 0;
    var e;
    for (e = c.t - this.t; d < e; ++d)
      c[d + this.t] = this.am(0, a[d], c, d, 0, this.t);
    for (e = Math.min(a.t, b); d < e; ++d)
      this.am(0, a[d], c, d, 0, b - d);
    c.clamp();
  };
  Sk.builtin.biginteger.prototype.bnpMultiplyUpperTo = function (a, b, c) {
    --b;
    var d = c.t = this.t + a.t - b;
    for (c.s = 0; 0 <= --d;)
      c[d] = 0;
    for (d = Math.max(b - this.t, 0); d < a.t; ++d)
      c[this.t + d - b] = this.am(b - d, a[d], c, 0, 0, this.t + d - b);
    c.clamp();
    c.drShiftTo(1, c);
  };
  Sk.builtin.biginteger.Barrett = function (a) {
    this.r2 = Sk.builtin.biginteger.nbi();
    this.q3 = Sk.builtin.biginteger.nbi();
    Sk.builtin.biginteger.ONE.dlShiftTo(2 * a.t, this.r2);
    this.mu = this.r2.divide(a);
    this.m = a;
  };
  Sk.builtin.biginteger.prototype.barrettConvert = function (a) {
    if (0 > a.s || a.t > 2 * this.m.t)
      return a.mod(this.m);
    if (0 > a.compareTo(this.m))
      return a;
    var b = Sk.builtin.biginteger.nbi();
    a.copyTo(b);
    this.reduce(b);
    return b;
  };
  Sk.builtin.biginteger.prototype.barrettRevert = function (a) {
    return a;
  };
  Sk.builtin.biginteger.prototype.barrettReduce = function (a) {
    a.drShiftTo(this.m.t - 1, this.r2);
    a.t > this.m.t + 1 && (a.t = this.m.t + 1, a.clamp());
    this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
    for (this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2); 0 > a.compareTo(this.r2);)
      a.dAddOffset(1, this.m.t + 1);
    for (a.subTo(this.r2, a); 0 <= a.compareTo(this.m);)
      a.subTo(this.m, a);
  };
  Sk.builtin.biginteger.prototype.barrettSqrTo = function (a, b) {
    a.squareTo(b);
    this.reduce(b);
  };
  Sk.builtin.biginteger.prototype.barrettMulTo = function (a, b, c) {
    a.multiplyTo(b, c);
    this.reduce(c);
  };
  Sk.builtin.biginteger.Barrett.prototype.convert = Sk.builtin.biginteger.prototype.barrettConvert;
  Sk.builtin.biginteger.Barrett.prototype.revert = Sk.builtin.biginteger.prototype.barrettRevert;
  Sk.builtin.biginteger.Barrett.prototype.reduce = Sk.builtin.biginteger.prototype.barrettReduce;
  Sk.builtin.biginteger.Barrett.prototype.mulTo = Sk.builtin.biginteger.prototype.barrettMulTo;
  Sk.builtin.biginteger.Barrett.prototype.sqrTo = Sk.builtin.biginteger.prototype.barrettSqrTo;
  Sk.builtin.biginteger.prototype.bnModPow = function (a, b) {
    var c = a.bitLength(), d, e = Sk.builtin.biginteger.nbv(1), f;
    if (0 >= c)
      return e;
    d = 18 > c ? 1 : 48 > c ? 3 : 144 > c ? 4 : 768 > c ? 5 : 6;
    f = 8 > c ? new Sk.builtin.biginteger.Classic(b) : b.isEven() ? new Sk.builtin.biginteger.Barrett(b) : new Sk.builtin.biginteger.Montgomery(b);
    var g = [], h = 3, l = d - 1, k = (1 << d) - 1;
    g[1] = f.convert(this);
    if (1 < d)
      for (c = Sk.builtin.biginteger.nbi(), f.sqrTo(g[1], c); h <= k;)
        g[h] = Sk.builtin.biginteger.nbi(), f.mulTo(c, g[h - 2], g[h]), h += 2;
    for (var m = a.t - 1, p, n = !0, q = Sk.builtin.biginteger.nbi(), c = Sk.builtin.biginteger.nbits(a[m]) - 1; 0 <= m;) {
      c >= l ? p = a[m] >> c - l & k : (p = (a[m] & (1 << c + 1) - 1) << l - c, 0 < m && (p |= a[m - 1] >> this.DB + c - l));
      for (h = d; 0 == (p & 1);)
        p >>= 1, --h;
      0 > (c -= h) && (c += this.DB, --m);
      if (n)
        g[p].copyTo(e), n = !1;
      else {
        for (; 1 < h;)
          f.sqrTo(e, q), f.sqrTo(q, e), h -= 2;
        0 < h ? f.sqrTo(e, q) : (h = e, e = q, q = h);
        f.mulTo(q, g[p], e);
      }
      for (; 0 <= m && 0 == (a[m] & 1 << c);)
        f.sqrTo(e, q), h = e, e = q, q = h, 0 > --c && (c = this.DB - 1, --m);
    }
    return f.revert(e);
  };
  Sk.builtin.biginteger.prototype.bnGCD = function (a) {
    var b = 0 > this.s ? this.negate() : this.clone();
    a = 0 > a.s ? a.negate() : a.clone();
    if (0 > b.compareTo(a)) {
      var c = b, b = a;
      a = c;
    }
    var c = b.getLowestSetBit(), d = a.getLowestSetBit();
    if (0 > d)
      return b;
    c < d && (d = c);
    0 < d && (b.rShiftTo(d, b), a.rShiftTo(d, a));
    for (; 0 < b.signum();)
      0 < (c = b.getLowestSetBit()) && b.rShiftTo(c, b), 0 < (c = a.getLowestSetBit()) && a.rShiftTo(c, a), 0 <= b.compareTo(a) ? (b.subTo(a, b), b.rShiftTo(1, b)) : (a.subTo(b, a), a.rShiftTo(1, a));
    0 < d && a.lShiftTo(d, a);
    return a;
  };
  Sk.builtin.biginteger.prototype.bnpModInt = function (a) {
    if (0 >= a)
      return 0;
    var b = this.DV % a, c = 0 > this.s ? a - 1 : 0;
    if (0 < this.t)
      if (0 == b)
        c = this[0] % a;
      else
        for (var d = this.t - 1; 0 <= d; --d)
          c = (b * c + this[d]) % a;
    return c;
  };
  Sk.builtin.biginteger.prototype.bnModInverse = function (a) {
    var b = a.isEven();
    if (this.isEven() && b || 0 == a.signum())
      return Sk.builtin.biginteger.ZERO;
    for (var c = a.clone(), d = this.clone(), e = Sk.builtin.biginteger.nbv(1), f = Sk.builtin.biginteger.nbv(0), g = Sk.builtin.biginteger.nbv(0), h = Sk.builtin.biginteger.nbv(1); 0 != c.signum();) {
      for (; c.isEven();)
        c.rShiftTo(1, c), b ? (e.isEven() && f.isEven() || (e.addTo(this, e), f.subTo(a, f)), e.rShiftTo(1, e)) : f.isEven() || f.subTo(a, f), f.rShiftTo(1, f);
      for (; d.isEven();)
        d.rShiftTo(1, d), b ? (g.isEven() && h.isEven() || (g.addTo(this, g), h.subTo(a, h)), g.rShiftTo(1, g)) : h.isEven() || h.subTo(a, h), h.rShiftTo(1, h);
      0 <= c.compareTo(d) ? (c.subTo(d, c), b && e.subTo(g, e), f.subTo(h, f)) : (d.subTo(c, d), b && g.subTo(e, g), h.subTo(f, h));
    }
    if (0 != d.compareTo(Sk.builtin.biginteger.ONE))
      return Sk.builtin.biginteger.ZERO;
    if (0 <= h.compareTo(a))
      return h.subtract(a);
    if (0 > h.signum())
      h.addTo(a, h);
    else
      return h;
    return 0 > h.signum() ? h.add(a) : h;
  };
  Sk.builtin.biginteger.lowprimes = [
    2,
    3,
    5,
    7,
    11,
    13,
    17,
    19,
    23,
    29,
    31,
    37,
    41,
    43,
    47,
    53,
    59,
    61,
    67,
    71,
    73,
    79,
    83,
    89,
    97,
    101,
    103,
    107,
    109,
    113,
    127,
    131,
    137,
    139,
    149,
    151,
    157,
    163,
    167,
    173,
    179,
    181,
    191,
    193,
    197,
    199,
    211,
    223,
    227,
    229,
    233,
    239,
    241,
    251,
    257,
    263,
    269,
    271,
    277,
    281,
    283,
    293,
    307,
    311,
    313,
    317,
    331,
    337,
    347,
    349,
    353,
    359,
    367,
    373,
    379,
    383,
    389,
    397,
    401,
    409,
    419,
    421,
    431,
    433,
    439,
    443,
    449,
    457,
    461,
    463,
    467,
    479,
    487,
    491,
    499,
    503,
    509
  ];
  Sk.builtin.biginteger.lplim = 67108864 / Sk.builtin.biginteger.lowprimes[Sk.builtin.biginteger.lowprimes.length - 1];
  Sk.builtin.biginteger.prototype.bnIsProbablePrime = function (a) {
    var b, c = this.abs();
    if (1 == c.t && c[0] <= Sk.builtin.biginteger.lowprimes[Sk.builtin.biginteger.lowprimes.length - 1]) {
      for (b = 0; b < Sk.builtin.biginteger.lowprimes.length; ++b)
        if (c[0] == Sk.builtin.biginteger.lowprimes[b])
          return !0;
      return !1;
    }
    if (c.isEven())
      return !1;
    for (b = 1; b < Sk.builtin.biginteger.lowprimes.length;) {
      for (var d = Sk.builtin.biginteger.lowprimes[b], e = b + 1; e < Sk.builtin.biginteger.lowprimes.length && d < Sk.builtin.biginteger.lplim;)
        d *= Sk.builtin.biginteger.lowprimes[e++];
      for (d = c.modInt(d); b < e;)
        if (0 == d % Sk.builtin.biginteger.lowprimes[b++])
          return !1;
    }
    return c.millerRabin(a);
  };
  Sk.builtin.biginteger.prototype.bnpMillerRabin = function (a) {
    var b = this.subtract(Sk.builtin.biginteger.ONE), c = b.getLowestSetBit();
    if (0 >= c)
      return !1;
    var d = b.shiftRight(c);
    a = a + 1 >> 1;
    a > Sk.builtin.biginteger.lowprimes.length && (a = Sk.builtin.biginteger.lowprimes.length);
    for (var e = Sk.builtin.biginteger.nbi(), f = 0; f < a; ++f) {
      e.fromInt(Sk.builtin.biginteger.lowprimes[f]);
      var g = e.modPow(d, this);
      if (0 != g.compareTo(Sk.builtin.biginteger.ONE) && 0 != g.compareTo(b)) {
        for (var h = 1; h++ < c && 0 != g.compareTo(b);)
          if (g = g.modPowInt(2, this), 0 == g.compareTo(Sk.builtin.biginteger.ONE))
            return !1;
        if (0 != g.compareTo(b))
          return !1;
      }
    }
    return !0;
  };
  Sk.builtin.biginteger.prototype.isnegative = function () {
    return 0 > this.s;
  };
  Sk.builtin.biginteger.prototype.ispositive = function () {
    return 0 <= this.s;
  };
  Sk.builtin.biginteger.prototype.trueCompare = function (a) {
    return 0 <= this.s && 0 > a.s ? 1 : 0 > this.s && 0 <= a.s ? -1 : this.compare(a);
  };
  Sk.builtin.biginteger.prototype.chunkSize = Sk.builtin.biginteger.prototype.bnpChunkSize;
  Sk.builtin.biginteger.prototype.toRadix = Sk.builtin.biginteger.prototype.bnpToRadix;
  Sk.builtin.biginteger.prototype.fromRadix = Sk.builtin.biginteger.prototype.bnpFromRadix;
  Sk.builtin.biginteger.prototype.fromNumber = Sk.builtin.biginteger.prototype.bnpFromNumber;
  Sk.builtin.biginteger.prototype.bitwiseTo = Sk.builtin.biginteger.prototype.bnpBitwiseTo;
  Sk.builtin.biginteger.prototype.changeBit = Sk.builtin.biginteger.prototype.bnpChangeBit;
  Sk.builtin.biginteger.prototype.addTo = Sk.builtin.biginteger.prototype.bnpAddTo;
  Sk.builtin.biginteger.prototype.dMultiply = Sk.builtin.biginteger.prototype.bnpDMultiply;
  Sk.builtin.biginteger.prototype.dAddOffset = Sk.builtin.biginteger.prototype.bnpDAddOffset;
  Sk.builtin.biginteger.prototype.multiplyLowerTo = Sk.builtin.biginteger.prototype.bnpMultiplyLowerTo;
  Sk.builtin.biginteger.prototype.multiplyUpperTo = Sk.builtin.biginteger.prototype.bnpMultiplyUpperTo;
  Sk.builtin.biginteger.prototype.modInt = Sk.builtin.biginteger.prototype.bnpModInt;
  Sk.builtin.biginteger.prototype.millerRabin = Sk.builtin.biginteger.prototype.bnpMillerRabin;
  Sk.builtin.biginteger.prototype.clone = Sk.builtin.biginteger.prototype.bnClone;
  Sk.builtin.biginteger.prototype.intValue = Sk.builtin.biginteger.prototype.bnIntValue;
  Sk.builtin.biginteger.prototype.byteValue = Sk.builtin.biginteger.prototype.bnByteValue;
  Sk.builtin.biginteger.prototype.shortValue = Sk.builtin.biginteger.prototype.bnShortValue;
  Sk.builtin.biginteger.prototype.signum = Sk.builtin.biginteger.prototype.bnSigNum;
  Sk.builtin.biginteger.prototype.toByteArray = Sk.builtin.biginteger.prototype.bnToByteArray;
  Sk.builtin.biginteger.prototype.equals = Sk.builtin.biginteger.prototype.bnEquals;
  Sk.builtin.biginteger.prototype.compare = Sk.builtin.biginteger.prototype.compareTo;
  Sk.builtin.biginteger.prototype.min = Sk.builtin.biginteger.prototype.bnMin;
  Sk.builtin.biginteger.prototype.max = Sk.builtin.biginteger.prototype.bnMax;
  Sk.builtin.biginteger.prototype.and = Sk.builtin.biginteger.prototype.bnAnd;
  Sk.builtin.biginteger.prototype.or = Sk.builtin.biginteger.prototype.bnOr;
  Sk.builtin.biginteger.prototype.xor = Sk.builtin.biginteger.prototype.bnXor;
  Sk.builtin.biginteger.prototype.andNot = Sk.builtin.biginteger.prototype.bnAndNot;
  Sk.builtin.biginteger.prototype.not = Sk.builtin.biginteger.prototype.bnNot;
  Sk.builtin.biginteger.prototype.shiftLeft = Sk.builtin.biginteger.prototype.bnShiftLeft;
  Sk.builtin.biginteger.prototype.shiftRight = Sk.builtin.biginteger.prototype.bnShiftRight;
  Sk.builtin.biginteger.prototype.getLowestSetBit = Sk.builtin.biginteger.prototype.bnGetLowestSetBit;
  Sk.builtin.biginteger.prototype.bitCount = Sk.builtin.biginteger.prototype.bnBitCount;
  Sk.builtin.biginteger.prototype.testBit = Sk.builtin.biginteger.prototype.bnTestBit;
  Sk.builtin.biginteger.prototype.setBit = Sk.builtin.biginteger.prototype.bnSetBit;
  Sk.builtin.biginteger.prototype.clearBit = Sk.builtin.biginteger.prototype.bnClearBit;
  Sk.builtin.biginteger.prototype.flipBit = Sk.builtin.biginteger.prototype.bnFlipBit;
  Sk.builtin.biginteger.prototype.add = Sk.builtin.biginteger.prototype.bnAdd;
  Sk.builtin.biginteger.prototype.subtract = Sk.builtin.biginteger.prototype.bnSubtract;
  Sk.builtin.biginteger.prototype.multiply = Sk.builtin.biginteger.prototype.bnMultiply;
  Sk.builtin.biginteger.prototype.divide = Sk.builtin.biginteger.prototype.bnDivide;
  Sk.builtin.biginteger.prototype.remainder = Sk.builtin.biginteger.prototype.bnRemainder;
  Sk.builtin.biginteger.prototype.divideAndRemainder = Sk.builtin.biginteger.prototype.bnDivideAndRemainder;
  Sk.builtin.biginteger.prototype.modPow = Sk.builtin.biginteger.prototype.bnModPow;
  Sk.builtin.biginteger.prototype.modInverse = Sk.builtin.biginteger.prototype.bnModInverse;
  Sk.builtin.biginteger.prototype.pow = Sk.builtin.biginteger.prototype.bnPow;
  Sk.builtin.biginteger.prototype.gcd = Sk.builtin.biginteger.prototype.bnGCD;
  Sk.builtin.biginteger.prototype.isProbablePrime = Sk.builtin.biginteger.prototype.bnIsProbablePrime;
  Sk.builtin.numberPy = function (a, b) {
    goog.asserts.assertNumber(a);
    return void 0 === b ? a > Sk.builtin.NumberPy.threshold$ || a < -Sk.builtin.NumberPy.threshold$ || 0 != a % 1 ? Sk.builtin.numberToPy(a) : new Sk.builtin.NumberPy(a, Sk.builtin.NumberPy.int$) : a > Sk.builtin.NumberPy.threshold$ || a < -Sk.builtin.NumberPy.threshold$ ? new Sk.builtin.lng(a) : new Sk.builtin.NumberPy(a, b);
  };
  Sk.builtin.numberToPy = function (a) {
    if ('undefined' !== typeof a)
      return goog.asserts.assertNumber(a), Sk.flyweight ? a : new Sk.builtin.NumberPy(a, Sk.builtin.NumberPy.float$);
  };
  goog.exportSymbol('Sk.builtin.numberToPy', Sk.builtin.numberToPy);
  Sk.builtin.NumberPy = function (a, b) {
    goog.asserts.assertNumber(a);
    goog.asserts.assert('undefined' !== typeof b);
    this.v = a;
    this.skType = b;
  };
  Sk.builtin.NumberPy.prototype.tp$index = function () {
    return this.v;
  };
  Sk.builtin.NumberPy.prototype.tp$hash = function () {
    return this.v;
  };
  Sk.builtin.NumberPy.prototype.tp$name = 'number';
  Sk.builtin.NumberPy.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj('number', Sk.builtin.NumberPy);
  Sk.builtin.NumberPy.threshold$ = Math.pow(2, 53);
  Sk.builtin.NumberPy.float$ = 'float';
  Sk.builtin.NumberPy.int$ = 'int';
  Sk.builtin.NumberPy.fromInt$ = function (a) {
    return Sk.builtin.numberPy(a, void 0);
  };
  Sk.numberFromStr = function (a) {
    if ('inf' == a)
      return Sk.builtin.numberToPy(Infinity);
    if ('-inf' == a)
      return Sk.builtin.numberToPy(-Infinity);
    var b = Sk.builtin.numberPy(0, void 0);
    if (-1 !== a.indexOf('.') || -1 !== a.indexOf('e') || -1 !== a.indexOf('E'))
      return Sk.builtin.numberToPy(parseFloat(a));
    var c = a;
    '-' === a.charAt(0) && (c = a.substr(1));
    a = '0' !== c.charAt(0) || 'x' !== c.charAt(1) && 'X' !== c.charAt(1) ? '0' !== c.charAt(0) || 'b' !== c.charAt(1) && 'B' !== c.charAt(1) ? '0' === c.charAt(0) ? parseInt(a, 8) : parseInt(a, 10) : parseInt(a, 2) : parseInt(a, 16);
    goog.asserts.assertNumber(a);
    b.v = a;
    b.skType = Sk.builtin.NumberPy.int$;
    return b;
  };
  goog.exportSymbol('Sk.numberFromStr', Sk.numberFromStr);
  Sk.builtin.NumberPy.prototype.clone = function () {
    return new Sk.builtin.NumberPy(this.v, this.skType);
  };
  Sk.builtin.NumberPy.prototype.toFixed = function (a) {
    a = Sk.builtin.asnum$(a);
    return this.v.toFixed(a);
  };
  Sk.builtin.NumberPy.prototype.nb$add = function (a) {
    'number' === typeof a && (a = Sk.builtin.numberToPy(a));
    var b = Sk.ffi.remapToJs(this);
    if (Sk.ffi.isFloat(a) || Sk.ffi.isInt(a)) {
      var c = Sk.ffi.remapToJs(a), d = b + c;
      return Sk.ffi.isFloat(this) || Sk.ffi.isFloat(a) ? Sk.builtin.numberToPy(d) : d > Sk.builtin.NumberPy.threshold$ || d < -Sk.builtin.NumberPy.threshold$ ? new Sk.builtin.lng(b).nb$add(c) : Sk.ffi.numberToIntPy(d);
    }
    if (Sk.ffi.isLong(a))
      return Sk.ffi.isFloat(this) ? Sk.builtin.numberToPy(b + parseFloat(a.str$(10, !0))) : new Sk.builtin.lng(b).nb$add(a);
  };
  Sk.builtin.NumberPy.prototype.nb$sub = function (a) {
    var b = Sk.ffi.remapToJs(this);
    'number' === typeof a && (a = Sk.builtin.numberToPy(a));
    if (Sk.ffi.isFloat(a) || Sk.ffi.isInt(a)) {
      var c = Sk.ffi.remapToJs(a), d = b - c;
      return Sk.ffi.isFloat(this) || Sk.ffi.isFloat(a) ? Sk.builtin.numberToPy(d) : d > Sk.builtin.NumberPy.threshold$ || d < -Sk.builtin.NumberPy.threshold$ ? new Sk.builtin.lng(b).nb$sub(c) : Sk.ffi.numberToIntPy(d);
    }
    if (Sk.ffi.isLong(a))
      return Sk.ffi.isFloat(this) ? Sk.builtin.numberToPy(b - parseFloat(a.str$(10, !0))) : new Sk.builtin.lng(b).nb$sub(a);
  };
  Sk.builtin.NumberPy.prototype.nb$mul = function (a) {
    var b = Sk.ffi.remapToJs(this);
    'number' === typeof a && (a = Sk.builtin.numberToPy(a));
    if (Sk.ffi.isFloat(a) || Sk.ffi.isInt(a)) {
      var c = Sk.ffi.remapToJs(a), b = b * c;
      return Sk.ffi.isFloat(this) || Sk.ffi.isFloat(a) ? Sk.builtin.numberToPy(b) : b > Sk.builtin.NumberPy.threshold$ || b < -Sk.builtin.NumberPy.threshold$ ? Sk.ffh.mul(Sk.ffi.promoteIntToLong(this), Sk.ffi.promoteIntToLong(a)) : Sk.ffi.numberToIntPy(b);
    }
    if (Sk.ffi.isLong(a))
      return Sk.ffi.isFloat(this) ? Sk.builtin.numberToPy(b * parseFloat(a.str$(10, !0))) : new Sk.builtin.lng(b).nb$mul(a);
  };
  Sk.builtin.NumberPy.prototype.nb$div = function (a) {
    var b = Sk.ffi.remapToJs(this);
    'number' === typeof a && (a = Sk.builtin.numberToPy(a));
    if (Sk.ffi.isFloat(a) || Sk.ffi.isInt(a)) {
      var c = Sk.ffi.remapToJs(a);
      if (0 === c)
        throw new Sk.builtin.ZeroDivisionError('integer division or modulo by zero');
      if (Infinity === b)
        return Infinity === c || -Infinity === c ? Sk.builtin.numberToPy(NaN) : a.nb$isnegative() ? Sk.builtin.numberToPy(-Infinity) : Sk.builtin.numberToPy(Infinity);
      if (-Infinity === b)
        return Infinity === c || -Infinity === c ? Sk.builtin.numberToPy(NaN) : a.nb$isnegative() ? Sk.builtin.numberToPy(Infinity) : Sk.builtin.numberToPy(-Infinity);
      var d = b / c;
      if (Sk.ffi.isFloat(this) || Sk.ffi.isFloat(a) || Sk.python3)
        return Sk.builtin.numberToPy(d);
      a = Math.floor(d);
      return a > Sk.builtin.NumberPy.threshold$ || a < -Sk.builtin.NumberPy.threshold$ ? new Sk.builtin.lng(b).nb$div(c) : Sk.ffi.numberToIntPy(a);
    }
    if (Sk.ffi.isLong(a)) {
      if (0 === a.longCompare(Sk.builtin.biginteger.ZERO))
        throw new Sk.builtin.ZeroDivisionError('integer division or modulo by zero');
      return Infinity === b ? a.nb$isnegative() ? Sk.builtin.numberToPy(-Infinity) : Sk.builtin.numberToPy(Infinity) : -Infinity === b ? a.nb$isnegative() ? Sk.builtin.numberToPy(Infinity) : Sk.builtin.numberToPy(-Infinity) : Sk.ffi.isFloat(this) ? Sk.builtin.numberToPy(b / parseFloat(a.str$(10, !0))) : new Sk.builtin.lng(b).nb$div(a);
    }
  };
  Sk.builtin.NumberPy.prototype.nb$floor_divide = function (a) {
    var b = Sk.ffi.remapToJs(this);
    'number' === typeof a && (a = Sk.builtin.numberToPy(a));
    if (Infinity === b || -Infinity === b)
      return Sk.builtin.numberToPy(NaN);
    if (Sk.ffi.isFloat(a) || Sk.ffi.isInt(a)) {
      var c = Sk.ffi.remapToJs(a);
      if (0 === c)
        throw new Sk.builtin.ZeroDivisionError('integer division or modulo by zero');
      if (Infinity === c)
        return this.nb$isnegative() ? Sk.builtin.numberToPy(-1) : Sk.builtin.numberToPy(0);
      if (-Infinity === c)
        return this.nb$isnegative() || !this.nb$nonzero() ? Sk.builtin.numberToPy(0) : Sk.builtin.numberToPy(-1);
      var d = Math.floor(b / c);
      if (Sk.ffi.isFloat(this) || Sk.ffi.isFloat(a))
        return Sk.builtin.numberToPy(d);
      a = Math.floor(d);
      return a > Sk.builtin.NumberPy.threshold$ || a < -Sk.builtin.NumberPy.threshold$ ? new Sk.builtin.lng(b).nb$floor_divide(c) : Sk.ffi.numberToIntPy(a);
    }
    if (Sk.ffi.isLong(a)) {
      if (0 == a.longCompare(Sk.builtin.biginteger.ZERO))
        throw new Sk.builtin.ZeroDivisionError('integer division or modulo by zero');
      return Sk.ffi.isFloat(this) ? Sk.builtin.numberToPy(Math.floor(this.v / parseFloat(a.str$(10, !0)))) : new Sk.builtin.lng(this.v).nb$floor_divide(a);
    }
  };
  Sk.builtin.NumberPy.prototype.nb$remainder = function (a) {
    var b = Sk.ffi.remapToJs(this);
    'number' === typeof a && (a = Sk.builtin.numberPy(a, void 0));
    if (Sk.ffi.isFloat(a) || Sk.ffi.isInt(a)) {
      var c = Sk.ffi.remapToJs(a);
      if (0 == c)
        throw new Sk.builtin.ZeroDivisionError('integer division or modulo by zero');
      if (0 == b)
        return Sk.ffi.isFloat(this) || Sk.ffi.isFloat(a) ? Sk.builtin.numberToPy(0) : Sk.ffi.numberToIntPy(0);
      if (Infinity === c)
        return Infinity === b || -Infinity === b ? Sk.builtin.numberToPy(NaN) : this.nb$ispositive() ? Sk.builtin.numberToPy(b) : Sk.builtin.numberToPy(Infinity);
      var d = b % c;
      0 > b ? 0 < c && 0 > d && (d += c) : 0 > c && 0 != d && (d += c);
      return Sk.ffi.isFloat(this) || Sk.ffi.isFloat(a) ? Sk.builtin.numberToPy(d) : d > Sk.builtin.NumberPy.threshold$ || d < -Sk.builtin.NumberPy.threshold$ ? new Sk.builtin.lng(b).nb$remainder(c) : Sk.ffi.numberToIntPy(d);
    }
    if (Sk.ffi.isLong(a)) {
      if (0 == a.longCompare(Sk.builtin.biginteger.ZERO))
        throw new Sk.builtin.ZeroDivisionError('integer division or modulo by zero');
      return 0 === b ? Sk.ffi.isInt(this) ? new Sk.builtin.lng(0) : Sk.builtin.numberToPy(0) : Sk.ffi.isFloat(this) ? (a = parseFloat(a.str$(10, !0)), d = b % a, 0 > d ? 0 < a && 0 != d && (d += a) : 0 > a && 0 != d && (d += a), Sk.builtin.numberToPy(d)) : new Sk.builtin.lng(b).nb$remainder(a);
    }
  };
  Sk.builtin.NumberPy.prototype.nb$power = function (a) {
    var b = Sk.ffi.remapToJs(this);
    'number' === typeof a && (a = Sk.builtin.numberPy(a, void 0));
    if (Sk.ffi.isFloat(a) || Sk.ffi.isInt(a)) {
      var c = Sk.ffi.remapToJs(a);
      if (0 > b && 0 !== c % 1)
        throw new Sk.builtin.NegativePowerError('cannot raise a negative number to a fractional power');
      if (0 === b && 0 > c)
        throw new Sk.builtin.NegativePowerError('cannot raise zero to a negative power');
      var d = Math.pow(b, c);
      if (Sk.ffi.isFloat(this) || Sk.ffi.isFloat(a) || 0 > a.v) {
        if (Infinity === Math.abs(d) && Infinity !== Math.abs(b) && Infinity !== Math.abs(c))
          throw new Sk.builtin.OverflowError('Numerical result out of range');
        return Sk.builtin.numberToPy(d);
      }
      a = Math.floor(d);
      if (a > Sk.builtin.NumberPy.threshold$ || a < -Sk.builtin.NumberPy.threshold$)
        return new Sk.builtin.lng(b).nb$power(c);
      if (Infinity === Math.abs(a) && Infinity !== Math.abs(b) && Infinity !== Math.abs(c))
        throw new Sk.builtin.OverflowError('Numerical result out of range');
      return Sk.ffi.numberToIntPy(a);
    }
    if (Sk.ffi.isLong(a)) {
      if (0 === b && 0 > a.longCompare(Sk.builtin.biginteger.ZERO))
        throw new Sk.builtin.NegativePowerError('cannot raise zero to a negative power');
      return Sk.ffi.isFloat(this) || a.nb$isnegative() ? Sk.builtin.numberToPy(Math.pow(b, parseFloat(a.str$(10, !0)))) : new Sk.builtin.lng(b).nb$power(a);
    }
  };
  Sk.builtin.NumberPy.prototype.nb$and = function (a) {
    a = Sk.builtin.asnum$(a);
    a &= this.v;
    void 0 !== a && 0 > a && (a += 4294967296);
    if (void 0 !== a)
      return Sk.builtin.numberPy(a, void 0);
  };
  Sk.builtin.NumberPy.prototype.nb$or = function (a) {
    a = Sk.builtin.asnum$(a);
    a |= this.v;
    void 0 !== a && 0 > a && (a += 4294967296);
    if (void 0 !== a)
      return Sk.builtin.numberPy(a, void 0);
  };
  Sk.builtin.NumberPy.prototype.nb$xor = function (a) {
    a = Sk.builtin.asnum$(a);
    a ^= this.v;
    void 0 !== a && 0 > a && (a += 4294967296);
    if (void 0 !== a)
      return Sk.builtin.numberPy(a, void 0);
  };
  Sk.builtin.NumberPy.prototype.nb$lshift = function (a) {
    a = Sk.builtin.asnum$(a);
    if (void 0 !== a) {
      if (0 > a)
        throw new Sk.builtin.ValueError('negative shift count');
      var b = this.v << a;
      return b <= this.v ? Sk.builtin.lng.fromInt$(this.v).nb$lshift(a) : Sk.builtin.numberPy(b, this.skType);
    }
  };
  Sk.builtin.NumberPy.prototype.nb$rshift = function (a) {
    a = Sk.builtin.asnum$(a);
    if (void 0 !== a) {
      if (0 > a)
        throw new Sk.builtin.ValueError('negative shift count');
      var b = this.v >> a;
      return 0 < this.v && 0 > b ? Sk.builtin.numberPy(b & Math.pow(2, 32 - a) - 1, this.skType) : Sk.builtin.numberPy(b, this.skType);
    }
  };
  Sk.builtin.NumberPy.prototype.nb$inplace_add = Sk.builtin.NumberPy.prototype.nb$add;
  Sk.builtin.NumberPy.prototype.nb$inplace_subtract = Sk.builtin.NumberPy.prototype.nb$sub;
  Sk.builtin.NumberPy.prototype.nb$inplace_multiply = Sk.builtin.NumberPy.prototype.nb$mul;
  Sk.builtin.NumberPy.prototype.nb$inplace_divide = Sk.builtin.NumberPy.prototype.nb$div;
  Sk.builtin.NumberPy.prototype.nb$inplace_remainder = Sk.builtin.NumberPy.prototype.nb$remainder;
  Sk.builtin.NumberPy.prototype.nb$inplace_floor_divide = Sk.builtin.NumberPy.prototype.nb$floor_divide;
  Sk.builtin.NumberPy.prototype.nb$inplace_power = Sk.builtin.NumberPy.prototype.nb$power;
  Sk.builtin.NumberPy.prototype.nb$inplace_and = Sk.builtin.NumberPy.prototype.nb$and;
  Sk.builtin.NumberPy.prototype.nb$inplace_or = Sk.builtin.NumberPy.prototype.nb$or;
  Sk.builtin.NumberPy.prototype.nb$inplace_xor = Sk.builtin.NumberPy.prototype.nb$xor;
  Sk.builtin.NumberPy.prototype.nb$inplace_lshift = Sk.builtin.NumberPy.prototype.nb$lshift;
  Sk.builtin.NumberPy.prototype.nb$inplace_rshift = Sk.builtin.NumberPy.prototype.nb$rshift;
  Sk.builtin.NumberPy.prototype.u$negative = function () {
    return Sk.builtin.numberPy(-this.v, this.skType);
  };
  Sk.builtin.NumberPy.prototype.u$positive = function () {
    return this;
  };
  Sk.builtin.NumberPy.prototype.u$cos = function () {
    return Sk.builtin.numberToPy(Sk.math.cos(this.v));
  };
  Sk.builtin.NumberPy.prototype.u$sin = function () {
    return Sk.builtin.numberToPy(Sk.math.sin(this.v));
  };
  Sk.builtin.NumberPy.prototype.u$tan = function () {
    return Sk.builtin.numberToPy(Sk.math.tan(this.v));
  };
  Sk.builtin.NumberPy.prototype.u$acos = function () {
    return Sk.builtin.numberToPy(Math.acos(this.v));
  };
  Sk.builtin.NumberPy.prototype.u$asin = function () {
    return Sk.builtin.numberToPy(Math.asin(this.v));
  };
  Sk.builtin.NumberPy.prototype.u$atan = function () {
    return Sk.builtin.numberToPy(Math.atan(this.v));
  };
  Sk.builtin.NumberPy.prototype.u$exp = function () {
    return Sk.builtin.numberToPy(Math.exp(this.v));
  };
  Sk.builtin.NumberPy.prototype.u$abs = function () {
    return Sk.builtin.numberPy(Math.abs(this.v), this.skType);
  };
  Sk.builtin.NumberPy.prototype.u$magnitude = function () {
    return Sk.builtin.numberPy(Math.abs(this.v), this.skType);
  };
  Sk.builtin.NumberPy.prototype.u$quadrance = function () {
    return Sk.builtin.numberPy(this.v * this.v, this.skType);
  };
  Sk.builtin.NumberPy.prototype.u$sqrt = function () {
    return Sk.builtin.numberPy(Math.sqrt(this.v), this.skType);
  };
  Sk.builtin.NumberPy.prototype.nb$nonzero = function () {
    return 0 !== this.v ? Sk.builtin.bool.true$ : Sk.builtin.bool.false$;
  };
  Sk.builtin.NumberPy.prototype.nb$isnegative = function () {
    return 0 > this.v;
  };
  Sk.builtin.NumberPy.prototype.nb$ispositive = function () {
    return 0 <= this.v;
  };
  Sk.builtin.NumberPy.prototype.numberCompare = function (a) {
    a instanceof Sk.builtin.bool && (a = Sk.builtin.asnum$(a));
    a === Sk.builtin.none.none$ && (a = 0);
    if ('number' === typeof a)
      return this.v - a;
    if (a instanceof Sk.builtin.NumberPy)
      return Infinity == this.v && Infinity == a.v || -Infinity == this.v && -Infinity == a.v ? 0 : this.v - a.v;
    if (a instanceof Sk.builtin.lng) {
      if (this.skType === Sk.builtin.NumberPy.int$ || 0 == this.v % 1)
        return new Sk.builtin.lng(this.v).longCompare(a);
      a = this.nb$sub(a);
      if (a instanceof Sk.builtin.NumberPy)
        return a.v;
      if (a instanceof Sk.builtin.lng)
        return a.longCompare(Sk.builtin.biginteger.ZERO);
    }
  };
  Sk.builtin.NumberPy.prototype.__eq__ = function (a, b) {
    return 0 == a.numberCompare(b) && b !== Sk.builtin.none.none$;
  };
  Sk.builtin.NumberPy.prototype.__ne__ = function (a, b) {
    return 0 != a.numberCompare(b) || b === Sk.builtin.none.none$;
  };
  Sk.builtin.NumberPy.prototype.__lt__ = function (a, b) {
    return 0 > a.numberCompare(b);
  };
  Sk.builtin.NumberPy.prototype.__le__ = function (a, b) {
    return 0 >= a.numberCompare(b);
  };
  Sk.builtin.NumberPy.prototype.__gt__ = function (a, b) {
    return 0 < a.numberCompare(b);
  };
  Sk.builtin.NumberPy.prototype.__ge__ = function (a, b) {
    return 0 <= a.numberCompare(b);
  };
  Sk.builtin.NumberPy.prototype.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;
  Sk.builtin.NumberPy.prototype.tp$repr = function () {
    return Sk.builtin.stringToPy(this.str$(10, !0));
  };
  Sk.builtin.NumberPy.prototype.tp$str = function () {
    return Sk.builtin.stringToPy(this.str$(10, !0));
  };
  Sk.builtin.NumberPy.prototype.str$ = function (a, b) {
    goog.asserts.assertNumber(a);
    goog.asserts.assertBoolean(b);
    var c = Sk.ffi.remapToJs(this);
    return Sk.ffi.isFloat(this) ? Sk.builtin.numberToFloatStringJs(c, a, b) : Sk.builtin.numberToIntStringJs(c, a, b);
  };
  Sk.builtin.numberToFloatStringJs = function (a, b, c) {
    goog.asserts.assertNumber(b);
    goog.asserts.assertBoolean(c);
    if (isNaN(a))
      return 'nan';
    if (Infinity == a)
      return 'inf';
    if (-Infinity == a && c)
      return '-inf';
    if (-Infinity == a && !c)
      return 'inf';
    a = c ? a : Math.abs(a);
    if (10 === b) {
      b = a.toPrecision(12);
      var d = b.indexOf('.');
      if (0 <= d)
        if (c = a.toString().slice(0, d), d = a.toString().slice(d), c.match(/^-?0$/) && d.slice(1).match(/^0{4,}/))
          b = 12 > b.length ? a.toExponential() : a.toExponential(11);
        else {
          for (; '0' === b.charAt(b.length - 1) && 0 > b.indexOf('e');)
            b = b.substring(0, b.length - 1);
          '.' == b.charAt(b.length - 1) && (b += '0');
        }
      else
        b = a.toExponential(11);
      b = b.replace(/\.0+e/, 'e', 'i');
      b = b.replace(/(e[-+])([1-9])$/, '$10$2');
      b = b.replace(/0+(e.*)/, '$1');
    } else
      b = a.toString(b);
    0 > b.indexOf('.') && (0 > b.indexOf('E') && 0 > b.indexOf('e')) && (b += '.0');
    return b;
  };
  goog.exportSymbol('Sk.builtin.numberToFloatStringJs', Sk.builtin.numberToFloatStringJs);
  Sk.builtin.numberToIntStringJs = function (a, b, c) {
    goog.asserts.assertNumber(b);
    goog.asserts.assertBoolean(c);
    return isNaN(a) ? 'nan' : Infinity === a ? 'inf' : -Infinity === a ? c ? '-inf' : 'inf' : (c ? a : Math.abs(a)).toString(b);
  };
  goog.exportSymbol('Sk.builtin.numberToIntStringJs', Sk.builtin.numberToIntStringJs);
  goog.exportSymbol('Sk.builtin.NumberPy', Sk.builtin.NumberPy);
  Sk.builtin.lng = function (a, b) {
    b = Sk.builtin.asnum$(b);
    if (!(this instanceof Sk.builtin.lng))
      return new Sk.builtin.lng(a, b);
    if (void 0 === a)
      this.biginteger = new Sk.builtin.biginteger(0);
    else if (Sk.ffi.isLong(a))
      this.biginteger = a.biginteger.clone();
    else if (a instanceof Sk.builtin.biginteger)
      this.biginteger = a;
    else {
      if ('string' === typeof a)
        return Sk.ffi.longFromString(a, b);
      if (Sk.builtin.isStringPy(a))
        return Sk.ffi.longFromString(Sk.builtin.stringToJs(a), b);
      if (void 0 !== a && !Sk.builtin.isStringPy(a) && !Sk.builtin.checkNumber(a))
        if (!0 === a)
          a = 1;
        else if (!1 === a)
          a = 0;
        else
          throw new Sk.builtin.TypeError('long() argument must be a string or a number, not \'' + Sk.ffi.typeName(a) + '\'');
      a = Sk.builtin.asnum$nofloat(a);
      this.biginteger = new Sk.builtin.biginteger(a);
    }
    return this;
  };
  Sk.builtin.lng.prototype.tp$index = function () {
    return parseInt(this.str$(10, !0), 10);
  };
  Sk.builtin.lng.prototype.tp$hash = function () {
    return this.tp$index();
  };
  Sk.builtin.lng.prototype.tp$name = 'long';
  Sk.builtin.lng.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj('long', Sk.builtin.lng);
  Sk.builtin.lng.threshold$ = Math.pow(2, 53);
  Sk.builtin.lng.prototype.cantBeInt = function () {
    return 0 < this.longCompare(Sk.ffi.MAX_INT) || 0 > this.longCompare(Sk.ffi.MIN_INT);
  };
  Sk.builtin.lng.fromInt$ = function (a) {
    return new Sk.builtin.lng(a);
  };
  Sk.builtin.lng.prototype.toInt$ = function () {
    return this.biginteger.intValue();
  };
  Sk.builtin.lng.prototype.clone = function () {
    return new Sk.builtin.lng(this);
  };
  Sk.builtin.lng.prototype.nb$add = function (a) {
    if (Sk.ffi.isFloat(a) || Sk.ffi.isInt(a)) {
      if (Sk.ffi.isFloat(a))
        return Sk.builtin.numberToPy(parseFloat(this.str$(10, !0))).nb$add(a);
      a = Sk.ffi.promoteIntToLong(a);
    }
    return Sk.ffi.isLong(a) ? new Sk.builtin.lng(this.biginteger.add(a.biginteger)) : a instanceof Sk.builtin.biginteger ? new Sk.builtin.lng(this.biginteger.add(a)) : new Sk.builtin.lng(this.biginteger.add(new Sk.builtin.biginteger(a)));
  };
  Sk.builtin.lng.prototype.nb$inplace_add = Sk.builtin.lng.prototype.nb$add;
  Sk.builtin.lng.prototype.nb$sub = function (a) {
    if (Sk.ffi.isFloat(a) || Sk.ffi.isInt(a)) {
      if (Sk.ffi.isFloat(a))
        return Sk.builtin.numberToPy(parseFloat(this.str$(10, !0))).nb$sub(a);
      a = Sk.ffi.promoteIntToLong(a);
    }
    return a instanceof Sk.builtin.lng ? new Sk.builtin.lng(this.biginteger.subtract(a.biginteger)) : a instanceof Sk.builtin.biginteger ? new Sk.builtin.lng(this.biginteger.subtract(a)) : new Sk.builtin.lng(this.biginteger.subtract(new Sk.builtin.biginteger(a)));
  };
  Sk.builtin.lng.prototype.nb$inplace_subtract = Sk.builtin.lng.prototype.nb$sub;
  Sk.builtin.lng.prototype.nb$mul = function (a) {
    if (Sk.ffi.isFloat(a) || Sk.ffi.isInt(a)) {
      if (Sk.ffi.isFloat(a))
        return Sk.ffh.mul(Sk.ffh.promoteLongToFloat(this), a);
      a = Sk.ffi.promoteIntToLong(a);
    }
    return a instanceof Sk.builtin.lng ? new Sk.builtin.lng(this.biginteger.multiply(a.biginteger)) : a instanceof Sk.builtin.biginteger ? new Sk.builtin.lng(this.biginteger.multiply(a)) : new Sk.builtin.lng(this.biginteger.multiply(new Sk.builtin.biginteger(a)));
  };
  Sk.builtin.lng.prototype.nb$inplace_multiply = Sk.builtin.lng.prototype.nb$mul;
  Sk.builtin.lng.prototype.nb$div = function (a) {
    if (Sk.ffi.isFloat(a) || Sk.ffi.isInt(a)) {
      if (Sk.ffi.isFloat(a))
        return Sk.builtin.numberToPy(parseFloat(this.str$(10, !0))).nb$div(a);
      a = Sk.ffi.promoteIntToLong(a);
    }
    a instanceof Sk.builtin.lng || (a = new Sk.builtin.lng(a));
    var b = this.nb$isnegative(), c = a.nb$isnegative();
    if (b && !c || c && !b) {
      a = this.biginteger.divideAndRemainder(a.biginteger);
      if (0 == a[1].trueCompare(Sk.builtin.biginteger.ZERO))
        return new Sk.builtin.lng(a[0]);
      a = a[0].subtract(Sk.builtin.biginteger.ONE);
      return new Sk.builtin.lng(a);
    }
    return new Sk.builtin.lng(this.biginteger.divide(a.biginteger));
  };
  Sk.builtin.lng.prototype.nb$inplace_divide = Sk.builtin.lng.prototype.nb$div;
  Sk.builtin.lng.prototype.nb$floor_divide = function (a) {
    return Sk.ffi.isFloat(a) ? Sk.builtin.numberToPy(parseFloat(this.str$(10, !0))).nb$floor_divide(a) : this.nb$div(a);
  };
  Sk.builtin.lng.prototype.nb$inplace_floor_divide = Sk.builtin.lng.prototype.nb$floor_divide;
  Sk.builtin.lng.prototype.nb$remainder = function (a) {
    if (0 === this.biginteger.trueCompare(Sk.builtin.biginteger.ZERO))
      return (Sk.ffi.isFloat(a) || Sk.ffi.isInt(a)) && Sk.ffi.isFloat(a) ? Sk.builtin.numberToPy(0) : new Sk.builtin.lng(0);
    if (Sk.ffi.isFloat(a) || Sk.ffi.isInt(a)) {
      if (Sk.ffi.isFloat(a))
        return Sk.builtin.numberToPy(parseFloat(this.str$(10, !0))).nb$remainder(a);
      a = Sk.ffi.promoteIntToLong(a);
    }
    a instanceof Sk.builtin.lng || (a = new Sk.builtin.lng(a));
    var b = new Sk.builtin.lng(this.biginteger.remainder(a.biginteger));
    this.nb$isnegative() ? a.nb$ispositive() && b.nb$nonzero() && (b = b.nb$add(a).nb$remainder(a)) : a.nb$isnegative() && b.nb$nonzero() && (b = b.nb$add(a));
    return b;
  };
  Sk.builtin.lng.prototype.nb$inplace_remainder = Sk.builtin.lng.prototype.nb$remainder;
  Sk.builtin.lng.prototype.nb$power = function (a, b) {
    if (void 0 !== b)
      return a = new Sk.builtin.biginteger(Sk.builtin.asnum$(a)), b = new Sk.builtin.biginteger(Sk.builtin.asnum$(b)), new Sk.builtin.lng(this.biginteger.modPowInt(a, b));
    if ('number' === typeof a)
      return 0 > a ? Sk.builtin.numberToPy(this.str$(10, !0)).nb$power(a) : new Sk.builtin.lng(this.biginteger.pow(new Sk.builtin.biginteger(a)));
    if (a instanceof Sk.builtin.NumberPy) {
      if (Sk.ffi.isFloat(a) || 0 > a.v)
        return Sk.builtin.numberToPy(this.str$(10, !0)).nb$power(a);
      a = Sk.ffi.promoteIntToLong(a);
    }
    return Sk.ffi.isLong(a) ? a.nb$isnegative() ? Sk.builtin.numberToPy(this.str$(10, !0)).nb$power(a) : new Sk.builtin.lng(this.biginteger.pow(a.biginteger)) : Sk.ffi.isBigInteger(a) ? a.isnegative() ? Sk.builtin.numberToPy(this.str$(10, !0)).nb$power(a) : new Sk.builtin.lng(this.biginteger.pow(a)) : new Sk.builtin.lng(this.biginteger.pow(new Sk.builtin.biginteger(a)));
  };
  Sk.builtin.lng.prototype.nb$inplace_power = Sk.builtin.lng.prototype.nb$power;
  Sk.builtin.lng.prototype.nb$lshift = function (a) {
    if (a instanceof Sk.builtin.lng) {
      if (0 > a.biginteger.signum())
        throw new Sk.builtin.ValueError('negative shift count');
      return new Sk.builtin.lng(this.biginteger.shiftLeft(a.biginteger));
    }
    if (a instanceof Sk.builtin.biginteger) {
      if (0 > a.signum())
        throw new Sk.builtin.ValueError('negative shift count');
      return new Sk.builtin.lng(this.biginteger.shiftLeft(a));
    }
    if (0 > a)
      throw new Sk.builtin.ValueError('negative shift count');
    a = Sk.builtin.asnum$(a);
    return new Sk.builtin.lng(this.biginteger.shiftLeft(new Sk.builtin.biginteger(a)));
  };
  Sk.builtin.lng.prototype.nb$inplace_lshift = Sk.builtin.lng.prototype.nb$lshift;
  Sk.builtin.lng.prototype.nb$rshift = function (a) {
    if (a instanceof Sk.builtin.lng) {
      if (0 > a.biginteger.signum())
        throw new Sk.builtin.ValueError('negative shift count');
      return new Sk.builtin.lng(this.biginteger.shiftRight(a.biginteger));
    }
    if (a instanceof Sk.builtin.biginteger) {
      if (0 > a.signum())
        throw new Sk.builtin.ValueError('negative shift count');
      return new Sk.builtin.lng(this.biginteger.shiftRight(a));
    }
    if (0 > a)
      throw new Sk.builtin.ValueError('negative shift count');
    a = Sk.builtin.asnum$(a);
    return new Sk.builtin.lng(this.biginteger.shiftRight(new Sk.builtin.biginteger(a)));
  };
  Sk.builtin.lng.prototype.nb$inplace_rshift = Sk.builtin.lng.prototype.nb$rshift;
  Sk.builtin.lng.prototype.nb$and = function (a) {
    if (a instanceof Sk.builtin.lng)
      return new Sk.builtin.lng(this.biginteger.and(a.biginteger));
    if (a instanceof Sk.builtin.biginteger)
      return new Sk.builtin.lng(this.biginteger.and(a));
    a = Sk.builtin.asnum$(a);
    return new Sk.builtin.lng(this.biginteger.and(new Sk.builtin.biginteger(a)));
  };
  Sk.builtin.lng.prototype.nb$inplace_and = Sk.builtin.lng.prototype.nb$and;
  Sk.builtin.lng.prototype.nb$or = function (a) {
    if (a instanceof Sk.builtin.lng)
      return new Sk.builtin.lng(this.biginteger.or(a.biginteger));
    if (a instanceof Sk.builtin.biginteger)
      return new Sk.builtin.lng(this.biginteger.or(a));
    a = Sk.builtin.asnum$(a);
    return new Sk.builtin.lng(this.biginteger.or(new Sk.builtin.biginteger(a)));
  };
  Sk.builtin.lng.prototype.nb$inplace_or = Sk.builtin.lng.prototype.nb$or;
  Sk.builtin.lng.prototype.nb$xor = function (a) {
    if (a instanceof Sk.builtin.lng)
      return new Sk.builtin.lng(this.biginteger.xor(a.biginteger));
    if (a instanceof Sk.builtin.biginteger)
      return new Sk.builtin.lng(this.biginteger.xor(a));
    a = Sk.builtin.asnum$(a);
    return new Sk.builtin.lng(this.biginteger.xor(new Sk.builtin.biginteger(a)));
  };
  Sk.builtin.lng.prototype.nb$inplace_xor = Sk.builtin.lng.prototype.nb$xor;
  Sk.builtin.lng.prototype.u$negative = function () {
    return new Sk.builtin.lng(this.biginteger.negate());
  };
  Sk.builtin.lng.prototype.u$positive = function () {
    return this.clone();
  };
  Sk.builtin.lng.prototype.nb$nonzero = function () {
    return 0 !== this.biginteger.trueCompare(Sk.builtin.biginteger.ZERO);
  };
  Sk.builtin.lng.prototype.nb$isnegative = function () {
    return this.biginteger.isnegative();
  };
  Sk.builtin.lng.prototype.nb$ispositive = function () {
    return !this.biginteger.isnegative();
  };
  Sk.builtin.lng.prototype.longCompare = function (a) {
    'boolean' === typeof a && (a = a ? 1 : 0);
    'number' === typeof a && (a = new Sk.builtin.lng(a));
    return a instanceof Sk.builtin.NumberPy ? Sk.ffi.isInt(a) || 0 == a.v % 1 ? (a = new Sk.builtin.lng(a.v), this.longCompare(a)) : Sk.builtin.numberToPy(parseFloat(this.str$(10, !0))).numberCompare(a) : Sk.ffi.isLong(a) ? this.biginteger.subtract(a.biginteger) : Sk.ffi.isBigInteger(a) ? this.biginteger.subtract(a) : this.biginteger.subtract(new Sk.builtin.biginteger(a));
  };
  Sk.builtin.lng.prototype.__eq__ = function (a, b) {
    return 0 == a.longCompare(b) && b !== Sk.builtin.none.none$;
  };
  Sk.builtin.lng.prototype.__ne__ = function (a, b) {
    return 0 != a.longCompare(b) || b === Sk.builtin.none.none$;
  };
  Sk.builtin.lng.prototype.__lt__ = function (a, b) {
    return 0 > a.longCompare(b);
  };
  Sk.builtin.lng.prototype.__le__ = function (a, b) {
    return 0 >= a.longCompare(b);
  };
  Sk.builtin.lng.prototype.__gt__ = function (a, b) {
    return 0 < a.longCompare(b);
  };
  Sk.builtin.lng.prototype.__ge__ = function (a, b) {
    return 0 <= a.longCompare(b);
  };
  Sk.builtin.lng.prototype.tp$repr = function () {
    return Sk.builtin.stringToPy(this.str$(10, !0) + 'L');
  };
  Sk.builtin.lng.prototype.tp$str = function () {
    return Sk.builtin.stringToPy(this.str$(10, !0));
  };
  Sk.builtin.lng.prototype.str$ = function (a, b) {
    goog.asserts.assertNumber(a);
    goog.asserts.assertBoolean(b);
    void 0 === a && (a = 10);
    void 0 === b && (b = !0);
    return (b ? this.biginteger : this.biginteger.abs()).toString(a);
  };
  Sk.str2number = function (a, b, c, d, e) {
    goog.asserts.assertString(a, 's must be a string');
    var f = a, g = !1;
    a = a.replace(/^\s+|\s+$/g, '');
    '-' == a.charAt(0) && (g = !0, a = a.substring(1));
    '+' == a.charAt(0) && (a = a.substring(1));
    void 0 === b && (b = 10);
    if ((2 > b || 36 < b) && 0 != b)
      throw new Sk.builtin.ValueError(e + '() base must be >= 2 and <= 36');
    if ('0x' == a.substring(0, 2).toLowerCase()) {
      if (16 != b && 0 != b)
        throw new Sk.builtin.ValueError('invalid literal for ' + e + '() with base ' + b + ': \'' + f + '\'');
      a = a.substring(2);
      b = 16;
    } else if ('0b' == a.substring(0, 2).toLowerCase()) {
      if (2 != b && 0 != b)
        throw new Sk.builtin.ValueError('invalid literal for ' + e + '() with base ' + b + ': \'' + f + '\'');
      a = a.substring(2);
      b = 2;
    } else if ('0o' == a.substring(0, 2).toLowerCase()) {
      if (8 != b && 0 != b)
        throw new Sk.builtin.ValueError('invalid literal for ' + e + '() with base ' + b + ': \'' + f + '\'');
      a = a.substring(2);
      b = 8;
    } else if ('0' == a.charAt(0)) {
      if ('0' == a)
        return 0;
      if (8 == b || 0 == b)
        b = 8;
    }
    0 == b && (b = 10);
    if (0 === a.length)
      throw new Sk.builtin.ValueError('invalid literal for ' + e + '() with base ' + b + ': \'' + f + '\'');
    var h, l, k;
    for (h = 0; h < a.length; h++)
      if (l = a.charCodeAt(h), k = b, 48 <= l && 57 >= l ? k = l - 48 : 65 <= l && 90 >= l ? k = l - 65 + 10 : 97 <= l && 122 >= l && (k = l - 97 + 10), k >= b)
        throw new Sk.builtin.ValueError('invalid literal for ' + e + '() with base ' + b + ': \'' + f + '\'');
    k = c(a, b);
    g && (k = d(k));
    return k;
  };
  Sk.builtin.int_ = function (a, b) {
    if (void 0 !== a && !Sk.builtin.isStringPy(a) && !Sk.builtin.checkNumber(a))
      if (a instanceof Sk.builtin.bool)
        a = Sk.builtin.asnum$(a);
      else
        throw new Sk.builtin.TypeError('int() argument must be a string or a number, not \'' + Sk.ffi.typeName(a) + '\'');
    if (Sk.builtin.isStringPy(a)) {
      b = Sk.builtin.asnum$(b);
      var c = Sk.str2number(Sk.builtin.stringToJs(a), b, parseInt, function (a) {
          return -a;
        }, 'int');
      return c > Sk.builtin.lng.threshold$ || c < -Sk.builtin.lng.threshold$ ? new Sk.builtin.lng(a, b) : Sk.builtin.numberPy(c, Sk.builtin.NumberPy.int$);
    }
    if (void 0 !== b)
      throw new Sk.builtin.TypeError('int() can\'t convert non-string with explicit base');
    if (a instanceof Sk.builtin.lng)
      return a.cantBeInt() ? new Sk.builtin.lng(a) : Sk.ffi.numberToIntPy(a.toInt$());
    a = Sk.builtin.asnum$(a);
    return Sk.ffi.numberToIntPy(a | 0);
  };
  Sk.builtin.int_.prototype.tp$name = 'int';
  Sk.builtin.int_.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj('int', Sk.builtin.int_);
  Sk.builtin.float_ = function (a) {
    if (void 0 === a)
      return Sk.builtin.numberToPy(0);
    if (Sk.builtin.isStringPy(a)) {
      a = Sk.builtin.stringToJs(a);
      if (a.match(/^-inf$/i))
        return Sk.builtin.numberToPy(-Infinity);
      if (a.match(/^[+]?inf$/i))
        return Sk.builtin.numberToPy(Infinity);
      if (a.match(/^[-+]?nan$/i))
        return Sk.builtin.numberToPy(NaN);
      if (isNaN(a))
        throw new Sk.builtin.ValueError('float: Argument: ' + a + ' is not number');
      return Sk.builtin.numberToPy(parseFloat(a));
    }
    if ('number' === typeof a || a instanceof Sk.builtin.NumberPy || a instanceof Sk.builtin.lng)
      return a = Sk.builtin.asnum$(a), Sk.builtin.numberToPy(a);
    if (a instanceof Sk.builtin.bool)
      return a = Sk.builtin.asnum$(a), Sk.builtin.numberToPy(a);
    throw new Sk.builtin.TypeError('float() argument must be a string or a number');
  };
  Sk.builtin.float_.prototype.tp$name = 'float';
  Sk.builtin.float_.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj('float', Sk.builtin.float_);
  Sk.builtin.complex = function (a, b) {
    Sk.ffi.checkFunctionArgs('complex(x,y)', arguments, 2, 2);
    return new Sk.builtin.ComplexPy(a, b);
  };
  Sk.builtin.ComplexPy = function (a, b) {
    this.xPy = a;
    this.yPy = b;
  };
  Sk.builtin.ComplexPy.prototype.tp$name = 'complex';
  Sk.builtin.ComplexPy.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj('complex', Sk.builtin.ComplexPy);
  Sk.builtin.ComplexPy.prototype.tp$getattr = function (a) {
    goog.asserts.assertString(a);
    var b = this.xPy, c = this.yPy;
    switch (a) {
    case 'real':
      return this.xPy;
    case 'imag':
      return this.yPy;
    case 'conjugate':
      return new Sk.builtin.func(function (a) {
        Sk.ffi.checkMethodArgs('conjugate()', arguments, 0, 0);
        return new Sk.builtin.ComplexPy(b, Sk.ffh.negative(c));
      });
    }
  };
  Sk.builtin.ComplexPy.prototype.tp$str = function () {
    if (Sk.ffh.nonzero(this.xPy)) {
      if (Sk.ffh.nonzero(this.yPy)) {
        var a = Sk.builtin.stringToJs(Sk.ffh.str(this.xPy)), b = Sk.builtin.stringToJs(Sk.ffh.str(this.yPy));
        return Sk.builtin.stringToPy('(' + a + '+' + b + 'j)');
      }
    } else
      Sk.ffh.nonzero(this.yPy);
    Sk.builtin.stringToJs(Sk.ffh.str(this.xPy));
    Sk.builtin.stringToJs(Sk.ffh.str(this.yPy));
    return Sk.builtin.stringToPy('Hello, I\'m very complex!');
  };
  Sk.builtin.ComplexPy.prototype.nb$add = function (a) {
    if (a instanceof Sk.builtin.ComplexPy) {
      var b = this.yPy, c = a.yPy;
      a = Sk.ffh.add(this.xPy, a.xPy);
      b = Sk.ffh.add(b, c);
      return Sk.builtin.complex(a, b);
    }
  };
  Sk.builtin.ComplexPy.prototype.nb$sub = function (a) {
    if (a instanceof Sk.builtin.ComplexPy) {
      var b = this.yPy, c = a.yPy;
      a = Sk.ffh.sub(this.xPy, a.xPy);
      b = Sk.ffh.sub(b, c);
      return Sk.builtin.complex(a, b);
    }
  };
  Sk.builtin.ComplexPy.prototype.nb$mul = function (a) {
    if (a instanceof Sk.builtin.ComplexPy) {
      var b = this.xPy, c = this.yPy, d = a.xPy, e = a.yPy;
      a = Sk.ffh.sub(Sk.ffh.mul(b, d), Sk.ffh.mul(c, e));
      b = Sk.ffh.add(Sk.ffh.mul(c, d), Sk.ffh.mul(b, e));
      return Sk.builtin.complex(a, b);
    }
  };
  Sk.builtin.ComplexPy.prototype.nb$div = function (a) {
    if (a instanceof Sk.builtin.ComplexPy) {
      var b = this.xPy, c = this.yPy, d = a.xPy, e = a.yPy, f = Sk.ffh.add(Sk.ffh.mul(d, d), Sk.ffh.mul(e, e));
      a = Sk.ffh.div(Sk.ffh.add(Sk.ffh.mul(b, d), Sk.ffh.mul(c, e)), f);
      b = Sk.ffh.div(Sk.ffh.sub(Sk.ffh.mul(c, d), Sk.ffh.mul(b, e)), f);
      return Sk.builtin.complex(a, b);
    }
  };
  Sk.builtin.slice = function (a, b, c) {
    a = Sk.builtin.asnum$(a);
    b = Sk.builtin.asnum$(b);
    c = Sk.builtin.asnum$(c);
    if (!(this instanceof Sk.builtin.slice))
      return new Sk.builtin.slice(a, b, c);
    void 0 === b && void 0 === c && (b = a, a = null);
    a || (a = null);
    void 0 === b && (b = null);
    void 0 === c && (c = null);
    this.start = a;
    this.stop = b;
    this.step = c;
    if (null !== this.start && !Sk.builtin.checkInt(this.start) || null !== this.stop && !Sk.builtin.checkInt(this.stop) || null !== this.step && !Sk.builtin.checkInt(this.step))
      throw new Sk.builtin.TypeError('slice indices must be integers or None');
    return this;
  };
  Sk.builtin.slice.prototype.tp$str = function () {
    var a = Sk.builtin.repr(this.start).v, b = Sk.builtin.repr(this.stop).v, c = Sk.builtin.repr(this.step).v;
    return Sk.builtin.stringToPy('slice(' + a + ', ' + b + ', ' + c + ')');
  };
  Sk.builtin.slice.prototype.indices = function (a) {
    a = Sk.builtin.asnum$(a);
    var b = this.start, c = this.stop, d = this.step;
    null === d && (d = 1);
    0 < d ? (null === b && (b = 0), null === c && (c = a), c > a && (c = a), 0 > b && (b = a + b, 0 > b && (b = 0)), 0 > c && (c = a + c)) : (null === b && (b = a - 1), b >= a && (b = a - 1), null === c ? c = -1 : 0 > c && (c = a + c, 0 > c && (c = -1)), 0 > b && (b = a + b));
    return [
      b,
      c,
      d
    ];
  };
  Sk.builtin.slice.prototype.sssiter$ = function (a, b) {
    var c = Sk.builtin.asnum$(a), d = this.indices('number' === typeof c ? c : a.v.length);
    if (0 < d[2]) {
      var e;
      for (e = d[0]; e < d[1] && !1 !== b(e, c); e += d[2]);
    } else
      for (e = d[0]; e > d[1] && !1 !== b(e, c); e += d[2]);
  };
  Sk.builtin.set = function (a) {
    if (!(this instanceof Sk.builtin.set))
      return new Sk.builtin.set(a);
    'undefined' === typeof a && (a = []);
    this.set_reset_();
    a = new Sk.builtin.list(a).tp$iter();
    for (var b = a.tp$iternext(); void 0 !== b; b = a.tp$iternext())
      Sk.builtin.set.prototype.add.func_code(this, b);
    this.__class__ = Sk.builtin.set;
    this.v = this.v;
    return this;
  };
  Sk.builtin.set.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj('set', Sk.builtin.set);
  Sk.builtin.set.prototype.set_iter_ = function () {
    return Sk.builtin.dict.prototype.keys.func_code(this.v).tp$iter();
  };
  Sk.builtin.set.prototype.set_reset_ = function () {
    this.v = new Sk.builtin.dict([]);
  };
  Sk.builtin.set.prototype.tp$name = 'set';
  Sk.builtin.set.prototype.tp$repr = function () {
    for (var a = [], b = this.tp$iter(), c = b.tp$iternext(); void 0 !== c; c = b.tp$iternext())
      a.push(Sk.misceval.objectRepr(c).v);
    return Sk.builtin.stringToPy('set([' + a.join(', ') + '])');
  };
  Sk.builtin.set.prototype.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;
  Sk.builtin.set.prototype.tp$hash = Sk.builtin.object.prototype.HashNotImplemented;
  Sk.builtin.set.prototype.tp$richcompare = function (a, b) {
    if (this === a && Sk.misceval.opAllowsEquality(b))
      return !0;
    if (!a.__class__ || a.__class__ != Sk.builtin.set)
      return b === Sk.misceval.compareOp.Eq ? !1 : b === Sk.misceval.compareOp.NotEq ? !0 : !1;
    var c = this.sq$length(), d = a.sq$length();
    if (d !== c) {
      if (b === Sk.misceval.compareOp.Eq)
        return !1;
      if (b === Sk.misceval.compareOp.NotEq)
        return !0;
    }
    var e = !1, f = !1;
    switch (b) {
    case Sk.misceval.compareOp.Lt:
    case 'LtE':
    case Sk.misceval.compareOp.Eq:
    case Sk.misceval.compareOp.NotEq:
      e = Sk.builtin.set.prototype.issubset.func_code(this, a);
      break;
    case Sk.misceval.compareOp.Gt:
    case Sk.misceval.compareOp.GtE:
      f = Sk.builtin.set.prototype.issuperset.func_code(this, a);
      break;
    default:
      goog.asserts.fail();
    }
    switch (b) {
    case Sk.misceval.compareOp.Lt:
      return c < d && e;
    case 'LtE':
    case Sk.misceval.compareOp.Eq:
      return e;
    case Sk.misceval.compareOp.NotEq:
      return !e;
    case Sk.misceval.compareOp.Gt:
      return c > d && f;
    case Sk.misceval.compareOp.GtE:
      return f;
    }
  };
  Sk.builtin.set.prototype.tp$iter = Sk.builtin.set.prototype.set_iter_;
  Sk.builtin.set.prototype.sq$length = function () {
    return this.v.mp$length();
  };
  Sk.builtin.set.prototype.isdisjoint = new Sk.builtin.func(function (a, b) {
    for (var c = a.tp$iter(), d = c.tp$iternext(); void 0 !== d; d = c.tp$iternext())
      if (Sk.abstr.sequenceContains(b, d))
        return Sk.builtin.bool.false$;
    return Sk.builtin.bool(!0);
  });
  Sk.builtin.set.prototype.issubset = new Sk.builtin.func(function (a, b) {
    var c = a.sq$length(), d = b.sq$length();
    if (c > d)
      return Sk.builtin.bool.false$;
    c = a.tp$iter();
    for (d = c.tp$iternext(); void 0 !== d; d = c.tp$iternext())
      if (!Sk.abstr.sequenceContains(b, d))
        return Sk.builtin.bool.false$;
    return Sk.builtin.bool.true$;
  });
  Sk.builtin.set.prototype.issuperset = new Sk.builtin.func(function (a, b) {
    return Sk.builtin.set.prototype.issubset.func_code(b, a);
  });
  Sk.builtin.set.prototype.union = new Sk.builtin.func(function (a) {
    for (var b = new Sk.builtin.set(a), c = 1; c < arguments.length; c++)
      Sk.builtin.set.prototype.update.func_code(b, arguments[c]);
    return b;
  });
  Sk.builtin.set.prototype.intersection = new Sk.builtin.func(function (a) {
    var b = Sk.builtin.set.prototype.copy.func_code(a);
    arguments[0] = b;
    Sk.builtin.set.prototype.intersection_update.func_code.apply(null, arguments);
    return b;
  });
  Sk.builtin.set.prototype.difference = new Sk.builtin.func(function (a, b) {
    var c = Sk.builtin.set.prototype.copy.func_code(a);
    arguments[0] = c;
    Sk.builtin.set.prototype.difference_update.func_code.apply(null, arguments);
    return c;
  });
  Sk.builtin.set.prototype.symmetric_difference = new Sk.builtin.func(function (a, b) {
    for (var c = Sk.builtin.set.prototype.union.func_code(a, b), d = c.tp$iter(), e = d.tp$iternext(); void 0 !== e; e = d.tp$iternext())
      Sk.abstr.sequenceContains(a, e) && Sk.abstr.sequenceContains(b, e) && Sk.builtin.set.prototype.discard.func_code(c, e);
    return c;
  });
  Sk.builtin.set.prototype.copy = new Sk.builtin.func(function (a) {
    return new Sk.builtin.set(a);
  });
  Sk.builtin.set.prototype.update = new Sk.builtin.func(function (a, b) {
    for (var c = b.tp$iter(), d = c.tp$iternext(); void 0 !== d; d = c.tp$iternext())
      Sk.builtin.set.prototype.add.func_code(a, d);
    return null;
  });
  Sk.builtin.set.prototype.intersection_update = new Sk.builtin.func(function (a) {
    for (var b = a.tp$iter(), c = b.tp$iternext(); void 0 !== c; c = b.tp$iternext())
      for (var d = 1; d < arguments.length; d++)
        if (!Sk.abstr.sequenceContains(arguments[d], c)) {
          Sk.builtin.set.prototype.discard.func_code(a, c);
          break;
        }
    return null;
  });
  Sk.builtin.set.prototype.difference_update = new Sk.builtin.func(function (a, b) {
    for (var c = a.tp$iter(), d = c.tp$iternext(); void 0 !== d; d = c.tp$iternext())
      for (var e = 1; e < arguments.length; e++)
        if (Sk.abstr.sequenceContains(arguments[e], d)) {
          Sk.builtin.set.prototype.discard.func_code(a, d);
          break;
        }
    return null;
  });
  Sk.builtin.set.prototype.symmetric_difference_update = new Sk.builtin.func(function (a, b) {
    var c = Sk.builtin.set.prototype.symmetric_difference.func_code(a, b);
    a.set_reset_();
    Sk.builtin.set.prototype.update.func_code(a, c);
    return null;
  });
  Sk.builtin.set.prototype.add = new Sk.builtin.func(function (a, b) {
    a.v.mp$ass_subscript(b, !0);
    return null;
  });
  Sk.builtin.set.prototype.discard = new Sk.builtin.func(function (a, b) {
    if (void 0 !== a.v.mp$lookup(b)) {
      var c = Sk.builtin.hash, c = c(b);
      void 0 !== a.v[c] && (a.v.size -= 1, delete a.v[c]);
    }
    return null;
  });
  Sk.builtin.set.prototype.pop = new Sk.builtin.func(function (a) {
    if (0 === a.sq$length())
      throw new Sk.builtin.KeyError('pop from an empty set');
    var b = a.tp$iter().tp$iternext();
    Sk.builtin.set.prototype.discard.func_code(a, b);
    return b;
  });
  Sk.builtin.set.prototype.remove = new Sk.builtin.func(function (a, b) {
    a.v.mp$del_subscript(b);
    return null;
  });
  goog.exportSymbol('Sk.builtin.set', Sk.builtin.set);
  Sk.builtin.module = function () {
  };
  goog.exportSymbol('Sk.builtin.module', Sk.builtin.module);
  Sk.builtin.module.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj('module', Sk.builtin.module);
  Sk.builtin.module.prototype.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;
  Sk.builtin.module.prototype.tp$setattr = Sk.builtin.object.prototype.GenericSetAttr;
  Sk.builtin.generator = function (a, b, c, d, e) {
    if (a) {
      this.func_code = a;
      this.func_globals = b || null;
      this.gi$running = !1;
      this.gi$resumeat = 0;
      this.gi$sentvalue = void 0;
      this.gi$locals = {};
      if (0 < c.length)
        for (b = 0; b < a.co_varnames.length; ++b)
          this.gi$locals[a.co_varnames[b]] = c[b];
      if (void 0 !== e)
        for (var f in e)
          d[f] = e[f];
      this.func_closure = d;
      return this;
    }
  };
  goog.exportSymbol('Sk.builtin.generator', Sk.builtin.generator);
  Sk.builtin.generator.prototype.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;
  Sk.builtin.generator.prototype.tp$iter = function () {
    return this;
  };
  Sk.builtin.generator.prototype.tp$iternext = function (a) {
    this.gi$running = !0;
    void 0 === a && (a = null);
    this.gi$sentvalue = a;
    a = [this];
    this.func_closure && a.push(this.func_closure);
    a = this.func_code.apply(this.func_globals, a);
    this.gi$running = !1;
    goog.asserts.assert(void 0 !== a);
    if (null !== a)
      return this.gi$resumeat = a[0], a = a[1];
  };
  Sk.builtin.generator.prototype.next = new Sk.builtin.func(function (a) {
    return a.tp$iternext();
  });
  Sk.builtin.generator.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj('generator', Sk.builtin.generator);
  Sk.builtin.generator.prototype.tp$repr = function () {
    return Sk.builtin.stringToPy('<generator object ' + Sk.ffi.remapToJs(this.func_code.co_name) + '>');
  };
  Sk.builtin.generator.prototype.send = new Sk.builtin.func(function (a, b) {
    return a.tp$iternext(b);
  });
  Sk.builtin.makeGenerator = function (a, b) {
    var c = new Sk.builtin.generator(null, null, null);
    c.tp$iternext = a;
    for (var d in b)
      b.hasOwnProperty(d) && (c[d] = b[d]);
    return c;
  };
  goog.exportSymbol('Sk.builtin.makeGenerator', Sk.builtin.makeGenerator);
  Sk.builtin.file = function (a, b, c) {
    this.mode = b;
    this.name = a;
    this.closed = !1;
    if (Sk.inBrowser) {
      b = document.getElementById(a.v);
      if (null == b)
        throw new Sk.builtin.IOError('[Errno 2] No such file or directory: \'' + a.v + '\'');
      'textarea' == b.nodeName.toLowerCase() ? this.data$ = b.value : this.data$ = b.textContent;
    } else
      this.data$ = Sk.read(a.v);
    this.lineList = this.data$.split('\n');
    this.lineList = this.lineList.slice(0, -1);
    for (var d in this.lineList)
      this.lineList[d] += '\n';
    this.pos$ = this.currentLine = 0;
    this.__class__ = Sk.builtin.file;
    return this;
  };
  Sk.builtin.file.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj('file', Sk.builtin.file);
  Sk.builtin.file.prototype.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;
  Sk.builtin.file.prototype.tp$repr = function () {
    return Sk.builtin.stringToPy('<' + (this.closed ? 'closed' : 'open') + 'file \'' + this.name + '\', mode \'' + this.mode + '\'>');
  };
  Sk.builtin.file.prototype.tp$iter = function () {
    var a = {
        tp$iter: function () {
          return a;
        },
        $obj: this,
        $index: 0,
        $lines: this.lineList,
        tp$iternext: function () {
          return a.$index >= a.$lines.length ? void 0 : Sk.builtin.stringToPy(a.$lines[a.$index++]);
        }
      };
    return a;
  };
  Sk.builtin.file.prototype.close = new Sk.builtin.func(function (a) {
    a.closed = !0;
  });
  Sk.builtin.file.prototype.flush = new Sk.builtin.func(function (a) {
  });
  Sk.builtin.file.prototype.fileno = new Sk.builtin.func(function (a) {
    return 10;
  });
  Sk.builtin.file.prototype.isatty = new Sk.builtin.func(function (a) {
    return !1;
  });
  Sk.builtin.file.prototype.read = new Sk.builtin.func(function (a, b) {
    if (a.closed)
      throw new Sk.builtin.ValueError('I/O operation on closed file');
    var c = a.data$.length;
    void 0 === b && (b = c);
    var d = Sk.builtin.stringToPy(a.data$.substr(a.pos$, b));
    a.pos$ += b;
    a.pos$ >= c && (a.pos$ = c);
    return d;
  });
  Sk.builtin.file.prototype.readline = new Sk.builtin.func(function (a, b) {
    var c = '';
    a.currentLine < a.lineList.length && (c = a.lineList[a.currentLine], a.currentLine++);
    return Sk.builtin.stringToPy(c);
  });
  Sk.builtin.file.prototype.readlines = new Sk.builtin.func(function (a, b) {
    for (var c = [], d = a.currentLine; d < a.lineList.length; d++)
      c.push(Sk.builtin.stringToPy(a.lineList[d]));
    return new Sk.builtin.list(c);
  });
  Sk.builtin.file.prototype.seek = new Sk.builtin.func(function (a, b, c) {
    void 0 === c && (c = 1);
    a.pos$ = 1 == c ? b : a.data$ + b;
  });
  Sk.builtin.file.prototype.tell = new Sk.builtin.func(function (a) {
    return a.pos$;
  });
  Sk.builtin.file.prototype.truncate = new Sk.builtin.func(function (a, b) {
    goog.asserts.fail();
  });
  Sk.builtin.file.prototype.write = new Sk.builtin.func(function (a, b) {
    goog.asserts.fail();
  });
  goog.exportSymbol('Sk.builtin.file', Sk.builtin.file);
  Sk.ffi = {};
  goog.exportSymbol('Sk.ffi.AssertionError', Sk.ffi.AssertionError);
  Sk.ffi.assertionError = function (a) {
    return new Sk.builtin.AssertionError(a);
  };
  goog.exportSymbol('Sk.ffi.assertionError', Sk.ffi.assertionError);
  goog.exportSymbol('Sk.ffi.AttributeError', Sk.ffi.AttributeError);
  Sk.ffi.attributeError = function (a) {
    return new Sk.builtin.AttributeError(a);
  };
  goog.exportSymbol('Sk.ffi.attributeError', Sk.ffi.attributeError);
  goog.exportSymbol('Sk.ffi.NotImplementedError', Sk.ffi.NotImplementedError);
  Sk.ffi.notImplementedError = function (a) {
    return new Sk.builtin.NotImplementedError(a);
  };
  goog.exportSymbol('Sk.ffi.notImplementedError', Sk.ffi.notImplementedError);
  goog.exportSymbol('Sk.ffi.TypeError', Sk.ffi.TypeError);
  Sk.ffi.typeError = function (a) {
    return new Sk.builtin.TypeError(a);
  };
  goog.exportSymbol('Sk.ffi.typeError', Sk.ffi.typeError);
  Sk.ffi.type = function (a) {
    return Sk.flyweight && typeof a === Sk.builtin.JsType.NUMBER ? Sk.builtin.float_.prototype.ob$type : a.constructor === Sk.builtin.NumberPy ? a.skType === Sk.builtin.NumberPy.int$ ? Sk.builtin.int_.prototype.ob$type : Sk.builtin.float_.prototype.ob$type : a.ob$type;
  };
  goog.exportSymbol('Sk.ffi.type', Sk.ffi.type);
  Sk.ffi.bool = {
    True: Sk.builtin.bool.true$,
    False: Sk.builtin.bool.false$
  };
  goog.exportSymbol('Sk.ffi.bool', Sk.ffi.bool);
  Sk.ffi.booleanToPy = function (a, b) {
    var c = typeof a;
    if (c === Sk.builtin.JsType.BOOLEAN)
      return a ? Sk.ffi.bool.True : Sk.ffi.bool.False;
    if (c === Sk.builtin.JsType.OBJECT && null === a)
      return Sk.builtin.none.none$;
    if (c === Sk.builtin.JsType.UNDEFINED) {
      c = typeof b;
      if (c === Sk.builtin.JsType.BOOLEAN)
        return Sk.ffi.booleanToPy(Boolean(b));
      if (c === Sk.builtin.JsType.UNDEFINED)
        return;
      if (c === Sk.builtin.JsType.OBJECT && null === b)
        return Sk.builtin.none.none$;
      throw Sk.ffi.err.argument('defaultJs').inFunction('Sk.ffi.booleanToPy').mustHaveType([
        Sk.builtin.JsType.BOOLEAN,
        'null',
        Sk.builtin.JsType.UNDEFINED
      ].join(' or '));
    }
    throw Sk.ffi.err.argument('valueJs').inFunction('Sk.ffi.booleanToPy').mustHaveType([
      Sk.builtin.JsType.BOOLEAN,
      'null',
      Sk.builtin.JsType.UNDEFINED
    ].join(' or '));
  };
  goog.exportSymbol('Sk.ffi.booleanToPy', Sk.ffi.booleanToPy);
  Sk.ffi.numberToFloatPy = function (a, b) {
    var c = typeof a;
    if (c === Sk.builtin.JsType.NUMBER)
      return Sk.builtin.numberToPy(a);
    if (c === Sk.builtin.JsType.OBJECT && null === a)
      return Sk.builtin.none.none$;
    if (c === Sk.builtin.JsType.UNDEFINED) {
      c = typeof b;
      if (c === Sk.builtin.JsType.NUMBER)
        return Sk.ffi.numberToFloatPy(Number(b));
      if (c === Sk.builtin.JsType.UNDEFINED)
        return;
      if (c === Sk.builtin.JsType.OBJECT && null === b)
        return Sk.builtin.none.none$;
      throw Sk.ffi.err.argument('defaultJs').inFunction('Sk.ffi.numberToFloatPy').mustHaveType([
        Sk.builtin.JsType.NUMBER,
        'null',
        Sk.builtin.JsType.UNDEFINED
      ].join(' or '));
    }
    throw Sk.ffi.err.argument('valueJs').inFunction('Sk.ffi.numberToFloatPy').mustHaveType([
      Sk.builtin.JsType.NUMBER,
      'null',
      Sk.builtin.JsType.UNDEFINED
    ].join(' or '));
  };
  goog.exportSymbol('Sk.ffi.numberToFloatPy', Sk.ffi.numberToFloatPy);
  Sk.ffi.numberToIntPy = function (a, b) {
    var c = typeof a;
    if (c === Sk.builtin.JsType.NUMBER)
      return new Sk.builtin.NumberPy(a, Sk.builtin.NumberPy.int$);
    if (c === Sk.builtin.JsType.OBJECT && null === a)
      return Sk.builtin.none.none$;
    if (c === Sk.builtin.JsType.UNDEFINED) {
      c = typeof b;
      if (c === Sk.builtin.JsType.NUMBER)
        return Sk.ffi.numberToIntPy(Number(b));
      if (c === Sk.builtin.JsType.UNDEFINED)
        return;
      if (c === Sk.builtin.JsType.OBJECT && null === b)
        return Sk.builtin.none.none$;
      throw Sk.ffi.err.argument('defaultJs').inFunction('Sk.ffi.numberToIntPy').mustHaveType([
        Sk.builtin.JsType.NUMBER,
        'null',
        Sk.builtin.JsType.UNDEFINED
      ].join(' or '));
    }
    throw Sk.ffi.err.argument('valueJs').inFunction('Sk.ffi.numberToIntPy').mustHaveType([
      Sk.builtin.JsType.NUMBER,
      'null',
      Sk.builtin.JsType.UNDEFINED
    ].join(' or '));
  };
  goog.exportSymbol('Sk.ffi.numberToIntPy', Sk.ffi.numberToIntPy);
  Sk.ffi.referenceToPy = function (a, b, c, d) {
    var e = typeof a;
    if (e === Sk.builtin.JsType.OBJECT || e === Sk.builtin.JsType.FUNCTION)
      if (typeof b === Sk.builtin.JsType.STRING)
        if (d)
          d.v = a, d.tp$name = b, d.custom = c;
        else
          return {
            v: a,
            tp$name: b,
            custom: c
          };
      else
        throw Sk.ffi.assertionError('9fad4b9e-4845-4a06-9bce-0aa7c68e1f03 [className is ' + b + ']');
    else
      throw Sk.ffi.assertionError('306f31df-f0a9-40a0-895b-d01308df8d6e typeof valueJs => ' + e);
  };
  goog.exportSymbol('Sk.ffi.referenceToPy', Sk.ffi.referenceToPy);
  Sk.ffi.functionPy = function (a) {
    return new Sk.builtin.func(a);
  };
  goog.exportSymbol('Sk.ffi.functionPy', Sk.ffi.functionPy);
  Sk.ffi.listPy = function (a) {
    return new Sk.builtin.list(a);
  };
  goog.exportSymbol('Sk.ffi.listPy', Sk.ffi.listPy);
  Sk.ffi.tuplePy = function (a) {
    return new Sk.builtin.tuple(a);
  };
  goog.exportSymbol('Sk.ffi.tuplePy', Sk.ffi.tuplePy);
  Sk.ffi.remapToPy = function (a, b, c) {
    var d = typeof a;
    if (d === Sk.builtin.JsType.OBJECT)
      return '[object Array]' === Object.prototype.toString.call(a) ? new Sk.ffi.ObjectPy(a) : typeof b === Sk.builtin.JsType.STRING ? Sk.ffi.referenceToPy(a, b.toString(), c) : d === Sk.builtin.JsType.OBJECT && null === a ? Sk.builtin.none.none$ : new Sk.ffi.ObjectPy(a);
    if (d === Sk.builtin.JsType.STRING)
      return Sk.builtin.stringToPy(a);
    if (d === Sk.builtin.JsType.NUMBER)
      return Sk.builtin.numberToPy(a);
    if (d === Sk.builtin.JsType.BOOLEAN)
      return Sk.ffi.booleanToPy(a);
    if (d === Sk.builtin.JsType.FUNCTION)
      return Sk.ffi.functionPy(a);
    if (d === Sk.builtin.JsType.UNDEFINED)
      return Sk.builtin.none.none$;
    throw Sk.ffi.assertionError('d39f7c01-213e-4ded-9e5c-209a2dc94b4c, typeof valueJs => ' + d);
  };
  goog.exportSymbol('Sk.ffi.remapToPy', Sk.ffi.remapToPy);
  Sk.ffi.isBool = function (a) {
    return Sk.ffi.getType(a) === Sk.ffi.PyType.BOOL;
  };
  goog.exportSymbol('Sk.ffi.isBool', Sk.ffi.isBool);
  Sk.ffi.isInstance = function (a, b) {
    if (Sk.ffi.getType(a) === Sk.ffi.PyType.INSTANCE) {
      var c = typeof b;
      if (c === Sk.builtin.JsType.STRING)
        return Sk.ffi.typeName(a) === b;
      if (c === Sk.builtin.JsType.UNDEFINED)
        return !0;
      if ('[object Array]' === Object.prototype.toString.call(b)) {
        var d = Sk.ffi.typeName(a);
        return b.some(function (a) {
          return d === a;
        });
      }
      throw Sk.ffi.assertionError('caa41602-62da-4850-8f76-38d013f45a6c, typeof className => ' + c);
    }
    return !1;
  };
  goog.exportSymbol('Sk.ffi.isInstance', Sk.ffi.isInstance);
  Sk.ffi.isDefined = function (a) {
    return Sk.ffi.getType(a) !== Sk.ffi.PyType.UNDEFINED;
  };
  goog.exportSymbol('Sk.ffi.isDefined', Sk.ffi.isDefined);
  Sk.ffi.isObjectPy = function (a) {
    return Sk.ffi.getType(a) === Sk.ffi.PyType.OBJECT;
  };
  goog.exportSymbol('Sk.ffi.isObjectPy', Sk.ffi.isObjectPy);
  Sk.ffi.isDict = function (a) {
    return Sk.ffi.getType(a) === Sk.ffi.PyType.DICT;
  };
  goog.exportSymbol('Sk.ffi.isDict', Sk.ffi.isDict);
  Sk.ffi.isList = function (a) {
    return Sk.ffi.getType(a) === Sk.ffi.PyType.LIST;
  };
  goog.exportSymbol('Sk.ffi.isList', Sk.ffi.isList);
  Sk.ffi.isTuple = function (a) {
    return Sk.ffi.getType(a) === Sk.ffi.PyType.TUPLE;
  };
  goog.exportSymbol('Sk.ffi.isTuple', Sk.ffi.isTuple);
  Sk.ffi.isFloat = function (a) {
    return Sk.ffi.getType(a) === Sk.ffi.PyType.FLOAT;
  };
  goog.exportSymbol('Sk.ffi.isFloat', Sk.ffi.isFloat);
  Sk.ffi.isFunction = function (a) {
    return Sk.ffi.getType(a) === Sk.ffi.PyType.FUNCTION;
  };
  goog.exportSymbol('Sk.ffi.isFunction', Sk.ffi.isFunction);
  Sk.ffi.isFunctionRef = function (a) {
    return Sk.ffi.getType(a) === Sk.ffi.PyType.FUNREF;
  };
  goog.exportSymbol('Sk.ffi.isFunctionRef', Sk.ffi.isFunctionRef);
  Sk.ffi.isInt = function (a) {
    return Sk.ffi.getType(a) === Sk.ffi.PyType.INT;
  };
  goog.exportSymbol('Sk.ffi.isInt', Sk.ffi.isInt);
  Sk.ffi.isLong = function (a) {
    return Sk.ffi.getType(a) === Sk.ffi.PyType.LONG;
  };
  goog.exportSymbol('Sk.ffi.isLong', Sk.ffi.isLong);
  Sk.ffi.isBigInteger = function (a) {
    return a instanceof Sk.builtin.biginteger;
  };
  goog.exportSymbol('Sk.ffi.isBigInteger', Sk.ffi.isBigInteger);
  Sk.ffi.isNone = function (a) {
    return Sk.ffi.getType(a) === Sk.ffi.PyType.NONE;
  };
  goog.exportSymbol('Sk.ffi.isNone', Sk.ffi.isNone);
  Sk.ffi.isNum = function (a) {
    return a instanceof Sk.builtin.NumberPy ? !0 : Sk.ffi.isFloat(a) || Sk.ffi.isInt(a) || Sk.ffi.isLong(a);
  };
  goog.exportSymbol('Sk.ffi.isNum', Sk.ffi.isNum);
  Sk.ffi.isUndefined = function (a) {
    return Sk.ffi.getType(a) === Sk.ffi.PyType.UNDEFINED;
  };
  goog.exportSymbol('Sk.ffi.isUndefined', Sk.ffi.isUndefined);
  Sk.ffi.checkFunctionArgs = function (a, b, c, d, e, f) {
    b = b.length;
    var g = '';
    void 0 === d && (d = Infinity);
    e && (b -= 1);
    f && (b -= 1);
    if (b < c || b > d)
      throw g = (c === d ? a + ' takes exactly ' + c + ' arguments' : b < c ? a + ' takes at least ' + c + ' arguments' : a + ' takes at most ' + d + ' arguments') + (' (' + b + ' given)'), Sk.ffi.assertionError(g);
    return b;
  };
  goog.exportSymbol('Sk.ffi.checkFunctionArgs', Sk.ffi.checkFunctionArgs);
  Sk.ffi.checkMethodArgs = function (a, b, c, d, e, f) {
    return Sk.ffi.checkFunctionArgs(a, Array.prototype.slice.call(b, 1), c, d, e, f);
  };
  goog.exportSymbol('Sk.ffi.checkMethodArgs', Sk.ffi.checkMethodArgs);
  goog.exportSymbol('Sk.ffi.SimpleType', Sk.ffi.SimpleType);
  goog.exportSymbol('Sk.ffi.UnionType', Sk.ffi.UnionType);
  Sk.ffi.checkArgType = function (a, b, c, d) {
    if (!c)
      throw Sk.ffi.err.argument(a).mustHaveType(b);
  };
  goog.exportSymbol('Sk.ffi.checkArgType', Sk.ffi.checkArgType);
  Sk.ffi.checkLhsOperandType = function (a, b, c, d) {
    if (!c)
      throw Sk.ffi.err.operand('Left').toOperation(a).mustHaveType(b);
  };
  goog.exportSymbol('Sk.ffi.checkLhsOperandType', Sk.ffi.checkLhsOperandType);
  Sk.ffi.checkRhsOperandType = function (a, b, c, d) {
    if (!c)
      throw Sk.ffi.err.operand('Right').toOperation(a).mustHaveType(b);
  };
  goog.exportSymbol('Sk.ffi.checkRhsOperandType', Sk.ffi.checkRhsOperandType);
  Sk.ffi.PyType = {
    OBJECT: 1,
    DICT: 2,
    LIST: 3,
    TUPLE: 4,
    BOOL: 5,
    FLOAT: 6,
    INT: 7,
    LONG: 8,
    STR: 9,
    NONE: 10,
    FUNCTION: 11,
    INSTANCE: 12,
    UNDEFINED: -1,
    FUNREF: -2
  };
  Sk.ffi.typeString = function (a, b) {
    function c(a) {
      return '<type \'' + a + '\'>';
    }
    function d(a) {
      switch (a) {
      case Sk.ffi.PyType.OBJECT:
        return c('object');
      case Sk.ffi.PyType.DICT:
        return c('dict');
      case Sk.ffi.PyType.LIST:
        return c('list');
      case Sk.ffi.PyType.TUPLE:
        return c('tuple');
      case Sk.ffi.PyType.BOOL:
        return c('bool');
      case Sk.ffi.PyType.FLOAT:
        return c('float');
      case Sk.ffi.PyType.LONG:
        return c('long');
      case Sk.ffi.PyType.INT:
        return c('int');
      case Sk.ffi.PyType.STR:
        return c('str');
      case Sk.ffi.PyType.NONE:
        return c('NoneType');
      case Sk.ffi.PyType.FUNCTION:
        return c('function');
      default:
        throw Sk.ffi.assertionError('fe2aed99-3b81-4a55-b3e8-61da7e734ac1, kind => ' + a);
      }
    }
    if (typeof a === Sk.builtin.JsType.STRING)
      return '<class \'' + String(a) + '\'>';
    if (typeof a === Sk.builtin.JsType.NUMBER)
      switch (a) {
      case Sk.ffi.PyType.OBJECT:
      case Sk.ffi.PyType.DICT:
      case Sk.ffi.PyType.LIST:
      case Sk.ffi.PyType.TUPLE:
      case Sk.ffi.PyType.BOOL:
      case Sk.ffi.PyType.FLOAT:
      case Sk.ffi.PyType.LONG:
      case Sk.ffi.PyType.INT:
      case Sk.ffi.PyType.STR:
      case Sk.ffi.PyType.NONE:
      case Sk.ffi.PyType.FUNCTION:
        return d(a);
      case Sk.ffi.PyType.INSTANCE:
        return '<class \'' + String(b) + '\'>';
      default:
        throw Sk.ffi.assertionError('b15da19c-b080-4695-a157-cfcb740b265b, kind => ' + a);
      }
    else {
      if ('[object Array]' === Object.prototype.toString.call(a))
        return a.map(function (a) {
          return Sk.ffi.typeString(a);
        }).join(' or ');
      throw Sk.ffi.assertionError('c32e2f75-a391-49aa-b567-b376955b4b4c, typeof kind => ' + typeof a);
    }
  };
  goog.exportSymbol('Sk.ffi.typeString', Sk.ffi.typeString);
  Sk.ffi.getType = function (a) {
    if (Sk.flyweight && typeof a === Sk.builtin.JsType.NUMBER)
      return Sk.ffi.PyType.FLOAT;
    if (typeof a === Sk.builtin.JsType.UNDEFINED)
      return Sk.ffi.PyType.UNDEFINED;
    if (a instanceof Sk.ffi.ObjectPy)
      return Sk.ffi.PyType.OBJECT;
    if (a instanceof Sk.builtin.object)
      throw Error('Ooch - object');
    if (a instanceof Sk.builtin.dict)
      return Sk.ffi.PyType.DICT;
    if (a instanceof Sk.builtin.list)
      return Sk.ffi.PyType.LIST;
    if (a instanceof Sk.builtin.tuple)
      return Sk.ffi.PyType.TUPLE;
    if (a instanceof Sk.builtin.NumberPy)
      if (a.skType === Sk.builtin.NumberPy.float$)
        if (Sk.flyweight)
          goog.asserts.assertNumber(a, 'You\'re kidding me?');
        else
          return Sk.ffi.PyType.FLOAT;
      else {
        if (a.skType === Sk.builtin.NumberPy.int$)
          return Sk.ffi.PyType.INT;
        throw Sk.ffi.assertionError('typeofPy(' + a + ') (Sk.builtin.NumberPy) skType=' + a.skType);
      }
    else {
      if (a instanceof Sk.builtin.lng)
        return Sk.ffi.PyType.LONG;
      if (a === Sk.builtin.bool.true$ || a === Sk.builtin.bool.false$)
        return Sk.ffi.PyType.BOOL;
      if (a === Sk.builtin.none.none$)
        return Sk.ffi.PyType.NONE;
      var b = typeof a.v;
      if (b !== Sk.builtin.JsType.UNDEFINED) {
        if (b === Sk.builtin.JsType.STRING)
          return Sk.ffi.PyType.STR;
        if (b === Sk.builtin.JsType.OBJECT) {
          if (a.tp$name)
            return Sk.ffi.PyType.INSTANCE;
          throw Sk.ffi.assertionError('0a459acc-9540-466b-ba1a-333f8215b61e');
        }
        if (b === Sk.builtin.JsType.FUNCTION)
          return Sk.ffi.PyType.FUNREF;
        throw Sk.ffi.assertionError('bb971bb0-3751-49bb-ac24-8dab8a4bcd29 (x:\'' + b + '\')');
      }
      return Sk.ffi.PyType.FUNCTION;
    }
  };
  goog.exportSymbol('Sk.ffi.getType', Sk.ffi.getType);
  Sk.ffi.typeName = function (a) {
    return Sk.flyweight && typeof a === Sk.builtin.JsType.NUMBER ? 'float' : a instanceof Sk.builtin.NumberPy ? a.skType : void 0 !== a.tp$name ? a.tp$name : '<invalid type>';
  };
  goog.exportSymbol('Sk.ffi.typeName', Sk.ffi.typeName);
  Sk.ffi.booleanToJs = function (a, b) {
    if (a === Sk.builtin.bool.true$)
      return !0;
    if (a === Sk.builtin.bool.false$)
      return !1;
    if (typeof b === Sk.builtin.JsType.STRING)
      throw Sk.ffi.typeError(String(b));
    throw Sk.ffi.err.attribute('value').mustHaveType(Sk.ffi.PyType.BOOL);
  };
  goog.exportSymbol('Sk.ffi.booleanToJs', Sk.ffi.booleanToJs);
  Sk.ffi.numberToJs = function (a, b) {
    if (a instanceof Sk.builtin.NumberPy)
      return Sk.builtin.asnum$(a);
    if (typeof b === Sk.builtin.JsType.STRING)
      throw Sk.ffi.typeError(String(b));
    throw Sk.ffi.err.attribute('value').mustHaveType([
      Sk.ffi.PyType.FLOAT,
      Sk.ffi.PyType.INT,
      Sk.ffi.PyType.LONG
    ]);
  };
  goog.exportSymbol('Sk.ffi.numberToJs', Sk.ffi.numberToJs);
  Sk.ffi.remapToJs = function (a, b) {
    Sk.ffi.checkFunctionArgs('Sk.ffi.remapToJs', arguments, 1, 2);
    if (Sk.flyweight && typeof a === Sk.builtin.JsType.NUMBER)
      return a;
    switch (Sk.ffi.getType(a)) {
    case Sk.ffi.PyType.STR:
      return Sk.builtin.stringToJs(a);
    case Sk.ffi.PyType.OBJECT:
      return a.v;
    case Sk.ffi.PyType.DICT:
      for (var c = {}, d = a.tp$iter(), e = d.tp$iternext(); void 0 !== e; e = d.tp$iternext()) {
        var f = a.mp$subscript(e);
        void 0 === f && (f = null);
        e = Sk.ffi.remapToJs(e);
        c[e] = Sk.ffi.remapToJs(f);
      }
      return c;
    case Sk.ffi.PyType.LIST:
      if (b)
        return a.v;
      c = [];
      for (d = 0; d < a.v.length; ++d)
        c.push(Sk.ffi.remapToJs(a.v[d]));
      return c;
    case Sk.ffi.PyType.TUPLE:
      c = [];
      for (d = 0; d < a.v.length; ++d)
        c.push(Sk.ffi.remapToJs(a.v[d]));
      return c;
    case Sk.ffi.PyType.BOOL:
      if (a === Sk.builtin.bool.true$)
        return !0;
      if (a === Sk.builtin.bool.false$)
        return !1;
      throw Sk.ffi.assertionError('5fd1f529-f9b2-4d0c-9775-36e782973986');
    case Sk.ffi.PyType.FLOAT:
      if (Sk.flyweight)
        goog.asserts.assertNumber(a, '5fd1f529-f9b2-4d0c-9775-36e782973986');
      else
        return Sk.builtin.asnum$(a);
    case Sk.ffi.PyType.INT:
    case Sk.ffi.PyType.LONG:
      return Sk.builtin.asnum$(a);
    case Sk.ffi.PyType.INSTANCE:
      return a.v;
    case Sk.ffi.PyType.FUNREF:
      return a.v;
    case Sk.ffi.PyType.UNDEFINED:
      break;
    case Sk.ffi.PyType.NONE:
      return null;
    case Sk.ffi.PyType.FUNCTION:
      return function () {
        var b = Array.prototype.slice.call(arguments, 0).map(function (a) {
            return Sk.ffi.remapToPy(a);
          });
        return Sk.ffi.remapToJs(Sk.misceval.apply(a, void 0, void 0, void 0, b));
      };
    default:
      throw Sk.ffi.assertionError('20be4da2-63e8-4fff-9359-7ab46eba4702 ' + Sk.ffi.getType(a));
    }
  };
  goog.exportSymbol('Sk.ffi.remapToJs', Sk.ffi.remapToJs);
  Sk.ffi.customToJs = function (a) {
    return a.custom;
  };
  goog.exportSymbol('Sk.ffi.customToJs', Sk.ffi.customToJs);
  Sk.ffi.buildClass = function (a, b, c, d) {
    return Sk.misceval.buildClass(a, b, c, d);
  };
  goog.exportSymbol('Sk.ffi.buildClass', Sk.ffi.buildClass);
  Sk.ffi.callsim = function (a, b) {
    var c = Array.prototype.slice.call(arguments, 1);
    return Sk.misceval.apply(a, void 0, void 0, void 0, c);
  };
  goog.exportSymbol('Sk.ffi.callsim', Sk.ffi.callsim);
  Sk.ffi.callableToPy = function (a, b, c) {
    return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, e) {
      e.__init__ = Sk.ffi.functionPy(function (a) {
        Sk.ffi.referenceToPy(null, b, null, a);
      });
      e.__call__ = Sk.ffi.functionPy(c);
      e.__str__ = Sk.ffi.functionPy(function (a) {
        return Sk.builtin.stringToPy(b);
      });
      e.__repr__ = Sk.ffi.functionPy(function (a) {
        return Sk.builtin.stringToPy(b);
      });
    }, b, []));
  };
  goog.exportSymbol('Sk.ffi.callableToPy', Sk.ffi.callableToPy);
  Sk.ffi.gattr = function (a, b) {
    return Sk.abstr.gattr(a, b);
  };
  goog.exportSymbol('Sk.ffi.gattr', Sk.ffi.gattr);
  Sk.ffi.sattr = function (a, b, c) {
    return Sk.abstr.sattr(a, b, c);
  };
  goog.exportSymbol('Sk.ffi.sattr', Sk.ffi.sattr);
  Sk.ffi.indexError = function (a) {
    return new Sk.builtin.IndexError(a);
  };
  goog.exportSymbol('Sk.ffi.indexError', Sk.ffi.indexError);
  Sk.ffi.valueError = function (a) {
    return new Sk.builtin.ValueError(a);
  };
  goog.exportSymbol('Sk.ffi.valueError', Sk.ffi.valueError);
  Sk.ffi.err = {
    attribute: function (a) {
      return {
        isNotGetableOnType: function (b) {
          return Sk.ffi.attributeError(a + ' is not an attribute of ' + Sk.ffi.typeString(b));
        },
        isNotSetableOnType: function (b) {
          return Sk.ffi.attributeError(a + ' is not an attribute of ' + Sk.ffi.typeString(b));
        }
      };
    },
    argument: function (a) {
      return {
        inFunction: function (b) {
          return {
            mustHaveType: function (c) {
              return Sk.ffi.typeError('Expecting argument \'' + a + '\' in function \'' + b + '\' to have type ' + Sk.ffi.typeString(c) + '.');
            }
          };
        },
        mustHaveType: function (b) {
          return Sk.ffi.typeError(a + ' must be a ' + Sk.ffi.typeString(b));
        }
      };
    },
    operand: function (a) {
      return {
        toOperation: function (b) {
          return {
            mustHaveType: function (c) {
              return Sk.ffi.typeError('Expecting operand \'' + a + '\' to operation \'' + b + '\' to have type ' + Sk.ffi.typeString(c) + '.');
            }
          };
        }
      };
    }
  };
  goog.exportSymbol('Sk.ffi.err', Sk.ffi.err);
  Sk.ffi.ObjectPy = function (a) {
    this.v = a;
  };
  Sk.ffi.ObjectPy.prototype.tp$getattr = function (a) {
    goog.asserts.assertString(a);
    goog.asserts.assert(void 0 !== this.ob$type, 'object has no ob$type!');
    var b = this.v, c = this.v[a];
    switch (typeof c) {
    case 'function':
      return new Sk.ffi.CallablePy(this.v, a);
    case 'number':
      return Sk.ffi.numberToFloatPy(c);
    case 'object':
      return new Sk.ffi.ObjectPy(c);
    case 'boolean':
      return Sk.ffi.booleanToPy(c);
    case 'undefined':
      switch (a) {
      case 'append':
        return new Sk.builtin.func(function (a) {
          Sk.builtin.pyCheckArgs('append', arguments, 1, 1);
          b.push(Sk.ffi.remapToJs(a));
          return Sk.builtin.none.none$;
        });
      default:
        return Sk.builtin.none.none$;
      }
    default:
      return goog.asserts.assertString(c), Sk.builtin.stringToPy(c);
    }
  };
  Sk.ffi.ObjectPy.prototype.tp$setattr = function (a, b) {
    goog.asserts.assert('string' === typeof a);
    this.v[a] = Sk.ffi.remapToJs(b);
  };
  Sk.ffi.ObjectPy.prototype.mp$subscript = function (a) {
    if (!Array.isArray(this.v))
      throw new Sk.builtin.TypeError('\'' + Sk.ffi.typeName(this) + '\' object does not support indexing.');
    if (Sk.misceval.isIndex(a)) {
      var b = Sk.misceval.asIndex(a);
      if (void 0 !== b) {
        0 > b && (b = this.v.length + b);
        if (0 > b || b >= this.v.length)
          throw new Sk.builtin.IndexError('list index out of range');
        return Sk.ffi.remapToPy(this.v[b]);
      }
    } else if (a instanceof Sk.builtin.slice) {
      var c = [];
      a.sssiter$(this, function (a, b) {
        c.push(b.v[a]);
      });
      return new Sk.builtin.list(c);
    }
    throw new Sk.builtin.TypeError('list indices must be integers, not ' + Sk.ffi.typeName(a));
  };
  Sk.ffi.ObjectPy.prototype.tp$iter = function () {
    var a = {
        tp$iter: function () {
          return a;
        },
        $obj: this,
        $index: 0,
        tp$iternext: function () {
          return a.$index >= a.$obj.v.length ? void 0 : Sk.ffi.remapToPy(a.$obj.v[a.$index++]);
        }
      };
    return a;
  };
  Sk.ffi.ObjectPy.prototype.sq$length = function () {
    if (!Array.isArray(this.v))
      throw new Sk.builtin.TypeError('\'' + Sk.ffi.typeName(this) + '\' object does not support len().');
    return this.v.length;
  };
  Sk.ffi.ObjectPy.prototype.tp$name = 'ObjectPy';
  Sk.ffi.ObjectPy.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj('ObjectPy', Sk.ffi.ObjectPy);
  Sk.ffi.ObjectPy.prototype.tp$str = function () {
    return Sk.builtin.stringToPy('' + this.v);
  };
  Sk.ffi.ObjectPy.prototype.tp$repr = function () {
    return Sk.builtin.stringToPy('' + this.v);
  };
  Sk.ffi.ObjectPy.prototype.nb$add = function (a) {
    return Sk.ffi.remapToPy(this.v.add(Sk.ffi.remapToJs(a)));
  };
  Sk.ffi.ObjectPy.prototype.nb$sub = function (a) {
    return Sk.ffi.remapToPy(this.v.sub(Sk.ffi.remapToJs(a)));
  };
  Sk.ffi.ObjectPy.prototype.nb$mul = function (a) {
    return Sk.ffi.remapToPy(this.v.mul(Sk.ffi.remapToJs(a)));
  };
  Sk.ffi.ObjectPy.prototype.nb$div = function (a) {
    return Sk.ffi.remapToPy(this.v.div(Sk.ffi.remapToJs(a)));
  };
  goog.exportSymbol('Sk.ffi.ObjectPy', Sk.ffi.ObjectPy);
  Sk.ffi.CallablePy = function (a, b) {
    this.v = a;
    this.name = b;
  };
  Sk.ffi.CallablePy.prototype.tp$call = function (a, b) {
    var c = this.v, d = this.name, e = c[d], f = a.map(function (a) {
        return Sk.ffi.remapToJs(a);
      });
    d = 'Value' === d || 'X' === d || 'Y' === d ? !1 : d[0] === d[0].toUpperCase() ? !0 : !1;
    if (d) {
      c = function () {
        var a = Object.create(e.prototype), b = e.apply(a, f);
        return Sk.ffi.remapToPy('object' === typeof b && b || a);
      };
      try {
        switch (f.length) {
        case 0:
          var g = new e();
          return Sk.ffi.remapToPy(g);
        case 1:
          return g = new e(f[0]), Sk.ffi.remapToPy(g);
        case 2:
          return g = new e(f[0], f[1]), Sk.ffi.remapToPy(g);
        case 3:
          return g = new e(f[0], f[1], f[2]), Sk.ffi.remapToPy(g);
        case 4:
          return g = new e(f[0], f[1], f[2], f[3]), Sk.ffi.remapToPy(g);
        case 5:
          return g = new e(f[0], f[1], f[2], f[3], f[4]), Sk.ffi.remapToPy(g);
        case 6:
          return g = new e(f[0], f[1], f[2], f[3], f[4], f[5]), Sk.ffi.remapToPy(g);
        case 7:
          return g = new e(f[0], f[1], f[2], f[3], f[4], f[5], f[6]), Sk.ffi.remapToPy(g);
        default:
          return c();
        }
      } catch (h) {
        return c();
      }
    } else
      return Sk.ffi.remapToPy(e.apply(c, f));
  };
  Sk.ffi.promoteIntToLong = function (a) {
    goog.asserts.assert(Sk.ffi.isInt(a));
    a = Sk.ffi.remapToJs(a);
    goog.asserts.assertNumber(a);
    return new Sk.builtin.lng(a);
  };
  goog.exportSymbol('Sk.ffi.promoteIntToLong', Sk.ffi.promoteIntToLong);
  Sk.ffi.longFromString = function (a, b) {
    goog.asserts.assertString(a, 's must be a string');
    var c = Sk.str2number(a, b, function (a, b) {
        return 10 == b ? new Sk.builtin.biginteger(a) : new Sk.builtin.biginteger(a, b);
      }, function (a) {
        return a.negate();
      }, 'long');
    return new Sk.builtin.lng(c);
  };
  goog.exportSymbol('Sk.ffi.longFromString', Sk.ffi.longFromString);
  Sk.ffi.MAX_INT = new Sk.builtin.lng(+Sk.builtin.lng.threshold$);
  goog.exportSymbol('Sk.ffi.MIN_INT', Sk.ffi.MIN_INT);
  Sk.ffi.MIN_INT = new Sk.builtin.lng(-Sk.builtin.lng.threshold$);
  goog.exportSymbol('Sk.ffi.MAX_INT', Sk.ffi.MAX_INT);
  Sk.ffh = Sk.ffh || {};
  var SPECIAL_METHOD_ADD = '__add__', SPECIAL_METHOD_CLIFFORD_CONJUGATE = '__cliffordConjugate__', SPECIAL_METHOD_CONJUGATE = '__conjugate__', SPECIAL_METHOD_EQ = '__eq__', SPECIAL_METHOD_EXP = '__exp__', SPECIAL_METHOD_GETITEM = '__getitem__', SPECIAL_METHOD_INVERT = '__invert__', SPECIAL_METHOD_LSHIFT = '__lshift__', SPECIAL_METHOD_MUL = '__mul__', SPECIAL_METHOD_NEG = '__neg__', SPECIAL_METHOD_NONZERO = '__nonzero__', SPECIAL_METHOD_POS = '__pos__', SPECIAL_METHOD_REPR = '__repr__', SPECIAL_METHOD_RMUL = '__rmul__', SPECIAL_METHOD_RSHIFT = '__rshift__', SPECIAL_METHOD_STR = '__str__', SPECIAL_METHOD_SUB = '__sub__', SPECIAL_METHOD_XOR = '__xor__';
  Sk.ffh.unaryExec = function (a, b, c, d) {
    if (c[b])
      return Sk.ffi.callsim(c[b], c);
    if ('undefined' !== typeof d && c[d])
      return c[d].call(c);
    throw Sk.ffi.typeError(a + '(' + Sk.ffi.remapToJs(Sk.ffh.repr(c)) + ')');
  };
  goog.exportSymbol('Sk.ffh.unaryExec', Sk.ffh.unaryExec);
  Sk.ffh.getitem = function (a, b) {
    if (a[SPECIAL_METHOD_GETITEM])
      return Sk.ffi.callsim(a[SPECIAL_METHOD_GETITEM], a, Sk.ffi.numberToIntPy(b));
    throw Sk.ffi.notImplementedError(SPECIAL_METHOD_GETITEM);
  };
  goog.exportSymbol('Sk.ffh.getitem', Sk.ffh.getitem);
  Sk.ffh.add = function (a, b) {
    return Sk.abstr.numberBinOp(a, b, 'Add');
  };
  goog.exportSymbol('Sk.ffh.add', Sk.ffh.add);
  Sk.ffh.sub = function (a, b) {
    return Sk.abstr.numberBinOp(a, b, 'Sub');
  };
  goog.exportSymbol('Sk.ffh.sub', Sk.ffh.sub);
  Sk.ffh.mul = function (a, b) {
    return Sk.abstr.numberBinOp(a, b, 'Mult');
  };
  goog.exportSymbol('Sk.ffh.mul', Sk.ffh.mul);
  Sk.ffh.div = function (a, b) {
    return Sk.abstr.numberBinOp(a, b, 'Div');
  };
  goog.exportSymbol('Sk.ffh.div', Sk.ffh.div);
  Sk.ffh.mod = function (a, b) {
    return Sk.abstr.numberBinOp(a, b, 'Mod');
  };
  goog.exportSymbol('Sk.ffh.mod', Sk.ffh.mod);
  Sk.ffh.xor = function (a, b) {
    return Sk.abstr.numberBinOp(a, b, 'BitXor');
  };
  goog.exportSymbol('Sk.ffh.xor', Sk.ffh.xor);
  Sk.ffh.lshift = function (a, b) {
    return Sk.abstr.numberBinOp(a, b, 'LShift');
  };
  goog.exportSymbol('Sk.ffh.lshift', Sk.ffh.lshift);
  Sk.ffh.rshift = function (a, b) {
    return Sk.abstr.numberBinOp(a, b, 'RShift');
  };
  goog.exportSymbol('Sk.ffh.rshift', Sk.ffh.rshift);
  Sk.ffh.pow = function (a, b) {
    return Sk.abstr.numberBinOp(a, b, 'Pow');
  };
  goog.exportSymbol('Sk.ffh.rshift', Sk.ffh.rshift);
  Sk.ffh.eq = function (a, b) {
    return Sk.builtin.bool(Sk.misceval.richCompareBool(a, b, Sk.misceval.compareOp.Eq));
  };
  goog.exportSymbol('Sk.ffh.eq', Sk.ffh.eq);
  Sk.ffh.lt = function (a, b) {
    return Sk.builtin.bool(Sk.misceval.richCompareBool(a, b, Sk.misceval.compareOp.Lt));
  };
  goog.exportSymbol('Sk.ffh.lt', Sk.ffh.lt);
  Sk.ffh.le = function (a, b) {
    return Sk.builtin.bool(Sk.misceval.richCompareBool(a, b, Sk.misceval.compareOp.LtE));
  };
  goog.exportSymbol('Sk.ffh.le', Sk.ffh.le);
  Sk.ffh.gt = function (a, b) {
    return Sk.builtin.bool(Sk.misceval.richCompareBool(a, b, Sk.misceval.compareOp.Gt));
  };
  goog.exportSymbol('Sk.ffh.gt', Sk.ffh.gt);
  Sk.ffh.ge = function (a, b) {
    return Sk.builtin.bool(Sk.misceval.richCompareBool(a, b, Sk.misceval.compareOp.GtE));
  };
  goog.exportSymbol('Sk.ffh.ge', Sk.ffh.ge);
  Sk.ffh.ne = function (a, b) {
    return Sk.builtin.bool(Sk.misceval.richCompareBool(a, b, Sk.misceval.compareOp.NotEq));
  };
  goog.exportSymbol('Sk.ffh.ne', Sk.ffh.ne);
  Sk.ffh.cliffordConjugate = function (a) {
    return Sk.ffh.unaryExec('', SPECIAL_METHOD_CLIFFORD_CONJUGATE, a, 'nb$cliffordConjugate');
  };
  goog.exportSymbol('Sk.ffh.cliffordConjugate', Sk.ffh.cliffordConjugate);
  Sk.ffh.conjugate = function (a) {
    return Sk.ffi.isNum(a) ? a : Sk.ffh.unaryExec('', SPECIAL_METHOD_CONJUGATE, a);
  };
  goog.exportSymbol('Sk.ffh.conjugate', Sk.ffh.conjugate);
  Sk.ffh.cos = function (a) {
    return Sk.ffh.unaryExec('cos', '__cos__', a, 'u$cos');
  };
  goog.exportSymbol('Sk.ffh.cos', Sk.ffh.cos);
  Sk.ffh.sin = function (a) {
    return Sk.ffh.unaryExec('sin', '__sin__', a, 'u$sin');
  };
  goog.exportSymbol('Sk.ffh.sin', Sk.ffh.sin);
  Sk.ffh.tan = function (a) {
    return Sk.ffh.unaryExec('tan', '__tan__', a, 'u$tan');
  };
  goog.exportSymbol('Sk.ffh.tan', Sk.ffh.tan);
  Sk.ffh.acos = function (a) {
    return Sk.ffh.unaryExec('acos', '__acos__', a, 'u$acos');
  };
  goog.exportSymbol('Sk.ffh.acos', Sk.ffh.acos);
  Sk.ffh.asin = function (a) {
    return Sk.ffh.unaryExec('asin', '__asin__', a, 'u$asin');
  };
  goog.exportSymbol('Sk.ffh.asin', Sk.ffh.asin);
  Sk.ffh.atan = function (a) {
    return Sk.ffh.unaryExec('atan', '__atan__', a, 'u$atan');
  };
  goog.exportSymbol('Sk.ffh.atan', Sk.ffh.atan);
  Sk.ffh.exp = function (a) {
    return Sk.ffh.unaryExec('exp', SPECIAL_METHOD_EXP, a, 'u$exp');
  };
  goog.exportSymbol('Sk.ffh.exp', Sk.ffh.exp);
  Sk.ffh.positive = function (a) {
    return Sk.ffi.isFloat(a) ? a : Sk.abstr.numberUnaryOp(a, Sk.abstr.unaryOp.UAdd);
  };
  goog.exportSymbol('Sk.ffh.positive', Sk.ffh.positive);
  Sk.ffh.negative = function (a) {
    return Sk.ffi.isFloat(a) ? (a = Sk.ffi.remapToJs(a), Sk.builtin.numberToPy(-a)) : Sk.abstr.numberUnaryOp(a, Sk.abstr.unaryOp.USub);
  };
  goog.exportSymbol('Sk.ffh.negative', Sk.ffh.negative);
  Sk.ffh.invert = function (a) {
    return Sk.ffh.unaryExec('~', SPECIAL_METHOD_INVERT, a, 'nb$invert');
  };
  goog.exportSymbol('Sk.ffh.invert', Sk.ffh.invert);
  Sk.ffh.nonzero = function (a) {
    return Sk.ffi.isFloat(a) ? (a = Sk.ffi.remapToJs(a), Sk.ffi.booleanToPy(0 !== a)) : Sk.ffh.unaryExec('', SPECIAL_METHOD_NONZERO, a, 'nb$nonzero');
  };
  goog.exportSymbol('Sk.ffh.nonzero', Sk.ffh.nonzero);
  Sk.ffh.abs = function (a) {
    return Sk.ffh.unaryExec('abs', '__abs__', a, 'u$abs');
  };
  goog.exportSymbol('Sk.ffh.abs', Sk.ffh.abs);
  Sk.ffh.magnitude = function (a) {
    return Sk.ffh.unaryExec('magnitude', '__magnitude__', a, 'u$magnitude');
  };
  goog.exportSymbol('Sk.ffh.magnitude', Sk.ffh.magnitude);
  Sk.ffh.quadrance = function (a) {
    return Sk.ffh.unaryExec('quadrance', '__quadrance__', a, 'u$quadrance');
  };
  goog.exportSymbol('Sk.ffh.quadrance', Sk.ffh.quadrance);
  Sk.ffh.sqrt = function (a) {
    return Sk.ffh.unaryExec('sqrt', '__sqrt__', a, 'u$sqrt');
  };
  goog.exportSymbol('Sk.ffh.sqrt', Sk.ffh.sqrt);
  Sk.ffh.str = function (a) {
    if (Sk.flyweight && Sk.ffi.isFloat(a))
      return Sk.builtin.stringToPy(Sk.builtin.numberToFloatStringJs(a, 10, !0));
    if (a[SPECIAL_METHOD_STR])
      return Sk.ffi.callsim(a[SPECIAL_METHOD_STR], a);
    if (a.tp$str)
      return a.tp$str.call(a);
    if (a.tp$repr)
      return a.tp$repr.call(a);
    throw Sk.ffi.notImplementedError('str');
  };
  goog.exportSymbol('Sk.ffh.str', Sk.ffh.str);
  Sk.ffh.repr = function (a) {
    if (Sk.flyweight && Sk.ffi.isFloat(a))
      return Sk.builtin.stringToPy(Sk.builtin.numberToFloatStringJs(a, 10, !0));
    if (a[SPECIAL_METHOD_REPR])
      return Sk.ffi.callsim(a[SPECIAL_METHOD_REPR], a);
    if (a.tp$repr)
      return a.tp$repr.call(a);
    throw Sk.ffi.notImplementedError('repr');
  };
  goog.exportSymbol('Sk.ffh.repr', Sk.ffh.repr);
  Sk.ffh.evaluate = function (a, b) {
    return Sk.ffi.isFloat(a) || Sk.ffi.isInt(a) || Sk.ffi.isLong(a) ? a : Sk.ffi.callsim(Sk.ffi.gattr(a, 'evaluate'), b);
  };
  goog.exportSymbol('Sk.ffh.evaluate', Sk.ffh.evaluate);
  Sk.ffi.promoteLongToFloat = function (a) {
    goog.asserts.assert(Sk.ffi.isLong(a));
    a = Sk.ffh.str(a);
    a = Sk.ffi.remapToJs(a);
    goog.asserts.assertString(a);
    a = parseFloat(a);
    goog.asserts.assertNumber(a);
    return Sk.builtin.numberToPy(a);
  };
  goog.exportSymbol('Sk.ffi.promoteLongToFloat', Sk.ffi.promoteLongToFloat);
  Sk.builtin.enumerate = function (a, b) {
    if (!(this instanceof Sk.builtin.enumerate))
      return new Sk.builtin.enumerate(a, b);
    Sk.builtin.pyCheckArgs('enumerate', arguments, 1, 2);
    if (!Sk.builtin.checkIterable(a))
      throw new Sk.builtin.TypeError('\'' + Sk.ffi.typeName(a) + '\' object is not iterable');
    if (void 0 !== b)
      if (Sk.misceval.isIndex(b))
        b = Sk.misceval.asIndex(b);
      else
        throw new Sk.builtin.TypeError('\'' + Sk.ffi.typeName(b) + '\' object cannot be interpreted as an index');
    else
      b = 0;
    var c = a.tp$iter();
    this.tp$iter = function () {
      return this;
    };
    this.$index = b;
    this.tp$iternext = function () {
      var a = c.tp$iternext();
      return void 0 === a ? void 0 : new Sk.builtin.tuple([
        this.$index++,
        a
      ]);
    };
    this.__class__ = Sk.builtin.enumerate;
    return this;
  };
  Sk.builtin.enumerate.prototype.tp$name = 'enumerate';
  Sk.builtin.enumerate.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj('enumerate', Sk.builtin.enumerate);
  Sk.builtin.enumerate.prototype.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;
  Sk.builtin.enumerate.prototype.__iter__ = new Sk.builtin.func(function (a) {
    return a.tp$iter();
  });
  Sk.builtin.enumerate.prototype.next = new Sk.builtin.func(function (a) {
    return a.tp$iternext();
  });
  Sk.Tokenizer = function (a, b, c) {
    this.filename = a;
    this.callback = c;
    this.parenlev = this.lnum = 0;
    this.continued = !1;
    this.namechars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_';
    this.numchars = '0123456789';
    this.contstr = '';
    this.needcont = !1;
    this.contline = void 0;
    this.indents = [0];
    this.endprog = /.*/;
    this.strstart = [
      -1,
      -1
    ];
    this.interactive = b;
    this.doneFunc = function () {
      for (var a = 1; a < this.indents.length; ++a)
        if (this.callback(Sk.Tokenizer.Tokens.T_DEDENT, '', [
            this.lnum,
            0
          ], [
            this.lnum,
            0
          ], ''))
          return 'done';
      return this.callback(Sk.Tokenizer.Tokens.T_ENDMARKER, '', [
        this.lnum,
        0
      ], [
        this.lnum,
        0
      ], '') ? 'done' : 'failed';
    };
  };
  Sk.Tokenizer.Tokens = {
    T_ENDMARKER: 0,
    T_NAME: 1,
    T_NUMBER: 2,
    T_STRING: 3,
    T_NEWLINE: 4,
    T_INDENT: 5,
    T_DEDENT: 6,
    T_LPAR: 7,
    T_RPAR: 8,
    T_LSQB: 9,
    T_RSQB: 10,
    T_COLON: 11,
    T_COMMA: 12,
    T_SEMI: 13,
    T_PLUS: 14,
    T_MINUS: 15,
    T_STAR: 16,
    T_SLASH: 17,
    T_VBAR: 18,
    T_AMPER: 19,
    T_LESS: 20,
    T_GREATER: 21,
    T_EQUAL: 22,
    T_DOT: 23,
    T_PERCENT: 24,
    T_BACKQUOTE: 25,
    T_LBRACE: 26,
    T_RBRACE: 27,
    T_EQEQUAL: 28,
    T_NOTEQUAL: 29,
    T_LESSEQUAL: 30,
    T_GREATEREQUAL: 31,
    T_TILDE: 32,
    T_CIRCUMFLEX: 33,
    T_LEFTSHIFT: 34,
    T_RIGHTSHIFT: 35,
    T_DOUBLESTAR: 36,
    T_PLUSEQUAL: 37,
    T_MINEQUAL: 38,
    T_STAREQUAL: 39,
    T_SLASHEQUAL: 40,
    T_PERCENTEQUAL: 41,
    T_AMPEREQUAL: 42,
    T_VBAREQUAL: 43,
    T_CIRCUMFLEXEQUAL: 44,
    T_LEFTSHIFTEQUAL: 45,
    T_RIGHTSHIFTEQUAL: 46,
    T_DOUBLESTAREQUAL: 47,
    T_DOUBLESLASH: 48,
    T_DOUBLESLASHEQUAL: 49,
    T_AT: 50,
    T_OP: 51,
    T_COMMENT: 52,
    T_NL: 53,
    T_RARROW: 54,
    T_ERRORTOKEN: 55,
    T_N_TOKENS: 56,
    T_NT_OFFSET: 256
  };
  function group(a) {
    return '(' + Array.prototype.slice.call(arguments).join('|') + ')';
  }
  function any(a) {
    return group.apply(null, arguments) + '*';
  }
  function maybe(a) {
    return group.apply(null, arguments) + '?';
  }
  var Whitespace = '[ \\f\\t]*', Comment_ = '#[^\\r\\n]*', Ident = '[a-zA-Z_]\\w*', Binnumber = '0[bB][01]*', Hexnumber = '0[xX][\\da-fA-F]*[lL]?', Octnumber = '0[oO]?[0-7]*[lL]?', Decnumber = '[1-9]\\d*[lL]?', Intnumber = group(Binnumber, Hexnumber, Octnumber, Decnumber), Exponent = '[eE][-+]?\\d+', Pointfloat = group('\\d+\\.\\d*', '\\.\\d+') + maybe(Exponent), Expfloat = '\\d+' + Exponent, Floatnumber = group(Pointfloat, Expfloat), Imagnumber = group('\\d+[jJ]', Floatnumber + '[jJ]'), Number_ = group(Imagnumber, Floatnumber, Intnumber), Single = '^[^\'\\\\]*(?:\\\\.[^\'\\\\]*)*\'', Double_ = '^[^"\\\\]*(?:\\\\.[^"\\\\]*)*"', Single3 = '[^\'\\\\]*(?:(?:\\\\.|\'(?!\'\'))[^\'\\\\]*)*\'\'\'', Double3 = '[^"\\\\]*(?:(?:\\\\.|"(?!""))[^"\\\\]*)*"""', Triple = group('[ubUB]?[rR]?\'\'\'', '[ubUB]?[rR]?"""'), String_ = group('[uU]?[rR]?\'[^\\n\'\\\\]*(?:\\\\.[^\\n\'\\\\]*)*\'', '[uU]?[rR]?"[^\\n"\\\\]*(?:\\\\.[^\\n"\\\\]*)*"'), Operator = group('\\*\\*=?', '>>=?', '<<=?', '<>', '!=', '//=?', '->', '[+\\-*/%&|^=<>]=?', '~'), Bracket = '[\\][(){}]', Special = group('\\r?\\n', '[:;.,`@]'), Funny = group(Operator, Bracket, Special), ContStr = group('[uUbB]?[rR]?\'[^\\n\'\\\\]*(?:\\\\.[^\\n\'\\\\]*)*' + group('\'', '\\\\\\r?\\n'), '[uUbB]?[rR]?"[^\\n"\\\\]*(?:\\\\.[^\\n"\\\\]*)*' + group('"', '\\\\\\r?\\n')), PseudoExtras = group('\\\\\\r?\\n', Comment_, Triple), PseudoToken = '^' + group(PseudoExtras, Number_, Funny, ContStr, Ident), pseudoprog, single3prog, double3prog, endprogs = {}, triple_quoted = {
      '\'\'\'': !0,
      '"""': !0,
      'r\'\'\'': !0,
      'r"""': !0,
      'R\'\'\'': !0,
      'R"""': !0,
      'u\'\'\'': !0,
      'u"""': !0,
      'U\'\'\'': !0,
      'U"""': !0,
      'b\'\'\'': !0,
      'b"""': !0,
      'B\'\'\'': !0,
      'B"""': !0,
      'ur\'\'\'': !0,
      'ur"""': !0,
      'Ur\'\'\'': !0,
      'Ur"""': !0,
      'uR\'\'\'': !0,
      'uR"""': !0,
      'UR\'\'\'': !0,
      'UR"""': !0,
      'br\'\'\'': !0,
      'br"""': !0,
      'Br\'\'\'': !0,
      'Br"""': !0,
      'bR\'\'\'': !0,
      'bR"""': !0,
      'BR\'\'\'': !0,
      'BR"""': !0
    }, single_quoted = {
      '\'': !0,
      '"': !0,
      'r\'': !0,
      'r"': !0,
      'R\'': !0,
      'R"': !0,
      'u\'': !0,
      'u"': !0,
      'U\'': !0,
      'U"': !0,
      'b\'': !0,
      'b"': !0,
      'B\'': !0,
      'B"': !0,
      'ur\'': !0,
      'ur"': !0,
      'Ur\'': !0,
      'Ur"': !0,
      'uR\'': !0,
      'uR"': !0,
      'UR\'': !0,
      'UR"': !0,
      'br\'': !0,
      'br"': !0,
      'Br\'': !0,
      'Br"': !0,
      'bR\'': !0,
      'bR"': !0,
      'BR\'': !0,
      'BR"': !0
    };
  (function () {
    for (var a in triple_quoted);
    for (a in single_quoted);
  }());
  var tabsize = 8;
  function contains(a, b) {
    for (var c = a.length; c--;)
      if (a[c] === b)
        return !0;
    return !1;
  }
  function rstrip(a, b) {
    for (var c = a.length; 0 < c && -1 !== b.indexOf(a.charAt(c - 1)); --c);
    return a.substring(0, c);
  }
  Sk.Tokenizer.prototype.generateTokens = function (a) {
    var b, c, d, e, f, g = RegExp(PseudoToken);
    c = RegExp(Single3, 'g');
    f = RegExp(Double3, 'g');
    var h = {
        '\'': RegExp(Single, 'g'),
        '"': RegExp(Double_, 'g'),
        '\'\'\'': c,
        '"""': f,
        'r\'\'\'': c,
        'r"""': f,
        'u\'\'\'': c,
        'u"""': f,
        'b\'\'\'': c,
        'b"""': f,
        'ur\'\'\'': c,
        'ur"""': f,
        'br\'\'\'': c,
        'br"""': f,
        'R\'\'\'': c,
        'R"""': f,
        'U\'\'\'': c,
        'U"""': f,
        'B\'\'\'': c,
        'B"""': f,
        'uR\'\'\'': c,
        'uR"""': f,
        'Ur\'\'\'': c,
        'Ur"""': f,
        'UR\'\'\'': c,
        'UR"""': f,
        'bR\'\'\'': c,
        'bR"""': f,
        'Br\'\'\'': c,
        'Br"""': f,
        'BR\'\'\'': c,
        'BR"""': f,
        r: null,
        R: null,
        u: null,
        U: null,
        b: null,
        B: null
      };
    a || (a = '');
    this.lnum += 1;
    c = 0;
    f = a.length;
    if (0 < this.contstr.length) {
      if (!a)
        throw new Sk.builtin.TokenError('EOF in multi-line string', this.filename, this.strstart[0], this.strstart[1], this.contline);
      this.endprog.lastIndex = 0;
      if (b = this.endprog.test(a)) {
        c = e = this.endprog.lastIndex;
        if (this.callback(Sk.Tokenizer.Tokens.T_STRING, this.contstr + a.substring(0, e), this.strstart, [
            this.lnum,
            e
          ], this.contline + a))
          return 'done';
        this.contstr = '';
        this.needcont = !1;
        this.contline = void 0;
      } else {
        if (this.needcont && '\\\n' !== a.substring(a.length - 2) && '\\\r\n' !== a.substring(a.length - 3)) {
          if (this.callback(Sk.Tokenizer.Tokens.T_ERRORTOKEN, this.contstr + a, this.strstart, [
              this.lnum,
              a.length
            ], this.contline))
            return 'done';
          this.contstr = '';
          this.contline = void 0;
        } else
          this.contstr += a, this.contline += a;
        return !1;
      }
    } else if (0 !== this.parenlev || this.continued) {
      if (!a)
        throw new Sk.builtin.TokenError('EOF in multi-line statement', this.filename, this.lnum, 0, a);
      this.continued = !1;
    } else {
      if (!a)
        return this.doneFunc();
      for (d = 0; c < f;) {
        if (' ' === a.charAt(c))
          d += 1;
        else if ('\t' === a.charAt(c))
          d = (d / tabsize + 1) * tabsize;
        else if ('\f' === a.charAt(c))
          d = 0;
        else
          break;
        c += 1;
      }
      if (c === f)
        return this.doneFunc();
      if (-1 !== '#\r\n'.indexOf(a.charAt(c))) {
        if ('#' === a.charAt(c))
          return g = rstrip(a.substring(c), '\r\n'), f = c + g.length, this.callback(Sk.Tokenizer.Tokens.T_COMMENT, g, [
            this.lnum,
            c
          ], [
            this.lnum,
            c + g.length
          ], a) || this.callback(Sk.Tokenizer.Tokens.T_NL, a.substring(f), [
            this.lnum,
            f
          ], [
            this.lnum,
            a.length
          ], a) ? 'done' : !1;
        if (this.callback(Sk.Tokenizer.Tokens.T_NL, a.substring(c), [
            this.lnum,
            c
          ], [
            this.lnum,
            a.length
          ], a))
          return 'done';
        if (!this.interactive)
          return !1;
      }
      if (d > this.indents[this.indents.length - 1] && (this.indents.push(d), this.callback(Sk.Tokenizer.Tokens.T_INDENT, a.substring(0, c), [
          this.lnum,
          0
        ], [
          this.lnum,
          c
        ], a)))
        return 'done';
      for (; d < this.indents[this.indents.length - 1];) {
        if (!contains(this.indents, d))
          throw new Sk.builtin.IndentationError('unindent does not match any outer indentation level', this.filename, this.lnum, c, a);
        this.indents.splice(this.indents.length - 1, 1);
        if (this.callback(Sk.Tokenizer.Tokens.T_DEDENT, '', [
            this.lnum,
            c
          ], [
            this.lnum,
            c
          ], a))
          return 'done';
      }
    }
    for (; c < f;) {
      for (d = a.charAt(c); ' ' === d || '\f' === d || '\t' === d;)
        c += 1, d = a.charAt(c);
      g.lastIndex = 0;
      var l = g.exec(a.substring(c));
      if (l) {
        d = c;
        e = d + l[1].length;
        l = [
          this.lnum,
          d
        ];
        b = [
          this.lnum,
          e
        ];
        c = e;
        e = a.substring(d, e);
        var k = a.charAt(d);
        if (-1 !== this.numchars.indexOf(k) || '.' === k && '.' !== e) {
          if (this.callback(Sk.Tokenizer.Tokens.T_NUMBER, e, l, b, a))
            return 'done';
        } else if ('\r' === k || '\n' === k) {
          if (d = Sk.Tokenizer.Tokens.T_NEWLINE, 0 < this.parenlev && (d = Sk.Tokenizer.Tokens.T_NL), this.callback(d, e, l, b, a))
            return 'done';
        } else if ('#' === k) {
          if (this.callback(Sk.Tokenizer.Tokens.T_COMMENT, e, l, b, a))
            return 'done';
        } else if (triple_quoted.hasOwnProperty(e))
          if (this.endprog = h[e], this.endprog.lastIndex = 0, b = this.endprog.test(a.substring(c))) {
            if (c = this.endprog.lastIndex + c, e = a.substring(d, c), this.callback(Sk.Tokenizer.Tokens.T_STRING, e, l, [
                this.lnum,
                c
              ], a))
              return 'done';
          } else {
            this.strstart = [
              this.lnum,
              d
            ];
            this.contstr = a.substring(d);
            this.contline = a;
            break;
          }
        else if (single_quoted.hasOwnProperty(k) || single_quoted.hasOwnProperty(e.substring(0, 2)) || single_quoted.hasOwnProperty(e.substring(0, 3)))
          if ('\n' === e[e.length - 1]) {
            this.strstart = [
              this.lnum,
              d
            ];
            this.endprog = h[k] || h[e[1]] || h[e[2]];
            this.contstr = a.substring(d);
            this.needcont = !0;
            this.contline = a;
            break;
          } else {
            if (this.callback(Sk.Tokenizer.Tokens.T_STRING, e, l, b, a))
              return 'done';
          }
        else if (-1 !== this.namechars.indexOf(k)) {
          if (this.callback(Sk.Tokenizer.Tokens.T_NAME, e, l, b, a))
            return 'done';
        } else if ('\\' === k) {
          if (this.callback(Sk.Tokenizer.Tokens.T_NL, e, l, [
              this.lnum,
              c
            ], a))
            return 'done';
          this.continued = !0;
        } else if (-1 !== '([{'.indexOf(k) ? this.parenlev += 1 : -1 !== ')]}'.indexOf(k) && (this.parenlev -= 1), this.callback(Sk.Tokenizer.Tokens.T_OP, e, l, b, a))
          return 'done';
      } else {
        if (this.callback(Sk.Tokenizer.Tokens.T_ERRORTOKEN, a.charAt(c), [
            this.lnum,
            c
          ], [
            this.lnum,
            c + 1
          ], a))
          return 'done';
        c += 1;
      }
    }
    return !1;
  };
  Sk.Tokenizer.tokenNames = {
    0: 'T_ENDMARKER',
    1: 'T_NAME',
    2: 'T_NUMBER',
    3: 'T_STRING',
    4: 'T_NEWLINE',
    5: 'T_INDENT',
    6: 'T_DEDENT',
    7: 'T_LPAR',
    8: 'T_RPAR',
    9: 'T_LSQB',
    10: 'T_RSQB',
    11: 'T_COLON',
    12: 'T_COMMA',
    13: 'T_SEMI',
    14: 'T_PLUS',
    15: 'T_MINUS',
    16: 'T_STAR',
    17: 'T_SLASH',
    18: 'T_VBAR',
    19: 'T_AMPER',
    20: 'T_LESS',
    21: 'T_GREATER',
    22: 'T_EQUAL',
    23: 'T_DOT',
    24: 'T_PERCENT',
    25: 'T_BACKQUOTE',
    26: 'T_LBRACE',
    27: 'T_RBRACE',
    28: 'T_EQEQUAL',
    29: 'T_NOTEQUAL',
    30: 'T_LESSEQUAL',
    31: 'T_GREATEREQUAL',
    32: 'T_TILDE',
    33: 'T_CIRCUMFLEX',
    34: 'T_LEFTSHIFT',
    35: 'T_RIGHTSHIFT',
    36: 'T_DOUBLESTAR',
    37: 'T_PLUSEQUAL',
    38: 'T_MINEQUAL',
    39: 'T_STAREQUAL',
    40: 'T_SLASHEQUAL',
    41: 'T_PERCENTEQUAL',
    42: 'T_AMPEREQUAL',
    43: 'T_VBAREQUAL',
    44: 'T_CIRCUMFLEXEQUAL',
    45: 'T_LEFTSHIFTEQUAL',
    46: 'T_RIGHTSHIFTEQUAL',
    47: 'T_DOUBLESTAREQUAL',
    48: 'T_DOUBLESLASH',
    49: 'T_DOUBLESLASHEQUAL',
    50: 'T_AT',
    51: 'T_OP',
    52: 'T_COMMENT',
    53: 'T_NL',
    54: 'T_RARROW',
    55: 'T_ERRORTOKEN',
    56: 'T_N_TOKENS',
    256: 'T_NT_OFFSET'
  };
  goog.exportSymbol('Sk.Tokenizer', Sk.Tokenizer);
  goog.exportSymbol('Sk.Tokenizer.prototype.generateTokens', Sk.Tokenizer.prototype.generateTokens);
  goog.exportSymbol('Sk.Tokenizer.tokenNames', Sk.Tokenizer.tokenNames);
  Sk.OpMap = {
    '(': Sk.Tokenizer.Tokens.T_LPAR,
    ')': Sk.Tokenizer.Tokens.T_RPAR,
    '[': Sk.Tokenizer.Tokens.T_LSQB,
    ']': Sk.Tokenizer.Tokens.T_RSQB,
    ':': Sk.Tokenizer.Tokens.T_COLON,
    ',': Sk.Tokenizer.Tokens.T_COMMA,
    ';': Sk.Tokenizer.Tokens.T_SEMI,
    '+': Sk.Tokenizer.Tokens.T_PLUS,
    '-': Sk.Tokenizer.Tokens.T_MINUS,
    '*': Sk.Tokenizer.Tokens.T_STAR,
    '/': Sk.Tokenizer.Tokens.T_SLASH,
    '|': Sk.Tokenizer.Tokens.T_VBAR,
    '&': Sk.Tokenizer.Tokens.T_AMPER,
    '<': Sk.Tokenizer.Tokens.T_LESS,
    '>': Sk.Tokenizer.Tokens.T_GREATER,
    '=': Sk.Tokenizer.Tokens.T_EQUAL,
    '.': Sk.Tokenizer.Tokens.T_DOT,
    '%': Sk.Tokenizer.Tokens.T_PERCENT,
    '`': Sk.Tokenizer.Tokens.T_BACKQUOTE,
    '{': Sk.Tokenizer.Tokens.T_LBRACE,
    '}': Sk.Tokenizer.Tokens.T_RBRACE,
    '@': Sk.Tokenizer.Tokens.T_AT,
    '==': Sk.Tokenizer.Tokens.T_EQEQUAL,
    '!=': Sk.Tokenizer.Tokens.T_NOTEQUAL,
    '<>': Sk.Tokenizer.Tokens.T_NOTEQUAL,
    '<=': Sk.Tokenizer.Tokens.T_LESSEQUAL,
    '>=': Sk.Tokenizer.Tokens.T_GREATEREQUAL,
    '~': Sk.Tokenizer.Tokens.T_TILDE,
    '^': Sk.Tokenizer.Tokens.T_CIRCUMFLEX,
    '<<': Sk.Tokenizer.Tokens.T_LEFTSHIFT,
    '>>': Sk.Tokenizer.Tokens.T_RIGHTSHIFT,
    '**': Sk.Tokenizer.Tokens.T_DOUBLESTAR,
    '+=': Sk.Tokenizer.Tokens.T_PLUSEQUAL,
    '-=': Sk.Tokenizer.Tokens.T_MINEQUAL,
    '*=': Sk.Tokenizer.Tokens.T_STAREQUAL,
    '/=': Sk.Tokenizer.Tokens.T_SLASHEQUAL,
    '%=': Sk.Tokenizer.Tokens.T_PERCENTEQUAL,
    '&=': Sk.Tokenizer.Tokens.T_AMPEREQUAL,
    '|=': Sk.Tokenizer.Tokens.T_VBAREQUAL,
    '^=': Sk.Tokenizer.Tokens.T_CIRCUMFLEXEQUAL,
    '<<=': Sk.Tokenizer.Tokens.T_LEFTSHIFTEQUAL,
    '>>=': Sk.Tokenizer.Tokens.T_RIGHTSHIFTEQUAL,
    '**=': Sk.Tokenizer.Tokens.T_DOUBLESTAREQUAL,
    '//': Sk.Tokenizer.Tokens.T_DOUBLESLASH,
    '//=': Sk.Tokenizer.Tokens.T_DOUBLESLASHEQUAL,
    '->': Sk.Tokenizer.Tokens.T_RARROW
  };
  Sk.ParseTables = {
    sym: {
      and_expr: 257,
      and_test: 258,
      arglist: 259,
      argument: 260,
      arith_expr: 261,
      assert_stmt: 262,
      atom: 263,
      augassign: 264,
      break_stmt: 265,
      classdef: 266,
      comp_op: 267,
      comparison: 268,
      compound_stmt: 269,
      continue_stmt: 270,
      decorated: 271,
      decorator: 272,
      decorators: 273,
      del_stmt: 274,
      dictmaker: 275,
      dotted_as_name: 276,
      dotted_as_names: 277,
      dotted_name: 278,
      encoding_decl: 279,
      eval_input: 280,
      except_clause: 281,
      exec_stmt: 282,
      expr: 283,
      expr_stmt: 284,
      exprlist: 285,
      factor: 286,
      file_input: 287,
      flow_stmt: 288,
      for_stmt: 289,
      fpdef: 290,
      fplist: 291,
      funcdef: 292,
      gen_for: 293,
      gen_if: 294,
      gen_iter: 295,
      global_stmt: 296,
      if_stmt: 297,
      import_as_name: 298,
      import_as_names: 299,
      import_from: 300,
      import_name: 301,
      import_stmt: 302,
      lambdef: 303,
      list_for: 304,
      list_if: 305,
      list_iter: 306,
      listmaker: 307,
      not_test: 308,
      old_lambdef: 309,
      old_test: 310,
      or_test: 311,
      parameters: 312,
      pass_stmt: 313,
      power: 314,
      print_stmt: 315,
      raise_stmt: 316,
      return_stmt: 317,
      shift_expr: 318,
      simple_stmt: 319,
      single_input: 256,
      sliceop: 320,
      small_stmt: 321,
      stmt: 322,
      subscript: 323,
      subscriptlist: 324,
      suite: 325,
      term: 326,
      test: 327,
      testlist: 328,
      testlist1: 329,
      testlist_gexp: 330,
      testlist_safe: 331,
      trailer: 332,
      try_stmt: 333,
      varargslist: 334,
      while_stmt: 335,
      with_stmt: 336,
      with_var: 337,
      xor_expr: 338,
      yield_expr: 339,
      yield_stmt: 340
    },
    number2symbol: {
      256: 'single_input',
      257: 'and_expr',
      258: 'and_test',
      259: 'arglist',
      260: 'argument',
      261: 'arith_expr',
      262: 'assert_stmt',
      263: 'atom',
      264: 'augassign',
      265: 'break_stmt',
      266: 'classdef',
      267: 'comp_op',
      268: 'comparison',
      269: 'compound_stmt',
      270: 'continue_stmt',
      271: 'decorated',
      272: 'decorator',
      273: 'decorators',
      274: 'del_stmt',
      275: 'dictmaker',
      276: 'dotted_as_name',
      277: 'dotted_as_names',
      278: 'dotted_name',
      279: 'encoding_decl',
      280: 'eval_input',
      281: 'except_clause',
      282: 'exec_stmt',
      283: 'expr',
      284: 'expr_stmt',
      285: 'exprlist',
      286: 'factor',
      287: 'file_input',
      288: 'flow_stmt',
      289: 'for_stmt',
      290: 'fpdef',
      291: 'fplist',
      292: 'funcdef',
      293: 'gen_for',
      294: 'gen_if',
      295: 'gen_iter',
      296: 'global_stmt',
      297: 'if_stmt',
      298: 'import_as_name',
      299: 'import_as_names',
      300: 'import_from',
      301: 'import_name',
      302: 'import_stmt',
      303: 'lambdef',
      304: 'list_for',
      305: 'list_if',
      306: 'list_iter',
      307: 'listmaker',
      308: 'not_test',
      309: 'old_lambdef',
      310: 'old_test',
      311: 'or_test',
      312: 'parameters',
      313: 'pass_stmt',
      314: 'power',
      315: 'print_stmt',
      316: 'raise_stmt',
      317: 'return_stmt',
      318: 'shift_expr',
      319: 'simple_stmt',
      320: 'sliceop',
      321: 'small_stmt',
      322: 'stmt',
      323: 'subscript',
      324: 'subscriptlist',
      325: 'suite',
      326: 'term',
      327: 'test',
      328: 'testlist',
      329: 'testlist1',
      330: 'testlist_gexp',
      331: 'testlist_safe',
      332: 'trailer',
      333: 'try_stmt',
      334: 'varargslist',
      335: 'while_stmt',
      336: 'with_stmt',
      337: 'with_var',
      338: 'xor_expr',
      339: 'yield_expr',
      340: 'yield_stmt'
    },
    dfas: {
      256: [
        [
          [
            [
              1,
              1
            ],
            [
              2,
              1
            ],
            [
              3,
              2
            ]
          ],
          [[
              0,
              1
            ]],
          [[
              2,
              1
            ]]
        ],
        {
          2: 1,
          4: 1,
          5: 1,
          6: 1,
          7: 1,
          8: 1,
          9: 1,
          10: 1,
          11: 1,
          12: 1,
          13: 1,
          14: 1,
          15: 1,
          16: 1,
          17: 1,
          18: 1,
          19: 1,
          20: 1,
          21: 1,
          22: 1,
          23: 1,
          24: 1,
          25: 1,
          26: 1,
          27: 1,
          28: 1,
          29: 1,
          30: 1,
          31: 1,
          32: 1,
          33: 1,
          34: 1,
          35: 1,
          36: 1
        }
      ],
      257: [
        [
          [[
              37,
              1
            ]],
          [
            [
              38,
              0
            ],
            [
              0,
              1
            ]
          ]
        ],
        {
          6: 1,
          8: 1,
          9: 1,
          11: 1,
          13: 1,
          17: 1,
          20: 1,
          24: 1,
          28: 1,
          35: 1
        }
      ],
      258: [
        [
          [[
              39,
              1
            ]],
          [
            [
              40,
              0
            ],
            [
              0,
              1
            ]
          ]
        ],
        {
          6: 1,
          7: 1,
          8: 1,
          9: 1,
          11: 1,
          13: 1,
          17: 1,
          20: 1,
          24: 1,
          28: 1,
          35: 1
        }
      ],
      259: [
        [
          [
            [
              41,
              1
            ],
            [
              42,
              2
            ],
            [
              43,
              3
            ]
          ],
          [[
              44,
              4
            ]],
          [
            [
              45,
              5
            ],
            [
              0,
              2
            ]
          ],
          [[
              44,
              6
            ]],
          [
            [
              45,
              7
            ],
            [
              0,
              4
            ]
          ],
          [
            [
              41,
              1
            ],
            [
              42,
              2
            ],
            [
              43,
              3
            ],
            [
              0,
              5
            ]
          ],
          [[
              0,
              6
            ]],
          [
            [
              42,
              4
            ],
            [
              43,
              3
            ]
          ]
        ],
        {
          6: 1,
          7: 1,
          8: 1,
          9: 1,
          11: 1,
          13: 1,
          17: 1,
          20: 1,
          24: 1,
          28: 1,
          35: 1,
          36: 1,
          41: 1,
          43: 1
        }
      ],
      260: [
        [
          [[
              44,
              1
            ]],
          [
            [
              46,
              2
            ],
            [
              47,
              3
            ],
            [
              0,
              1
            ]
          ],
          [[
              0,
              2
            ]],
          [[
              44,
              2
            ]]
        ],
        {
          6: 1,
          7: 1,
          8: 1,
          9: 1,
          11: 1,
          13: 1,
          17: 1,
          20: 1,
          24: 1,
          28: 1,
          35: 1,
          36: 1
        }
      ],
      261: [
        [
          [[
              48,
              1
            ]],
          [
            [
              24,
              0
            ],
            [
              35,
              0
            ],
            [
              0,
              1
            ]
          ]
        ],
        {
          6: 1,
          8: 1,
          9: 1,
          11: 1,
          13: 1,
          17: 1,
          20: 1,
          24: 1,
          28: 1,
          35: 1
        }
      ],
      262: [
        [
          [[
              19,
              1
            ]],
          [[
              44,
              2
            ]],
          [
            [
              45,
              3
            ],
            [
              0,
              2
            ]
          ],
          [[
              44,
              4
            ]],
          [[
              0,
              4
            ]]
        ],
        { 19: 1 }
      ],
      263: [
        [
          [
            [
              17,
              1
            ],
            [
              8,
              2
            ],
            [
              9,
              5
            ],
            [
              28,
              4
            ],
            [
              11,
              3
            ],
            [
              13,
              6
            ],
            [
              20,
              2
            ]
          ],
          [
            [
              17,
              1
            ],
            [
              0,
              1
            ]
          ],
          [[
              0,
              2
            ]],
          [
            [
              49,
              7
            ],
            [
              50,
              2
            ]
          ],
          [
            [
              51,
              2
            ],
            [
              52,
              8
            ],
            [
              53,
              8
            ]
          ],
          [
            [
              54,
              9
            ],
            [
              55,
              2
            ]
          ],
          [[
              56,
              10
            ]],
          [[
              50,
              2
            ]],
          [[
              51,
              2
            ]],
          [[
              55,
              2
            ]],
          [[
              13,
              2
            ]]
        ],
        {
          8: 1,
          9: 1,
          11: 1,
          13: 1,
          17: 1,
          20: 1,
          28: 1
        }
      ],
      264: [
        [
          [
            [
              57,
              1
            ],
            [
              58,
              1
            ],
            [
              59,
              1
            ],
            [
              60,
              1
            ],
            [
              61,
              1
            ],
            [
              62,
              1
            ],
            [
              63,
              1
            ],
            [
              64,
              1
            ],
            [
              65,
              1
            ],
            [
              66,
              1
            ],
            [
              67,
              1
            ],
            [
              68,
              1
            ]
          ],
          [[
              0,
              1
            ]]
        ],
        {
          57: 1,
          58: 1,
          59: 1,
          60: 1,
          61: 1,
          62: 1,
          63: 1,
          64: 1,
          65: 1,
          66: 1,
          67: 1,
          68: 1
        }
      ],
      265: [
        [
          [[
              31,
              1
            ]],
          [[
              0,
              1
            ]]
        ],
        { 31: 1 }
      ],
      266: [
        [
          [[
              10,
              1
            ]],
          [[
              20,
              2
            ]],
          [
            [
              69,
              3
            ],
            [
              28,
              4
            ]
          ],
          [[
              70,
              5
            ]],
          [
            [
              51,
              6
            ],
            [
              71,
              7
            ]
          ],
          [[
              0,
              5
            ]],
          [[
              69,
              3
            ]],
          [[
              51,
              6
            ]]
        ],
        { 10: 1 }
      ],
      267: [
        [
          [
            [
              72,
              1
            ],
            [
              73,
              1
            ],
            [
              7,
              2
            ],
            [
              74,
              1
            ],
            [
              72,
              1
            ],
            [
              75,
              1
            ],
            [
              76,
              1
            ],
            [
              77,
              3
            ],
            [
              78,
              1
            ],
            [
              79,
              1
            ]
          ],
          [[
              0,
              1
            ]],
          [[
              75,
              1
            ]],
          [
            [
              7,
              1
            ],
            [
              0,
              3
            ]
          ]
        ],
        {
          7: 1,
          72: 1,
          73: 1,
          74: 1,
          75: 1,
          76: 1,
          77: 1,
          78: 1,
          79: 1
        }
      ],
      268: [
        [
          [[
              80,
              1
            ]],
          [
            [
              81,
              0
            ],
            [
              0,
              1
            ]
          ]
        ],
        {
          6: 1,
          8: 1,
          9: 1,
          11: 1,
          13: 1,
          17: 1,
          20: 1,
          24: 1,
          28: 1,
          35: 1
        }
      ],
      269: [
        [
          [
            [
              82,
              1
            ],
            [
              83,
              1
            ],
            [
              84,
              1
            ],
            [
              85,
              1
            ],
            [
              86,
              1
            ],
            [
              87,
              1
            ],
            [
              88,
              1
            ],
            [
              89,
              1
            ]
          ],
          [[
              0,
              1
            ]]
        ],
        {
          4: 1,
          10: 1,
          14: 1,
          16: 1,
          27: 1,
          30: 1,
          33: 1,
          34: 1
        }
      ],
      270: [
        [
          [[
              32,
              1
            ]],
          [[
              0,
              1
            ]]
        ],
        { 32: 1 }
      ],
      271: [
        [
          [[
              90,
              1
            ]],
          [
            [
              88,
              2
            ],
            [
              85,
              2
            ]
          ],
          [[
              0,
              2
            ]]
        ],
        { 33: 1 }
      ],
      272: [
        [
          [[
              33,
              1
            ]],
          [[
              91,
              2
            ]],
          [
            [
              28,
              4
            ],
            [
              2,
              3
            ]
          ],
          [[
              0,
              3
            ]],
          [
            [
              51,
              5
            ],
            [
              92,
              6
            ]
          ],
          [[
              2,
              3
            ]],
          [[
              51,
              5
            ]]
        ],
        { 33: 1 }
      ],
      273: [
        [
          [[
              93,
              1
            ]],
          [
            [
              93,
              1
            ],
            [
              0,
              1
            ]
          ]
        ],
        { 33: 1 }
      ],
      274: [
        [
          [[
              21,
              1
            ]],
          [[
              94,
              2
            ]],
          [[
              0,
              2
            ]]
        ],
        { 21: 1 }
      ],
      275: [
        [
          [[
              44,
              1
            ]],
          [[
              69,
              2
            ]],
          [[
              44,
              3
            ]],
          [
            [
              45,
              4
            ],
            [
              0,
              3
            ]
          ],
          [
            [
              44,
              1
            ],
            [
              0,
              4
            ]
          ]
        ],
        {
          6: 1,
          7: 1,
          8: 1,
          9: 1,
          11: 1,
          13: 1,
          17: 1,
          20: 1,
          24: 1,
          28: 1,
          35: 1,
          36: 1
        }
      ],
      276: [
        [
          [[
              91,
              1
            ]],
          [
            [
              95,
              2
            ],
            [
              0,
              1
            ]
          ],
          [[
              20,
              3
            ]],
          [[
              0,
              3
            ]]
        ],
        { 20: 1 }
      ],
      277: [
        [
          [[
              96,
              1
            ]],
          [
            [
              45,
              0
            ],
            [
              0,
              1
            ]
          ]
        ],
        { 20: 1 }
      ],
      278: [
        [
          [[
              20,
              1
            ]],
          [
            [
              97,
              0
            ],
            [
              0,
              1
            ]
          ]
        ],
        { 20: 1 }
      ],
      279: [
        [
          [[
              20,
              1
            ]],
          [[
              0,
              1
            ]]
        ],
        { 20: 1 }
      ],
      280: [
        [
          [[
              71,
              1
            ]],
          [
            [
              2,
              1
            ],
            [
              98,
              2
            ]
          ],
          [[
              0,
              2
            ]]
        ],
        {
          6: 1,
          7: 1,
          8: 1,
          9: 1,
          11: 1,
          13: 1,
          17: 1,
          20: 1,
          24: 1,
          28: 1,
          35: 1,
          36: 1
        }
      ],
      281: [
        [
          [[
              99,
              1
            ]],
          [
            [
              44,
              2
            ],
            [
              0,
              1
            ]
          ],
          [
            [
              95,
              3
            ],
            [
              45,
              3
            ],
            [
              0,
              2
            ]
          ],
          [[
              44,
              4
            ]],
          [[
              0,
              4
            ]]
        ],
        { 99: 1 }
      ],
      282: [
        [
          [[
              15,
              1
            ]],
          [[
              80,
              2
            ]],
          [
            [
              75,
              3
            ],
            [
              0,
              2
            ]
          ],
          [[
              44,
              4
            ]],
          [
            [
              45,
              5
            ],
            [
              0,
              4
            ]
          ],
          [[
              44,
              6
            ]],
          [[
              0,
              6
            ]]
        ],
        { 15: 1 }
      ],
      283: [
        [
          [[
              100,
              1
            ]],
          [
            [
              101,
              0
            ],
            [
              0,
              1
            ]
          ]
        ],
        {
          6: 1,
          8: 1,
          9: 1,
          11: 1,
          13: 1,
          17: 1,
          20: 1,
          24: 1,
          28: 1,
          35: 1
        }
      ],
      284: [
        [
          [[
              71,
              1
            ]],
          [
            [
              102,
              2
            ],
            [
              47,
              3
            ],
            [
              0,
              1
            ]
          ],
          [
            [
              71,
              4
            ],
            [
              53,
              4
            ]
          ],
          [
            [
              71,
              5
            ],
            [
              53,
              5
            ]
          ],
          [[
              0,
              4
            ]],
          [
            [
              47,
              3
            ],
            [
              0,
              5
            ]
          ]
        ],
        {
          6: 1,
          7: 1,
          8: 1,
          9: 1,
          11: 1,
          13: 1,
          17: 1,
          20: 1,
          24: 1,
          28: 1,
          35: 1,
          36: 1
        }
      ],
      285: [
        [
          [[
              80,
              1
            ]],
          [
            [
              45,
              2
            ],
            [
              0,
              1
            ]
          ],
          [
            [
              80,
              1
            ],
            [
              0,
              2
            ]
          ]
        ],
        {
          6: 1,
          8: 1,
          9: 1,
          11: 1,
          13: 1,
          17: 1,
          20: 1,
          24: 1,
          28: 1,
          35: 1
        }
      ],
      286: [
        [
          [
            [
              103,
              2
            ],
            [
              24,
              1
            ],
            [
              6,
              1
            ],
            [
              35,
              1
            ]
          ],
          [[
              104,
              2
            ]],
          [[
              0,
              2
            ]]
        ],
        {
          6: 1,
          8: 1,
          9: 1,
          11: 1,
          13: 1,
          17: 1,
          20: 1,
          24: 1,
          28: 1,
          35: 1
        }
      ],
      287: [
        [
          [
            [
              2,
              0
            ],
            [
              98,
              1
            ],
            [
              105,
              0
            ]
          ],
          [[
              0,
              1
            ]]
        ],
        {
          2: 1,
          4: 1,
          5: 1,
          6: 1,
          7: 1,
          8: 1,
          9: 1,
          10: 1,
          11: 1,
          12: 1,
          13: 1,
          14: 1,
          15: 1,
          16: 1,
          17: 1,
          18: 1,
          19: 1,
          20: 1,
          21: 1,
          22: 1,
          23: 1,
          24: 1,
          25: 1,
          26: 1,
          27: 1,
          28: 1,
          29: 1,
          30: 1,
          31: 1,
          32: 1,
          33: 1,
          34: 1,
          35: 1,
          36: 1,
          98: 1
        }
      ],
      288: [
        [
          [
            [
              106,
              1
            ],
            [
              107,
              1
            ],
            [
              108,
              1
            ],
            [
              109,
              1
            ],
            [
              110,
              1
            ]
          ],
          [[
              0,
              1
            ]]
        ],
        {
          5: 1,
          18: 1,
          25: 1,
          31: 1,
          32: 1
        }
      ],
      289: [
        [
          [[
              27,
              1
            ]],
          [[
              94,
              2
            ]],
          [[
              75,
              3
            ]],
          [[
              71,
              4
            ]],
          [[
              69,
              5
            ]],
          [[
              70,
              6
            ]],
          [
            [
              111,
              7
            ],
            [
              0,
              6
            ]
          ],
          [[
              69,
              8
            ]],
          [[
              70,
              9
            ]],
          [[
              0,
              9
            ]]
        ],
        { 27: 1 }
      ],
      290: [
        [
          [
            [
              28,
              1
            ],
            [
              20,
              2
            ]
          ],
          [[
              112,
              3
            ]],
          [[
              0,
              2
            ]],
          [[
              51,
              2
            ]]
        ],
        {
          20: 1,
          28: 1
        }
      ],
      291: [
        [
          [[
              113,
              1
            ]],
          [
            [
              45,
              2
            ],
            [
              0,
              1
            ]
          ],
          [
            [
              113,
              1
            ],
            [
              0,
              2
            ]
          ]
        ],
        {
          20: 1,
          28: 1
        }
      ],
      292: [
        [
          [[
              4,
              1
            ]],
          [[
              20,
              2
            ]],
          [[
              114,
              3
            ]],
          [[
              69,
              4
            ]],
          [[
              70,
              5
            ]],
          [[
              0,
              5
            ]]
        ],
        { 4: 1 }
      ],
      293: [
        [
          [[
              27,
              1
            ]],
          [[
              94,
              2
            ]],
          [[
              75,
              3
            ]],
          [[
              115,
              4
            ]],
          [
            [
              116,
              5
            ],
            [
              0,
              4
            ]
          ],
          [[
              0,
              5
            ]]
        ],
        { 27: 1 }
      ],
      294: [
        [
          [[
              30,
              1
            ]],
          [[
              117,
              2
            ]],
          [
            [
              116,
              3
            ],
            [
              0,
              2
            ]
          ],
          [[
              0,
              3
            ]]
        ],
        { 30: 1 }
      ],
      295: [
        [
          [
            [
              46,
              1
            ],
            [
              118,
              1
            ]
          ],
          [[
              0,
              1
            ]]
        ],
        {
          27: 1,
          30: 1
        }
      ],
      296: [
        [
          [[
              26,
              1
            ]],
          [[
              20,
              2
            ]],
          [
            [
              45,
              1
            ],
            [
              0,
              2
            ]
          ]
        ],
        { 26: 1 }
      ],
      297: [
        [
          [[
              30,
              1
            ]],
          [[
              44,
              2
            ]],
          [[
              69,
              3
            ]],
          [[
              70,
              4
            ]],
          [
            [
              111,
              5
            ],
            [
              119,
              1
            ],
            [
              0,
              4
            ]
          ],
          [[
              69,
              6
            ]],
          [[
              70,
              7
            ]],
          [[
              0,
              7
            ]]
        ],
        { 30: 1 }
      ],
      298: [
        [
          [[
              20,
              1
            ]],
          [
            [
              95,
              2
            ],
            [
              0,
              1
            ]
          ],
          [[
              20,
              3
            ]],
          [[
              0,
              3
            ]]
        ],
        { 20: 1 }
      ],
      299: [
        [
          [[
              120,
              1
            ]],
          [
            [
              45,
              2
            ],
            [
              0,
              1
            ]
          ],
          [
            [
              120,
              1
            ],
            [
              0,
              2
            ]
          ]
        ],
        { 20: 1 }
      ],
      300: [
        [
          [[
              29,
              1
            ]],
          [
            [
              91,
              2
            ],
            [
              97,
              3
            ]
          ],
          [[
              23,
              4
            ]],
          [
            [
              91,
              2
            ],
            [
              23,
              4
            ],
            [
              97,
              3
            ]
          ],
          [
            [
              121,
              5
            ],
            [
              41,
              5
            ],
            [
              28,
              6
            ]
          ],
          [[
              0,
              5
            ]],
          [[
              121,
              7
            ]],
          [[
              51,
              5
            ]]
        ],
        { 29: 1 }
      ],
      301: [
        [
          [[
              23,
              1
            ]],
          [[
              122,
              2
            ]],
          [[
              0,
              2
            ]]
        ],
        { 23: 1 }
      ],
      302: [
        [
          [
            [
              123,
              1
            ],
            [
              124,
              1
            ]
          ],
          [[
              0,
              1
            ]]
        ],
        {
          23: 1,
          29: 1
        }
      ],
      303: [
        [
          [[
              36,
              1
            ]],
          [
            [
              69,
              2
            ],
            [
              125,
              3
            ]
          ],
          [[
              44,
              4
            ]],
          [[
              69,
              2
            ]],
          [[
              0,
              4
            ]]
        ],
        { 36: 1 }
      ],
      304: [
        [
          [[
              27,
              1
            ]],
          [[
              94,
              2
            ]],
          [[
              75,
              3
            ]],
          [[
              126,
              4
            ]],
          [
            [
              127,
              5
            ],
            [
              0,
              4
            ]
          ],
          [[
              0,
              5
            ]]
        ],
        { 27: 1 }
      ],
      305: [
        [
          [[
              30,
              1
            ]],
          [[
              117,
              2
            ]],
          [
            [
              127,
              3
            ],
            [
              0,
              2
            ]
          ],
          [[
              0,
              3
            ]]
        ],
        { 30: 1 }
      ],
      306: [
        [
          [
            [
              128,
              1
            ],
            [
              129,
              1
            ]
          ],
          [[
              0,
              1
            ]]
        ],
        {
          27: 1,
          30: 1
        }
      ],
      307: [
        [
          [[
              44,
              1
            ]],
          [
            [
              128,
              2
            ],
            [
              45,
              3
            ],
            [
              0,
              1
            ]
          ],
          [[
              0,
              2
            ]],
          [
            [
              44,
              4
            ],
            [
              0,
              3
            ]
          ],
          [
            [
              45,
              3
            ],
            [
              0,
              4
            ]
          ]
        ],
        {
          6: 1,
          7: 1,
          8: 1,
          9: 1,
          11: 1,
          13: 1,
          17: 1,
          20: 1,
          24: 1,
          28: 1,
          35: 1,
          36: 1
        }
      ],
      308: [
        [
          [
            [
              7,
              1
            ],
            [
              130,
              2
            ]
          ],
          [[
              39,
              2
            ]],
          [[
              0,
              2
            ]]
        ],
        {
          6: 1,
          7: 1,
          8: 1,
          9: 1,
          11: 1,
          13: 1,
          17: 1,
          20: 1,
          24: 1,
          28: 1,
          35: 1
        }
      ],
      309: [
        [
          [[
              36,
              1
            ]],
          [
            [
              69,
              2
            ],
            [
              125,
              3
            ]
          ],
          [[
              117,
              4
            ]],
          [[
              69,
              2
            ]],
          [[
              0,
              4
            ]]
        ],
        { 36: 1 }
      ],
      310: [
        [
          [
            [
              131,
              1
            ],
            [
              115,
              1
            ]
          ],
          [[
              0,
              1
            ]]
        ],
        {
          6: 1,
          7: 1,
          8: 1,
          9: 1,
          11: 1,
          13: 1,
          17: 1,
          20: 1,
          24: 1,
          28: 1,
          35: 1,
          36: 1
        }
      ],
      311: [
        [
          [[
              132,
              1
            ]],
          [
            [
              133,
              0
            ],
            [
              0,
              1
            ]
          ]
        ],
        {
          6: 1,
          7: 1,
          8: 1,
          9: 1,
          11: 1,
          13: 1,
          17: 1,
          20: 1,
          24: 1,
          28: 1,
          35: 1
        }
      ],
      312: [
        [
          [[
              28,
              1
            ]],
          [
            [
              51,
              2
            ],
            [
              125,
              3
            ]
          ],
          [[
              0,
              2
            ]],
          [[
              51,
              2
            ]]
        ],
        { 28: 1 }
      ],
      313: [
        [
          [[
              22,
              1
            ]],
          [[
              0,
              1
            ]]
        ],
        { 22: 1 }
      ],
      314: [
        [
          [[
              134,
              1
            ]],
          [
            [
              135,
              1
            ],
            [
              43,
              2
            ],
            [
              0,
              1
            ]
          ],
          [[
              104,
              3
            ]],
          [[
              0,
              3
            ]]
        ],
        {
          8: 1,
          9: 1,
          11: 1,
          13: 1,
          17: 1,
          20: 1,
          28: 1
        }
      ],
      315: [
        [
          [[
              12,
              1
            ]],
          [
            [
              44,
              2
            ],
            [
              136,
              3
            ],
            [
              0,
              1
            ]
          ],
          [
            [
              45,
              4
            ],
            [
              0,
              2
            ]
          ],
          [[
              44,
              5
            ]],
          [
            [
              44,
              2
            ],
            [
              0,
              4
            ]
          ],
          [
            [
              45,
              6
            ],
            [
              0,
              5
            ]
          ],
          [[
              44,
              7
            ]],
          [
            [
              45,
              8
            ],
            [
              0,
              7
            ]
          ],
          [
            [
              44,
              7
            ],
            [
              0,
              8
            ]
          ]
        ],
        { 12: 1 }
      ],
      316: [
        [
          [[
              5,
              1
            ]],
          [
            [
              44,
              2
            ],
            [
              0,
              1
            ]
          ],
          [
            [
              45,
              3
            ],
            [
              0,
              2
            ]
          ],
          [[
              44,
              4
            ]],
          [
            [
              45,
              5
            ],
            [
              0,
              4
            ]
          ],
          [[
              44,
              6
            ]],
          [[
              0,
              6
            ]]
        ],
        { 5: 1 }
      ],
      317: [
        [
          [[
              18,
              1
            ]],
          [
            [
              71,
              2
            ],
            [
              0,
              1
            ]
          ],
          [[
              0,
              2
            ]]
        ],
        { 18: 1 }
      ],
      318: [
        [
          [[
              137,
              1
            ]],
          [
            [
              136,
              0
            ],
            [
              138,
              0
            ],
            [
              0,
              1
            ]
          ]
        ],
        {
          6: 1,
          8: 1,
          9: 1,
          11: 1,
          13: 1,
          17: 1,
          20: 1,
          24: 1,
          28: 1,
          35: 1
        }
      ],
      319: [
        [
          [[
              139,
              1
            ]],
          [
            [
              2,
              2
            ],
            [
              140,
              3
            ]
          ],
          [[
              0,
              2
            ]],
          [
            [
              139,
              1
            ],
            [
              2,
              2
            ]
          ]
        ],
        {
          5: 1,
          6: 1,
          7: 1,
          8: 1,
          9: 1,
          11: 1,
          12: 1,
          13: 1,
          15: 1,
          17: 1,
          18: 1,
          19: 1,
          20: 1,
          21: 1,
          22: 1,
          23: 1,
          24: 1,
          25: 1,
          26: 1,
          28: 1,
          29: 1,
          31: 1,
          32: 1,
          35: 1,
          36: 1
        }
      ],
      320: [
        [
          [[
              69,
              1
            ]],
          [
            [
              44,
              2
            ],
            [
              0,
              1
            ]
          ],
          [[
              0,
              2
            ]]
        ],
        { 69: 1 }
      ],
      321: [
        [
          [
            [
              141,
              1
            ],
            [
              142,
              1
            ],
            [
              143,
              1
            ],
            [
              144,
              1
            ],
            [
              145,
              1
            ],
            [
              146,
              1
            ],
            [
              147,
              1
            ],
            [
              148,
              1
            ],
            [
              149,
              1
            ]
          ],
          [[
              0,
              1
            ]]
        ],
        {
          5: 1,
          6: 1,
          7: 1,
          8: 1,
          9: 1,
          11: 1,
          12: 1,
          13: 1,
          15: 1,
          17: 1,
          18: 1,
          19: 1,
          20: 1,
          21: 1,
          22: 1,
          23: 1,
          24: 1,
          25: 1,
          26: 1,
          28: 1,
          29: 1,
          31: 1,
          32: 1,
          35: 1,
          36: 1
        }
      ],
      322: [
        [
          [
            [
              1,
              1
            ],
            [
              3,
              1
            ]
          ],
          [[
              0,
              1
            ]]
        ],
        {
          4: 1,
          5: 1,
          6: 1,
          7: 1,
          8: 1,
          9: 1,
          10: 1,
          11: 1,
          12: 1,
          13: 1,
          14: 1,
          15: 1,
          16: 1,
          17: 1,
          18: 1,
          19: 1,
          20: 1,
          21: 1,
          22: 1,
          23: 1,
          24: 1,
          25: 1,
          26: 1,
          27: 1,
          28: 1,
          29: 1,
          30: 1,
          31: 1,
          32: 1,
          33: 1,
          34: 1,
          35: 1,
          36: 1
        }
      ],
      323: [
        [
          [
            [
              44,
              1
            ],
            [
              69,
              2
            ],
            [
              97,
              3
            ]
          ],
          [
            [
              69,
              2
            ],
            [
              0,
              1
            ]
          ],
          [
            [
              44,
              4
            ],
            [
              150,
              5
            ],
            [
              0,
              2
            ]
          ],
          [[
              97,
              6
            ]],
          [
            [
              150,
              5
            ],
            [
              0,
              4
            ]
          ],
          [[
              0,
              5
            ]],
          [[
              97,
              5
            ]]
        ],
        {
          6: 1,
          7: 1,
          8: 1,
          9: 1,
          11: 1,
          13: 1,
          17: 1,
          20: 1,
          24: 1,
          28: 1,
          35: 1,
          36: 1,
          69: 1,
          97: 1
        }
      ],
      324: [
        [
          [[
              151,
              1
            ]],
          [
            [
              45,
              2
            ],
            [
              0,
              1
            ]
          ],
          [
            [
              151,
              1
            ],
            [
              0,
              2
            ]
          ]
        ],
        {
          6: 1,
          7: 1,
          8: 1,
          9: 1,
          11: 1,
          13: 1,
          17: 1,
          20: 1,
          24: 1,
          28: 1,
          35: 1,
          36: 1,
          69: 1,
          97: 1
        }
      ],
      325: [
        [
          [
            [
              1,
              1
            ],
            [
              2,
              2
            ]
          ],
          [[
              0,
              1
            ]],
          [[
              152,
              3
            ]],
          [[
              105,
              4
            ]],
          [
            [
              153,
              1
            ],
            [
              105,
              4
            ]
          ]
        ],
        {
          2: 1,
          5: 1,
          6: 1,
          7: 1,
          8: 1,
          9: 1,
          11: 1,
          12: 1,
          13: 1,
          15: 1,
          17: 1,
          18: 1,
          19: 1,
          20: 1,
          21: 1,
          22: 1,
          23: 1,
          24: 1,
          25: 1,
          26: 1,
          28: 1,
          29: 1,
          31: 1,
          32: 1,
          35: 1,
          36: 1
        }
      ],
      326: [
        [
          [[
              104,
              1
            ]],
          [
            [
              154,
              0
            ],
            [
              41,
              0
            ],
            [
              155,
              0
            ],
            [
              156,
              0
            ],
            [
              0,
              1
            ]
          ]
        ],
        {
          6: 1,
          8: 1,
          9: 1,
          11: 1,
          13: 1,
          17: 1,
          20: 1,
          24: 1,
          28: 1,
          35: 1
        }
      ],
      327: [
        [
          [
            [
              115,
              1
            ],
            [
              157,
              2
            ]
          ],
          [
            [
              30,
              3
            ],
            [
              0,
              1
            ]
          ],
          [[
              0,
              2
            ]],
          [[
              115,
              4
            ]],
          [[
              111,
              5
            ]],
          [[
              44,
              2
            ]]
        ],
        {
          6: 1,
          7: 1,
          8: 1,
          9: 1,
          11: 1,
          13: 1,
          17: 1,
          20: 1,
          24: 1,
          28: 1,
          35: 1,
          36: 1
        }
      ],
      328: [
        [
          [[
              44,
              1
            ]],
          [
            [
              45,
              2
            ],
            [
              0,
              1
            ]
          ],
          [
            [
              44,
              1
            ],
            [
              0,
              2
            ]
          ]
        ],
        {
          6: 1,
          7: 1,
          8: 1,
          9: 1,
          11: 1,
          13: 1,
          17: 1,
          20: 1,
          24: 1,
          28: 1,
          35: 1,
          36: 1
        }
      ],
      329: [
        [
          [[
              44,
              1
            ]],
          [
            [
              45,
              0
            ],
            [
              0,
              1
            ]
          ]
        ],
        {
          6: 1,
          7: 1,
          8: 1,
          9: 1,
          11: 1,
          13: 1,
          17: 1,
          20: 1,
          24: 1,
          28: 1,
          35: 1,
          36: 1
        }
      ],
      330: [
        [
          [[
              44,
              1
            ]],
          [
            [
              46,
              2
            ],
            [
              45,
              3
            ],
            [
              0,
              1
            ]
          ],
          [[
              0,
              2
            ]],
          [
            [
              44,
              4
            ],
            [
              0,
              3
            ]
          ],
          [
            [
              45,
              3
            ],
            [
              0,
              4
            ]
          ]
        ],
        {
          6: 1,
          7: 1,
          8: 1,
          9: 1,
          11: 1,
          13: 1,
          17: 1,
          20: 1,
          24: 1,
          28: 1,
          35: 1,
          36: 1
        }
      ],
      331: [
        [
          [[
              117,
              1
            ]],
          [
            [
              45,
              2
            ],
            [
              0,
              1
            ]
          ],
          [[
              117,
              3
            ]],
          [
            [
              45,
              4
            ],
            [
              0,
              3
            ]
          ],
          [
            [
              117,
              3
            ],
            [
              0,
              4
            ]
          ]
        ],
        {
          6: 1,
          7: 1,
          8: 1,
          9: 1,
          11: 1,
          13: 1,
          17: 1,
          20: 1,
          24: 1,
          28: 1,
          35: 1,
          36: 1
        }
      ],
      332: [
        [
          [
            [
              28,
              1
            ],
            [
              97,
              2
            ],
            [
              11,
              3
            ]
          ],
          [
            [
              51,
              4
            ],
            [
              92,
              5
            ]
          ],
          [[
              20,
              4
            ]],
          [[
              158,
              6
            ]],
          [[
              0,
              4
            ]],
          [[
              51,
              4
            ]],
          [[
              50,
              4
            ]]
        ],
        {
          11: 1,
          28: 1,
          97: 1
        }
      ],
      333: [
        [
          [[
              14,
              1
            ]],
          [[
              69,
              2
            ]],
          [[
              70,
              3
            ]],
          [
            [
              159,
              4
            ],
            [
              160,
              5
            ]
          ],
          [[
              69,
              6
            ]],
          [[
              69,
              7
            ]],
          [[
              70,
              8
            ]],
          [[
              70,
              9
            ]],
          [
            [
              159,
              4
            ],
            [
              111,
              10
            ],
            [
              160,
              5
            ],
            [
              0,
              8
            ]
          ],
          [[
              0,
              9
            ]],
          [[
              69,
              11
            ]],
          [[
              70,
              12
            ]],
          [
            [
              160,
              5
            ],
            [
              0,
              12
            ]
          ]
        ],
        { 14: 1 }
      ],
      334: [
        [
          [
            [
              41,
              1
            ],
            [
              113,
              2
            ],
            [
              43,
              3
            ]
          ],
          [[
              20,
              4
            ]],
          [
            [
              47,
              5
            ],
            [
              45,
              6
            ],
            [
              0,
              2
            ]
          ],
          [[
              20,
              7
            ]],
          [
            [
              45,
              8
            ],
            [
              0,
              4
            ]
          ],
          [[
              44,
              9
            ]],
          [
            [
              41,
              1
            ],
            [
              113,
              2
            ],
            [
              43,
              3
            ],
            [
              0,
              6
            ]
          ],
          [[
              0,
              7
            ]],
          [[
              43,
              3
            ]],
          [
            [
              45,
              6
            ],
            [
              0,
              9
            ]
          ]
        ],
        {
          20: 1,
          28: 1,
          41: 1,
          43: 1
        }
      ],
      335: [
        [
          [[
              16,
              1
            ]],
          [[
              44,
              2
            ]],
          [[
              69,
              3
            ]],
          [[
              70,
              4
            ]],
          [
            [
              111,
              5
            ],
            [
              0,
              4
            ]
          ],
          [[
              69,
              6
            ]],
          [[
              70,
              7
            ]],
          [[
              0,
              7
            ]]
        ],
        { 16: 1 }
      ],
      336: [
        [
          [[
              34,
              1
            ]],
          [[
              44,
              2
            ]],
          [
            [
              69,
              3
            ],
            [
              161,
              4
            ]
          ],
          [[
              70,
              5
            ]],
          [[
              69,
              3
            ]],
          [[
              0,
              5
            ]]
        ],
        { 34: 1 }
      ],
      337: [
        [
          [[
              95,
              1
            ]],
          [[
              80,
              2
            ]],
          [[
              0,
              2
            ]]
        ],
        { 95: 1 }
      ],
      338: [
        [
          [[
              162,
              1
            ]],
          [
            [
              163,
              0
            ],
            [
              0,
              1
            ]
          ]
        ],
        {
          6: 1,
          8: 1,
          9: 1,
          11: 1,
          13: 1,
          17: 1,
          20: 1,
          24: 1,
          28: 1,
          35: 1
        }
      ],
      339: [
        [
          [[
              25,
              1
            ]],
          [
            [
              71,
              2
            ],
            [
              0,
              1
            ]
          ],
          [[
              0,
              2
            ]]
        ],
        { 25: 1 }
      ],
      340: [
        [
          [[
              53,
              1
            ]],
          [[
              0,
              1
            ]]
        ],
        { 25: 1 }
      ]
    },
    states: [
      [
        [
          [
            1,
            1
          ],
          [
            2,
            1
          ],
          [
            3,
            2
          ]
        ],
        [[
            0,
            1
          ]],
        [[
            2,
            1
          ]]
      ],
      [
        [[
            37,
            1
          ]],
        [
          [
            38,
            0
          ],
          [
            0,
            1
          ]
        ]
      ],
      [
        [[
            39,
            1
          ]],
        [
          [
            40,
            0
          ],
          [
            0,
            1
          ]
        ]
      ],
      [
        [
          [
            41,
            1
          ],
          [
            42,
            2
          ],
          [
            43,
            3
          ]
        ],
        [[
            44,
            4
          ]],
        [
          [
            45,
            5
          ],
          [
            0,
            2
          ]
        ],
        [[
            44,
            6
          ]],
        [
          [
            45,
            7
          ],
          [
            0,
            4
          ]
        ],
        [
          [
            41,
            1
          ],
          [
            42,
            2
          ],
          [
            43,
            3
          ],
          [
            0,
            5
          ]
        ],
        [[
            0,
            6
          ]],
        [
          [
            42,
            4
          ],
          [
            43,
            3
          ]
        ]
      ],
      [
        [[
            44,
            1
          ]],
        [
          [
            46,
            2
          ],
          [
            47,
            3
          ],
          [
            0,
            1
          ]
        ],
        [[
            0,
            2
          ]],
        [[
            44,
            2
          ]]
      ],
      [
        [[
            48,
            1
          ]],
        [
          [
            24,
            0
          ],
          [
            35,
            0
          ],
          [
            0,
            1
          ]
        ]
      ],
      [
        [[
            19,
            1
          ]],
        [[
            44,
            2
          ]],
        [
          [
            45,
            3
          ],
          [
            0,
            2
          ]
        ],
        [[
            44,
            4
          ]],
        [[
            0,
            4
          ]]
      ],
      [
        [
          [
            17,
            1
          ],
          [
            8,
            2
          ],
          [
            9,
            5
          ],
          [
            28,
            4
          ],
          [
            11,
            3
          ],
          [
            13,
            6
          ],
          [
            20,
            2
          ]
        ],
        [
          [
            17,
            1
          ],
          [
            0,
            1
          ]
        ],
        [[
            0,
            2
          ]],
        [
          [
            49,
            7
          ],
          [
            50,
            2
          ]
        ],
        [
          [
            51,
            2
          ],
          [
            52,
            8
          ],
          [
            53,
            8
          ]
        ],
        [
          [
            54,
            9
          ],
          [
            55,
            2
          ]
        ],
        [[
            56,
            10
          ]],
        [[
            50,
            2
          ]],
        [[
            51,
            2
          ]],
        [[
            55,
            2
          ]],
        [[
            13,
            2
          ]]
      ],
      [
        [
          [
            57,
            1
          ],
          [
            58,
            1
          ],
          [
            59,
            1
          ],
          [
            60,
            1
          ],
          [
            61,
            1
          ],
          [
            62,
            1
          ],
          [
            63,
            1
          ],
          [
            64,
            1
          ],
          [
            65,
            1
          ],
          [
            66,
            1
          ],
          [
            67,
            1
          ],
          [
            68,
            1
          ]
        ],
        [[
            0,
            1
          ]]
      ],
      [
        [[
            31,
            1
          ]],
        [[
            0,
            1
          ]]
      ],
      [
        [[
            10,
            1
          ]],
        [[
            20,
            2
          ]],
        [
          [
            69,
            3
          ],
          [
            28,
            4
          ]
        ],
        [[
            70,
            5
          ]],
        [
          [
            51,
            6
          ],
          [
            71,
            7
          ]
        ],
        [[
            0,
            5
          ]],
        [[
            69,
            3
          ]],
        [[
            51,
            6
          ]]
      ],
      [
        [
          [
            72,
            1
          ],
          [
            73,
            1
          ],
          [
            7,
            2
          ],
          [
            74,
            1
          ],
          [
            72,
            1
          ],
          [
            75,
            1
          ],
          [
            76,
            1
          ],
          [
            77,
            3
          ],
          [
            78,
            1
          ],
          [
            79,
            1
          ]
        ],
        [[
            0,
            1
          ]],
        [[
            75,
            1
          ]],
        [
          [
            7,
            1
          ],
          [
            0,
            3
          ]
        ]
      ],
      [
        [[
            80,
            1
          ]],
        [
          [
            81,
            0
          ],
          [
            0,
            1
          ]
        ]
      ],
      [
        [
          [
            82,
            1
          ],
          [
            83,
            1
          ],
          [
            84,
            1
          ],
          [
            85,
            1
          ],
          [
            86,
            1
          ],
          [
            87,
            1
          ],
          [
            88,
            1
          ],
          [
            89,
            1
          ]
        ],
        [[
            0,
            1
          ]]
      ],
      [
        [[
            32,
            1
          ]],
        [[
            0,
            1
          ]]
      ],
      [
        [[
            90,
            1
          ]],
        [
          [
            88,
            2
          ],
          [
            85,
            2
          ]
        ],
        [[
            0,
            2
          ]]
      ],
      [
        [[
            33,
            1
          ]],
        [[
            91,
            2
          ]],
        [
          [
            28,
            4
          ],
          [
            2,
            3
          ]
        ],
        [[
            0,
            3
          ]],
        [
          [
            51,
            5
          ],
          [
            92,
            6
          ]
        ],
        [[
            2,
            3
          ]],
        [[
            51,
            5
          ]]
      ],
      [
        [[
            93,
            1
          ]],
        [
          [
            93,
            1
          ],
          [
            0,
            1
          ]
        ]
      ],
      [
        [[
            21,
            1
          ]],
        [[
            94,
            2
          ]],
        [[
            0,
            2
          ]]
      ],
      [
        [[
            44,
            1
          ]],
        [[
            69,
            2
          ]],
        [[
            44,
            3
          ]],
        [
          [
            45,
            4
          ],
          [
            0,
            3
          ]
        ],
        [
          [
            44,
            1
          ],
          [
            0,
            4
          ]
        ]
      ],
      [
        [[
            91,
            1
          ]],
        [
          [
            95,
            2
          ],
          [
            0,
            1
          ]
        ],
        [[
            20,
            3
          ]],
        [[
            0,
            3
          ]]
      ],
      [
        [[
            96,
            1
          ]],
        [
          [
            45,
            0
          ],
          [
            0,
            1
          ]
        ]
      ],
      [
        [[
            20,
            1
          ]],
        [
          [
            97,
            0
          ],
          [
            0,
            1
          ]
        ]
      ],
      [
        [[
            20,
            1
          ]],
        [[
            0,
            1
          ]]
      ],
      [
        [[
            71,
            1
          ]],
        [
          [
            2,
            1
          ],
          [
            98,
            2
          ]
        ],
        [[
            0,
            2
          ]]
      ],
      [
        [[
            99,
            1
          ]],
        [
          [
            44,
            2
          ],
          [
            0,
            1
          ]
        ],
        [
          [
            95,
            3
          ],
          [
            45,
            3
          ],
          [
            0,
            2
          ]
        ],
        [[
            44,
            4
          ]],
        [[
            0,
            4
          ]]
      ],
      [
        [[
            15,
            1
          ]],
        [[
            80,
            2
          ]],
        [
          [
            75,
            3
          ],
          [
            0,
            2
          ]
        ],
        [[
            44,
            4
          ]],
        [
          [
            45,
            5
          ],
          [
            0,
            4
          ]
        ],
        [[
            44,
            6
          ]],
        [[
            0,
            6
          ]]
      ],
      [
        [[
            100,
            1
          ]],
        [
          [
            101,
            0
          ],
          [
            0,
            1
          ]
        ]
      ],
      [
        [[
            71,
            1
          ]],
        [
          [
            102,
            2
          ],
          [
            47,
            3
          ],
          [
            0,
            1
          ]
        ],
        [
          [
            71,
            4
          ],
          [
            53,
            4
          ]
        ],
        [
          [
            71,
            5
          ],
          [
            53,
            5
          ]
        ],
        [[
            0,
            4
          ]],
        [
          [
            47,
            3
          ],
          [
            0,
            5
          ]
        ]
      ],
      [
        [[
            80,
            1
          ]],
        [
          [
            45,
            2
          ],
          [
            0,
            1
          ]
        ],
        [
          [
            80,
            1
          ],
          [
            0,
            2
          ]
        ]
      ],
      [
        [
          [
            103,
            2
          ],
          [
            24,
            1
          ],
          [
            6,
            1
          ],
          [
            35,
            1
          ]
        ],
        [[
            104,
            2
          ]],
        [[
            0,
            2
          ]]
      ],
      [
        [
          [
            2,
            0
          ],
          [
            98,
            1
          ],
          [
            105,
            0
          ]
        ],
        [[
            0,
            1
          ]]
      ],
      [
        [
          [
            106,
            1
          ],
          [
            107,
            1
          ],
          [
            108,
            1
          ],
          [
            109,
            1
          ],
          [
            110,
            1
          ]
        ],
        [[
            0,
            1
          ]]
      ],
      [
        [[
            27,
            1
          ]],
        [[
            94,
            2
          ]],
        [[
            75,
            3
          ]],
        [[
            71,
            4
          ]],
        [[
            69,
            5
          ]],
        [[
            70,
            6
          ]],
        [
          [
            111,
            7
          ],
          [
            0,
            6
          ]
        ],
        [[
            69,
            8
          ]],
        [[
            70,
            9
          ]],
        [[
            0,
            9
          ]]
      ],
      [
        [
          [
            28,
            1
          ],
          [
            20,
            2
          ]
        ],
        [[
            112,
            3
          ]],
        [[
            0,
            2
          ]],
        [[
            51,
            2
          ]]
      ],
      [
        [[
            113,
            1
          ]],
        [
          [
            45,
            2
          ],
          [
            0,
            1
          ]
        ],
        [
          [
            113,
            1
          ],
          [
            0,
            2
          ]
        ]
      ],
      [
        [[
            4,
            1
          ]],
        [[
            20,
            2
          ]],
        [[
            114,
            3
          ]],
        [[
            69,
            4
          ]],
        [[
            70,
            5
          ]],
        [[
            0,
            5
          ]]
      ],
      [
        [[
            27,
            1
          ]],
        [[
            94,
            2
          ]],
        [[
            75,
            3
          ]],
        [[
            115,
            4
          ]],
        [
          [
            116,
            5
          ],
          [
            0,
            4
          ]
        ],
        [[
            0,
            5
          ]]
      ],
      [
        [[
            30,
            1
          ]],
        [[
            117,
            2
          ]],
        [
          [
            116,
            3
          ],
          [
            0,
            2
          ]
        ],
        [[
            0,
            3
          ]]
      ],
      [
        [
          [
            46,
            1
          ],
          [
            118,
            1
          ]
        ],
        [[
            0,
            1
          ]]
      ],
      [
        [[
            26,
            1
          ]],
        [[
            20,
            2
          ]],
        [
          [
            45,
            1
          ],
          [
            0,
            2
          ]
        ]
      ],
      [
        [[
            30,
            1
          ]],
        [[
            44,
            2
          ]],
        [[
            69,
            3
          ]],
        [[
            70,
            4
          ]],
        [
          [
            111,
            5
          ],
          [
            119,
            1
          ],
          [
            0,
            4
          ]
        ],
        [[
            69,
            6
          ]],
        [[
            70,
            7
          ]],
        [[
            0,
            7
          ]]
      ],
      [
        [[
            20,
            1
          ]],
        [
          [
            95,
            2
          ],
          [
            0,
            1
          ]
        ],
        [[
            20,
            3
          ]],
        [[
            0,
            3
          ]]
      ],
      [
        [[
            120,
            1
          ]],
        [
          [
            45,
            2
          ],
          [
            0,
            1
          ]
        ],
        [
          [
            120,
            1
          ],
          [
            0,
            2
          ]
        ]
      ],
      [
        [[
            29,
            1
          ]],
        [
          [
            91,
            2
          ],
          [
            97,
            3
          ]
        ],
        [[
            23,
            4
          ]],
        [
          [
            91,
            2
          ],
          [
            23,
            4
          ],
          [
            97,
            3
          ]
        ],
        [
          [
            121,
            5
          ],
          [
            41,
            5
          ],
          [
            28,
            6
          ]
        ],
        [[
            0,
            5
          ]],
        [[
            121,
            7
          ]],
        [[
            51,
            5
          ]]
      ],
      [
        [[
            23,
            1
          ]],
        [[
            122,
            2
          ]],
        [[
            0,
            2
          ]]
      ],
      [
        [
          [
            123,
            1
          ],
          [
            124,
            1
          ]
        ],
        [[
            0,
            1
          ]]
      ],
      [
        [[
            36,
            1
          ]],
        [
          [
            69,
            2
          ],
          [
            125,
            3
          ]
        ],
        [[
            44,
            4
          ]],
        [[
            69,
            2
          ]],
        [[
            0,
            4
          ]]
      ],
      [
        [[
            27,
            1
          ]],
        [[
            94,
            2
          ]],
        [[
            75,
            3
          ]],
        [[
            126,
            4
          ]],
        [
          [
            127,
            5
          ],
          [
            0,
            4
          ]
        ],
        [[
            0,
            5
          ]]
      ],
      [
        [[
            30,
            1
          ]],
        [[
            117,
            2
          ]],
        [
          [
            127,
            3
          ],
          [
            0,
            2
          ]
        ],
        [[
            0,
            3
          ]]
      ],
      [
        [
          [
            128,
            1
          ],
          [
            129,
            1
          ]
        ],
        [[
            0,
            1
          ]]
      ],
      [
        [[
            44,
            1
          ]],
        [
          [
            128,
            2
          ],
          [
            45,
            3
          ],
          [
            0,
            1
          ]
        ],
        [[
            0,
            2
          ]],
        [
          [
            44,
            4
          ],
          [
            0,
            3
          ]
        ],
        [
          [
            45,
            3
          ],
          [
            0,
            4
          ]
        ]
      ],
      [
        [
          [
            7,
            1
          ],
          [
            130,
            2
          ]
        ],
        [[
            39,
            2
          ]],
        [[
            0,
            2
          ]]
      ],
      [
        [[
            36,
            1
          ]],
        [
          [
            69,
            2
          ],
          [
            125,
            3
          ]
        ],
        [[
            117,
            4
          ]],
        [[
            69,
            2
          ]],
        [[
            0,
            4
          ]]
      ],
      [
        [
          [
            131,
            1
          ],
          [
            115,
            1
          ]
        ],
        [[
            0,
            1
          ]]
      ],
      [
        [[
            132,
            1
          ]],
        [
          [
            133,
            0
          ],
          [
            0,
            1
          ]
        ]
      ],
      [
        [[
            28,
            1
          ]],
        [
          [
            51,
            2
          ],
          [
            125,
            3
          ]
        ],
        [[
            0,
            2
          ]],
        [[
            51,
            2
          ]]
      ],
      [
        [[
            22,
            1
          ]],
        [[
            0,
            1
          ]]
      ],
      [
        [[
            134,
            1
          ]],
        [
          [
            135,
            1
          ],
          [
            43,
            2
          ],
          [
            0,
            1
          ]
        ],
        [[
            104,
            3
          ]],
        [[
            0,
            3
          ]]
      ],
      [
        [[
            12,
            1
          ]],
        [
          [
            44,
            2
          ],
          [
            136,
            3
          ],
          [
            0,
            1
          ]
        ],
        [
          [
            45,
            4
          ],
          [
            0,
            2
          ]
        ],
        [[
            44,
            5
          ]],
        [
          [
            44,
            2
          ],
          [
            0,
            4
          ]
        ],
        [
          [
            45,
            6
          ],
          [
            0,
            5
          ]
        ],
        [[
            44,
            7
          ]],
        [
          [
            45,
            8
          ],
          [
            0,
            7
          ]
        ],
        [
          [
            44,
            7
          ],
          [
            0,
            8
          ]
        ]
      ],
      [
        [[
            5,
            1
          ]],
        [
          [
            44,
            2
          ],
          [
            0,
            1
          ]
        ],
        [
          [
            45,
            3
          ],
          [
            0,
            2
          ]
        ],
        [[
            44,
            4
          ]],
        [
          [
            45,
            5
          ],
          [
            0,
            4
          ]
        ],
        [[
            44,
            6
          ]],
        [[
            0,
            6
          ]]
      ],
      [
        [[
            18,
            1
          ]],
        [
          [
            71,
            2
          ],
          [
            0,
            1
          ]
        ],
        [[
            0,
            2
          ]]
      ],
      [
        [[
            137,
            1
          ]],
        [
          [
            136,
            0
          ],
          [
            138,
            0
          ],
          [
            0,
            1
          ]
        ]
      ],
      [
        [[
            139,
            1
          ]],
        [
          [
            2,
            2
          ],
          [
            140,
            3
          ]
        ],
        [[
            0,
            2
          ]],
        [
          [
            139,
            1
          ],
          [
            2,
            2
          ]
        ]
      ],
      [
        [[
            69,
            1
          ]],
        [
          [
            44,
            2
          ],
          [
            0,
            1
          ]
        ],
        [[
            0,
            2
          ]]
      ],
      [
        [
          [
            141,
            1
          ],
          [
            142,
            1
          ],
          [
            143,
            1
          ],
          [
            144,
            1
          ],
          [
            145,
            1
          ],
          [
            146,
            1
          ],
          [
            147,
            1
          ],
          [
            148,
            1
          ],
          [
            149,
            1
          ]
        ],
        [[
            0,
            1
          ]]
      ],
      [
        [
          [
            1,
            1
          ],
          [
            3,
            1
          ]
        ],
        [[
            0,
            1
          ]]
      ],
      [
        [
          [
            44,
            1
          ],
          [
            69,
            2
          ],
          [
            97,
            3
          ]
        ],
        [
          [
            69,
            2
          ],
          [
            0,
            1
          ]
        ],
        [
          [
            44,
            4
          ],
          [
            150,
            5
          ],
          [
            0,
            2
          ]
        ],
        [[
            97,
            6
          ]],
        [
          [
            150,
            5
          ],
          [
            0,
            4
          ]
        ],
        [[
            0,
            5
          ]],
        [[
            97,
            5
          ]]
      ],
      [
        [[
            151,
            1
          ]],
        [
          [
            45,
            2
          ],
          [
            0,
            1
          ]
        ],
        [
          [
            151,
            1
          ],
          [
            0,
            2
          ]
        ]
      ],
      [
        [
          [
            1,
            1
          ],
          [
            2,
            2
          ]
        ],
        [[
            0,
            1
          ]],
        [[
            152,
            3
          ]],
        [[
            105,
            4
          ]],
        [
          [
            153,
            1
          ],
          [
            105,
            4
          ]
        ]
      ],
      [
        [[
            104,
            1
          ]],
        [
          [
            154,
            0
          ],
          [
            41,
            0
          ],
          [
            155,
            0
          ],
          [
            156,
            0
          ],
          [
            0,
            1
          ]
        ]
      ],
      [
        [
          [
            115,
            1
          ],
          [
            157,
            2
          ]
        ],
        [
          [
            30,
            3
          ],
          [
            0,
            1
          ]
        ],
        [[
            0,
            2
          ]],
        [[
            115,
            4
          ]],
        [[
            111,
            5
          ]],
        [[
            44,
            2
          ]]
      ],
      [
        [[
            44,
            1
          ]],
        [
          [
            45,
            2
          ],
          [
            0,
            1
          ]
        ],
        [
          [
            44,
            1
          ],
          [
            0,
            2
          ]
        ]
      ],
      [
        [[
            44,
            1
          ]],
        [
          [
            45,
            0
          ],
          [
            0,
            1
          ]
        ]
      ],
      [
        [[
            44,
            1
          ]],
        [
          [
            46,
            2
          ],
          [
            45,
            3
          ],
          [
            0,
            1
          ]
        ],
        [[
            0,
            2
          ]],
        [
          [
            44,
            4
          ],
          [
            0,
            3
          ]
        ],
        [
          [
            45,
            3
          ],
          [
            0,
            4
          ]
        ]
      ],
      [
        [[
            117,
            1
          ]],
        [
          [
            45,
            2
          ],
          [
            0,
            1
          ]
        ],
        [[
            117,
            3
          ]],
        [
          [
            45,
            4
          ],
          [
            0,
            3
          ]
        ],
        [
          [
            117,
            3
          ],
          [
            0,
            4
          ]
        ]
      ],
      [
        [
          [
            28,
            1
          ],
          [
            97,
            2
          ],
          [
            11,
            3
          ]
        ],
        [
          [
            51,
            4
          ],
          [
            92,
            5
          ]
        ],
        [[
            20,
            4
          ]],
        [[
            158,
            6
          ]],
        [[
            0,
            4
          ]],
        [[
            51,
            4
          ]],
        [[
            50,
            4
          ]]
      ],
      [
        [[
            14,
            1
          ]],
        [[
            69,
            2
          ]],
        [[
            70,
            3
          ]],
        [
          [
            159,
            4
          ],
          [
            160,
            5
          ]
        ],
        [[
            69,
            6
          ]],
        [[
            69,
            7
          ]],
        [[
            70,
            8
          ]],
        [[
            70,
            9
          ]],
        [
          [
            159,
            4
          ],
          [
            111,
            10
          ],
          [
            160,
            5
          ],
          [
            0,
            8
          ]
        ],
        [[
            0,
            9
          ]],
        [[
            69,
            11
          ]],
        [[
            70,
            12
          ]],
        [
          [
            160,
            5
          ],
          [
            0,
            12
          ]
        ]
      ],
      [
        [
          [
            41,
            1
          ],
          [
            113,
            2
          ],
          [
            43,
            3
          ]
        ],
        [[
            20,
            4
          ]],
        [
          [
            47,
            5
          ],
          [
            45,
            6
          ],
          [
            0,
            2
          ]
        ],
        [[
            20,
            7
          ]],
        [
          [
            45,
            8
          ],
          [
            0,
            4
          ]
        ],
        [[
            44,
            9
          ]],
        [
          [
            41,
            1
          ],
          [
            113,
            2
          ],
          [
            43,
            3
          ],
          [
            0,
            6
          ]
        ],
        [[
            0,
            7
          ]],
        [[
            43,
            3
          ]],
        [
          [
            45,
            6
          ],
          [
            0,
            9
          ]
        ]
      ],
      [
        [[
            16,
            1
          ]],
        [[
            44,
            2
          ]],
        [[
            69,
            3
          ]],
        [[
            70,
            4
          ]],
        [
          [
            111,
            5
          ],
          [
            0,
            4
          ]
        ],
        [[
            69,
            6
          ]],
        [[
            70,
            7
          ]],
        [[
            0,
            7
          ]]
      ],
      [
        [[
            34,
            1
          ]],
        [[
            44,
            2
          ]],
        [
          [
            69,
            3
          ],
          [
            161,
            4
          ]
        ],
        [[
            70,
            5
          ]],
        [[
            69,
            3
          ]],
        [[
            0,
            5
          ]]
      ],
      [
        [[
            95,
            1
          ]],
        [[
            80,
            2
          ]],
        [[
            0,
            2
          ]]
      ],
      [
        [[
            162,
            1
          ]],
        [
          [
            163,
            0
          ],
          [
            0,
            1
          ]
        ]
      ],
      [
        [[
            25,
            1
          ]],
        [
          [
            71,
            2
          ],
          [
            0,
            1
          ]
        ],
        [[
            0,
            2
          ]]
      ],
      [
        [[
            53,
            1
          ]],
        [[
            0,
            1
          ]]
      ]
    ],
    labels: [
      [
        0,
        'EMPTY'
      ],
      [
        319,
        null
      ],
      [
        4,
        null
      ],
      [
        269,
        null
      ],
      [
        1,
        'def'
      ],
      [
        1,
        'raise'
      ],
      [
        32,
        null
      ],
      [
        1,
        'not'
      ],
      [
        2,
        null
      ],
      [
        26,
        null
      ],
      [
        1,
        'class'
      ],
      [
        9,
        null
      ],
      [
        1,
        'print'
      ],
      [
        25,
        null
      ],
      [
        1,
        'try'
      ],
      [
        1,
        'exec'
      ],
      [
        1,
        'while'
      ],
      [
        3,
        null
      ],
      [
        1,
        'return'
      ],
      [
        1,
        'assert'
      ],
      [
        1,
        null
      ],
      [
        1,
        'del'
      ],
      [
        1,
        'pass'
      ],
      [
        1,
        'import'
      ],
      [
        15,
        null
      ],
      [
        1,
        'yield'
      ],
      [
        1,
        'global'
      ],
      [
        1,
        'for'
      ],
      [
        7,
        null
      ],
      [
        1,
        'from'
      ],
      [
        1,
        'if'
      ],
      [
        1,
        'break'
      ],
      [
        1,
        'continue'
      ],
      [
        50,
        null
      ],
      [
        1,
        'with'
      ],
      [
        14,
        null
      ],
      [
        1,
        'lambda'
      ],
      [
        318,
        null
      ],
      [
        19,
        null
      ],
      [
        308,
        null
      ],
      [
        1,
        'and'
      ],
      [
        16,
        null
      ],
      [
        260,
        null
      ],
      [
        36,
        null
      ],
      [
        327,
        null
      ],
      [
        12,
        null
      ],
      [
        293,
        null
      ],
      [
        22,
        null
      ],
      [
        326,
        null
      ],
      [
        307,
        null
      ],
      [
        10,
        null
      ],
      [
        8,
        null
      ],
      [
        330,
        null
      ],
      [
        339,
        null
      ],
      [
        275,
        null
      ],
      [
        27,
        null
      ],
      [
        329,
        null
      ],
      [
        46,
        null
      ],
      [
        39,
        null
      ],
      [
        41,
        null
      ],
      [
        47,
        null
      ],
      [
        42,
        null
      ],
      [
        43,
        null
      ],
      [
        37,
        null
      ],
      [
        44,
        null
      ],
      [
        49,
        null
      ],
      [
        40,
        null
      ],
      [
        38,
        null
      ],
      [
        45,
        null
      ],
      [
        11,
        null
      ],
      [
        325,
        null
      ],
      [
        328,
        null
      ],
      [
        29,
        null
      ],
      [
        21,
        null
      ],
      [
        28,
        null
      ],
      [
        1,
        'in'
      ],
      [
        30,
        null
      ],
      [
        1,
        'is'
      ],
      [
        31,
        null
      ],
      [
        20,
        null
      ],
      [
        283,
        null
      ],
      [
        267,
        null
      ],
      [
        333,
        null
      ],
      [
        297,
        null
      ],
      [
        289,
        null
      ],
      [
        266,
        null
      ],
      [
        336,
        null
      ],
      [
        335,
        null
      ],
      [
        292,
        null
      ],
      [
        271,
        null
      ],
      [
        273,
        null
      ],
      [
        278,
        null
      ],
      [
        259,
        null
      ],
      [
        272,
        null
      ],
      [
        285,
        null
      ],
      [
        1,
        'as'
      ],
      [
        276,
        null
      ],
      [
        23,
        null
      ],
      [
        0,
        null
      ],
      [
        1,
        'except'
      ],
      [
        338,
        null
      ],
      [
        18,
        null
      ],
      [
        264,
        null
      ],
      [
        314,
        null
      ],
      [
        286,
        null
      ],
      [
        322,
        null
      ],
      [
        265,
        null
      ],
      [
        270,
        null
      ],
      [
        316,
        null
      ],
      [
        317,
        null
      ],
      [
        340,
        null
      ],
      [
        1,
        'else'
      ],
      [
        291,
        null
      ],
      [
        290,
        null
      ],
      [
        312,
        null
      ],
      [
        311,
        null
      ],
      [
        295,
        null
      ],
      [
        310,
        null
      ],
      [
        294,
        null
      ],
      [
        1,
        'elif'
      ],
      [
        298,
        null
      ],
      [
        299,
        null
      ],
      [
        277,
        null
      ],
      [
        301,
        null
      ],
      [
        300,
        null
      ],
      [
        334,
        null
      ],
      [
        331,
        null
      ],
      [
        306,
        null
      ],
      [
        304,
        null
      ],
      [
        305,
        null
      ],
      [
        268,
        null
      ],
      [
        309,
        null
      ],
      [
        258,
        null
      ],
      [
        1,
        'or'
      ],
      [
        263,
        null
      ],
      [
        332,
        null
      ],
      [
        35,
        null
      ],
      [
        261,
        null
      ],
      [
        34,
        null
      ],
      [
        321,
        null
      ],
      [
        13,
        null
      ],
      [
        288,
        null
      ],
      [
        262,
        null
      ],
      [
        284,
        null
      ],
      [
        313,
        null
      ],
      [
        315,
        null
      ],
      [
        274,
        null
      ],
      [
        282,
        null
      ],
      [
        296,
        null
      ],
      [
        302,
        null
      ],
      [
        320,
        null
      ],
      [
        323,
        null
      ],
      [
        5,
        null
      ],
      [
        6,
        null
      ],
      [
        48,
        null
      ],
      [
        17,
        null
      ],
      [
        24,
        null
      ],
      [
        303,
        null
      ],
      [
        324,
        null
      ],
      [
        281,
        null
      ],
      [
        1,
        'finally'
      ],
      [
        337,
        null
      ],
      [
        257,
        null
      ],
      [
        33,
        null
      ]
    ],
    keywords: {
      and: 40,
      as: 95,
      assert: 19,
      'break': 31,
      'class': 10,
      'continue': 32,
      def: 4,
      del: 21,
      elif: 119,
      'else': 111,
      except: 99,
      exec: 15,
      'finally': 160,
      'for': 27,
      from: 29,
      global: 26,
      'if': 30,
      'import': 23,
      'in': 75,
      is: 77,
      lambda: 36,
      not: 7,
      or: 133,
      pass: 22,
      print: 12,
      raise: 5,
      'return': 18,
      'try': 14,
      'while': 16,
      'with': 34,
      yield: 25
    },
    tokens: {
      0: 98,
      1: 20,
      2: 8,
      3: 17,
      4: 2,
      5: 152,
      6: 153,
      7: 28,
      8: 51,
      9: 11,
      10: 50,
      11: 69,
      12: 45,
      13: 140,
      14: 35,
      15: 24,
      16: 41,
      17: 155,
      18: 101,
      19: 38,
      20: 79,
      21: 73,
      22: 47,
      23: 97,
      24: 156,
      25: 13,
      26: 9,
      27: 55,
      28: 74,
      29: 72,
      30: 76,
      31: 78,
      32: 6,
      33: 163,
      34: 138,
      35: 136,
      36: 43,
      37: 63,
      38: 67,
      39: 58,
      40: 66,
      41: 59,
      42: 61,
      43: 62,
      44: 64,
      45: 68,
      46: 57,
      47: 60,
      48: 154,
      49: 65,
      50: 33
    },
    start: 256
  };
  function Parser(a, b) {
    this.filename = a;
    this.grammar = b;
    return this;
  }
  Parser.prototype.setup = function (a) {
    a = a || this.grammar.start;
    this.stack = [{
        dfa: this.grammar.dfas[a],
        state: 0,
        node: {
          type: a,
          value: null,
          context: null,
          children: []
        }
      }];
    this.used_names = {};
  };
  function findInDfa(a, b) {
    for (var c = a.length; c--;)
      if (a[c][0] === b[0] && a[c][1] === b[1])
        return !0;
    return !1;
  }
  Parser.prototype.addtoken = function (a, b, c) {
    var d = this.classify(a, b, c);
    a:
      for (;;) {
        for (var e = this.stack[this.stack.length - 1], f = e.dfa[0], g = f[e.state], h = 0; h < g.length; ++h) {
          var l = g[h][0], k = g[h][1], m = this.grammar.labels[l][0];
          if (d === l) {
            goog.asserts.assert(256 > m);
            this.shift(a, b, k, c);
            for (a = k; 1 === f[a].length && 0 === f[a][0][0] && f[a][0][1] === a;) {
              this.pop();
              if (0 === this.stack.length)
                return !0;
              e = this.stack[this.stack.length - 1];
              a = e.state;
              f = e.dfa[0];
            }
            return !1;
          }
          if (256 <= m && this.grammar.dfas[m][1].hasOwnProperty(d)) {
            this.push(m, this.grammar.dfas[m], k, c);
            continue a;
          }
        }
        if (findInDfa(g, [
            0,
            e.state
          ])) {
          if (this.pop(), 0 === this.stack.length)
            throw new Sk.builtin.ParseError('too much input', this.filename);
        } else
          throw new Sk.builtin.ParseError('bad input', this.filename, c[0][0], c);
      }
  };
  Parser.prototype.classify = function (a, b, c) {
    if (a === Sk.Tokenizer.Tokens.T_NAME && (this.used_names[b] = !0, b = this.grammar.keywords.hasOwnProperty(b) && this.grammar.keywords[b]))
      return b;
    b = this.grammar.tokens.hasOwnProperty(a) && this.grammar.tokens[a];
    if (!b)
      throw new Sk.builtin.ParseError('bad token', this.filename, c[0][0], c);
    return b;
  };
  Parser.prototype.shift = function (a, b, c, d) {
    var e = this.stack[this.stack.length - 1].dfa, f = this.stack[this.stack.length - 1].node;
    f.children.push({
      type: a,
      value: b,
      lineno: d[0][0],
      col_offset: d[0][1],
      children: null
    });
    this.stack[this.stack.length - 1] = {
      dfa: e,
      state: c,
      node: f
    };
  };
  Parser.prototype.push = function (a, b, c, d) {
    a = {
      type: a,
      value: null,
      lineno: d[0][0],
      col_offset: d[0][1],
      children: []
    };
    this.stack[this.stack.length - 1] = {
      dfa: this.stack[this.stack.length - 1].dfa,
      state: c,
      node: this.stack[this.stack.length - 1].node
    };
    this.stack.push({
      dfa: b,
      state: 0,
      node: a
    });
  };
  Parser.prototype.pop = function () {
    var a = this.stack.pop().node;
    a && (0 !== this.stack.length ? this.stack[this.stack.length - 1].node.children.push(a) : (this.rootnode = a, this.rootnode.used_names = this.used_names));
  };
  function makeParser(a, b) {
    void 0 === b && (b = 'file_input');
    var c = new Parser(a, Sk.ParseTables);
    'file_input' === b ? c.setup(Sk.ParseTables.sym.file_input) : goog.asserts.fail('todo;');
    var d = Sk.Tokenizer.Tokens.T_COMMENT, e = Sk.Tokenizer.Tokens.T_NL, f = Sk.Tokenizer.Tokens.T_OP, g = new Sk.Tokenizer(a, 'single_input' === b, function (a, b, k, m, p) {
        if (a !== d && a !== e && (a === f && (a = Sk.OpMap[b]), c.addtoken(a, b, [
            k,
            m,
            p
          ])))
          return !0;
      });
    return function (a) {
      if (a = g.generateTokens(a)) {
        if ('done' !== a)
          throw new Sk.builtin.ParseError('incomplete input', this.filename);
        return c.rootnode;
      }
      return !1;
    };
  }
  Sk.parse = function (a, b) {
    var c = makeParser(a);
    '\n' !== b.substr(b.length - 1, 1) && (b += '\n');
    for (var d = b.split('\n'), e, f = 0; f < d.length; ++f)
      e = c(d[f] + (f === d.length - 1 ? '' : '\n'));
    return e;
  };
  Sk.parseTreeDump = function (a, b) {
    b = b || '';
    var c;
    c = '' + b;
    if (256 <= a.type) {
      c += Sk.ParseTables.number2symbol[a.type] + '\n';
      for (var d = 0; d < a.children.length; ++d)
        c += Sk.parseTreeDump(a.children[d], b + '  ');
    } else
      c += Sk.Tokenizer.tokenNames[a.type] + ': ' + Sk.ffi.remapToJs(Sk.builtin.stringToPy(a.value).tp$repr()) + '\n';
    return c;
  };
  goog.exportSymbol('Sk.parse', Sk.parse);
  goog.exportSymbol('Sk.parseTreeDump', Sk.parseTreeDump);
  function Load() {
  }
  function Store() {
  }
  function Del() {
  }
  function AugLoad() {
  }
  function AugStore() {
  }
  function Param() {
  }
  function And() {
  }
  function Or() {
  }
  function Add() {
  }
  function Sub() {
  }
  function Mult() {
  }
  function Div() {
  }
  function Mod() {
  }
  function Pow() {
  }
  function LShift() {
  }
  function RShift() {
  }
  function BitOr() {
  }
  function BitXor() {
  }
  function BitAnd() {
  }
  function FloorDiv() {
  }
  function Invert() {
  }
  function Not() {
  }
  function UAdd() {
  }
  function USub() {
  }
  function Eq() {
  }
  function NotEq() {
  }
  function Lt() {
  }
  function LtE() {
  }
  function Gt() {
  }
  function GtE() {
  }
  function Is() {
  }
  function IsNot() {
  }
  function In_() {
  }
  function NotIn() {
  }
  function Module(a) {
    this.body = a;
    return this;
  }
  function Interactive(a) {
    this.body = a;
    return this;
  }
  function Expression(a) {
    goog.asserts.assert(null !== a && void 0 !== a);
    this.body = a;
    return this;
  }
  function Suite(a) {
    this.body = a;
    return this;
  }
  function FunctionDef(a, b, c, d, e, f) {
    goog.asserts.assert(null !== a && void 0 !== a);
    goog.asserts.assert(null !== b && void 0 !== b);
    this.name = a;
    this.args = b;
    this.body = c;
    this.decorator_list = d;
    this.lineno = e;
    this.col_offset = f;
    return this;
  }
  function ClassDef(a, b, c, d, e, f) {
    goog.asserts.assert(null !== a && void 0 !== a);
    this.name = a;
    this.bases = b;
    this.body = c;
    this.decorator_list = d;
    this.lineno = e;
    this.col_offset = f;
    return this;
  }
  function Return_(a, b, c) {
    this.value = a;
    this.lineno = b;
    this.col_offset = c;
    return this;
  }
  function Delete_(a, b, c) {
    this.targets = a;
    this.lineno = b;
    this.col_offset = c;
    return this;
  }
  function Assign(a, b, c, d) {
    goog.asserts.assert(null !== b && void 0 !== b);
    this.targets = a;
    this.value = b;
    this.lineno = c;
    this.col_offset = d;
    return this;
  }
  function AugAssign(a, b, c, d, e) {
    goog.asserts.assert(null !== a && void 0 !== a);
    goog.asserts.assert(null !== b && void 0 !== b);
    goog.asserts.assert(null !== c && void 0 !== c);
    this.target = a;
    this.op = b;
    this.value = c;
    this.lineno = d;
    this.col_offset = e;
    return this;
  }
  function Print(a, b, c, d, e) {
    this.dest = a;
    this.values = b;
    this.nl = c;
    this.lineno = d;
    this.col_offset = e;
    return this;
  }
  function For_(a, b, c, d, e, f) {
    goog.asserts.assert(null !== a && void 0 !== a);
    goog.asserts.assert(null !== b && void 0 !== b);
    this.target = a;
    this.iter = b;
    this.body = c;
    this.orelse = d;
    this.lineno = e;
    this.col_offset = f;
    return this;
  }
  function While_(a, b, c, d, e) {
    goog.asserts.assert(null !== a && void 0 !== a);
    this.test = a;
    this.body = b;
    this.orelse = c;
    this.lineno = d;
    this.col_offset = e;
    return this;
  }
  function If_(a, b, c, d, e) {
    goog.asserts.assert(null !== a && void 0 !== a);
    this.test = a;
    this.body = b;
    this.orelse = c;
    this.lineno = d;
    this.col_offset = e;
    return this;
  }
  function With_(a, b, c, d, e) {
    goog.asserts.assert(null !== a && void 0 !== a);
    this.context_expr = a;
    this.optional_vars = b;
    this.body = c;
    this.lineno = d;
    this.col_offset = e;
    return this;
  }
  function Raise(a, b, c, d, e) {
    this.type = a;
    this.inst = b;
    this.tback = c;
    this.lineno = d;
    this.col_offset = e;
    return this;
  }
  function TryExcept(a, b, c, d, e) {
    this.body = a;
    this.handlers = b;
    this.orelse = c;
    this.lineno = d;
    this.col_offset = e;
    return this;
  }
  function TryFinally(a, b, c, d) {
    this.body = a;
    this.finalbody = b;
    this.lineno = c;
    this.col_offset = d;
    return this;
  }
  function Assert(a, b, c, d) {
    goog.asserts.assert(null !== a && void 0 !== a);
    this.test = a;
    this.msg = b;
    this.lineno = c;
    this.col_offset = d;
    return this;
  }
  function Import_(a, b, c) {
    this.names = a;
    this.lineno = b;
    this.col_offset = c;
    return this;
  }
  function ImportFrom(a, b, c, d, e) {
    goog.asserts.assert(null !== a && void 0 !== a);
    this.module = a;
    this.names = b;
    this.level = c;
    this.lineno = d;
    this.col_offset = e;
    return this;
  }
  function Exec(a, b, c, d, e) {
    goog.asserts.assert(null !== a && void 0 !== a);
    this.body = a;
    this.globals = b;
    this.locals = c;
    this.lineno = d;
    this.col_offset = e;
    return this;
  }
  function Global(a, b, c) {
    this.names = a;
    this.lineno = b;
    this.col_offset = c;
    return this;
  }
  function Expr(a, b, c) {
    goog.asserts.assert(null !== a && void 0 !== a);
    this.value = a;
    this.lineno = b;
    this.col_offset = c;
    return this;
  }
  function Pass(a, b) {
    this.lineno = a;
    this.col_offset = b;
    return this;
  }
  function Break_(a, b) {
    this.lineno = a;
    this.col_offset = b;
    return this;
  }
  function Continue_(a, b) {
    this.lineno = a;
    this.col_offset = b;
    return this;
  }
  function BoolOp(a, b, c, d) {
    goog.asserts.assert(null !== a && void 0 !== a);
    this.op = a;
    this.values = b;
    this.lineno = c;
    this.col_offset = d;
    return this;
  }
  function BinOp(a, b, c, d, e) {
    goog.asserts.assert(null !== a && void 0 !== a);
    goog.asserts.assert(null !== b && void 0 !== b);
    goog.asserts.assert(null !== c && void 0 !== c);
    this.left = a;
    this.op = b;
    this.right = c;
    this.lineno = d;
    this.col_offset = e;
    return this;
  }
  function UnaryOp(a, b, c, d) {
    goog.asserts.assert(null !== a && void 0 !== a);
    goog.asserts.assert(null !== b && void 0 !== b);
    this.op = a;
    this.operand = b;
    this.lineno = c;
    this.col_offset = d;
    return this;
  }
  function Lambda(a, b, c, d) {
    goog.asserts.assert(null !== a && void 0 !== a);
    goog.asserts.assert(null !== b && void 0 !== b);
    this.args = a;
    this.body = b;
    this.lineno = c;
    this.col_offset = d;
    return this;
  }
  function IfExp(a, b, c, d, e) {
    goog.asserts.assert(null !== a && void 0 !== a);
    goog.asserts.assert(null !== b && void 0 !== b);
    goog.asserts.assert(null !== c && void 0 !== c);
    this.test = a;
    this.body = b;
    this.orelse = c;
    this.lineno = d;
    this.col_offset = e;
    return this;
  }
  function Dict(a, b, c, d) {
    this.keys = a;
    this.values = b;
    this.lineno = c;
    this.col_offset = d;
    return this;
  }
  function ListComp(a, b, c, d) {
    goog.asserts.assert(null !== a && void 0 !== a);
    this.elt = a;
    this.generators = b;
    this.lineno = c;
    this.col_offset = d;
    return this;
  }
  function GeneratorExp(a, b, c, d) {
    goog.asserts.assert(null !== a && void 0 !== a);
    this.elt = a;
    this.generators = b;
    this.lineno = c;
    this.col_offset = d;
    return this;
  }
  function Yield(a, b, c) {
    this.value = a;
    this.lineno = b;
    this.col_offset = c;
    return this;
  }
  function Compare(a, b, c, d, e) {
    goog.asserts.assert(null !== a && void 0 !== a);
    this.left = a;
    this.ops = b;
    this.comparators = c;
    this.lineno = d;
    this.col_offset = e;
    return this;
  }
  function Call(a, b, c, d, e, f, g) {
    goog.asserts.assert(null !== a && void 0 !== a);
    this.func = a;
    this.args = b;
    this.keywords = c;
    this.starargs = d;
    this.kwargs = e;
    this.lineno = f;
    this.col_offset = g;
    return this;
  }
  function Num(a, b, c) {
    goog.asserts.assert(null !== a && void 0 !== a);
    this.n = a;
    this.lineno = b;
    this.col_offset = c;
    return this;
  }
  function Str(a, b, c) {
    goog.asserts.assert(null !== a && void 0 !== a);
    this.s = a;
    this.lineno = b;
    this.col_offset = c;
    return this;
  }
  function Attribute(a, b, c, d, e) {
    goog.asserts.assert(null !== a && void 0 !== a);
    goog.asserts.assert(null !== b && void 0 !== b);
    goog.asserts.assert(null !== c && void 0 !== c);
    this.value = a;
    this.attr = b;
    this.ctx = c;
    this.lineno = d;
    this.col_offset = e;
    return this;
  }
  function Subscript(a, b, c, d, e) {
    goog.asserts.assert(null !== a && void 0 !== a);
    goog.asserts.assert(null !== b && void 0 !== b);
    goog.asserts.assert(null !== c && void 0 !== c);
    this.value = a;
    this.slice = b;
    this.ctx = c;
    this.lineno = d;
    this.col_offset = e;
    return this;
  }
  function Name(a, b, c, d) {
    goog.asserts.assert(null !== a && void 0 !== a);
    goog.asserts.assert(null !== b && void 0 !== b);
    this.id = a;
    this.ctx = b;
    this.lineno = c;
    this.col_offset = d;
    return this;
  }
  function List(a, b, c, d) {
    goog.asserts.assert(null !== b && void 0 !== b);
    this.elts = a;
    this.ctx = b;
    this.lineno = c;
    this.col_offset = d;
    return this;
  }
  function Tuple(a, b, c, d) {
    goog.asserts.assert(null !== b && void 0 !== b);
    this.elts = a;
    this.ctx = b;
    this.lineno = c;
    this.col_offset = d;
    return this;
  }
  function Ellipsis() {
    return this;
  }
  function Slice(a, b, c) {
    this.lower = a;
    this.upper = b;
    this.step = c;
    return this;
  }
  function ExtSlice(a) {
    this.dims = a;
    return this;
  }
  function Index(a) {
    goog.asserts.assert(null !== a && void 0 !== a);
    this.value = a;
    return this;
  }
  function comprehension(a, b, c) {
    goog.asserts.assert(null !== a && void 0 !== a);
    goog.asserts.assert(null !== b && void 0 !== b);
    this.target = a;
    this.iter = b;
    this.ifs = c;
    return this;
  }
  function ExceptHandler(a, b, c, d, e) {
    this.type = a;
    this.name = b;
    this.body = c;
    this.lineno = d;
    this.col_offset = e;
    return this;
  }
  function arguments_(a, b, c, d) {
    this.args = a;
    this.vararg = b;
    this.kwarg = c;
    this.defaults = d;
    return this;
  }
  function keyword(a, b) {
    goog.asserts.assert(null !== a && void 0 !== a);
    goog.asserts.assert(null !== b && void 0 !== b);
    this.arg = a;
    this.value = b;
    return this;
  }
  function alias(a, b) {
    goog.asserts.assert(null !== a && void 0 !== a);
    this.name = a;
    this.asname = b;
    return this;
  }
  Module.prototype._astname = 'Module';
  Module.prototype._fields = [
    'body',
    function (a) {
      return a.body;
    }
  ];
  Interactive.prototype._astname = 'Interactive';
  Interactive.prototype._fields = [
    'body',
    function (a) {
      return a.body;
    }
  ];
  Expression.prototype._astname = 'Expression';
  Expression.prototype._fields = [
    'body',
    function (a) {
      return a.body;
    }
  ];
  Suite.prototype._astname = 'Suite';
  Suite.prototype._fields = [
    'body',
    function (a) {
      return a.body;
    }
  ];
  FunctionDef.prototype._astname = 'FunctionDef';
  FunctionDef.prototype._fields = [
    'name',
    function (a) {
      return a.name;
    },
    'args',
    function (a) {
      return a.args;
    },
    'body',
    function (a) {
      return a.body;
    },
    'decorator_list',
    function (a) {
      return a.decorator_list;
    }
  ];
  ClassDef.prototype._astname = 'ClassDef';
  ClassDef.prototype._fields = [
    'name',
    function (a) {
      return a.name;
    },
    'bases',
    function (a) {
      return a.bases;
    },
    'body',
    function (a) {
      return a.body;
    },
    'decorator_list',
    function (a) {
      return a.decorator_list;
    }
  ];
  Return_.prototype._astname = 'Return';
  Return_.prototype._fields = [
    'value',
    function (a) {
      return a.value;
    }
  ];
  Delete_.prototype._astname = 'Delete';
  Delete_.prototype._fields = [
    'targets',
    function (a) {
      return a.targets;
    }
  ];
  Assign.prototype._astname = 'Assign';
  Assign.prototype._fields = [
    'targets',
    function (a) {
      return a.targets;
    },
    'value',
    function (a) {
      return a.value;
    }
  ];
  AugAssign.prototype._astname = 'AugAssign';
  AugAssign.prototype._fields = [
    'target',
    function (a) {
      return a.target;
    },
    'op',
    function (a) {
      return a.op;
    },
    'value',
    function (a) {
      return a.value;
    }
  ];
  Print.prototype._astname = 'Print';
  Print.prototype._fields = [
    'dest',
    function (a) {
      return a.dest;
    },
    'values',
    function (a) {
      return a.values;
    },
    'nl',
    function (a) {
      return a.nl;
    }
  ];
  For_.prototype._astname = 'For';
  For_.prototype._fields = [
    'target',
    function (a) {
      return a.target;
    },
    'iter',
    function (a) {
      return a.iter;
    },
    'body',
    function (a) {
      return a.body;
    },
    'orelse',
    function (a) {
      return a.orelse;
    }
  ];
  While_.prototype._astname = 'While';
  While_.prototype._fields = [
    'test',
    function (a) {
      return a.test;
    },
    'body',
    function (a) {
      return a.body;
    },
    'orelse',
    function (a) {
      return a.orelse;
    }
  ];
  If_.prototype._astname = 'If';
  If_.prototype._fields = [
    'test',
    function (a) {
      return a.test;
    },
    'body',
    function (a) {
      return a.body;
    },
    'orelse',
    function (a) {
      return a.orelse;
    }
  ];
  With_.prototype._astname = 'With';
  With_.prototype._fields = [
    'context_expr',
    function (a) {
      return a.context_expr;
    },
    'optional_vars',
    function (a) {
      return a.optional_vars;
    },
    'body',
    function (a) {
      return a.body;
    }
  ];
  Raise.prototype._astname = 'Raise';
  Raise.prototype._fields = [
    'type',
    function (a) {
      return a.type;
    },
    'inst',
    function (a) {
      return a.inst;
    },
    'tback',
    function (a) {
      return a.tback;
    }
  ];
  TryExcept.prototype._astname = 'TryExcept';
  TryExcept.prototype._fields = [
    'body',
    function (a) {
      return a.body;
    },
    'handlers',
    function (a) {
      return a.handlers;
    },
    'orelse',
    function (a) {
      return a.orelse;
    }
  ];
  TryFinally.prototype._astname = 'TryFinally';
  TryFinally.prototype._fields = [
    'body',
    function (a) {
      return a.body;
    },
    'finalbody',
    function (a) {
      return a.finalbody;
    }
  ];
  Assert.prototype._astname = 'Assert';
  Assert.prototype._fields = [
    'test',
    function (a) {
      return a.test;
    },
    'msg',
    function (a) {
      return a.msg;
    }
  ];
  Import_.prototype._astname = 'Import';
  Import_.prototype._fields = [
    'names',
    function (a) {
      return a.names;
    }
  ];
  ImportFrom.prototype._astname = 'ImportFrom';
  ImportFrom.prototype._fields = [
    'module',
    function (a) {
      return a.module;
    },
    'names',
    function (a) {
      return a.names;
    },
    'level',
    function (a) {
      return a.level;
    }
  ];
  Exec.prototype._astname = 'Exec';
  Exec.prototype._fields = [
    'body',
    function (a) {
      return a.body;
    },
    'globals',
    function (a) {
      return a.globals;
    },
    'locals',
    function (a) {
      return a.locals;
    }
  ];
  Global.prototype._astname = 'Global';
  Global.prototype._fields = [
    'names',
    function (a) {
      return a.names;
    }
  ];
  Expr.prototype._astname = 'Expr';
  Expr.prototype._fields = [
    'value',
    function (a) {
      return a.value;
    }
  ];
  Pass.prototype._astname = 'Pass';
  Pass.prototype._fields = [];
  Break_.prototype._astname = 'Break';
  Break_.prototype._fields = [];
  Continue_.prototype._astname = 'Continue';
  Continue_.prototype._fields = [];
  BoolOp.prototype._astname = 'BoolOp';
  BoolOp.prototype._fields = [
    'op',
    function (a) {
      return a.op;
    },
    'values',
    function (a) {
      return a.values;
    }
  ];
  BinOp.prototype._astname = 'BinOp';
  BinOp.prototype._fields = [
    'left',
    function (a) {
      return a.left;
    },
    'op',
    function (a) {
      return a.op;
    },
    'right',
    function (a) {
      return a.right;
    }
  ];
  UnaryOp.prototype._astname = 'UnaryOp';
  UnaryOp.prototype._fields = [
    'op',
    function (a) {
      return a.op;
    },
    'operand',
    function (a) {
      return a.operand;
    }
  ];
  Lambda.prototype._astname = 'Lambda';
  Lambda.prototype._fields = [
    'args',
    function (a) {
      return a.args;
    },
    'body',
    function (a) {
      return a.body;
    }
  ];
  IfExp.prototype._astname = 'IfExp';
  IfExp.prototype._fields = [
    'test',
    function (a) {
      return a.test;
    },
    'body',
    function (a) {
      return a.body;
    },
    'orelse',
    function (a) {
      return a.orelse;
    }
  ];
  Dict.prototype._astname = 'Dict';
  Dict.prototype._fields = [
    'keys',
    function (a) {
      return a.keys;
    },
    'values',
    function (a) {
      return a.values;
    }
  ];
  ListComp.prototype._astname = 'ListComp';
  ListComp.prototype._fields = [
    'elt',
    function (a) {
      return a.elt;
    },
    'generators',
    function (a) {
      return a.generators;
    }
  ];
  GeneratorExp.prototype._astname = 'GeneratorExp';
  GeneratorExp.prototype._fields = [
    'elt',
    function (a) {
      return a.elt;
    },
    'generators',
    function (a) {
      return a.generators;
    }
  ];
  Yield.prototype._astname = 'Yield';
  Yield.prototype._fields = [
    'value',
    function (a) {
      return a.value;
    }
  ];
  Compare.prototype._astname = 'Compare';
  Compare.prototype._fields = [
    'left',
    function (a) {
      return a.left;
    },
    'ops',
    function (a) {
      return a.ops;
    },
    'comparators',
    function (a) {
      return a.comparators;
    }
  ];
  Call.prototype._astname = 'Call';
  Call.prototype._fields = [
    'func',
    function (a) {
      return a.func;
    },
    'args',
    function (a) {
      return a.args;
    },
    'keywords',
    function (a) {
      return a.keywords;
    },
    'starargs',
    function (a) {
      return a.starargs;
    },
    'kwargs',
    function (a) {
      return a.kwargs;
    }
  ];
  Num.prototype._astname = 'Num';
  Num.prototype._fields = [
    'n',
    function (a) {
      return a.n;
    }
  ];
  Str.prototype._astname = 'Str';
  Str.prototype._fields = [
    's',
    function (a) {
      return a.s;
    }
  ];
  Attribute.prototype._astname = 'Attribute';
  Attribute.prototype._fields = [
    'value',
    function (a) {
      return a.value;
    },
    'attr',
    function (a) {
      return a.attr;
    },
    'ctx',
    function (a) {
      return a.ctx;
    }
  ];
  Subscript.prototype._astname = 'Subscript';
  Subscript.prototype._fields = [
    'value',
    function (a) {
      return a.value;
    },
    'slice',
    function (a) {
      return a.slice;
    },
    'ctx',
    function (a) {
      return a.ctx;
    }
  ];
  Name.prototype._astname = 'Name';
  Name.prototype._fields = [
    'id',
    function (a) {
      return a.id;
    },
    'ctx',
    function (a) {
      return a.ctx;
    }
  ];
  List.prototype._astname = 'List';
  List.prototype._fields = [
    'elts',
    function (a) {
      return a.elts;
    },
    'ctx',
    function (a) {
      return a.ctx;
    }
  ];
  Tuple.prototype._astname = 'Tuple';
  Tuple.prototype._fields = [
    'elts',
    function (a) {
      return a.elts;
    },
    'ctx',
    function (a) {
      return a.ctx;
    }
  ];
  Load.prototype._astname = 'Load';
  Load.prototype._isenum = !0;
  Store.prototype._astname = 'Store';
  Store.prototype._isenum = !0;
  Del.prototype._astname = 'Del';
  Del.prototype._isenum = !0;
  AugLoad.prototype._astname = 'AugLoad';
  AugLoad.prototype._isenum = !0;
  AugStore.prototype._astname = 'AugStore';
  AugStore.prototype._isenum = !0;
  Param.prototype._astname = 'Param';
  Param.prototype._isenum = !0;
  Ellipsis.prototype._astname = 'Ellipsis';
  Ellipsis.prototype._fields = [];
  Slice.prototype._astname = 'Slice';
  Slice.prototype._fields = [
    'lower',
    function (a) {
      return a.lower;
    },
    'upper',
    function (a) {
      return a.upper;
    },
    'step',
    function (a) {
      return a.step;
    }
  ];
  ExtSlice.prototype._astname = 'ExtSlice';
  ExtSlice.prototype._fields = [
    'dims',
    function (a) {
      return a.dims;
    }
  ];
  Index.prototype._astname = 'Index';
  Index.prototype._fields = [
    'value',
    function (a) {
      return a.value;
    }
  ];
  And.prototype._astname = 'And';
  And.prototype._isenum = !0;
  Or.prototype._astname = 'Or';
  Or.prototype._isenum = !0;
  Add.prototype._astname = 'Add';
  Add.prototype._isenum = !0;
  Sub.prototype._astname = 'Sub';
  Sub.prototype._isenum = !0;
  Mult.prototype._astname = 'Mult';
  Mult.prototype._isenum = !0;
  Div.prototype._astname = 'Div';
  Div.prototype._isenum = !0;
  Mod.prototype._astname = 'Mod';
  Mod.prototype._isenum = !0;
  Pow.prototype._astname = 'Pow';
  Pow.prototype._isenum = !0;
  LShift.prototype._astname = 'LShift';
  LShift.prototype._isenum = !0;
  RShift.prototype._astname = 'RShift';
  RShift.prototype._isenum = !0;
  BitOr.prototype._astname = 'BitOr';
  BitOr.prototype._isenum = !0;
  BitXor.prototype._astname = 'BitXor';
  BitXor.prototype._isenum = !0;
  BitAnd.prototype._astname = 'BitAnd';
  BitAnd.prototype._isenum = !0;
  FloorDiv.prototype._astname = 'FloorDiv';
  FloorDiv.prototype._isenum = !0;
  Invert.prototype._astname = 'Invert';
  Invert.prototype._isenum = !0;
  Not.prototype._astname = 'Not';
  Not.prototype._isenum = !0;
  UAdd.prototype._astname = 'UAdd';
  UAdd.prototype._isenum = !0;
  USub.prototype._astname = 'USub';
  USub.prototype._isenum = !0;
  Eq.prototype._astname = 'Eq';
  Eq.prototype._isenum = !0;
  NotEq.prototype._astname = 'NotEq';
  NotEq.prototype._isenum = !0;
  Lt.prototype._astname = 'Lt';
  Lt.prototype._isenum = !0;
  LtE.prototype._astname = 'LtE';
  LtE.prototype._isenum = !0;
  Gt.prototype._astname = 'Gt';
  Gt.prototype._isenum = !0;
  GtE.prototype._astname = 'GtE';
  GtE.prototype._isenum = !0;
  Is.prototype._astname = 'Is';
  Is.prototype._isenum = !0;
  IsNot.prototype._astname = 'IsNot';
  IsNot.prototype._isenum = !0;
  In_.prototype._astname = 'In';
  In_.prototype._isenum = !0;
  NotIn.prototype._astname = 'NotIn';
  NotIn.prototype._isenum = !0;
  comprehension.prototype._astname = 'comprehension';
  comprehension.prototype._fields = [
    'target',
    function (a) {
      return a.target;
    },
    'iter',
    function (a) {
      return a.iter;
    },
    'ifs',
    function (a) {
      return a.ifs;
    }
  ];
  ExceptHandler.prototype._astname = 'ExceptHandler';
  ExceptHandler.prototype._fields = [
    'type',
    function (a) {
      return a.type;
    },
    'name',
    function (a) {
      return a.name;
    },
    'body',
    function (a) {
      return a.body;
    }
  ];
  arguments_.prototype._astname = 'arguments';
  arguments_.prototype._fields = [
    'args',
    function (a) {
      return a.args;
    },
    'vararg',
    function (a) {
      return a.vararg;
    },
    'kwarg',
    function (a) {
      return a.kwarg;
    },
    'defaults',
    function (a) {
      return a.defaults;
    }
  ];
  keyword.prototype._astname = 'keyword';
  keyword.prototype._fields = [
    'arg',
    function (a) {
      return a.arg;
    },
    'value',
    function (a) {
      return a.value;
    }
  ];
  alias.prototype._astname = 'alias';
  alias.prototype._fields = [
    'name',
    function (a) {
      return a.name;
    },
    'asname',
    function (a) {
      return a.asname;
    }
  ];
  var SYM = Sk.ParseTables.sym, TOK = Sk.Tokenizer.Tokens;
  function Compiling(a, b) {
    this.c_encoding = a;
    this.c_filename = b;
  }
  function NCH(a) {
    goog.asserts.assert(void 0 !== a);
    return null === a.children ? 0 : a.children.length;
  }
  function CHILD(a, b) {
    goog.asserts.assert(void 0 !== a);
    goog.asserts.assert(void 0 !== b);
    return a.children[b];
  }
  function REQ(a, b) {
    goog.asserts.assert(a.type === b, 'node wasn\'t expected type');
  }
  function strobj(a) {
    goog.asserts.assert('string' === typeof a, 'expecting string, got ' + typeof a);
    return Sk.builtin.stringToPy(a);
  }
  function numStmts(a) {
    switch (a.type) {
    case SYM.single_input:
      if (CHILD(a, 0).type === TOK.T_NEWLINE)
        break;
      else
        return numStmts(CHILD(a, 0));
    case SYM.file_input:
      for (var b = 0, c = 0; c < NCH(a); ++c) {
        var d = CHILD(a, c);
        d.type === SYM.stmt && (b += numStmts(d));
      }
      return b;
    case SYM.stmt:
      return numStmts(CHILD(a, 0));
    case SYM.compound_stmt:
      return 1;
    case SYM.simple_stmt:
      return Math.floor(NCH(a) / 2);
    case SYM.suite:
      if (1 === NCH(a))
        return numStmts(CHILD(a, 0));
      b = 0;
      for (c = 2; c < NCH(a) - 1; ++c)
        b += numStmts(CHILD(a, c));
      return b;
    default:
      goog.asserts.fail('Non-statement found');
    }
    return 0;
  }
  function forbiddenCheck(a, b, c, d) {
    if ('None' === c)
      throw new Sk.builtin.SyntaxError('assignment to None', a.c_filename, d);
    if ('True' === c || 'False' === c)
      throw new Sk.builtin.SyntaxError('assignment to True or False is forbidden', a.c_filename, d);
  }
  function setContext(a, b, c, d) {
    goog.asserts.assert(c !== AugStore && c !== AugLoad);
    var e = null, f = null;
    switch (b.constructor) {
    case Attribute:
    case Name:
      c === Store && forbiddenCheck(a, d, b.attr, d.lineno);
      b.ctx = c;
      break;
    case Subscript:
      b.ctx = c;
      break;
    case List:
      b.ctx = c;
      e = b.elts;
      break;
    case Tuple:
      if (0 === b.elts.length)
        throw new Sk.builtin.SyntaxError('can\'t assign to ()', a.c_filename, d.lineno);
      b.ctx = c;
      e = b.elts;
      break;
    case Lambda:
      f = 'lambda';
      break;
    case Call:
      f = 'function call';
      break;
    case BoolOp:
    case BinOp:
    case UnaryOp:
      f = 'operator';
      break;
    case GeneratorExp:
      f = 'generator expression';
      break;
    case Yield:
      f = 'yield expression';
      break;
    case ListComp:
      f = 'list comprehension';
      break;
    case Dict:
    case Num:
    case Str:
      f = 'literal';
      break;
    case Compare:
      f = 'comparison';
      break;
    case IfExp:
      f = 'conditional expression';
      break;
    default:
      goog.asserts.fail('unhandled expression in assignment');
    }
    if (f)
      throw new Sk.builtin.SyntaxError('can\'t ' + (c === Store ? 'assign to' : 'delete') + ' ' + f, a.c_filename, d.lineno);
    if (e)
      for (b = 0; b < e.length; ++b)
        setContext(a, e[b], c, d);
  }
  var operatorMap = {};
  (function () {
    operatorMap[TOK.T_VBAR] = BitOr;
    operatorMap[TOK.T_VBAR] = BitOr;
    operatorMap[TOK.T_CIRCUMFLEX] = BitXor;
    operatorMap[TOK.T_AMPER] = BitAnd;
    operatorMap[TOK.T_LEFTSHIFT] = LShift;
    operatorMap[TOK.T_RIGHTSHIFT] = RShift;
    operatorMap[TOK.T_PLUS] = Add;
    operatorMap[TOK.T_MINUS] = Sub;
    operatorMap[TOK.T_STAR] = Mult;
    operatorMap[TOK.T_SLASH] = Div;
    operatorMap[TOK.T_DOUBLESLASH] = FloorDiv;
    operatorMap[TOK.T_PERCENT] = Mod;
  }());
  function getOperator(a) {
    goog.asserts.assert(void 0 !== operatorMap[a.type]);
    return operatorMap[a.type];
  }
  function astForCompOp(a, b) {
    REQ(b, SYM.comp_op);
    if (1 === NCH(b))
      switch (b = CHILD(b, 0), b.type) {
      case TOK.T_LESS:
        return Lt;
      case TOK.T_GREATER:
        return Gt;
      case TOK.T_EQEQUAL:
        return Eq;
      case TOK.T_LESSEQUAL:
        return LtE;
      case TOK.T_GREATEREQUAL:
        return GtE;
      case TOK.T_NOTEQUAL:
        return NotEq;
      case TOK.T_NAME:
        if ('in' === b.value)
          return In_;
        if ('is' === b.value)
          return Is;
      }
    else if (2 === NCH(b) && CHILD(b, 0).type === TOK.T_NAME) {
      if ('in' === CHILD(b, 1).value)
        return NotIn;
      if ('is' === CHILD(b, 0).value)
        return IsNot;
    }
    goog.asserts.fail('invalid comp_op');
  }
  function seqForTestlist(a, b) {
    goog.asserts.assert(b.type === SYM.testlist || b.type === SYM.listmaker || b.type === SYM.testlist_gexp || b.type === SYM.testlist_safe || b.type === SYM.testlist1);
    for (var c = [], d = 0; d < NCH(b); d += 2)
      goog.asserts.assert(CHILD(b, d).type === SYM.test || CHILD(b, d).type === SYM.old_test), c[d / 2] = astForExpr(a, CHILD(b, d));
    return c;
  }
  function astForSuite(a, b) {
    REQ(b, SYM.suite);
    var c = [], d = 0, e;
    if (CHILD(b, 0).type === SYM.simple_stmt) {
      b = CHILD(b, 0);
      e = NCH(b) - 1;
      CHILD(b, e - 1).type === TOK.T_SEMI && (e -= 1);
      for (var f = 0; f < e; f += 2)
        c[d++] = astForStmt(a, CHILD(b, f));
    } else
      for (f = 2; f < NCH(b) - 1; ++f)
        if (e = CHILD(b, f), REQ(e, SYM.stmt), 1 === numStmts(e))
          c[d++] = astForStmt(a, e);
        else {
          e = CHILD(e, 0);
          REQ(e, SYM.simple_stmt);
          for (var g = 0; g < NCH(e); g += 2) {
            if (0 === NCH(CHILD(e, g))) {
              goog.asserts.assert(g + 1 === NCH(e));
              break;
            }
            c[d++] = astForStmt(a, CHILD(e, g));
          }
        }
    goog.asserts.assert(d === numStmts(b));
    return c;
  }
  function astForExceptClause(a, b, c) {
    REQ(b, SYM.except_clause);
    REQ(c, SYM.suite);
    if (1 === NCH(b))
      return new ExceptHandler(null, null, astForSuite(a, c), b.lineno, b.col_offset);
    if (2 === NCH(b))
      return new ExceptHandler(astForExpr(a, CHILD(b, 1)), null, astForSuite(a, c), b.lineno, b.col_offset);
    if (4 === NCH(b)) {
      var d = astForExpr(a, CHILD(b, 3));
      setContext(a, d, Store, CHILD(b, 3));
      return new ExceptHandler(astForExpr(a, CHILD(b, 1)), d, astForSuite(a, c), b.lineno, b.col_offset);
    }
    goog.asserts.fail('wrong number of children for except clause');
  }
  function astForTryStmt(a, b) {
    var c = NCH(b), d = (c - 3) / 3, e, f = [], g = null;
    REQ(b, SYM.try_stmt);
    e = astForSuite(a, CHILD(b, 2));
    if (CHILD(b, c - 3).type === TOK.T_NAME)
      'finally' === CHILD(b, c - 3).value ? (9 <= c && CHILD(b, c - 6).type === TOK.T_NAME && (f = astForSuite(a, CHILD(b, c - 4)), d--), g = astForSuite(a, CHILD(b, c - 1))) : f = astForSuite(a, CHILD(b, c - 1)), d--;
    else if (CHILD(b, c - 3).type !== SYM.except_clause)
      throw new Sk.builtin.SyntaxError('malformed \'try\' statement', a.c_filename, b.lineno);
    if (0 < d) {
      for (var c = [], h = 0; h < d; ++h)
        c[h] = astForExceptClause(a, CHILD(b, 3 + 3 * h), CHILD(b, 5 + 3 * h));
      d = new TryExcept(e, c, f, b.lineno, b.col_offset);
      if (!g)
        return d;
      e = [d];
    }
    goog.asserts.assert(null !== g);
    return new TryFinally(e, g, b.lineno, b.col_offset);
  }
  function astForDottedName(a, b) {
    REQ(b, SYM.dotted_name);
    for (var c = b.lineno, d = b.col_offset, e = strobj(CHILD(b, 0).value), f = new Name(e, Load, c, d), g = 2; g < NCH(b); g += 2)
      e = strobj(CHILD(b, g).value), f = new Attribute(f, e, Load, c, d);
    return f;
  }
  function astForDecorator(a, b) {
    REQ(b, SYM.decorator);
    REQ(CHILD(b, 0), TOK.T_AT);
    REQ(CHILD(b, NCH(b) - 1), TOK.T_NEWLINE);
    var c = astForDottedName(a, CHILD(b, 1));
    return 3 === NCH(b) ? c : 5 === NCH(b) ? new Call(c, [], [], null, null, b.lineno, b.col_offset) : astForCall(a, CHILD(b, 3), c);
  }
  function astForDecorators(a, b) {
    REQ(b, SYM.decorators);
    for (var c = [], d = 0; d < NCH(b); ++d)
      c[d] = astForDecorator(a, CHILD(b, d));
    return c;
  }
  function astForDecorated(a, b) {
    REQ(b, SYM.decorated);
    var c = astForDecorators(a, CHILD(b, 0));
    goog.asserts.assert(CHILD(b, 1).type === SYM.funcdef || CHILD(b, 1).type === SYM.classdef);
    var d = null;
    CHILD(b, 1).type === SYM.funcdef ? d = astForFuncdef(a, CHILD(b, 1), c) : CHILD(b, 1) === SYM.classdef && (d = astForClassdef(a, CHILD(b, 1), c));
    d && (d.lineno = b.lineno, d.col_offset = b.col_offset);
    return d;
  }
  function astForWithVar(a, b) {
    REQ(b, SYM.with_var);
    return astForExpr(a, CHILD(b, 1));
  }
  function astForWithStmt(a, b) {
    var c = 3;
    goog.asserts.assert(b.type === SYM.with_stmt);
    var d = astForExpr(a, CHILD(b, 1));
    if (CHILD(b, 2).type === SYM.with_var) {
      var e = astForWithVar(a, CHILD(b, 2));
      setContext(a, e, Store, b);
      c = 4;
    }
    return new With_(d, e, astForSuite(a, CHILD(b, c)), b.lineno, b.col_offset);
  }
  function astForExecStmt(a, b) {
    var c, d = null, e = null, f = NCH(b);
    goog.asserts.assert(2 === f || 4 === f || 6 === f);
    REQ(b, SYM.exec_stmt);
    c = astForExpr(a, CHILD(b, 1));
    4 <= f && (d = astForExpr(a, CHILD(b, 3)));
    6 === f && (e = astForExpr(a, CHILD(b, 5)));
    return new Exec(c, d, e, b.lineno, b.col_offset);
  }
  function astForIfStmt(a, b) {
    REQ(b, SYM.if_stmt);
    if (4 === NCH(b))
      return new If_(astForExpr(a, CHILD(b, 1)), astForSuite(a, CHILD(b, 3)), [], b.lineno, b.col_offset);
    var c = CHILD(b, 4).value.charAt(2);
    if ('s' === c)
      return new If_(astForExpr(a, CHILD(b, 1)), astForSuite(a, CHILD(b, 3)), astForSuite(a, CHILD(b, 6)), b.lineno, b.col_offset);
    if ('i' === c) {
      var c = NCH(b) - 4, d = !1, e = [];
      CHILD(b, c + 1).type === TOK.T_NAME && 's' === CHILD(b, c + 1).value.charAt(2) && (d = !0, c -= 3);
      c /= 4;
      d && (e = [new If_(astForExpr(a, CHILD(b, NCH(b) - 6)), astForSuite(a, CHILD(b, NCH(b) - 4)), astForSuite(a, CHILD(b, NCH(b) - 1)), CHILD(b, NCH(b) - 6).lineno, CHILD(b, NCH(b) - 6).col_offset)], c--);
      for (d = 0; d < c; ++d)
        var f = 5 + 4 * (c - d - 1), e = [new If_(astForExpr(a, CHILD(b, f)), astForSuite(a, CHILD(b, f + 2)), e, CHILD(b, f).lineno, CHILD(b, f).col_offset)];
      return new If_(astForExpr(a, CHILD(b, 1)), astForSuite(a, CHILD(b, 3)), e, b.lineno, b.col_offset);
    }
    goog.asserts.fail('unexpected token in \'if\' statement');
  }
  function astForExprlist(a, b, c) {
    REQ(b, SYM.exprlist);
    for (var d = [], e = 0; e < NCH(b); e += 2) {
      var f = astForExpr(a, CHILD(b, e));
      d[e / 2] = f;
      c && setContext(a, f, c, CHILD(b, e));
    }
    return d;
  }
  function astForDelStmt(a, b) {
    REQ(b, SYM.del_stmt);
    return new Delete_(astForExprlist(a, CHILD(b, 1), Del), b.lineno, b.col_offset);
  }
  function astForGlobalStmt(a, b) {
    REQ(b, SYM.global_stmt);
    for (var c = [], d = 1; d < NCH(b); d += 2)
      c[(d - 1) / 2] = strobj(CHILD(b, d).value);
    return new Global(c, b.lineno, b.col_offset);
  }
  function astForAssertStmt(a, b) {
    REQ(b, SYM.assert_stmt);
    if (2 === NCH(b))
      return new Assert(astForExpr(a, CHILD(b, 1)), null, b.lineno, b.col_offset);
    if (4 === NCH(b))
      return new Assert(astForExpr(a, CHILD(b, 1)), astForExpr(a, CHILD(b, 3)), b.lineno, b.col_offset);
    goog.asserts.fail('improper number of parts to assert stmt');
  }
  function aliasForImportName(a, b) {
    a:
      for (;;)
        switch (b.type) {
        case SYM.import_as_name:
          var c = null, d = strobj(CHILD(b, 0).value);
          3 === NCH(b) && (c = CHILD(b, 2).value);
          return new alias(d, null == c ? null : strobj(c));
        case SYM.dotted_as_name:
          if (1 === NCH(b)) {
            b = CHILD(b, 0);
            continue a;
          } else
            return c = aliasForImportName(a, CHILD(b, 0)), goog.asserts.assert(!c.asname), c.asname = strobj(CHILD(b, 2).value), c;
        case SYM.dotted_name:
          if (1 === NCH(b))
            return new alias(strobj(CHILD(b, 0).value), null);
          c = '';
          for (d = 0; d < NCH(b); d += 2)
            c += CHILD(b, d).value + '.';
          return new alias(strobj(c.substr(0, c.length - 1)), null);
        case TOK.T_STAR:
          return new alias(strobj('*'), null);
        default:
          throw new Sk.builtin.SyntaxError('unexpected import name', a.c_filename, b.lineno);
        }
  }
  function astForImportStmt(a, b) {
    REQ(b, SYM.import_stmt);
    var c = b.lineno, d = b.col_offset;
    b = CHILD(b, 0);
    if (b.type === SYM.import_name) {
      b = CHILD(b, 1);
      REQ(b, SYM.dotted_as_names);
      for (var e = [], f = 0; f < NCH(b); f += 2)
        e[f / 2] = aliasForImportName(a, CHILD(b, f));
      return new Import_(e, c, d);
    }
    if (b.type === SYM.import_from) {
      for (var g = null, h = 0, e = 1; e < NCH(b); ++e) {
        if (CHILD(b, e).type === SYM.dotted_name) {
          g = aliasForImportName(a, CHILD(b, e));
          e++;
          break;
        } else if (CHILD(b, e).type !== TOK.T_DOT)
          break;
        h++;
      }
      ++e;
      switch (CHILD(b, e).type) {
      case TOK.T_STAR:
        b = CHILD(b, e);
        break;
      case TOK.T_LPAR:
        b = CHILD(b, e + 1);
        NCH(b);
        break;
      case SYM.import_as_names:
        b = CHILD(b, e);
        e = NCH(b);
        if (0 === e % 2)
          throw new Sk.builtin.SyntaxError('trailing comma not allowed without surrounding parentheses', a.c_filename, b.lineno);
        break;
      default:
        throw new Sk.builtin.SyntaxError('Unexpected node-type in from-import', a.c_filename, b.lineno);
      }
      e = [];
      if (b.type === TOK.T_STAR)
        e[0] = aliasForImportName(a, b);
      else
        for (f = 0; f < NCH(b); f += 2)
          e[f / 2] = aliasForImportName(a, CHILD(b, f));
      return new ImportFrom(strobj(g ? g.name.v : ''), e, h, c, d);
    }
    throw new Sk.builtin.SyntaxError('unknown import statement', a.c_filename, b.lineno);
  }
  function astForTestlistGexp(a, b) {
    goog.asserts.assert(b.type === SYM.testlist_gexp || b.type === SYM.argument);
    return 1 < NCH(b) && CHILD(b, 1).type === SYM.gen_for ? astForGenexp(a, b) : astForTestlist(a, b);
  }
  function astForListcomp(a, b) {
    function c(a, b) {
      for (var c = 0;;) {
        REQ(b, SYM.list_iter);
        if (CHILD(b, 0).type === SYM.list_for)
          return c;
        b = CHILD(b, 0);
        REQ(b, SYM.list_if);
        c++;
        if (2 == NCH(b))
          return c;
        b = CHILD(b, 2);
      }
    }
    REQ(b, SYM.listmaker);
    goog.asserts.assert(1 < NCH(b));
    for (var d = astForExpr(a, CHILD(b, 0)), e = function (a, b) {
          var c = 0, d = CHILD(b, 1);
          a:
            for (;;) {
              c++;
              REQ(d, SYM.list_for);
              if (5 === NCH(d))
                d = CHILD(d, 4);
              else
                return c;
              b:
                for (;;) {
                  REQ(d, SYM.list_iter);
                  d = CHILD(d, 0);
                  if (d.type === SYM.list_for)
                    continue a;
                  else if (d.type === SYM.list_if)
                    if (3 === NCH(d)) {
                      d = CHILD(d, 2);
                      continue b;
                    } else
                      return c;
                  break;
                }
              break;
            }
        }(a, b), f = [], g = CHILD(b, 1), h = 0; h < e; ++h) {
      REQ(g, SYM.list_for);
      var l = CHILD(g, 1), k = astForExprlist(a, l, Store), m = astForTestlist(a, CHILD(g, 3)), l = 1 === NCH(l) ? new comprehension(k[0], m, []) : new comprehension(new Tuple(k, Store, g.lineno, g.col_offset), m, []);
      if (5 === NCH(g)) {
        for (var g = CHILD(g, 4), k = c(a, g), m = [], p = 0; p < k; ++p)
          REQ(g, SYM.list_iter), g = CHILD(g, 0), REQ(g, SYM.list_if), m[p] = astForExpr(a, CHILD(g, 1)), 3 === NCH(g) && (g = CHILD(g, 2));
        g.type === SYM.list_iter && (g = CHILD(g, 0));
        l.ifs = m;
      }
      f[h] = l;
    }
    return new ListComp(d, f, b.lineno, b.col_offset);
  }
  function astForFactor(a, b) {
    if (CHILD(b, 0).type === TOK.T_MINUS && 2 === NCH(b)) {
      var c = CHILD(b, 1);
      if (c.type === SYM.factor && 1 === NCH(c) && (c = CHILD(c, 0), c.type === SYM.power && 1 === NCH(c) && (c = CHILD(c, 0), c.type === SYM.atom))) {
        var d = CHILD(c, 0);
        if (d.type === TOK.T_NUMBER)
          return d.value = '-' + d.value, astForAtom(a, c);
      }
    }
    c = astForExpr(a, CHILD(b, 1));
    switch (CHILD(b, 0).type) {
    case TOK.T_PLUS:
      return new UnaryOp(UAdd, c, b.lineno, b.col_offset);
    case TOK.T_MINUS:
      return new UnaryOp(USub, c, b.lineno, b.col_offset);
    case TOK.T_TILDE:
      return new UnaryOp(Invert, c, b.lineno, b.col_offset);
    }
    goog.asserts.fail('unhandled factor');
  }
  function astForForStmt(a, b) {
    var c = [];
    REQ(b, SYM.for_stmt);
    9 === NCH(b) && (c = astForSuite(a, CHILD(b, 8)));
    var d = CHILD(b, 1), e = astForExprlist(a, d, Store), d = 1 === NCH(d) ? e[0] : new Tuple(e, Store, b.lineno, b.col_offset);
    return new For_(d, astForTestlist(a, CHILD(b, 3)), astForSuite(a, CHILD(b, 5)), c, b.lineno, b.col_offset);
  }
  function astForCall(a, b, c) {
    REQ(b, SYM.arglist);
    for (var d = 0, e = 0, f = 0, g = 0; g < NCH(b); ++g) {
      var h = CHILD(b, g);
      h.type === SYM.argument && (1 === NCH(h) ? d++ : CHILD(h, 1).type === SYM.gen_for ? f++ : e++);
    }
    if (1 < f || f && (d || e))
      throw new Sk.builtin.SyntaxError('Generator expression must be parenthesized if not sole argument', a.c_filename, b.lineno);
    if (255 < d + e + f)
      throw new Sk.builtin.SyntaxError('more than 255 arguments', a.c_filename, b.lineno);
    for (var f = [], l = [], e = d = 0, k = null, m = null, g = 0; g < NCH(b); ++g)
      if (h = CHILD(b, g), h.type === SYM.argument)
        if (1 === NCH(h)) {
          if (e)
            throw new Sk.builtin.SyntaxError('non-keyword arg after keyword arg', a.c_filename, b.lineno);
          if (k)
            throw new Sk.builtin.SyntaxError('only named arguments may follow *expression', a.c_filename, b.lineno);
          f[d++] = astForExpr(a, CHILD(h, 0));
        } else if (CHILD(h, 1).type === SYM.gen_for)
          f[d++] = astForGenexp(a, h);
        else {
          var p = astForExpr(a, CHILD(h, 0));
          if (p.constructor === Lambda)
            throw new Sk.builtin.SyntaxError('lambda cannot contain assignment', a.c_filename, b.lineno);
          if (p.constructor !== Name)
            throw new Sk.builtin.SyntaxError('keyword can\'t be an expression', a.c_filename, b.lineno);
          p = p.id;
          forbiddenCheck(a, CHILD(h, 0), p, b.lineno);
          for (var n = 0; n < e; ++n)
            if (l[n].arg === p)
              throw new Sk.builtin.SyntaxError('keyword argument repeated', a.c_filename, b.lineno);
          l[e++] = new keyword(p, astForExpr(a, CHILD(h, 2)));
        }
      else
        h.type === TOK.T_STAR ? k = astForExpr(a, CHILD(b, ++g)) : h.type === TOK.T_DOUBLESTAR && (m = astForExpr(a, CHILD(b, ++g)));
    return new Call(c, f, l, k, m, c.lineno, c.col_offset);
  }
  function astForTrailer(a, b, c) {
    REQ(b, SYM.trailer);
    if (CHILD(b, 0).type === TOK.T_LPAR)
      return 2 === NCH(b) ? new Call(c, [], [], null, null, b.lineno, b.col_offset) : astForCall(a, CHILD(b, 1), c);
    if (CHILD(b, 0).type === TOK.T_DOT)
      return new Attribute(c, strobj(CHILD(b, 1).value), Load, b.lineno, b.col_offset);
    REQ(CHILD(b, 0), TOK.T_LSQB);
    REQ(CHILD(b, 2), TOK.T_RSQB);
    b = CHILD(b, 1);
    if (1 === NCH(b))
      return new Subscript(c, astForSlice(a, CHILD(b, 0)), Load, b.lineno, b.col_offset);
    for (var d = !0, e = [], f = 0; f < NCH(b); f += 2) {
      var g = astForSlice(a, CHILD(b, f));
      g.constructor !== Index && (d = !1);
      e[f / 2] = g;
    }
    if (!d)
      return new Subscript(c, new ExtSlice(e), Load, b.lineno, b.col_offset);
    a = [];
    for (f = 0; f < e.length; ++f)
      g = e[f], goog.asserts.assert(g.constructor === Index && null !== g.value && void 0 !== g.value), a[f] = g.value;
    e = new Tuple(a, Load, b.lineno, b.col_offset);
    return new Subscript(c, new Index(e), Load, b.lineno, b.col_offset);
  }
  function astForFlowStmt(a, b) {
    var c;
    REQ(b, SYM.flow_stmt);
    c = CHILD(b, 0);
    switch (c.type) {
    case SYM.break_stmt:
      return new Break_(b.lineno, b.col_offset);
    case SYM.continue_stmt:
      return new Continue_(b.lineno, b.col_offset);
    case SYM.yield_stmt:
      return new Expr(astForExpr(a, CHILD(c, 0)), b.lineno, b.col_offset);
    case SYM.return_stmt:
      return 1 === NCH(c) ? new Return_(null, b.lineno, b.col_offset) : new Return_(astForTestlist(a, CHILD(c, 1)), b.lineno, b.col_offset);
    case SYM.raise_stmt:
      if (1 === NCH(c))
        return new Raise(null, null, null, b.lineno, b.col_offset);
      if (2 === NCH(c))
        return new Raise(astForExpr(a, CHILD(c, 1)), null, null, b.lineno, b.col_offset);
      if (4 === NCH(c))
        return new Raise(astForExpr(a, CHILD(c, 1)), astForExpr(a, CHILD(c, 3)), null, b.lineno, b.col_offset);
      if (6 === NCH(c))
        return new Raise(astForExpr(a, CHILD(c, 1)), astForExpr(a, CHILD(c, 3)), astForExpr(a, CHILD(c, 5)), b.lineno, b.col_offset);
    default:
      goog.asserts.fail('unexpected flow_stmt');
    }
    goog.asserts.fail('unhandled flow statement');
  }
  function astForArguments(a, b) {
    var c, d = null, e = null;
    if (b.type === SYM.parameters) {
      if (2 === NCH(b))
        return new arguments_([], null, null, []);
      b = CHILD(b, 1);
    }
    REQ(b, SYM.varargslist);
    for (var f = [], g = [], h = !1, l = 0, k = 0, m = 0; l < NCH(b);)
      switch (c = CHILD(b, l), c.type) {
      case SYM.fpdef:
        var p = 0;
        a:
          for (;;) {
            if (l + 1 < NCH(b) && CHILD(b, l + 1).type === TOK.T_EQUAL)
              g[k++] = astForExpr(a, CHILD(b, l + 2)), l += 2, h = !0;
            else if (h) {
              if (p)
                throw new Sk.builtin.SyntaxError('parenthesized arg with default', a.c_filename, b.lineno);
              throw new Sk.builtin.SyntaxError('non-default argument follows default argument', a.c_filename, b.lineno);
            }
            if (3 === NCH(c)) {
              c = CHILD(c, 1);
              if (1 !== NCH(c))
                throw new Sk.builtin.SyntaxError('tuple parameter unpacking has been removed', a.c_filename, b.lineno);
              p = !0;
              c = CHILD(c, 0);
              goog.asserts.assert(c.type === SYM.fpdef);
              continue a;
            }
            if (CHILD(c, 0).type === TOK.T_NAME) {
              forbiddenCheck(a, b, CHILD(c, 0).value, b.lineno);
              var n = strobj(CHILD(c, 0).value);
              f[m++] = new Name(n, Param, c.lineno, c.col_offset);
            }
            l += 2;
            if (p)
              throw new Sk.builtin.SyntaxError('parenthesized argument names are invalid', a.c_filename, b.lineno);
            break;
          }
        break;
      case TOK.T_STAR:
        forbiddenCheck(a, CHILD(b, l + 1), CHILD(b, l + 1).value, b.lineno);
        d = strobj(CHILD(b, l + 1).value);
        l += 3;
        break;
      case TOK.T_DOUBLESTAR:
        forbiddenCheck(a, CHILD(b, l + 1), CHILD(b, l + 1).value, b.lineno);
        e = strobj(CHILD(b, l + 1).value);
        l += 3;
        break;
      default:
        goog.asserts.fail('unexpected node in varargslist');
      }
    return new arguments_(f, d, e, g);
  }
  function astForFuncdef(a, b, c) {
    REQ(b, SYM.funcdef);
    var d = strobj(CHILD(b, 1).value);
    forbiddenCheck(a, CHILD(b, 1), CHILD(b, 1).value, b.lineno);
    var e = astForArguments(a, CHILD(b, 2));
    a = astForSuite(a, CHILD(b, 4));
    return new FunctionDef(d, e, a, c, b.lineno, b.col_offset);
  }
  function astForClassBases(a, b) {
    goog.asserts.assert(0 < NCH(b));
    REQ(b, SYM.testlist);
    return 1 === NCH(b) ? [astForExpr(a, CHILD(b, 0))] : seqForTestlist(a, b);
  }
  function astForClassdef(a, b, c) {
    REQ(b, SYM.classdef);
    forbiddenCheck(a, b, CHILD(b, 1).value, b.lineno);
    var d = strobj(CHILD(b, 1).value);
    if (4 === NCH(b))
      return new ClassDef(d, [], astForSuite(a, CHILD(b, 3)), c, b.lineno, b.col_offset);
    if (CHILD(b, 3).type === TOK.T_RPAR)
      return new ClassDef(d, [], astForSuite(a, CHILD(b, 5)), c, b.lineno, b.col_offset);
    var e = astForClassBases(a, CHILD(b, 3));
    a = astForSuite(a, CHILD(b, 6));
    return new ClassDef(d, e, a, c, b.lineno, b.col_offset);
  }
  function astForLambdef(a, b) {
    var c, d;
    3 === NCH(b) ? (c = new arguments_([], null, null, []), d = astForExpr(a, CHILD(b, 2))) : (c = astForArguments(a, CHILD(b, 1)), d = astForExpr(a, CHILD(b, 3)));
    return new Lambda(c, d, b.lineno, b.col_offset);
  }
  function astForGenexp(a, b) {
    function c(a, b) {
      for (var c = 0;;) {
        REQ(b, SYM.gen_iter);
        if (CHILD(b, 0).type === SYM.gen_for)
          return c;
        b = CHILD(b, 0);
        REQ(b, SYM.gen_if);
        c++;
        if (2 == NCH(b))
          return c;
        b = CHILD(b, 2);
      }
    }
    goog.asserts.assert(b.type === SYM.testlist_gexp || b.type === SYM.argument);
    goog.asserts.assert(1 < NCH(b));
    for (var d = astForExpr(a, CHILD(b, 0)), e = function (a, b) {
          var c = 0, d = CHILD(b, 1);
          a:
            for (;;) {
              c++;
              REQ(d, SYM.gen_for);
              if (5 === NCH(d))
                d = CHILD(d, 4);
              else
                return c;
              b:
                for (;;) {
                  REQ(d, SYM.gen_iter);
                  d = CHILD(d, 0);
                  if (d.type === SYM.gen_for)
                    continue a;
                  else if (d.type === SYM.gen_if)
                    if (3 === NCH(d)) {
                      d = CHILD(d, 2);
                      continue b;
                    } else
                      return c;
                  break;
                }
              break;
            }
          goog.asserts.fail('logic error in countGenFors');
        }(a, b), f = [], g = CHILD(b, 1), h = 0; h < e; ++h) {
      REQ(g, SYM.gen_for);
      var l = CHILD(g, 1), k = astForExprlist(a, l, Store), m = astForExpr(a, CHILD(g, 3)), l = 1 === NCH(l) ? new comprehension(k[0], m, []) : new comprehension(new Tuple(k, Store, g.lineno, g.col_offset), m, []);
      if (5 === NCH(g)) {
        for (var g = CHILD(g, 4), k = c(a, g), p = [], n = 0; n < k; ++n)
          REQ(g, SYM.gen_iter), g = CHILD(g, 0), REQ(g, SYM.gen_if), m = astForExpr(a, CHILD(g, 1)), p[n] = m, 3 === NCH(g) && (g = CHILD(g, 2));
        g.type === SYM.gen_iter && (g = CHILD(g, 0));
        l.ifs = p;
      }
      f[h] = l;
    }
    return new GeneratorExp(d, f, b.lineno, b.col_offset);
  }
  function astForWhileStmt(a, b) {
    REQ(b, SYM.while_stmt);
    if (4 === NCH(b))
      return new While_(astForExpr(a, CHILD(b, 1)), astForSuite(a, CHILD(b, 3)), [], b.lineno, b.col_offset);
    if (7 === NCH(b))
      return new While_(astForExpr(a, CHILD(b, 1)), astForSuite(a, CHILD(b, 3)), astForSuite(a, CHILD(b, 6)), b.lineno, b.col_offset);
    goog.asserts.fail('wrong number of tokens for \'while\' stmt');
  }
  function astForAugassign(a, b) {
    REQ(b, SYM.augassign);
    b = CHILD(b, 0);
    switch (b.value.charAt(0)) {
    case '+':
      return Add;
    case '-':
      return Sub;
    case '/':
      return '/' === b.value.charAt(1) ? FloorDiv : Div;
    case '%':
      return Mod;
    case '<':
      return LShift;
    case '>':
      return RShift;
    case '&':
      return BitAnd;
    case '^':
      return BitXor;
    case '|':
      return BitOr;
    case '*':
      return '*' === b.value.charAt(1) ? Pow : Mult;
    default:
      goog.asserts.fail('invalid augassign');
    }
  }
  function astForBinop(a, b) {
    for (var c = new BinOp(astForExpr(a, CHILD(b, 0)), getOperator(CHILD(b, 1)), astForExpr(a, CHILD(b, 2)), b.lineno, b.col_offset), d = (NCH(b) - 1) / 2, e = 1; e < d; ++e)
      var f = CHILD(b, 2 * e + 1), g = getOperator(f), h = astForExpr(a, CHILD(b, 2 * e + 2)), c = new BinOp(c, g, h, f.lineno, f.col_offset);
    return c;
  }
  function astForTestlist(a, b) {
    goog.asserts.assert(0 < NCH(b));
    b.type === SYM.testlist_gexp ? 1 < NCH(b) && goog.asserts.assert(CHILD(b, 1).type !== SYM.gen_for) : goog.asserts.assert(b.type === SYM.testlist || b.type === SYM.testlist_safe || b.type === SYM.testlist1);
    return 1 === NCH(b) ? astForExpr(a, CHILD(b, 0)) : new Tuple(seqForTestlist(a, b), Load, b.lineno, b.col_offset);
  }
  function astForExprStmt(a, b) {
    REQ(b, SYM.expr_stmt);
    if (1 === NCH(b))
      return new Expr(astForTestlist(a, CHILD(b, 0)), b.lineno, b.col_offset);
    if (CHILD(b, 1).type === SYM.augassign) {
      var c = CHILD(b, 0), d = astForTestlist(a, c);
      switch (d.constructor) {
      case GeneratorExp:
        throw new Sk.builtin.SyntaxError('augmented assignment to generator expression not possible', a.c_filename, b.lineno);
      case Yield:
        throw new Sk.builtin.SyntaxError('augmented assignment to yield expression not possible', a.c_filename, b.lineno);
      case Name:
        forbiddenCheck(a, c, d.id, b.lineno);
        break;
      case Attribute:
      case Subscript:
        break;
      default:
        throw new Sk.builtin.SyntaxError('illegal expression for augmented assignment', a.c_filename, b.lineno);
      }
      setContext(a, d, Store, c);
      c = CHILD(b, 2);
      c = c.type === SYM.testlist ? astForTestlist(a, c) : astForExpr(a, c);
      return new AugAssign(d, astForAugassign(a, CHILD(b, 1)), c, b.lineno, b.col_offset);
    }
    REQ(CHILD(b, 1), TOK.T_EQUAL);
    for (var d = [], e = 0; e < NCH(b) - 2; e += 2) {
      c = CHILD(b, e);
      if (c.type === SYM.yield_expr)
        throw new Sk.builtin.SyntaxError('assignment to yield expression not possible', a.c_filename, b.lineno);
      c = astForTestlist(a, c);
      setContext(a, c, Store, CHILD(b, e));
      d[e / 2] = c;
    }
    c = CHILD(b, NCH(b) - 1);
    c = c.type === SYM.testlist ? astForTestlist(a, c) : astForExpr(a, c);
    return new Assign(d, c, b.lineno, b.col_offset);
  }
  function astForIfexpr(a, b) {
    goog.asserts.assert(5 === NCH(b));
    return new IfExp(astForExpr(a, CHILD(b, 2)), astForExpr(a, CHILD(b, 0)), astForExpr(a, CHILD(b, 4)), b.lineno, b.col_offset);
  }
  function parsestr(a, b) {
    var c = b.charAt(0), d = !1, e = !1;
    if ('u' === c || 'U' === c)
      b = b.substr(1), c = b.charAt(0), e = !0;
    else if ('r' === c || 'R' === c)
      b = b.substr(1), c = b.charAt(0), d = !0;
    goog.asserts.assert('b' !== c && 'B' !== c, 'todo; haven\'t done b\'\' strings yet');
    goog.asserts.assert('\'' === c || '"' === c && b.charAt(b.length - 1) === c);
    b = b.substr(1, b.length - 2);
    e && (b = unescape(encodeURIComponent(b)));
    4 <= b.length && (b.charAt(0) === c && b.charAt(1) === c) && (goog.asserts.assert(b.charAt(b.length - 1) === c && b.charAt(b.length - 2) === c), b = b.substr(2, b.length - 4));
    if (d || -1 === b.indexOf('\\'))
      c = strobj(decodeURIComponent(escape(b)));
    else {
      for (var c = strobj, d = b, e = d.length, f = '', g = 0; g < e; ++g) {
        var h = d.charAt(g);
        if ('\\' === h)
          if (++g, h = d.charAt(g), 'n' === h)
            f += '\n';
          else if ('\\' === h)
            f += '\\';
          else if ('t' === h)
            f += '\t';
          else if ('r' === h)
            f += '\r';
          else if ('b' === h)
            f += '\b';
          else if ('f' === h)
            f += '\f';
          else if ('v' === h)
            f += '\x0B';
          else if ('0' === h)
            f += '\0';
          else if ('"' === h)
            f += '"';
          else if ('\'' === h)
            f += '\'';
          else {
            if ('\n' !== h)
              if ('x' === h)
                var h = d.charAt(++g), l = d.charAt(++g), f = f + String.fromCharCode(parseInt(h + l, 16));
              else if ('u' === h || 'U' === h)
                var h = d.charAt(++g), l = d.charAt(++g), k = d.charAt(++g), m = d.charAt(++g), f = f + String.fromCharCode(parseInt(h + l, 16), parseInt(k + m, 16));
              else
                f += '\\' + h;
          }
        else
          f += h;
      }
      c = c(f);
    }
    return c;
  }
  function parsestrplus(a, b) {
    REQ(CHILD(b, 0), TOK.T_STRING);
    for (var c = Sk.builtin.stringToPy(''), d = 0; d < NCH(b); ++d)
      try {
        c = c.sq$concat(parsestr(a, CHILD(b, d).value));
      } catch (e) {
        throw new Sk.builtin.SyntaxError('invalid string (possibly contains a unicode character)', a.c_filename, CHILD(b, d).lineno);
      }
    return c;
  }
  function parsenumber(a, b, c) {
    var d = b.charAt(b.length - 1);
    if ('j' === d || 'J' === d)
      throw new Sk.builtin.SyntaxError('complex numbers are currently unsupported', a.c_filename, c);
    if ('l' === d || 'L' === d)
      return Sk.ffi.longFromString(b.substr(0, b.length - 1), 0);
    if (-1 !== b.indexOf('.'))
      return Sk.builtin.numberToPy(parseFloat(b));
    c = b;
    a = !1;
    '-' === b.charAt(0) && (c = b.substr(1), a = !0);
    if ('0' !== c.charAt(0) || 'x' !== c.charAt(1) && 'X' !== c.charAt(1)) {
      if (-1 !== b.indexOf('e') || -1 !== b.indexOf('E'))
        return Sk.builtin.numberToPy(parseFloat(b));
      if ('0' !== c.charAt(0) || 'b' !== c.charAt(1) && 'B' !== c.charAt(1))
        if ('0' === c.charAt(0))
          if ('0' === c)
            c = 0;
          else {
            c = c.substring(1);
            if ('o' === c.charAt(0) || 'O' === c.charAt(0))
              c = c.substring(1);
            c = parseInt(c, 8);
          }
        else
          c = parseInt(c, 10);
      else
        c = c.substring(2), c = parseInt(c, 2);
    } else
      c = c.substring(2), c = parseInt(c, 16);
    return c > Sk.builtin.lng.threshold$ && Math.floor(c) === c && -1 === b.indexOf('e') && -1 === b.indexOf('E') ? Sk.ffi.longFromString(b, 0) : a ? Sk.ffi.numberToIntPy(-c) : Sk.ffi.numberToIntPy(c);
  }
  function astForSlice(a, b) {
    REQ(b, SYM.subscript);
    var c = CHILD(b, 0), d = null, e = null, f = null;
    if (c.type === TOK.T_DOT)
      return new Ellipsis();
    if (1 === NCH(b) && c.type === SYM.test)
      return new Index(astForExpr(a, c));
    c.type === SYM.test && (d = astForExpr(a, c));
    c.type === TOK.T_COLON ? 1 < NCH(b) && (c = CHILD(b, 1), c.type === SYM.test && (e = astForExpr(a, c))) : 2 < NCH(b) && (c = CHILD(b, 2), c.type === SYM.test && (e = astForExpr(a, c)));
    c = CHILD(b, NCH(b) - 1);
    c.type === SYM.sliceop && (1 === NCH(c) ? (c = CHILD(c, 0), f = new Name(strobj('None'), Load, c.lineno, c.col_offset)) : (c = CHILD(c, 1), c.type === SYM.test && (f = astForExpr(a, c))));
    return new Slice(d, e, f);
  }
  function astForAtom(a, b) {
    var c = CHILD(b, 0);
    switch (c.type) {
    case TOK.T_NAME:
      return new Name(strobj(c.value), Load, b.lineno, b.col_offset);
    case TOK.T_STRING:
      return new Str(parsestrplus(a, b), b.lineno, b.col_offset);
    case TOK.T_NUMBER:
      return new Num(parsenumber(a, c.value, b.lineno), b.lineno, b.col_offset);
    case TOK.T_LPAR:
      return c = CHILD(b, 1), c.type === TOK.T_RPAR ? new Tuple([], Load, b.lineno, b.col_offset) : c.type === SYM.yield_expr ? astForExpr(a, c) : 1 < NCH(c) && CHILD(c, 1).type === SYM.gen_for ? astForGenexp(a, c) : astForTestlistGexp(a, c);
    case TOK.T_LSQB:
      c = CHILD(b, 1);
      if (c.type === TOK.T_RSQB)
        return new List([], Load, b.lineno, b.col_offset);
      REQ(c, SYM.listmaker);
      return 1 === NCH(c) || CHILD(c, 1).type === TOK.T_COMMA ? new List(seqForTestlist(a, c), Load, b.lineno, b.col_offset) : astForListcomp(a, c);
    case TOK.T_LBRACE:
      c = CHILD(b, 1);
      NCH(c);
      for (var d = [], e = [], f = 0; f < NCH(c); f += 4)
        d[f / 4] = astForExpr(a, CHILD(c, f)), e[f / 4] = astForExpr(a, CHILD(c, f + 2));
      return new Dict(d, e, b.lineno, b.col_offset);
    case TOK.T_BACKQUOTE:
      throw new Sk.builtin.SyntaxError('backquote not supported, use repr()', a.c_filename, b.lineno);
    default:
      goog.asserts.fail('unhandled atom', c.type);
    }
  }
  function astForPower(a, b) {
    REQ(b, SYM.power);
    var c = astForAtom(a, CHILD(b, 0));
    if (1 === NCH(b))
      return c;
    for (var d = 1; d < NCH(b); ++d) {
      var e = CHILD(b, d);
      if (e.type !== SYM.trailer)
        break;
      e = astForTrailer(a, e, c);
      e.lineno = c.lineno;
      e.col_offset = c.col_offset;
      c = e;
    }
    CHILD(b, NCH(b) - 1).type === SYM.factor && (d = astForExpr(a, CHILD(b, NCH(b) - 1)), c = new BinOp(c, Pow, d, b.lineno, b.col_offset));
    return c;
  }
  function astForExpr(a, b) {
    a:
      for (;;) {
        switch (b.type) {
        case SYM.test:
        case SYM.old_test:
          if (CHILD(b, 0).type === SYM.lambdef || CHILD(b, 0).type === SYM.old_lambdef)
            return astForLambdef(a, CHILD(b, 0));
          if (1 < NCH(b))
            return astForIfexpr(a, b);
        case SYM.or_test:
        case SYM.and_test:
          if (1 === NCH(b)) {
            b = CHILD(b, 0);
            continue a;
          }
          for (var c = [], d = 0; d < NCH(b); d += 2)
            c[d / 2] = astForExpr(a, CHILD(b, d));
          if ('and' === CHILD(b, 1).value)
            return new BoolOp(And, c, b.lineno, b.col_offset);
          goog.asserts.assert('or' === CHILD(b, 1).value);
          return new BoolOp(Or, c, b.lineno, b.col_offset);
        case SYM.not_test:
          if (1 === NCH(b)) {
            b = CHILD(b, 0);
            continue a;
          } else
            return new UnaryOp(Not, astForExpr(a, CHILD(b, 1)), b.lineno, b.col_offset);
        case SYM.comparison:
          if (1 === NCH(b)) {
            b = CHILD(b, 0);
            continue a;
          } else {
            for (var c = [], e = [], d = 1; d < NCH(b); d += 2)
              c[(d - 1) / 2] = astForCompOp(a, CHILD(b, d)), e[(d - 1) / 2] = astForExpr(a, CHILD(b, d + 1));
            return new Compare(astForExpr(a, CHILD(b, 0)), c, e, b.lineno, b.col_offset);
          }
        case SYM.expr:
        case SYM.xor_expr:
        case SYM.and_expr:
        case SYM.shift_expr:
        case SYM.arith_expr:
        case SYM.term:
          if (1 === NCH(b)) {
            b = CHILD(b, 0);
            continue a;
          }
          return astForBinop(a, b);
        case SYM.yield_expr:
          return d = null, 2 === NCH(b) && (d = astForTestlist(a, CHILD(b, 1))), new Yield(d, b.lineno, b.col_offset);
        case SYM.factor:
          if (1 === NCH(b)) {
            b = CHILD(b, 0);
            continue a;
          }
          return astForFactor(a, b);
        case SYM.power:
          return astForPower(a, b);
        default:
          goog.asserts.fail('unhandled expr', 'n.type: %d', b.type);
        }
        break;
      }
  }
  function astForPrintStmt(a, b) {
    var c = 1, d = null;
    REQ(b, SYM.print_stmt);
    2 <= NCH(b) && CHILD(b, 1).type === TOK.T_RIGHTSHIFT && (d = astForExpr(a, CHILD(b, 2)), c = 4);
    for (var e = [], f = 0; c < NCH(b); c += 2, ++f)
      e[f] = astForExpr(a, CHILD(b, c));
    c = CHILD(b, NCH(b) - 1).type === TOK.T_COMMA ? !1 : !0;
    return new Print(d, e, c, b.lineno, b.col_offset);
  }
  function astForStmt(a, b) {
    b.type === SYM.stmt && (goog.asserts.assert(1 === NCH(b)), b = CHILD(b, 0));
    b.type === SYM.simple_stmt && (goog.asserts.assert(1 === numStmts(b)), b = CHILD(b, 0));
    if (b.type === SYM.small_stmt)
      switch (REQ(b, SYM.small_stmt), b = CHILD(b, 0), b.type) {
      case SYM.expr_stmt:
        return astForExprStmt(a, b);
      case SYM.print_stmt:
        return astForPrintStmt(a, b);
      case SYM.del_stmt:
        return astForDelStmt(a, b);
      case SYM.pass_stmt:
        return new Pass(b.lineno, b.col_offset);
      case SYM.flow_stmt:
        return astForFlowStmt(a, b);
      case SYM.import_stmt:
        return astForImportStmt(a, b);
      case SYM.global_stmt:
        return astForGlobalStmt(a, b);
      case SYM.exec_stmt:
        return astForExecStmt(a, b);
      case SYM.assert_stmt:
        return astForAssertStmt(a, b);
      default:
        goog.asserts.fail('unhandled small_stmt');
      }
    else {
      var c = CHILD(b, 0);
      REQ(b, SYM.compound_stmt);
      switch (c.type) {
      case SYM.if_stmt:
        return astForIfStmt(a, c);
      case SYM.while_stmt:
        return astForWhileStmt(a, c);
      case SYM.for_stmt:
        return astForForStmt(a, c);
      case SYM.try_stmt:
        return astForTryStmt(a, c);
      case SYM.with_stmt:
        return astForWithStmt(a, c);
      case SYM.funcdef:
        return astForFuncdef(a, c, []);
      case SYM.classdef:
        return astForClassdef(a, c, []);
      case SYM.decorated:
        return astForDecorated(a, c);
      default:
        goog.asserts.assert('unhandled compound_stmt');
      }
    }
  }
  Sk.astFromParse = function (a, b) {
    var c = new Compiling('utf-8', b), d = [], e, f = 0;
    switch (a.type) {
    case SYM.file_input:
      for (var g = 0; g < NCH(a) - 1; ++g)
        if (e = CHILD(a, g), a.type !== TOK.T_NEWLINE) {
          REQ(e, SYM.stmt);
          var h = numStmts(e);
          if (1 === h)
            d[f++] = astForStmt(c, e);
          else {
            e = CHILD(e, 0);
            REQ(e, SYM.simple_stmt);
            for (var l = 0; l < h; ++l)
              d[f++] = astForStmt(c, CHILD(e, 2 * l));
          }
        }
      return new Module(d);
    case SYM.eval_input:
      goog.asserts.fail('todo;');
    case SYM.single_input:
      goog.asserts.fail('todo;');
    default:
      goog.asserts.fail('todo;');
    }
  };
  Sk.astDump = function (a) {
    var b = function (a) {
        for (var b = '', c = 0; c < a; ++c)
          b += ' ';
        return b;
      }, c = function (a, e) {
        if (null === a)
          return e + 'None';
        if (a.prototype && void 0 !== a.prototype._astname && a.prototype._isenum)
          return e + a.prototype._astname + '()';
        if (void 0 !== a._astname) {
          for (var f = b(a._astname.length + 1), g = [], h = 0; h < a._fields.length; h += 2) {
            var l = a._fields[h], k = a._fields[h + 1](a), m = b(l.length + 1);
            g.push([
              l,
              c(k, e + f + m)
            ]);
          }
          l = [];
          for (h = 0; h < g.length; ++h)
            k = g[h], l.push(k[0] + '=' + k[1].replace(/^\s+/, ''));
          h = l.join(',\n' + e + f);
          return e + a._astname + '(' + h + ')';
        }
        if (goog.isArrayLike(a)) {
          f = [];
          for (h = 0; h < a.length; ++h)
            f.push(c(a[h], e + ' '));
          h = f.join(',\n');
          return e + '[' + h.replace(/^\s+/, '') + ']';
        }
        h = !0 === a ? 'True' : !1 === a ? 'False' : Sk.ffi.isLong(a) ? Sk.ffi.remapToJs(a.tp$str()) : Sk.builtin.isStringPy(a) ? Sk.builtin.stringToJs(a.tp$repr()) : '' + a;
        return e + h;
      };
    return c(a, '');
  };
  goog.exportSymbol('Sk.astFromParse', Sk.astFromParse);
  goog.exportSymbol('Sk.astDump', Sk.astDump);
  var DEF_GLOBAL = 1, DEF_LOCAL = 2, DEF_PARAM = 4, USE = 8, DEF_STAR = 16, DEF_DOUBLESTAR = 32, DEF_INTUPLE = 64, DEF_FREE = 128, DEF_FREE_GLOBAL = 256, DEF_FREE_CLASS = 512, DEF_IMPORT = 1024, DEF_BOUND = DEF_LOCAL | DEF_PARAM | DEF_IMPORT, SCOPE_OFF = 11, SCOPE_MASK = 7, LOCAL = 1, GLOBAL_EXPLICIT = 2, GLOBAL_IMPLICIT = 3, FREE = 4, CELL = 5, OPT_IMPORT_STAR = 1, OPT_EXEC = 2, OPT_BARE_EXEC = 4, OPT_TOPLEVEL = 8, GENERATOR = 2, GENERATOR_EXPRESSION = 2, ModuleBlock = 'module', FunctionBlock = 'function', ClassBlock = 'class';
  function Symbol(a, b, c) {
    this.__name = a;
    this.__flags = b;
    this.__scope = b >> SCOPE_OFF & SCOPE_MASK;
    this.__namespaces = c || [];
  }
  Symbol.prototype.get_name = function () {
    return this.__name;
  };
  Symbol.prototype.is_referenced = function () {
    return !!(this.__flags & USE);
  };
  Symbol.prototype.is_parameter = function () {
    return !!(this.__flags & DEF_PARAM);
  };
  Symbol.prototype.is_global = function () {
    return this.__scope === GLOBAL_IMPLICIT || this.__scope == GLOBAL_EXPLICIT;
  };
  Symbol.prototype.is_declared_global = function () {
    return this.__scope == GLOBAL_EXPLICIT;
  };
  Symbol.prototype.is_local = function () {
    return !!(this.__flags & DEF_BOUND);
  };
  Symbol.prototype.is_free = function () {
    return this.__scope == FREE;
  };
  Symbol.prototype.is_imported = function () {
    return !!(this.__flags & DEF_IMPORT);
  };
  Symbol.prototype.is_assigned = function () {
    return !!(this.__flags & DEF_LOCAL);
  };
  Symbol.prototype.is_namespace = function () {
    return this.__namespaces && 0 < this.__namespaces.length;
  };
  Symbol.prototype.get_namespaces = function () {
    return this.__namespaces;
  };
  var astScopeCounter = 0;
  function SymbolTableScope(a, b, c, d, e) {
    this.symFlags = {};
    this.name = b;
    this.varnames = [];
    this.children = [];
    this.blockType = c;
    this.returnsValue = this.varkeywords = this.varargs = this.generator = this.childHasFree = this.hasFree = this.isNested = !1;
    this.lineno = e;
    this.table = a;
    a.cur && (a.cur.nested || a.cur.blockType === FunctionBlock) && (this.isNested = !0);
    d.scopeId = astScopeCounter++;
    a.stss[d.scopeId] = this;
    this.symbols = {};
  }
  SymbolTableScope.prototype.get_type = function () {
    return this.blockType;
  };
  SymbolTableScope.prototype.get_name = function () {
    return this.name;
  };
  SymbolTableScope.prototype.get_lineno = function () {
    return this.lineno;
  };
  SymbolTableScope.prototype.is_nested = function () {
    return this.isNested;
  };
  SymbolTableScope.prototype.has_children = function () {
    return 0 < this.children.length;
  };
  SymbolTableScope.prototype.get_identifiers = function () {
    return this._identsMatching(function (a) {
      return !0;
    });
  };
  SymbolTableScope.prototype.lookup = function (a) {
    if (this.symbols.hasOwnProperty(a))
      a = this.symbols[a];
    else {
      var b = this.symFlags[a], c = this.__check_children(a);
      a = this.symbols[a] = new Symbol(a, b, c);
    }
    return a;
  };
  SymbolTableScope.prototype.__check_children = function (a) {
    for (var b = [], c = 0; c < this.children.length; ++c) {
      var d = this.children[c];
      d.name === a && b.push(d);
    }
    return b;
  };
  SymbolTableScope.prototype._identsMatching = function (a) {
    var b = [], c;
    for (c in this.symFlags)
      this.symFlags.hasOwnProperty(c) && a(this.symFlags[c]) && b.push(c);
    b.sort();
    return b;
  };
  SymbolTableScope.prototype.get_parameters = function () {
    goog.asserts.assert('function' == this.get_type(), 'get_parameters only valid for function scopes');
    this._funcParams || (this._funcParams = this._identsMatching(function (a) {
      return a & DEF_PARAM;
    }));
    return this._funcParams;
  };
  SymbolTableScope.prototype.get_locals = function () {
    goog.asserts.assert('function' == this.get_type(), 'get_locals only valid for function scopes');
    this._funcLocals || (this._funcLocals = this._identsMatching(function (a) {
      return a & DEF_BOUND;
    }));
    return this._funcLocals;
  };
  SymbolTableScope.prototype.get_globals = function () {
    goog.asserts.assert('function' == this.get_type(), 'get_globals only valid for function scopes');
    this._funcGlobals || (this._funcGlobals = this._identsMatching(function (a) {
      a = a >> SCOPE_OFF & SCOPE_MASK;
      return a == GLOBAL_IMPLICIT || a == GLOBAL_EXPLICIT;
    }));
    return this._funcGlobals;
  };
  SymbolTableScope.prototype.get_frees = function () {
    goog.asserts.assert('function' == this.get_type(), 'get_frees only valid for function scopes');
    this._funcFrees || (this._funcFrees = this._identsMatching(function (a) {
      return (a >> SCOPE_OFF & SCOPE_MASK) == FREE;
    }));
    return this._funcFrees;
  };
  SymbolTableScope.prototype.get_methods = function () {
    goog.asserts.assert('class' == this.get_type(), 'get_methods only valid for class scopes');
    if (!this._classMethods) {
      for (var a = [], b = 0; b < this.children.length; ++b)
        a.push(this.children[b].name);
      a.sort();
      this._classMethods = a;
    }
    return this._classMethods;
  };
  SymbolTableScope.prototype.getScope = function (a) {
    a = this.symFlags[a];
    return void 0 === a ? 0 : a >> SCOPE_OFF & SCOPE_MASK;
  };
  function SymbolTable(a) {
    this.filename = a;
    this.top = this.cur = null;
    this.stack = [];
    this.curClass = this.global = null;
    this.tmpname = 0;
    this.stss = {};
  }
  SymbolTable.prototype.getStsForAst = function (a) {
    goog.asserts.assert(void 0 !== a.scopeId, 'ast wasn\'t added to st?');
    a = this.stss[a.scopeId];
    goog.asserts.assert(void 0 !== a, 'unknown sym tab entry');
    return a;
  };
  SymbolTable.prototype.SEQStmt = function (a) {
    goog.asserts.assert(goog.isArrayLike(a), 'SEQ: nodes isn\'t array? got %s', a);
    for (var b = a.length, c = 0; c < b; ++c) {
      var d = a[c];
      d && this.visitStmt(d);
    }
  };
  SymbolTable.prototype.SEQExpr = function (a) {
    goog.asserts.assert(goog.isArrayLike(a), 'SEQ: nodes isn\'t array? got %s', a);
    for (var b = a.length, c = 0; c < b; ++c) {
      var d = a[c];
      d && this.visitExpr(d);
    }
  };
  SymbolTable.prototype.enterBlock = function (a, b, c, d) {
    a = fixReservedNames(a);
    var e = null;
    this.cur && (e = this.cur, this.stack.push(this.cur));
    this.cur = new SymbolTableScope(this, a, b, c, d);
    'top' === a && (this.global = this.cur.symFlags);
    e && e.children.push(this.cur);
  };
  SymbolTable.prototype.exitBlock = function () {
    this.cur = null;
    0 < this.stack.length && (this.cur = this.stack.pop());
  };
  SymbolTable.prototype.visitParams = function (a, b) {
    for (var c = 0; c < a.length; ++c) {
      var d = a[c];
      if (d.constructor === Name)
        goog.asserts.assert(d.ctx === Param || d.ctx === Store && !b), this.addDef(d.id, DEF_PARAM, d.lineno);
      else
        throw new Sk.builtin.SyntaxError('invalid expression in parameter list', this.filename);
    }
  };
  SymbolTable.prototype.visitArguments = function (a, b) {
    a.args && this.visitParams(a.args, !0);
    a.vararg && (this.addDef(a.vararg, DEF_PARAM, b), this.cur.varargs = !0);
    a.kwarg && (this.addDef(a.kwarg, DEF_PARAM, b), this.cur.varkeywords = !0);
  };
  SymbolTable.prototype.newTmpname = function (a) {
    this.addDef(Sk.builtin.stringToPy('_[' + ++this.tmpname + ']'), DEF_LOCAL, a);
  };
  SymbolTable.prototype.addDef = function (a, b, c) {
    var d = Sk.ffi.remapToJs(mangleName(this.curClass, a)), d = fixReservedNames(d), e = this.cur.symFlags[d];
    if (void 0 !== e) {
      if (b & DEF_PARAM && e & DEF_PARAM)
        throw new Sk.builtin.SyntaxError('duplicate argument \'' + Sk.ffi.remapToJs(a) + '\' in function definition', this.filename, c);
      e |= b;
    } else
      e = b;
    this.cur.symFlags[d] = e;
    b & DEF_PARAM ? this.cur.varnames.push(d) : b & DEF_GLOBAL && (e = b, a = this.global[d], void 0 !== a && (e |= a), this.global[d] = e);
  };
  SymbolTable.prototype.visitSlice = function (a) {
    switch (a.constructor) {
    case Slice:
      a.lower && this.visitExpr(a.lower);
      a.upper && this.visitExpr(a.upper);
      a.step && this.visitExpr(a.step);
      break;
    case ExtSlice:
      for (var b = 0; b < a.dims.length; ++b)
        this.visitSlice(a.dims[b]);
      break;
    case Index:
      this.visitExpr(a.value);
    }
  };
  SymbolTable.prototype.visitStmt = function (a) {
    goog.asserts.assert(void 0 !== a, 'visitStmt called with undefined');
    switch (a.constructor) {
    case FunctionDef:
      this.addDef(a.name, DEF_LOCAL, a.lineno);
      a.args.defaults && this.SEQExpr(a.args.defaults);
      a.decorator_list && this.SEQExpr(a.decorator_list);
      this.enterBlock(a.name.v, FunctionBlock, a, a.lineno);
      this.visitArguments(a.args, a.lineno);
      this.SEQStmt(a.body);
      this.exitBlock();
      break;
    case ClassDef:
      this.addDef(a.name, DEF_LOCAL, a.lineno);
      this.SEQExpr(a.bases);
      a.decorator_list && this.SEQExpr(a.decorator_list);
      this.enterBlock(a.name.v, ClassBlock, a, a.lineno);
      var b = this.curClass;
      this.curClass = a.name;
      this.SEQStmt(a.body);
      this.curCalss = b;
      this.exitBlock();
      break;
    case Return_:
      if (a.value && (this.visitExpr(a.value), this.cur.returnsValue = !0, this.cur.generator))
        throw new Sk.builtin.SyntaxError('\'return\' with argument inside generator', this.filename);
      break;
    case Delete_:
      this.SEQExpr(a.targets);
      break;
    case Assign:
      this.SEQExpr(a.targets);
      this.visitExpr(a.value);
      break;
    case AugAssign:
      this.visitExpr(a.target);
      this.visitExpr(a.value);
      break;
    case Print:
      a.dest && this.visitExpr(a.dest);
      this.SEQExpr(a.values);
      break;
    case For_:
      this.visitExpr(a.target);
      this.visitExpr(a.iter);
      this.SEQStmt(a.body);
      a.orelse && this.SEQStmt(a.orelse);
      break;
    case While_:
      this.visitExpr(a.test);
      this.SEQStmt(a.body);
      a.orelse && this.SEQStmt(a.orelse);
      break;
    case If_:
      this.visitExpr(a.test);
      this.SEQStmt(a.body);
      a.orelse && this.SEQStmt(a.orelse);
      break;
    case Raise:
      a.type && (this.visitExpr(a.type), a.inst && (this.visitExpr(a.inst), a.tback && this.visitExpr(a.tback)));
      break;
    case TryExcept:
      this.SEQStmt(a.body);
      this.SEQStmt(a.orelse);
      this.visitExcepthandlers(a.handlers);
      break;
    case TryFinally:
      this.SEQStmt(a.body);
      this.SEQStmt(a.finalbody);
      break;
    case Assert:
      this.visitExpr(a.test);
      a.msg && this.visitExpr(a.msg);
      break;
    case Import_:
    case ImportFrom:
      this.visitAlias(a.names, a.lineno);
      break;
    case Exec:
      this.visitExpr(a.body);
      a.globals && (this.visitExpr(a.globals), a.locals && this.visitExpr(a.locals));
      break;
    case Global:
      for (var b = a.names.length, c = 0; c < b; ++c) {
        var d = Sk.ffi.remapToJs(mangleName(this.curClass, a.names[c])), d = fixReservedNames(d), e = this.cur.symFlags[d];
        if (e & (DEF_LOCAL | USE)) {
          if (e & DEF_LOCAL)
            throw new Sk.builtin.SyntaxError('name \'' + d + '\' is assigned to before global declaration', this.filename, a.lineno);
          throw new Sk.builtin.SyntaxError('name \'' + d + '\' is used prior to global declaration', this.filename, a.lineno);
        }
        this.addDef(Sk.builtin.stringToPy(d), DEF_GLOBAL, a.lineno);
      }
      break;
    case Expr:
      this.visitExpr(a.value);
      break;
    case Pass:
    case Break_:
    case Continue_:
      break;
    case With_:
      this.newTmpname(a.lineno);
      this.visitExpr(a.context_expr);
      a.optional_vars && (this.newTmpname(a.lineno), this.visitExpr(a.optional_vars));
      this.SEQStmt(a.body);
      break;
    default:
      goog.asserts.fail('Unhandled type ' + a.constructor.name + ' in visitStmt');
    }
  };
  SymbolTable.prototype.visitExpr = function (a) {
    goog.asserts.assert(void 0 !== a, 'visitExpr called with undefined');
    switch (a.constructor) {
    case BoolOp:
      this.SEQExpr(a.values);
      break;
    case BinOp:
      this.visitExpr(a.left);
      this.visitExpr(a.right);
      break;
    case UnaryOp:
      this.visitExpr(a.operand);
      break;
    case Lambda:
      this.addDef(Sk.builtin.stringToPy('lambda'), DEF_LOCAL, a.lineno);
      a.args.defaults && this.SEQExpr(a.args.defaults);
      this.enterBlock('lambda', FunctionBlock, a, a.lineno);
      this.visitArguments(a.args, a.lineno);
      this.visitExpr(a.body);
      this.exitBlock();
      break;
    case IfExp:
      this.visitExpr(a.test);
      this.visitExpr(a.body);
      this.visitExpr(a.orelse);
      break;
    case Dict:
      this.SEQExpr(a.keys);
      this.SEQExpr(a.values);
      break;
    case ListComp:
      this.newTmpname(a.lineno);
      this.visitExpr(a.elt);
      this.visitComprehension(a.generators, 0);
      break;
    case GeneratorExp:
      this.visitGenexp(a);
      break;
    case Yield:
      a.value && this.visitExpr(a.value);
      this.cur.generator = !0;
      if (this.cur.returnsValue)
        throw new Sk.builtin.SyntaxError('\'return\' with argument inside generator', this.filename);
      break;
    case Compare:
      this.visitExpr(a.left);
      this.SEQExpr(a.comparators);
      break;
    case Call:
      this.visitExpr(a.func);
      this.SEQExpr(a.args);
      for (var b = 0; b < a.keywords.length; ++b)
        this.visitExpr(a.keywords[b].value);
      a.starargs && this.visitExpr(a.starargs);
      a.kwargs && this.visitExpr(a.kwargs);
      break;
    case Num:
    case Str:
      break;
    case Attribute:
      this.visitExpr(a.value);
      break;
    case Subscript:
      this.visitExpr(a.value);
      this.visitSlice(a.slice);
      break;
    case Name:
      this.addDef(a.id, a.ctx === Load ? USE : DEF_LOCAL, a.lineno);
      break;
    case List:
    case Tuple:
      this.SEQExpr(a.elts);
      break;
    default:
      goog.asserts.fail('Unhandled type ' + a.constructor.name + ' in visitExpr');
    }
  };
  SymbolTable.prototype.visitComprehension = function (a, b) {
    for (var c = a.length, d = b; d < c; ++d) {
      var e = a[d];
      this.visitExpr(e.target);
      this.visitExpr(e.iter);
      this.SEQExpr(e.ifs);
    }
  };
  SymbolTable.prototype.visitAlias = function (a, b) {
    for (var c = 0; c < a.length; ++c) {
      var d = a[c], e = d = null === d.asname ? d.name.v : d.asname.v, f = d.indexOf('.');
      -1 !== f && (e = d.substr(0, f));
      if ('*' !== d)
        this.addDef(Sk.builtin.stringToPy(e), DEF_IMPORT, b);
      else if (this.cur.blockType !== ModuleBlock)
        throw new Sk.builtin.SyntaxError('import * only allowed at module level', this.filename);
    }
  };
  SymbolTable.prototype.visitGenexp = function (a) {
    var b = a.generators[0];
    this.visitExpr(b.iter);
    this.enterBlock('genexpr', FunctionBlock, a, a.lineno);
    this.cur.generator = !0;
    this.addDef(Sk.builtin.stringToPy('.0'), DEF_PARAM, a.lineno);
    this.visitExpr(b.target);
    this.SEQExpr(b.ifs);
    this.visitComprehension(a.generators, 1);
    this.visitExpr(a.elt);
    this.exitBlock();
  };
  SymbolTable.prototype.visitExcepthandlers = function (a) {
    for (var b = 0, c; c = a[b]; ++b)
      c.type && this.visitExpr(c.type), c.name && this.visitExpr(c.name), this.SEQStmt(c.body);
  };
  function _dictUpdate(a, b) {
    for (var c in b)
      a[c] = b[c];
  }
  SymbolTable.prototype.analyzeBlock = function (a, b, c, d) {
    var e = {}, f = {}, g = {}, h = {}, l = {};
    a.blockType == ClassBlock && (_dictUpdate(g, d), b && _dictUpdate(h, b));
    for (var k in a.symFlags)
      this.analyzeName(a, f, k, a.symFlags[k], b, e, c, d);
    a.blockType !== ClassBlock && (a.blockType === FunctionBlock && _dictUpdate(h, e), b && _dictUpdate(h, b), _dictUpdate(g, d));
    d = {};
    e = a.children.length;
    for (k = 0; k < e; ++k) {
      var m = a.children[k];
      this.analyzeChildBlock(m, h, l, g, d);
      if (m.hasFree || m.childHasFree)
        a.childHasFree = !0;
    }
    _dictUpdate(l, d);
    a.blockType === FunctionBlock && this.analyzeCells(f, l);
    this.updateSymbols(a.symFlags, f, b, l, a.blockType === ClassBlock);
    _dictUpdate(c, l);
  };
  SymbolTable.prototype.analyzeChildBlock = function (a, b, c, d, e) {
    var f = {};
    _dictUpdate(f, b);
    b = {};
    _dictUpdate(b, c);
    c = {};
    _dictUpdate(c, d);
    this.analyzeBlock(a, f, b, c);
    _dictUpdate(e, b);
  };
  SymbolTable.prototype.analyzeCells = function (a, b) {
    for (var c in a)
      a[c] === LOCAL && void 0 !== b[c] && (a[c] = CELL, delete b[c]);
  };
  SymbolTable.prototype.updateSymbols = function (a, b, c, d, e) {
    for (var f in a) {
      var g = a[f], g = g | b[f] << SCOPE_OFF;
      a[f] = g;
    }
    b = FREE << SCOPE_OFF;
    for (f in d)
      d = a[f], void 0 !== d ? e && d & (DEF_BOUND | DEF_GLOBAL) && (a[f] = d | DEF_FREE_CLASS) : void 0 !== c[f] && (a[f] = b);
  };
  SymbolTable.prototype.analyzeName = function (a, b, c, d, e, f, g, h) {
    if (d & DEF_GLOBAL) {
      if (d & DEF_PARAM)
        throw new Sk.builtin.SyntaxError('name \'' + c + '\' is local and global', this.filename, a.lineno);
      b[c] = GLOBAL_EXPLICIT;
      h[c] = null;
      e && void 0 !== e[c] && delete e[c];
    } else
      d & DEF_BOUND ? (b[c] = LOCAL, f[c] = null, delete h[c]) : e && void 0 !== e[c] ? (b[c] = FREE, a.hasFree = !0, g[c] = null) : (h && void 0 !== h[c] || !a.isNested || (a.hasFree = !0), b[c] = GLOBAL_IMPLICIT);
  };
  SymbolTable.prototype.analyze = function () {
    this.analyzeBlock(this.top, null, {}, {});
  };
  Sk.symboltable = function (a, b) {
    var c = new SymbolTable(b);
    c.enterBlock('top', ModuleBlock, a, 0);
    c.top = c.cur;
    for (var d = 0; d < a.body.length; ++d)
      c.visitStmt(a.body[d]);
    c.exitBlock();
    c.analyze();
    return c;
  };
  Sk.dumpSymtab = function (a) {
    var b = function (a) {
        return a ? 'True' : 'False';
      }, c = function (a) {
        for (var b = [], c = 0; c < a.length; ++c)
          b.push(Sk.ffi.remapToJs(Sk.builtin.stringToPy(a[c]).tp$repr()));
        return '[' + b.join(', ') + ']';
      }, d = function (a, f) {
        void 0 === f && (f = '');
        var g;
        g = '' + (f + 'Sym_type: ' + a.get_type() + '\n');
        g += f + 'Sym_name: ' + a.get_name() + '\n';
        g += f + 'Sym_lineno: ' + a.get_lineno() + '\n';
        g += f + 'Sym_nested: ' + b(a.is_nested()) + '\n';
        g += f + 'Sym_haschildren: ' + b(a.has_children()) + '\n';
        'class' === a.get_type() ? g += f + 'Class_methods: ' + c(a.get_methods()) + '\n' : 'function' === a.get_type() && (g += f + 'Func_params: ' + c(a.get_parameters()) + '\n', g += f + 'Func_locals: ' + c(a.get_locals()) + '\n', g += f + 'Func_globals: ' + c(a.get_globals()) + '\n', g += f + 'Func_frees: ' + c(a.get_frees()) + '\n');
        g += f + '-- Identifiers --\n';
        for (var h = a.get_identifiers(), l = h.length, k = 0; k < l; ++k) {
          var m = a.lookup(h[k]);
          g += f + 'name: ' + m.get_name() + '\n';
          g += f + '  is_referenced: ' + b(m.is_referenced()) + '\n';
          g += f + '  is_imported: ' + b(m.is_imported()) + '\n';
          g += f + '  is_parameter: ' + b(m.is_parameter()) + '\n';
          g += f + '  is_global: ' + b(m.is_global()) + '\n';
          g += f + '  is_declared_global: ' + b(m.is_declared_global()) + '\n';
          g += f + '  is_local: ' + b(m.is_local()) + '\n';
          g += f + '  is_free: ' + b(m.is_free()) + '\n';
          g += f + '  is_assigned: ' + b(m.is_assigned()) + '\n';
          g += f + '  is_namespace: ' + b(m.is_namespace()) + '\n';
          var m = m.get_namespaces(), p = m.length;
          g += f + '  namespaces: [\n';
          for (var n = [], q = 0; q < p; ++q)
            n.push(d(m[q], f + '    '));
          g += n.join('\n');
          g += f + '  ]\n';
        }
        return g;
      };
    return d(a.top, '');
  };
  goog.exportSymbol('Sk.symboltable', Sk.symboltable);
  goog.exportSymbol('Sk.dumpSymtab', Sk.dumpSymtab);
  var out;
  Sk.gensymcount = 0;
  function Compiler(a, b, c, d) {
    this.filename = a;
    this.st = b;
    this.flags = c;
    this.interactive = !1;
    this.nestlevel = 0;
    this.u = null;
    this.stack = [];
    this.result = [];
    this.allUnits = [];
    this.source = d ? d.split('\n') : !1;
  }
  function CompilerUnit() {
    this.private_ = this.name = this.ste = null;
    this.lineno = this.firstlineno = 0;
    this.linenoSet = !1;
    this.localnames = [];
    this.blocknum = 0;
    this.blocks = [];
    this.curblock = 0;
    this.scopename = null;
    this.suffixCode = this.switchCode = this.varDeclsCode = this.prefixCode = '';
    this.breakBlocks = [];
    this.continueBlocks = [];
    this.exceptBlocks = [];
    this.finallyBlocks = [];
  }
  CompilerUnit.prototype.activateScope = function () {
    var a = this;
    out = function () {
      for (var b = a.blocks[a.curblock], c = 0; c < arguments.length; ++c)
        b.push(arguments[c]);
    };
  };
  Compiler.prototype.getSourceLine = function (a) {
    goog.asserts.assert(this.source);
    return this.source[a - 1];
  };
  Compiler.prototype.annotateSource = function (a) {
    if (this.source) {
      var b = a.lineno;
      a = a.col_offset;
      out('\n//\n// line ', b, ':\n// ', this.getSourceLine(b), '\n// ');
      for (var c = 0; c < a; ++c)
        out(' ');
      out('^\n//\n');
      out('\nSk.currLineNo = ', b, ';\nSk.currColNo = ', a, '\n\n');
      out('\nSk.currFilename = \'', this.filename, '\';\n\n');
    }
  };
  Compiler.prototype.gensym = function (a) {
    a = '$' + (a || '');
    return a += Sk.gensymcount++;
  };
  Compiler.prototype.niceName = function (a) {
    return this.gensym(a.replace('<', '').replace('>', '').replace(' ', '_'));
  };
  var reservedWords_ = {
      'abstract': !0,
      as: !0,
      'boolean': !0,
      'break': !0,
      'byte': !0,
      'case': !0,
      'catch': !0,
      'char': !0,
      'class': !0,
      'continue': !0,
      'const': !0,
      'debugger': !0,
      'default': !0,
      'delete': !0,
      'do': !0,
      'double': !0,
      'else': !0,
      'enum': !0,
      'export': !0,
      'extends': !0,
      'false': !0,
      'final': !0,
      'finally': !0,
      'float': !0,
      'for': !0,
      'function': !0,
      'goto': !0,
      'if': !0,
      'implements': !0,
      'import': !0,
      'in': !0,
      'instanceof': !0,
      'int': !0,
      'interface': !0,
      is: !0,
      'long': !0,
      namespace: !0,
      'native': !0,
      'new': !0,
      'null': !0,
      'package': !0,
      'private': !0,
      'protected': !0,
      'public': !0,
      'return': !0,
      'short': !0,
      'static': !0,
      'super': !1,
      'switch': !0,
      'synchronized': !0,
      'this': !0,
      'throw': !0,
      'throws': !0,
      'transient': !0,
      'true': !0,
      'try': !0,
      'typeof': !0,
      use: !0,
      'var': !0,
      'void': !0,
      'volatile': !0,
      'while': !0,
      'with': !0
    };
  function fixReservedWords(a) {
    return !0 !== reservedWords_[a] ? a : a + '_$rw$';
  }
  var reservedNames_ = {
      __defineGetter__: !0,
      __defineSetter__: !0,
      apply: !0,
      call: !0,
      eval: !0,
      hasOwnProperty: !0,
      isPrototypeOf: !0,
      __lookupGetter__: !0,
      __lookupSetter__: !0,
      __noSuchMethod__: !0,
      propertyIsEnumerable: !0,
      toSource: !0,
      toLocaleString: !0,
      toString: !0,
      unwatch: !0,
      valueOf: !0,
      watch: !0,
      length: !0
    };
  function fixReservedNames(a) {
    return reservedNames_[a] ? a + '_$rn$' : a;
  }
  Sk.mangleName = function (a) {
    return fixReservedNames(a);
  };
  goog.exportSymbol('Sk.mangleName', Sk.mangleName);
  function mangleName(a, b) {
    Sk.ffi.checkArgType('ident', Sk.ffi.PyType.STR, Sk.builtin.isStringPy(b), b);
    var c = Sk.builtin.stringToJs(b), d = null;
    if (null === a || (null === c || '_' !== c.charAt(0) || '_' !== c.charAt(1)) || '_' === c.charAt(c.length - 1) && '_' === c.charAt(c.length - 2))
      return b;
    Sk.ffi.checkArgType('priv', Sk.ffi.PyType.STR, Sk.builtin.isStringPy(a), a);
    d = Sk.builtin.stringToJs(a);
    d.replace(/_/g, '');
    if ('' === d)
      return b;
    d = Sk.builtin.stringToJs(a);
    d.replace(/^_*/, '');
    return d = Sk.builtin.stringToPy('_' + d + c);
  }
  Compiler.prototype._gr = function (a, b) {
    var c = this.gensym(a);
    out('var ', c, '=');
    for (var d = 1; d < arguments.length; ++d)
      out(arguments[d]);
    out(';');
    return c;
  };
  Compiler.prototype._interruptTest = function () {
    out('if (Sk.execStart === undefined) {Sk.execStart=new Date()}');
    out('if (Sk.execLimit != null && new Date() - Sk.execStart > Sk.execLimit) {throw new Sk.builtin.TimeLimitError(Sk.timeoutMsg())}');
  };
  Compiler.prototype._jumpfalse = function (a, b) {
    var c = this._gr('jfalse', '(', a, '===false||!Sk.misceval.isTrue(', a, '))');
    this._interruptTest();
    out('if(', c, '){/*test failed */$blk=', b, ';continue;}');
  };
  Compiler.prototype._jumpundef = function (a, b) {
    this._interruptTest();
    out('if(', a, '===undefined){$blk=', b, ';continue;}');
  };
  Compiler.prototype._jumptrue = function (a, b) {
    var c = this._gr('jtrue', '(', a, '===true||Sk.misceval.isTrue(', a, '))');
    this._interruptTest();
    out('if(', c, '){/*test passed */$blk=', b, ';continue;}');
  };
  Compiler.prototype._jump = function (a) {
    this._interruptTest();
    out('$blk=', a, ';/* jump */continue;');
  };
  Compiler.prototype.ctupleorlist = function (a, b, c) {
    goog.asserts.assert('tuple' === c || 'list' === c);
    if (a.ctx === Store)
      for (var d = 0; d < a.elts.length; ++d)
        this.vexpr(a.elts[d], 'Sk.abstr.objectGetItem(' + b + ',' + d + ')');
    else if (a.ctx === Load) {
      b = [];
      for (d = 0; d < a.elts.length; ++d)
        b.push(this._gr('elem', this.vexpr(a.elts[d])));
      return this._gr('load' + c, 'new Sk.builtins[\'', c, '\']([', b, '])');
    }
  };
  Compiler.prototype.cdict = function (a) {
    goog.asserts.assert(a.values.length === a.keys.length);
    for (var b = [], c = 0; c < a.values.length; ++c) {
      var d = this.vexpr(a.values[c]);
      b.push(this.vexpr(a.keys[c]));
      b.push(d);
    }
    return this._gr('loaddict', 'new Sk.builtins[\'dict\']([', b, '])');
  };
  Compiler.prototype.clistcompgen = function (a, b, c, d) {
    var e = this.newBlock('list gen start'), f = this.newBlock('list gen skip'), g = this.newBlock('list gen anchor'), h = b[c], l = this.vexpr(h.iter), l = this._gr('iter', 'Sk.abstr.iter(', l, ')');
    this._jump(e);
    this.setBlock(e);
    l = this._gr('next', 'Sk.abstr.iternext(', l, ')');
    this._jumpundef(l, g);
    this.vexpr(h.target, l);
    for (var l = h.ifs.length, k = 0; k < l; ++k) {
      var m = this.vexpr(h.ifs[k]);
      this._jumpfalse(m, e);
    }
    ++c < b.length && this.clistcompgen(a, b, c, d);
    c >= b.length && (b = this.vexpr(d), out(a, '.v.push(', b, ');'), this._jump(f), this.setBlock(f));
    this._jump(e);
    this.setBlock(g);
    return a;
  };
  Compiler.prototype.clistcomp = function (a) {
    goog.asserts.assert(a instanceof ListComp);
    var b = this._gr('_compr', 'new Sk.builtins[\'list\']([])');
    return this.clistcompgen(b, a.generators, 0, a.elt);
  };
  Compiler.prototype.cyield = function (a) {
    if (this.u.ste.blockType !== FunctionBlock)
      throw new SyntaxError('\'yield\' outside function');
    var b = 'null';
    a.value && (b = this.vexpr(a.value));
    a = this.newBlock('after yield');
    out('return [/*resume*/', a, ',/*ret*/', b, '];');
    this.setBlock(a);
    return '$gen.gi$sentvalue';
  };
  Compiler.prototype.ccompare = function (a) {
    goog.asserts.assert(a.ops.length === a.comparators.length);
    for (var b = this.vexpr(a.left), c = a.ops.length, d = this.newBlock('done'), e = this._gr('compareres', 'null'), f = 0; f < c; ++f) {
      var g = this.vexpr(a.comparators[f]), b = this._gr('compare', 'Sk.builtin.bool(Sk.misceval.richCompareBool(', b, ',', g, ',\'', a.ops[f].prototype._astname, '\'))');
      out(e, '=', b, ';');
      this._jumpfalse(b, d);
      b = g;
    }
    this._jump(d);
    this.setBlock(d);
    return e;
  };
  Compiler.prototype.ccall = function (a) {
    var b = this.vexpr(a.func), c = this.vseqexpr(a.args);
    if (0 < a.keywords.length || a.starargs || a.kwargs) {
      for (var d = [], e = 0; e < a.keywords.length; ++e)
        d.push('\'' + a.keywords[e].arg.v + '\''), d.push(this.vexpr(a.keywords[e].value));
      var d = '[' + d.join(',') + ']', f = e = 'undefined';
      a.starargs && (e = this.vexpr(a.starargs));
      a.kwargs && (f = this.vexpr(a.kwargs));
      return this._gr('call', 'Sk.misceval.call(', b, ',', f, ',', e, ',', d, 0 < c.length ? ',' : '', c, ')');
    }
    return this._gr('call', 'Sk.misceval.callsim(', b, 0 < c.length ? ',' : '', c, ')');
  };
  Compiler.prototype.cslice = function (a) {
    goog.asserts.assert(a instanceof Slice);
    var b = a.lower ? this.vexpr(a.lower) : 'null', c = a.upper ? this.vexpr(a.upper) : 'null';
    a = a.step ? this.vexpr(a.step) : 'null';
    return this._gr('slice', 'new Sk.builtins[\'slice\'](', b, ',', c, ',', a, ')');
  };
  Compiler.prototype.vslicesub = function (a) {
    var b;
    switch (a.constructor) {
    case Number:
    case String:
      b = a;
      break;
    case Index:
      b = this.vexpr(a.value);
      break;
    case Slice:
      b = this.cslice(a);
      break;
    case Ellipsis:
    case ExtSlice:
      goog.asserts.fail('todo;');
      break;
    default:
      goog.asserts.fail('invalid subscript kind');
    }
    return b;
  };
  Compiler.prototype.vslice = function (a, b, c, d) {
    a = this.vslicesub(a);
    return this.chandlesubscr(b, c, a, d);
  };
  Compiler.prototype.chandlesubscr = function (a, b, c, d) {
    if (a === Load || a === AugLoad)
      return this._gr('lsubscr', 'Sk.abstr.objectGetItem(', b, ',', c, ')');
    a === Store || a === AugStore ? out('Sk.abstr.objectSetItem(', b, ',', c, ',', d, ');') : a === Del ? out('Sk.abstr.objectDelItem(', b, ',', c, ');') : goog.asserts.fail('handlesubscr fail');
  };
  Compiler.prototype.cboolop = function (a) {
    goog.asserts.assert(a instanceof BoolOp);
    var b;
    b = a.op === And ? this._jumpfalse : this._jumptrue;
    var c = this.newBlock('end of boolop');
    a = a.values;
    for (var d = a.length, e, f = 0; f < d; ++f) {
      var g = this.vexpr(a[f]);
      0 === f && (e = this._gr('boolopsucc', g));
      out(e, '=', g, ';');
      b.call(this, g, c);
    }
    this._jump(c);
    this.setBlock(c);
    return e;
  };
  Compiler.prototype.vexpr = function (a, b, c) {
    a.lineno > this.u.lineno && (this.u.lineno = a.lineno, this.u.linenoSet = !1);
    switch (a.constructor) {
    case BoolOp:
      return this.cboolop(a);
    case BinOp:
      return this._gr('binop', 'Sk.abstr.numberBinOp(', this.vexpr(a.left), ',', this.vexpr(a.right), ',\'', a.op.prototype._astname, '\')');
    case UnaryOp:
      return this._gr('unaryop', 'Sk.abstr.numberUnaryOp(', this.vexpr(a.operand), ',\'', a.op.prototype._astname, '\')');
    case Lambda:
      return this.clambda(a);
    case IfExp:
      return this.cifexp(a);
    case Dict:
      return this.cdict(a);
    case ListComp:
      return this.clistcomp(a);
    case GeneratorExp:
      return this.cgenexp(a);
    case Yield:
      return this.cyield(a);
    case Compare:
      return this.ccompare(a);
    case Call:
      return b = this.ccall(a), this.annotateSource(a), b;
    case Num:
      if ('number' === typeof a.n)
        return a.n;
      if (Sk.ffi.isFloat(a.n))
        return 'Sk.builtin.numberToPy(' + Sk.ffi.remapToJs(a.n) + ')';
      if (Sk.ffi.isInt(a.n))
        return 'Sk.ffi.numberToIntPy(' + Sk.ffi.remapToJs(a.n) + ')';
      if (Sk.ffi.isLong(a.n))
        return 'Sk.ffi.longFromString(\'' + Sk.ffi.remapToJs(a.n.tp$str()) + '\')';
      goog.asserts.fail('unhandled Num type');
    case Str:
      return this._gr('str', 'Sk.builtin.stringToPy(', Sk.ffi.remapToJs(a.s.tp$repr()), ')');
    case Attribute:
      var d;
      a.ctx !== AugStore && (d = this.vexpr(a.value));
      var e = Sk.ffi.remapToJs(a.attr.tp$repr()), e = e.substring(1, e.length - 1), e = Sk.ffi.remapToJs(mangleName(this.u.private_, Sk.builtin.stringToPy(e))), e = fixReservedWords(e), e = fixReservedNames(e);
      switch (a.ctx) {
      case AugLoad:
      case Load:
        return this._gr('lattr', 'Sk.abstr.gattr(', d, ',\'', e, '\')');
      case AugStore:
        out('if(', b, '!==undefined){');
        d = this.vexpr(c || null);
        out('Sk.abstr.sattr(', d, ',\'', e, '\',', b, ');');
        out('}');
        break;
      case Store:
        out('Sk.abstr.sattr(', d, ',\'', e, '\',', b, ');');
        break;
      case Del:
        goog.asserts.fail('todo;');
        break;
      default:
        goog.asserts.fail('invalid attribute expression');
      }
      break;
    case Subscript:
      switch (a.ctx) {
      case AugLoad:
      case Load:
      case Store:
      case Del:
        return this.vslice(a.slice, a.ctx, this.vexpr(a.value), b);
      case AugStore:
        out('if(', b, '!==undefined){');
        d = this.vexpr(c || null);
        this.vslice(a.slice, a.ctx, d, b);
        out('}');
        break;
      default:
        goog.asserts.fail('invalid subscript expression');
      }
      break;
    case Name:
      return this.nameop(a.id, a.ctx, b);
    case List:
      return this.ctupleorlist(a, b, 'list');
    case Tuple:
      return this.ctupleorlist(a, b, 'tuple');
    default:
      goog.asserts.fail('unhandled case in vexpr');
    }
  };
  Compiler.prototype.vseqexpr = function (a, b) {
    goog.asserts.assert(void 0 === b || a.length === b.length);
    for (var c = [], d = 0; d < a.length; ++d)
      c.push(this.vexpr(a[d], void 0 === b ? void 0 : b[d]));
    return c;
  };
  Compiler.prototype.caugassign = function (a) {
    goog.asserts.assert(a instanceof AugAssign);
    var b = a.target;
    switch (b.constructor) {
    case Attribute:
      var c = new Attribute(b.value, b.attr, AugLoad, b.lineno, b.col_offset), d = this.vexpr(c), e = this.vexpr(a.value);
      a = this._gr('inplbinopattr', 'Sk.abstr.numberInplaceBinOp(', d, ',', e, ',\'', a.op.prototype._astname, '\')');
      c.ctx = AugStore;
      return this.vexpr(c, a, b.value);
    case Subscript:
      return c = this.vslicesub(b.slice), c = new Subscript(b.value, c, AugLoad, b.lineno, b.col_offset), d = this.vexpr(c), e = this.vexpr(a.value), a = this._gr('inplbinopsubscr', 'Sk.abstr.numberInplaceBinOp(', d, ',', e, ',\'', a.op.prototype._astname, '\')'), c.ctx = AugStore, this.vexpr(c, a, b.value);
    case Name:
      return c = this.nameop(b.id, Load), e = this.vexpr(a.value), a = this._gr('inplbinop', 'Sk.abstr.numberInplaceBinOp(', c, ',', e, ',\'', a.op.prototype._astname, '\')'), this.nameop(b.id, Store, a);
    default:
      goog.asserts.fail('unhandled case in augassign');
    }
  };
  Compiler.prototype.exprConstant = function (a) {
    switch (a.constructor) {
    case Num:
      return Sk.misceval.isTrue(a.n);
    case Str:
      return Sk.misceval.isTrue(a.s);
    default:
      return -1;
    }
  };
  Compiler.prototype.newBlock = function (a) {
    var b = this.u.blocknum++;
    this.u.blocks[b] = [];
    this.u.blocks[b]._name = a || '<unnamed>';
    return b;
  };
  Compiler.prototype.setBlock = function (a) {
    goog.asserts.assert(0 <= a && a < this.u.blocknum);
    this.u.curblock = a;
  };
  Compiler.prototype.pushBreakBlock = function (a) {
    goog.asserts.assert(0 <= a && a < this.u.blocknum);
    this.u.breakBlocks.push(a);
  };
  Compiler.prototype.popBreakBlock = function () {
    this.u.breakBlocks.pop();
  };
  Compiler.prototype.pushContinueBlock = function (a) {
    goog.asserts.assert(0 <= a && a < this.u.blocknum);
    this.u.continueBlocks.push(a);
  };
  Compiler.prototype.popContinueBlock = function () {
    this.u.continueBlocks.pop();
  };
  Compiler.prototype.pushExceptBlock = function (a) {
    goog.asserts.assert(0 <= a && a < this.u.blocknum);
    this.u.exceptBlocks.push(a);
  };
  Compiler.prototype.popExceptBlock = function () {
    this.u.exceptBlocks.pop();
  };
  Compiler.prototype.pushFinallyBlock = function (a) {
    goog.asserts.assert(0 <= a && a < this.u.blocknum);
    this.u.finallyBlocks.push(a);
  };
  Compiler.prototype.popFinallyBlock = function () {
    this.u.finallyBlocks.pop();
  };
  Compiler.prototype.setupExcept = function (a) {
    out('$exc.push(', a, ');');
  };
  Compiler.prototype.endExcept = function () {
    out('$exc.pop();');
  };
  Compiler.prototype.outputLocals = function (a) {
    for (var b = {}, c = 0; a.argnames && c < a.argnames.length; ++c)
      b[a.argnames[c]] = !0;
    a.localnames.sort();
    for (var d = [], c = 0; c < a.localnames.length; ++c) {
      var e = a.localnames[c];
      void 0 === b[e] && (d.push(e), b[e] = !0);
    }
    return 0 < d.length ? 'var ' + d.join(',') + '; /* locals */' : '';
  };
  Compiler.prototype.outputAllUnits = function () {
    for (var a = '', b = 0; b < this.allUnits.length; ++b) {
      for (var c = this.allUnits[b], a = a + c.prefixCode, a = a + this.outputLocals(c), a = a + c.varDeclsCode, a = a + c.switchCode, d = c.blocks, e = 0; e < d.length; ++e)
        a += 'case ' + e + ': /* --- ' + d[e]._name + ' --- */', a += d[e].join(''), a += 'throw new Sk.builtin.SystemError(\'internal error: unterminated block\');';
      a += c.suffixCode;
    }
    return a;
  };
  Compiler.prototype.cif = function (a) {
    goog.asserts.assert(a instanceof If_);
    var b = this.exprConstant(a.test);
    if (0 === b)
      a.orelse && this.vseqstmt(a.orelse);
    else if (1 === b)
      this.vseqstmt(a.body);
    else {
      var c = this.newBlock('end of if'), b = this.newBlock('next branch of if'), d = this.vexpr(a.test);
      this._jumpfalse(d, b);
      this.vseqstmt(a.body);
      this._jump(c);
      this.setBlock(b);
      a.orelse && this.vseqstmt(a.orelse);
      this._jump(c);
    }
    this.setBlock(c);
  };
  Compiler.prototype.cwhile = function (a) {
    if (0 === this.exprConstant(a.test))
      a.orelse && this.vseqstmt(a.orelse);
    else {
      var b = this.newBlock('while test');
      this._jump(b);
      this.setBlock(b);
      var c = this.newBlock('after while'), d = 0 < a.orelse.length ? this.newBlock('while orelse') : null, e = this.newBlock('while body');
      this._jumpfalse(this.vexpr(a.test), d ? d : c);
      this._jump(e);
      this.pushBreakBlock(c);
      this.pushContinueBlock(b);
      this.setBlock(e);
      this.vseqstmt(a.body);
      this._jump(b);
      this.popContinueBlock();
      this.popBreakBlock();
      0 < a.orelse.length && (this.setBlock(d), this.vseqstmt(a.orelse), this._jump(c));
      this.setBlock(c);
    }
  };
  Compiler.prototype.cfor = function (a) {
    var b = this.newBlock('for start'), c = this.newBlock('for cleanup'), d = this.newBlock('for end');
    this.pushBreakBlock(d);
    this.pushContinueBlock(b);
    var e = this.vexpr(a.iter), f;
    this.u.ste.generator ? (f = '$loc.' + this.gensym('iter'), out(f, '=Sk.abstr.iter(', e, ');')) : f = this._gr('iter', 'Sk.abstr.iter(', e, ')');
    this._jump(b);
    this.setBlock(b);
    e = this._gr('next', 'Sk.abstr.iternext(', f, ')');
    this._jumpundef(e, c);
    this.vexpr(a.target, e);
    this.vseqstmt(a.body);
    this._jump(b);
    this.setBlock(c);
    this.popContinueBlock();
    this.popBreakBlock();
    this.vseqstmt(a.orelse);
    this._jump(d);
    this.setBlock(d);
  };
  Compiler.prototype.craise = function (a) {
    if (a && a.type && a.type.id && 'StopIteration' === Sk.ffi.remapToJs(a.type.id))
      out('return undefined;');
    else {
      var b = '';
      a.inst ? (b = this.vexpr(a.inst), out('throw ', this.vexpr(a.type), '(', b, ');')) : a.type ? a.type.func ? out('throw ', this.vexpr(a.type), ';') : out('throw ', this.vexpr(a.type), '(\'\');') : out('throw $err;');
    }
  };
  Compiler.prototype.ctryexcept = function (a) {
    for (var b = a.handlers.length, c = [], d = 0; d < b; ++d)
      c.push(this.newBlock('except_' + d + '_'));
    var e = this.newBlock('unhandled'), f = this.newBlock('orelse'), g = this.newBlock('end');
    this.setupExcept(c[0]);
    this.vseqstmt(a.body);
    this.endExcept();
    this._jump(f);
    for (d = 0; d < b; ++d) {
      this.setBlock(c[d]);
      var h = a.handlers[d];
      if (!h.type && d < b - 1)
        throw new SyntaxError('default \'except:\' must be last');
      if (h.type) {
        var l = this.vexpr(h.type), k = d == b - 1 ? e : c[d + 1], l = this._gr('instance', '$err instanceof ', l);
        this._jumpfalse(l, k);
      }
      h.name && this.vexpr(h.name, '$err');
      this.vseqstmt(h.body);
      this._jump(g);
    }
    this.setBlock(e);
    out('throw $err;');
    this.setBlock(f);
    this.vseqstmt(a.orelse);
    this._jump(g);
    this.setBlock(g);
  };
  Compiler.prototype.ctryfinally = function (a) {
    out('/*todo; tryfinally*/');
    this.ctryexcept(a.body[0]);
  };
  Compiler.prototype.cassert = function (a) {
    var b = this.vexpr(a.test), c = this.newBlock('end');
    this._jumptrue(b, c);
    out('throw new Sk.builtin.AssertionError(', a.msg ? this.vexpr(a.msg) : '', ');');
    this.setBlock(c);
  };
  Compiler.prototype.cimportas = function (a, b, c) {
    a = Sk.ffi.remapToJs(a);
    var d = a.indexOf('.');
    if (-1 !== d)
      for (a = a.substr(d + 1); -1 !== d;) {
        var d = a.indexOf('.'), e = -1 !== d ? a.substr(0, d) : a;
        c = this._gr('lattr', 'Sk.abstr.gattr(', c, ',\'', e, '\')');
        a = a.substr(d + 1);
      }
    return this.nameop(b, Store, c);
  };
  Compiler.prototype.cimport = function (a) {
    for (var b = a.names.length, c = 0; c < b; ++c) {
      var d = a.names[c], e = this._gr('module', 'Sk.builtin.__import__(', Sk.ffi.remapToJs(d.name.tp$repr()), ',$gbl,$loc,[])');
      if (d.asname)
        this.cimportas(d.name, d.asname, e);
      else {
        var d = d.name, f = d.v.indexOf('.');
        -1 !== f && (d = Sk.builtin.stringToPy(Sk.ffi.remapToJs(d).substr(0, f)));
        this.nameop(d, Store, e);
      }
    }
  };
  Compiler.prototype.cfromimport = function (a) {
    for (var b = a.names.length, c = [], d = 0; d < b; ++d)
      c[d] = Sk.ffi.remapToJs(a.names[d].name.tp$repr());
    c = this._gr('module', 'Sk.builtin.__import__(', Sk.ffi.remapToJs(a.module.tp$repr()), ',$gbl,$loc,[', c, '])');
    for (d = 0; d < b; ++d) {
      var e = a.names[d];
      if (0 === d && '*' === Sk.ffi.remapToJs(e.name)) {
        goog.asserts.assert(1 === b);
        out('Sk.importStar(', c, ',$loc, $gbl);');
        break;
      }
      var f = this._gr('item', 'Sk.abstr.gattr(', c, ',', Sk.ffi.remapToJs(e.name.tp$repr()), ')'), g = e.name;
      e.asname && (g = e.asname);
      this.nameop(g, Store, f);
    }
  };
  Compiler.prototype.buildcodeobj = function (a, b, c, d, e) {
    var f = [], g = null, h = null;
    c && this.vseqexpr(c);
    d && d.defaults && (f = this.vseqexpr(d.defaults));
    d && d.vararg && (g = d.vararg);
    d && d.kwarg && (h = d.kwarg);
    c = this.u.ste.hasFree;
    var l = this.u.ste.childHasFree;
    a = this.enterScope(b, a, a.lineno);
    var k = this.u.ste.generator, m = this.u.ste.hasFree, p = this.u.ste.childHasFree, n = this.u.ste.hasFree, q = this.newBlock('codeobj entry');
    this.u.prefixCode = 'var ' + a + '=(function ' + this.niceName(Sk.ffi.remapToJs(b)) + '$(';
    var x = [];
    if (k) {
      if (h)
        throw new SyntaxError(Sk.ffi.remapToJs(b) + '(): keyword arguments in generators not supported');
      if (g)
        throw new SyntaxError(Sk.ffi.remapToJs(b) + '(): variable number of arguments in generators not supported');
      x.push('$gen');
    } else {
      h && x.push('$kwa');
      for (var D = 0; d && D < d.args.length; ++D)
        x.push(this.nameop(d.args[D].id, Param));
    }
    n && x.push('$free');
    this.u.prefixCode += x.join(',');
    this.u.prefixCode += '){';
    k && (this.u.prefixCode += '\n// generator\n');
    c && (this.u.prefixCode += '\n// containing has free\n');
    l && (this.u.prefixCode += '\n// containing has cell\n');
    m && (this.u.prefixCode += '\n// has free\n');
    p && (this.u.prefixCode += '\n// has cell\n');
    D = '{}';
    k && (q = '$gen.gi$resumeat', D = '$gen.gi$locals');
    l = '';
    p && (l = ',$cell={}');
    this.u.varDeclsCode += 'var $blk=' + q + ',$exc=[],$loc=' + D + l + ',$gbl=this,$err=undefined;';
    for (D = 0; d && D < d.args.length; ++D)
      p = d.args[D].id, this.isCell(p) && (this.u.varDeclsCode += '$cell.' + Sk.ffi.remapToJs(p) + '=' + Sk.ffi.remapToJs(p) + ';');
    k || (D = d ? d.args.length - f.length : 0, p = g ? Infinity : d ? d.args.length : 0, q = h ? !0 : !1, this.u.varDeclsCode += 'Sk.builtin.pyCheckArgs("' + Sk.ffi.remapToJs(b) + '", arguments, ' + D + ', ' + p + ', ' + q + ', ' + n + ');');
    if (0 < f.length)
      for (n = d.args.length - f.length, D = 0; D < f.length; ++D)
        p = this.nameop(d.args[D + n].id, Param), this.u.varDeclsCode += 'if(' + p + '===undefined)' + p + '=' + a + '.$defaults[' + D + '];';
    g && (x = x.length, this.u.varDeclsCode += Sk.ffi.remapToJs(g) + '=new Sk.builtins[\'tuple\'](Array.prototype.slice.call(arguments,' + x + ')); /*vararg*/');
    h && (this.u.varDeclsCode += Sk.ffi.remapToJs(h) + '=new Sk.builtins[\'dict\']($kwa);');
    this.u.switchCode = 'while(true){try{ switch($blk){';
    this.u.suffixCode = '} }catch(err){if ($exc.length>0) { $err = err; $blk=$exc.pop(); continue; } else { throw err; }} }});';
    e.call(this, a);
    var J;
    if (d && 0 < d.args.length) {
      e = [];
      for (D = 0; D < d.args.length; ++D)
        e.push(Sk.ffi.remapToJs(d.args[D].id));
      J = e.join('\', \'');
      this.u.argnames = e;
    }
    this.exitScope();
    0 < f.length && out(a, '.$defaults=[', f.join(','), '];');
    J && out(a, '.co_varnames=[\'', J, '\'];');
    h && out(a, '.co_kwargs=1;');
    h = '';
    m && (h = ',$cell', c && (h += ',$free'));
    return k ? d && 0 < d.args.length ? this._gr('gener', 'new Sk.builtins[\'function\']((function(){var $origargs=Array.prototype.slice.call(arguments);Sk.builtin.pyCheckArgs("', Sk.ffi.remapToJs(b), '",arguments,', d.args.length - f.length, ',', d.args.length, ');return new Sk.builtins[\'generator\'](', a, ',$gbl,$origargs', h, ');}))') : this._gr('gener', 'new Sk.builtins[\'function\']((function(){Sk.builtin.pyCheckArgs("', Sk.ffi.remapToJs(b), '",arguments,0,0);return new Sk.builtins[\'generator\'](', a, ',$gbl,[]', h, ');}))') : this._gr('funcobj', 'new Sk.builtins[\'function\'](', a, ',$gbl', h, ')');
  };
  Compiler.prototype.cfunction = function (a) {
    goog.asserts.assert(a instanceof FunctionDef);
    var b = this.buildcodeobj(a, a.name, a.decorator_list, a.args, function (b) {
        this.vseqstmt(a.body);
        out('return Sk.builtin.none.none$;');
      });
    this.nameop(a.name, Store, b);
  };
  Compiler.prototype.clambda = function (a) {
    goog.asserts.assert(a instanceof Lambda);
    return this.buildcodeobj(a, Sk.builtin.stringToPy('<lambda>'), null, a.args, function (b) {
      b = this.vexpr(a.body);
      out('return ', b, ';');
    });
  };
  Compiler.prototype.cifexp = function (a) {
    var b = this.newBlock('next of ifexp'), c = this.newBlock('end of ifexp'), d = this._gr('res', 'null'), e = this.vexpr(a.test);
    this._jumpfalse(e, b);
    out(d, '=', this.vexpr(a.body), ';');
    this._jump(c);
    this.setBlock(b);
    out(d, '=', this.vexpr(a.orelse), ';');
    this._jump(c);
    this.setBlock(c);
    return d;
  };
  Compiler.prototype.cgenexpgen = function (a, b, c) {
    var d = this.newBlock('start for ' + b), e = this.newBlock('skip for ' + b);
    this.newBlock('if cleanup for ' + b);
    var f = this.newBlock('end for ' + b), g = a[b], h;
    if (0 === b)
      h = '$loc.$iter0';
    else {
      var l = this.vexpr(g.iter);
      h = '$loc.' + this.gensym('iter');
      out(h, '=', 'Sk.abstr.iter(', l, ');');
    }
    this._jump(d);
    this.setBlock(d);
    h = this._gr('next', 'Sk.abstr.iternext(', h, ')');
    this._jumpundef(h, f);
    this.vexpr(g.target, h);
    h = g.ifs.length;
    for (l = 0; l < h; ++l) {
      var k = this.vexpr(g.ifs[l]);
      this._jumpfalse(k, d);
    }
    ++b < a.length && this.cgenexpgen(a, b, c);
    b >= a.length && (a = this.vexpr(c), out('return [', e, '/*resume*/,', a, '/*ret*/];'), this.setBlock(e));
    this._jump(d);
    this.setBlock(f);
    1 === b && out('return null;');
  };
  Compiler.prototype.cgenexp = function (a) {
    var b = this.buildcodeobj(a, Sk.builtin.stringToPy('<genexpr>'), null, null, function (b) {
        this.cgenexpgen(a.generators, 0, a.elt);
      }), b = this._gr('gener', 'Sk.misceval.callsim(', b, ');');
    out(b, '.gi$locals.$iter0=Sk.abstr.iter(', this.vexpr(a.generators[0].iter), ');');
    return b;
  };
  Compiler.prototype.cclass = function (a) {
    goog.asserts.assert(a instanceof ClassDef);
    var b = this.vseqexpr(a.bases), c = this.enterScope(a.name, a, a.lineno), d = this.newBlock('class entry');
    this.u.prefixCode = 'var ' + c + '=(function $' + Sk.ffi.remapToJs(a.name) + '$class_outer($globals,$locals,$rest){var $gbl=$globals,$loc=$locals;';
    this.u.switchCode += 'return(function ' + Sk.ffi.remapToJs(a.name) + '(){';
    this.u.switchCode += 'var $blk=' + d + ',$exc=[];while(true){switch($blk){';
    this.u.suffixCode = '}break;}}).apply(null,$rest);});';
    this.u.private_ = a.name;
    this.cbody(a.body);
    out('break;');
    this.exitScope();
    b = this._gr('built', 'Sk.misceval.buildClass($gbl,', c, ',', Sk.ffi.remapToJs(a.name.tp$repr()), ',[', b, '])');
    this.nameop(a.name, Store, b);
  };
  Compiler.prototype.ccontinue = function (a) {
    if (0 === this.u.continueBlocks.length)
      throw new SyntaxError('\'continue\' outside loop');
    this._jump(this.u.continueBlocks[this.u.continueBlocks.length - 1]);
  };
  Compiler.prototype.vstmt = function (a) {
    this.u.lineno = a.lineno;
    this.u.linenoSet = !1;
    this.annotateSource(a);
    switch (a.constructor) {
    case FunctionDef:
      this.cfunction(a);
      break;
    case ClassDef:
      this.cclass(a);
      break;
    case Return_:
      if (this.u.ste.blockType !== FunctionBlock)
        throw new SyntaxError('\'return\' outside function');
      a.value ? out('return ', this.vexpr(a.value), ';') : out('return null;');
      break;
    case Delete_:
      this.vseqexpr(a.targets);
      break;
    case Assign:
      for (var b = a.targets.length, c = this.vexpr(a.value), d = 0; d < b; ++d)
        this.vexpr(a.targets[d], c);
      break;
    case AugAssign:
      return this.caugassign(a);
    case Print:
      this.cprint(a);
      break;
    case For_:
      return this.cfor(a);
    case While_:
      return this.cwhile(a);
    case If_:
      return this.cif(a);
    case Raise:
      return this.craise(a);
    case TryExcept:
      return this.ctryexcept(a);
    case TryFinally:
      return this.ctryfinally(a);
    case Assert:
      return this.cassert(a);
    case Import_:
      return this.cimport(a);
    case ImportFrom:
      return this.cfromimport(a);
    case Global:
      break;
    case Expr:
      this.vexpr(a.value);
      break;
    case Pass:
      break;
    case Break_:
      if (0 === this.u.breakBlocks.length)
        throw new SyntaxError('\'break\' outside loop');
      this._jump(this.u.breakBlocks[this.u.breakBlocks.length - 1]);
      break;
    case Continue_:
      this.ccontinue(a);
      break;
    default:
      goog.asserts.fail('unhandled case in vstmt');
    }
  };
  Compiler.prototype.vseqstmt = function (a) {
    for (var b = 0; b < a.length; ++b)
      this.vstmt(a[b]);
  };
  var OP_FAST = 0, OP_GLOBAL = 1, OP_DEREF = 2, OP_NAME = 3, D_NAMES = 0, D_FREEVARS = 1, D_CELLVARS = 2;
  Compiler.prototype.isCell = function (a) {
    a = Sk.ffi.remapToJs(mangleName(this.u.private_, a));
    return this.u.ste.getScope(a) === CELL ? !0 : !1;
  };
  Compiler.prototype.nameop = function (a, b, c) {
    if ((b === Store || b === AugStore || b === Del) && '__debug__' === Sk.ffi.remapToJs(a))
      throw new Sk.builtin.SyntaxError('can not assign to __debug__');
    if ((b === Store || b === AugStore || b === Del) && 'None' === Sk.ffi.remapToJs(a))
      throw new Sk.builtin.SyntaxError('can not assign to None');
    if ('None' === Sk.ffi.remapToJs(a))
      return 'Sk.builtin.none.none$';
    if ('True' === Sk.ffi.remapToJs(a))
      return 'Sk.ffi.bool.True';
    if ('False' === Sk.ffi.remapToJs(a))
      return 'Sk.ffi.bool.False';
    var d = Sk.ffi.remapToJs(mangleName(this.u.private_, a)), d = fixReservedNames(d), e = OP_NAME, f = this.u.ste.getScope(d), g = null;
    switch (f) {
    case FREE:
      g = '$free';
      e = OP_DEREF;
      break;
    case CELL:
      g = '$cell';
      e = OP_DEREF;
      break;
    case LOCAL:
      this.u.ste.blockType !== FunctionBlock || this.u.ste.generator || (e = OP_FAST);
      break;
    case GLOBAL_IMPLICIT:
      this.u.ste.blockType === FunctionBlock && (e = OP_GLOBAL);
      break;
    case GLOBAL_EXPLICIT:
      e = OP_GLOBAL;
    }
    d = fixReservedWords(d);
    goog.asserts.assert(f || '_' === Sk.ffi.remapToJs(a).charAt(1));
    a = d;
    this.u.ste.generator || this.u.ste.blockType !== FunctionBlock ? d = '$loc.' + d : e !== OP_FAST && e !== OP_NAME || this.u.localnames.push(d);
    switch (e) {
    case OP_FAST:
      switch (b) {
      case Load:
      case Param:
        return out('if (', d, ' === undefined) { throw new Error(\'local variable \\\'', d, '\\\' referenced before assignment\'); }\n'), d;
      case Store:
        out(d, '=', c, ';');
        break;
      case Del:
        out('delete ', d, ';');
        break;
      default:
        goog.asserts.fail('unhandled');
      }
      break;
    case OP_NAME:
      switch (b) {
      case Load:
        return b = this.gensym('loadname'), out('var ', b, '=', d, '!==undefined?', d, ':Sk.misceval.loadname(\'', a, '\',$gbl);'), b;
      case Store:
        out(d, '=', c, ';');
        break;
      case Del:
        out('delete ', d, ';');
        break;
      case Param:
        return d;
      default:
        goog.asserts.fail('unhandled');
      }
      break;
    case OP_GLOBAL:
      switch (b) {
      case Load:
        return this._gr('loadgbl', 'Sk.misceval.loadname(\'', a, '\',$gbl)');
      case Store:
        out('$gbl.', a, '=', c, ';');
        break;
      case Del:
        out('delete $gbl.', a);
        break;
      default:
        goog.asserts.fail('unhandled case in name op_global');
      }
      break;
    case OP_DEREF:
      switch (b) {
      case Load:
        return g + '.' + a;
      case Store:
        out(g, '.', a, '=', c, ';');
        break;
      case Param:
        return a;
      default:
        goog.asserts.fail('unhandled case in name op_deref');
      }
      break;
    default:
      goog.asserts.fail('unhandled case');
    }
  };
  Compiler.prototype.enterScope = function (a, b, c) {
    var d = new CompilerUnit();
    d.ste = this.st.getStsForAst(b);
    d.name = a;
    d.firstlineno = c;
    this.u && this.u.private_ && (d.private_ = this.u.private_);
    this.stack.push(this.u);
    this.allUnits.push(d);
    a = this.gensym('scope');
    d.scopename = a;
    this.u = d;
    this.u.activateScope();
    this.nestlevel++;
    return a;
  };
  Compiler.prototype.exitScope = function () {
    var a = this.u;
    this.nestlevel--;
    (this.u = 0 <= this.stack.length - 1 ? this.stack.pop() : null) && this.u.activateScope();
    if ('<module>' !== Sk.ffi.remapToJs(a.name)) {
      var b = Sk.ffi.remapToJs(a.name.tp$repr()), b = b.substring(1, b.length - 1), b = fixReservedWords(b), b = fixReservedNames(b);
      out(a.scopename, '.co_name=Sk.builtin.stringToPy(\'', b, '\');');
    }
  };
  Compiler.prototype.cbody = function (a) {
    for (var b = 0; b < a.length; ++b)
      this.vstmt(a[b]);
  };
  Compiler.prototype.cprint = function (a) {
    goog.asserts.assert(a instanceof Print);
    a.dest && this.vexpr(a.dest);
    for (var b = a.values.length, c = 0; c < b; ++c)
      out('Sk.misceval.print_(', 'Sk.ffi.remapToJs(new Sk.builtins[\'str\'](', this.vexpr(a.values[c]), ')));');
    a.nl && out('Sk.misceval.print_(', '"\\n");');
  };
  Compiler.prototype.cmod = function (a) {
    var b = this.enterScope(Sk.builtin.stringToPy('<module>'), a, 0), c = this.newBlock('module entry');
    this.u.prefixCode = 'var ' + b + '=(function($modname){';
    this.u.varDeclsCode = 'var $blk=' + c + ',$exc=[],$gbl={},$loc=$gbl,$err=undefined;$gbl.__name__=$modname;Sk.globals=$gbl;';
    this.u.switchCode = 'try { while(true){try{ switch($blk){';
    this.u.suffixCode = '} }catch(err){if ($exc.length>0) { $err = err; $blk=$exc.pop(); continue; } else { throw err; }} } }catch(err){ if (err instanceof Sk.builtin.SystemExit && !Sk.throwSystemExit) { Sk.misceval.print_(err.toString() + \'\\n\'); return $loc; } else { throw err; } } });';
    switch (a.constructor) {
    case Module:
      this.cbody(a.body);
      out('return $loc;');
      break;
    default:
      goog.asserts.fail('todo; unhandled case in compilerMod');
    }
    this.exitScope();
    this.result.push(this.outputAllUnits());
    return b;
  };
  Sk.compile = function (a, b, c) {
    c = Sk.parse(b, a);
    c = Sk.astFromParse(c, b);
    var d = Sk.symboltable(c, b);
    a = new Compiler(b, d, 0, a);
    return {
      funcname: a.cmod(c),
      code: a.result.join('')
    };
  };
  goog.exportSymbol('Sk.compile', Sk.compile);
  Sk.resetCompiler = function () {
    Sk.gensymcount = 0;
  };
  goog.exportSymbol('Sk.resetCompiler', Sk.resetCompiler);
  Sk.sysmodules = new Sk.builtin.dict([]);
  Sk.realsyspath = void 0;
  Sk.importSearchPathForName = function (a, b, c) {
    for (var d = (Sk.realsyspath ? Sk.realsyspath : new Sk.builtin.list([])).tp$iter(), e = d.tp$iternext(); void 0 !== e; e = d.tp$iternext())
      for (var f = a.replace(/\./g, '/'), e = [
            e.v + '/' + f + b,
            e.v + '/' + f + '/__init__' + b
          ], f = 0; f < e.length; ++f) {
        var g = e[f];
        try {
          return Sk.read(g), g;
        } catch (h) {
        }
      }
    if (!c)
      throw new Sk.builtin.ImportError('No module named ' + a);
  };
  Sk.doOneTimeInitialization = function () {
    Sk.builtin.type.basesStr_ = Sk.builtin.stringToPy('__bases__');
    Sk.builtin.type.mroStr_ = Sk.builtin.stringToPy('__mro__');
    Sk.builtin.object.$d = new Sk.builtin.dict([]);
    Sk.builtin.object.$d.mp$ass_subscript(Sk.builtin.type.basesStr_, new Sk.builtin.tuple([]));
    Sk.builtin.object.$d.mp$ass_subscript(Sk.builtin.type.mroStr_, new Sk.builtin.tuple([Sk.builtin.object]));
  };
  Sk.importSetUpPath = function () {
    if (!Sk.realsyspath) {
      for (var a = [
            Sk.builtin.stringToPy('src/builtin'),
            Sk.builtin.stringToPy('src/lib'),
            Sk.builtin.stringToPy('.')
          ], b = 0; b < Sk.syspath.length; ++b)
        a.push(Sk.builtin.stringToPy(Sk.syspath[b]));
      Sk.realsyspath = new Sk.builtin.list(a);
      Sk.doOneTimeInitialization();
    }
  };
  if (COMPILED)
    var js_beautify = function (a) {
      return a;
    };
  Sk.importModuleInternalFromBody_ = function (a, b, c, d) {
    Sk.importSetUpPath();
    c = 'string' === typeof c ? c : a;
    var e = c.split('.');
    if (1 < e.length)
      try {
        return Sk.sysmodules.mp$subscript(e[0]);
      } catch (f) {
        var g = e.slice(0, e.length - 1).join('.'), h = Sk.importModuleInternalNoBody_(g, b, void 0), l = new Sk.builtin.module();
        Sk.sysmodules.mp$ass_subscript(a, l);
        a = Sk.compile(d, a + '.py', 'exec');
        Sk.evaluateModule(l, a, b, c);
        Sk.storeModuleInParent(l, g, e);
        return h;
      }
    else
      try {
        return Sk.sysmodules.mp$subscript(c);
      } catch (k) {
        return e = new Sk.builtin.module(), Sk.sysmodules.mp$ass_subscript(a, e), a = Sk.compile(d, a + '.py', 'exec'), Sk.evaluateModule(e, a, b, c), e;
      }
  };
  Sk.importModuleInternalNoBody_ = function (a, b, c) {
    goog.asserts.assertString(a, 'name must be a string, e.g. \'<stdin>\'');
    goog.asserts.assertBoolean(b, 'dumpJS must be a boolean');
    Sk.importSetUpPath();
    c = 'string' === typeof c ? c : a;
    var d = c.split('.');
    if (1 < d.length)
      try {
        return Sk.sysmodules.mp$subscript(d[0]);
      } catch (e) {
        var f = d.slice(0, d.length - 1).join('.'), g = Sk.importModuleInternalNoBody_(f, b, void 0), h = new Sk.builtin.module();
        Sk.sysmodules.mp$ass_subscript(a, h);
        var l = Sk.importSearchPathForName(a, '.js', !0);
        l ? a = {
          funcname: '$builtinmodule',
          code: Sk.read(l)
        } : (l = Sk.importSearchPathForName(a, '.py', !1), a = Sk.compile(Sk.read(l), l, 'exec'));
        Sk.evaluateModule(h, a, b, c);
        Sk.storeModuleInParent(h, f, d);
        return g;
      }
    else
      try {
        return Sk.sysmodules.mp$subscript(c);
      } catch (k) {
        return d = new Sk.builtin.module(), Sk.sysmodules.mp$ass_subscript(a, d), (l = Sk.importSearchPathForName(a, '.js', !0)) ? a = {
          funcname: '$builtinmodule',
          code: Sk.read(l)
        } : (l = Sk.importSearchPathForName(a, '.py', !1), a = Sk.compile(Sk.read(l), l, 'exec')), Sk.evaluateModule(d, a, b, c), d;
      }
  };
  Sk.evaluateModule = function (a, b, c, d) {
    var e = a.$js = b.code;
    null != Sk.dateSet && Sk.dateSet || (e = 'Sk.execStart = new Date();\n' + b.code, Sk.dateSet = !0);
    if (c) {
      c = js_beautify(b.code).split('\n');
      for (e = 1; e <= c.length; ++e) {
        for (var f = '', g = ('' + e).length; 5 > g; ++g)
          f += ' ';
        c[e - 1] = '/* ' + f + e + ' */ ' + c[e - 1];
      }
      e = c.join('\n');
      Sk.debugout(e);
    }
    e += '\n' + b.funcname + '(' + ('Sk.builtin.stringToPy(\'' + d + '\')') + ');';
    b = goog.global.eval(e);
    b.__name__ || (b.__name__ = Sk.builtin.stringToPy(d));
    a.$d = b;
  };
  Sk.storeModuleInParent = function (a, b, c) {
    Sk.sysmodules.mp$subscript(b).tp$setattr(c[c.length - 1], a);
  };
  Sk.importModule = function (a, b) {
    goog.asserts.assertString(a, 'name must be a string, e.g. \'<stdin>\'');
    goog.asserts.assertBoolean(b, 'dumpJS must be a boolean');
    return Sk.importModuleInternalNoBody_(a, b, void 0);
  };
  Sk.importMain = function (a, b) {
    goog.asserts.assertString(a, 'name must be a string, e.g. \'<stdin>\'');
    Sk.dateSet = !1;
    Sk.filesLoaded = !1;
    Sk.sysmodules = new Sk.builtin.dict([]);
    Sk.realsyspath = void 0;
    Sk.resetCompiler();
    return Sk.importModuleInternalNoBody_(a, 'boolean' === typeof b ? b : !1, '__main__');
  };
  goog.exportSymbol('Sk.importMain', Sk.importMain);
  Sk.importMainWithBody = function (a, b, c) {
    goog.asserts.assertString(a, 'name must be a string, e.g. \'<stdin>\'');
    goog.asserts.assertBoolean(b, 'dumpJS must be a boolean');
    goog.asserts.assertString(c, 'body must be a string');
    Sk.dateSet = !1;
    Sk.filesLoaded = !1;
    Sk.sysmodules = new Sk.builtin.dict([]);
    Sk.realsyspath = void 0;
    Sk.resetCompiler();
    return Sk.importModuleInternalFromBody_(a, b, '__main__', c);
  };
  goog.exportSymbol('Sk.importMainWithBody', Sk.importMainWithBody);
  Sk.builtin.__import__ = function (a, b, c, d) {
    b = Sk.importModuleInternalNoBody_(a, !1, void 0);
    return d && 0 !== d.length ? (a = Sk.sysmodules.mp$subscript(a), goog.asserts.assert(a), a) : b;
  };
  goog.exportSymbol('Sk.builtin.__import__', Sk.builtin.__import__);
  Sk.importStar = function (a, b) {
    var c = Object.getOwnPropertyNames(a.$d), d;
    for (d in c)
      b[c[d]] = a.$d[c[d]];
  };
  goog.exportSymbol('Sk.importStar', Sk.importStar);
  Sk.builtin.timSort = function (a, b) {
    this.list = new Sk.builtin.list(a.v);
    this.MIN_GALLOP = 7;
    this.listlength = b ? b : a.sq$length();
  };
  Sk.builtin.timSort.prototype.lt = function (a, b) {
    return Sk.misceval.richCompareBool(a, b, Sk.misceval.compareOp.Lt);
  };
  Sk.builtin.timSort.prototype.le = function (a, b) {
    return !this.lt(b, a);
  };
  Sk.builtin.timSort.prototype.setitem = function (a, b) {
    this.list.v[a] = b;
  };
  Sk.builtin.timSort.prototype.binary_sort = function (a, b) {
    for (var c = a.base + b; c < a.base + a.len; c++) {
      for (var d = a.base, e = c, f = a.getitem(e); d < e;) {
        var g = d + (e - d >> 1);
        this.lt(f, a.getitem(g)) ? e = g : d = g + 1;
      }
      goog.asserts.assert(d === e);
      for (g = c; g > d; g--)
        a.setitem(g, a.getitem(g - 1));
      a.setitem(d, f);
    }
  };
  Sk.builtin.timSort.prototype.count_run = function (a) {
    var b;
    if (1 >= a.len) {
      var c = a.len;
      b = !1;
    } else if (c = 2, this.lt(a.getitem(a.base + 1), a.getitem(a.base))) {
      b = !0;
      for (var d = a.base + 2; d < a.base + a.len; d++)
        if (this.lt(a.getitem(d), a.getitem(d - 1)))
          c++;
        else
          break;
    } else
      for (b = !1, d = a.base + 2; d < a.base + a.len && !this.lt(a.getitem(d), a.getitem(d - 1)); d++)
        c++;
    return {
      run: new Sk.builtin.listSlice(a.list, a.base, c),
      descending: b
    };
  };
  Sk.builtin.timSort.prototype.sort = function () {
    var a = new Sk.builtin.listSlice(this.list, 0, this.listlength);
    if (!(2 > a.len)) {
      this.merge_init();
      for (var b = this.merge_compute_minrun(a.len); 0 < a.len;) {
        var c = this.count_run(a);
        c.descending && c.run.reverse();
        if (c.run.len < b) {
          var d = c.run.len;
          c.run.len = b < a.len ? b : a.len;
          this.binary_sort(c.run, d);
        }
        a.advance(c.run.len);
        this.pending.push(c.run);
        this.merge_collapse();
      }
      goog.asserts.assert(a.base == this.listlength);
      this.merge_force_collapse();
      goog.asserts.assert(1 == this.pending.length);
      goog.asserts.assert(0 == this.pending[0].base);
      goog.asserts.assert(this.pending[0].len == this.listlength);
    }
  };
  Sk.builtin.timSort.prototype.gallop = function (a, b, c, d) {
    goog.asserts.assert(0 <= c && c < b.len);
    var e = this;
    d = d ? function (a, b) {
      return e.le(a, b);
    } : function (a, b) {
      return e.lt(a, b);
    };
    var f = b.base + c, g = 0, h = 1, l;
    if (d(b.getitem(f), a)) {
      for (l = b.len - c; h < l;)
        if (d(b.getitem(f + h), a)) {
          g = h;
          try {
            h = (h << 1) + 1;
          } catch (k) {
            h = l;
          }
        } else
          break;
      h > l && (h = l);
      g += c;
      h += c;
    } else {
      for (l = c + 1; h < l && !d(b.getitem(f - h), a);) {
        g = h;
        try {
          h = (h << 1) + 1;
        } catch (m) {
          h = l;
        }
      }
      h > l && (h = l);
      f = c - g;
      g = c - h;
      h = f;
    }
    goog.asserts.assert(-1 <= g < h <= b.len);
    for (g += 1; g < h;)
      c = g + (h - g >> 1), d(b.getitem(b.base + c), a) ? g = c + 1 : h = c;
    goog.asserts.assert(g == h);
    return h;
  };
  Sk.builtin.timSort.prototype.merge_init = function () {
    this.min_gallop = this.MIN_GALLOP;
    this.pending = [];
  };
  Sk.builtin.timSort.prototype.merge_lo = function (a, b) {
    goog.asserts.assert(0 < a.len && 0 < b.len && a.base + a.len == b.base);
    var c = this.min_gallop, d = a.base;
    a = a.copyitems();
    try {
      if (this.setitem(d, b.popleft()), d++, 1 != a.len && 0 != b.len)
        for (var e, f;;) {
          for (f = e = 0;;)
            if (this.lt(b.getitem(b.base), a.getitem(a.base))) {
              this.setitem(d, b.popleft());
              d++;
              if (0 == b.len)
                return;
              f++;
              e = 0;
              if (f >= c)
                break;
            } else {
              this.setitem(d, a.popleft());
              d++;
              if (1 == a.len)
                return;
              e++;
              f = 0;
              if (e >= c)
                break;
            }
          for (c += 1;;) {
            this.min_gallop = c -= 1 < c;
            e = this.gallop(b.getitem(b.base), a, 0, !0);
            for (var g = a.base; g < a.base + e; g++)
              this.setitem(d, a.getitem(g)), d++;
            a.advance(e);
            if (1 >= a.len)
              return;
            this.setitem(d, b.popleft());
            d++;
            if (0 == b.len)
              return;
            f = this.gallop(a.getitem(a.base), b, 0, !1);
            for (g = b.base; g < b.base + f; g++)
              this.setitem(d, b.getitem(g)), d++;
            b.advance(f);
            if (0 == b.len)
              return;
            this.setitem(d, a.popleft());
            d++;
            if (1 == a.len)
              return;
            if (e < this.MIN_GALLOP && f < this.MIN_GALLOP)
              break;
            c++;
            this.min_gallop = c;
          }
        }
    } finally {
      goog.asserts.assert(0 <= a.len && 0 <= b.len);
      for (g = b.base; g < b.base + b.len; g++)
        this.setitem(d, b.getitem(g)), d++;
      for (g = a.base; g < a.base + a.len; g++)
        this.setitem(d, a.getitem(g)), d++;
    }
  };
  Sk.builtin.timSort.prototype.merge_hi = function (a, b) {
    goog.asserts.assert(0 < a.len && 0 < b.len && a.base + a.len == b.base);
    var c = this.min_gallop, d = b.base + b.len;
    b = b.copyitems();
    try {
      if (d--, this.setitem(d, a.popright()), 0 != a.len && 1 != b.len)
        for (var e, f, g, h;;) {
          for (f = e = 0;;)
            if (g = a.getitem(a.base + a.len - 1), h = b.getitem(b.base + b.len - 1), this.lt(h, g)) {
              d--;
              this.setitem(d, g);
              a.len--;
              if (0 == a.len)
                return;
              e++;
              f = 0;
              if (e >= c)
                break;
            } else {
              d--;
              this.setitem(d, h);
              b.len--;
              if (1 == b.len)
                return;
              f++;
              e = 0;
              if (f >= c)
                break;
            }
          for (c += 1;;) {
            this.min_gallop = c -= 1 < c;
            h = b.getitem(b.base + b.len - 1);
            var l = this.gallop(h, a, a.len - 1, !0);
            e = a.len - l;
            for (var k = a.base + a.len - 1; k > a.base + l - 1; k--)
              d--, this.setitem(d, a.getitem(k));
            a.len -= e;
            if (0 == a.len)
              return;
            d--;
            this.setitem(d, b.popright());
            if (1 == b.len)
              return;
            g = a.getitem(a.base + a.len - 1);
            l = this.gallop(g, b, b.len - 1, !1);
            f = b.len - l;
            for (k = b.base + b.len - 1; k > b.base + l - 1; k--)
              d--, this.setitem(d, b.getitem(k));
            b.len -= f;
            if (1 >= b.len)
              return;
            d--;
            this.setitem(d, a.popright());
            if (0 == a.len)
              return;
            if (e < this.MIN_GALLOP && f < this.MIN_GALLOP)
              break;
            c++;
            this.min_gallop = c;
          }
        }
    } finally {
      goog.asserts.assert(0 <= a.len && 0 <= b.len);
      for (k = a.base + a.len - 1; k > a.base - 1; k--)
        d--, this.setitem(d, a.getitem(k));
      for (k = b.base + b.len - 1; k > b.base - 1; k--)
        d--, this.setitem(d, b.getitem(k));
    }
  };
  Sk.builtin.timSort.prototype.merge_at = function (a) {
    0 > a && (a = this.pending.length + a);
    var b = this.pending[a], c = this.pending[a + 1];
    goog.asserts.assert(0 < b.len && 0 < c.len);
    goog.asserts.assert(b.base + b.len == c.base);
    this.pending[a] = new Sk.builtin.listSlice(this.list, b.base, b.len + c.len);
    this.pending.splice(a + 1, 1);
    a = this.gallop(c.getitem(c.base), b, 0, !0);
    b.advance(a);
    0 != b.len && (c.len = this.gallop(b.getitem(b.base + b.len - 1), c, c.len - 1, !1), 0 != c.len && (b.len <= c.len ? this.merge_lo(b, c) : this.merge_hi(b, c)));
  };
  Sk.builtin.timSort.prototype.merge_collapse = function () {
    for (var a = this.pending; 1 < a.length;)
      if (3 <= a.length && a[a.length - 3].len <= a[a.length - 2].len + a[a.length - 1].len)
        a[a.length - 3].len < a[a.length - 1].len ? this.merge_at(-3) : this.merge_at(-2);
      else if (a[a.length - 2].len <= a[a.length - 1].len)
        this.merge_at(-2);
      else
        break;
  };
  Sk.builtin.timSort.prototype.merge_force_collapse = function () {
    for (var a = this.pending; 1 < a.length;)
      3 <= a.length && a[a.length - 3].len < a[a.length - 1].len ? this.merge_at(-3) : this.merge_at(-2);
  };
  Sk.builtin.timSort.prototype.merge_compute_minrun = function (a) {
    for (var b = 0; 64 <= a;)
      b |= a & 1, a >>= 1;
    return a + b;
  };
  Sk.builtin.listSlice = function (a, b, c) {
    this.list = a;
    this.base = b;
    this.len = c;
  };
  Sk.builtin.listSlice.prototype.copyitems = function () {
    var a = this.base, b = this.base + this.len;
    goog.asserts.assert(0 <= a <= b);
    return new Sk.builtin.listSlice(new Sk.builtin.list(this.list.v.slice(a, b)), 0, this.len);
  };
  Sk.builtin.listSlice.prototype.advance = function (a) {
    this.base += a;
    this.len -= a;
    goog.asserts.assert(this.base <= this.list.sq$length());
  };
  Sk.builtin.listSlice.prototype.getitem = function (a) {
    return this.list.v[a];
  };
  Sk.builtin.listSlice.prototype.setitem = function (a, b) {
    this.list.v[a] = b;
  };
  Sk.builtin.listSlice.prototype.popleft = function () {
    var a = this.list.v[this.base];
    this.base++;
    this.len--;
    return a;
  };
  Sk.builtin.listSlice.prototype.popright = function () {
    this.len--;
    return this.list.v[this.base + this.len];
  };
  Sk.builtin.listSlice.prototype.reverse = function () {
    for (var a = this.list, b = this.base, c = b + this.len - 1; b < c;) {
      var d = a.v[b];
      a.v[b] = a.v[c];
      a.v[c] = d;
      b++;
      c--;
    }
  };
  goog.exportSymbol('Sk.builtin.listSlice', Sk.builtin.listSlice);
  goog.exportSymbol('Sk.builtin.timSort', Sk.builtin.timSort);
  Sk.builtins = {
    range: Sk.builtin.range,
    round: Sk.builtin.round,
    len: Sk.builtin.len,
    min: Sk.builtin.min,
    max: Sk.builtin.max,
    sum: Sk.builtin.sum,
    zip: Sk.builtin.zip,
    abs: Sk.builtin.abs,
    fabs: Sk.builtin.abs,
    ord: Sk.builtin.ord,
    chr: Sk.builtin.chr,
    hex: Sk.builtin.hex,
    oct: Sk.builtin.oct,
    bin: Sk.builtin.bin,
    dir: Sk.builtin.dir,
    repr: Sk.builtin.repr,
    open: Sk.builtin.open,
    isinstance: Sk.builtin.isinstance,
    hash: Sk.builtin.hash,
    getattr: Sk.builtin.getattr,
    float_$rw$: Sk.builtin.float_,
    int_$rw$: Sk.builtin.int_,
    hasattr: Sk.builtin.hasattr,
    map: Sk.builtin.map,
    filter: Sk.builtin.filter,
    reduce: Sk.builtin.reduce,
    sorted: Sk.builtin.sorted,
    bool: Sk.builtin.bool,
    any: Sk.builtin.any,
    all: Sk.builtin.all,
    enumerate: Sk.builtin.enumerate,
    AttributeError: Sk.builtin.AttributeError,
    ValueError: Sk.builtin.ValueError,
    Exception: Sk.builtin.Exception,
    ZeroDivisionError: Sk.builtin.ZeroDivisionError,
    AssertionError: Sk.builtin.AssertionError,
    ImportError: Sk.builtin.ImportError,
    IndentationError: Sk.builtin.IndentationError,
    IndexError: Sk.builtin.IndexError,
    KeyError: Sk.builtin.KeyError,
    TypeError: Sk.builtin.TypeError,
    NameError: Sk.builtin.NameError,
    IOError: Sk.builtin.IOError,
    NotImplementedError: Sk.builtin.NotImplementedError,
    SystemExit: Sk.builtin.SystemExit,
    OverflowError: Sk.builtin.OverflowError,
    OperationError: Sk.builtin.OperationError,
    dict: Sk.builtin.dict,
    file: Sk.builtin.file,
    'function': Sk.builtin.func,
    generator: Sk.builtin.generator,
    list: Sk.builtin.list,
    long_$rw$: Sk.builtin.lng,
    method: Sk.builtin.method,
    object: Sk.builtin.object,
    slice: Sk.builtin.slice,
    str: Sk.builtin.StringPy,
    set: Sk.builtin.set,
    tuple: Sk.builtin.tuple,
    type: Sk.builtin.type,
    input: Sk.builtin.input,
    raw_input: Sk.builtin.raw_input,
    jseval: Sk.builtin.jseval,
    jsmillis: Sk.builtin.jsmillis,
    quit: Sk.builtin.quit,
    exit: Sk.builtin.quit,
    bytearray: Sk.builtin.bytearray,
    callable: Sk.builtin.callable,
    complex: Sk.builtin.complex,
    delattr: Sk.builtin.delattr,
    divmod: Sk.builtin.divmod,
    eval_$rn$: Sk.builtin.eval_,
    execfile: Sk.builtin.execfile,
    format: Sk.builtin.format,
    frozenset: Sk.builtin.frozenset,
    globals: Sk.builtin.globals,
    help: Sk.builtin.help,
    issubclass: Sk.builtin.issubclass,
    iter: Sk.builtin.iter,
    locals: Sk.builtin.locals,
    memoryview: Sk.builtin.memoryview,
    next: Sk.builtin.next_,
    pow: Sk.builtin.pow,
    property: Sk.builtin.property,
    reload: Sk.builtin.reload,
    reversed: Sk.builtin.reversed,
    'super': Sk.builtin.superbi,
    unichr: Sk.builtin.unichr,
    vars: Sk.builtin.vars,
    xrange: Sk.builtin.xrange,
    apply_$rn$: Sk.builtin.apply_,
    buffer: Sk.builtin.buffer,
    coerce: Sk.builtin.coerce,
    intern: Sk.builtin.intern
  };
  goog.exportSymbol('Sk.builtins', Sk.builtins);
  Sk.stdlib = Sk.stdlib || {};
  Sk.stdlib.direction = function (a, b, c) {
    return a ? 0 : b ? 1 : 2;
  };
  goog.exportSymbol('Sk.stdlib.direction', Sk.stdlib.direction);
  Sk.stdlib.orientation = function (a, b, c) {
    return 0 < a ? 1 : 0 > a ? -1 : 0 < b ? 1 : 0 > b ? -1 : 0 < c ? 1 : 0 > c ? -1 : 2;
  };
  goog.exportSymbol('Sk.stdlib.orientation', Sk.stdlib.orientation);
  Sk.math = Sk.math || {};
  Sk.math.PI_TIMES_1_OVER_4 = Math.PI / 4;
  Sk.math.PI_TIMES_2_OVER_4 = Math.PI / 2;
  Sk.math.PI_TIMES_3_OVER_4 = 3 * Math.PI / 4;
  Sk.math.PI_TIMES_4_OVER_4 = Math.PI;
  Sk.math.PI_TIMES_5_OVER_4 = 5 * Math.PI / 4;
  Sk.math.PI_TIMES_6_OVER_4 = 3 * Math.PI / 2;
  Sk.math.PI_TIMES_7_OVER_4 = 7 * Math.PI / 4;
  Sk.math.PI_TIMES_8_OVER_4 = 2 * Math.PI;
  Sk.math.EPSILON = 1e-9;
  Sk.math.isCloseTo = function (a, b, c) {
    return Math.abs(a - b) < c;
  };
  Sk.math.cos = function (a) {
    return Sk.snapToAngle ? Sk.math.isCloseTo(Math.abs(a), 0, Sk.math.EPSILON) ? 1 : Sk.math.isCloseTo(Math.abs(a), Sk.math.PI_TIMES_1_OVER_4, Sk.math.EPSILON) ? +Math.SQRT1_2 : Sk.math.isCloseTo(Math.abs(a), Sk.math.PI_TIMES_2_OVER_4, Sk.math.EPSILON) ? 0 : Sk.math.isCloseTo(Math.abs(a), Sk.math.PI_TIMES_3_OVER_4, Sk.math.EPSILON) ? -Math.SQRT1_2 : Sk.math.isCloseTo(Math.abs(a), Sk.math.PI_TIMES_4_OVER_4, Sk.math.EPSILON) ? -1 : Sk.math.isCloseTo(Math.abs(a), Sk.math.PI_TIMES_5_OVER_4, Sk.math.EPSILON) ? -Math.SQRT1_2 : Sk.math.isCloseTo(Math.abs(a), Sk.math.PI_TIMES_6_OVER_4, Sk.math.EPSILON) ? 0 : Sk.math.isCloseTo(Math.abs(a), Sk.math.PI_TIMES_7_OVER_4, Sk.math.EPSILON) ? +Math.SQRT1_2 : Sk.math.isCloseTo(Math.abs(a), Sk.math.PI_TIMES_8_OVER_4, Sk.math.EPSILON) ? 1 : Math.cos(a) : Math.cos(a);
  };
  Sk.math.sin = function (a) {
    return Sk.snapToAngle ? Sk.math.isCloseTo(a, 0, Sk.math.EPSILON) ? 0 : Sk.math.isCloseTo(a, +Sk.math.PI_TIMES_1_OVER_4, Sk.math.EPSILON) ? Math.SQRT1_2 : Sk.math.isCloseTo(a, +Sk.math.PI_TIMES_2_OVER_4, Sk.math.EPSILON) ? 1 : Sk.math.isCloseTo(a, +Sk.math.PI_TIMES_3_OVER_4, Sk.math.EPSILON) ? Math.SQRT1_2 : Sk.math.isCloseTo(a, +Sk.math.PI_TIMES_4_OVER_4, Sk.math.EPSILON) ? 0 : Sk.math.isCloseTo(a, +Sk.math.PI_TIMES_5_OVER_4, Sk.math.EPSILON) ? -Math.SQRT1_2 : Sk.math.isCloseTo(a, +Sk.math.PI_TIMES_6_OVER_4, Sk.math.EPSILON) ? -1 : Sk.math.isCloseTo(a, +Sk.math.PI_TIMES_7_OVER_4, Sk.math.EPSILON) ? -Math.SQRT1_2 : Sk.math.isCloseTo(a, +Sk.math.PI_TIMES_8_OVER_4, Sk.math.EPSILON) ? 0 : Sk.math.isCloseTo(a, -Sk.math.PI_TIMES_1_OVER_4, Sk.math.EPSILON) ? -Math.SQRT1_2 : Sk.math.isCloseTo(a, -Sk.math.PI_TIMES_2_OVER_4, Sk.math.EPSILON) ? -1 : Sk.math.isCloseTo(a, -Sk.math.PI_TIMES_3_OVER_4, Sk.math.EPSILON) ? -Math.SQRT1_2 : Sk.math.isCloseTo(a, -Sk.math.PI_TIMES_4_OVER_4, Sk.math.EPSILON) ? 0 : Sk.math.isCloseTo(a, -Sk.math.PI_TIMES_5_OVER_4, Sk.math.EPSILON) ? +Math.SQRT1_2 : Sk.math.isCloseTo(a, -Sk.math.PI_TIMES_6_OVER_4, Sk.math.EPSILON) ? 1 : Sk.math.isCloseTo(a, -Sk.math.PI_TIMES_7_OVER_4, Sk.math.EPSILON) ? +Math.SQRT1_2 : Sk.math.isCloseTo(a, -Sk.math.PI_TIMES_8_OVER_4, Sk.math.EPSILON) ? 0 : Math.sin(a) : Math.sin(a);
  };
  Sk.math.tan = function (a) {
    return Sk.snapToAngle ? Sk.math.sin(a) / Sk.math.cos(a) : Math.tan(a);
  };
  (function () {
    Sk.builtin.defineMath = function (a) {
      function b(a, b, e) {
        goog.asserts.assertString(a);
        goog.asserts.assertFunction(b);
        goog.asserts.assertFunction(e);
        return function (f) {
          Sk.ffi.checkFunctionArgs(a, arguments, 1, 1);
          return Sk.ffi.isNum(f) ? Sk.builtin.numberToPy(b(Sk.ffi.remapToJs(f))) : e(f);
        };
      }
      Sk.ffi.checkFunctionArgs('defineMath', arguments, 1, 1);
      a.e = Sk.builtin.numberToPy(Math.E);
      a.pi = Sk.builtin.numberToPy(Math.PI);
      a.sqrt2 = Sk.builtin.numberToPy(Math.SQRT2);
      a.sqrt1_2 = Sk.builtin.numberToPy(Math.SQRT1_2);
      a.tao = Sk.builtin.numberToPy(2 * Math.PI);
      a.cliffordConjugate = Sk.ffi.functionPy(function (a) {
        Sk.ffi.checkFunctionArgs('cliffordConjugate', arguments, 1, 1);
        return Sk.ffi.isNum(a) ? a : Sk.ffh.cliffordConjugate(a);
      });
      a.fabs = Sk.ffi.functionPy(function (a) {
        Sk.ffi.checkFunctionArgs('fabs', arguments, 1, 1);
        Sk.builtin.pyCheckType('x', 'number', Sk.builtin.checkNumber(a));
        return Sk.builtin.numberToPy(Math.abs(Sk.builtin.asnum$(a)));
      });
      a.asin = Sk.ffi.functionPy(function (a) {
        return Sk.ffh.asin(a);
      });
      a.acos = Sk.ffi.functionPy(function (a) {
        return Sk.ffh.acos(a);
      });
      a.atan = Sk.ffi.functionPy(function (a) {
        return Sk.ffh.atan(a);
      });
      a.atan2 = Sk.ffi.functionPy(function (a, b) {
        Sk.ffi.checkFunctionArgs('atan2', arguments, 2, 2);
        Sk.builtin.pyCheckType('y', 'number', Sk.builtin.checkNumber(a));
        Sk.builtin.pyCheckType('x', 'number', Sk.builtin.checkNumber(b));
        return Sk.builtin.numberToPy(Math.atan2(Sk.builtin.asnum$(a), Sk.builtin.asnum$(b)));
      });
      a.exp = Sk.ffi.functionPy(function (a) {
        Sk.ffi.checkFunctionArgs('exp', arguments, 1, 1);
        return Sk.ffi.isNum(a) ? Sk.builtin.numberToPy(Math.exp(Sk.ffi.remapToJs(a))) : Sk.ffh.exp(a);
      });
      a.cos = Sk.ffi.functionPy(b('cos', Sk.math.cos, Sk.ffh.cos));
      a.sin = Sk.ffi.functionPy(b('sin', Sk.math.sin, Sk.ffh.sin));
      a.tan = Sk.ffi.functionPy(b('tan', Sk.math.tan, Sk.ffh.tan));
      a.asinh = Sk.ffi.functionPy(function (a) {
        Sk.ffi.checkFunctionArgs('asinh', arguments, 1, 1);
        Sk.builtin.pyCheckType('x', 'number', Sk.builtin.checkNumber(a));
        a = Sk.builtin.asnum$(a);
        var b = a + Math.sqrt(a * a + 1);
        return Sk.builtin.numberToPy(Math.log(b));
      });
      a.acosh = Sk.ffi.functionPy(function (a) {
        Sk.ffi.checkFunctionArgs('acosh', arguments, 1, 1);
        Sk.builtin.pyCheckType('x', 'number', Sk.builtin.checkNumber(a));
        a = Sk.builtin.asnum$(a);
        var b = a + Math.sqrt(a * a - 1);
        return Sk.builtin.numberToPy(Math.log(b));
      });
      a.atanh = Sk.ffi.functionPy(function (a) {
        Sk.ffi.checkFunctionArgs('atanh', arguments, 1, 1);
        Sk.builtin.pyCheckType('x', 'number', Sk.builtin.checkNumber(a));
        a = Sk.builtin.asnum$(a);
        return Sk.builtin.numberToPy(Math.log((1 + a) / (1 - a)) / 2);
      });
      a.sinh = Sk.ffi.functionPy(function (a) {
        Sk.ffi.checkFunctionArgs('sinh', arguments, 1, 1);
        Sk.builtin.pyCheckType('x', 'number', Sk.builtin.checkNumber(a));
        a = Sk.builtin.asnum$(a);
        var b = Math.pow(Math.E, a);
        return Sk.builtin.numberToPy((b - 1 / b) / 2);
      });
      a.cosh = Sk.ffi.functionPy(function (a) {
        Sk.ffi.checkFunctionArgs('cosh', arguments, 1, 1);
        Sk.builtin.pyCheckType('x', 'number', Sk.builtin.checkNumber(a));
        a = Sk.builtin.asnum$(a);
        var b = Math.pow(Math.E, a);
        return Sk.builtin.numberToPy((b + 1 / b) / 2);
      });
      a.tanh = Sk.ffi.functionPy(function (a) {
        Sk.ffi.checkFunctionArgs('tanh', arguments, 1, 1);
        Sk.builtin.pyCheckType('x', 'number', Sk.builtin.checkNumber(a));
        a = Sk.builtin.asnum$(a);
        var b = Math.pow(Math.E, a), e = 1 / b;
        return Sk.builtin.numberToPy((b - e) / 2 / ((b + e) / 2));
      });
      a.ceil = Sk.ffi.functionPy(function (a) {
        Sk.ffi.checkFunctionArgs('ceil', arguments, 1, 1);
        Sk.builtin.pyCheckType('x', 'number', Sk.builtin.checkNumber(a));
        return Sk.builtin.numberToPy(Math.ceil(Sk.builtin.asnum$(a)));
      });
      a.floor = Sk.ffi.functionPy(function (a) {
        Sk.ffi.checkFunctionArgs('floor', arguments, 1, 1);
        Sk.builtin.pyCheckType('x', 'number', Sk.builtin.checkNumber(a));
        return Sk.builtin.numberToPy(Math.floor(Sk.builtin.asnum$(a)));
      });
      a.sqrt = Sk.ffi.functionPy(function (a) {
        Sk.ffi.checkFunctionArgs('sqrt', arguments, 1, 1);
        return Sk.ffi.isNum(a) ? Sk.builtin.numberToPy(Math.sqrt(Sk.ffi.remapToJs(a))) : Sk.ffh.sqrt(a);
      });
      a.trunc = Sk.ffi.functionPy(function (a) {
        Sk.ffi.checkFunctionArgs('trunc', arguments, 1, 1);
        Sk.builtin.pyCheckType('x', 'number', Sk.builtin.checkNumber(a));
        return Sk.builtin.numberToPy(Sk.builtin.asnum$(a) | 0);
      });
      a.log = Sk.ffi.functionPy(function (a, b) {
        Sk.ffi.checkFunctionArgs('log', arguments, 1, 2);
        Sk.builtin.pyCheckType('x', 'number', Sk.builtin.checkNumber(a));
        if (void 0 === b)
          return Sk.builtin.numberToPy(Math.log(Sk.builtin.asnum$(a)));
        Sk.builtin.pyCheckType('base', 'number', Sk.builtin.checkNumber(b));
        var e = Math.log(Sk.builtin.asnum$(a)) / Math.log(Sk.builtin.asnum$(b));
        return Sk.builtin.numberToPy(e);
      });
      a.log10 = Sk.ffi.functionPy(function (a) {
        Sk.ffi.checkFunctionArgs('log10', arguments, 1, 1);
        Sk.builtin.pyCheckType('x', 'number', Sk.builtin.checkNumber(a));
        var b = Math.log(Sk.builtin.asnum$(a)) / Math.log(10);
        return Sk.builtin.numberToPy(b);
      });
      a.pow = Sk.ffi.functionPy(function (a, b) {
        Sk.ffi.checkFunctionArgs('pow', arguments, 2, 2);
        Sk.builtin.pyCheckType('x', 'number', Sk.builtin.checkNumber(a));
        Sk.builtin.pyCheckType('y', 'number', Sk.builtin.checkNumber(b));
        return Sk.builtin.numberToPy(Math.pow(Sk.builtin.asnum$(a), Sk.builtin.asnum$(b)));
      });
      a.radians = Sk.ffi.functionPy(function (a) {
        Sk.ffi.checkFunctionArgs('radians', arguments, 1, 1);
        Sk.builtin.pyCheckType('deg', 'number', Sk.builtin.checkNumber(a));
        var b = Math.PI / 180 * Sk.builtin.asnum$(a);
        return Sk.builtin.numberToPy(b);
      });
      a.degrees = Sk.ffi.functionPy(function (a) {
        Sk.ffi.checkFunctionArgs('degrees', arguments, 1, 1);
        Sk.builtin.pyCheckType('rad', 'number', Sk.builtin.checkNumber(a));
        var b = 180 / Math.PI * Sk.builtin.asnum$(a);
        return Sk.builtin.numberToPy(b);
      });
      a.hypot = Sk.ffi.functionPy(function (a, b) {
        Sk.ffi.checkFunctionArgs('hypot', arguments, 2, 2);
        Sk.builtin.pyCheckType('x', 'number', Sk.builtin.checkNumber(a));
        Sk.builtin.pyCheckType('y', 'number', Sk.builtin.checkNumber(b));
        a = Sk.builtin.asnum$(a);
        b = Sk.builtin.asnum$(b);
        return Sk.builtin.numberToPy(Math.sqrt(a * a + b * b));
      });
      a.factorial = Sk.ffi.functionPy(function (a) {
        Sk.ffi.checkFunctionArgs('factorial', arguments, 1, 1);
        Sk.builtin.pyCheckType('x', 'number', Sk.builtin.checkNumber(a));
        a = Math.floor(Sk.builtin.asnum$(a));
        for (var b = 1, e = 2; e <= a; e++)
          b *= e;
        return Sk.ffi.numberToIntPy(b);
      });
      a.conjugate = Sk.ffi.functionPy(function (a) {
        Sk.ffi.checkFunctionArgs('conjugate', arguments, 1, 1);
        return Sk.ffi.isNum(a) ? a : Sk.ffh.conjugate(a);
      });
      a.magnitude = Sk.ffi.functionPy(function (a) {
        Sk.ffi.checkFunctionArgs('magnitude', arguments, 1, 1);
        return Sk.ffh.magnitude(a);
      });
      a.quadrance = Sk.ffi.functionPy(function (a) {
        Sk.ffi.checkFunctionArgs('quadrance', arguments, 1, 1);
        return Sk.ffh.quadrance(a);
      });
    };
  }.call(this));
  Sk.matrix = Sk.matrix || {};
  Sk.matrix.MATRIX_2x1 = 'Matrix2x1';
  Sk.matrix.MATRIX_2x2 = 'Matrix2x2';
  Sk.matrix.MATRIX_1x2 = 'Matrix1x2';
  (function () {
    Sk.builtin.defineMatrix = function (a) {
      Sk.ffi.checkFunctionArgs('defineMatrix', arguments, 1, 1);
      a[Sk.matrix.MATRIX_2x1] = Sk.ffi.buildClass(a, function (b, c) {
        c.__init__ = Sk.ffi.functionPy(function (a, b, c) {
          Sk.ffi.checkMethodArgs(Sk.matrix.MATRIX_2x1, arguments, 2, 2);
          Sk.ffi.referenceToPy({
            elements: [
              b,
              c
            ]
          }, Sk.matrix.MATRIX_2x1, void 0, a);
        });
        c.__add__ = Sk.ffi.functionPy(function (b, c) {
          var f = Sk.ffi.remapToJs(b).elements, g = Sk.ffi.remapToJs(c).elements, h = Sk.ffh.add(f[0], g[0]), f = Sk.ffh.add(f[1], g[1]);
          return Sk.ffi.callsim(a[Sk.matrix.MATRIX_2x1], h, f);
        });
        c.__sub__ = Sk.ffi.functionPy(function (b, c) {
          var f = Sk.ffi.remapToJs(b).elements, g = Sk.ffi.remapToJs(c).elements, h = Sk.ffh.sub(f[0], g[0]), f = Sk.ffh.sub(f[1], g[1]);
          return Sk.ffi.callsim(a[Sk.matrix.MATRIX_2x1], h, f);
        });
        c.__mul__ = Sk.ffi.functionPy(function (b, c) {
          if (Sk.ffi.isInstance(c, Sk.matrix.MATRIX_2x1))
            throw Sk.ffi.assertionError('multiplication with 2x1 is not supported.');
          var f = Sk.ffi.remapToJs(b).elements, g = Sk.ffh.mul(f[0], c), f = Sk.ffh.mul(f[1], c);
          return Sk.ffi.callsim(a[Sk.matrix.MATRIX_2x1], g, f);
        });
        c.__rmul__ = Sk.ffi.functionPy(function (b, c) {
          var f = Sk.ffi.remapToJs(b).elements, g = Sk.ffh.mul(c, f[0]), f = Sk.ffh.mul(c, f[1]);
          return Sk.ffi.callsim(a[Sk.matrix.MATRIX_2x1], g, f);
        });
        c.__div__ = Sk.ffi.functionPy(function (b, c) {
          var f = Sk.ffi.remapToJs(b).elements, g = Sk.ffh.div(f[0], c), f = Sk.ffh.div(f[1], c);
          return Sk.ffi.callsim(a[Sk.matrix.MATRIX_2x1], g, f);
        });
        c.__conjugate__ = Sk.ffi.functionPy(function (b) {
          Sk.ffi.checkMethodArgs('conjugate', arguments, 0, 0);
          return Sk.ffi.callsim(a[Sk.matrix.MATRIX_2x1], Sk.ffh.conjugate(Sk.ffh.getitem(b, 0)), Sk.ffh.conjugate(Sk.ffh.getitem(b, 1)));
        });
        c.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          Sk.ffi.remapToJs(b);
          switch (c) {
          case 'transpose':
            return Sk.ffi.callableToPy(a, c, function (f) {
              Sk.ffi.checkMethodArgs(c, arguments, 0, 0);
              return Sk.ffi.callsim(a[Sk.matrix.MATRIX_1x2], Sk.ffh.getitem(b, 0), Sk.ffh.getitem(b, 1));
            });
          default:
            throw Sk.ffi.err.attribute(c).isNotGetableOnType(Sk.matrix.MATRIX_2x1);
          }
        });
        c.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          switch (b) {
          default:
            throw Sk.ffi.err.attribute(b).isNotSetableOnType(Sk.matrix.MATRIX_2x1);
          }
        });
        c.__getitem__ = Sk.ffi.functionPy(function (a, b) {
          Sk.ffi.checkMethodArgs('[]', arguments, 1, 1);
          Sk.ffi.checkArgType('index', Sk.ffi.PyType.INT, Sk.ffi.isInt(b), b);
          var c = Sk.ffi.remapToJs(b), g = Sk.ffi.remapToJs(a).elements;
          switch (c) {
          case 0:
            return g[0];
          case 1:
            return g[1];
          }
        });
        c.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a).elements;
          a = [
            a[0],
            a[1]
          ].map(function (a) {
            return Sk.ffi.remapToJs(Sk.ffh.str(a));
          }).join(', ');
          return Sk.builtin.stringToPy('(' + a + ')');
        });
        c.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a).elements;
          a = [
            a[0],
            a[1]
          ].map(function (a) {
            return Sk.ffi.remapToJs(Sk.ffh.repr(a));
          }).join(', ');
          return Sk.builtin.stringToPy(Sk.matrix.MATRIX_2x1 + '(' + a + ')');
        });
      }, Sk.matrix.MATRIX_2x1, []);
      a[Sk.matrix.MATRIX_1x2] = Sk.ffi.buildClass(a, function (b, c) {
        c.__init__ = Sk.ffi.functionPy(function (a, b, c) {
          Sk.ffi.checkMethodArgs(Sk.matrix.MATRIX_1x2, arguments, 2, 2);
          Sk.ffi.referenceToPy({
            elements: [
              b,
              c
            ]
          }, Sk.matrix.MATRIX_1x2, void 0, a);
        });
        c.__add__ = Sk.ffi.functionPy(function (b, c) {
          var f = Sk.ffi.remapToJs(b).elements, g = Sk.ffi.remapToJs(c).elements, h = Sk.ffh.add(f[0], g[0]), f = Sk.ffh.add(f[1], g[1]);
          return Sk.ffi.callsim(a[Sk.matrix.MATRIX_1x2], h, f);
        });
        c.__sub__ = Sk.ffi.functionPy(function (b, c) {
          var f = Sk.ffi.remapToJs(b).elements, g = Sk.ffi.remapToJs(c).elements, h = Sk.ffh.sub(f[0], g[0]), f = Sk.ffh.sub(f[1], g[1]);
          return Sk.ffi.callsim(a[Sk.matrix.MATRIX_1x2], h, f);
        });
        c.__mul__ = Sk.ffi.functionPy(function (b, c) {
          if (Sk.ffi.isInstance(c, Sk.matrix.MATRIX_2x1))
            return Sk.ffh.add(Sk.ffh.mul(Sk.ffh.getitem(b, 0), Sk.ffh.getitem(c, 0)), Sk.ffh.mul(Sk.ffh.getitem(b, 1), Sk.ffh.getitem(c, 1)));
          if (Sk.ffi.isInstance(c, Sk.matrix.MATRIX_1x2))
            throw Sk.ffi.assertionError('multiplication with 2x1 is not supported.');
          var f = Sk.ffi.remapToJs(b).elements, g = Sk.ffh.mul(f[0], c), f = Sk.ffh.mul(f[1], c);
          return Sk.ffi.callsim(a[Sk.matrix.MATRIX_1x2], g, f);
        });
        c.__rmul__ = Sk.ffi.functionPy(function (b, c) {
          var f = Sk.ffi.remapToJs(b).elements, g = Sk.ffh.mul(c, f[0]), f = Sk.ffh.mul(c, f[1]);
          return Sk.ffi.callsim(a[Sk.matrix.MATRIX_1x2], g, f);
        });
        c.__div__ = Sk.ffi.functionPy(function (b, c) {
          var f = Sk.ffi.remapToJs(b).elements, g = Sk.ffh.div(f[0], c), f = Sk.ffh.div(f[1], c);
          return Sk.ffi.callsim(a[Sk.matrix.MATRIX_1x2], g, f);
        });
        c.__conjugate__ = Sk.ffi.functionPy(function (b) {
          Sk.ffi.checkMethodArgs('conjugate', arguments, 0, 0);
          return Sk.ffi.callsim(a[Sk.matrix.MATRIX_1x2], Sk.ffh.conjugate(Sk.ffh.getitem(b, 0)), Sk.ffh.conjugate(Sk.ffh.getitem(b, 1)));
        });
        c.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          Sk.ffi.remapToJs(b);
          switch (c) {
          case 'transpose':
            return Sk.ffi.callableToPy(a, c, function (f) {
              Sk.ffi.checkMethodArgs(c, arguments, 0, 0);
              return Sk.ffi.callsim(a[Sk.matrix.MATRIX_2x1], Sk.ffh.getitem(b, 0), Sk.ffh.getitem(b, 1));
            });
          default:
            throw Sk.ffi.err.attribute(c).isNotGetableOnType(Sk.matrix.MATRIX_1x2);
          }
        });
        c.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          switch (b) {
          default:
            throw Sk.ffi.err.attribute(b).isNotSetableOnType(Sk.matrix.MATRIX_1x2);
          }
        });
        c.__getitem__ = Sk.ffi.functionPy(function (a, b) {
          Sk.ffi.checkMethodArgs('[]', arguments, 1, 1);
          Sk.ffi.checkArgType('index', Sk.ffi.PyType.INT, Sk.ffi.isInt(b), b);
          var c = Sk.ffi.remapToJs(b), g = Sk.ffi.remapToJs(a).elements;
          switch (c) {
          case 0:
            return g[0];
          case 1:
            return g[1];
          }
        });
        c.__str__ = Sk.ffi.functionPy(function (a) {
          a = [
            Sk.ffh.getitem(a, 0),
            Sk.ffh.getitem(a, 1)
          ].map(function (a) {
            return Sk.ffi.remapToJs(Sk.ffh.str(a));
          }).join(' ');
          return Sk.builtin.stringToPy('[' + a + ']');
        });
        c.__repr__ = Sk.ffi.functionPy(function (a) {
          a = [
            Sk.ffh.getitem(a, 0),
            Sk.ffh.getitem(a, 1)
          ].map(function (a) {
            return Sk.ffi.remapToJs(Sk.ffh.repr(a));
          }).join(', ');
          return Sk.builtin.stringToPy(Sk.matrix.MATRIX_1x2 + '(' + a + ')');
        });
      }, Sk.matrix.MATRIX_1x2, []);
      a[Sk.matrix.MATRIX_2x2] = Sk.ffi.buildClass(a, function (b, c) {
        c.__init__ = Sk.ffi.functionPy(function (a, b, c) {
          Sk.ffi.checkMethodArgs(Sk.matrix.MATRIX_2x2, arguments, 2, 2);
          Sk.ffi.checkArgType('one', Sk.matrix.MATRIX_2x1, Sk.ffi.isInstance(b, Sk.matrix.MATRIX_2x1), b);
          Sk.ffi.checkArgType('two', Sk.matrix.MATRIX_2x1, Sk.ffi.isInstance(c, Sk.matrix.MATRIX_2x1), c);
          Sk.ffi.referenceToPy({
            elements: [
              b,
              c
            ]
          }, Sk.matrix.MATRIX_2x2, void 0, a);
        });
        c.__add__ = Sk.ffi.functionPy(function (b, c) {
          var f = Sk.ffi.remapToJs(b).elements, g = Sk.ffi.remapToJs(c).elements, h = Sk.ffh.add(f[0], g[0]), f = Sk.ffh.add(f[1], g[1]);
          return Sk.ffi.callsim(a[Sk.matrix.MATRIX_2x2], h, f);
        });
        c.__sub__ = Sk.ffi.functionPy(function (b, c) {
          var f = Sk.ffi.remapToJs(b).elements, g = Sk.ffi.remapToJs(c).elements, h = Sk.ffh.sub(f[0], g[0]), f = Sk.ffh.sub(f[1], g[1]);
          return Sk.ffi.callsim(a[Sk.matrix.MATRIX_2x2], h, f);
        });
        c.__mul__ = Sk.ffi.functionPy(function (b, c) {
          var f = Sk.ffh.getitem(Sk.ffh.getitem(b, 0), 0), g = Sk.ffh.getitem(Sk.ffh.getitem(b, 0), 1), h = Sk.ffh.getitem(Sk.ffh.getitem(b, 1), 0), l = Sk.ffh.getitem(Sk.ffh.getitem(b, 1), 1);
          if (Sk.ffi.isInstance(c, Sk.matrix.MATRIX_2x2)) {
            var k = Sk.ffh.getitem(Sk.ffh.getitem(c, 0), 0), m = Sk.ffh.getitem(Sk.ffh.getitem(c, 0), 1), p = Sk.ffh.getitem(Sk.ffh.getitem(c, 1), 0), n = Sk.ffh.getitem(Sk.ffh.getitem(c, 1), 1), q = Sk.ffh.add(Sk.ffh.mul(f, k), Sk.ffh.mul(h, m)), k = Sk.ffh.add(Sk.ffh.mul(g, k), Sk.ffh.mul(l, m)), f = Sk.ffh.add(Sk.ffh.mul(f, p), Sk.ffh.mul(h, n)), g = Sk.ffh.add(Sk.ffh.mul(g, p), Sk.ffh.mul(l, n)), h = Sk.ffi.callsim(a[Sk.matrix.MATRIX_2x1], q, k), g = Sk.ffi.callsim(a[Sk.matrix.MATRIX_2x1], f, g);
            return Sk.ffi.callsim(a[Sk.matrix.MATRIX_2x2], h, g);
          }
          if (Sk.ffi.isInstance(c, Sk.matrix.MATRIX_2x1))
            return q = Sk.ffh.getitem(c, 0), p = Sk.ffh.getitem(c, 1), h = Sk.ffh.add(Sk.ffh.mul(f, q), Sk.ffh.mul(h, p)), g = Sk.ffh.add(Sk.ffh.mul(g, q), Sk.ffh.mul(l, p)), Sk.ffi.callsim(a[Sk.matrix.MATRIX_2x1], h, g);
          q = Sk.ffh.mul(f, c);
          k = Sk.ffh.mul(g, c);
          f = Sk.ffh.mul(h, c);
          g = Sk.ffh.mul(l, c);
          h = Sk.ffi.callsim(a[Sk.matrix.MATRIX_2x1], q, k);
          g = Sk.ffi.callsim(a[Sk.matrix.MATRIX_2x1], f, g);
          return Sk.ffi.callsim(a[Sk.matrix.MATRIX_2x2], h, g);
        });
        c.__rmul__ = Sk.ffi.functionPy(function (b, c) {
          var f = Sk.ffh.getitem(Sk.ffh.getitem(b, 0), 0), g = Sk.ffh.getitem(Sk.ffh.getitem(b, 0), 1), h = Sk.ffh.getitem(Sk.ffh.getitem(b, 1), 0), l = Sk.ffh.getitem(Sk.ffh.getitem(b, 1), 1);
          if (Sk.ffi.isInstance(c, Sk.matrix.MATRIX_1x2))
            var k = Sk.ffh.getitem(Sk.ffh.getitem(c, 0), 0), m = Sk.ffh.getitem(Sk.ffh.getitem(c, 0), 1), p = Sk.ffh.getitem(Sk.ffh.getitem(c, 1), 0), n = Sk.ffh.getitem(Sk.ffh.getitem(c, 1), 1), q = Sk.ffh.add(Sk.ffh.mul(f, k), Sk.ffh.mul(h, m)), k = Sk.ffh.add(Sk.ffh.mul(g, k), Sk.ffh.mul(l, m)), f = Sk.ffh.add(Sk.ffh.mul(f, p), Sk.ffh.mul(h, n)), g = Sk.ffh.add(Sk.ffh.mul(g, p), Sk.ffh.mul(l, n));
          else
            q = Sk.ffh.mul(c, f), k = Sk.ffh.mul(c, g), f = Sk.ffh.mul(c, h), g = Sk.ffh.mul(c, l);
          q = Sk.ffi.callsim(a[Sk.matrix.MATRIX_2x1], q, k);
          g = Sk.ffi.callsim(a[Sk.matrix.MATRIX_2x1], f, g);
          return Sk.ffi.callsim(a[Sk.matrix.MATRIX_2x2], q, g);
        });
        c.__div__ = Sk.ffi.functionPy(function (b, c) {
          var f = Sk.ffi.remapToJs(b).elements, g = Sk.ffh.div(f[0], c), f = Sk.ffh.div(f[1], c);
          return Sk.ffi.callsim(a[Sk.matrix.MATRIX_2x2], g, f);
        });
        c.__conjugate__ = Sk.ffi.functionPy(function (b) {
          Sk.ffi.checkMethodArgs('conjugate', arguments, 0, 0);
          return Sk.ffi.callsim(a[Sk.matrix.MATRIX_2x2], Sk.ffh.conjugate(Sk.ffh.getitem(b, 0)), Sk.ffh.conjugate(Sk.ffh.getitem(b, 1)));
        });
        c.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          Sk.ffi.remapToJs(b);
          switch (c) {
          case 'transpose':
            return Sk.ffi.callableToPy(a, c, function (f) {
              Sk.ffi.checkMethodArgs(c, arguments, 0, 0);
              var g = Sk.ffh.getitem(b, 0), h = Sk.ffh.getitem(b, 1), l = Sk.ffi.callsim(a[Sk.matrix.MATRIX_2x1], Sk.ffh.getitem(g, 0), Sk.ffh.getitem(h, 0)), g = Sk.ffi.callsim(a[Sk.matrix.MATRIX_2x1], Sk.ffh.getitem(g, 1), Sk.ffh.getitem(h, 1));
              return Sk.ffi.callsim(a[Sk.matrix.MATRIX_2x2], l, g);
            });
          default:
            throw Sk.ffi.err.attribute(c).isNotGetableOnType(Sk.matrix.MATRIX_2x2);
          }
        });
        c.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          switch (b) {
          default:
            throw Sk.ffi.err.attribute(b).isNotSetableOnType(Sk.matrix.MATRIX_2x2);
          }
        });
        c.__getitem__ = Sk.ffi.functionPy(function (a, b) {
          Sk.ffi.checkMethodArgs('[]', arguments, 1, 1);
          Sk.ffi.checkArgType('index', Sk.ffi.PyType.INT, Sk.ffi.isInt(b), b);
          var c = Sk.ffi.remapToJs(b), g = Sk.ffi.remapToJs(a).elements;
          switch (c) {
          case 0:
            return g[0];
          case 1:
            return g[1];
          }
        });
        c.__str__ = Sk.ffi.functionPy(function (a) {
          a = [
            Sk.ffh.getitem(a, 0),
            Sk.ffh.getitem(a, 1)
          ].map(function (a) {
            return Sk.ffi.remapToJs(Sk.ffh.str(a));
          }).join(' ');
          return Sk.builtin.stringToPy('[' + a + ']');
        });
        c.__repr__ = Sk.ffi.functionPy(function (a) {
          a = [
            Sk.ffh.getitem(a, 0),
            Sk.ffh.getitem(a, 1)
          ].map(function (a) {
            return Sk.ffi.remapToJs(Sk.ffh.repr(a));
          }).join(', ');
          return Sk.builtin.stringToPy(Sk.matrix.MATRIX_2x2 + '(' + a + ')');
        });
      }, Sk.matrix.MATRIX_2x2, []);
    };
  }.call(this));
  (function () {
    Sk.builtin.defineComplex = function (a, b) {
      function c(a) {
        return Sk.ffi.isInstance(a, b);
      }
      function d(a, b) {
        return Math.sqrt(a * a + b * b);
      }
      function e(a, b, c) {
        var d, e, f, q, g;
        f = [];
        d = function (a, b) {
          var d;
          if (0 !== a) {
            0 <= a ? 0 < f.length && f.push('+') : f.push('-');
            d = Math.abs(a);
            if (1 === d)
              return f.push(b);
            f.push(d.toString());
            if ('1' !== b)
              return f.push(c), f.push(b);
          }
        };
        e = q = 0;
        for (g = a.length - 1; 0 <= g ? q <= g : q >= g; e = 0 <= g ? ++q : --q)
          d(a[e], b[e]);
        return 0 < f.length ? f.join('') : '0';
      }
      function f(c, d) {
        return Sk.ffi.callsim(a[b], Sk.ffi.numberToFloatPy(c), Sk.ffi.numberToFloatPy(d));
      }
      Sk.ffi.checkFunctionArgs('defineComplex', arguments, 2, 2);
      var g = [
          Sk.ffi.PyType.FLOAT,
          Sk.ffi.PyType.INT,
          Sk.ffi.PyType.LONG
        ];
      a[b] = Sk.ffi.buildClass(a, function (d, l) {
        l.__init__ = Sk.ffi.functionPy(function (a, c, d) {
          Sk.ffi.checkMethodArgs(b, arguments, 2, 2);
          Sk.ffi.checkArgType('real', g, Sk.ffi.isNum(c), c);
          Sk.ffi.checkArgType('imag', g, Sk.ffi.isNum(d), d);
          Sk.ffi.referenceToPy({
            x: Sk.ffi.remapToJs(c),
            y: Sk.ffi.remapToJs(d)
          }, b, void 0, a);
        });
        l.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'real':
            return Sk.ffi.numberToFloatPy(d.x);
          case 'imag':
            return Sk.ffi.numberToFloatPy(d.y);
          case 'abs':
            return Sk.ffi.callableToPy(a, c, function (a) {
              return Sk.ffi.numberToFloatPy(Math.sqrt(d.x * d.x + d.y * d.y));
            });
          case 'conjugate':
            return Sk.ffi.callableToPy(a, c, function (a) {
              return f(d.x, -d.y);
            });
          case 'exp':
            return Sk.ffi.callableToPy(a, c, function (a) {
              a = Math.exp(d.x);
              var b = Sk.math.cos(d.y), c = Sk.math.sin(d.y);
              return f(a * b, a * c);
            });
          }
        });
        l.__add__ = Sk.ffi.functionPy(function (a, d) {
          var e = Sk.ffi.remapToJs(a), n = Sk.ffi.remapToJs(d);
          if (c(d))
            return f(e.x + n.x, e.y + n.y);
          if (Sk.ffi.isNum(d))
            return f(e.x + n, e.y);
          throw Sk.ffi.err.argument('other').mustHaveType(b);
        });
        l.__radd__ = Sk.ffi.functionPy(function (a, b) {
          Sk.ffi.checkArgType('other', g, Sk.ffi.isNum(b), b);
          var c = Sk.ffi.remapToJs(b), d = Sk.ffi.remapToJs(a);
          return f(c + d.x, d.y);
        });
        l.__iadd__ = Sk.ffi.functionPy(function (a, d) {
          var e = Sk.ffi.remapToJs(a), f = Sk.ffi.remapToJs(d);
          if (Sk.ffi.isNum(d))
            e.x += f;
          else if (c(d))
            e.x += f.x, e.y += f.y;
          else
            throw Sk.ffi.err.argument('other').mustHaveType([
              b,
              g
            ]);
          return a;
        });
        l.__sub__ = Sk.ffi.functionPy(function (a, d) {
          var e = Sk.ffi.remapToJs(a), n = Sk.ffi.remapToJs(d);
          if (c(d))
            return f(e.x - n.x, e.y - n.y);
          if (Sk.ffi.isNum(d))
            return f(e.x - n, e.y);
          throw Sk.ffi.err.argument('other').mustHaveType([
            b,
            g
          ]);
        });
        l.__rsub__ = Sk.ffi.functionPy(function (a, b) {
          var c, d;
          c = Sk.ffi.remapToJs(b);
          d = Sk.ffi.remapToJs(a);
          if (Sk.ffi.isNum(b))
            return c -= d.x, d = -d.y, f(c, d);
          throw Sk.ffi.err.argument('other').mustHaveType(g);
        });
        l.__isub__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a), d = Sk.ffi.remapToJs(b);
          Sk.ffi.isNum(b) ? c.x -= d : (c.x -= d.x, c.y -= d.y);
          return a;
        });
        l.__mul__ = Sk.ffi.functionPy(function (a, b) {
          var d, e;
          e = Sk.ffi.remapToJs(a);
          var q = Sk.ffi.remapToJs(b);
          if (c(b))
            return d = e.x * q.x - e.y * q.y, e = e.y * q.x + e.x * q.y, f(d, e);
          if (Sk.ffi.isNum(b))
            return d = e.x * q, e = e.y * q, f(d, e);
        });
        l.__rmul__ = Sk.ffi.functionPy(function (a, b) {
          var d, e;
          e = Sk.ffi.remapToJs(b);
          var q = Sk.ffi.remapToJs(a);
          if (c(b))
            return d = q.x * e.x - q.y * e.y, e = q.y * e.x + q.x * e.y, f(d, e);
          if (Sk.ffi.isNum(b))
            return d = e * q.x, e *= q.y, f(d, e);
        });
        l.__imul__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a), d = c.x, e = c.y, f = Sk.ffi.remapToJs(b);
          Sk.ffi.isNum(b) ? (c.x *= f, c.y *= f) : (c.x = d * f.x - e * f.y, c.y = e * f.x + d * f.y);
          return a;
        });
        l.__div__ = Sk.ffi.functionPy(function (a, d) {
          var e = Sk.ffi.remapToJs(a), n = Sk.ffi.remapToJs(d);
          if (c(d)) {
            var q = n.x * n.x + n.y * n.y;
            return f((e.x * n.x + e.y * n.y) / q, (e.y * n.x - e.x * n.y) / q);
          }
          if (Sk.ffi.isNum(d))
            return f(e.x / n, e.y / n);
          Sk.ffi.checkArgType('other', [
            b,
            g
          ], !1, d);
        });
        l.__rdiv__ = Sk.ffi.functionPy(function (a, b) {
          Sk.ffi.checkArgType('other', g, Sk.ffi.isNum(b), b);
          var c = Sk.ffi.remapToJs(b), d = Sk.ffi.remapToJs(a);
          if (Sk.ffi.isNum(b)) {
            var e = d.x * d.x + d.y * d.y;
            return f(c * d.x / e, -c * d.y / e);
          }
          throw Sk.ffi.err.argument('other').mustHaveType(g);
        });
        l.__idiv__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a), d = c.x, e = c.y, f = Sk.ffi.remapToJs(b);
          if (Sk.ffi.isNum(b))
            c.x /= f, c.y /= f;
          else {
            var g = f.x * f.x + f.y * f.y;
            c.x = (d * f.x + e * f.y) / g;
            c.y = (e * f.x - d * f.y) / g;
          }
          return a;
        });
        l.__abs__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.numberToFloatPy(Math.sqrt(a.x * a.x + a.y * a.y));
        });
        l.__conjugate__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return f(a.x, -a.y);
        });
        l.__cos__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          var b = a.x, c = a.y;
          a = Sk.math.cos(b);
          var d = (Math.pow(Math.E, c) + Math.pow(Math.E, -c)) / 2, b = Sk.math.sin(b), c = (Math.pow(Math.E, c) - Math.pow(Math.E, -c)) / 2;
          return f(a * d, -b * c);
        });
        l.__sin__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          var b = a.x, c = a.y;
          a = Sk.math.cos(b);
          var d = (Math.pow(Math.E, c) + Math.pow(Math.E, -c)) / 2, b = Sk.math.sin(b), c = (Math.pow(Math.E, c) - Math.pow(Math.E, -c)) / 2;
          return f(b * d, a * c);
        });
        l.__exp__ = Sk.ffi.functionPy(function (a) {
          var b = Sk.ffi.remapToJs(a);
          a = Math.exp(b.x);
          var c = Sk.math.cos(b.y), b = Sk.math.sin(b.y);
          return f(a * c, a * b);
        });
        l.__magnitude__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffh.sqrt(Sk.ffh.quadrance(a));
        });
        l.__quadrance__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return f(a.x * a.x + a.y * a.y, 0);
        });
        l.__sqrt__ = Sk.ffi.functionPy(function (a) {
          var b = Sk.ffi.remapToJs(a);
          return 0 !== b.y ? (a = 0 !== b.x ? Math.sqrt((b.x + Math.sqrt(b.x * b.x + b.y * b.y)) / 2) : Math.sqrt(Math.abs(b.y) / 2), b = b.y / (2 * a), f(a, b)) : 0 !== b.x ? 0 < b.x ? f(Math.sqrt(b.x), 0) : f(0, Math.sqrt(-b.x)) : f(0, 0);
        });
        l.__pos__ = Sk.ffi.functionPy(function (a) {
          return a;
        });
        l.__neg__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return f(-a.x, -a.y);
        });
        l.__invert__ = Sk.ffi.functionPy(function (a) {
          var b = f(1, 0);
          return Sk.ffi.callsim(a.__div__, b, a);
        });
        l.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.builtin.stringToPy(e([
            a.x,
            a.y
          ], [
            '1',
            'i'
          ], ''));
        });
        l.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.builtin.stringToPy(b + '(' + a.x + ', ' + a.y + ')');
        });
        l.__eq__ = Sk.ffi.functionPy(function (a, b) {
          a = Sk.ffi.remapToJs(a);
          b = Sk.ffi.remapToJs(b);
          return a.x === b.x && a.y === b.y;
        });
        l.__ne__ = Sk.ffi.functionPy(function (a, b) {
          a = Sk.ffi.remapToJs(a);
          b = Sk.ffi.remapToJs(b);
          return a.x !== b.x || a.y !== b.y;
        });
      }, b, []);
      a.phase = Sk.ffi.functionPy(function (a) {
        Sk.ffi.checkFunctionArgs('phase', arguments, 1, 1);
        if (c(a)) {
          var d = Sk.ffi.remapToJs(a);
          return Sk.ffi.numberToFloatPy(Math.atan2(d.y, d.x));
        }
        if (Sk.ffi.isNum(a))
          return Sk.ffi.numberToFloatPy(Math.atan2(0, Sk.ffi.remapToJs(a)));
        Sk.ffi.checkArgType('x', b, !1, a);
      });
      a.polar = Sk.ffi.functionPy(function (a) {
        Sk.ffi.checkFunctionArgs('polar', arguments, 1, 1);
        if (c(a)) {
          var e = Sk.ffi.remapToJs(a);
          return Sk.ffi.tuplePy([
            Sk.ffi.numberToFloatPy(d(e.x, e.y)),
            Sk.ffi.numberToFloatPy(Math.atan2(e.y, e.x))
          ]);
        }
        if (Sk.ffi.isNum(a))
          return Sk.ffi.tuplePy([
            Sk.ffi.numberToFloatPy(d(Sk.ffi.remapToJs(a), 0)),
            Sk.ffi.numberToFloatPy(0)
          ]);
        Sk.ffi.checkArgType('x', b, !1, a);
      });
    };
  }.call(this));
  (function () {
    Sk.builtin.defineQuaternion = function (a, b) {
      function c(a, b, c) {
        var d, l, k, m, p;
        k = [];
        d = function (a, b) {
          var d;
          if (0 !== a) {
            0 <= a ? 0 < k.length && k.push('+') : k.push('-');
            d = Math.abs(a);
            if (1 === d)
              return k.push(b);
            k.push(d.toString());
            if ('1' !== b)
              return k.push(c), k.push(b);
          }
        };
        l = m = 0;
        for (p = a.length - 1; 0 <= p ? m <= p : m >= p; l = 0 <= p ? ++m : --m)
          d(a[l], b[l]);
        return 0 < k.length ? k.join('') : '0';
      }
      function d(b, c, d, h) {
        return Sk.ffi.callsim(a.Quaternion, Sk.ffi.numberToFloatPy(c), Sk.ffi.numberToFloatPy(d), Sk.ffi.numberToFloatPy(h), Sk.ffi.numberToFloatPy(b));
      }
      Sk.ffi.checkFunctionArgs('defineQuaternion', arguments, 2, 2);
      a.Quaternion = Sk.ffi.buildClass(a, function (e, f) {
        f.__init__ = Sk.ffi.functionPy(function (a, c, d, e, f) {
          Sk.ffi.isInstance(c, 'Quaternion') ? Sk.ffi.referenceToPy(Sk.ffi.remapToJs(c), 'Quaternion', void 0, a) : (c = Sk.ffi.remapToJs(c), d = Sk.ffi.remapToJs(d), e = Sk.ffi.remapToJs(e), f = Sk.ffi.remapToJs(f), Sk.ffi.referenceToPy(new b.Quaternion(c, d, e, f), 'Quaternion', void 0, a));
        });
        f.__add__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(b);
          return Sk.ffi.isNum(b) ? d(c.w + e, c.x, c.y, c.z) : d(c.w + e.w, c.x + e.x, c.y + e.y, c.z + e.z);
        });
        f.__radd__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(b), e = Sk.ffi.remapToJs(a);
          if (Sk.ffi.isNum(b))
            return d(c + e.w, e.x, e.y, e.z);
          throw Sk.ffi.err.operand('other').toOperation('+').mustHaveType('Quaternion');
        });
        f.__iadd__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a), d = Sk.ffi.remapToJs(b);
          Sk.ffi.isNum(b) ? c.w += d : (c.w += d.w, c.x += d.x, c.y += d.y, c.z += d.z);
          return a;
        });
        f.__sub__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(b);
          return Sk.ffi.isNum(b) ? d(c.w - e, c.x, c.y, c.z) : d(c.w - e.w, c.x - e.x, c.y - e.y, c.z - e.z);
        });
        f.__rsub__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(b), e = Sk.ffi.remapToJs(a);
          if (Sk.ffi.isNum(b))
            return d(c - e.w, -e.x, -e.y, -e.z);
          throw Sk.ffi.err.operand('other').toOperation('-').mustHaveType('Quaternion');
        });
        f.__isub__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a), d = Sk.ffi.remapToJs(b);
          Sk.ffi.isNum(b) ? c.w -= d : (c.w -= d.w, c.x -= d.x, c.y -= d.y, c.z -= d.z);
          return a;
        });
        f.__mul__ = Sk.ffi.functionPy(function (c, e) {
          var f = Sk.ffi.remapToJs(c), k = Sk.ffi.remapToJs(e);
          if (Sk.ffi.isNum(e))
            return d(f.w * k, f.x * k, f.y * k, f.z * k);
          f = new b.Quaternion(0, 0, 0, 1).multiplyQuaternions(f, k);
          return Sk.ffi.callsim(a.Quaternion, Sk.ffi.referenceToPy(f, 'Quaternion'));
        });
        f.__rmul__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(b), e = Sk.ffi.remapToJs(a);
          if (Sk.ffi.isNum(b))
            return d(c * e.w, c * e.x, c * e.y, c * e.z);
          throw Sk.ffi.err.operand('other').toOperation('*').mustHaveType('Quaternion');
        });
        f.__imul__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a), d = Sk.ffi.remapToJs(b);
          Sk.ffi.isNum(b) ? (c.w *= d, c.x *= d, c.y *= d, c.z *= d) : c.multiply(d);
          return a;
        });
        f.u$positive = function () {
          return this;
        };
        f.u$negative = function () {
          var a = Sk.ffi.remapToJs(this);
          return d(-a.w, -a.x, -a.y, -a.z);
        };
        f.__eq__ = Sk.ffi.functionPy(function (a, b) {
          if (Sk.ffi.isInstance(b, 'Quaternion')) {
            var c = Sk.ffi.remapToJs(a), d = Sk.ffi.remapToJs(b);
            return Sk.ffi.booleanToPy(c.w === d.w && c.x === d.x && c.y === d.y && c.z === d.z);
          }
          return Sk.ffi.bool.False;
        });
        f.__ne__ = Sk.ffi.functionPy(function (a, b) {
          if (Sk.ffi.isInstance(b, 'Quaternion')) {
            var c = Sk.ffi.remapToJs(a), d = Sk.ffi.remapToJs(b);
            return Sk.ffi.booleanToPy(c.w !== d.w || c.x !== d.x || c.y !== d.y || c.z !== d.z);
          }
          return Sk.ffi.bool.True;
        });
        f.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var e = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'x':
            return Sk.ffi.numberToFloatPy(e.x);
          case 'y':
            return Sk.ffi.numberToFloatPy(e.y);
          case 'z':
            return Sk.ffi.numberToFloatPy(e.z);
          case 'w':
            return Sk.ffi.numberToFloatPy(e.w);
          case 'copy':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, c) {
              c.__init__ = Sk.ffi.functionPy(function (a) {
                Sk.ffi.referenceToPy(null, 'copy', null, a);
              });
              c.__call__ = Sk.ffi.functionPy(function (a, c) {
                Sk.ffi.checkMethodArgs('copy', arguments, 1, 1);
                Sk.ffi.checkArgType('q', 'Quaternion', Sk.ffi.isInstance(c, 'Quaternion'), c);
                var d = Sk.ffi.remapToJs(c);
                e.copy(d);
                return b;
              });
            }, 'copy', []));
          case 'setFromAxisAngle':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, c) {
              c.__init__ = Sk.ffi.functionPy(function (a) {
                Sk.ffi.referenceToPy(null, 'setFromAxisAngle', null, a);
              });
              c.__call__ = Sk.ffi.functionPy(function (a, c, d) {
                a = Sk.ffi.remapToJs(c);
                d = Sk.ffi.remapToJs(d);
                e.setFromAxisAngle(a, d);
                return b;
              });
            }, 'setFromAxisAngle', []));
          case 'setFromEuler':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, c) {
              c.__init__ = Sk.ffi.functionPy(function (a) {
                Sk.ffi.referenceToPy(null, 'setFromEuler', null, a);
              });
              c.__call__ = Sk.ffi.functionPy(function (a, c, d) {
                a = Sk.ffi.remapToJs(c);
                d = Sk.ffi.remapToJs(d);
                e.setFromEuler(a, d);
                return b;
              });
            }, 'setFromEuler', []));
          case 'set':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, c) {
              c.__init__ = Sk.ffi.functionPy(function (a) {
                Sk.ffi.referenceToPy(null, 'set', null, a);
              });
              c.__call__ = Sk.ffi.functionPy(function (a, c, d, f, m) {
                e.x = Sk.ffi.remapToJs(c);
                e.y = Sk.ffi.remapToJs(d);
                e.z = Sk.ffi.remapToJs(f);
                e.w = Sk.ffi.remapToJs(m);
                return b;
              });
            }, 'set', []));
          case 'clone':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
              b.__init__ = Sk.ffi.functionPy(function (a) {
                Sk.ffi.referenceToPy(null, 'clone', null, a);
              });
              b.__call__ = Sk.ffi.functionPy(function (a) {
                return d(e.w, e.x, e.y, e.z);
              });
            }, 'clone', []));
          case 'conjugate':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, c) {
              c.__init__ = Sk.ffi.functionPy(function (a) {
                Sk.ffi.referenceToPy(null, 'conjugate', null, a);
              });
              c.__call__ = Sk.ffi.functionPy(function (a) {
                e.conjugate();
                return b;
              });
            }, 'conjugate', []));
          case 'inverse':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, c) {
              c.__init__ = Sk.ffi.functionPy(function (a) {
                Sk.ffi.referenceToPy(null, 'inverse', null, a);
              });
              c.__call__ = Sk.ffi.functionPy(function (a) {
                a = 1 / e.lengthSq();
                e.conjugate();
                e.w *= a;
                e.x *= a;
                e.y *= a;
                e.z *= a;
                return b;
              });
            }, 'inverse', []));
          case 'magnitude':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
              b.__init__ = Sk.ffi.functionPy(function (a) {
                Sk.ffi.referenceToPy(null, 'magnitude', null, a);
              });
              b.__call__ = Sk.ffi.functionPy(function (a) {
                return Sk.ffi.numberToFloatPy(e.length());
              });
            }, 'magnitude', []));
          case 'quadrance':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
              b.__init__ = Sk.ffi.functionPy(function (a) {
                Sk.ffi.referenceToPy(null, 'quadrance', null, a);
              });
              b.__call__ = Sk.ffi.functionPy(function (a) {
                return Sk.ffi.numberToFloatPy(e.lengthSq());
              });
            }, 'quadrance', []));
          case 'normalize':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, c) {
              c.__init__ = Sk.ffi.functionPy(function (a) {
                Sk.ffi.referenceToPy(null, 'normalize', null, a);
              });
              c.__call__ = Sk.ffi.functionPy(function (a) {
                e.normalize();
                return b;
              });
            }, 'normalize', []));
          default:
            throw Sk.ffi.err.attribute(c).isNotGetableOnType('Quaternion');
          }
        });
        f.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          a = Sk.ffi.remapToJs(a);
          c = Sk.ffi.remapToJs(c);
          switch (b) {
          case 'x':
            a.x = c;
            break;
          case 'y':
            a.y = c;
            break;
          case 'z':
            a.z = c;
            break;
          case 'w':
            a.w = c;
            break;
          default:
            throw Sk.ffi.err.attribute(b).isNotSetableOnType('Quaternion');
          }
        });
        f.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.builtin.stringToPy('Quaternion(' + [
            a.x,
            a.y,
            a.z,
            a.w
          ].join(', ') + ')');
        });
        f.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.builtin.stringToPy(c([
            a.w,
            a.x,
            a.y,
            a.z
          ], [
            '1',
            'i',
            'j',
            'k'
          ]));
        });
      }, 'Quaternion', []);
    };
  }.call(this));
  (function () {
    Sk.builtin.defineEasel = function (a, b, c) {
      function d(b, c, d) {
        var e = Sk.ffi.remapToJs(b);
        switch (c) {
        case 'alpha':
          return Sk.ffi.numberToFloatPy(e.alpha);
        case 'graphics':
          return Sk.ffi.callsim(a.Graphics, Sk.ffi.referenceToPy(e.graphics, 'Graphics'));
        case 'name':
          return Sk.builtin.stringToPy(e.name);
        case 'x':
          return Sk.ffi.numberToFloatPy(e.x);
        case 'y':
          return Sk.ffi.numberToFloatPy(e.y);
        case 'rotation':
          return Sk.ffi.numberToFloatPy(e.rotation);
        case 'addEventListener':
          return Sk.builtin.addEventListener(a, e);
        case 'removeEventListener':
          return Sk.builtin.removeEventListener(a, e);
        case 'globalToLocal':
          return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (b, c) {
            c.__init__ = Sk.ffi.functionPy(function (a) {
              a.tp$name = 'globalToLocal';
              a.v = e.globalToLocal;
            });
            c.__call__ = Sk.ffi.functionPy(function (b, c, d) {
              b = e.globalToLocal(Sk.ffi.remapToJs(c), Sk.ffi.remapToJs(d));
              return Sk.ffi.callsim(a.Point, Sk.ffi.referenceToPy(b, 'Point'));
            });
          }, 'globalToLocal', []));
        case 'hitTest':
          return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
            b.__init__ = Sk.ffi.functionPy(function (a) {
              a.tp$name = 'hitTest';
              a.v = e.hitTest;
            });
            b.__call__ = Sk.ffi.functionPy(function (a, b, c) {
              return Sk.ffi.booleanToPy(e.hitTest(Sk.ffi.remapToJs(b), Sk.ffi.remapToJs(c)));
            });
          }, 'hitTest', []));
        case 'localToLocal':
          return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (b, c) {
            c.__init__ = Sk.ffi.functionPy(function (a) {
              a.tp$name = 'localToLocal';
              a.v = e.localToLocal;
            });
            c.__call__ = Sk.ffi.functionPy(function (b, c, d, f) {
              b = e.localToLocal(Sk.ffi.remapToJs(c), Sk.ffi.remapToJs(d), Sk.ffi.remapToJs(f));
              return Sk.ffi.callsim(a.Point, Sk.ffi.referenceToPy(b, 'Point'));
            });
          }, 'localToLocal', []));
        default:
          throw Sk.ffi.err.attribute(c).isNotGetableOnType(d);
        }
      }
      function e(a, b, c, d) {
        a = Sk.ffi.remapToJs(a);
        var e = Sk.ffi.remapToJs(c);
        switch (b) {
        case 'alpha':
          Sk.ffi.checkArgType('alpha', f, Sk.ffi.isNum(c), c);
          a.alpha = e;
          break;
        case 'name':
          Sk.ffi.checkArgType('name', Sk.ffi.PyType.STR, Sk.builtin.isStringPy(c), c);
          a.name = e;
          break;
        case 'x':
        case 'y':
          Sk.ffi.checkArgType(b, f, Sk.ffi.isNum(c), c);
          a[b] = e;
          break;
        case 'rotation':
          Sk.ffi.checkArgType('rotation', f, Sk.ffi.isNum(c), c);
          a.rotation = e;
          break;
        default:
          throw Sk.ffi.err.attribute(b).isNotSetableOnType(d);
        }
      }
      Sk.ffi.checkFunctionArgs('defineEasel', arguments, 3, 3);
      Sk.builtin.defineEuclidean2(a, c);
      Sk.builtin.defineEvent(a);
      var f = [
          Sk.ffi.PyType.FLOAT,
          Sk.ffi.PyType.INT,
          Sk.ffi.PyType.LONG
        ];
      a.Graphics = Sk.ffi.buildClass(a, function (c, d) {
        d.__init__ = Sk.ffi.functionPy(function (a, c) {
          Sk.ffi.checkMethodArgs('Graphics', arguments, 0, 1);
          Sk.ffi.isDefined(c) ? Sk.ffi.referenceToPy(Sk.ffi.remapToJs(c), 'Graphics', void 0, a) : Sk.ffi.referenceToPy(new b.Graphics(), 'Graphics', void 0, a);
        });
        d.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'beginFill':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, c) {
              c.__init__ = Sk.ffi.functionPy(function (a) {
                Sk.ffi.referenceToPy(d.beginFill, 'beginFill', void 0, a);
              });
              c.__call__ = Sk.ffi.functionPy(function (a, c) {
                c = Sk.ffi.remapToJs(c);
                d.beginFill(c);
                return b;
              });
            }, 'beginFill', []));
          case 'beginStroke':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, c) {
              c.__init__ = Sk.ffi.functionPy(function (a) {
                Sk.ffi.referenceToPy(d.beginStroke, 'beginStroke', void 0, a);
              });
              c.__call__ = Sk.ffi.functionPy(function (a, c) {
                c = Sk.ffi.remapToJs(c);
                d.beginStroke(c);
                return b;
              });
            }, 'beginStroke', []));
          case 'drawCircle':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, c) {
              c.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'drawCircle';
                a.v = d.drawCircle;
              });
              c.__call__ = Sk.ffi.functionPy(function (a, c, e, f) {
                c = Sk.ffi.remapToJs(c);
                e = Sk.ffi.remapToJs(e);
                f = Sk.ffi.remapToJs(f);
                d.drawCircle(c, e, f);
                return b;
              });
            }, 'drawCircle', []));
          case 'drawRect':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, c) {
              c.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'drawRect';
                a.v = d.drawRect;
              });
              c.__call__ = Sk.ffi.functionPy(function (a, c, e, f, n) {
                c = Sk.ffi.remapToJs(c);
                e = Sk.ffi.remapToJs(e);
                f = Sk.ffi.remapToJs(f);
                n = Sk.ffi.remapToJs(n);
                d.drawRect(c, e, f, n);
                return b;
              });
            }, 'drawRect', []));
          case 'drawRoundRect':
            return Sk.ffi.callableToPy(a, c, function (a, c, e, g, k, h) {
              Sk.ffi.checkMethodArgs('drawRoundRect', arguments, 5, 5);
              Sk.ffi.checkArgType('x', f, Sk.ffi.isNum(c), c);
              Sk.ffi.checkArgType('y', f, Sk.ffi.isNum(e), e);
              Sk.ffi.checkArgType('width', f, Sk.ffi.isNum(g), g);
              Sk.ffi.checkArgType('height', f, Sk.ffi.isNum(k), k);
              Sk.ffi.checkArgType('radius', f, Sk.ffi.isNum(h), h);
              var F = Sk.ffi.remapToJs(c), H = Sk.ffi.remapToJs(e), z = Sk.ffi.remapToJs(g), G = Sk.ffi.remapToJs(k), E = Sk.ffi.remapToJs(h);
              d.drawRoundRect(F, H, z, G, E);
              return b;
            });
          case 'endFill':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, c) {
              c.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'endFill';
                a.v = d.endFill;
              });
              c.__call__ = Sk.ffi.functionPy(function (a) {
                d.endFill();
                return b;
              });
            }, 'endFill', []));
          case 'endStroke':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, c) {
              c.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'endStroke';
                a.v = d.endStroke;
              });
              c.__call__ = Sk.ffi.functionPy(function (a) {
                d.endStroke();
                return b;
              });
            }, 'endStroke', []));
          case 'lineTo':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, c) {
              c.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'lineTo';
                a.v = d.lineTo;
              });
              c.__call__ = Sk.ffi.functionPy(function (a, c, e) {
                c = Sk.ffi.remapToJs(c);
                e = Sk.ffi.remapToJs(e);
                d.lineTo(c, e);
                return b;
              });
            }, 'lineTo', []));
          case 'moveTo':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, c) {
              c.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'moveTo';
                a.v = d.moveTo;
              });
              c.__call__ = Sk.ffi.functionPy(function (a, c, e) {
                c = Sk.ffi.remapToJs(c);
                e = Sk.ffi.remapToJs(e);
                d.moveTo(c, e);
                return b;
              });
            }, 'moveTo', []));
          case 'setStrokeStyle':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, c) {
              c.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'setStrokeStyle';
                a.v = d.setStrokeStyle;
              });
              c.__call__ = Sk.ffi.functionPy(function (a, c, e, f, n, p) {
                c = Sk.ffi.remapToJs(c);
                e = Sk.ffi.remapToJs(e);
                f = Sk.ffi.remapToJs(f);
                n = Sk.ffi.remapToJs(n);
                p = Sk.ffi.remapToJs(p);
                d.setStrokeStyle(c, e, f, n, p);
                return b;
              });
            }, 'setStrokeStyle', []));
          }
        });
      }, 'Graphics', []);
      a.MovieClip = Sk.ffi.buildClass(a, function (c, d) {
        d.__init__ = Sk.ffi.functionPy(function (a, c, d, e, f) {
          c = null !== c ? Sk.ffi.remapToJs(c) : null;
          d = Sk.ffi.remapToJs(d);
          e = Sk.ffi.remapToJs(e);
          f = Sk.ffi.remapToJs(f);
          Sk.ffi.referenceToPy(new b.MovieClip(c, d, e, f), 'MovieClip', void 0, a);
        });
        d.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'timeline':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (b, c) {
              c.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'timeline';
                a.v = d.timeline;
              });
              c.__getattr__ = Sk.ffi.functionPy(function (b, c) {
                var d = Sk.ffi.remapToJs(b);
                switch (c) {
                case 'addTween':
                  return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
                    b.__init__ = Sk.ffi.functionPy(function (a) {
                      a.tp$name = 'addTween';
                      a.v = d.addTween;
                    });
                    b.__call__ = Sk.ffi.functionPy(function (a, b) {
                      var c = Sk.ffi.remapToJs(b);
                      d.addTween(c);
                    });
                  }, 'addTween', []));
                }
              });
            }, 'timeline', []));
          case 'gotoAndPlay':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
              b.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'gotoAndPlay';
                a.v = d.gotoAndPlay;
              });
              b.__call__ = Sk.ffi.functionPy(function (a, b) {
                var c = Sk.ffi.remapToJs(b);
                d.gotoAndPlay(c);
              });
            }, 'gotoAndPlay', []));
          }
        });
      }, 'MovieClip', []);
      a.Shape = Sk.ffi.buildClass(a, function (a, c) {
        c.__init__ = Sk.ffi.functionPy(function (a, c) {
          Sk.ffi.checkMethodArgs('Shape', arguments, 0, 1);
          if (Sk.ffi.isUndefined(c))
            Sk.ffi.referenceToPy(new b.Shape(), 'Shape', void 0, a);
          else
            switch (Sk.ffi.checkArgType('graphics', 'Graphics', Sk.ffi.isInstance(c), c), Sk.ffi.typeName(c)) {
            case 'Shape':
              Sk.ffi.referenceToPy(Sk.ffi.remapToJs(c), 'Shape', void 0, a);
              break;
            case 'Graphics':
              Sk.ffi.referenceToPy(new b.Shape(Sk.ffi.remapToJs(c)), 'Shape', void 0, a);
              break;
            default:
              Sk.ffi.checkArgType('graphics', 'Graphics', !1, c);
            }
        });
        c.__getattr__ = Sk.ffi.functionPy(function (a, b) {
          return d(a, b, 'Shape');
        });
        c.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          return e(a, b, c, 'Shape');
        });
      }, 'Shape', []);
      a.Stage = Sk.ffi.buildClass(a, function (c, d) {
        d.__init__ = Sk.ffi.functionPy(function (a, c) {
          Sk.ffi.checkMethodArgs('Stage', arguments, 1, 1);
          Sk.ffi.checkArgType('canvas', 'Node', Sk.ffi.isObjectPy(c) || Sk.ffi.isInstance(c, 'Node'), c);
          var d = Sk.ffi.remapToJs(c);
          Sk.ffi.referenceToPy(new b.Stage(d), 'Stage', void 0, a);
        });
        d.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'mouseInBounds':
            return Sk.ffi.booleanToPy(d.mouseInBounds);
          case 'mouseMoveOutside':
            return Sk.ffi.booleanToPy(d.mouseMoveOutside);
          case 'mouseX':
            return Sk.ffi.numberToIntPy(d.mouseX);
          case 'mouseY':
            return Sk.ffi.numberToIntPy(d.mouseY);
          case 'addChild':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
              b.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'addChild';
                a.v = d.addChild;
              });
              b.__call__ = Sk.ffi.functionPy(function (a, b) {
                d.addChild(Sk.ffi.remapToJs(b));
                return b;
              });
            }, 'addChild', []));
          case 'enableMouseOver':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
              b.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'enableMouseOver';
                a.v = d.enableMouseOver;
              });
              b.__call__ = Sk.ffi.functionPy(function (a) {
                d.enableMouseOver();
              });
            }, 'enableMouseOver', []));
          case 'render':
          case 'update':
            return Sk.ffi.callableToPy(a, c, function (a) {
              d.update();
            });
          default:
            throw Sk.ffi.err.attribute(c).isNotGetableOnType('Stage');
          }
        });
        d.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          a = Sk.ffi.remapToJs(a);
          c = Sk.ffi.remapToJs(c);
          switch (b) {
          case 'autoClear':
            a.autoClear = c;
            break;
          case 'mouseMoveOutside':
            a.mouseMoveOutside = c;
            break;
          default:
            throw Sk.ffi.err.attribute(b).isNotSetableOnType('Stage');
          }
        });
      }, 'Stage', []);
      a.Text = Sk.ffi.buildClass(a, function (c, f) {
        f.__init__ = Sk.ffi.functionPy(function (a, c, d, e) {
          Sk.ffi.checkArgType('text', Sk.ffi.PyType.STR, Sk.builtin.isStringPy(c), c);
          Sk.ffi.checkArgType('font', Sk.ffi.PyType.STR, Sk.builtin.isStringPy(d), d);
          c = Sk.ffi.remapToJs(c);
          d = Sk.ffi.remapToJs(d);
          e = Sk.ffi.remapToJs(e);
          Sk.ffi.referenceToPy(new b.Text(c, d, e), 'Text', void 0, a);
        });
        f.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var e = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'text':
            return Sk.builtin.stringToPy(e.text);
          case 'textAlign':
            return Sk.builtin.stringToPy(e.textAlign);
          case 'getMeasuredWidth':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
              b.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'getMeasuredWidth';
                a.v = e.getMeasuredWidth;
              });
              b.__call__ = Sk.ffi.functionPy(function (a, b) {
                return Sk.builtin.numberToPy(e.getMeasuredWidth());
              });
            }, 'getMeasuredWidth', []));
          case 'getMeasuredHeight':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
              b.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'getMeasuredHeight';
                a.v = e.getMeasuredHeight;
              });
              b.__call__ = Sk.ffi.functionPy(function (a, b) {
                return Sk.builtin.numberToPy(e.getMeasuredHeight());
              });
            }, 'getMeasuredHeight', []));
          default:
            return d(b, c, 'Text');
          }
        });
        f.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          var d = Sk.ffi.remapToJs(a), f = Sk.ffi.remapToJs(c);
          switch (b) {
          case 'hitArea':
            d.hitArea = f;
            break;
          case 'text':
            d.text = Sk.ffi.remapToJs(Sk.builtin.isStringPy(c) ? c : Sk.ffh.str(c));
            break;
          case 'textAlign':
            d.textAlign = f;
            break;
          default:
            return e(a, b, c, 'Text');
          }
        });
        f.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.builtin.stringToPy('Text(' + a.x + ', ' + a.y + ')');
        });
        f.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.builtin.stringToPy('[' + a.x + ', ' + a.y + ']');
        });
      }, 'Text', []);
      a.Ticker = Sk.ffi.callsim(Sk.ffi.buildClass(a, function (c, d) {
        d.__init__ = Sk.ffi.functionPy(function (a) {
          a.tp$name = 'Ticker';
          a.v = b.Ticker;
        });
        d.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'addEventListener':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
              b.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'addEventListener';
              });
              b.__call__ = Sk.ffi.functionPy(function (a, b, c, e) {
                a = Sk.ffi.remapToJs(b);
                b = Sk.ffi.remapToJs(c);
                'object' !== typeof b && (b = function (a) {
                  Sk.ffi.callsim(c);
                });
                d.addEventListener(a, b, e);
              });
            }, 'addEventListener', []));
          }
        });
      }, 'Ticker', []));
      a.Tween = Sk.ffi.callsim(Sk.ffi.buildClass(a, function (c, d) {
        d.__init__ = Sk.ffi.functionPy(function (a) {
          a.tp$name = 'Tween';
          a.v = b.Tween;
        });
        d.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'get':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (b, c) {
              c.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'get';
              });
              c.__call__ = Sk.ffi.functionPy(function (b, c, e, f, n) {
                c = Sk.ffi.remapToJs(c);
                e = Sk.ffi.remapToJs(e);
                f = Sk.ffi.remapToJs(f);
                n = Sk.ffi.remapToJs(n);
                var p = d.get(c, e, f, n);
                return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (b, c) {
                  c.__init__ = Sk.ffi.functionPy(function (a) {
                    a.tp$name = 'Tween';
                    a.v = p;
                  });
                  c.__getattr__ = Sk.ffi.functionPy(function (b, c) {
                    var d = Sk.ffi.remapToJs(b);
                    switch (c) {
                    case 'to':
                      return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, c) {
                        c.__init__ = Sk.ffi.functionPy(function (a) {
                          a.tp$name = 'to';
                        });
                        c.__call__ = Sk.ffi.functionPy(function (a, c, e, f) {
                          c = Sk.ffi.remapToJs(c);
                          e = Sk.ffi.remapToJs(e);
                          f = Sk.ffi.remapToJs(f);
                          d.to(c, e, f);
                          return b;
                        });
                      }, 'to', []));
                    case 'onComplete':
                      return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, c) {
                        c.__init__ = Sk.ffi.functionPy(function (a) {
                          a.tp$name = 'onComplete';
                        });
                        c.__call__ = Sk.ffi.functionPy(function (a, c, e) {
                          a = Sk.ffi.remapToJs(e);
                          d.call(function (a) {
                            Sk.ffi.callsim(c, Sk.ffi.remapToPy(a));
                          }, a);
                          return b;
                        });
                      }, 'onComplete', []));
                    case 'wait':
                      return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, c) {
                        c.__init__ = Sk.ffi.functionPy(function (a) {
                          a.tp$name = 'wait';
                        });
                        c.__call__ = Sk.ffi.functionPy(function (a, c) {
                          c = Sk.ffi.remapToJs(c);
                          d.wait(c);
                          return b;
                        });
                      }, 'wait', []));
                    }
                  });
                }, 'Tween', []));
              });
            }, 'get', []));
          }
        });
      }, 'Tween', []));
      a.Container = Sk.ffi.buildClass(a, function (c, d) {
        d.__init__ = Sk.ffi.functionPy(function (a, c) {
          Sk.ffi.isUndefined(c) ? Sk.ffi.referenceToPy(new b.Container(), 'Container', void 0, a) : Sk.ffi.referenceToPy(Sk.ffi.remapToJs(c), 'Container', void 0, a);
        });
        d.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'name':
            return Sk.builtin.stringToPy(d.name);
          case 'x':
            return Sk.builtin.numberToPy(d.x);
          case 'y':
            return Sk.builtin.numberToPy(d.y);
          case 'rotation':
            return Sk.builtin.numberToPy(d.rotation);
          case 'addChild':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
              b.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'addChild';
                a.v = d.addChild;
              });
              b.__call__ = Sk.ffi.functionPy(function (a, b) {
                d.addChild(Sk.ffi.remapToJs(b));
                return b;
              });
            }, 'addChild', []));
          case 'addEventListener':
            return Sk.builtin.addEventListener(a, d);
          case 'getChildAt':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (b, c) {
              c.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'getChildAt';
                a.v = d.getChildAt;
              });
              c.__call__ = Sk.ffi.functionPy(function (b, c) {
                var e = d.getChildAt(Sk.ffi.remapToJs(c));
                return Sk.ffi.callsim(a.Shape, Sk.ffi.referenceToPy(e, 'Shape'));
              });
            }, 'getChildAt', []));
          case 'getNumChildren':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
              b.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'getNumChildren';
                a.v = d.getNumChildren;
              });
              b.__call__ = Sk.ffi.functionPy(function (a, b) {
                return Sk.ffi.numberToIntPy(d.getNumChildren());
              });
            }, 'getNumChildren', []));
          case 'removeEventListener':
            return Sk.builtin.removeEventListener(a, d);
          }
        });
        d.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          a = Sk.ffi.remapToJs(a);
          c = Sk.ffi.remapToJs(c);
          switch (b) {
          case 'name':
            a.name = c;
            break;
          case 'x':
            a.x = c;
            break;
          case 'y':
            a.y = c;
            break;
          case 'rotation':
            a.rotation = c;
            break;
          default:
            throw new Sk.builtin.AttributeError(b + ' is not a writeable attribute of Container');
          }
        });
        d.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.builtin.stringToPy('Container(' + a.x + ', ' + a.y + ')');
        });
        d.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.builtin.stringToPy('[' + a.x + ', ' + a.y + ']');
        });
      }, 'Container', []);
      a.Ease = Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, c) {
        c.__init__ = Sk.ffi.functionPy(function (a) {
          a.tp$name = 'Ease';
          a.v = b.Ease;
        });
        c.__getattr__ = Sk.ffi.functionPy(function (a, c) {
          switch (c) {
          case 'bounceOut':
            return { v: b.Ease.bounceOut };
          }
        });
      }, 'Ease', []));
      a.Point = Sk.ffi.buildClass(a, function (c, d) {
        d.__init__ = Sk.ffi.functionPy(function (a, c, d) {
          Sk.builtin.pyCheckArgs('Point', arguments, 1, 3);
          a.tp$name = 'Point';
          switch (arguments.length) {
          case 1:
            a.v = new b.Point();
            break;
          case 2:
            c = Sk.ffi.remapToJs(c);
            a.tp$name = 'Point';
            a.v = c;
            break;
          case 3:
            Sk.builtin.pyCheckType('x', 'number', Sk.builtin.checkNumber(c)), Sk.builtin.pyCheckType('y', 'number', Sk.builtin.checkNumber(d)), c = Sk.ffi.remapToJs(c), d = Sk.ffi.remapToJs(d), a.tp$name = 'Point', a.v = new b.Point(c, d);
          }
        });
        d.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'x':
            return Sk.ffi.numberToFloatPy(d.x);
          case 'y':
            return Sk.ffi.numberToFloatPy(d.y);
          case 'clone':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (b, c) {
              c.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'clone';
              });
              c.__call__ = Sk.ffi.functionPy(function (b) {
                return Sk.ffi.callsim(a.Point, Sk.ffi.numberToFloatPy(d.x), Sk.ffi.numberToFloatPy(d.y));
              });
            }, 'clone', []));
          }
        });
        d.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          a = Sk.ffi.remapToJs(a);
          c = Sk.ffi.remapToJs(c);
          switch (b) {
          case 'x':
            a.x = c;
            break;
          case 'y':
            a.y = c;
          }
        });
        d.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.builtin.stringToPy('Point(' + a.x + ', ' + a.y + ')');
        });
        d.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.builtin.stringToPy('[' + a.x + ', ' + a.y + ']');
        });
      }, 'Point', []);
      a.getHSL = Sk.ffi.functionPy(function (a, c, d, e) {
        a = Sk.ffi.remapToJs(a);
        c = Sk.ffi.remapToJs(c);
        d = Sk.ffi.remapToJs(d);
        e = Sk.ffi.remapToJs(e);
        return Sk.builtin.stringToPy(b.Graphics.getHSL(a, c, d, e));
      });
    };
  }.call(this));
  Sk.builtin.defineEvent = function (a) {
    a.Event = Sk.ffi.buildClass(a, function (b, c) {
      c.__init__ = Sk.ffi.functionPy(function (a, b) {
        Sk.ffi.referenceToPy(Sk.ffi.remapToJs(b), 'Event', void 0, a);
      });
      c.__getattr__ = Sk.ffi.functionPy(function (b, c) {
        var f = Sk.ffi.remapToJs(b);
        switch (c) {
        case 'altKey':
          return Sk.ffi.booleanToPy(f.altKey);
        case 'bubbles':
          return Sk.ffi.booleanToPy(f.bubbles);
        case 'button':
          return Sk.ffi.numberToIntPy(f.button);
        case 'cancelable':
          return Sk.ffi.booleanToPy(f.cancelable);
        case 'clientX':
          return Sk.ffi.numberToIntPy(f.clientX);
        case 'clientY':
          return Sk.ffi.numberToIntPy(f.clientY);
        case 'ctrlKey':
          return Sk.ffi.booleanToPy(f.ctrlKey);
        case 'defaultPrevented':
          return Sk.ffi.booleanToPy(f.defaultPrevented);
        case 'keyCode':
          return Sk.ffi.numberToIntPy(f.keyCode);
        case 'screenX':
          return Sk.ffi.numberToIntPy(f.screenX);
        case 'screenY':
          return Sk.ffi.numberToIntPy(f.screenY);
        case 'shiftKey':
          return Sk.ffi.booleanToPy(f.shiftKey);
        case 'target':
          return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
            b.__init__ = Sk.ffi.functionPy(function (a) {
              Sk.ffi.referenceToPy(f.target, 'target', void 0, a);
            });
            b.__getattr__ = Sk.ffi.functionPy(function (a, b) {
              return Sk.ffi.remapToPy(f.target[b], '');
            });
            b.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
              f.target[b] = Sk.ffi.remapToJs(c);
            });
            b.__str__ = Sk.ffi.functionPy(function (a) {
              a = Sk.ffi.remapToJs(a);
              return Sk.builtin.stringToPy('' + a);
            });
            b.__repr__ = Sk.ffi.functionPy(function (a) {
              a = Sk.ffi.remapToJs(a);
              return Sk.builtin.stringToPy('' + a);
            });
          }, 'target', []));
        case 'type':
          return Sk.builtin.stringToPy(f.type);
        case 'addEventListener':
          return Sk.builtin.addEventListener(a, f);
        case 'preventDefault':
          return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
            b.__init__ = Sk.ffi.functionPy(function (a) {
              a.tp$name = 'preventDefault';
            });
            b.__call__ = Sk.ffi.functionPy(function (a) {
              f.preventDefault();
            });
            b.__str__ = Sk.ffi.functionPy(function (a) {
              return Sk.builtin.stringToPy('preventDefault');
            });
            b.__repr__ = Sk.ffi.functionPy(function (a) {
              return Sk.builtin.stringToPy('preventDefault');
            });
          }, 'preventDefault', []));
        case 'stopImmediatePropagation':
          return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
            b.__init__ = Sk.ffi.functionPy(function (a) {
              a.tp$name = 'stopImmediatePropagation';
            });
            b.__call__ = Sk.ffi.functionPy(function (a) {
              f.stopImmediatePropagation();
            });
            b.__str__ = Sk.ffi.functionPy(function (a) {
              return Sk.builtin.stringToPy('stopImmediatePropagation');
            });
            b.__repr__ = Sk.ffi.functionPy(function (a) {
              return Sk.builtin.stringToPy('stopImmediatePropagation');
            });
          }, 'stopImmediatePropagation', []));
        case 'stopPropagation':
          return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
            b.__init__ = Sk.ffi.functionPy(function (a) {
              a.tp$name = 'stopPropagation';
            });
            b.__call__ = Sk.ffi.functionPy(function (a) {
              f.stopPropagation();
            });
            b.__str__ = Sk.ffi.functionPy(function (a) {
              return Sk.builtin.stringToPy('stopPropagation');
            });
            b.__repr__ = Sk.ffi.functionPy(function (a) {
              return Sk.builtin.stringToPy('stopPropagation');
            });
          }, 'stopPropagation', []));
        default:
          return Sk.ffi.remapToPy(f[c], '');
        }
      });
      c.__str__ = Sk.ffi.functionPy(function (a) {
        a = Sk.ffi.remapToJs(a);
        return Sk.builtin.stringToPy('' + a);
      });
      c.__repr__ = Sk.ffi.functionPy(function (a) {
        a = Sk.ffi.remapToJs(a);
        return Sk.builtin.stringToPy('' + a);
      });
    }, 'Event', []);
  };
  Sk.builtin.addEventListener = function (a, b) {
    return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (c, d) {
      d.__init__ = Sk.ffi.functionPy(function (a) {
        Sk.ffi.referenceToPy(b.addEventListener, 'addEventListener', void 0, a);
      });
      d.__call__ = Sk.ffi.functionPy(function (c, d, g, h) {
        c = Sk.ffi.remapToJs(d);
        h = Sk.ffi.remapToJs(h);
        b.addEventListener(c, function (b) {
          b = Sk.ffi.callsim(a.Event, Sk.ffi.referenceToPy(b, 'Event'));
          Sk.ffi.callsim(g, b);
        }, h);
      });
    }, 'addEventListener', []));
  };
  Sk.builtin.removeEventListener = function (a, b) {
    return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (c, d) {
      d.__init__ = Sk.ffi.functionPy(function (a) {
        Sk.ffi.referenceToPy(b.removeEventListener, 'removeEventListener', void 0, a);
      });
      d.__call__ = Sk.ffi.functionPy(function (c, d, g, h) {
        c = Sk.ffi.remapToJs(d);
        h = Sk.ffi.remapToJs(h);
        b.removeEventListener(c, function (b) {
          b = Sk.ffi.callsim(a.Event, Sk.ffi.referenceToPy(b, 'Event'));
          Sk.ffi.callsim(g, b);
        }, h);
      });
    }, 'removeEventListener', []));
  };
  Sk.geometry = {};
  Sk.geometry.ARROW_BUILDER = 'ArrowBuilder';
  Sk.geometry.CYLINDER_BUILDER = 'CylinderBuilder';
  Sk.geometry.VORTEX_BUILDER = 'VortexBuilder';
  Sk.geometry.VOLUME_BUILDER = 'VolumeBuilder';
  Sk.geometry.VOLUME = 'Volume';
  (function () {
    Sk.builtin.defineGeometry = function (a, b, c) {
      function d(b) {
        var c = Sk.ffi.remapToJs(b);
        return Sk.ffi.callableToPy(a, 'name', function (a, d) {
          Sk.ffi.checkMethodArgs('name', arguments, 1, 1);
          Sk.ffi.checkArgType('name', Sk.ffi.PyType.STR, Sk.builtin.isStringPy(d), d);
          c.name = Sk.builtin.stringToJs(d);
          return b;
        });
      }
      function e(b) {
        if (b.material)
          return b.material;
        var c = {};
        c.color = 'undefined' !== typeof b.color ? b.color : 16777215;
        'undefined' !== typeof b.wireframeLinewidth && (c.wireframeLinewidth = b.wireframeLinewidth);
        if ('undefined' !== typeof b.wireframe)
          return (c.wireframe = b.wireframe) ? Sk.ffi.callsim(a.MeshBasicMaterial, Sk.ffi.remapToPy(c)) : Sk.ffi.callsim(a.MeshLambertMaterial, Sk.ffi.remapToPy(c));
        c.wireframe = !1;
        return Sk.ffi.callsim(a.MeshLambertMaterial, Sk.ffi.remapToPy(c));
      }
      function f(b, c) {
        function d(a) {
          var b = Sk.ffi.remapToJs(a);
          c.name && (b.name = c.name);
          return a;
        }
        if (c.material)
          return d(Sk.ffi.callsim(a.Mesh, b, c.material));
        var e = {};
        e.color = 'undefined' !== typeof c.color ? c.color : 16777215;
        'undefined' !== typeof c.wireframeLinewidth && (e.wireframeLinewidth = c.wireframeLinewidth);
        'undefined' !== typeof c.wireframe ? e = (e.wireframe = c.wireframe) ? Sk.ffi.callsim(a.MeshBasicMaterial, Sk.ffi.remapToPy(e)) : Sk.ffi.callsim(a.MeshLambertMaterial, Sk.ffi.remapToPy(e)) : (e.wireframe = !1, e = Sk.ffi.callsim(a.MeshLambertMaterial, Sk.ffi.remapToPy(e)));
        return d(Sk.ffi.callsim(a.Mesh, b, e));
      }
      function g(a) {
        a = [
          [
            +a,
            0,
            0
          ],
          [
            0,
            +a,
            0
          ],
          [
            0,
            0,
            +a
          ],
          [
            -a,
            0,
            0
          ],
          [
            0,
            -a,
            0
          ],
          [
            0,
            0,
            -a
          ]
        ].map(function (a) {
          var c = new b.Geometry();
          c.vertices.push(new b.Vector3(0, 0, 0));
          c.vertices.push(new b.Vector3(a[0], a[1], a[2]));
          return c;
        });
        var c = new b[Sk.three.OBJECT_3D]();
        c.add(new b.Line(a[0], new b.LineBasicMaterial({
          color: 16711680,
          opacity: 0.5,
          transparent: !0
        })));
        c.add(new b.Line(a[1], new b.LineBasicMaterial({
          color: 65280,
          opacity: 0.5,
          transparent: !0
        })));
        c.add(new b.Line(a[2], new b.LineBasicMaterial({
          color: 255,
          opacity: 0.5,
          transparent: !0
        })));
        c.add(new b.Line(a[3], new b.LineBasicMaterial({
          color: 16711680,
          opacity: 0.2,
          transparent: !0
        })));
        c.add(new b.Line(a[4], new b.LineBasicMaterial({
          color: 65280,
          opacity: 0.2,
          transparent: !0
        })));
        c.add(new b.Line(a[5], new b.LineBasicMaterial({
          color: 255,
          opacity: 0.2,
          transparent: !0
        })));
        return c;
      }
      function h(a, c, d, e, f) {
        var q = new b[Sk.three.OBJECT_3D](), n = a * c, g = d / c, k = a * d;
        a = f.x * k;
        d = f.y * k;
        f = f.z * k;
        for (k = -n; k <= n; k += 1)
          if (0 != k) {
            var h = k * g, x = new b.Geometry();
            x.vertices.push(new b.Vector3(e.x * h - a, e.y * h - d, e.z * h - f));
            x.vertices.push(new b.Vector3(e.x * h + a, e.y * h + d, e.z * h + f));
            h = new b.Line(x, 0 === k % c ? m : p);
            q.add(h);
          }
        return q;
      }
      function l(b, c, e) {
        var f = Sk.ffi.remapToJs(b);
        switch (c) {
        case 'attitude':
          return Sk.ffi.callableToPy(a, c, function (a, d) {
            Sk.ffi.checkMethodArgs(c, arguments, 1, 1);
            Sk.ffi.checkArgType(c, 'Euclidean3', Sk.ffi.isInstance(d, 'Euclidean3'), d);
            f[c] = Sk.ffi.remapToJs(d);
            return b;
          });
        case 'color':
          return Sk.ffi.callableToPy(a, c, function (a, d) {
            Sk.ffi.checkMethodArgs(c, arguments, 1, 1);
            Sk.ffi.checkArgType(c, k, Sk.ffi.isNum(d) || Sk.builtin.isStringPy(d) || Sk.ffi.isInstance(d, 'Color'), d);
            f[c] = Sk.ffi.remapToJs(d);
            return b;
          });
        case 'material':
          return Sk.ffi.callableToPy(a, 'material', function (a, c) {
            Sk.ffi.checkMethodArgs('material', arguments, 1, 1);
            Sk.ffi.checkArgType('material', Sk.three.MATERIAL, Sk.ffi.isInstance(c), c);
            f.material = c;
            return b;
          });
        case 'name':
          return d(b);
        case 'scale':
          return Sk.ffi.callableToPy(a, 'scale', function (a, c) {
            Sk.ffi.checkMethodArgs('scale', arguments, 1, 1);
            Sk.ffi.checkArgType('scale', [
              k,
              Sk.ffi.PyType.NONE
            ], Sk.ffi.isNum(c) || Sk.ffi.isNone(c), c);
            f.scale = Sk.ffi.remapToJs(c);
            return b;
          });
        case 'volume':
          return Sk.ffi.callableToPy(a, 'volume', function (a, c) {
            Sk.ffi.checkMethodArgs('volume', arguments, 1, 1);
            Sk.ffi.checkArgType('volume', k, Sk.ffi.isNum(c) || Sk.ffi.isNone(c), c);
            f.volume = Sk.ffi.remapToJs(c);
            return b;
          });
        case 'wireframe':
          return Sk.ffi.callableToPy(a, c, function (a, d) {
            Sk.ffi.checkMethodArgs(c, arguments, 1, 1);
            Sk.ffi.checkArgType(c, Sk.ffi.PyType.BOOL, Sk.ffi.isBool(d), d);
            f[c] = Sk.ffi.remapToJs(d);
            return b;
          });
        case 'wireframeLinewidth':
          return Sk.ffi.callableToPy(a, c, function (a, d) {
            Sk.ffi.checkMethodArgs(c, arguments, 1, 1);
            Sk.ffi.checkArgType(c, Sk.ffi.PyType.INT, Sk.ffi.isInt(d), d);
            f[c] = Sk.ffi.remapToJs(d);
            return b;
          });
        default:
          throw Sk.ffi.err.attribute(c).isNotGetableOnType(e);
        }
      }
      Sk.ffi.checkFunctionArgs('defineGeometry', arguments, 3, 3);
      var k = [
          Sk.ffi.PyType.FLOAT,
          Sk.ffi.PyType.INT,
          Sk.ffi.PyType.LONG
        ], m = new b.LineBasicMaterial({
          color: 6726098,
          opacity: 0.2,
          transparent: !0
        }), p = new b.LineBasicMaterial({
          color: 6726098,
          opacity: 0.02,
          transparent: !0
        }), n = new b.Vector3(1, 0, 0), q = new b.Vector3(0, 1, 0);
      new b.Vector3(0, 0, 1);
      var x = new b.Euclidean3(!1, new b.Vector3(0, 0, 1), new b.Quaternion(0, 0, 0, 0), 0, !1), D = new b.Euclidean3(!1, new b.Vector3(0, 0, 0), new b.Quaternion(0, 0, 0, 1), 0, !1);
      a.world = Sk.ffi.functionPy(function () {
        Sk.ffi.checkFunctionArgs('world', arguments, 0, 0);
        var c = Sk.ffi.callsim(a.Scene), d = Sk.ffi.remapToJs(c), e = new b.PointLight(16777215);
        e.position.set(5, 5, 5);
        d.add(e);
        d.add(new b.AmbientLight(2236962));
        return c;
      });
      a.CartesianSpace = Sk.ffi.buildClass(a, function (b, c) {
        c.__init__ = Sk.ffi.functionPy(function (b, c, d, e) {
          var f, p, m;
          Sk.ffi.checkMethodArgs('CartesianSpace(scene, renderer)', arguments, 0, 3);
          Sk.ffi.isDefined(c) || (c = Sk.ffi.callsim(a.world));
          f = Sk.ffi.remapToJs(c);
          Sk.ffi.isDefined(d) || (d = Sk.ffi.callsim(a.WebGLRenderer, Sk.ffi.remapToPy({ antialias: !0 })));
          p = Sk.ffi.remapToJs(d);
          Sk.ffi.isDefined(e) || (e = Sk.ffi.callsim(a.PerspectiveCamera, Sk.ffi.numberToFloatPy(45), Sk.ffi.numberToFloatPy(1), Sk.ffi.numberToFloatPy(0.1), Sk.ffi.numberToFloatPy(10000)));
          m = Sk.ffi.remapToJs(e);
          m.up.set(0, 0, 1);
          m.position.set(8, 4, 5);
          m.lookAt(f.position);
          p.setClearColor(526344, 1);
          f.add(g(1000));
          f.add(h(5, 10, 1, n, q));
          f.add(h(5, 10, 1, q, n));
          Sk.ffi.referenceToPy({
            scenePy: c,
            cameraPy: e,
            rendererPy: d
          }, 'CartesianSpace', void 0, b);
        });
        c.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'camera':
            return d.cameraPy;
          case 'origin':
            return Sk.ffi.gattr(d.scenePy, 'position');
          case 'renderer':
            return d.rendererPy;
          case 'scene':
            return d.scenePy;
          case 'add':
            return Sk.ffi.gattr(d.scenePy, 'add');
          case 'render':
            return Sk.ffi.callableToPy(a, 'render', function (a) {
              a = Sk.ffi.gattr(d.rendererPy, 'render');
              return Sk.ffi.callsim(a, d.scenePy, d.cameraPy);
            });
          case 'viewSize':
            return Sk.ffi.callableToPy(a, 'render', function (a, b, c) {
              Sk.ffi.checkMethodArgs('viewSize', arguments, 2, 2);
              Sk.ffi.checkArgType('width', Sk.ffi.PyType.INT, Sk.ffi.isInt(b), b);
              Sk.ffi.checkArgType('height', Sk.ffi.PyType.INT, Sk.ffi.isInt(c), c);
              var e = Sk.ffi.remapToJs(b), f = Sk.ffi.remapToJs(c);
              Sk.ffi.remapToJs(d.rendererPy).setSize(e, f);
              var q = Sk.ffi.remapToJs(d.cameraPy);
              q.aspect = e / f;
              q.updateProjectionMatrix();
            });
          default:
            throw Sk.ffi.err.attribute(c).isNotGetableOnType('CartesianSpace');
          }
        });
        c.__str__ = Sk.ffi.functionPy(function (a) {
          return Sk.builtin.stringToPy('CartesianSpace');
        });
        c.__repr__ = Sk.ffi.functionPy(function (a) {
          return Sk.builtin.stringToPy('CartesianSpace');
        });
      }, 'CartesianSpace', []);
      Sk.geometry.ArrowBuilder = function () {
        this._innerPy = Sk.ffi.callsim(a[Sk.geometry.ARROW_BUILDER]);
      };
      Sk.geometry.ArrowBuilder.prototype = {
        constructor: Sk.geometry.ArrowBuilder,
        axis: function (b, c, d) {
          b = Sk.ffi.numberToFloatPy(b);
          c = Sk.ffi.numberToFloatPy(c);
          d = Sk.ffi.numberToFloatPy(d);
          d = Sk.ffi.callsim(a[Sk.e3ga.VECTOR_E3], b, c, d);
          Sk.ffi.callsim(Sk.ffi.gattr(this._innerPy, 'axis'), d);
          return this;
        },
        material: function (b) {
          b = Sk.ffi.callsim(a[Sk.three.MATERIAL], Sk.ffi.referenceToPy(b, Sk.three.MATERIAL));
          Sk.ffi.callsim(Sk.ffi.gattr(this._innerPy, 'material'), b);
          return this;
        },
        radius: function (a) {
          a = Sk.ffi.numberToFloatPy(a);
          Sk.ffi.callsim(Sk.ffi.gattr(this._innerPy, 'radius'), a);
          return this;
        },
        build: function () {
          return Sk.ffi.remapToJs(Sk.ffi.callsim(Sk.ffi.gattr(this._innerPy, 'build')));
        }
      };
      a[Sk.geometry.ARROW_BUILDER] = Sk.ffi.buildClass(a, function (b, c) {
        c.__init__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.checkMethodArgs(Sk.geometry.ARROW_BUILDER, arguments, 0, 0);
          Sk.ffi.referenceToPy({}, Sk.geometry.ARROW_BUILDER, void 0, a);
        });
        c.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'magnitude':
            return Sk.ffi.callableToPy(a, 'magnitude', function (a, c) {
              Sk.ffi.checkMethodArgs('magnitude', arguments, 1, 1);
              Sk.ffi.checkArgType('magnitude', [
                k,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isNum(c) || Sk.ffi.isNone(c), c);
              d.magnitude = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'axis':
            return Sk.ffi.callableToPy(a, 'axis', function (a, c) {
              Sk.ffi.checkMethodArgs('axis', arguments, 1, 1);
              Sk.ffi.checkArgType('axis', [
                'Euclidean3',
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isInstance(c, 'Euclidean3') || Sk.ffi.isNone(c), c);
              d.axis = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'radius':
            return Sk.ffi.callableToPy(a, 'radius', function (a, c) {
              Sk.ffi.checkMethodArgs('radius', arguments, 1, 1);
              Sk.ffi.checkArgType('radius', [
                k,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isNum(c) || Sk.ffi.isNone(c), c);
              d.radius = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'segments':
            return Sk.ffi.callableToPy(a, 'segments', function (a, c) {
              Sk.ffi.checkMethodArgs('segments', arguments, 1, 1);
              Sk.ffi.checkArgType('segments', [
                Sk.ffi.PyType.INT,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isInt(c) || Sk.ffi.isNone(c), c);
              d.segments = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'build':
            return Sk.ffi.callableToPy(a, 'build', function (b) {
              Sk.ffi.checkMethodArgs('build', arguments, 0, 0);
              var c, e = {};
              e.attitude = d.attitude ? d.attitude : D;
              e.axis = d.axis ? d.axis : x;
              if (d.volume) {
                var q = (d.radius ? d.radius : 0.5) / (d.length ? d.length : 1);
                e.radius = Math.pow(3 * q * d.volume / Math.PI, 1 / 3);
                e.length = e.radius / q;
              } else
                e.scale = d.scale ? d.scale : 1, e.radius = d.radius ? d.radius : 0.5, e.length = d.length ? d.length : 1;
              c = e;
              var e = Sk.ffi.numberToFloatPy(c.scale), q = Sk.ffi.callsim(a.Euclidean3, Sk.ffi.referenceToPy(c.attitude, 'Euclidean3')), n = Sk.ffi.numberToIntPy(d.segments ? d.segments : 32), p = Sk.ffi.numberToFloatPy(c.magnitude);
              c = Sk.ffi.callsim(a.Euclidean3, Sk.ffi.referenceToPy(c.axis, 'Euclidean3'));
              e = Sk.ffi.callsim(a[Sk.three.ARROW_GEOMETRY], e, q, n, p, void 0, void 0, void 0, c);
              return f(e, d);
            });
          case 'normalize':
            return Sk.ffi.callableToPy(a, 'normalize', function (a) {
              Sk.ffi.checkMethodArgs('normalize', arguments, 0, 0);
              return b;
            });
          default:
            return l(b, c, Sk.geometry.ARROW_BUILDER);
          }
        });
        c.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.builtin.stringToPy('' + a);
        });
        c.__repr__ = Sk.ffi.functionPy(function (a) {
          return Sk.builtin.stringToPy(Sk.geometry.ARROW_BUILDER + '()');
        });
      }, Sk.geometry.ARROW_BUILDER, []);
      a.ConeBuilder = Sk.ffi.buildClass(a, function (b, c) {
        c.__init__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.checkMethodArgs('ConeBuilder', arguments, 0, 0);
          Sk.ffi.referenceToPy({}, 'ConeBuilder', void 0, a);
        });
        c.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'height':
            return Sk.ffi.callableToPy(a, 'height', function (a, c) {
              Sk.ffi.checkMethodArgs('height', arguments, 1, 1);
              Sk.ffi.checkArgType('height', [
                k,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isNum(c) || Sk.ffi.isNone(c), c);
              d.height = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'radius':
            return Sk.ffi.callableToPy(a, 'radius', function (a, c) {
              Sk.ffi.checkMethodArgs('radius', arguments, 1, 1);
              Sk.ffi.checkArgType('radius', [
                k,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isNum(c) || Sk.ffi.isNone(c), c);
              d.radius = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'segments':
            return Sk.ffi.callableToPy(a, 'segments', function (a, c) {
              Sk.ffi.checkMethodArgs('segments', arguments, 1, 1);
              Sk.ffi.checkArgType('segments', [
                Sk.ffi.PyType.INT,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isInt(c) || Sk.ffi.isNone(c), c);
              d.segments = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'build':
            return Sk.ffi.callableToPy(a, 'build', function (b) {
              Sk.ffi.checkMethodArgs('build', arguments, 0, 0);
              var c, e = {};
              if (d.volume) {
                var q = (d.radius ? d.radius : 0.5) / (d.height ? d.height : 1);
                e.radius = Math.pow(3 * q * d.volume / Math.PI, 1 / 3);
                e.height = e.radius / q;
              } else
                e.radius = d.radius ? d.radius : 0.5, e.height = d.height ? d.height : 1;
              c = e;
              e = Sk.ffi.numberToFloatPy(0);
              q = Sk.ffi.numberToFloatPy(c.radius);
              c = Sk.ffi.numberToFloatPy(c.height);
              var n = Sk.ffi.numberToIntPy(d.segments ? d.segments : 32), p = Sk.ffi.numberToIntPy(1), g = Sk.ffi.booleanToPy(!1), e = Sk.ffi.callsim(a.CylinderGeometry, e, q, c, n, p, g);
              return f(e, d);
            });
          case 'normalize':
            return Sk.ffi.callableToPy(a, 'normalize', function (a) {
              Sk.ffi.checkMethodArgs('normalize', arguments, 0, 0);
              return b;
            });
          default:
            return l(b, c, 'ConeBuilder');
          }
        });
        c.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.builtin.stringToPy('' + a);
        });
        c.__repr__ = Sk.ffi.functionPy(function (a) {
          return Sk.builtin.stringToPy('ConeBuilder()');
        });
      }, 'ConeBuilder', []);
      a.CubeBuilder = Sk.ffi.buildClass(a, function (b, c) {
        c.__init__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.checkMethodArgs('CubeBuilder', arguments, 0, 0);
          Sk.ffi.referenceToPy({}, 'CubeBuilder', void 0, a);
        });
        c.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'depth':
            return Sk.ffi.callableToPy(a, 'depth', function (a, c) {
              Sk.ffi.checkMethodArgs('depth', arguments, 1, 1);
              Sk.ffi.checkArgType('depth', [
                k,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isNum(c) || Sk.ffi.isNone(c), c);
              d.depth = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'height':
            return Sk.ffi.callableToPy(a, 'height', function (a, c) {
              Sk.ffi.checkMethodArgs('height', arguments, 1, 1);
              Sk.ffi.checkArgType('height', [
                k,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isNum(c) || Sk.ffi.isNone(c), c);
              d.height = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'width':
            return Sk.ffi.callableToPy(a, 'width', function (a, c) {
              Sk.ffi.checkMethodArgs('width', arguments, 1, 1);
              Sk.ffi.checkArgType('width', [
                k,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isNum(c) || Sk.ffi.isNone(c), c);
              d.width = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'segments':
            return Sk.ffi.callableToPy(a, 'segments', function (a, c) {
              Sk.ffi.checkMethodArgs('segments', arguments, 1, 1);
              Sk.ffi.checkArgType('segments', [
                Sk.ffi.PyType.INT,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isInt(c) || Sk.ffi.isNone(c), c);
              d.segments = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'build':
            return Sk.ffi.callableToPy(a, 'build', function (b) {
              Sk.ffi.checkMethodArgs('build', arguments, 0, 0);
              var c, e = {};
              if (d.volume) {
                var q = d.width ? d.width : 1;
                c = d.height ? d.height : 1;
                var n = d.depth ? d.depth : 1, p = Math.pow(d.volume / (q * c * n), 1 / 3);
                e.width = p * q;
                e.height = p * c;
                e.depth = p * n;
              } else
                e.width = d.width ? d.width : 1, e.height = d.height ? d.height : 1, e.depth = d.depth ? d.depth : 1;
              c = e;
              e = Sk.ffi.numberToFloatPy(c.width);
              q = Sk.ffi.numberToFloatPy(c.height);
              c = Sk.ffi.numberToFloatPy(c.depth);
              n = Sk.ffi.numberToIntPy(d.segments ? d.segments : 1);
              e = Sk.ffi.callsim(a.BoxGeometry, e, q, c, n, n, n);
              return f(e, d);
            });
          case 'normalize':
            return Sk.ffi.callableToPy(a, 'normalize', function (a) {
              Sk.ffi.checkMethodArgs('normalize', arguments, 0, 0);
              d.depth = 1;
              d.width = 1;
              d.height = 1;
              return b;
            });
          default:
            return l(b, c, 'CubeBuilder');
          }
        });
        c.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.builtin.stringToPy('' + a);
        });
        c.__repr__ = Sk.ffi.functionPy(function (a) {
          return Sk.builtin.stringToPy('CubeBuilder()');
        });
      }, 'CubeBuilder', []);
      Sk.geometry.CylinderBuilder = function () {
        this._innerPy = Sk.ffi.callsim(a[Sk.geometry.CYLINDER_BUILDER]);
      };
      Sk.geometry.CylinderBuilder.prototype = {
        constructor: Sk.geometry.CylinderBuilder,
        axis: function (b, c, d) {
          b = Sk.ffi.numberToFloatPy(b);
          c = Sk.ffi.numberToFloatPy(c);
          d = Sk.ffi.numberToFloatPy(d);
          d = Sk.ffi.callsim(a[Sk.e3ga.VECTOR_E3], b, c, d);
          Sk.ffi.callsim(Sk.ffi.gattr(this._innerPy, 'axis'), d);
          return this;
        },
        material: function (b) {
          b = Sk.ffi.callsim(a[Sk.three.MATERIAL], Sk.ffi.referenceToPy(b, Sk.three.MATERIAL));
          Sk.ffi.callsim(Sk.ffi.gattr(this._innerPy, 'material'), b);
          return this;
        },
        radius: function (a) {
          a = Sk.ffi.numberToFloatPy(a);
          Sk.ffi.callsim(Sk.ffi.gattr(this._innerPy, 'radius'), a);
          return this;
        },
        build: function () {
          return Sk.ffi.remapToJs(Sk.ffi.callsim(Sk.ffi.gattr(this._innerPy, 'build')));
        }
      };
      a[Sk.geometry.CYLINDER_BUILDER] = Sk.ffi.buildClass(a, function (b, c) {
        c.__init__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.checkMethodArgs(Sk.geometry.CYLINDER_BUILDER, arguments, 0, 0);
          Sk.ffi.referenceToPy({
            radiusTop: 0.5,
            radiusBottom: 0.5,
            height: 1
          }, Sk.geometry.CYLINDER_BUILDER, void 0, a);
        });
        c.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'axis':
            return Sk.ffi.callableToPy(a, 'axis', function (a, c) {
              Sk.ffi.checkMethodArgs('axis', arguments, 1, 1);
              Sk.ffi.checkArgType('axis', [
                'Euclidean3',
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isInstance(c, 'Euclidean3') || Sk.ffi.isNone(c), c);
              d.axis = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'height':
            return Sk.ffi.callableToPy(a, 'height', function (a, c) {
              Sk.ffi.checkMethodArgs('height', arguments, 1, 1);
              Sk.ffi.checkArgType('height', [
                k,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isNum(c) || Sk.ffi.isNone(c), c);
              d.height = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'radius':
            return Sk.ffi.callableToPy(a, 'radius', function (a, c) {
              Sk.ffi.checkMethodArgs('radius', arguments, 1, 1);
              Sk.ffi.checkArgType('radius', [
                k,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isNum(c) || Sk.ffi.isNone(c), c);
              d.radiusTop = Sk.ffi.remapToJs(c);
              d.radiusBottom = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'radiusTop':
            return Sk.ffi.callableToPy(a, 'radiusTop', function (a, c) {
              Sk.ffi.checkMethodArgs('radiusTop', arguments, 1, 1);
              Sk.ffi.checkArgType('radiusTop', [
                k,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isNum(c) || Sk.ffi.isNone(c), c);
              d.radiusTop = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'radiusBottom':
            return Sk.ffi.callableToPy(a, 'radiusBottom', function (a, c) {
              Sk.ffi.checkMethodArgs('radiusBottom', arguments, 1, 1);
              Sk.ffi.checkArgType('radiusBottom', [
                k,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isNum(c) || Sk.ffi.isNone(c), c);
              d.radiusBottom = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'segments':
            return Sk.ffi.callableToPy(a, 'segments', function (a, c) {
              Sk.ffi.checkMethodArgs('segments', arguments, 1, 1);
              Sk.ffi.checkArgType('segments', [
                Sk.ffi.PyType.INT,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isInt(c) || Sk.ffi.isNone(c), c);
              d.segments = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'build':
            return Sk.ffi.callableToPy(a, 'build', function (b) {
              Sk.ffi.checkMethodArgs('build', arguments, 0, 0);
              var c, e = {};
              e.axis = d.axis ? d.axis : x;
              if (d.volume) {
                var q = 'number' === typeof d.radiusTop ? d.radiusTop : 0.5, n = 'number' === typeof d.radiusBottom ? d.radiusBottom : 0.5, p = 'number' === typeof d.height ? d.height : 1, g = Math.pow(3 * d.volume / (n * (n + q) * p * Math.PI), 1 / 3);
                e.a = g * q;
                e.b = g * n;
                e.h = g * p;
              } else
                e.a = 'number' === typeof d.radiusTop ? d.radiusTop : 0.5, e.b = 'number' === typeof d.radiusBottom ? d.radiusBottom : 0.5, e.h = 'number' === typeof d.height ? d.height : 1;
              c = e;
              var e = Sk.ffi.numberToFloatPy(c.a), q = Sk.ffi.numberToFloatPy(c.b), n = Sk.ffi.numberToFloatPy(c.h), p = Sk.ffi.numberToIntPy(d.segments ? d.segments : 32), g = Sk.ffi.numberToIntPy(1), m = Sk.ffi.booleanToPy(!1);
              c = Sk.ffi.callsim(a.Euclidean3, Sk.ffi.referenceToPy(c.axis, 'Euclidean3'));
              e = Sk.ffi.callsim(a.CylinderGeometry, e, q, n, p, g, m, c);
              return f(e, d);
            });
          case 'normalize':
            return Sk.ffi.callableToPy(a, 'normalize', function (a) {
              Sk.ffi.checkMethodArgs('normalize', arguments, 0, 0);
              return b;
            });
          default:
            return l(b, c, Sk.geometry.CYLINDER_BUILDER);
          }
        });
        c.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.builtin.stringToPy('' + a);
        });
        c.__repr__ = Sk.ffi.functionPy(function (a) {
          return Sk.builtin.stringToPy(Sk.geometry.CYLINDER_BUILDER + '()');
        });
      }, Sk.geometry.CYLINDER_BUILDER, []);
      a.PlaneBuilder = Sk.ffi.buildClass(a, function (b, c) {
        c.__init__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.checkMethodArgs('PlaneBuilder', arguments, 0, 0);
          Sk.ffi.referenceToPy({}, 'PlaneBuilder', void 0, a);
        });
        c.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'height':
            return Sk.ffi.callableToPy(a, 'height', function (a, c) {
              Sk.ffi.checkMethodArgs('height', arguments, 1, 1);
              Sk.ffi.checkArgType('height', [
                k,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isNum(c) || Sk.ffi.isNone(c), c);
              d.height = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'width':
            return Sk.ffi.callableToPy(a, 'width', function (a, c) {
              Sk.ffi.checkMethodArgs('width', arguments, 1, 1);
              Sk.ffi.checkArgType('width', [
                k,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isNum(c) || Sk.ffi.isNone(c), c);
              d.width = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'segments':
            return Sk.ffi.callableToPy(a, 'segments', function (a, c) {
              Sk.ffi.checkMethodArgs('segments', arguments, 1, 1);
              Sk.ffi.checkArgType('segments', [
                Sk.ffi.PyType.INT,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isInt(c) || Sk.ffi.isNone(c), c);
              d.segments = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'build':
            return Sk.ffi.callableToPy(a, 'build', function (b) {
              Sk.ffi.checkMethodArgs('build', arguments, 0, 0);
              var c, e = {};
              if (d.volume) {
                c = d.width ? d.width : 1;
                var q = d.height ? d.height : 1, n = Math.pow(d.volume / (c * q), 0.5);
                e.width = n * c;
                e.height = n * q;
              } else
                e.width = d.width ? d.width : 1, e.height = d.height ? d.height : 1;
              c = e;
              e = Sk.ffi.numberToFloatPy(c.width);
              c = Sk.ffi.numberToFloatPy(c.height);
              q = Sk.ffi.numberToIntPy(d.segments ? d.segments : 1);
              e = Sk.ffi.callsim(a.PlaneGeometry, e, c, q, q);
              return f(e, d);
            });
          case 'normalize':
            return Sk.ffi.callableToPy(a, 'normalize', function (a) {
              Sk.ffi.checkMethodArgs('normalize', arguments, 0, 0);
              return b;
            });
          default:
            return l(b, c, 'PlaneBuilder');
          }
        });
        c.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.builtin.stringToPy('' + a);
        });
        c.__repr__ = Sk.ffi.functionPy(function (a) {
          return Sk.builtin.stringToPy('PlaneBuilder()');
        });
      }, 'PlaneBuilder', []);
      a.SphereBuilder = Sk.ffi.buildClass(a, function (b, c) {
        c.__init__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.checkMethodArgs('SphereBuilder', arguments, 0, 0);
          Sk.ffi.referenceToPy({}, 'SphereBuilder', void 0, a);
        });
        c.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'radius':
            return Sk.ffi.callableToPy(a, 'radius', function (a, c) {
              Sk.ffi.checkMethodArgs('radius', arguments, 1, 1);
              Sk.ffi.checkArgType('radius', [
                k,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isNum(c) || Sk.ffi.isNone(c), c);
              d.radius = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'segments':
            return Sk.ffi.callableToPy(a, 'segments', function (a, c) {
              Sk.ffi.checkMethodArgs('segments', arguments, 1, 1);
              Sk.ffi.checkArgType('segments', [
                Sk.ffi.PyType.INT,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isInt(c) || Sk.ffi.isNone(c), c);
              d.segments = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'build':
            return Sk.ffi.callableToPy(a, 'build', function (b) {
              Sk.ffi.checkMethodArgs('build', arguments, 0, 0);
              var c;
              c = d.volume ? Math.pow(3 * d.volume / (4 * Math.PI), 1 / 3) : d.radius ? d.radius : 0.5;
              c = Sk.ffi.numberToFloatPy(c);
              var e = Sk.ffi.numberToIntPy(d.segments ? d.segments : 24), q = Sk.ffi.numberToIntPy(d.segments ? d.segments : 18);
              c = Sk.ffi.callsim(a.SphereGeometry, c, e, q);
              return f(c, d);
            });
          case 'normalize':
            return Sk.ffi.callableToPy(a, 'normalize', function (a) {
              Sk.ffi.checkMethodArgs('normalize', arguments, 0, 0);
              d.radius = Math.pow(3 / (4 * Math.PI), 1 / 3);
              return b;
            });
          default:
            return l(b, c, 'SphereBuilder');
          }
        });
        c.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.builtin.stringToPy('' + a);
        });
        c.__repr__ = Sk.ffi.functionPy(function (a) {
          return Sk.builtin.stringToPy('SphereBuilder()');
        });
      }, 'SphereBuilder', []);
      a[Sk.geometry.VOLUME_BUILDER] = Sk.ffi.buildClass(a, function (b, c) {
        c.__init__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.checkMethodArgs(Sk.geometry.VOLUME_BUILDER, arguments, 0, 0);
          Sk.ffi.referenceToPy({}, Sk.geometry.VOLUME_BUILDER, void 0, a);
        });
        c.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'radius':
            return Sk.ffi.callableToPy(a, 'radius', function (a, c) {
              Sk.ffi.checkMethodArgs('radius', arguments, 1, 1);
              Sk.ffi.checkArgType('radius', [
                k,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isNum(c) || Sk.ffi.isNone(c), c);
              d.radius = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'segments':
            return Sk.ffi.callableToPy(a, 'segments', function (a, c) {
              Sk.ffi.checkMethodArgs('segments', arguments, 1, 1);
              Sk.ffi.checkArgType('segments', [
                Sk.ffi.PyType.INT,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isInt(c) || Sk.ffi.isNone(c), c);
              d.segments = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'build':
            return Sk.ffi.callableToPy(a, 'build', function (b) {
              Sk.ffi.checkMethodArgs('build', arguments, 0, 0);
              var c = {};
              if (d.volume) {
                var f = d.radius ? d.radius : 1, q = d.height ? d.height : 1, n = Math.pow(d.volume / (f * q), 0.5);
                c.width = n * f;
                c.height = n * q;
              } else
                c.radius = d.radius ? d.radius : 1, c.height = d.height ? d.height : 1;
              Sk.ffi.numberToFloatPy(c.radius);
              Sk.ffi.numberToFloatPy(0.08);
              Sk.ffi.numberToFloatPy(0.01);
              Sk.ffi.numberToFloatPy(0.2);
              Sk.ffi.numberToFloatPy(0.8);
              Sk.ffi.numberToIntPy(6);
              Sk.ffi.numberToIntPy(d.segments ? d.segments : 32);
              return Sk.ffi.callsim(a[Sk.geometry.VOLUME], e(d));
            });
          case 'normalize':
            return Sk.ffi.callableToPy(a, 'normalize', function (a) {
              Sk.ffi.checkMethodArgs('normalize', arguments, 0, 0);
              d.radius = Math.sqrt(1 / Math.PI);
              return b;
            });
          default:
            return l(b, c, Sk.geometry.VOLUME_BUILDER);
          }
        });
        c.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.builtin.stringToPy('' + a);
        });
        c.__repr__ = Sk.ffi.functionPy(function (a) {
          return Sk.builtin.stringToPy(Sk.geometry.VOLUME_BUILDER + '()');
        });
      }, Sk.geometry.VOLUME_BUILDER, []);
      a[Sk.geometry.VOLUME] = Sk.ffi.buildClass(a, function (a, c) {
        c.__init__ = Sk.ffi.functionPy(function (a, c) {
          Sk.ffi.checkMethodArgs(Sk.geometry.VOLUME, arguments, 1, 1);
          var d = new b[Sk.three.OBJECT_3D](), e, f = new Sk.geometry.CylinderBuilder();
          f.radius(0.01).material(Sk.ffi.remapToJs(c));
          f.axis(1, 0, 0);
          e = f.build();
          e.position.set(0, 0.5, 0.5);
          d.add(e);
          e = f.build();
          e.position.set(0, 0.5, -0.5);
          e.name = 'c1';
          d.add(e);
          e = f.build();
          e.position.set(0, -0.5, 0.5);
          d.add(e);
          f.axis(0, 1, 0);
          e = f.build();
          e.position.set(0.5, 0, 0.5);
          d.add(e);
          e = f.build();
          e.position.set(-0.5, 0, 0.5);
          d.add(e);
          e = f.build();
          e.position.set(-0.5, 0, -0.5);
          e.name = 'c2';
          d.add(e);
          f.axis(0, 0, 1);
          e = f.build();
          e.position.set(0.5, -0.5, 0);
          d.add(e);
          e = f.build();
          e.position.set(-0.5, 0.5, 0);
          d.add(e);
          e = f.build();
          e.position.set(-0.5, -0.5, 0);
          d.add(e);
          f = new Sk.geometry.ArrowBuilder();
          f.radius(0.01).material(Sk.ffi.remapToJs(c));
          f.axis(1, 0, 0);
          e = f.build();
          e.name = 'e1';
          e.position.set(0, -0.5, -0.5);
          d.add(e);
          f.axis(0, 1, 0);
          e = f.build();
          e.name = 'e2';
          e.position.set(0.5, 0, -0.5);
          d.add(e);
          f.axis(0, 0, 1);
          e = f.build();
          e.position.set(0.5, 0.5, 0);
          d.add(e);
          Sk.ffi.referenceToPy(d, Sk.geometry.VOLUME, void 0, a);
        });
        c.__getattr__ = Sk.ffi.functionPy(function (a, b) {
          Sk.ffi.remapToJs(a);
          switch (b) {
          default:
            return Sk.three.object3DGetAttr(Sk.geometry.VOLUME, a, b);
          }
        });
        c.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          var d = Sk.ffi.remapToJs(a);
          switch (b) {
          case 'orientation':
            Sk.ffi.checkArgType(b, Sk.ffi.PyType.BOOL, Sk.ffi.isBool(c), c);
            a = Sk.ffi.remapToJs(c);
            b = d.getObjectByName('e1');
            c = d.getObjectByName('c1');
            var e = d.getObjectByName('e2'), d = d.getObjectByName('c2');
            a ? (b.position.set(0, -0.5, -0.5), c.position.set(0, 0.5, -0.5), e.position.set(0.5, 0, -0.5), d.position.set(-0.5, 0, -0.5)) : (b.position.set(0, 0.5, -0.5), c.position.set(0, -0.5, -0.5), e.position.set(-0.5, 0, -0.5), d.position.set(0.5, 0, -0.5));
            break;
          default:
            return Sk.three.object3DSetAttr(Sk.geometry.VOLUME, a, b, c);
          }
        });
        c.__str__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.remapToJs(a);
          var b = [].map(function (b) {
              return [
                b,
                Sk.ffi.remapToJs(Sk.ffh.str(Sk.ffi.gattr(a, b)))
              ].join('=');
            });
          return Sk.builtin.stringToPy(Sk.geometry.VOLUME + '(' + b.join(', ') + ')');
        });
        c.__repr__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.remapToJs(a);
          var b = [].map(function (b) {
              return Sk.ffi.gattr(a, b);
            }).map(function (a) {
              return Sk.ffi.remapToJs(Sk.ffh.repr(a));
            });
          return Sk.builtin.stringToPy(Sk.geometry.VOLUME + '(' + b.join(', ') + ')');
        });
      }, Sk.geometry.VOLUME, []);
      a[Sk.geometry.VORTEX_BUILDER] = Sk.ffi.buildClass(a, function (b, c) {
        c.__init__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.checkMethodArgs(Sk.geometry.VORTEX_BUILDER, arguments, 0, 0);
          Sk.ffi.referenceToPy({}, Sk.geometry.VORTEX_BUILDER, void 0, a);
        });
        c.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'radius':
            return Sk.ffi.callableToPy(a, 'radius', function (a, c) {
              Sk.ffi.checkMethodArgs('radius', arguments, 1, 1);
              Sk.ffi.checkArgType('radius', [
                k,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isNum(c) || Sk.ffi.isNone(c), c);
              d.radius = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'segments':
            return Sk.ffi.callableToPy(a, 'segments', function (a, c) {
              Sk.ffi.checkMethodArgs('segments', arguments, 1, 1);
              Sk.ffi.checkArgType('segments', [
                Sk.ffi.PyType.INT,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isInt(c) || Sk.ffi.isNone(c), c);
              d.segments = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'build':
            return Sk.ffi.callableToPy(a, 'build', function (b) {
              Sk.ffi.checkMethodArgs('build', arguments, 0, 0);
              var c = {};
              if (d.volume) {
                var e = d.radius ? d.radius : 1, q = d.height ? d.height : 1, n = Math.pow(d.volume / (e * q), 0.5);
                c.width = n * e;
                c.height = n * q;
              } else
                c.radius = d.radius ? d.radius : 1, c.height = d.height ? d.height : 1;
              var c = Sk.ffi.numberToFloatPy(c.radius), e = Sk.ffi.numberToFloatPy(0.08), q = Sk.ffi.numberToFloatPy(0.01), n = Sk.ffi.numberToFloatPy(0.2), p = Sk.ffi.numberToFloatPy(0.8), g = Sk.ffi.numberToIntPy(6), m = Sk.ffi.numberToIntPy(d.segments ? d.segments : 32), c = Sk.ffi.callsim(a[Sk.three.VORTEX_GEOMETRY], c, e, q, n, p, g, m);
              return f(c, d);
            });
          case 'normalize':
            return Sk.ffi.callableToPy(a, 'normalize', function (a) {
              Sk.ffi.checkMethodArgs('normalize', arguments, 0, 0);
              d.radius = Math.sqrt(1 / Math.PI);
              return b;
            });
          default:
            return l(b, c, Sk.geometry.VORTEX_BUILDER);
          }
        });
        c.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.builtin.stringToPy('' + a);
        });
        c.__repr__ = Sk.ffi.functionPy(function (a) {
          return Sk.builtin.stringToPy(Sk.geometry.VORTEX_BUILDER + '()');
        });
      }, Sk.geometry.VORTEX_BUILDER, []);
    };
  }.call(this));
  (function () {
    Sk.builtin.defineHttp = function (a) {
      Sk.ffi.checkFunctionArgs('defineHttp', arguments, 1, 1);
      a.XMLHttpRequest = Sk.ffi.buildClass(a, function (b, c) {
        c.__init__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.referenceToPy(new XMLHttpRequest(), 'XMLHttpRequest', void 0, a);
        });
        c.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var f = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'open':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
              b.__init__ = Sk.ffi.functionPy(function (a) {
                Sk.ffi.referenceToPy(null, 'open', null, a);
              });
              b.__call__ = Sk.ffi.functionPy(function (a, b, c, d, e, q) {
                Sk.ffi.checkMethodArgs('open', arguments, 2, 5);
                Sk.ffi.checkArgType('method', [Sk.ffi.PyType.STR], Sk.builtin.isStringPy(b), b);
                Sk.ffi.checkArgType('url', [Sk.ffi.PyType.STR], Sk.builtin.isStringPy(c), c);
                Sk.ffi.checkArgType('async', [Sk.ffi.PyType.BOOL], Sk.ffi.isBool(d), d);
                var g = Sk.builtin.stringToJs(b), h = Sk.builtin.stringToJs(c), J = Sk.ffi.remapToJs(d);
                f.open(g, h, J);
              });
            }, 'open', []));
          case 'send':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
              b.__init__ = Sk.ffi.functionPy(function (a) {
                Sk.ffi.referenceToPy(null, 'send', null, a);
              });
              b.__call__ = Sk.ffi.functionPy(function (a, b) {
                Sk.ffi.checkMethodArgs('send', arguments, 0, 1);
                f.send();
              });
            }, 'send', []));
          default:
            throw Sk.ffi.err.attribute(c).isNotGetableOnType('XMLHttpRequest');
          }
        });
        c.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          a = Sk.ffi.remapToJs(a);
          switch (b) {
          case 'onload':
            Sk.ffi.checkArgType(b, [Sk.ffi.PyType.FUNCTION], Sk.ffi.isFunction(c), c);
            a.onload = Sk.ffi.remapToJs(c);
            break;
          case 'responseType':
            Sk.ffi.checkArgType(b, [Sk.ffi.PyType.STR], Sk.builtin.isStringPy(c), c);
            a.responseType = Sk.ffi.remapToJs(c);
            break;
          default:
            throw Sk.ffi.err.attribute(b).isNotSetableOnType('XMLHttpRequest');
          }
        });
        c.__str__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.remapToJs(a);
          return Sk.builtin.stringToPy('XMLHttpRequest');
        });
        c.__repr__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.remapToJs(a);
          return Sk.builtin.stringToPy('XMLHttpRequest()');
        });
      }, 'XMLHttpRequest', []);
    };
  }.call(this));
  (function () {
    Sk.builtin.defineNode = function (a) {
      Sk.ffi.checkFunctionArgs('defineNode', arguments, 1, 1);
      var b = function (b) {
        return b ? Sk.ffi.callsim(a.Node, Sk.ffi.referenceToPy(b, 'Node')) : Sk.builtin.none.none$;
      };
      a.Node = Sk.ffi.buildClass(a, function (c, d) {
        d.__init__ = Sk.ffi.functionPy(function (a, b) {
          Sk.ffi.checkMethodArgs('Node', arguments, 1, 1);
          Sk.ffi.checkArgType('node', 'Node', Sk.ffi.isInstance(b, 'Node'), b);
          Sk.ffi.referenceToPy(Sk.ffi.remapToJs(b), 'Node', void 0, a);
        });
        d.__getattr__ = Sk.ffi.functionPy(function (c, d) {
          var g = Sk.ffi.remapToJs(c);
          switch (d) {
          case 'clientHeight':
            return Sk.ffi.numberToFloatPy(g.clientHeight);
          case 'clientWidth':
            return Sk.ffi.numberToFloatPy(g.clientWidth);
          case 'dir':
            return Sk.builtin.stringToPy(g.dir);
          case 'firstChild':
            return b(g.firstChild);
          case 'lastChild':
            return b(g.lastChild);
          case 'nextSibling':
            return b(g.nextSibling);
          case 'offsetHeight':
            return Sk.ffi.numberToIntPy(g.offsetHeight);
          case 'offsetWidth':
            return Sk.ffi.numberToIntPy(g.offsetWidth);
          case 'parentNode':
            return b(g.parentNode);
          case 'previousSibling':
            return b(g.previousSibling);
          case 'height':
            return Sk.ffi.numberToIntPy(g.height);
          case 'width':
            return Sk.ffi.numberToIntPy(g.width);
          case 'style':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
              b.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'style';
                a.v = g.style;
              });
              b.__getattr__ = Sk.ffi.functionPy(function (a, b) {
                var c = Sk.ffi.remapToJs(a);
                switch (b) {
                case 'height':
                  return Sk.builtin.stringToPy(c.height);
                case 'left':
                  return Sk.builtin.stringToPy(c.left);
                case 'position':
                  return Sk.builtin.stringToPy(c.position);
                case 'top':
                  return Sk.builtin.stringToPy(c.top);
                case 'width':
                  return Sk.builtin.stringToPy(c.width);
                }
              });
              b.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
                a = Sk.ffi.remapToJs(a);
                c = Sk.ffi.remapToJs(c);
                switch (b) {
                case 'height':
                  a.height = c;
                  break;
                case 'left':
                  a.left = c;
                  break;
                case 'position':
                  a.position = c;
                  break;
                case 'top':
                  a.top = c;
                  break;
                case 'width':
                  a.width = c;
                  break;
                default:
                  throw new Sk.builtin.AssertionError(b + ' is not a writeable attribute of style');
                }
              });
              b.__str__ = Sk.ffi.functionPy(function (a) {
                return Sk.builtin.stringToPy('style');
              });
              b.__repr__ = Sk.ffi.functionPy(function (a) {
                return Sk.builtin.stringToPy('style');
              });
            }, 'style', []));
          case 'appendChild':
            return Sk.ffi.callableToPy(a, 'appendChild', function (a, c) {
              Sk.ffi.checkMethodArgs('appendChild', arguments, 1, 1);
              Sk.ffi.checkArgType('child', 'Node', Sk.ffi.isInstance(c, 'Node'), c);
              var d = Sk.ffi.remapToJs(c);
              return b(g.appendChild(d));
            });
          case 'getContext':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (b, c) {
              c.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'getContext';
              });
              c.__call__ = Sk.ffi.functionPy(function (b, c, d) {
                b = Sk.ffi.remapToJs(c);
                d = Sk.ffi.remapToJs(d);
                var e = g.getContext(b, d);
                return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (b, c) {
                  c.__init__ = Sk.ffi.functionPy(function (a) {
                    a.tp$name = 'CanvasRenderingContext2D';
                    a.v = e;
                  });
                  c.__getattr__ = Sk.ffi.functionPy(function (b, c) {
                    switch (c) {
                    case 'fillStyle':
                      return Sk.builtin.stringToPy(e.fillStyle);
                    case 'font':
                      return Sk.builtin.stringToPy(e.font);
                    case 'lineCap':
                      return Sk.builtin.stringToPy(e.lineCap);
                    case 'lineJoin':
                      return Sk.builtin.stringToPy(e.lineJoin);
                    case 'lineWidth':
                      return Sk.ffi.numberToIntPy(e.lineWidth);
                    case 'shadowBlur':
                      return Sk.ffi.numberToIntPy(e.shadowBlur);
                    case 'shadowColor':
                      return Sk.builtin.stringToPy(e.shadowColor);
                    case 'shadowOffsetX':
                      return Sk.ffi.numberToIntPy(e.shadowOffsetX);
                    case 'shadowOffsetY':
                      return Sk.ffi.numberToIntPy(e.shadowOffsetY);
                    case 'strokeStyle':
                      return Sk.builtin.stringToPy(e.strokeStyle);
                    case 'textAlign':
                      return Sk.builtin.stringToPy(e.textAlign);
                    case 'textBaseline':
                      return Sk.builtin.stringToPy(e.textBaseline);
                    case 'webkitBackingStorePixelRatio':
                      return Sk.ffi.numberToIntPy(e.webkitBackingStorePixelRatio);
                    case 'arc':
                      return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
                        b.__init__ = Sk.ffi.functionPy(function (a) {
                          a.tp$name = 'arc';
                        });
                        b.__call__ = Sk.ffi.functionPy(function (a, b, c, d, f, q, p) {
                          b = Sk.ffi.remapToJs(b);
                          c = Sk.ffi.remapToJs(c);
                          d = Sk.ffi.remapToJs(d);
                          f = Sk.ffi.remapToJs(f);
                          q = Sk.ffi.remapToJs(q);
                          p = Sk.ffi.remapToJs(p);
                          e.arc(b, c, d, f, q, p);
                        });
                        b.__str__ = Sk.ffi.functionPy(function (a) {
                          return Sk.builtin.stringToPy('arc');
                        });
                        b.__repr__ = Sk.ffi.functionPy(function (a) {
                          return Sk.builtin.stringToPy('arc');
                        });
                      }, 'arc', []));
                    case 'arcTo':
                      return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
                        b.__init__ = Sk.ffi.functionPy(function (a) {
                          a.tp$name = 'arcTo';
                        });
                        b.__call__ = Sk.ffi.functionPy(function (a, b, c, d, f, q, p, g) {
                          b = Sk.ffi.remapToJs(b);
                          c = Sk.ffi.remapToJs(c);
                          d = Sk.ffi.remapToJs(d);
                          f = Sk.ffi.remapToJs(f);
                          q = Sk.ffi.remapToJs(q);
                          p = Sk.ffi.remapToJs(p);
                          g = Sk.ffi.remapToJs(g);
                          e.arcTo(b, c, d, f, q, p, g);
                        });
                        b.__str__ = Sk.ffi.functionPy(function (a) {
                          return Sk.builtin.stringToPy('arcTo');
                        });
                        b.__repr__ = Sk.ffi.functionPy(function (a) {
                          return Sk.builtin.stringToPy('arcTo');
                        });
                      }, 'arcTo', []));
                    case 'beginPath':
                      return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
                        b.__init__ = Sk.ffi.functionPy(function (a) {
                          a.tp$name = 'beginPath';
                        });
                        b.__call__ = Sk.ffi.functionPy(function (a) {
                          e.beginPath();
                        });
                        b.__str__ = Sk.ffi.functionPy(function (a) {
                          return Sk.builtin.stringToPy('beginPath');
                        });
                        b.__repr__ = Sk.ffi.functionPy(function (a) {
                          return Sk.builtin.stringToPy('beginPath');
                        });
                      }, 'beginPath', []));
                    case 'bezierCurveTo':
                      return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
                        b.__init__ = Sk.ffi.functionPy(function (a) {
                          a.tp$name = 'bezierCurveTo';
                        });
                        b.__call__ = Sk.ffi.functionPy(function (a, b, c, d, f, q, p) {
                          b = Sk.ffi.remapToJs(b);
                          c = Sk.ffi.remapToJs(c);
                          d = Sk.ffi.remapToJs(d);
                          f = Sk.ffi.remapToJs(f);
                          q = Sk.ffi.remapToJs(q);
                          p = Sk.ffi.remapToJs(p);
                          e.bezierCurveTo(b, c, d, f, q, p);
                        });
                        b.__str__ = Sk.ffi.functionPy(function (a) {
                          return Sk.builtin.stringToPy('bezierCurveTo');
                        });
                        b.__repr__ = Sk.ffi.functionPy(function (a) {
                          return Sk.builtin.stringToPy('bezierCurveTo');
                        });
                      }, 'bezierCurveTo', []));
                    case 'clearRect':
                      return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
                        b.__init__ = Sk.ffi.functionPy(function (a) {
                          a.tp$name = 'clearRect';
                        });
                        b.__call__ = Sk.ffi.functionPy(function (a, b, c, d, f) {
                          b = Sk.ffi.remapToJs(b);
                          c = Sk.ffi.remapToJs(c);
                          d = Sk.ffi.remapToJs(d);
                          f = Sk.ffi.remapToJs(f);
                          e.clearRect(b, c, d, f);
                        });
                        b.__str__ = Sk.ffi.functionPy(function (a) {
                          return Sk.builtin.stringToPy('clearRect');
                        });
                        b.__repr__ = Sk.ffi.functionPy(function (a) {
                          return Sk.builtin.stringToPy('clearRect');
                        });
                      }, 'clearRect', []));
                    case 'clip':
                      return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
                        b.__init__ = Sk.ffi.functionPy(function (a) {
                          a.tp$name = 'clip';
                        });
                        b.__call__ = Sk.ffi.functionPy(function (a) {
                          e.clip();
                        });
                        b.__str__ = Sk.ffi.functionPy(function (a) {
                          return Sk.builtin.stringToPy('clip');
                        });
                        b.__repr__ = Sk.ffi.functionPy(function (a) {
                          return Sk.builtin.stringToPy('clip');
                        });
                      }, 'clip', []));
                    case 'closePath':
                      return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
                        b.__init__ = Sk.ffi.functionPy(function (a) {
                          a.tp$name = 'closePath';
                        });
                        b.__call__ = Sk.ffi.functionPy(function (a) {
                          e.closePath();
                        });
                        b.__str__ = Sk.ffi.functionPy(function (a) {
                          return Sk.builtin.stringToPy('closePath');
                        });
                        b.__repr__ = Sk.ffi.functionPy(function (a) {
                          return Sk.builtin.stringToPy('closePath');
                        });
                      }, 'closePath', []));
                    case 'createLinearGradient':
                      return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (b, c) {
                        c.__init__ = Sk.ffi.functionPy(function (a) {
                          a.tp$name = 'createLinearGradient';
                        });
                        c.__call__ = Sk.ffi.functionPy(function (b, c, d, f, q) {
                          c = Sk.ffi.remapToJs(c);
                          d = Sk.ffi.remapToJs(d);
                          f = Sk.ffi.remapToJs(f);
                          q = Sk.ffi.remapToJs(q);
                          var p = e.createLinearGradient(c, d, f, q);
                          return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (b, c) {
                            c.__init__ = Sk.ffi.functionPy(function (a) {
                              a.tp$name = 'CanvasGradient';
                              a.v = p;
                            });
                            c.__getattr__ = Sk.ffi.functionPy(function (b, c) {
                              switch (c) {
                              case 'addColorStop':
                                return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
                                  b.__init__ = Sk.ffi.functionPy(function (a) {
                                    a.tp$name = 'addColorStop';
                                  });
                                  b.__call__ = Sk.ffi.functionPy(function (a, b, c) {
                                    b = Sk.ffi.remapToJs(b);
                                    c = Sk.ffi.remapToJs(c);
                                    p.addColorStop(b, c);
                                  });
                                  b.__str__ = Sk.ffi.functionPy(function (a) {
                                    return Sk.builtin.stringToPy('addColorStop');
                                  });
                                  b.__repr__ = Sk.ffi.functionPy(function (a) {
                                    return Sk.builtin.stringToPy('addColorStop');
                                  });
                                }, 'addColorStop', []));
                              }
                            });
                            c.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
                              Sk.ffi.remapToJs(c);
                              switch (b) {
                              default:
                                throw new Sk.builtin.AssertionError(b + ' is not a writeable attribute of CanvasGradient');
                              }
                            });
                            c.__str__ = Sk.ffi.functionPy(function (a) {
                              return Sk.builtin.stringToPy('CanvasGradient');
                            });
                            c.__repr__ = Sk.ffi.functionPy(function (a) {
                              return Sk.builtin.stringToPy('CanvasGradient');
                            });
                          }, 'CanvasGradient', []));
                        });
                        c.__str__ = Sk.ffi.functionPy(function (a) {
                          return Sk.builtin.stringToPy('createLinearGradient');
                        });
                        c.__repr__ = Sk.ffi.functionPy(function (a) {
                          return Sk.builtin.stringToPy('createLinearGradient');
                        });
                      }, 'createLinearGradient', []));
                    case 'fill':
                      return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
                        b.__init__ = Sk.ffi.functionPy(function (a) {
                          a.tp$name = 'fill';
                        });
                        b.__call__ = Sk.ffi.functionPy(function (a) {
                          e.fill();
                        });
                        b.__str__ = Sk.ffi.functionPy(function (a) {
                          return Sk.builtin.stringToPy('fill');
                        });
                        b.__repr__ = Sk.ffi.functionPy(function (a) {
                          return Sk.builtin.stringToPy('fill');
                        });
                      }, 'fill', []));
                    case 'fillRect':
                      return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
                        b.__init__ = Sk.ffi.functionPy(function (a) {
                          a.tp$name = 'fillRect';
                        });
                        b.__call__ = Sk.ffi.functionPy(function (a, b, c, d, f) {
                          b = Sk.ffi.remapToJs(b);
                          c = Sk.ffi.remapToJs(c);
                          d = Sk.ffi.remapToJs(d);
                          f = Sk.ffi.remapToJs(f);
                          e.fillRect(b, c, d, f);
                        });
                        b.__str__ = Sk.ffi.functionPy(function (a) {
                          return Sk.builtin.stringToPy('fillRect');
                        });
                        b.__repr__ = Sk.ffi.functionPy(function (a) {
                          return Sk.builtin.stringToPy('fillRect');
                        });
                      }, 'fillRect', []));
                    case 'fillText':
                      return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
                        b.__init__ = Sk.ffi.functionPy(function (a) {
                          a.tp$name = 'fillText';
                        });
                        b.__call__ = Sk.ffi.functionPy(function (a, b, c, d, f) {
                          b = Sk.ffi.remapToJs(b);
                          c = Sk.ffi.remapToJs(c);
                          d = Sk.ffi.remapToJs(d);
                          a = Sk.ffi.remapToJs(f);
                          if ('undefined' === typeof a)
                            e.fillText(b, c, d);
                          else if ('number' === typeof a)
                            e.fillText(b, c, d, a);
                          else
                            throw new Sk.builtin.TypeError('maxWidth');
                        });
                        b.__str__ = Sk.ffi.functionPy(function (a) {
                          return Sk.builtin.stringToPy('fillText');
                        });
                        b.__repr__ = Sk.ffi.functionPy(function (a) {
                          return Sk.builtin.stringToPy('fillText');
                        });
                      }, 'fillText', []));
                    case 'lineTo':
                      return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
                        b.__init__ = Sk.ffi.functionPy(function (a) {
                          a.tp$name = 'lineTo';
                        });
                        b.__call__ = Sk.ffi.functionPy(function (a, b, c) {
                          b = Sk.ffi.remapToJs(b);
                          c = Sk.ffi.remapToJs(c);
                          e.lineTo(b, c);
                        });
                        b.__str__ = Sk.ffi.functionPy(function (a) {
                          return Sk.builtin.stringToPy('lineTo');
                        });
                        b.__repr__ = Sk.ffi.functionPy(function (a) {
                          return Sk.builtin.stringToPy('lineTo');
                        });
                      }, 'lineTo', []));
                    case 'moveTo':
                      return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
                        b.__init__ = Sk.ffi.functionPy(function (a) {
                          a.tp$name = 'moveTo';
                        });
                        b.__call__ = Sk.ffi.functionPy(function (a, b, c) {
                          b = Sk.ffi.remapToJs(b);
                          c = Sk.ffi.remapToJs(c);
                          e.moveTo(b, c);
                        });
                        b.__str__ = Sk.ffi.functionPy(function (a) {
                          return Sk.builtin.stringToPy('moveTo');
                        });
                        b.__repr__ = Sk.ffi.functionPy(function (a) {
                          return Sk.builtin.stringToPy('moveTo');
                        });
                      }, 'moveTo', []));
                    case 'quadraticCurveTo':
                      return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
                        b.__init__ = Sk.ffi.functionPy(function (a) {
                          a.tp$name = 'quadraticCurveTo';
                        });
                        b.__call__ = Sk.ffi.functionPy(function (a, b, c, d, f) {
                          b = Sk.ffi.remapToJs(b);
                          c = Sk.ffi.remapToJs(c);
                          d = Sk.ffi.remapToJs(d);
                          f = Sk.ffi.remapToJs(f);
                          e.quadraticCurveTo(b, c, d, f);
                        });
                        b.__str__ = Sk.ffi.functionPy(function (a) {
                          return Sk.builtin.stringToPy('quadraticCurveTo');
                        });
                        b.__repr__ = Sk.ffi.functionPy(function (a) {
                          return Sk.builtin.stringToPy('quadraticCurveTo');
                        });
                      }, 'quadraticCurveTo', []));
                    case 'rect':
                      return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
                        b.__init__ = Sk.ffi.functionPy(function (a) {
                          a.tp$name = 'rect';
                        });
                        b.__call__ = Sk.ffi.functionPy(function (a, b, c, d, f) {
                          b = Sk.ffi.remapToJs(b);
                          c = Sk.ffi.remapToJs(c);
                          d = Sk.ffi.remapToJs(d);
                          f = Sk.ffi.remapToJs(f);
                          e.rect(b, c, d, f);
                        });
                        b.__str__ = Sk.ffi.functionPy(function (a) {
                          return Sk.builtin.stringToPy('rect');
                        });
                        b.__repr__ = Sk.ffi.functionPy(function (a) {
                          return Sk.builtin.stringToPy('rect');
                        });
                      }, 'rect', []));
                    case 'restore':
                      return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
                        b.__init__ = Sk.ffi.functionPy(function (a) {
                          a.tp$name = 'restore';
                        });
                        b.__call__ = Sk.ffi.functionPy(function (a) {
                          e.restore();
                        });
                        b.__str__ = Sk.ffi.functionPy(function (a) {
                          return Sk.builtin.stringToPy('restore');
                        });
                        b.__repr__ = Sk.ffi.functionPy(function (a) {
                          return Sk.builtin.stringToPy('restore');
                        });
                      }, 'restore', []));
                    case 'rotate':
                      return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
                        b.__init__ = Sk.ffi.functionPy(function (a) {
                          a.tp$name = 'rotate';
                        });
                        b.__call__ = Sk.ffi.functionPy(function (a, b) {
                          b = Sk.ffi.remapToJs(b);
                          e.rotate(b);
                        });
                        b.__str__ = Sk.ffi.functionPy(function (a) {
                          return Sk.builtin.stringToPy('rotate');
                        });
                        b.__repr__ = Sk.ffi.functionPy(function (a) {
                          return Sk.builtin.stringToPy('rotate');
                        });
                      }, 'rotate', []));
                    case 'save':
                      return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
                        b.__init__ = Sk.ffi.functionPy(function (a) {
                          a.tp$name = 'save';
                        });
                        b.__call__ = Sk.ffi.functionPy(function (a) {
                          e.save();
                        });
                        b.__str__ = Sk.ffi.functionPy(function (a) {
                          return Sk.builtin.stringToPy('save');
                        });
                        b.__repr__ = Sk.ffi.functionPy(function (a) {
                          return Sk.builtin.stringToPy('save');
                        });
                      }, 'save', []));
                    case 'scale':
                      return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
                        b.__init__ = Sk.ffi.functionPy(function (a) {
                          a.tp$name = 'scale';
                        });
                        b.__call__ = Sk.ffi.functionPy(function (a, b, c) {
                          b = Sk.ffi.remapToJs(b);
                          c = Sk.ffi.remapToJs(c);
                          e.scale(b, c);
                        });
                        b.__str__ = Sk.ffi.functionPy(function (a) {
                          return Sk.builtin.stringToPy('scale');
                        });
                        b.__repr__ = Sk.ffi.functionPy(function (a) {
                          return Sk.builtin.stringToPy('scale');
                        });
                      }, 'scale', []));
                    case 'setTransform':
                      return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
                        b.__init__ = Sk.ffi.functionPy(function (a) {
                          a.tp$name = 'setTransform';
                        });
                        b.__call__ = Sk.ffi.functionPy(function (a, b, c, d, f, q, p) {
                          b = Sk.ffi.remapToJs(b);
                          c = Sk.ffi.remapToJs(c);
                          d = Sk.ffi.remapToJs(d);
                          f = Sk.ffi.remapToJs(f);
                          q = Sk.ffi.remapToJs(q);
                          p = Sk.ffi.remapToJs(p);
                          e.setTransform(b, c, d, f, q, p);
                        });
                        b.__str__ = Sk.ffi.functionPy(function (a) {
                          return Sk.builtin.stringToPy('setTransform');
                        });
                        b.__repr__ = Sk.ffi.functionPy(function (a) {
                          return Sk.builtin.stringToPy('setTransform');
                        });
                      }, 'setTransform', []));
                    case 'stroke':
                      return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
                        b.__init__ = Sk.ffi.functionPy(function (a) {
                          a.tp$name = 'stroke';
                        });
                        b.__call__ = Sk.ffi.functionPy(function (a) {
                          e.stroke();
                        });
                        b.__str__ = Sk.ffi.functionPy(function (a) {
                          return Sk.builtin.stringToPy('stroke');
                        });
                        b.__repr__ = Sk.ffi.functionPy(function (a) {
                          return Sk.builtin.stringToPy('stroke');
                        });
                      }, 'stroke', []));
                    case 'strokeRect':
                      return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
                        b.__init__ = Sk.ffi.functionPy(function (a) {
                          a.tp$name = 'strokeRect';
                        });
                        b.__call__ = Sk.ffi.functionPy(function (a, b, c, d, f) {
                          b = Sk.ffi.remapToJs(b);
                          c = Sk.ffi.remapToJs(c);
                          d = Sk.ffi.remapToJs(d);
                          f = Sk.ffi.remapToJs(f);
                          e.strokeRect(b, c, d, f);
                        });
                        b.__str__ = Sk.ffi.functionPy(function (a) {
                          return Sk.builtin.stringToPy('strokeRect');
                        });
                        b.__repr__ = Sk.ffi.functionPy(function (a) {
                          return Sk.builtin.stringToPy('strokeRect');
                        });
                      }, 'strokeRect', []));
                    case 'strokeText':
                      return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
                        b.__init__ = Sk.ffi.functionPy(function (a) {
                          a.tp$name = 'strokeText';
                        });
                        b.__call__ = Sk.ffi.functionPy(function (a, b, c, d, f) {
                          b = Sk.ffi.remapToJs(b);
                          c = Sk.ffi.remapToJs(c);
                          d = Sk.ffi.remapToJs(d);
                          a = Sk.ffi.remapToJs(f);
                          if ('undefined' === typeof a)
                            e.strokeText(b, c, d);
                          else if ('number' === typeof a)
                            e.strokeText(b, c, d, a);
                          else
                            throw new Sk.builtin.TypeError('maxWidth');
                        });
                        b.__str__ = Sk.ffi.functionPy(function (a) {
                          return Sk.builtin.stringToPy('strokeText');
                        });
                        b.__repr__ = Sk.ffi.functionPy(function (a) {
                          return Sk.builtin.stringToPy('strokeText');
                        });
                      }, 'strokeText', []));
                    case 'transform':
                      return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
                        b.__init__ = Sk.ffi.functionPy(function (a) {
                          a.tp$name = 'transform';
                        });
                        b.__call__ = Sk.ffi.functionPy(function (a, b, c, d, f, q, p) {
                          b = Sk.ffi.remapToJs(b);
                          c = Sk.ffi.remapToJs(c);
                          d = Sk.ffi.remapToJs(d);
                          f = Sk.ffi.remapToJs(f);
                          q = Sk.ffi.remapToJs(q);
                          p = Sk.ffi.remapToJs(p);
                          e.transform(b, c, d, f, q, p);
                        });
                        b.__str__ = Sk.ffi.functionPy(function (a) {
                          return Sk.builtin.stringToPy('transform');
                        });
                        b.__repr__ = Sk.ffi.functionPy(function (a) {
                          return Sk.builtin.stringToPy('transform');
                        });
                      }, 'transform', []));
                    case 'translate':
                      return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
                        b.__init__ = Sk.ffi.functionPy(function (a) {
                          a.tp$name = 'translate';
                        });
                        b.__call__ = Sk.ffi.functionPy(function (a, b, c) {
                          b = Sk.ffi.remapToJs(b);
                          c = Sk.ffi.remapToJs(c);
                          e.translate(b, c);
                        });
                        b.__str__ = Sk.ffi.functionPy(function (a) {
                          return Sk.builtin.stringToPy('translate');
                        });
                        b.__repr__ = Sk.ffi.functionPy(function (a) {
                          return Sk.builtin.stringToPy('translate');
                        });
                      }, 'translate', []));
                    }
                  });
                  c.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
                    a = Sk.ffi.remapToJs(a);
                    c = Sk.ffi.remapToJs(c);
                    switch (b) {
                    case 'fillStyle':
                      a.fillStyle = c;
                      break;
                    case 'font':
                      a.font = c;
                      break;
                    case 'lineCap':
                      a.lineCap = c;
                      break;
                    case 'lineJoin':
                      a.lineJoin = c;
                      break;
                    case 'lineWidth':
                      a.lineWidth = c;
                      break;
                    case 'shadowBlur':
                      a.shadowBlur = c;
                      break;
                    case 'shadowColor':
                      a.shadowColor = c;
                      break;
                    case 'shadowOffsetX':
                      a.shadowOffsetX = c;
                      break;
                    case 'shadowOffsetY':
                      a.shadowOffsetY = c;
                      break;
                    case 'strokeStyle':
                      a.strokeStyle = c;
                      break;
                    case 'textAlign':
                      a.textAlign = c;
                      break;
                    case 'textBaseline':
                      a.textBaseline = c;
                      break;
                    default:
                      throw new Sk.builtin.AssertionError(b + ' is not a writeable attribute of CanvasRenderingContext2D');
                    }
                  });
                  c.__str__ = Sk.ffi.functionPy(function (a) {
                    return Sk.builtin.stringToPy('CanvasRenderingContext2D');
                  });
                  c.__repr__ = Sk.ffi.functionPy(function (a) {
                    return Sk.builtin.stringToPy('CanvasRenderingContext2D');
                  });
                }, 'CanvasRenderingContext2D', []));
              });
              c.__str__ = Sk.ffi.functionPy(function (a) {
                return Sk.builtin.stringToPy('getContext');
              });
              c.__repr__ = Sk.ffi.functionPy(function (a) {
                return Sk.builtin.stringToPy('getContext');
              });
            }, 'getContext', []));
          case 'insertBefore':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, c) {
              c.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'insertBefore';
              });
              c.__call__ = Sk.ffi.functionPy(function (a, c, d) {
                return b(g.insertBefore(Sk.ffi.remapToJs(c), Sk.ffi.remapToJs(d)));
              });
              c.__str__ = Sk.ffi.functionPy(function (a) {
                return Sk.builtin.stringToPy('insertBefore');
              });
              c.__repr__ = Sk.ffi.functionPy(function (a) {
                return Sk.builtin.stringToPy('insertBefore');
              });
            }, 'insertBefore', []));
          case 'removeChild':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, c) {
              c.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'removeChild';
              });
              c.__call__ = Sk.ffi.functionPy(function (a, c) {
                return b(g.removeChild(Sk.ffi.remapToJs(c)));
              });
              c.__str__ = Sk.ffi.functionPy(function (a) {
                return Sk.builtin.stringToPy('removeChild');
              });
              c.__repr__ = Sk.ffi.functionPy(function (a) {
                return Sk.builtin.stringToPy('removeChild');
              });
            }, 'removeChild', []));
          case 'setAttribute':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
              b.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'setAttribute';
              });
              b.__call__ = Sk.ffi.functionPy(function (a, b, c) {
                Sk.ffi.checkMethodArgs('setAttribute', arguments, 2, 2);
                Sk.ffi.checkArgType('name', Sk.ffi.PyType.STR, Sk.builtin.isStringPy(b), b);
                g.setAttribute(Sk.builtin.stringToJs(b), Sk.ffi.remapToJs(c));
              });
              b.__str__ = Sk.ffi.functionPy(function (a) {
                return Sk.builtin.stringToPy('setAttribute');
              });
              b.__repr__ = Sk.ffi.functionPy(function (a) {
                return Sk.builtin.stringToPy('setAttribute');
              });
            }, 'setAttribute', []));
          default:
            throw Sk.ffi.err.attribute(d).isNotGetableOnType('Node');
          }
        });
        d.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          a = Sk.ffi.remapToJs(a);
          var d = Sk.ffi.remapToJs(c);
          switch (b) {
          case 'dir':
            a.dir = d;
            break;
          case 'id':
            a.setAttribute(b, d);
            break;
          case 'height':
            a.height = d;
            break;
          case 'innerHTML':
            Sk.ffi.checkArgType('innerHTML', Sk.ffi.PyType.STR, Sk.builtin.isStringPy(c), c);
            a.innerHTML = Sk.builtin.stringToJs(c);
            break;
          case 'width':
            a.width = d;
            break;
          default:
            throw Sk.ffi.err.attribute(b).isNotSetableOnType('Node');
          }
        });
        d.getCSS = Sk.ffi.functionPy(function (a, b) {
          return Sk.builtin.stringToPy(a.v.style[b.v]);
        });
        d.setCSS = Sk.ffi.functionPy(function (a, b, c) {
          a.v.style[b.v] = c.v;
        });
        d.getAttribute = Sk.ffi.functionPy(function (a, b) {
          var c = a.v.getAttribute(b.v);
          return c ? Sk.builtin.stringToPy(c) : null;
        });
        d.setAttribute = Sk.ffi.functionPy(function (a, b, c) {
          a.v.setAttribute(b.v, c.v);
        });
        d.__str__ = Sk.ffi.functionPy(function (a) {
          return Sk.builtin.stringToPy(a.v.tagName);
        });
        d.__repr__ = Sk.ffi.functionPy(function (a) {
          return Sk.builtin.stringToPy('Node');
        });
      }, 'Node', []);
    };
  }.call(this));
  (function () {
    Sk.builtin.defineNumPy = function (a) {
      function b(a, c, d) {
        if (Sk.ffi.isList(a)) {
          a = Sk.ffi.remapToJs(a, !0);
          d.level += 1;
          d.level > d.shape.length && d.shape.push(a.length);
          for (var e = 0, f = a.length; e < f; e++)
            b(a[e], c, d);
          d.level -= 1;
        } else
          c.push(a);
      }
      function c(a) {
        for (var b = null, c = null, d = null, e = a.length, b = 0, c = e - 1; b < e / 2; b++, c--)
          d = a[b], a[b] = a[c], a[c] = d;
      }
      function d(a, b) {
        for (var c = 0, d = 0, e = a.length; d < e; d++)
          c += a[d] * b[d];
        return c;
      }
      function e(a) {
        for (var b = 1, c = 0, d = a.length; c < d; c++)
          b *= a[c];
        return b;
      }
      function f(b) {
        return function (c, d) {
          var e = Sk.ffi.remapToJs(c);
          if (Sk.ffi.isInstance(d, 'ndarray'))
            for (var f = e.buffer, g = Sk.ffi.remapToJs(d).buffer, h = [], l = 0, F = f.length; l < F; l++)
              h[l] = b(f[l], g[l]);
          else
            for (f = e.buffer, h = [], l = 0, F = f.length; l < F; l++)
              h[l] = b(f[l], d);
          e = Sk.ffi.tuplePy(e.shape.map(function (a) {
            return Sk.ffi.numberToIntPy(a);
          }));
          h = Sk.ffi.listPy(h);
          return Sk.ffi.callsim(a.ndarray, e, void 0, h);
        };
      }
      function g(b) {
        return function (c, d) {
          for (var e = Sk.ffi.remapToJs(c), f = e.buffer, g = [], h = 0, l = f.length; h < l; h++)
            g[h] = b(d, f[h]);
          e = Sk.ffi.tuplePy(e.shape.map(function (a) {
            return Sk.ffi.numberToIntPy(a);
          }));
          g = Sk.ffi.listPy(g);
          return Sk.ffi.callsim(a.ndarray, e, void 0, g);
        };
      }
      function h(b) {
        return function (c) {
          var d = Sk.ffi.remapToJs(c);
          c = d.buffer.map(function (a) {
            return b(a);
          });
          d = Sk.ffi.tuplePy(d.shape.map(function (a) {
            return Sk.ffi.numberToIntPy(a);
          }));
          c = Sk.ffi.listPy(c);
          return Sk.ffi.callsim(a.ndarray, d, void 0, c);
        };
      }
      function l(a, b) {
        for (var c = b.map(function (a) {
              return 0;
            }), d = b.length - 1, e = 0, f = '[', g = 0; -1 !== e;)
          c[e] < b[e] ? (0 !== c[e] && (f += ', '), e < d ? (f += '[', e += 1) : (f += Sk.ffi.remapToJs(Sk.ffh.str(a[g++])), c[e] += 1)) : (c[e] = 0, f += ']', e -= 1, 0 <= e && (c[e] += 1));
        return f;
      }
      Sk.ffi.checkFunctionArgs('defineNumPy', arguments, 1, 1);
      a.ndarray = Sk.ffi.buildClass(a, function (b, m) {
        m.__init__ = Sk.ffi.functionPy(function (a, b, d, e, f, g, m) {
          f = {};
          f.shape = Sk.ffi.remapToJs(b);
          b = f.shape.slice(0);
          c(b);
          g = 1;
          for (var h = m = 0, k = b.length; h < k; h++)
            m = b[h], b[h] = g, g *= m;
          c(b);
          f.strides = b;
          f.dtypePy = d;
          Sk.ffi.isDefined(e) && (Sk.ffi.checkArgType('buffer', [Sk.ffi.PyType.LIST], Sk.ffi.isList(e), e), f.buffer = Sk.ffi.remapToJs(e, !0));
          Sk.ffi.referenceToPy(f, 'ndarray', void 0, a);
        });
        m.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'dtype':
            return d.dtypePy;
          case 'ndim':
            return Sk.ffi.numberToIntPy(d.shape.length);
          case 'shape':
            return Sk.ffi.tuplePy(d.shape.map(function (a) {
              return Sk.ffi.numberToIntPy(a);
            }));
          case 'size':
            return Sk.ffi.numberToIntPy(e(d.shape));
          case 'strides':
            return Sk.ffi.tuplePy(d.strides.map(function (a) {
              return Sk.ffi.numberToIntPy(a);
            }));
          case 'buffer':
            return Sk.ffi.listPy(d.buffer);
          case 'copy':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (b, c) {
              c.__init__ = Sk.ffi.functionPy(function (a) {
                Sk.ffi.referenceToPy(null, 'copy', null, a);
              });
              c.__call__ = Sk.ffi.functionPy(function (b) {
                Sk.ffi.checkMethodArgs('copy', arguments, 0, 0);
                var c = Sk.ffi.tuplePy(d.shape.map(function (a) {
                    return Sk.ffi.numberToIntPy(a);
                  })), e = d.buffer.map(function (a) {
                    return a;
                  });
                return Sk.ffi.callsim(a.ndarray, c, d.dtypePy, Sk.ffi.listPy(e));
              });
            }, 'copy', []));
          case 'fill':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
              b.__init__ = Sk.ffi.functionPy(function (a) {
                Sk.ffi.referenceToPy(null, 'fill', null, a);
              });
              b.__call__ = Sk.ffi.functionPy(function (a, b) {
                Sk.ffi.checkMethodArgs('fill', arguments, 1, 1);
                for (var c = 0, e = d.buffer.length; c < e; c++)
                  d.dtypePy && (d.buffer[c] = Sk.misceval.callsim(d.dtypePy, b));
              });
            }, 'fill', []));
          case 'reshape':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (b, c) {
              c.__init__ = Sk.ffi.functionPy(function (a) {
                Sk.ffi.referenceToPy(null, 'reshape', null, a);
              });
              c.__call__ = Sk.ffi.functionPy(function (b, c) {
                Sk.ffi.checkMethodArgs('reshape', arguments, 0, 1);
                return Sk.ffi.callsim(a.ndarray, c, d.dtypePy, Sk.ffi.listPy(d.buffer));
              });
            }, 'reshape', []));
          case 'tolist':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
              b.__init__ = Sk.ffi.functionPy(function (a) {
                Sk.ffi.referenceToPy(null, 'tolist', null, a);
              });
              b.__call__ = Sk.ffi.functionPy(function (a) {
                Sk.ffi.checkMethodArgs('tolist', arguments, 0, 0);
                var b = d.buffer.map(function (a) {
                    return a;
                  });
                return Sk.ffi.listPy(b);
              });
            }, 'tolist', []));
          default:
            throw Sk.ffi.err.attribute(c).isNotGetableOnType('ndarray');
          }
        });
        m.__getitem__ = Sk.ffi.functionPy(function (b, c) {
          var e = Sk.ffi.remapToJs(b);
          Sk.ffi.checkMethodArgs('[]', arguments, 1, 1);
          if (Sk.ffi.isInt(c)) {
            var f = Sk.ffi.remapToJs(c);
            if (1 < e.shape.length) {
              for (var g = e.strides[0], m = [], h = 0, k = f * g, f = (f + 1) * g; k < f; k++)
                m[h++] = e.buffer[k];
              h = Sk.ffi.listPy(m);
              e = Sk.ffi.tuplePy(Array.prototype.slice.call(e.shape, 1).map(function (a) {
                return Sk.ffi.numberToIntPy(a);
              }));
              return Sk.ffi.callsim(a.ndarray, e, void 0, h);
            }
            if (0 <= f && f < e.buffer.length)
              return e.buffer[f];
            throw new Sk.builtin.IndexError('array index out of range');
          }
          if (Sk.ffi.isTuple(c))
            return m = Sk.ffi.remapToJs(c), e.buffer[d(e.strides, m)];
          if (Sk.ffi.isFunction(c)) {
            m = c.indices();
            k = 'undefined' !== typeof m[0] ? m[0] : 0;
            f = 'undefined' !== typeof m[1] ? m[1] : e.buffer.length;
            f = f > e.buffer.length ? e.buffer.length : f;
            g = 'undefined' !== typeof m[2] ? m[2] : 1;
            m = [];
            h = 0;
            if (0 < g)
              for (; k < f; k += g)
                m[h++] = e.buffer[k];
            h = Sk.ffi.listPy(m);
            e = Sk.ffi.tuplePy([m.length].map(function (a) {
              return Sk.ffi.numberToIntPy(a);
            }));
            return Sk.ffi.callsim(a.ndarray, e, void 0, h);
          }
          Sk.ffi.checkArgType('index', [
            Sk.ffi.PyType.INT,
            Sk.ffi.PyType.TUPLE,
            Sk.ffi.PyType.FUNCTION
          ], !1, c);
        });
        m.__setitem__ = Sk.ffi.functionPy(function (a, b, c) {
          var e = Sk.ffi.remapToJs(a);
          Sk.ffi.checkMethodArgs('[]', arguments, 2, 2);
          if (Sk.ffi.isInt(b)) {
            var f = Sk.ffi.remapToJs(b);
            if (1 < e.shape.length)
              for (var g = Sk.ffi.remapToJs(c), m = e.strides[0], h = 0, k = f * m, f = (f + 1) * m; k < f; k++)
                e.buffer[k] = g.buffer[h++];
            else if (0 <= f && f < e.buffer.length)
              e.buffer[f] = c;
            else
              throw new Sk.builtin.IndexError('array index out of range');
          } else
            Sk.ffi.isTuple(b) ? (g = Sk.ffi.remapToJs(b), e = Sk.ffi.remapToJs(a), e.buffer[d(e.strides, g)] = c) : Sk.ffi.checkArgType('index', [
              Sk.ffi.PyType.INT,
              Sk.ffi.PyType.TUPLE
            ], !1, b);
        });
        m.__len__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.numberToIntPy(a.shape[0]);
        });
        m.__iter__ = Sk.ffi.functionPy(function (a) {
          var b = {
              tp$iter: function () {
                return b;
              },
              $obj: Sk.ffi.remapToJs(a),
              $index: 0,
              tp$iternext: function () {
                return b.$index >= b.$obj.buffer.length ? void 0 : b.$obj.buffer[b.$index++];
              }
            };
          return b;
        });
        m.__add__ = Sk.ffi.functionPy(f(Sk.ffh.add));
        m.__radd__ = Sk.ffi.functionPy(g(Sk.ffh.add));
        m.__sub__ = Sk.ffi.functionPy(f(Sk.ffh.sub));
        m.__rsub__ = Sk.ffi.functionPy(g(Sk.ffh.sub));
        m.__mul__ = Sk.ffi.functionPy(f(Sk.ffh.mul));
        m.__rmul__ = Sk.ffi.functionPy(g(Sk.ffh.mul));
        m.__div__ = Sk.ffi.functionPy(f(Sk.ffh.div));
        m.__rdiv__ = Sk.ffi.functionPy(g(Sk.ffh.div));
        m.__mod__ = Sk.ffi.functionPy(f(Sk.ffh.mod));
        m.__rmod__ = Sk.ffi.functionPy(g(Sk.ffh.mod));
        m.__xor__ = Sk.ffi.functionPy(f(Sk.ffh.xor));
        m.__rxor__ = Sk.ffi.functionPy(g(Sk.ffh.xor));
        m.__lshift__ = Sk.ffi.functionPy(f(Sk.ffh.lshift));
        m.__rlshift__ = Sk.ffi.functionPy(g(Sk.ffh.lshift));
        m.__rshift__ = Sk.ffi.functionPy(f(Sk.ffh.rshift));
        m.__rrshift__ = Sk.ffi.functionPy(g(Sk.ffh.rshift));
        m.__pos__ = Sk.ffi.functionPy(h(Sk.ffh.positive));
        m.__neg__ = Sk.ffi.functionPy(h(Sk.ffh.negative));
        m.__exp__ = Sk.ffi.functionPy(h(Sk.ffh.exp));
        m.__sin__ = Sk.ffi.functionPy(h(Sk.ffh.sin));
        m.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.builtin.stringToPy(l(a.buffer, a.shape));
        });
        m.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.builtin.stringToPy('array(' + l(a.buffer, a.shape) + ')');
        });
      }, 'ndarray', []);
      a.array = Sk.ffi.functionPy(function (c, d, e, f, q, g) {
        Sk.ffi.checkFunctionArgs('array', arguments, 1, 6);
        Sk.ffi.checkArgType('object', [Sk.ffi.PyType.LIST], Sk.ffi.isList(c), c);
        Sk.ffi.isDefined(e) && Sk.ffi.checkArgType('copy', [Sk.ffi.PyType.BOOL], Sk.ffi.isBool(e), e);
        var h = [], l = {
            level: 0,
            shape: []
          };
        b(c, h, l);
        if (Sk.ffi.isDefined(d)) {
          Sk.ffi.checkArgType('dtype', [Sk.ffi.PyType.FUNCTION], Sk.ffi.isFunction(d), d);
          for (var F = 0, H = h.length; F < H; F++)
            h[F] = Sk.misceval.callsim(d, h[F]);
        }
        l = Sk.ffi.tuplePy(l.shape.map(function (a) {
          return Sk.ffi.numberToFloatPy(a);
        }));
        h = Sk.ffi.listPy(h);
        return Sk.ffi.callsim(a.ndarray, l, d, h);
      });
      a.empty = Sk.ffi.functionPy(function (a, b, c) {
        Sk.ffi.checkFunctionArgs('empty', arguments, 1, 3);
      });
      a.linspace = Sk.ffi.functionPy(function (b, c, d, e, f) {
        Sk.ffi.checkFunctionArgs('linspace(start, stop, num=50, endpoint=True, retstep=False)', arguments, 2, 5);
        var g;
        Sk.ffi.isDefined(d) ? (Sk.ffi.checkArgType('num', [Sk.ffi.PyType.INT], Sk.ffi.isInt(d), d), g = Sk.ffi.remapToJs(d)) : (g = 50, d = Sk.ffi.numberToIntPy(50));
        var h;
        Sk.ffi.isDefined(e) ? (Sk.ffi.checkArgType('endpoint', [Sk.ffi.PyType.BOOL], Sk.ffi.isBool(e), e), h = Sk.ffi.remapToJs(e)) : h = !0;
        var l;
        Sk.ffi.isDefined(f) ? (Sk.ffi.checkArgType('retstep', [Sk.ffi.PyType.BOOL], Sk.ffi.isBool(f), f), l = Sk.ffi.remapToJs(f)) : l = !1;
        var F = Sk.ffh.sub(c, b);
        h = h ? Sk.ffh.div(F, Sk.ffh.sub(d, Sk.ffi.numberToIntPy(1))) : Sk.ffh.div(F, d);
        for (var F = [], H = 0; H < g; H++)
          F[H] = Sk.ffh.add(Sk.ffh.mul(Sk.ffi.numberToFloatPy(H), h), b);
        g = [];
        g[0] = d;
        g = Sk.ffi.tuplePy(g);
        g = Sk.ffi.callsim(a.ndarray, g, void 0, Sk.ffi.listPy(F));
        return l ? Sk.ffi.tuplePy([
          g,
          h
        ]) : g;
      });
      a.zeros = Sk.ffi.functionPy(function (b, c, d) {
        Sk.ffi.checkFunctionArgs('zeros', arguments, 1, 2);
        Sk.ffi.checkArgType('shape', [Sk.ffi.PyType.TUPLE], Sk.ffi.isTuple(b), b);
        for (var f = Sk.ffi.remapToJs(b), f = e(f), q = [], g = Sk.ffi.numberToFloatPy(0), h = 0; h < f; h++)
          q[h] = g;
        return Sk.ffi.callsim(a.ndarray, b, c, Sk.ffi.listPy(q));
      });
    };
  }.call(this));
  (function () {
    Sk.builtin.defineProbeE3 = function (a, b) {
      Sk.ffi.checkFunctionArgs('defineProbeE3', arguments, 2, 2);
      var c = [
          Sk.ffi.PyType.FLOAT,
          Sk.ffi.PyType.INT,
          Sk.ffi.PyType.LONG
        ];
      a.ProbeE3 = Sk.ffi.buildClass(a, function (a, c) {
        c.__init__ = Sk.ffi.functionPy(function (a, b, c, d, e) {
          Sk.ffi.checkMethodArgs('ProbeE3', arguments, 4, 4);
          var m = {};
          m.grade0 = b;
          m.grade1 = c;
          m.grade2 = d;
          m.grade3 = e;
          m.quantity = Sk.builtin.none.none$;
          Sk.ffi.referenceToPy(m, 'ProbeE3', void 0, a);
        });
        c.__getattr__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a);
          switch (b) {
          case 'grade0':
            return c.grade0;
          case 'grade1':
            return c.grade1;
          case 'grade2':
            return c.grade2;
          case 'grade3':
            return c.grade3;
          case 'position':
            return c.position;
          case 'quantity':
            return c.quantity;
          default:
            throw Sk.ffi.err.attribute(b).isNotGetableOnType('ProbeE3');
          }
        });
        c.__setattr__ = Sk.ffi.functionPy(function (a, c, d) {
          a = Sk.ffi.remapToJs(a);
          switch (c) {
          case 'position':
            Sk.ffi.checkArgType('position', 'Euclidean3', Sk.ffi.isInstance(d, 'Euclidean3'), d);
            a.position = d;
            d = Sk.ffi.remapToJs(d).vector;
            var e = Sk.ffi.remapToJs(a.grade0);
            e.position = d;
            e = Sk.ffi.remapToJs(a.grade1);
            e.position = d;
            var k = Sk.ffi.remapToJs(a.grade2);
            k.position = d;
            var m = Sk.ffi.remapToJs(a.grade3);
            m.position = d;
            break;
          case 'quantity':
            Sk.ffi.checkArgType('quantity', 'Euclidean3', Sk.ffi.isInstance(d, 'Euclidean3'), d);
            m = function (a, c, d) {
              if (-1 !== d) {
                var e = 1 / Math.sqrt(2 * (1 + d));
                return new b.Quaternion(-(+e * c), -(-e * a), -0, e * (1 + d));
              }
              return new b.Quaternion(1, 0, 0, 0);
            };
            c = function (a, b) {
              a.scale.set(b, b, b);
              a.traverse(function (a) {
                a.visible = !0;
              });
            };
            var p = function (a) {
                a.traverse(function (a) {
                  a.visible = !1;
                });
                a.scale.set(1, 1, 1);
              }, n = Sk.ffi.remapToJs(d), q = n.w, k = n.x, x = n.y, D = n.z, J = n.xy, F = n.yz, H = n.zx, n = n.xyz, e = Sk.ffi.remapToJs(a.grade0), q = Math.abs(q);
            0 !== q ? c(e, q) : p(e);
            e = Sk.ffi.remapToJs(a.grade1);
            0 !== k || 0 !== x || 0 !== D ? (q = Math.sqrt(k * k + x * x + D * D), x = m(k / q, x / q, D / q), e.quaternion.set(x.x, x.y, x.z, x.w), c(e, q)) : p(e);
            k = Sk.ffi.remapToJs(a.grade2);
            0 !== J || 0 !== F || 0 !== H ? (x = Math.sqrt(J * J + F * F + H * H), D = Math.pow(x, 0.5), x = m(F / x, H / x, J / x), k.quaternion.set(x.x, x.y, x.z, x.w), c(k, D)) : p(k);
            m = Sk.ffi.remapToJs(a.grade3);
            if (0 !== n) {
              p = Math.pow(Math.abs(n), 1 / 3);
              try {
                Sk.ffi.sattr(a.grade3, 'orientation', Sk.ffi.booleanToPy(0 <= ('number' === typeof n ? n ? 0 > n ? -1 : 1 : isNaN(n) ? NaN : 0 : NaN)));
              } catch (z) {
              }
              c(m, p);
            } else
              p(m);
            a.quantity = d;
            break;
          case 'grade0':
            a.grade0 = d;
            break;
          case 'grade1':
            a.grade1 = d;
            break;
          case 'grade2':
            a.grade2 = d;
            break;
          case 'grade3':
            a.grade3 = d;
            break;
          default:
            throw Sk.ffi.err.attribute(c).isNotSetableOnType('ProbeE3');
          }
        });
        c.__str__ = Sk.ffi.functionPy(function (a) {
          return Sk.builtin.stringToPy('ProbeE3');
        });
        c.__repr__ = Sk.ffi.functionPy(function (a) {
          return Sk.builtin.stringToPy('ProbeE3');
        });
      }, 'ProbeE3', []);
      a.ProbeBuilderE3 = Sk.ffi.buildClass(a, function (b, e) {
        e.__init__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.checkMethodArgs('ProbeBuilderE3', arguments, 0, 0);
          Sk.ffi.referenceToPy({
            segments: 12,
            wireframe: !1
          }, 'ProbeBuilderE3', void 0, a);
        });
        e.__getattr__ = Sk.ffi.functionPy(function (b, d) {
          var e = Sk.ffi.remapToJs(b);
          switch (d) {
          case 'color':
            return Sk.ffi.callableToPy(a, d, function (a, k) {
              Sk.ffi.checkMethodArgs(d, arguments, 1, 1);
              Sk.ffi.checkArgType(d, [
                c,
                Sk.ffi.PyType.STR,
                'Color'
              ], Sk.ffi.isNum(k) || Sk.builtin.isStringPy(k) || Sk.ffi.isInstance(k, 'Color'), k);
              e.color = k;
              return b;
            });
          case 'segments':
            return Sk.ffi.callableToPy(a, d, function (a, c) {
              Sk.ffi.checkMethodArgs(d, arguments, 1, 1);
              Sk.ffi.checkArgType(d, Sk.ffi.PyType.INT, Sk.ffi.isInt(c), c);
              e.segments = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'wireframe':
            return Sk.ffi.callableToPy(a, d, function (a, c) {
              Sk.ffi.checkMethodArgs(d, arguments, 1, 1);
              Sk.ffi.checkArgType(d, Sk.ffi.PyType.BOOL, Sk.ffi.isBool(c), c);
              e.wireframe = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'build':
            return Sk.ffi.callableToPy(a, d, function (b) {
              b = [
                'SphereBuilder',
                Sk.geometry.ARROW_BUILDER,
                Sk.geometry.VORTEX_BUILDER,
                Sk.geometry.VOLUME_BUILDER
              ].map(function (b) {
                b = Sk.ffi.callsim(a[b]);
                e.color && Sk.ffi.callsim(Sk.ffi.gattr(b, 'color'), e.color);
                Sk.ffi.callsim(Sk.ffi.gattr(b, 'normalize'));
                Sk.ffi.callsim(Sk.ffi.gattr(b, 'segments'), Sk.ffi.numberToIntPy(e.segments));
                Sk.ffi.callsim(Sk.ffi.gattr(b, 'wireframe'), Sk.ffi.booleanToPy(e.wireframe));
                return Sk.ffi.callsim(Sk.ffi.gattr(b, 'build'));
              });
              return Sk.ffi.callsim(a.ProbeE3, b[0], b[1], b[2], b[3]);
            });
          default:
            throw Sk.ffi.err.attribute(d).isNotGetableOnType('ProbeBuilderE3');
          }
        });
        e.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          Sk.ffi.remapToJs(a);
          switch (b) {
          default:
            throw Sk.ffi.err.attribute(b).isNotSetableOnType('ProbeBuilderE3');
          }
        });
        e.__str__ = Sk.ffi.functionPy(function (a) {
          return Sk.builtin.stringToPy('ProbeBuilderE3');
        });
        e.__repr__ = Sk.ffi.functionPy(function (a) {
          return Sk.builtin.stringToPy('ProbeBuilderE3');
        });
      }, 'ProbeBuilderE3', []);
    };
  }.call(this));
  (function () {
    Sk.builtin.defineEuclidean2 = function (a, b) {
      function c(a) {
        return 'number' === typeof a;
      }
      function d(b, c, d, e) {
        return Sk.ffi.callsim(a.Euclidean2, Sk.ffi.numberToFloatPy(b), Sk.ffi.numberToFloatPy(c), Sk.ffi.numberToFloatPy(d), Sk.ffi.numberToFloatPy(e));
      }
      function e(a, b, c) {
        var d, e, f, g, D = [];
        d = function (a, b) {
          var d;
          if (0 !== a) {
            0 <= a ? 0 < D.length && D.push('+') : D.push('-');
            d = Math.abs(a);
            if (1 === d)
              return D.push(b);
            D.push(Sk.builtin.numberToFloatStringJs(d, 10, !0));
            if (b !== h)
              return D.push(c), D.push(b);
          }
        };
        e = f = 0;
        for (g = a.length - 1; 0 <= g ? f <= g : f >= g; e = 0 <= g ? ++f : --f)
          d(a[e], b[e]);
        return 0 < D.length ? D.join('') : Sk.builtin.numberToFloatStringJs(0, 10, !0);
      }
      function f(a, b, c, e, f, q, g, h, J) {
        var F = +f, H = +q, z = +g, G = -h, E = +(f * F + q * H + g * z - h * G), C = F * E + -0 * H + -0 * z - -0 * G, A = -0 * F + H * E - -0 * z + -0 * G, u = -0 * F + -0 * H + z * E - -0 * G, F = -0 * F + -0 * H - -0 * z + G * E;
        f = f * C + q * A + g * u - h * F;
        C /= f;
        A /= f;
        u /= f;
        h = F / f;
        f = a * C + b * A + c * u - e * h;
        q = a * A + b * C - c * h + e * u;
        g = a * u + b * h + c * C - e * A;
        a = a * h + b * u - c * A + e * C;
        if ('undefined' !== typeof J)
          J.w = f, J.x = q, J.y = g, J.xy = a;
        else
          return d(f, q, g, a);
      }
      Sk.ffi.checkFunctionArgs('defineEuclidean2', arguments, 2, 2);
      var g = [
          Sk.ffi.PyType.FLOAT,
          Sk.ffi.PyType.INT,
          Sk.ffi.PyType.LONG
        ], h = Sk.builtin.numberToFloatStringJs(1, 10, !0);
      a.ScalarE2 = Sk.ffi.functionPy(function (a) {
        Sk.ffi.checkFunctionArgs('ScalarE2', arguments, 1, 1);
        Sk.ffi.checkArgType('w', g, Sk.ffi.isNum(a), a);
        return d(Sk.ffi.remapToJs(a), 0, 0, 0);
      });
      a.VectorE2 = Sk.ffi.functionPy(function (a, b) {
        Sk.ffi.checkFunctionArgs('VectorE2', arguments, 2, 2);
        Sk.ffi.checkArgType('x', g, Sk.ffi.isNum(a), a);
        Sk.ffi.checkArgType('y', g, Sk.ffi.isNum(b), b);
        return d(0, Sk.ffi.remapToJs(a), Sk.ffi.remapToJs(b), 0);
      });
      a.PseudoscalarE2 = Sk.ffi.functionPy(function (a) {
        Sk.ffi.checkFunctionArgs('PseudoscalarE2', arguments, 1, 1);
        Sk.ffi.checkArgType('xy', g, Sk.ffi.isNum(a), a);
        return d(0, 0, 0, Sk.ffi.remapToJs(a));
      });
      a.Euclidean2 = Sk.ffi.buildClass(a, function (l, k) {
        k.__init__ = Sk.ffi.functionPy(function (a, c, d, e, f) {
          Sk.ffi.checkMethodArgs('Euclidean2', arguments, 1, 4);
          switch (Sk.ffi.getType(c)) {
          case Sk.ffi.PyType.FLOAT:
          case Sk.ffi.PyType.INT:
          case Sk.ffi.PyType.LONG:
            Sk.ffi.checkMethodArgs('Euclidean2', arguments, 4, 4);
            Sk.ffi.checkArgType('w', g, Sk.ffi.isNum(c), c);
            Sk.ffi.checkArgType('x', g, Sk.ffi.isNum(d), d);
            Sk.ffi.checkArgType('y', g, Sk.ffi.isNum(e), e);
            Sk.ffi.checkArgType('xy', g, Sk.ffi.isNum(f), f);
            Sk.ffi.referenceToPy(new b.Euclidean2(Sk.ffi.remapToJs(c), Sk.ffi.remapToJs(d), Sk.ffi.remapToJs(e), Sk.ffi.remapToJs(f)), 'Euclidean2', void 0, a);
            break;
          case Sk.ffi.PyType.INSTANCE:
            Sk.ffi.checkMethodArgs('Euclidean2', arguments, 1, 1);
            Sk.ffi.checkArgType('w', g, Sk.ffi.isInstance(c, 'Euclidean2'), c);
            Sk.ffi.referenceToPy(Sk.ffi.remapToJs(c), 'Euclidean2', void 0, a);
            break;
          default:
            Sk.ffi.checkArgType('w', g, !1, c);
          }
        });
        k.__add__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(b);
          if (Sk.ffi.isNum(b))
            return d(c.w + e, c.x, c.y, c.xy);
          if (Sk.ffi.isInstance(b, 'Euclidean2'))
            return d(c.w + e.w, c.x + e.x, c.y + e.y, c.xy + e.xy);
        });
        k.__radd__ = Sk.ffi.functionPy(function (a, b) {
          Sk.ffi.checkLhsOperandType('add', g, Sk.ffi.isNum(b), b);
          var c = Sk.ffi.remapToJs(b), e = Sk.ffi.remapToJs(a);
          return d(c + e.w, e.x, e.y, e.xy);
        });
        k.__iadd__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a), d = Sk.ffi.remapToJs(b);
          if (Sk.ffi.isNum(b))
            return c.w += d, a;
          if (Sk.ffi.isInstance(b, 'Euclidean2'))
            return c.w += d.w, c.x += d.x, c.y += d.y, c.xy += d.xy, a;
        });
        k.__sub__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(b);
          if (Sk.ffi.isNum(b))
            return d(c.w - e, c.x, c.y, c.xy);
          if (Sk.ffi.isInstance(b, 'Euclidean2'))
            return d(c.w - e.w, c.x - e.x, c.y - e.y, c.xy - e.xy);
        });
        k.__rsub__ = Sk.ffi.functionPy(function (a, b) {
          Sk.ffi.checkLhsOperandType('add', g, Sk.ffi.isNum(b), b);
          var c = Sk.ffi.remapToJs(b), e = Sk.ffi.remapToJs(a);
          return d(c - e.w, -e.x, -e.y, -e.xy);
        });
        k.__isub__ = Sk.ffi.functionPy(function (a, b) {
          var d = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(b);
          c(e) ? d.w -= e : (d.w -= e.w, d.x -= e.x, d.y -= e.y, d.xy -= e.xy);
          return a;
        });
        k.__mul__ = Sk.ffi.functionPy(function (a, b) {
          switch (Sk.ffi.getType(b)) {
          case Sk.ffi.PyType.INSTANCE:
            switch (Sk.ffi.typeName(b)) {
            case 'Euclidean2':
              var c = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(b), f = c.w, g = c.x, h = c.y, c = c.xy, k = e.w, l = e.x, z = e.y, e = e.xy;
              return d(f * k + g * l + h * z - c * e, f * l + g * k - h * e + c * z, f * z + g * e + h * k - c * l, f * e + g * z - h * l + c * k);
            default:
              return;
            }
          case Sk.ffi.PyType.FLOAT:
          case Sk.ffi.PyType.INT:
          case Sk.ffi.PyType.LONG:
            return c = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(b), d(c.w * e, c.x * e, c.y * e, c.xy * e);
          }
        });
        k.__rmul__ = Sk.ffi.functionPy(function (a, b) {
          b = Sk.ffi.remapToJs(b);
          a = Sk.ffi.remapToJs(a);
          if (c(b))
            return d(b * a.w, b * a.x, b * a.y, b * a.xy);
        });
        k.__imul__ = Sk.ffi.functionPy(function (a, b) {
          var d = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(b);
          if (c(e))
            d.w *= e, d.x *= e, d.y *= e, d.xy *= e;
          else {
            var f = d.w, g = d.x, h = d.y, k = d.xy, l = e.w, z = e.x, G = e.y, e = e.xy;
            d.w = f * l + g * z + h * G - k * e;
            d.x = f * z + g * l - h * e + k * G;
            d.y = f * G + g * e + h * l - k * z;
            d.xy = f * e + g * G - h * z + k * l;
          }
          return a;
        });
        k.__div__ = Sk.ffi.functionPy(function (a, b) {
          a = Sk.ffi.remapToJs(a);
          b = Sk.ffi.remapToJs(b);
          return c(b) ? f(a.w, a.x, a.y, a.xy, b, 0, 0, 0, void 0) : f(a.w, a.x, a.y, a.xy, b.w, b.x, b.y, b.xy, void 0);
        });
        k.__rdiv__ = Sk.ffi.functionPy(function (a, b) {
          b = Sk.ffi.remapToJs(b);
          a = Sk.ffi.remapToJs(a);
          if (c(b))
            return f(b, 0, 0, 0, a.w, a.x, a.y, a.xy, void 0);
          throw new Sk.builtin.AssertionError('' + JSON.stringify(b, null, 2) + ' / ' + JSON.stringify(a, null, 2));
        });
        k.__idiv__ = Sk.ffi.functionPy(function (a, b) {
          var d = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(b);
          c(e) ? f(d.w, d.x, d.y, d.xy, e, 0, 0, 0, d) : f(d.w, d.x, d.y, d.xy, e.w, e.x, e.y, e.xy, d);
          return a;
        });
        k.__mod__ = Sk.ffi.functionPy(function (a, b) {
          switch (Sk.ffi.getType(b)) {
          case Sk.ffi.PyType.INSTANCE:
            switch (Sk.ffi.typeName(b)) {
            case 'Euclidean2':
              var c = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(b);
              return d(c.w * e.w + c.x * e.x + c.y * e.y + c.xy * e.xy, 0, 0, 0);
            default:
              return;
            }
          case Sk.ffi.PyType.FLOAT:
          case Sk.ffi.PyType.INT:
          case Sk.ffi.PyType.LONG:
            return c = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(b), d(c.w * e, c.x * e, c.y * e, c.xy * e);
          }
        });
        k.__rmod__ = Sk.ffi.functionPy(function (a, b) {
          var e = Sk.ffi.remapToJs(a), f = Sk.ffi.remapToJs(b);
          if (c(f))
            return d(f * e.w, f * e.x, f * e.y, f * e.xy);
        });
        k.__xor__ = Sk.ffi.functionPy(function (a, b) {
          switch (Sk.ffi.getType(b)) {
          case Sk.ffi.PyType.INSTANCE:
            switch (Sk.ffi.typeName(b)) {
            case 'Euclidean2':
              var c = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(b), f = c.w, g = c.x, h = c.y, k = e.w, l = e.x, z = e.y;
              return d(f * k, f * l + g * k, f * z + h * k, f * e.xy + g * z - h * l + c.xy * k);
            default:
              return;
            }
          case Sk.ffi.PyType.FLOAT:
          case Sk.ffi.PyType.INT:
          case Sk.ffi.PyType.LONG:
            return c = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(b), d(c.w * e, c.x * e, c.y * e, c.xy * e);
          }
        });
        k.__rxor__ = Sk.ffi.functionPy(function (a, b) {
          b = Sk.ffi.remapToJs(b);
          a = Sk.ffi.remapToJs(a);
          if (c(b))
            return d(b * a.w, b * a.x, b * a.y, b * a.xy);
        });
        k.__ixor__ = Sk.ffi.functionPy(function (a, b) {
          var d = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(b);
          if (c(e))
            d.w *= e, d.x *= e, d.y *= e, d.xy *= e;
          else {
            var f = d.w, g = d.x, h = d.y, k = d.xy, l = e.w, z = e.x, G = e.y, e = e.xy;
            d.w = f * l;
            d.x = f * z + g * l;
            d.y = f * G + h * l;
            d.xy = f * e + g * G - h * z + k * l;
          }
          return a;
        });
        k.__lshift__ = Sk.ffi.functionPy(function (a, b) {
          switch (Sk.ffi.getType(b)) {
          case Sk.ffi.PyType.INSTANCE:
            switch (Sk.ffi.typeName(b)) {
            case 'Euclidean2':
              var c = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(b), f = c.w, g = c.x, h = c.y, k = e.x, l = e.y, z = e.xy;
              return d(f * e.w + g * k + h * l - c.xy * z, f * k - h * z, f * l + g * z, f * z);
            default:
              return;
            }
          case Sk.ffi.PyType.FLOAT:
          case Sk.ffi.PyType.INT:
          case Sk.ffi.PyType.LONG:
            return c = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(b), d(c.w * e, 0, 0, 0);
          }
        });
        k.__rlshift__ = Sk.ffi.functionPy(function (a, b) {
          b = Sk.ffi.remapToJs(b);
          a = Sk.ffi.remapToJs(a);
          if (c(b))
            return d(b * a.w, b * a.x, b * a.y, b * a.xy);
        });
        k.__ilshift__ = Sk.ffi.functionPy(function (a, b) {
          var d = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(b);
          if (c(e))
            d.w *= e, d.x = 0, d.y = 0, d.xy = 0;
          else {
            var f = d.w, g = d.x, h = d.y, k = e.x, l = e.y, z = e.xy;
            d.w = f * e.w + g * k + h * l - d.xy * z;
            d.x = f * k - h * z;
            d.y = f * l + g * z;
            d.xy = f * z;
          }
          return a;
        });
        k.__rshift__ = Sk.ffi.functionPy(function (a, b) {
          switch (Sk.ffi.getType(b)) {
          case Sk.ffi.PyType.INSTANCE:
            switch (Sk.ffi.typeName(b)) {
            case 'Euclidean2':
              var c = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(b), f = c.x, g = c.y, h = c.xy, k = e.w, l = e.x, z = e.y;
              return d(c.w * k + f * l + g * z - h * e.xy, +f * k + h * z, +g * k - h * l, h * k);
            default:
              return;
            }
          case Sk.ffi.PyType.FLOAT:
          case Sk.ffi.PyType.INT:
          case Sk.ffi.PyType.LONG:
            return c = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(b), d(c.w * e, -c.x * e, -c.y * e, c.xy * e);
          }
        });
        k.__rrshift__ = Sk.ffi.functionPy(function (a, b) {
          b = Sk.ffi.remapToJs(b);
          a = Sk.ffi.remapToJs(a);
          if (c(b))
            return d(b * a.w, 0, 0, 0);
        });
        k.__irshift__ = Sk.ffi.functionPy(function (a, b) {
          var d = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(b);
          if (c(e)) {
            var f = d.w, g = d.x, h = d.y, k = d.xy, l = e, z = 0, G = 0, E = 0;
            d.w *= e;
            d.x *= -e;
            d.y *= -e;
            d.xy *= e;
          } else
            f = d.w, g = d.x, h = d.y, k = d.xy, l = e.w, z = e.x, G = e.y, E = e.xy, d.w = f * l + g * z + h * G - k * E, d.x = +g * l + k * G, d.y = +h * l - k * z, d.xy = k * l;
          return a;
        });
        k.u$negative = function () {
          var a = Sk.ffi.remapToJs(this);
          return d(-a.w, -a.x, -a.y, -a.xy);
        };
        k.u$positive = function () {
          return this;
        };
        k.nb$invert = function () {
          var a = Sk.ffi.remapToJs(this);
          return d(a.w, a.x, a.y, -a.xy);
        };
        k.__getitem__ = Sk.ffi.functionPy(function (a, b) {
          a = Sk.ffi.remapToJs(a);
          b = Sk.ffi.remapToJs(b);
          switch (b) {
          case 0:
            return d(a.w, 0, 0, 0);
          case 1:
            return d(0, a.x, a.y, 0);
          case 2:
            return d(0, 0, 0, a.xy);
          }
        });
        k.__cliffordConjugate__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.checkMethodArgs('cliffordConjugate', arguments, 0, 0);
          var b = Sk.ffi.remapToJs(a);
          return d(b.w, -b.x, -b.y, -b.xy);
        });
        k.__cos__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.checkMethodArgs('cos', arguments, 0, 0);
          var b = Sk.ffi.remapToJs(a), c = b.w, e = b.xy, b = Sk.math.cos(c), f = (Math.pow(Math.E, e) + Math.pow(Math.E, -e)) / 2, c = Sk.math.sin(c), e = (Math.pow(Math.E, e) - Math.pow(Math.E, -e)) / 2;
          return d(b * f, 0, 0, -c * e);
        });
        k.__sin__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.checkMethodArgs('sin', arguments, 0, 0);
          var b = Sk.ffi.remapToJs(a), c = b.w, e = b.xy, b = Sk.math.cos(c), f = (Math.pow(Math.E, e) + Math.pow(Math.E, -e)) / 2, c = Sk.math.sin(c), e = (Math.pow(Math.E, e) - Math.pow(Math.E, -e)) / 2;
          return d(c * f, 0, 0, b * e);
        });
        k.__tan__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.checkMethodArgs('tan', arguments, 0, 0);
          return Sk.ffh.div(Sk.ffh.sin(a), Sk.ffh.cos(a));
        });
        k.__acos__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.checkMethodArgs('acos', arguments, 0, 0);
          var b = Sk.ffi.remapToJs(a);
          return d(Math.acos(b.w), 0, 0, 0);
        });
        k.__asin__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.checkMethodArgs('asin', arguments, 0, 0);
          var b = Sk.ffi.remapToJs(a);
          return d(Math.asin(b.w), 0, 0, 0);
        });
        k.__atan__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.checkMethodArgs('atan', arguments, 0, 0);
          var b = Sk.ffi.remapToJs(a);
          return d(Math.atan(b.w), 0, 0, 0);
        });
        k.__exp__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.checkMethodArgs('exp', arguments, 0, 0);
          var b = Sk.ffi.remapToJs(a), c = b.xy, b = Math.exp(b.w), e = Sk.math.cos(c), c = Sk.math.sin(c);
          return d(b * e, 0, 0, b * c);
        });
        k.__abs__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.numberToFloatPy(Math.sqrt(a.w * a.w + a.x * a.x + a.y * a.y + a.xy * a.xy));
        });
        k.__magnitude__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return d(Math.sqrt(a.w * a.w + a.x * a.x + a.y * a.y + a.xy * a.xy), 0, 0, 0);
        });
        k.__quadrance__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return d(a.w * a.w + a.x * a.x + a.y * a.y + a.xy * a.xy, 0, 0, 0);
        });
        k.__sqrt__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.checkMethodArgs('sqrt', arguments, 0, 0);
          var b = Sk.ffi.remapToJs(a);
          return d(Math.sqrt(b.w), 0, 0, 0);
        });
        k.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.builtin.stringToPy('Euclidean2(' + [
            a.w,
            a.x,
            a.y,
            a.xy
          ].map(function (a) {
            return String(a);
          }).join(', ') + ')');
        });
        k.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return a.isNaN() ? Sk.builtin.stringToPy('NaN') : Sk.builtin.stringToPy(e([
            a.w,
            a.x,
            a.y,
            a.xy
          ], [
            h,
            'e1',
            'e2',
            'I'
          ], '*'));
        });
        k.__eq__ = Sk.ffi.functionPy(function (a, b) {
          a = Sk.ffi.remapToJs(a);
          b = Sk.ffi.remapToJs(b);
          return a.w === b.w && a.x === b.x && a.y === b.y && a.xy === b.xy;
        });
        k.__ne__ = Sk.ffi.functionPy(function (a, b) {
          a = Sk.ffi.remapToJs(a);
          b = Sk.ffi.remapToJs(b);
          return a.w !== b.w || a.x !== b.x || a.y !== b.y || a.xy !== b.xy;
        });
        k.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var e = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'w':
            return Sk.ffi.numberToFloatPy(e.w);
          case 'x':
            return Sk.ffi.numberToFloatPy(e.x);
          case 'y':
            return Sk.ffi.numberToFloatPy(e.y);
          case 'xy':
            return Sk.ffi.numberToFloatPy(e.xy);
          case 'clone':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
              b.__init__ = Sk.ffi.functionPy(function (a) {
              });
              b.__call__ = Sk.ffi.functionPy(function (a) {
                return d(e.w, e.x, e.y, e.xy);
              });
            }, 'clone', []));
          case 'dot':
            return Sk.ffi.callableToPy(a, c, function (a, b) {
              Sk.ffi.checkMethodArgs(c, arguments, 1, 1);
              Sk.ffi.checkArgType('other', 'Euclidean2', Sk.ffi.isInstance(b, 'Euclidean2'), b);
              var f = Sk.ffi.remapToJs(b);
              return d(e.x * f.x + e.y * f.y, 0, 0, 0);
            });
          case 'magnitude':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
              b.__init__ = Sk.ffi.functionPy(function (a) {
              });
              b.__call__ = Sk.ffi.functionPy(function (a) {
                return Sk.ffi.numberToFloatPy(Math.sqrt(e.w * e.w + e.x * e.x + e.y * e.y - e.xy * e.xy));
              });
            }, 'magnitude', []));
          default:
            throw Sk.ffi.err.attribute(c).isNotGetableOnType('Euclidean2');
          }
        });
        k.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          a = Sk.ffi.remapToJs(a);
          switch (b) {
          case 'w':
          case 'x':
          case 'y':
          case 'xy':
            Sk.ffi.checkArgType(b, [
              Sk.ffi.PyType.FLOAT,
              Sk.ffi.PyType.INT,
              Sk.ffi.PyType.LONG
            ], Sk.ffi.isNum(c), c);
            a[b] = Sk.ffi.remapToJs(c);
            break;
          default:
            throw Sk.ffi.err.attribute(b).isNotSetableOnType('Euclidean2');
          }
        });
      }, 'Euclidean2', []);
    };
  }.call(this));
  Sk.e3ga = Sk.e3ga || {};
  Sk.e3ga.EUCLIDEAN_3 = 'Euclidean3';
  Sk.e3ga.SCALAR_E3 = 'ScalarE3';
  Sk.e3ga.VECTOR_E3 = 'VectorE3';
  Sk.e3ga.BIVECTOR_E3 = 'BivectorE3';
  Sk.e3ga.PSEUDOSCALAR_E3 = 'PseudoscalarE3';
  (function () {
    Sk.builtin.defineEuclidean3 = function (a, b, c) {
      function d(a) {
        return 'number' === typeof a;
      }
      function e(a) {
        return Sk.ffi.isInstance(a, Sk.e3ga.EUCLIDEAN_3);
      }
      function f(b, c, d, e, f, g, h, k, m, l) {
        goog.asserts.assertBoolean(b, 'coordsJsToE3Py(...), pseudo must be a boolean.');
        b = Sk.ffi.numberToFloatPy(c);
        d = Sk.ffi.numberToFloatPy(d);
        e = Sk.ffi.numberToFloatPy(e);
        f = Sk.ffi.numberToFloatPy(f);
        g = Sk.ffi.numberToFloatPy(g);
        h = Sk.ffi.numberToFloatPy(h);
        k = Sk.ffi.numberToFloatPy(k);
        m = Sk.ffi.numberToFloatPy(m);
        l = Sk.ffi.booleanToPy(l);
        return Sk.ffi.callsim(a[Sk.e3ga.EUCLIDEAN_3], b, d, e, f, g, h, k, m, l);
      }
      function g(a, b) {
        var c, d, e, f, g = [];
        c = function (a, b) {
          var c;
          if (0 !== a) {
            0 <= a ? 0 < g.length && g.push('+') : g.push('-');
            c = Math.abs(a);
            if (1 === c)
              return g.push(b);
            g.push(Sk.builtin.numberToFloatStringJs(c, 10, !0));
            if (b !== m)
              return g.push('*'), g.push(b);
          }
        };
        d = e = 0;
        for (f = a.length - 1; 0 <= f ? e <= f : e >= f; d = 0 <= f ? ++e : --e)
          c(a[d], b[d]);
        return 0 < g.length ? g.join('') : Sk.builtin.numberToFloatStringJs(0, 10, !0);
      }
      function h(a, b, d, e, f, g, h, k, m, l, E, C, A, u, t, y, v, s) {
        var r = +m, B = +l, w = +E, K = -C, I = +A, L = -u, M = -t, Q = -y, V = c.bladeASM.mulE3(m, l, E, A, C, t, -u, y, r, B, w, I, K, M, -L, Q, 0), N = c.bladeASM.mulE3(m, l, E, A, C, t, -u, y, r, B, w, I, K, M, -L, Q, 1), O = c.bladeASM.mulE3(m, l, E, A, C, t, -u, y, r, B, w, I, K, M, -L, Q, 2), P = c.bladeASM.mulE3(m, l, E, A, C, t, -u, y, r, B, w, I, K, M, -L, Q, 3), R = +V, S = -N, T = -O, U = -P, W = c.bladeASM.mulE3(r, B, w, I, K, M, -L, Q, R, S, T, U, -0, -0, 0, 0, 0), X = c.bladeASM.mulE3(r, B, w, I, K, M, -L, Q, R, S, T, U, -0, -0, 0, 0, 1), Y = c.bladeASM.mulE3(r, B, w, I, K, M, -L, Q, R, S, T, U, -0, -0, 0, 0, 2), V = c.bladeASM.mulE3(r, B, w, I, K, M, -L, Q, R, S, T, U, -0, -0, 0, 0, 4), N = c.bladeASM.mulE3(r, B, w, I, K, M, -L, Q, R, S, T, U, -0, -0, 0, 0, 3), O = -c.bladeASM.mulE3(r, B, w, I, K, M, -L, Q, R, S, T, U, -0, -0, 0, 0, 6), P = c.bladeASM.mulE3(r, B, w, I, K, M, -L, Q, R, S, T, U, -0, -0, 0, 0, 5), r = c.bladeASM.mulE3(r, B, w, I, K, M, -L, Q, R, S, T, U, -0, -0, 0, 0, 7);
        A = c.bladeASM.mulE3(m, l, E, A, C, t, -u, y, W, X, Y, N, V, P, -O, r, 0);
        m = W / A;
        l = X / A;
        E = Y / A;
        C = V / A;
        N /= A;
        O /= A;
        P /= A;
        w = r / A;
        A = c.bladeASM.mulE3(a, b, d, f, e, h, -g, k, m, l, E, N, C, P, -O, w, 0);
        u = c.bladeASM.mulE3(a, b, d, f, e, h, -g, k, m, l, E, N, C, P, -O, w, 1);
        t = c.bladeASM.mulE3(a, b, d, f, e, h, -g, k, m, l, E, N, C, P, -O, w, 2);
        y = c.bladeASM.mulE3(a, b, d, f, e, h, -g, k, m, l, E, N, C, P, -O, w, 4);
        V = c.bladeASM.mulE3(a, b, d, f, e, h, -g, k, m, l, E, N, C, P, -O, w, 3);
        B = -c.bladeASM.mulE3(a, b, d, f, e, h, -g, k, m, l, E, N, C, P, -O, w, 6);
        r = c.bladeASM.mulE3(a, b, d, f, e, h, -g, k, m, l, E, N, C, P, -O, w, 5);
        a = c.bladeASM.mulE3(a, b, d, f, e, h, -g, k, m, l, E, N, C, P, -O, w, 7);
        b = -B;
        if ('undefined' !== typeof v)
          v.w = A, v.x = u, v.y = t, v.z = V, v.xy = y, v.yz = r, v.zx = b, v.xyz = a;
        else
          return s(!1, A, u, t, V, y, r, b, a);
      }
      function l(a, b) {
        switch (b) {
        case 0:
          return a.w;
        case 1:
          return a.x;
        case 2:
          return a.y;
        case 3:
          return a.z;
        case 4:
          return a.xy;
        case 5:
          return a.yz;
        case 6:
          return a.zx;
        case 7:
          return a.xyz;
        default:
          throw Sk.ffi.assertionError('' + b + ' is not a valid multivector coordinate index');
        }
      }
      function k(a, b, c, d, e) {
        var f, g, h, k, m, l, C, A, u, t, y, v, s, r, B, w, K, I, L, M;
        d = b.quaternion.w;
        f = b.vector.x;
        g = b.vector.y;
        h = b.vector.z;
        k = -b.quaternion.z;
        m = -b.quaternion.x;
        l = -b.quaternion.y;
        b = b.xyz;
        C = c.quaternion.w;
        A = c.vector.x;
        u = c.vector.y;
        t = c.vector.z;
        y = -c.quaternion.z;
        v = -c.quaternion.x;
        s = -c.quaternion.y;
        r = c.xyz;
        c = a(d, f, g, h, k, m, l, b, C, A, u, t, y, v, s, r, 0);
        B = a(d, f, g, h, k, m, l, b, C, A, u, t, y, v, s, r, 1);
        w = a(d, f, g, h, k, m, l, b, C, A, u, t, y, v, s, r, 2);
        K = a(d, f, g, h, k, m, l, b, C, A, u, t, y, v, s, r, 3);
        I = a(d, f, g, h, k, m, l, b, C, A, u, t, y, v, s, r, 4);
        L = a(d, f, g, h, k, m, l, b, C, A, u, t, y, v, s, r, 5);
        M = a(d, f, g, h, k, m, l, b, C, A, u, t, y, v, s, r, 6);
        a = a(d, f, g, h, k, m, l, b, C, A, u, t, y, v, s, r, 7);
        return e(!1, c, B, w, K, I, L, M, a);
      }
      Sk.ffi.checkFunctionArgs('defineEuclidean3', arguments, 3, 3);
      Sk.builtin.defineVector3(a, b);
      Sk.builtin.defineQuaternion(a, b);
      var m = Sk.builtin.numberToFloatStringJs(1, 10, !0);
      b.Euclidean3 = function (a, b, c, d, e) {
        goog.asserts.assertBoolean(a, 'pseudo must be a boolean');
        if ('object' !== typeof b)
          throw Error('43a75b65-8614-4836-9829-377eaeee7cfe');
        if ('object' !== typeof c)
          throw Error('89fb1d18-dc26-4149-913d-58f192c161d7');
        goog.asserts.assertNumber(d, 'xyz must be a number');
        this.vector = b;
        this.quaternion = c;
        this._xyz = d;
        this._pseudo = a;
        this._mutable = 'boolean' === typeof e ? e : !0;
      };
      b.Euclidean3.prototype = {
        constructor: b.Euclidean3,
        get w() {
          return this.quaternion.w;
        },
        set w(a) {
          this.checkMutable();
          this.quaternion.w = a;
        },
        get x() {
          return this.vector.x;
        },
        set x(a) {
          this.checkMutable();
          this.vector.x = a;
        },
        get y() {
          return this.vector.y;
        },
        set y(a) {
          this.checkMutable();
          this.vector.y = a;
        },
        get z() {
          return this.vector.z;
        },
        set z(a) {
          this.checkMutable();
          this.vector.z = a;
        },
        get xy() {
          return -this.quaternion.z;
        },
        set xy(a) {
          this.checkMutable();
          this.quaternion.z = -a;
        },
        get yz() {
          return -this.quaternion.x;
        },
        set yz(a) {
          this.checkMutable();
          this.quaternion.x = -a;
        },
        get zx() {
          return -this.quaternion.y;
        },
        set zx(a) {
          this.checkMutable();
          this.quaternion.y = -a;
        },
        get xyz() {
          return this._xyz;
        },
        set xyz(a) {
          this.checkMutable();
          this._xyz = a;
        },
        get pseudo() {
          return this._pseudo;
        },
        set pseudo(a) {
          this.checkMutable();
          this._pseudo = a;
        },
        get mutable() {
          return this._mutable;
        },
        set mutable(a) {
          this._mutable = a;
        },
        checkMutable: function () {
          if (!this._mutable)
            throw Sk.ffi.assertionError('Quantity is not mutable');
        }
      };
      a[Sk.e3ga.SCALAR_E3] = Sk.ffi.functionPy(function (a, b) {
        Sk.ffi.checkFunctionArgs(Sk.e3ga.SCALAR_E3, arguments, 1, 2);
        Sk.ffi.checkArgType('w', Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(a), a);
        Sk.ffi.isDefined(b) && Sk.ffi.checkArgType('mutable', Sk.ffi.PyType.BOOL, Sk.ffi.isBool(b), b);
        return f(!1, Sk.ffi.numberToJs(a), 0, 0, 0, 0, 0, 0, 0, Sk.ffi.remapToJs(b));
      });
      a[Sk.e3ga.VECTOR_E3] = Sk.ffi.functionPy(function (a, b, c, d) {
        Sk.ffi.checkFunctionArgs(Sk.e3ga.VECTOR_E3, arguments, 3, 4);
        Sk.ffi.checkArgType('x', Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(a), a);
        Sk.ffi.checkArgType('y', Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(b), b);
        Sk.ffi.checkArgType('z', Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(c), c);
        Sk.ffi.isDefined(d) && Sk.ffi.checkArgType('mutable', Sk.ffi.PyType.BOOL, Sk.ffi.isBool(d), d);
        var e = Sk.ffi.numberToJs(a), g = Sk.ffi.numberToJs(b), h = Sk.ffi.numberToJs(c);
        return f(!1, 0, e, g, h, 0, 0, 0, 0, Sk.ffi.remapToJs(d));
      });
      a[Sk.e3ga.BIVECTOR_E3] = Sk.ffi.functionPy(function (a, b, c, d) {
        Sk.ffi.checkFunctionArgs(Sk.e3ga.BIVECTOR_E3, arguments, 3, 4);
        Sk.ffi.checkArgType('xy', Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(a), a);
        Sk.ffi.checkArgType('yz', Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(b), b);
        Sk.ffi.checkArgType('zx', Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(c), c);
        Sk.ffi.isDefined(d) && Sk.ffi.checkArgType('mutable', Sk.ffi.PyType.BOOL, Sk.ffi.isBool(d), d);
        a = Sk.ffi.numberToJs(a);
        b = Sk.ffi.numberToJs(b);
        c = Sk.ffi.numberToJs(c);
        return f(!1, 0, 0, 0, 0, a, b, c, 0, Sk.ffi.remapToJs(d));
      });
      a[Sk.e3ga.PSEUDOSCALAR_E3] = Sk.ffi.functionPy(function (a, b) {
        Sk.ffi.checkFunctionArgs(Sk.e3ga.PSEUDOSCALAR_E3, arguments, 1, 2);
        Sk.ffi.checkArgType('xyz', Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(a), a);
        Sk.ffi.isDefined(b) && Sk.ffi.checkArgType('mutable', Sk.ffi.PyType.BOOL, Sk.ffi.isBool(b), b);
        a = Sk.ffi.numberToJs(a);
        return f(!1, 0, 0, 0, 0, 0, 0, 0, a, Sk.ffi.remapToJs(b));
      });
      a[Sk.e3ga.EUCLIDEAN_3] = Sk.ffi.buildClass(a, function (p, n) {
        n.__init__ = Sk.ffi.functionPy(function (a, c, d, e, f, g, h, k, m, l) {
          Sk.ffi.checkMethodArgs(Sk.e3ga.EUCLIDEAN_3, arguments, 1, 9);
          switch (Sk.ffi.getType(c)) {
          case Sk.ffi.PyType.FLOAT:
          case Sk.ffi.PyType.INT:
            Sk.ffi.checkMethodArgs(Sk.e3ga.EUCLIDEAN_3, arguments, 8, 9);
            Sk.ffi.checkArgType('w', Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(c), c);
            Sk.ffi.checkArgType('x', Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(d), d);
            Sk.ffi.checkArgType('y', Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(e), e);
            Sk.ffi.checkArgType('z', Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(f), f);
            Sk.ffi.checkArgType('xy', Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(g), g);
            Sk.ffi.checkArgType('yz', Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(h), h);
            Sk.ffi.checkArgType('zx', Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(k), k);
            Sk.ffi.checkArgType('xyz', Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(m), m);
            Sk.ffi.isDefined(l) && Sk.ffi.checkArgType('mutable', Sk.ffi.PyType.BOOL, Sk.ffi.isBool(l), l);
            c = Sk.ffi.remapToJs(c);
            d = Sk.ffi.remapToJs(d);
            e = Sk.ffi.remapToJs(e);
            f = Sk.ffi.remapToJs(f);
            g = Sk.ffi.remapToJs(g);
            h = Sk.ffi.remapToJs(h);
            k = Sk.ffi.remapToJs(k);
            m = Sk.ffi.remapToJs(m);
            var p = Sk.ffi.isDefined(l) ? Sk.ffi.remapToJs(l) : !0, n = new b.Vector3(d, e, f), t = new b.Quaternion(-h, -k, -g, c);
            Sk.ffi.referenceToPy(new b.Euclidean3(!1, n, t, m, p), Sk.e3ga.EUCLIDEAN_3, void 0, a);
            break;
          case Sk.ffi.PyType.INSTANCE:
            Sk.ffi.checkMethodArgs(Sk.e3ga.EUCLIDEAN_3, arguments, 1, 1);
            Sk.ffi.referenceToPy(Sk.ffi.remapToJs(c), Sk.e3ga.EUCLIDEAN_3, void 0, a);
            break;
          default:
            throw new Sk.builtin.AssertionError('09eaed05-6d9d-4ded-a499-e4c480a9ed68, getType(w) => ' + Sk.ffi.getType(c));
          }
        });
        n.__add__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a), d = c.vector, e = c.quaternion, g = Sk.ffi.remapToJs(b);
          if (Sk.ffi.isNum(b))
            return f(!1, e.w + g, d.x, d.y, d.z, -e.z, -e.x, -e.y, c.xyz);
          if (Sk.ffi.isInstance(b, Sk.e3ga.EUCLIDEAN_3))
            return f(!1, e.w + g.quaternion.w, d.x + g.vector.x, d.y + g.vector.y, d.z + g.vector.z, -(e.z + g.quaternion.z), -(e.x + g.quaternion.x), -(e.y + g.quaternion.y), c.xyz + g.xyz);
        });
        n.__radd__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(b), d = Sk.ffi.remapToJs(a), e = d.vector, g = d.quaternion;
          if (Sk.ffi.isNum(b))
            return f(!1, c + g.w, e.x, e.y, e.z, -g.z, -g.x, -g.y, d.xyz);
        });
        n.__iadd__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a), d = c.vector, f = c.quaternion, g = Sk.ffi.remapToJs(b);
          if (Sk.ffi.isNum(b))
            f.w += g;
          else if (e(b)) {
            var h = g.vector, k = g.quaternion;
            f.w += k.w;
            d.x += h.x;
            d.y += h.y;
            d.z += h.z;
            f.z += k.z;
            f.x += k.x;
            f.y += k.y;
            c.xyz += g.xyz;
          } else
            return;
          return a;
        });
        n.__sub__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a), d = c.vector, e = c.quaternion, g = Sk.ffi.remapToJs(b);
          if (Sk.ffi.isNum(b))
            return f(!1, e.w - g, d.x, d.y, d.z, -e.z, -e.x, -e.y, c.xyz);
          if (Sk.ffi.isInstance(b, Sk.e3ga.EUCLIDEAN_3)) {
            var h = g.vector, k = g.quaternion;
            return f(!1, e.w - k.w, d.x - h.x, d.y - h.y, d.z - h.z, -(e.z - k.z), -(e.x - k.x), -(e.y - k.y), c.xyz - g.xyz);
          }
          throw Sk.ffi.err.operand('other').toOperation('subtract').mustHaveType([
            Sk.ffi.PyType.FLOAT,
            Sk.e3ga.EUCLIDEAN_3
          ]);
        });
        n.__rsub__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(b), d = Sk.ffi.remapToJs(a), e = d.vector, g = d.quaternion;
          if (Sk.ffi.isNum(b))
            return f(!1, c - g.w, -e.x, -e.y, -e.z, g.z, g.x, g.y, -d.xyz);
          throw Sk.ffi.err.operand('other').toOperation('subtract').mustHaveType([
            Sk.ffi.PyType.FLOAT,
            Sk.e3ga.EUCLIDEAN_3
          ]);
        });
        n.__isub__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a), d = c.vector, f = c.quaternion, g = Sk.ffi.remapToJs(b);
          if (Sk.ffi.isNum(b))
            f.w -= g;
          else if (e(b)) {
            var h = g.vector, k = g.quaternion;
            f.w -= k.w;
            d.x -= h.x;
            d.y -= h.y;
            d.z -= h.z;
            f.z -= k.z;
            f.x -= k.x;
            f.y -= k.y;
            c.xyz -= g.xyz;
          } else
            throw Sk.ffi.err.operand('other').toOperation('subtract').mustHaveType([
              Sk.ffi.PyType.FLOAT,
              Sk.e3ga.EUCLIDEAN_3
            ]);
          return a;
        });
        n.__mul__ = Sk.ffi.functionPy(function (a, b) {
          switch (Sk.ffi.getType(b)) {
          case Sk.ffi.PyType.INSTANCE:
            switch (Sk.ffi.typeName(b)) {
            case Sk.e3ga.EUCLIDEAN_3:
              var d = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(b);
              return k(c.bladeASM.mulE3, d, e, l, f);
            default:
              return;
            }
          case Sk.ffi.PyType.INT:
          case Sk.ffi.PyType.FLOAT:
            var d = Sk.ffi.remapToJs(a), e = d.vector, g = d.quaternion, h = Sk.ffi.remapToJs(b);
            return f(!1, g.w * h, e.x * h, e.y * h, e.z * h, -g.z * h, -g.x * h, -g.y * h, d.xyz * h);
          }
        });
        n.__rmul__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a), d = c.vector, e = c.quaternion;
          if (Sk.ffi.isNum(b)) {
            var g = Sk.ffi.remapToJs(b);
            return f(!1, g * e.w, g * d.x, g * d.y, g * d.z, -g * e.z, -g * e.x, -g * e.y, g * c.xyz);
          }
        });
        n.__imul__ = Sk.ffi.functionPy(function (a, b) {
          var e = Sk.ffi.remapToJs(a), f = Sk.ffi.remapToJs(b), g = e.w, h = e.x, k = e.y, m = e.z, l = e.xy, p = e.yz, n = e.zx, u = e.xyz, t, y, v, s, r, B, w;
          d(f) ? (t = f, f = w = B = r = s = v = y = 0) : (t = f.w, y = f.x, v = f.y, s = f.z, r = f.xy, B = f.yz, w = f.zx, f = f.xyz);
          e.w = c.bladeASM.mulE3(g, h, k, m, l, p, n, u, t, y, v, s, r, B, w, f, 0);
          e.x = c.bladeASM.mulE3(g, h, k, m, l, p, n, u, t, y, v, s, r, B, w, f, 1);
          e.y = c.bladeASM.mulE3(g, h, k, m, l, p, n, u, t, y, v, s, r, B, w, f, 2);
          e.z = c.bladeASM.mulE3(g, h, k, m, l, p, n, u, t, y, v, s, r, B, w, f, 3);
          e.xy = c.bladeASM.mulE3(g, h, k, m, l, p, n, u, t, y, v, s, r, B, w, f, 4);
          e.yz = c.bladeASM.mulE3(g, h, k, m, l, p, n, u, t, y, v, s, r, B, w, f, 5);
          e.zx = c.bladeASM.mulE3(g, h, k, m, l, p, n, u, t, y, v, s, r, B, w, f, 6);
          e.xyz = c.bladeASM.mulE3(g, h, k, m, l, p, n, u, t, y, v, s, r, B, w, f, 7);
          return a;
        });
        n.__div__ = Sk.ffi.functionPy(function (a, b) {
          switch (Sk.ffi.getType(b)) {
          case Sk.ffi.PyType.INSTANCE:
            switch (Sk.ffi.typeName(b)) {
            case Sk.e3ga.EUCLIDEAN_3:
              var c = Sk.ffi.remapToJs(a), d = c.vector, e = c.quaternion, g = Sk.ffi.remapToJs(b), k = g.vector, m = g.quaternion;
              return h(e.w, d.x, d.y, -e.z, d.z, e.y, -e.x, c.xyz, m.w, k.x, k.y, -m.z, k.z, m.y, -m.x, g.xyz, void 0, f);
            default:
              return;
            }
          case Sk.ffi.PyType.INT:
          case Sk.ffi.PyType.FLOAT:
            return c = Sk.ffi.remapToJs(a), d = c.vector, e = c.quaternion, g = Sk.ffi.remapToJs(b), h(e.w, d.x, d.y, -e.z, d.z, e.y, -e.x, c.xyz, g, 0, 0, 0, 0, 0, 0, 0, void 0, f);
          }
        });
        n.__rdiv__ = Sk.ffi.functionPy(function (a, b) {
          b = Sk.ffi.remapToJs(b);
          a = Sk.ffi.remapToJs(a);
          if (d(b))
            return h(b, 0, 0, 0, 0, 0, 0, 0, a.w, a.x, a.y, a.xy, a.z, -a.zx, a.yz, a.xyz, void 0, f);
          throw new Sk.builtin.AssertionError('' + JSON.stringify(b, null, 2) + ' / ' + JSON.stringify(a, null, 2));
        });
        n.__idiv__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(b);
          d(e) ? h(c.w, c.x, c.y, c.xy, c.z, -c.zx, c.yz, c.xyz, e, 0, 0, 0, 0, 0, 0, 0, c, f) : h(c.w, c.x, c.y, c.xy, c.z, -c.zx, c.yz, c.xyz, e.w, e.x, e.y, e.xy, e.z, -e.zx, e.yz, e.xyz, c, f);
          return a;
        });
        n.__mod__ = Sk.ffi.functionPy(function (a, b) {
          switch (Sk.ffi.getType(b)) {
          case Sk.ffi.PyType.INSTANCE:
            switch (Sk.ffi.typeName(b)) {
            case Sk.e3ga.EUCLIDEAN_3:
              var c = Sk.ffi.remapToJs(a), d = Sk.ffi.remapToJs(b);
              return f(!1, c.x * d.x + c.y * d.y + c.z * d.z, 0, 0, 0, 0, 0, 0, 0);
            default:
              return;
            }
          case Sk.ffi.PyType.INT:
          case Sk.ffi.PyType.FLOAT:
            var c = Sk.ffi.remapToJs(a), d = c.vector, e = c.quaternion, g = Sk.ffi.remapToJs(b);
            return f(!1, e.w * g, d.x * g, d.y * g, d.z * g, -e.z * g, -e.x * g, -e.y * g, c.xyz * g);
          }
        });
        n.__xor__ = Sk.ffi.functionPy(function (a, b) {
          switch (Sk.ffi.getType(b)) {
          case Sk.ffi.PyType.INSTANCE:
            switch (Sk.ffi.typeName(b)) {
            case Sk.e3ga.EUCLIDEAN_3:
              var d = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(b);
              return k(c.bladeASM.extE3, d, e, l, f);
            default:
              return;
            }
          case Sk.ffi.PyType.INT:
          case Sk.ffi.PyType.FLOAT:
            return d = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(b), f(!1, d.w * e, d.x * e, d.y * e, d.z * e, d.xy * e, d.yz * e, d.zx * e, d.xyz * e);
          }
        });
        n.__rxor__ = Sk.ffi.functionPy(function (a, b) {
          if (Sk.ffi.isNum(b)) {
            var c = Sk.ffi.remapToJs(b), d = Sk.ffi.remapToJs(a);
            return f(!1, c * d.w, c * d.x, c * d.y, c * d.z, c * d.xy, c * d.yz, c * d.zx, c * d.xyz);
          }
        });
        n.__ixor__ = Sk.ffi.functionPy(function (a, b) {
          var e = Sk.ffi.remapToJs(a), f = Sk.ffi.remapToJs(b), g = e.w, h = e.x, k = e.y, m = e.z, l = e.xy, p = e.yz, n = e.zx, u = e.xyz, t, y, v, s, r, B, w;
          d(f) ? (t = f, f = w = B = r = s = v = y = 0) : (t = f.w, y = f.x, v = f.y, s = f.z, r = f.xy, B = f.yz, w = f.zx, f = f.xyz);
          e.w = c.bladeASM.extE3(g, h, k, m, l, p, n, u, t, y, v, s, r, B, w, f, 0);
          e.x = c.bladeASM.extE3(g, h, k, m, l, p, n, u, t, y, v, s, r, B, w, f, 1);
          e.y = c.bladeASM.extE3(g, h, k, m, l, p, n, u, t, y, v, s, r, B, w, f, 2);
          e.z = c.bladeASM.extE3(g, h, k, m, l, p, n, u, t, y, v, s, r, B, w, f, 3);
          e.xy = c.bladeASM.extE3(g, h, k, m, l, p, n, u, t, y, v, s, r, B, w, f, 4);
          e.yz = c.bladeASM.extE3(g, h, k, m, l, p, n, u, t, y, v, s, r, B, w, f, 5);
          e.zx = c.bladeASM.extE3(g, h, k, m, l, p, n, u, t, y, v, s, r, B, w, f, 6);
          e.xyz = c.bladeASM.extE3(g, h, k, m, l, p, n, u, t, y, v, s, r, B, w, f, 7);
          return a;
        });
        n.__lshift__ = Sk.ffi.functionPy(function (a, b) {
          switch (Sk.ffi.getType(b)) {
          case Sk.ffi.PyType.INSTANCE:
            switch (Sk.ffi.typeName(b)) {
            case Sk.e3ga.EUCLIDEAN_3:
              var d = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(b);
              return k(c.bladeASM.lcoE3, d, e, l, f);
            default:
              return;
            }
          case Sk.ffi.PyType.INT:
          case Sk.ffi.PyType.FLOAT:
            return d = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(b), f(!1, d.w * e, 0, 0, 0, 0, 0, 0, 0);
          }
        });
        n.__rlshift__ = Sk.ffi.functionPy(function (a, b) {
          b = Sk.ffi.remapToJs(b);
          a = Sk.ffi.remapToJs(a);
          if (d(b))
            return f(!1, b * a.w, b * a.x, b * a.y, b * a.z, b * a.xy, b * a.yz, b * a.zx, b * a.xyz);
        });
        n.__ilshift__ = Sk.ffi.functionPy(function (a, b) {
          var e = Sk.ffi.remapToJs(a), f = Sk.ffi.remapToJs(b), g = e.w, h = e.x, k = e.y, m = e.z, l = e.xy, p = e.yz, n = e.zx, u = e.xyz, t, y, v, s, r, B, w;
          d(f) ? (t = f, f = w = B = r = s = v = y = 0) : (t = f.w, y = f.x, v = f.y, s = f.z, r = f.xy, B = f.yz, w = f.zx, f = f.xyz);
          e.w = c.bladeASM.lcoE3(g, h, k, m, l, p, n, u, t, y, v, s, r, B, w, f, 0);
          e.x = c.bladeASM.lcoE3(g, h, k, m, l, p, n, u, t, y, v, s, r, B, w, f, 1);
          e.y = c.bladeASM.lcoE3(g, h, k, m, l, p, n, u, t, y, v, s, r, B, w, f, 2);
          e.z = c.bladeASM.lcoE3(g, h, k, m, l, p, n, u, t, y, v, s, r, B, w, f, 3);
          e.xy = c.bladeASM.lcoE3(g, h, k, m, l, p, n, u, t, y, v, s, r, B, w, f, 4);
          e.yz = c.bladeASM.lcoE3(g, h, k, m, l, p, n, u, t, y, v, s, r, B, w, f, 5);
          e.zx = c.bladeASM.lcoE3(g, h, k, m, l, p, n, u, t, y, v, s, r, B, w, f, 6);
          e.xyz = c.bladeASM.lcoE3(g, h, k, m, l, p, n, u, t, y, v, s, r, B, w, f, 7);
          return a;
        });
        n.__rshift__ = Sk.ffi.functionPy(function (a, b) {
          switch (Sk.ffi.getType(b)) {
          case Sk.ffi.PyType.INSTANCE:
            switch (Sk.ffi.typeName(b)) {
            case Sk.e3ga.EUCLIDEAN_3:
              var d = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(b);
              return k(c.bladeASM.rcoE3, d, e, l, f);
            default:
              return;
            }
          case Sk.ffi.PyType.INT:
          case Sk.ffi.PyType.FLOAT:
            return d = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(b), f(!1, d.w * e, d.x * e, d.y * e, d.z * e, d.xy * e, d.yz * e, d.zx * e, d.xyz * e);
          }
        });
        n.__rrshift__ = Sk.ffi.functionPy(function (a, b) {
          b = Sk.ffi.remapToJs(b);
          a = Sk.ffi.remapToJs(a);
          if (d(b))
            return f(!1, b * a.w, 0, 0, 0, 0, 0, 0, 0);
        });
        n.__irshift__ = Sk.ffi.functionPy(function (a, b) {
          var e = Sk.ffi.remapToJs(a), f = Sk.ffi.remapToJs(b), g = e.w, h = e.x, k = e.y, m = e.z, l = e.xy, p = e.yz, n = e.zx, u = e.xyz, t, y, v, s, r, B, w;
          d(f) ? (t = f, f = w = B = r = s = v = y = 0) : (t = f.w, y = f.x, v = f.y, s = f.z, r = f.xy, B = f.yz, w = f.zx, f = f.xyz);
          e.w = c.bladeASM.rcoE3(g, h, k, m, l, p, n, u, t, y, v, s, r, B, w, f, 0);
          e.x = c.bladeASM.rcoE3(g, h, k, m, l, p, n, u, t, y, v, s, r, B, w, f, 1);
          e.y = c.bladeASM.rcoE3(g, h, k, m, l, p, n, u, t, y, v, s, r, B, w, f, 2);
          e.z = c.bladeASM.rcoE3(g, h, k, m, l, p, n, u, t, y, v, s, r, B, w, f, 3);
          e.xy = c.bladeASM.rcoE3(g, h, k, m, l, p, n, u, t, y, v, s, r, B, w, f, 4);
          e.yz = c.bladeASM.rcoE3(g, h, k, m, l, p, n, u, t, y, v, s, r, B, w, f, 5);
          e.zx = c.bladeASM.rcoE3(g, h, k, m, l, p, n, u, t, y, v, s, r, B, w, f, 6);
          e.xyz = c.bladeASM.rcoE3(g, h, k, m, l, p, n, u, t, y, v, s, r, B, w, f, 7);
          return a;
        });
        n.__pow__ = Sk.ffi.functionPy(function (a, b) {
          switch (Sk.ffi.getType(b)) {
          case Sk.ffi.PyType.INSTANCE:
            switch (Sk.ffi.typeName(b)) {
            case Sk.e3ga.EUCLIDEAN_3:
              var c = Sk.ffi.remapToJs(a), d = Sk.ffi.remapToJs(b);
              return f(!1, Math.pow(c.w, d.w), 0, 0, 0, 0, 0, 0, 0);
            default:
              return;
            }
          case Sk.ffi.PyType.INT:
          case Sk.ffi.PyType.FLOAT:
            return c = Sk.ffi.remapToJs(a), d = Sk.ffi.remapToJs(b), f(!1, Math.pow(c.w, d), 0, 0, 0, 0, 0, 0, 0);
          }
        });
        n.__len__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.numberToIntPy(8);
        });
        n.__pos__ = Sk.ffi.functionPy(function (a) {
          return a;
        });
        n.__neg__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          var b = a.vector, c = a.quaternion;
          return f(!1, -c.w, -b.x, -b.y, -b.z, c.z, c.x, c.y, -a.xyz);
        });
        n.__invert__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          var b = a.vector, c = a.quaternion;
          return f(!1, c.w, b.x, b.y, b.z, c.z, c.x, c.y, -a.xyz);
        });
        n.__eq__ = Sk.ffi.functionPy(function (a, b) {
          if (Sk.ffi.isInstance(b, Sk.e3ga.EUCLIDEAN_3)) {
            var c = Sk.ffi.remapToJs(a), d = c.vector, e = c.quaternion, f = Sk.ffi.remapToJs(b), g = f.quaternion;
            return d.equals(f.vector) && e.equals(g) && c.xyz === f.xyz;
          }
          return Sk.ffi.bool.False;
        });
        n.__ne__ = Sk.ffi.functionPy(function (a, b) {
          if (Sk.ffi.isInstance(b, Sk.e3ga.EUCLIDEAN_3)) {
            var c = Sk.ffi.remapToJs(a), d = c.vector, e = c.quaternion, f = Sk.ffi.remapToJs(b), g = f.quaternion;
            return !d.equals(f.vector) || !e.equals(g) || c.xyz !== f.xyz;
          }
          return Sk.ffi.bool.True;
        });
        n.__getitem__ = Sk.ffi.functionPy(function (a, b) {
          Sk.ffi.checkMethodArgs('[]', arguments, 1, 1);
          Sk.ffi.checkArgType('index', Sk.ffi.PyType.INT, Sk.ffi.isInt(b), b);
          var c = Sk.ffi.remapToJs(b), d = Sk.ffi.remapToJs(a), e = d.vector, g = d.quaternion;
          switch (c) {
          case 0:
            return f(!1, g.w, 0, 0, 0, 0, 0, 0, 0);
          case 1:
            return f(!1, 0, e.x, e.y, e.z, 0, 0, 0, 0);
          case 2:
            return f(!1, 0, 0, 0, 0, -g.z, -g.x, -g.y, 0);
          case 3:
            return f(!1, 0, 0, 0, 0, 0, 0, 0, d.xyz);
          }
        });
        n.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b), e = d.vector, g = d.quaternion;
          switch (c) {
          case 'w':
            return Sk.ffi.numberToFloatPy(d.w);
          case 'x':
            return Sk.ffi.numberToFloatPy(d.x);
          case 'y':
            return Sk.ffi.numberToFloatPy(d.y);
          case 'z':
            return Sk.ffi.numberToFloatPy(d.z);
          case 'xy':
            return Sk.ffi.numberToFloatPy(d.xy);
          case 'yz':
            return Sk.ffi.numberToFloatPy(d.yz);
          case 'zx':
            return Sk.ffi.numberToFloatPy(d.zx);
          case 'xyz':
            return Sk.ffi.numberToFloatPy(d.xyz);
          case 'mutable':
            return Sk.ffi.booleanToPy(d.mutable);
          case 'vector':
            return Sk.ffi.callsim(a.Vector3, Sk.ffi.referenceToPy(d.vector, 'Vector3'));
          case 'quaternion':
            return Sk.ffi.callsim(a.Quaternion, Sk.ffi.referenceToPy(d.quaternion, 'Quaternion'));
          case 'add':
            return Sk.ffi.callableToPy(a, c, function (a, f) {
              Sk.ffi.checkMethodArgs(c, arguments, 1, 1);
              Sk.ffi.checkArgType('other', Sk.e3ga.EUCLIDEAN_3, Sk.ffi.isInstance(f, Sk.e3ga.EUCLIDEAN_3), f);
              var h = Sk.ffi.remapToJs(f);
              g.w += h.quaternion.w;
              e.x += h.vector.x;
              e.y += h.vector.y;
              e.z += h.vector.z;
              g.x += h.quaternion.x;
              g.y += h.quaternion.y;
              g.z += h.quaternion.z;
              d.xyz += h.xyz;
              return b;
            });
          case 'applyMatrix3':
            return Sk.ffi.callableToPy(a, c, function (a, d) {
              Sk.ffi.checkMethodArgs(c, arguments, 1, 1);
              Sk.ffi.checkArgType('m', Sk.three.MATRIX_3, Sk.ffi.isInstance(d, Sk.three.MATRIX_3), d);
              e[c](Sk.ffi.remapToJs(d));
              return b;
            });
          case 'applyMatrix4':
            return Sk.ffi.callableToPy(a, c, function (a, d) {
              Sk.ffi.checkMethodArgs(c, arguments, 1, 1);
              Sk.ffi.checkArgType('m', Sk.three.MATRIX_4, Sk.ffi.isInstance(d, Sk.three.MATRIX_4), d);
              e[c](Sk.ffi.remapToJs(d));
              return b;
            });
          case 'sub':
            return Sk.ffi.callableToPy(a, c, function (a, f) {
              Sk.ffi.checkMethodArgs(c, arguments, 1, 1);
              Sk.ffi.checkArgType('other', Sk.e3ga.EUCLIDEAN_3, Sk.ffi.isInstance(f, Sk.e3ga.EUCLIDEAN_3), f);
              var h = Sk.ffi.remapToJs(f);
              g.w -= h.quaternion.w;
              e.x -= h.vector.x;
              e.y -= h.vector.y;
              e.z -= h.vector.z;
              g.x -= h.quaternion.x;
              g.y -= h.quaternion.y;
              g.z -= h.quaternion.z;
              d.xyz -= h.xyz;
              return b;
            });
          case 'constantify':
            return Sk.ffi.callableToPy(a, 'constantify', function (a) {
              Sk.ffi.checkMethodArgs('constantify', arguments, 0, 0);
              d.mutable = !1;
              return b;
            });
          case 'copy':
            return Sk.ffi.callableToPy(a, c, function (a, f) {
              Sk.ffi.checkMethodArgs(c, arguments, 1, 1);
              Sk.ffi.checkArgType('other', Sk.e3ga.EUCLIDEAN_3, Sk.ffi.isInstance(f, Sk.e3ga.EUCLIDEAN_3), f);
              var h = Sk.ffi.remapToJs(f);
              g.w = h.quaternion.w;
              e.x = h.vector.x;
              e.y = h.vector.y;
              e.z = h.vector.z;
              g.x = h.quaternion.x;
              g.y = h.quaternion.y;
              g.z = h.quaternion.z;
              d.xyz = h.xyz;
              return b;
            });
          case 'cross':
            return Sk.ffi.callableToPy(a, 'cross', function (a, b) {
              Sk.ffi.checkMethodArgs('cross', arguments, 1, 1);
              Sk.ffi.checkArgType('other', Sk.e3ga.EUCLIDEAN_3, Sk.ffi.isInstance(b, Sk.e3ga.EUCLIDEAN_3), b);
              var c = Sk.ffi.remapToJs(b), e = d.w, g = d.x, h = d.y, k = d.z, m = d.xy, l = d.yz, p = d.zx, q = c.w, n = c.x, x = c.y, J = c.z, K = c.xy, I = c.yz, L = c.zx;
              return f(!0, e * q + g * I + h * L + k * K + m * J + l * n + p * x, e * n + g * q + h * J - k * x, e * x + h * q + k * n - g * J, e * J + k * q + g * x - h * n, e * K + m * q, e * I + l * q, e * L + p * q, e * c.xyz + d.xyz * q);
            });
          case 'distanceTo':
            return Sk.ffi.callableToPy(a, c, function (a, b) {
              Sk.ffi.checkMethodArgs(c, arguments, 1, 1);
              Sk.ffi.checkArgType('other', Sk.e3ga.EUCLIDEAN_3, Sk.ffi.isInstance(b, Sk.e3ga.EUCLIDEAN_3), b);
              var d = Sk.ffi.remapToJs(b);
              return Sk.ffi.numberToFloatPy(e.distanceTo(d.vector));
            });
          case 'distanceToSquared':
            return Sk.ffi.callableToPy(a, c, function (a, b) {
              Sk.ffi.checkMethodArgs(c, arguments, 1, 1);
              Sk.ffi.checkArgType('other', Sk.e3ga.EUCLIDEAN_3, Sk.ffi.isInstance(b, Sk.e3ga.EUCLIDEAN_3), b);
              var d = Sk.ffi.remapToJs(b);
              return Sk.ffi.numberToFloatPy(e.distanceToSquared(d.vector));
            });
          case 'divideScalar':
            return Sk.ffi.callableToPy(a, c, function (a, f) {
              Sk.ffi.checkMethodArgs(c, arguments, 1, 1);
              Sk.ffi.checkArgType('s', Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(f), f);
              var h = Sk.ffi.remapToJs(f);
              g.w /= h;
              e.x /= h;
              e.y /= h;
              e.z /= h;
              g.x /= h;
              g.y /= h;
              g.z /= h;
              d.xyz /= h;
              return b;
            });
          case 'dot':
            return Sk.ffi.callableToPy(a, c, function (a, b) {
              Sk.ffi.checkMethodArgs('dot', arguments, 1, 1);
              Sk.ffi.checkArgType('other', Sk.e3ga.EUCLIDEAN_3, Sk.ffi.isInstance(b, Sk.e3ga.EUCLIDEAN_3), b);
              var c = Sk.ffi.remapToJs(b), e = d.w, g = d.x, h = d.y, k = d.z, m = d.xy, l = d.yz, p = d.zx, q = d.xyz, n = c.w, x = c.x, J = c.y, K = c.z, I = c.xy, L = c.yz, M = c.zx, c = c.xyz;
              return f(!1, e * n + g * x + h * J + k * K - m * I - l * L - p * M - q * c, k * M - h * I - K * p + J * m, g * I - k * L - x * m + K * l, h * L - g * M - J * l + x * p, k * c + K * q, g * c + x * q, h * c + J * q, q * n + c * e);
            });
          case 'multiplyScalar':
            return Sk.ffi.callableToPy(a, c, function (a, f) {
              Sk.ffi.checkMethodArgs(c, arguments, 1, 1);
              Sk.ffi.checkArgType('s', Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(f), f);
              var h = Sk.ffi.remapToJs(f);
              g.w *= h;
              e.x *= h;
              e.y *= h;
              e.z *= h;
              g.x *= h;
              g.y *= h;
              g.z *= h;
              d.xyz *= h;
              return b;
            });
          case 'setX':
            return Sk.ffi.callableToPy(a, 'setX', function (a, c) {
              Sk.ffi.checkMethodArgs('setX', arguments, 1, 1);
              Sk.ffi.checkArgType('x', Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(c), c);
              d.x = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'setY':
            return Sk.ffi.callableToPy(a, 'setY', function (a, c) {
              Sk.ffi.checkMethodArgs('setY', arguments, 1, 1);
              Sk.ffi.checkArgType('y', Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(c), c);
              d.y = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'setZ':
            return Sk.ffi.callableToPy(a, 'setZ', function (a, c) {
              Sk.ffi.checkMethodArgs('setZ', arguments, 1, 1);
              Sk.ffi.checkArgType('z', Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(c), c);
              d.z = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'getComponent':
            return Sk.ffi.callableToPy(a, 'getComponent', function (a, b) {
              Sk.ffi.checkMethodArgs('getComponent', arguments, 1, 1);
              Sk.ffi.checkArgType('index', Sk.ffi.PyType.INT, Sk.ffi.isInt(b), b);
              var c = Sk.ffi.remapToJs(b);
              return Sk.ffi.numberToFloatPy(e.getComponent(c));
            });
          case 'setComponent':
            return Sk.ffi.callableToPy(a, 'setComponent', function (a, c, d) {
              Sk.ffi.checkMethodArgs('setComponent', arguments, 1, 1);
              Sk.ffi.checkArgType('index', Sk.ffi.PyType.INT, Sk.ffi.isInt(c), c);
              Sk.ffi.checkArgType('value', Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(d), d);
              var f = Sk.ffi.remapToJs(c), g = Sk.ffi.remapToJs(d);
              e.setComponent(f, g);
              return b;
            });
          case 'set':
            return Sk.ffi.callableToPy(a, 'set', function (a, c, d, f) {
              Sk.ffi.checkMethodArgs('set', arguments, 3, 3);
              Sk.ffi.checkArgType('x', Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(c), c);
              Sk.ffi.checkArgType('y', Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(d), d);
              Sk.ffi.checkArgType('z', Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(f), f);
              var g = Sk.ffi.remapToJs(c), h = Sk.ffi.remapToJs(d), k = Sk.ffi.remapToJs(f);
              e.set(g, h, k);
              return b;
            });
          case 'clone':
            return Sk.ffi.callableToPy(a, 'clone', function (a) {
              Sk.ffi.checkMethodArgs('clone', arguments, 0, 0);
              return f(!1, g.w, e.x, e.y, e.z, -g.z, -g.x, -g.y, d.xyz);
            });
          case 'magnitude':
            return Sk.ffi.callableToPy(a, 'magnitude', function (a) {
              Sk.ffi.checkMethodArgs('magnitude', arguments, 0, 0);
              return Sk.ffi.numberToFloatPy(e.length());
            });
          case 'normalize':
            return Sk.ffi.callableToPy(a, 'normalize', function (a) {
              Sk.ffi.checkMethodArgs('normalize', arguments, 0, 0);
              e.normalize();
              return b;
            });
          default:
            throw Sk.ffi.err.attribute(c).isNotGetableOnType(Sk.e3ga.EUCLIDEAN_3);
          }
        });
        n.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          Sk.ffi.checkArgType('self', Sk.e3ga.EUCLIDEAN_3, e(a), a);
          a = Sk.ffi.remapToJs(a);
          switch (b) {
          case 'w':
          case 'x':
          case 'y':
          case 'z':
          case 'xy':
          case 'yz':
          case 'zx':
          case 'xyz':
            Sk.ffi.checkArgType(b, Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(c), c);
            try {
              a[b] = Sk.ffi.remapToJs(c);
            } catch (d) {
              throw Sk.ffi.assertionError(d.message);
            }
            break;
          default:
            throw Sk.ffi.err.attribute(b).isNotSetableOnType(Sk.e3ga.EUCLIDEAN_3);
          }
        });
        n.__cliffordConjugate__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.checkMethodArgs('cliffordConjugate', arguments, 0, 0);
          var b = Sk.ffi.remapToJs(a);
          return f(!1, b.w, -b.x, -b.y, -b.z, -b.xy, -b.yz, -b.zx, b.xyz);
        });
        n.__cos__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.checkMethodArgs('cos', arguments, 0, 0);
          var b = Sk.ffi.remapToJs(a);
          return f(!1, Sk.math.cos(b.w), 0, 0, 0, 0, 0, 0, 0);
        });
        n.__sin__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.checkMethodArgs('sin', arguments, 0, 0);
          var b = Sk.ffi.remapToJs(a);
          return f(!1, Sk.math.sin(b.w), 0, 0, 0, 0, 0, 0, 0);
        });
        n.__tan__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.checkMethodArgs('tan', arguments, 0, 0);
          return Sk.ffh.div(Sk.ffh.sin(a), Sk.ffh.cos(a));
        });
        n.__acos__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.checkMethodArgs('acos', arguments, 0, 0);
          var b = Sk.ffi.remapToJs(a);
          return f(!1, Math.acos(b.w), 0, 0, 0, 0, 0, 0, 0);
        });
        n.__asin__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.checkMethodArgs('asin', arguments, 0, 0);
          var b = Sk.ffi.remapToJs(a);
          return f(!1, Math.asin(b.w), 0, 0, 0, 0, 0, 0, 0);
        });
        n.__atan__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.checkMethodArgs('atan', arguments, 0, 0);
          var b = Sk.ffi.remapToJs(a);
          return f(!1, Math.atan(b.w), 0, 0, 0, 0, 0, 0, 0);
        });
        n.__exp__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.checkMethodArgs('exp', arguments, 0, 0);
          var b = Sk.ffi.remapToJs(a).quaternion, c = -b.z, d = -b.x, b = -b.y;
          if (0 === c && 0 === d) {
            var e = Sk.math.cos(b), g = Sk.math.sin(b);
            return f(!1, e, 0, 0, 0, 0, 0, g, 0);
          }
          if (0 === d && 0 === b)
            return e = Sk.math.cos(c), g = Sk.math.sin(c), f(!1, e, 0, 0, 0, g, 0, 0, 0);
          if (0 === b && 0 === c)
            return e = Sk.math.cos(d), g = Sk.math.sin(d), f(!1, e, 0, 0, 0, 0, g, 0, 0);
          var h = Math.sqrt(c * c + d * d + b * b), e = Sk.math.cos(h), g = Sk.math.sin(h), g = g / h;
          return f(!1, e, 0, 0, 0, g * c, g * d, g * b, 0);
        });
        n.__abs__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.gattr(Sk.ffh.sqrt(Sk.ffh.quadrance(a)), 'w');
        });
        n.__magnitude__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffh.sqrt(Sk.ffh.quadrance(a));
        });
        n.__quadrance__ = Sk.ffi.functionPy(function (a) {
          var b = Sk.ffi.remapToJs(a);
          a = b.w;
          var c = b.x, d = b.y, e = b.z, g = b.xy, h = b.yz, k = b.zx, b = b.xyz;
          return f(!1, a * a + c * c + d * d + e * e + g * g + h * h + k * k + b * b, 0, 0, 0, 0, 0, 0, 0);
        });
        n.__sqrt__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.checkMethodArgs('sqrt', arguments, 0, 0);
          var b = Sk.ffi.remapToJs(a);
          return f(!1, Math.sqrt(b.w), 0, 0, 0, 0, 0, 0, 0);
        });
        n.__repr__ = Sk.ffi.functionPy(function (a) {
          var b = Sk.ffi.remapToJs(a), c = b.vector, d = b.quaternion;
          a = d.w;
          var e = c.x, f = c.y, c = c.z, g = -d.z, h = -d.x, d = -d.y, b = b.xyz, k = 0 !== a, m = 0 !== e || 0 != f || 0 !== c, l = 0 !== g || 0 !== h || 0 !== d, p = 0 !== b;
          if (!k || m || l || p) {
            if (k || !m || l || p) {
              if (k || m || !l || p) {
                if (k || m || l || !p)
                  return a = [
                    a,
                    e,
                    f,
                    c,
                    g,
                    h,
                    d,
                    b
                  ], Sk.builtin.stringToPy(Sk.e3ga.EUCLIDEAN_3 + '(' + a.join(', ') + ')');
                a = [b];
                return Sk.builtin.stringToPy(Sk.e3ga.PSEUDOSCALAR_E3 + '(' + a.join(', ') + ')');
              }
              a = [
                g,
                h,
                d
              ];
              return Sk.builtin.stringToPy(Sk.e3ga.BIVECTOR_E3 + '(' + a.join(', ') + ')');
            }
            a = [
              e,
              f,
              c
            ];
            return Sk.builtin.stringToPy(Sk.e3ga.VECTOR_E3 + '(' + a.join(', ') + ')');
          }
          a = [a];
          return Sk.builtin.stringToPy(Sk.e3ga.SCALAR_E3 + '(' + a.join(', ') + ')');
        });
        n.__str__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.checkMethodArgs('__str__', arguments, 0, 0);
          Sk.ffi.checkFunctionArgs('str', arguments, 1, 1);
          Sk.ffi.checkArgType('self', Sk.e3ga.EUCLIDEAN_3, e(a), a);
          var b = Sk.ffi.remapToJs(a);
          return Sk.builtin.stringToPy(g([
            b.w,
            b.x,
            b.y,
            b.z,
            b.xy,
            b.yz,
            b.zx,
            b.xyz
          ], [
            m,
            'e1',
            'e2',
            'e3',
            'e12',
            'e23',
            'e31',
            'I'
          ]));
        });
      }, Sk.e3ga.EUCLIDEAN_3, []);
    };
  }.call(this));
  (function () {
    Sk.builtin.defineLorentzian = function (a, b) {
      function c(a) {
        return 'number' === typeof a;
      }
      function d(b, c, d, e) {
        return Sk.ffi.callsim(a.Lorentzian, Sk.ffi.numberToFloatPy(b), Sk.ffi.numberToFloatPy(c), Sk.ffi.numberToFloatPy(d), Sk.ffi.numberToFloatPy(e));
      }
      function e(a, b, c) {
        var d, e, f, g, h;
        f = [];
        d = function (a, b) {
          var d;
          if (0 !== a) {
            0 <= a ? 0 < f.length && f.push('+') : f.push('-');
            d = Math.abs(a);
            if (1 === d)
              return f.push(b);
            f.push(d.toString());
            if ('1' !== b)
              return f.push(c), f.push(b);
          }
        };
        e = g = 0;
        for (h = a.length - 1; 0 <= h ? g <= h : g >= h; e = 0 <= h ? ++g : --g)
          d(a[e], b[e]);
        return 0 < f.length ? f.join('') : '0';
      }
      function f(a, b, c, e, f, g, h, l, F) {
        var H = +f, z = +g, G = +h, E = -l, C = +(f * H + g * z + h * G - l * E), A = H * C + -0 * z + -0 * G - -0 * E, u = -0 * H + z * C - -0 * G + -0 * E, t = -0 * H + -0 * z + G * C - -0 * E, H = -0 * H + -0 * z - -0 * G + E * C;
        f = f * A + g * u + h * t - l * H;
        A /= f;
        u /= f;
        t /= f;
        l = H / f;
        f = a * A + b * u + c * t - e * l;
        g = a * u + b * A - c * l + e * t;
        h = a * t + b * l + c * A - e * u;
        a = a * l + b * t - c * u + e * A;
        if ('undefined' !== typeof F)
          F.w = f, F.x = g, F.y = h, F.xy = a;
        else
          return d(f, g, h, a);
      }
      Sk.ffi.checkFunctionArgs('defineLorentzian', arguments, 2, 2);
      Sk.builtin.defineUnits(a, b);
      var g = [
          Sk.ffi.PyType.FLOAT,
          Sk.ffi.PyType.INT,
          Sk.ffi.PyType.LONG
        ], h = [
          'Lorentzian',
          g
        ], l = function (a) {
          return Sk.ffi.isInstance(a, 'Lorentzian');
        };
      a.ScalarL4 = Sk.ffi.functionPy(function (b) {
        Sk.ffi.checkFunctionArgs('ScalarL4', arguments, 1, 1);
        var c = Sk.ffi.numberToFloatPy(0);
        return Sk.ffi.callsim(a.Lorentzian, b, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c);
      });
      a.VectorL4 = Sk.ffi.functionPy(function (b, c, d, e) {
        Sk.ffi.checkFunctionArgs('VectorL4', arguments, 4, 4);
        var f = Sk.ffi.numberToFloatPy(0);
        return Sk.ffi.callsim(a.Lorentzian, f, b, c, f, d, f, f, f, e, f, f, f, f, f, f, f);
      });
      a.PseudoscalarE2 = Sk.ffi.functionPy(function (a) {
        Sk.ffi.checkFunctionArgs('PseudoscalarE2', arguments, 1, 1);
        Sk.ffi.checkArgType('xy', g, Sk.ffi.isNum(a), a);
        return d(0, 0, 0, Sk.ffi.remapToJs(a));
      });
      a.Lorentzian = Sk.ffi.buildClass(a, function (b, g) {
        g.__init__ = Sk.ffi.functionPy(function (a, b, c, d, e, f, g, h, k, m, E, C, A, u, t, y, v) {
          Sk.ffi.checkMethodArgs('Lorentzian', arguments, 1, 16);
          if (l(b))
            Sk.ffi.checkMethodArgs('Lorentzian', arguments, 1, 1), Sk.ffi.referenceToPy(Sk.ffi.remapToJs(b), 'Lorentzian', void 0, a);
          else {
            Sk.ffi.checkMethodArgs('Lorentzian', arguments, 16, 16);
            var s = {};
            s[0] = b;
            s[1] = c;
            s[2] = d;
            s[3] = e;
            s[4] = f;
            s[5] = g;
            s[6] = h;
            s[7] = k;
            s[8] = m;
            s[9] = E;
            s[10] = C;
            s[11] = A;
            s[12] = u;
            s[13] = t;
            s[14] = y;
            s[15] = v;
            Sk.ffi.referenceToPy(s, 'Lorentzian', void 0, a);
          }
        });
        g.__add__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b), e = Sk.ffi.remapToJs(c);
          if (l(c)) {
            var f = Sk.ffi.numberToFloatPy(0), g = Sk.ffh.add(d[0], e[0]), k = Sk.ffh.add(d[1], e[1]), m = Sk.ffh.add(d[2], e[2]), z = f, G = Sk.ffh.add(d[4], e[4]), E = f, C = f, A = f, d = Sk.ffh.add(d[8], e[8]);
            return Sk.ffi.callsim(a.Lorentzian, g, k, m, z, G, E, C, A, d, f, f, f, f, f, f, f);
          }
          if (Sk.ffi.isNum(c))
            return f = Sk.ffi.numberToFloatPy(0), g = Sk.ffh.add(d[0], e), k = d[1], m = d[2], G = d[4], d = d[8], Sk.ffi.callsim(a.Lorentzian, g, k, m, f, G, f, f, f, d, f, f, f, f, f, f, f);
          Sk.ffi.checkRhsOperandType('add', h, !1, c);
        });
        g.__radd__ = Sk.ffi.functionPy(function (b, c) {
          Sk.ffi.checkLhsOperandType('add', h, Sk.ffi.isNum(c), c);
          var d = Sk.ffi.remapToJs(c), e = Sk.ffi.remapToJs(b), f = Sk.ffi.numberToFloatPy(0), g;
          try {
            g = Sk.ffh.add(d, e[0]);
          } catch (k) {
            g = Sk.ffh.add(e[0], d);
          }
          return Sk.ffi.callsim(a.Lorentzian, g, e[1], e[2], f, e[4], f, f, f, e[8], f, f, f, f, f, f, f);
        });
        g.__iadd__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a), d = Sk.ffi.remapToJs(b);
          if (Sk.ffi.isNum(b))
            return c.w += d, a;
          if (l(b))
            return c.w += d.w, c.x += d.x, c.y += d.y, c.xy += d.xy, a;
          Sk.ffi.checkRhsOperandType('add', h, Sk.ffi.isNum(b), b);
        });
        g.__sub__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(b);
          if (Sk.ffi.isNum(b))
            return d(c.w - e, c.x, c.y, c.xy);
          if (l(b))
            return d(c.w - e.w, c.x - e.x, c.y - e.y, c.xy - e.xy);
          Sk.ffi.checkRhsOperandType('subtract', h, Sk.ffi.isNum(b), b);
        });
        g.__rsub__ = Sk.ffi.functionPy(function (a, b) {
          Sk.ffi.checkLhsOperandType('add', h, Sk.ffi.isNum(b), b);
          var c = Sk.ffi.remapToJs(b), e = Sk.ffi.remapToJs(a);
          return d(c - e.w, -e.x, -e.y, -e.xy);
        });
        g.__isub__ = Sk.ffi.functionPy(function (a, b) {
          var d = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(b);
          c(e) ? d.w -= e : (d.w -= e.w, d.x -= e.x, d.y -= e.y, d.xy -= e.xy);
          return a;
        });
        g.__mul__ = Sk.ffi.functionPy(function (b, c) {
          function d(a) {
            for (var b = Sk.ffi.numberToIntPy(0), c = 0; c < a.length; c++)
              b = Sk.ffh.add(b, a[c]);
            return b;
          }
          function e(a) {
            return a.map(function (a) {
              var b = a[0];
              a = Sk.ffh.mul(f[a[1]], g[a[2]]);
              return 0 < b ? a : Sk.ffh.negative(a);
            });
          }
          var f = Sk.ffi.remapToJs(b), g = Sk.ffi.remapToJs(c);
          if (l(c)) {
            Sk.ffi.numberToFloatPy(0);
            var k = d(e([
                [
                  1,
                  0,
                  0
                ],
                [
                  1,
                  1,
                  1
                ],
                [
                  1,
                  2,
                  2
                ],
                [
                  -1,
                  3,
                  3
                ],
                [
                  1,
                  4,
                  4
                ],
                [
                  -1,
                  5,
                  5
                ],
                [
                  -1,
                  6,
                  6
                ],
                [
                  -1,
                  7,
                  7
                ],
                [
                  1,
                  8,
                  8
                ],
                [
                  -1,
                  9,
                  9
                ],
                [
                  -1,
                  10,
                  10
                ],
                [
                  1,
                  11,
                  11
                ],
                [
                  -1,
                  12,
                  12
                ],
                [
                  1,
                  13,
                  13
                ],
                [
                  1,
                  14,
                  14
                ],
                [
                  -1,
                  15,
                  15
                ]
              ])), m = d(e([
                [
                  1,
                  1,
                  0
                ],
                [
                  1,
                  0,
                  1
                ],
                [
                  1,
                  3,
                  2
                ],
                [
                  -1,
                  2,
                  3
                ],
                [
                  1,
                  5,
                  4
                ],
                [
                  -1,
                  4,
                  5
                ],
                [
                  -1,
                  7,
                  6
                ],
                [
                  -1,
                  6,
                  7
                ],
                [
                  -1,
                  9,
                  8
                ],
                [
                  1,
                  8,
                  9
                ],
                [
                  -1,
                  11,
                  10
                ]
              ])), z = d(e([
                [
                  1,
                  2,
                  0
                ],
                [
                  -1,
                  3,
                  1
                ],
                [
                  1,
                  0,
                  2
                ]
              ])), G = d(e([
                [
                  1,
                  3,
                  0
                ],
                [
                  -1,
                  2,
                  1
                ],
                [
                  1,
                  1,
                  2
                ],
                [
                  1,
                  0,
                  3
                ],
                [
                  1,
                  7,
                  4
                ],
                [
                  1,
                  6,
                  5
                ],
                [
                  -1,
                  5,
                  6
                ],
                [
                  1,
                  4,
                  7
                ],
                [
                  -1,
                  11,
                  8
                ],
                [
                  -1,
                  10,
                  9
                ],
                [
                  1,
                  9,
                  10
                ],
                [
                  -1,
                  8,
                  11
                ],
                [
                  -1,
                  15,
                  12
                ],
                [
                  -1,
                  14,
                  13
                ],
                [
                  1,
                  13,
                  14
                ],
                [
                  1,
                  12,
                  15
                ]
              ])), E = d(e([[
                  1,
                  4,
                  0
                ]])), C = d(e([[
                  1,
                  5,
                  0
                ]])), A = d(e([[
                  1,
                  6,
                  0
                ]])), u = d(e([[
                  1,
                  7,
                  0
                ]])), t = d(e([[
                  1,
                  8,
                  0
                ]])), y = d(e([[
                  1,
                  9,
                  0
                ]])), v = d(e([[
                  1,
                  10,
                  0
                ]])), s = d(e([[
                  1,
                  11,
                  0
                ]])), r = d(e([[
                  1,
                  12,
                  0
                ]])), B = d(e([[
                  1,
                  13,
                  0
                ]])), w = d(e([[
                  1,
                  14,
                  0
                ]])), K = d(e([[
                  1,
                  15,
                  0
                ]]));
            return Sk.ffi.callsim(a.Lorentzian, k, m, z, G, E, C, A, u, t, y, v, s, r, B, w, K);
          }
          if (Sk.ffi.isNum(c))
            return k = Sk.ffh.add(f[0], g), m = Sk.ffh.add(f[1], g), z = Sk.ffh.add(f[2], g), G = Sk.ffh.add(f[3], g), E = Sk.ffh.add(f[4], g), C = Sk.ffh.add(f[5], g), A = Sk.ffh.add(f[6], g), u = Sk.ffh.add(f[7], g), t = Sk.ffh.add(f[8], g), y = Sk.ffh.add(f[9], g), v = Sk.ffh.add(f[10], g), s = Sk.ffh.add(f[11], g), r = Sk.ffh.add(f[12], g), B = Sk.ffh.add(f[13], g), w = Sk.ffh.add(f[14], g), K = Sk.ffh.add(f[15], g), Sk.ffi.callsim(a.Lorentzian, k, m, z, G, E, C, A, u, t, y, v, s, r, B, w, K);
          Sk.ffi.checkRhsOperandType('multiply', h, !1, c);
        });
        g.__rmul__ = Sk.ffi.functionPy(function (a, b) {
          b = Sk.ffi.remapToJs(b);
          a = Sk.ffi.remapToJs(a);
          if (c(b))
            return d(b * a.w, b * a.x, b * a.y, b * a.xy);
          throw new Sk.builtin.AssertionError('' + JSON.stringify(b, null, 2) + ' * ' + JSON.stringify(a, null, 2));
        });
        g.__imul__ = Sk.ffi.functionPy(function (a, b) {
          var d = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(b);
          if (c(e))
            d.w *= e, d.x *= e, d.y *= e, d.xy *= e;
          else {
            var f = d.w, g = d.x, h = d.y, k = d.xy, l = e.w, m = e.x, E = e.y, e = e.xy;
            d.w = f * l + g * m + h * E - k * e;
            d.x = f * m + g * l - h * e + k * E;
            d.y = f * E + g * e + h * l - k * m;
            d.xy = f * e + g * E - h * m + k * l;
          }
          return a;
        });
        g.__div__ = Sk.ffi.functionPy(function (a, b) {
          a = Sk.ffi.remapToJs(a);
          b = Sk.ffi.remapToJs(b);
          return c(b) ? f(a.w, a.x, a.y, a.xy, b, 0, 0, 0, void 0) : f(a.w, a.x, a.y, a.xy, b.w, b.x, b.y, b.xy, void 0);
        });
        g.__rdiv__ = Sk.ffi.functionPy(function (a, b) {
          b = Sk.ffi.remapToJs(b);
          a = Sk.ffi.remapToJs(a);
          if (c(b))
            return f(b, 0, 0, 0, a.w, a.x, a.y, a.xy, void 0);
          throw new Sk.builtin.AssertionError('' + JSON.stringify(b, null, 2) + ' / ' + JSON.stringify(a, null, 2));
        });
        g.__idiv__ = Sk.ffi.functionPy(function (a, b) {
          var d = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(b);
          c(e) ? f(d.w, d.x, d.y, d.xy, e, 0, 0, 0, d) : f(d.w, d.x, d.y, d.xy, e.w, e.x, e.y, e.xy, d);
          return a;
        });
        g.__xor__ = Sk.ffi.functionPy(function (a, b) {
          a = Sk.ffi.remapToJs(a);
          b = Sk.ffi.remapToJs(b);
          if (c(b))
            return d(a.w * b, a.x * b, a.y * b, a.xy * b);
          var e = a.w, f = a.x, g = a.y, h = b.w, k = b.x, l = b.y;
          return d(e * h, e * k + f * h, e * l + g * h, e * b.xy + f * l - g * k + a.xy * h);
        });
        g.__rxor__ = Sk.ffi.functionPy(function (a, b) {
          b = Sk.ffi.remapToJs(b);
          a = Sk.ffi.remapToJs(a);
          if (c(b))
            return d(b * a.w, b * a.x, b * a.y, b * a.xy);
          throw new Sk.builtin.AssertionError('' + JSON.stringify(b, null, 2) + ' ^ ' + JSON.stringify(a, null, 2));
        });
        g.__ixor__ = Sk.ffi.functionPy(function (a, b) {
          var d = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(b);
          if (c(e))
            d.w *= e, d.x *= e, d.y *= e, d.xy *= e;
          else {
            var f = d.w, g = d.x, h = d.y, k = d.xy, l = e.w, m = e.x, E = e.y, e = e.xy;
            d.w = f * l;
            d.x = f * m + g * l;
            d.y = f * E + h * l;
            d.xy = f * e + g * E - h * m + k * l;
          }
          return a;
        });
        g.__lshift__ = Sk.ffi.functionPy(function (a, b) {
          a = Sk.ffi.remapToJs(a);
          b = Sk.ffi.remapToJs(b);
          if (c(b))
            return d(a.w * b, 0, 0, 0);
          var e = a.w, f = a.x, g = a.y, h = b.x, k = b.y, l = b.xy;
          return d(e * b.w + f * h + g * k - a.xy * l, e * h - g * l, e * k + f * l, e * l);
        });
        g.__rlshift__ = Sk.ffi.functionPy(function (a, b) {
          b = Sk.ffi.remapToJs(b);
          a = Sk.ffi.remapToJs(a);
          if (c(b))
            return d(b * a.w, b * a.x, b * a.y, b * a.xy);
          throw new Sk.builtin.AssertionError('' + JSON.stringify(b, null, 2) + ' << ' + JSON.stringify(a, null, 2));
        });
        g.__ilshift__ = Sk.ffi.functionPy(function (a, b) {
          var d = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(b);
          if (c(e))
            d.w *= e, d.x = 0, d.y = 0, d.xy = 0;
          else {
            var f = d.w, g = d.x, h = d.y, k = e.x, l = e.y, m = e.xy;
            d.w = f * e.w + g * k + h * l - d.xy * m;
            d.x = f * k - h * m;
            d.y = f * l + g * m;
            d.xy = f * m;
          }
          return a;
        });
        g.__rshift__ = Sk.ffi.functionPy(function (a, b) {
          a = Sk.ffi.remapToJs(a);
          b = Sk.ffi.remapToJs(b);
          if (c(b))
            return d(a.w * b, -a.x * b, -a.y * b, a.xy * b);
          var e = a.x, f = a.y, g = a.xy, h = b.w, k = b.x, l = b.y;
          return d(a.w * h + e * k + f * l - g * b.xy, +e * h + g * l, +f * h - g * k, g * h);
        });
        g.__rrshift__ = Sk.ffi.functionPy(function (a, b) {
          b = Sk.ffi.remapToJs(b);
          a = Sk.ffi.remapToJs(a);
          if (c(b))
            return d(b * a.w, 0, 0, 0);
          throw new Sk.builtin.AssertionError('' + JSON.stringify(b, null, 2) + ' >> ' + JSON.stringify(a, null, 2));
        });
        g.__irshift__ = Sk.ffi.functionPy(function (a, b) {
          var d = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(b);
          if (c(e)) {
            var f = d.w, g = d.x, h = d.y, k = d.xy, l = e, m = 0, E = 0, C = 0;
            d.w *= e;
            d.x *= -e;
            d.y *= -e;
            d.xy *= e;
          } else
            f = d.w, g = d.x, h = d.y, k = d.xy, l = e.w, m = e.x, E = e.y, C = e.xy, d.w = f * l + g * m + h * E - k * C, d.x = +g * l + k * E, d.y = +h * l - k * m, d.xy = k * l;
          return a;
        });
        g.u$negative = function () {
          var a = Sk.ffi.remapToJs(this);
          return d(-a.w, -a.x, -a.y, -a.xy);
        };
        g.u$positive = function () {
          return this;
        };
        g.nb$invert = function () {
          var a = Sk.ffi.remapToJs(this);
          return d(a.w, a.x, a.y, -a.xy);
        };
        g.__getitem__ = Sk.ffi.functionPy(function (a, b) {
          a = Sk.ffi.remapToJs(a);
          b = Sk.ffi.remapToJs(b);
          switch (b) {
          case 0:
            return d(a.w, 0, 0, 0);
          case 1:
            return d(0, a.x, a.y, 0);
          case 2:
            return d(0, 0, 0, a.xy);
          }
        });
        g.__abs__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.numberToFloatPy(Math.sqrt(a.w * a.w + a.x * a.x + a.y * a.y - a.xy * a.xy));
        });
        g.__exp__ = Sk.ffi.functionPy(function (a) {
          var b = Sk.ffi.remapToJs(a);
          a = Math.exp(b.w);
          var c = Sk.math.cos(b.xy), b = Sk.math.sin(b.xy);
          return d(a * c, 0, 0, a * b);
        });
        g.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.builtin.stringToPy('Lorentzian(' + [
            a.w,
            a.x,
            a.y,
            a.xy
          ].map(function (a) {
            return String(a);
          }).join(', ') + ')');
        });
        g.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return a.isNaN() ? Sk.builtin.stringToPy('NaN') : Sk.builtin.stringToPy(e([
            a.w,
            a.x,
            a.y,
            a.xy
          ], [
            '1',
            'i',
            'j',
            'I'
          ], '*'));
        });
        g.__eq__ = Sk.ffi.functionPy(function (a, b) {
          return Sk.ffi.bool.True;
        });
        g.__ne__ = Sk.ffi.functionPy(function (a, b) {
          a = Sk.ffi.remapToJs(a);
          b = Sk.ffi.remapToJs(b);
          return a.w !== b.w || a.x !== b.x || a.y !== b.y || a.xy !== b.xy;
        });
        g.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var e = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'w':
            return e[0];
          case 'x':
            return e[1];
          case 'y':
            return e[2];
          case 'xy':
            return e[3];
          case 'yx':
            return Sk.ffh.negative(e[3]);
          case 'z':
            return e[4];
          case 'xz':
            return e[5];
          case 'zx':
            return Sk.ffh.negative(e[5]);
          case 'yz':
            return e[6];
          case 'zy':
            return Sk.ffh.negative(e[6]);
          case 'xyz':
            return e[7];
          case 't':
            return e[8];
          case 'xt':
            return e[9];
          case 'tx':
            return Sk.ffh.negative(e[9]);
          case 'yt':
            return e[10];
          case 'ty':
            return Sk.ffh.negative(e[10]);
          case 'xyt':
            return e[11];
          case 'zt':
            return e[12];
          case 'tz':
            return Sk.ffh.negative(e[12]);
          case 'xzt':
            return e[13];
          case 'zxt':
            return Sk.ffh.negative(e[13]);
          case 'yzt':
            return e[14];
          case 'xyzt':
            return e[15];
          case 'clone':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
              b.__init__ = Sk.ffi.functionPy(function (a) {
              });
              b.__call__ = Sk.ffi.functionPy(function (a) {
                return d(e.w, e.x, e.y, e.xy);
              });
            }, 'clone', []));
          case 'magnitude':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
              b.__init__ = Sk.ffi.functionPy(function (a) {
              });
              b.__call__ = Sk.ffi.functionPy(function (a) {
                return Sk.ffi.numberToFloatPy(Math.sqrt(e.w * e.w + e.x * e.x + e.y * e.y - e.xy * e.xy));
              });
            }, 'magnitude', []));
          case 'quadrance':
            return Sk.ffi.callableToPy(a, c, function (a) {
              a = Sk.ffh.mul(e[0], e[0]);
              a = Sk.ffh.add(a, Sk.ffh.mul(e[1], e[1]));
              a = Sk.ffh.add(a, Sk.ffh.mul(e[2], e[2]));
              a = Sk.ffh.add(a, Sk.ffh.mul(e[4], e[4]));
              return a = Sk.ffh.sub(a, Sk.ffh.mul(e[8], e[8]));
            });
          default:
            throw Sk.ffi.err.attribute(c).isNotGetableOnType('Lorentzian');
          }
        });
        g.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          a = Sk.ffi.remapToJs(a);
          switch (b) {
          case 'w':
          case 'x':
          case 'y':
          case 'xy':
            Sk.ffi.checkArgType(b, [
              Sk.ffi.PyType.FLOAT,
              Sk.ffi.PyType.INT,
              Sk.ffi.PyType.LONG
            ], Sk.ffi.isNum(c), c);
            a[b] = Sk.ffi.remapToJs(c);
            break;
          default:
            throw Sk.ffi.err.attribute(b).isNotSetableOnType('Lorentzian');
          }
        });
      }, 'Lorentzian', []);
    };
  }.call(this));
  Sk.symbolic = Sk.symbolic || {};
  Sk.symbolic.VARIABLE = 'Variable';
  (function () {
    Sk.builtin.defineSymbolic = function (a, b) {
      Sk.ffi.checkFunctionArgs('defineSymbolic', arguments, 2, 2);
      Sk.symbolic.treeGetAttr = function (a, b, e) {
        b = Sk.ffi.remapToJs(b);
        switch (e) {
        case 'childAxis':
          return Sk.ffi.listPy(b[e]);
        case 'uuid':
          return Sk.builtin.stringToPy(b[e]);
        default:
          throw Sk.ffi.err.attribute(e).isNotGetableOnType(a);
        }
      };
      Sk.symbolic.treeSetAttr = function (a, b, e, f) {
        Sk.ffi.remapToJs(b);
        switch (e) {
        default:
          throw Sk.ffi.err.attribute(e).isNotSetableOnType(a);
        }
      };
      a.Environment = Sk.ffi.buildClass(a, function (b, d) {
        d.__init__ = Sk.ffi.functionPy(function (a, b, c) {
          Sk.ffi.checkMethodArgs('Environment', arguments, 0, 2);
          var d = { bindings: {} };
          'undefined' === typeof b || Sk.ffi.isNone(b) || (Sk.ffi.checkArgType('parent', 'Environment', Sk.ffi.isInstance(b, 'Environment'), b), d.parent = b);
          if ('undefined' !== typeof c && !Sk.ffi.isNone(c)) {
            Sk.ffi.checkArgType('binding', 'Binding', Sk.ffi.isInstance(c, 'Binding'), c);
            var l = Sk.ffi.gattr(c, 'name');
            Sk.ffi.checkArgType('name', Sk.ffi.PyType.STR, Sk.builtin.isStringPy(l), l);
            var k = Sk.ffi.gattr(c, 'expr');
            d.bindings[Sk.ffi.remapToJs(l)] = k;
          }
          Sk.ffi.referenceToPy(d, 'Environment', void 0, a);
        });
        d.__add__ = Sk.ffi.functionPy(function (b, c) {
          Sk.ffi.checkMethodArgs('+', arguments, 1, 1);
          return Sk.ffi.callsim(a.Environment, b, c);
        });
        d.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'lookup':
            return Sk.ffi.callableToPy(a, 'lookup', function (a, b) {
              Sk.ffi.checkMethodArgs('lookup', arguments, 1, 1);
              Sk.ffi.checkArgType('name', Sk.ffi.PyType.STR, Sk.builtin.isStringPy(b), b);
              var c = Sk.ffi.remapToJs(b);
              return 'undefined' !== typeof d.bindings[c] ? d.bindings[c] : 'undefined' !== typeof d.parent ? Sk.ffi.callsim(Sk.ffi.gattr(d.parent, 'lookup'), b) : Sk.builtin.none.none$;
            });
          default:
            throw Sk.ffi.err.attribute(c).isNotGetableOnType('Environment');
          }
        });
        d.__repr__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.remapToJs(a);
          return Sk.builtin.stringToPy('Environment()');
        });
        d.__str__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.remapToJs(a);
          return Sk.builtin.stringToPy('Environment');
        });
      }, 'Environment', []);
      a.Variable = Sk.ffi.buildClass(a, function (b, d) {
        d.__init__ = Sk.ffi.functionPy(function (a, b) {
          Sk.ffi.checkMethodArgs('Variable', arguments, 1, 1);
          Sk.ffi.checkArgType('name', Sk.ffi.PyType.STR, Sk.builtin.isStringPy(b), b);
          var c = {};
          c.name = b;
          c.uuid = THREE.Math.generateUUID();
          c.childAxis = [];
          Sk.ffi.referenceToPy(c, 'Variable', void 0, a);
        });
        d.__add__ = Sk.ffi.functionPy(function (b, c) {
          Sk.ffi.checkMethodArgs('+', arguments, 1, 1);
          return Sk.ffi.callsim(a.Add, b, c);
        });
        d.__radd__ = Sk.ffi.functionPy(function (b, c) {
          Sk.ffi.checkMethodArgs('+', arguments, 1, 1);
          return Sk.ffi.callsim(a.Add, c, b);
        });
        d.__sub__ = Sk.ffi.functionPy(function (b, c) {
          Sk.ffi.checkMethodArgs('-', arguments, 1, 1);
          return Sk.ffi.callsim(a.Subtract, b, c);
        });
        d.__mul__ = Sk.ffi.functionPy(function (b, c) {
          Sk.ffi.checkMethodArgs('*', arguments, 1, 1);
          return Sk.ffi.callsim(a.Multiply, b, c);
        });
        d.__rmul__ = Sk.ffi.functionPy(function (b, c) {
          Sk.ffi.checkMethodArgs('*', arguments, 1, 1);
          return Sk.ffi.callsim(a.Multiply, c, b);
        });
        d.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'evaluate':
            return Sk.ffi.callableToPy(a, 'evaluate', function (a, c) {
              Sk.ffi.checkMethodArgs('evaluate', arguments, 1, 1);
              Sk.ffi.checkArgType('env', 'Environment', Sk.ffi.isInstance(c, 'Environment'), c);
              var f = Sk.ffi.gattr(c, 'lookup'), f = Sk.ffi.callsim(f, d.name);
              return Sk.ffi.isNone(f) ? b : f;
            });
          default:
            return Sk.symbolic.treeGetAttr('Variable', b, c);
          }
        });
        d.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.builtin.stringToPy('Variable("' + Sk.ffi.remapToJs(a.name) + '")');
        });
        d.__str__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.remapToJs(a).name;
        });
      }, 'Variable', []);
      a.TreeWalker = Sk.ffi.buildClass(a, function (b, d) {
        d.__init__ = Sk.ffi.functionPy(function (a, b) {
          Sk.ffi.checkMethodArgs('TreeWalker', arguments, 1, 1);
          var c = { ancestorAxis: [] };
          c.contextNode = b;
          c.childAxis = Sk.ffi.gattr(c.contextNode, 'childAxis');
          Sk.ffi.referenceToPy(c, 'TreeWalker', void 0, a);
        });
        d.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'ancestorAxis':
            return Sk.ffi.listPy(d[c]);
          case 'contextNode':
            return d[c];
          case 'moveToFirstChild':
            return Sk.ffi.callableToPy(a, c, function (a) {
              a = Sk.ffi.remapToJs(d.childAxis);
              return 0 < a.length ? (d.ancestorAxis.push(d.contextNode), d.contextNode = a[0], d.childAxis = Sk.ffi.gattr(d.contextNode, 'childAxis'), Sk.ffi.booleanToPy(!0)) : Sk.ffi.booleanToPy(!1);
            });
          case 'moveToLastChild':
            return Sk.ffi.callableToPy(a, c, function (a) {
              a = Sk.ffi.remapToJs(d.childAxis);
              return 0 < a.length ? (d.ancestorAxis.push(d.contextNode), d.contextNode = a[a.length - 1], d.childAxis = Sk.ffi.gattr(d.contextNode, 'childAxis'), Sk.ffi.booleanToPy(!0)) : Sk.ffi.booleanToPy(!1);
            });
          case 'moveToParent':
            return Sk.ffi.callableToPy(a, c, function (a) {
              Sk.ffi.remapToJs(d.childAxis);
              return 0 < d.ancestorAxis.length ? (a = d.ancestorAxis.pop(), d.contextNode = a, d.childAxis = Sk.ffi.gattr(d.contextNode, 'childAxis'), Sk.ffi.booleanToPy(!0)) : Sk.ffi.booleanToPy(!1);
            });
          default:
            throw Sk.ffi.err.attribute(c).isNotGetableOnType('TreeWalker');
          }
        });
        d.__repr__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.remapToJs(a);
          return Sk.builtin.stringToPy('TreeWalker()');
        });
        d.__str__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.remapToJs(a);
          return Sk.builtin.stringToPy('TreeWalker');
        });
      }, 'TreeWalker', []);
      a.Binding = Sk.ffi.buildClass(a, function (a, b) {
        b.__init__ = Sk.ffi.functionPy(function (a, b, c) {
          Sk.ffi.checkMethodArgs('Binding', arguments, 2, 2);
          Sk.ffi.checkArgType('name', Sk.ffi.PyType.STR, Sk.builtin.isStringPy(b), b);
          var d = {};
          d.name = b;
          d.expr = c;
          Sk.ffi.referenceToPy(d, 'Binding', void 0, a);
        });
        b.__getattr__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a);
          switch (b) {
          case 'name':
            return c.name;
          case 'expr':
            return c.expr;
          default:
            throw Sk.ffi.err.attribute(b).isNotGetableOnType('Binding');
          }
        });
        b.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          a = [
            '"' + Sk.ffi.remapToJs(a.name) + '"',
            Sk.ffi.remapToJs(Sk.ffh.repr(a.expr))
          ].join(', ');
          return Sk.builtin.stringToPy('Binding(' + a + ')');
        });
        b.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          a = [
            Sk.ffi.remapToJs(a.name),
            Sk.ffi.remapToJs(Sk.ffh.str(a.expr))
          ].join(' => ');
          return Sk.builtin.stringToPy(a);
        });
      }, 'Binding', []);
      a.Add = Sk.ffi.buildClass(a, function (b, d) {
        d.__init__ = Sk.ffi.functionPy(function (a, b, c) {
          Sk.ffi.checkMethodArgs('Add', arguments, 2, 2);
          var d = {};
          d.lhs = b;
          d.rhs = c;
          d.uuid = THREE.Math.generateUUID();
          d.childAxis = [
            b,
            c
          ];
          Sk.ffi.referenceToPy(d, 'Add', void 0, a);
        });
        d.__add__ = Sk.ffi.functionPy(function (b, c) {
          Sk.ffi.checkMethodArgs('+', arguments, 1, 1);
          return Sk.ffi.callsim(a.Add, b, c);
        });
        d.__sub__ = Sk.ffi.functionPy(function (b, c) {
          Sk.ffi.checkMethodArgs('-', arguments, 1, 1);
          return Sk.ffi.callsim(a.Subtract, b, c);
        });
        d.__mul__ = Sk.ffi.functionPy(function (b, c) {
          Sk.ffi.checkMethodArgs('*', arguments, 1, 1);
          return Sk.ffi.callsim(a.Multiply, b, c);
        });
        d.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'className':
            return Sk.builtin.stringToPy('Add');
          case 'lhs':
          case 'rhs':
            return d[c];
          case 'evaluate':
            return Sk.ffi.callableToPy(a, 'evaluate', function (a, b) {
              Sk.ffi.checkMethodArgs('evaluate', arguments, 1, 1);
              Sk.ffi.checkArgType('env', 'Environment', Sk.ffi.isInstance(b, 'Environment'), b);
              var c = Sk.ffh.evaluate(d.lhs, b), e = Sk.ffh.evaluate(d.rhs, b);
              return Sk.ffh.add(c, e);
            });
          default:
            return Sk.symbolic.treeGetAttr('Add', b, c);
          }
        });
        d.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          a = [
            a.lhs,
            a.rhs
          ].map(function (a) {
            return Sk.ffi.remapToJs(Sk.ffh.repr(a));
          }).join(', ');
          return Sk.builtin.stringToPy('Add(' + a + ')');
        });
        d.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          a = [
            a.lhs,
            a.rhs
          ].map(function (a) {
            return Sk.ffi.remapToJs(Sk.ffh.str(a));
          }).join(' + ');
          return Sk.builtin.stringToPy('(' + a + ')');
        });
      }, 'Add', []);
      a.Subtract = Sk.ffi.buildClass(a, function (b, d) {
        d.__init__ = Sk.ffi.functionPy(function (a, b, c) {
          Sk.ffi.checkMethodArgs('Subtract', arguments, 2, 2);
          var d = {};
          d.lhs = b;
          d.rhs = c;
          d.uuid = THREE.Math.generateUUID();
          d.childAxis = [
            b,
            c
          ];
          Sk.ffi.referenceToPy(d, 'Subtract', void 0, a);
        });
        d.__add__ = Sk.ffi.functionPy(function (b, c) {
          Sk.ffi.checkMethodArgs('+', arguments, 1, 1);
          return Sk.ffi.callsim(a.Add, b, c);
        });
        d.__mul__ = Sk.ffi.functionPy(function (b, c) {
          Sk.ffi.checkMethodArgs('*', arguments, 1, 1);
          return Sk.ffi.callsim(a.Multiply, b, c);
        });
        d.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'evaluate':
            return Sk.ffi.callableToPy(a, 'evaluate', function (a, b) {
              Sk.ffi.checkMethodArgs('evaluate', arguments, 1, 1);
              Sk.ffi.checkArgType('env', 'Environment', Sk.ffi.isInstance(b, 'Environment'), b);
              var c = Sk.ffh.evaluate(d.lhs, b), e = Sk.ffh.evaluate(d.rhs, b);
              return Sk.ffh.sub(c, e);
            });
          default:
            return Sk.symbolic.treeGetAttr('Subtract', b, c);
          }
        });
        d.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          a = [
            a.lhs,
            a.rhs
          ].map(function (a) {
            return Sk.ffi.remapToJs(Sk.ffh.repr(a));
          }).join(', ');
          return Sk.builtin.stringToPy('Subtract(' + a + ')');
        });
        d.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          a = [
            a.lhs,
            a.rhs
          ].map(function (a) {
            return Sk.ffi.remapToJs(Sk.ffh.str(a));
          }).join(' - ');
          return Sk.builtin.stringToPy('(' + a + ')');
        });
      }, 'Subtract', []);
      a.Multiply = Sk.ffi.buildClass(a, function (b, d) {
        d.__init__ = Sk.ffi.functionPy(function (a, b, c) {
          Sk.ffi.checkMethodArgs('Multiply', arguments, 2, 2);
          var d = {};
          d.lhs = b;
          d.rhs = c;
          d.uuid = THREE.Math.generateUUID();
          d.childAxis = [
            b,
            c
          ];
          Sk.ffi.referenceToPy(d, 'Multiply', void 0, a);
        });
        d.__add__ = Sk.ffi.functionPy(function (b, c) {
          Sk.ffi.checkMethodArgs('+', arguments, 1, 1);
          return Sk.ffi.callsim(a.Add, b, c);
        });
        d.__mul__ = Sk.ffi.functionPy(function (b, c) {
          Sk.ffi.checkMethodArgs('*', arguments, 1, 1);
          return Sk.ffi.callsim(a.Multiply, b, c);
        });
        d.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'className':
            return Sk.builtin.stringToPy('Multiply');
          case 'lhs':
          case 'rhs':
            return d[c];
          case 'evaluate':
            return Sk.ffi.callableToPy(a, 'evaluate', function (a, b) {
              Sk.ffi.checkMethodArgs('evaluate', arguments, 1, 1);
              Sk.ffi.checkArgType('env', 'Environment', Sk.ffi.isInstance(b, 'Environment'), b);
              var c = Sk.ffh.evaluate(d.lhs, b), e = Sk.ffh.evaluate(d.rhs, b);
              return Sk.ffh.mul(c, e);
            });
          default:
            return Sk.symbolic.treeGetAttr('Multiply', b, c);
          }
        });
        d.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          a = [
            a.lhs,
            a.rhs
          ].map(function (a) {
            return Sk.ffi.remapToJs(Sk.ffh.repr(a));
          }).join(', ');
          return Sk.builtin.stringToPy('Multiply(' + a + ')');
        });
        d.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          a = [
            a.lhs,
            a.rhs
          ].map(function (a) {
            return Sk.ffi.remapToJs(Sk.ffh.str(a));
          }).join(' * ');
          return Sk.builtin.stringToPy('(' + a + ')');
        });
      }, 'Multiply', []);
      a.PointE2 = Sk.ffi.buildClass(a, function (b, d) {
        d.__init__ = Sk.ffi.functionPy(function (a, b, c) {
          Sk.ffi.checkMethodArgs('PointE2', arguments, 2, 2);
          var d = {};
          d.x = b;
          d.y = c;
          Sk.ffi.referenceToPy(d, 'PointE2', void 0, a);
        });
        d.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'evaluate':
            return Sk.ffi.callableToPy(a, 'evaluate', function (b, c) {
              Sk.ffi.checkMethodArgs('evaluate', arguments, 1, 1);
              Sk.ffi.checkArgType('env', 'Environment', Sk.ffi.isInstance(c, 'Environment'), c);
              var e = Sk.ffh.evaluate(d.x, c), f = Sk.ffh.evaluate(d.y, c);
              return Sk.ffi.callsim(a.PointE2, e, f);
            });
          default:
            throw Sk.ffi.err.attribute(c).isNotGetableOnType('PointE2');
          }
        });
        d.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          a = [
            a.x,
            a.y
          ].map(function (a) {
            return Sk.ffi.remapToJs(Sk.ffh.repr(a));
          }).join(', ');
          return Sk.builtin.stringToPy('PointE2(' + a + ')');
        });
        d.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          a = [
            a.x,
            a.y
          ].map(function (a) {
            return Sk.ffi.remapToJs(Sk.ffh.str(a));
          }).join(', ');
          return Sk.builtin.stringToPy('[' + a + ']');
        });
      }, 'PointE2', []);
      a.Commute = Sk.ffi.buildClass(a, function (b, d) {
        d.__init__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.checkMethodArgs('Commute', arguments, 0, 0);
          Sk.ffi.referenceToPy({}, 'Commute', void 0, a);
        });
        d.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          Sk.ffi.remapToJs(b);
          switch (c) {
          case 'execute':
            return Sk.ffi.callableToPy(a, 'evaluate', function (b, c) {
              var d = Sk.ffi.remapToJs(Sk.ffi.gattr(c, 'className')), e = Sk.ffi.gattr(c, 'lhs'), f = Sk.ffi.gattr(c, 'rhs');
              Sk.ffi.checkMethodArgs('evaluate', arguments, 1, 1);
              return Sk.ffi.callsim(a[d], f, e);
            });
          default:
            throw Sk.ffi.err.attribute(c).isNotGetableOnType('Commute');
          }
        });
        d.__repr__ = Sk.ffi.functionPy(function (a) {
          return Sk.builtin.stringToPy('Commute');
        });
        d.__str__ = Sk.ffi.functionPy(function (a) {
          return Sk.builtin.stringToPy('Commute');
        });
      }, 'Commute', []);
      a.DistribL = Sk.ffi.buildClass(a, function (b, d) {
        d.__init__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.checkMethodArgs('DistribL', arguments, 0, 0);
          Sk.ffi.referenceToPy({}, 'DistribL', void 0, a);
        });
        d.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          Sk.ffi.remapToJs(b);
          switch (c) {
          case 'execute':
            return Sk.ffi.callableToPy(a, 'evaluate', function (b, c) {
              Sk.ffi.checkMethodArgs('evaluate', arguments, 1, 1);
              var d = Sk.ffi.remapToJs(Sk.ffi.gattr(c, 'className')), e = Sk.ffi.gattr(c, 'lhs'), f = Sk.ffi.gattr(c, 'rhs'), p = Sk.ffi.remapToJs(Sk.ffi.gattr(f, 'className')), n = Sk.ffi.gattr(f, 'lhs'), f = Sk.ffi.gattr(f, 'rhs'), n = Sk.ffi.callsim(a[d], e, n), d = Sk.ffi.callsim(a[d], e, f);
              return Sk.ffi.callsim(a[p], n, d);
            });
          default:
            throw Sk.ffi.err.attribute(c).isNotGetableOnType('DistribL');
          }
        });
        d.__repr__ = Sk.ffi.functionPy(function (a) {
          return Sk.builtin.stringToPy('DistribL');
        });
        d.__str__ = Sk.ffi.functionPy(function (a) {
          return Sk.builtin.stringToPy('DistribL');
        });
      }, 'DistribL', []);
      a.DistribR = Sk.ffi.buildClass(a, function (b, d) {
        d.__init__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.checkMethodArgs('DistribR', arguments, 0, 0);
          Sk.ffi.referenceToPy({}, 'DistribR', void 0, a);
        });
        d.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          Sk.ffi.remapToJs(b);
          switch (c) {
          case 'execute':
            return Sk.ffi.callableToPy(a, 'evaluate', function (b, c) {
              Sk.ffi.checkMethodArgs('evaluate', arguments, 1, 1);
              var d = Sk.ffi.remapToJs(Sk.ffi.gattr(c, 'className')), e = Sk.ffi.gattr(c, 'lhs'), f = Sk.ffi.remapToJs(Sk.ffi.gattr(e, 'className')), p = Sk.ffi.gattr(e, 'lhs'), e = Sk.ffi.gattr(e, 'rhs'), n = Sk.ffi.gattr(c, 'rhs');
              return Sk.ffi.callsim(a[f], Sk.ffi.callsim(a[d], p, n), Sk.ffi.callsim(a[d], e, n));
            });
          default:
            throw Sk.ffi.err.attribute(c).isNotGetableOnType('DistribR');
          }
        });
        d.__repr__ = Sk.ffi.functionPy(function (a) {
          return Sk.builtin.stringToPy('DistribR');
        });
        d.__str__ = Sk.ffi.functionPy(function (a) {
          return Sk.builtin.stringToPy('DistribR');
        });
      }, 'DistribR', []);
      a.FactorL = Sk.ffi.buildClass(a, function (b, d) {
        d.__init__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.checkMethodArgs('FactorL', arguments, 0, 0);
          Sk.ffi.referenceToPy({}, 'FactorL', void 0, a);
        });
        d.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          Sk.ffi.remapToJs(b);
          switch (c) {
          case 'execute':
            return Sk.ffi.callableToPy(a, 'evaluate', function (b, c) {
              Sk.ffi.checkMethodArgs('evaluate', arguments, 1, 1);
              var d = Sk.ffi.remapToJs(Sk.ffi.gattr(c, 'className')), e = Sk.ffi.gattr(c, 'lhs'), f = Sk.ffi.gattr(c, 'rhs'), p = Sk.ffi.gattr(e, 'lhs'), n = Sk.ffi.gattr(e, 'rhs'), p = Sk.ffi.gattr(f, 'lhs'), q = Sk.ffi.gattr(f, 'rhs'), e = Sk.ffi.remapToJs(Sk.ffi.gattr(e, 'className'));
              Sk.ffi.remapToJs(Sk.ffi.gattr(f, 'className'));
              return Sk.ffi.callsim(a[e], p, Sk.ffi.callsim(a[d], n, q));
            });
          default:
            throw Sk.ffi.err.attribute(c).isNotGetableOnType('FactorL');
          }
        });
        d.__repr__ = Sk.ffi.functionPy(function (a) {
          return Sk.builtin.stringToPy('FactorL');
        });
        d.__str__ = Sk.ffi.functionPy(function (a) {
          return Sk.builtin.stringToPy('FactorL');
        });
      }, 'FactorL', []);
      a.FactorR = Sk.ffi.buildClass(a, function (b, d) {
        d.__init__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.checkMethodArgs('FactorR', arguments, 0, 0);
          Sk.ffi.referenceToPy({}, 'FactorR', void 0, a);
        });
        d.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          Sk.ffi.remapToJs(b);
          switch (c) {
          case 'execute':
            return Sk.ffi.callableToPy(a, 'evaluate', function (b, c) {
              Sk.ffi.checkMethodArgs('evaluate', arguments, 1, 1);
              var d = Sk.ffi.remapToJs(Sk.ffi.gattr(c, 'className')), e = Sk.ffi.gattr(c, 'lhs'), f = Sk.ffi.gattr(c, 'rhs'), p = Sk.ffi.gattr(e, 'lhs'), n = Sk.ffi.gattr(e, 'rhs'), q = Sk.ffi.gattr(f, 'lhs'), n = Sk.ffi.gattr(f, 'rhs'), e = Sk.ffi.remapToJs(Sk.ffi.gattr(e, 'className'));
              Sk.ffi.remapToJs(Sk.ffi.gattr(f, 'className'));
              return Sk.ffi.callsim(a[e], Sk.ffi.callsim(a[d], p, q), n);
            });
          default:
            throw Sk.ffi.err.attribute(c).isNotGetableOnType('FactorR');
          }
        });
        d.__repr__ = Sk.ffi.functionPy(function (a) {
          return Sk.builtin.stringToPy('FactorR');
        });
        d.__str__ = Sk.ffi.functionPy(function (a) {
          return Sk.builtin.stringToPy('FactorR');
        });
      }, 'FactorR', []);
      a.AssocL = Sk.ffi.buildClass(a, function (b, d) {
        d.__init__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.checkMethodArgs('AssocL', arguments, 0, 0);
          Sk.ffi.referenceToPy({}, 'AssocL', void 0, a);
        });
        d.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          Sk.ffi.remapToJs(b);
          switch (c) {
          case 'execute':
            return Sk.ffi.callableToPy(a, 'evaluate', function (b, c) {
              Sk.ffi.checkMethodArgs('evaluate', arguments, 1, 1);
              var d = Sk.ffi.remapToJs(Sk.ffi.gattr(c, 'className')), e = Sk.ffi.gattr(c, 'lhs'), f = Sk.ffi.gattr(c, 'rhs'), p = Sk.ffi.gattr(f, 'lhs'), f = Sk.ffi.gattr(f, 'rhs');
              return Sk.ffi.callsim(a[d], Sk.ffi.callsim(a[d], e, p), f);
            });
          default:
            throw Sk.ffi.err.attribute(c).isNotGetableOnType('AssocL');
          }
        });
        d.__repr__ = Sk.ffi.functionPy(function (a) {
          return Sk.builtin.stringToPy('AssocL');
        });
        d.__str__ = Sk.ffi.functionPy(function (a) {
          return Sk.builtin.stringToPy('AssocL');
        });
      }, 'AssocL', []);
      a.AssocR = Sk.ffi.buildClass(a, function (b, d) {
        d.__init__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.checkMethodArgs('AssocR', arguments, 0, 0);
          Sk.ffi.referenceToPy({}, 'AssocR', void 0, a);
        });
        d.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          Sk.ffi.remapToJs(b);
          switch (c) {
          case 'execute':
            return Sk.ffi.callableToPy(a, 'evaluate', function (b, c) {
              Sk.ffi.checkMethodArgs('evaluate', arguments, 1, 1);
              var d = Sk.ffi.remapToJs(Sk.ffi.gattr(c, 'className')), e = Sk.ffi.gattr(c, 'lhs'), f = Sk.ffi.gattr(e, 'lhs'), e = Sk.ffi.gattr(e, 'rhs'), p = Sk.ffi.gattr(c, 'rhs');
              return Sk.ffi.callsim(a[d], f, Sk.ffi.callsim(a[d], e, p));
            });
          default:
            throw Sk.ffi.err.attribute(c).isNotGetableOnType('AssocR');
          }
        });
        d.__repr__ = Sk.ffi.functionPy(function (a) {
          return Sk.builtin.stringToPy('AssocR');
        });
        d.__str__ = Sk.ffi.functionPy(function (a) {
          return Sk.builtin.stringToPy('AssocR');
        });
      }, 'AssocR', []);
    };
  }.call(this));
  Sk.units = Sk.units || {};
  (function () {
    Sk.builtin.defineUnits = function (a, b) {
      Sk.ffi.checkFunctionArgs('defineUnits', arguments, 2, 2);
      a.yocto = Sk.ffi.numberToFloatPy(1e-24);
      a.zepto = Sk.ffi.numberToFloatPy(1e-21);
      a.atto = Sk.ffi.numberToFloatPy(1e-18);
      a.femto = Sk.ffi.numberToFloatPy(1e-15);
      a.pico = Sk.ffi.numberToFloatPy(1e-12);
      a.nano = Sk.ffi.numberToFloatPy(1e-9);
      a.micro = Sk.ffi.numberToFloatPy(0.000001);
      a.milli = Sk.ffi.numberToFloatPy(0.001);
      a.centi = Sk.ffi.numberToFloatPy(0.01);
      a.deci = Sk.ffi.numberToFloatPy(0.1);
      a.deka = Sk.ffi.numberToFloatPy(10);
      a.hecto = Sk.ffi.numberToFloatPy(100);
      a.kilo = Sk.ffi.numberToFloatPy(1000);
      a.mega = Sk.ffi.numberToFloatPy(1000000);
      a.giga = Sk.ffi.numberToFloatPy(1000000000);
      a.tera = Sk.ffi.numberToFloatPy(1000000000000);
      a.peta = Sk.ffi.numberToFloatPy(1000000000000000);
      a.exa = Sk.ffi.numberToFloatPy(1000000000000000000);
      a.zetta = Sk.ffi.numberToFloatPy(1e+21);
      a.yotta = Sk.ffi.numberToFloatPy(1e+24);
      var c = [
          Sk.ffi.PyType.FLOAT,
          Sk.ffi.PyType.INT,
          Sk.ffi.PyType.LONG
        ], d = function (a) {
          return Sk.ffi.isInstance(a, 'Measure');
        }, e = function (a) {
          return Sk.ffi.isInstance(a, 'Unit');
        }, f = function (a) {
          return Sk.ffi.isNum(a) ? !0 : Sk.ffi.isInstance(a, 'Euclidean3') ? !0 : Sk.ffi.isInstance(a, 'Euclidean2') ? !0 : Sk.ffi.isInstance(a, 'complex') ? !0 : Sk.ffi.isInstance(a, 'Rational') ? !0 : Sk.ffi.isInstance(a, 'Fraction') ? !0 : !1;
        };
      Sk.builtin.defineFractions(a, 'Rational', function (a, c) {
        return new b.Rational(a, c);
      });
      a.Dimensions = Sk.ffi.buildClass(a, function (c, d) {
        d.__init__ = Sk.ffi.functionPy(function (a, c, d, e, f, g, h, D) {
          Sk.ffi.checkMethodArgs('Dimensions', arguments, 1, 7);
          Sk.ffi.checkArgType('M', 'Rational', Sk.ffi.isInstance(c, 'Rational') || Sk.ffi.isInstance(c, 'Dimensions'), c);
          switch (Sk.ffi.typeName(c)) {
          case 'Rational':
            Sk.ffi.checkMethodArgs('Dimensions', arguments, 7, 7);
            Sk.ffi.checkArgType('L', 'Rational', Sk.ffi.isInstance(d, 'Rational'), d);
            Sk.ffi.checkArgType('T', 'Rational', Sk.ffi.isInstance(e, 'Rational'), e);
            Sk.ffi.checkArgType('Q', 'Rational', Sk.ffi.isInstance(f, 'Rational'), f);
            Sk.ffi.checkArgType('temperature', 'Rational', Sk.ffi.isInstance(g, 'Rational'), g);
            Sk.ffi.checkArgType('amount', 'Rational', Sk.ffi.isInstance(h, 'Rational'), h);
            Sk.ffi.checkArgType('intensity', 'Rational', Sk.ffi.isInstance(D, 'Rational'), D);
            Sk.ffi.referenceToPy(new b.Dimensions(Sk.ffi.remapToJs(c), Sk.ffi.remapToJs(d), Sk.ffi.remapToJs(e), Sk.ffi.remapToJs(f), Sk.ffi.remapToJs(g), Sk.ffi.remapToJs(h), Sk.ffi.remapToJs(D)), 'Dimensions', void 0, a);
            break;
          case 'Dimensions':
            Sk.ffi.checkMethodArgs('Dimensions', arguments, 1, 1);
            Sk.ffi.referenceToPy(Sk.ffi.remapToJs(c), 'Dimensions', void 0, a);
            break;
          default:
            throw Sk.ffi.err.argument('M').inFunction('Dimensions').mustHaveType([
              'Rational',
              'Dimensions'
            ]);
          }
        });
        d.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'M':
            return Sk.ffi.callsim(a.Rational, Sk.ffi.referenceToPy(d.M, 'Rational'));
          case 'L':
            return Sk.ffi.callsim(a.Rational, Sk.ffi.referenceToPy(d.L, 'Rational'));
          case 'T':
            return Sk.ffi.callsim(a.Rational, Sk.ffi.referenceToPy(d.T, 'Rational'));
          case 'Q':
            return Sk.ffi.callsim(a.Rational, Sk.ffi.referenceToPy(d.Q, 'Rational'));
          case 'temperature':
            return Sk.ffi.callsim(a.Rational, Sk.ffi.referenceToPy(d.temperature, 'Rational'));
          case 'amount':
            return Sk.ffi.callsim(a.Rational, Sk.ffi.referenceToPy(d.amount, 'Rational'));
          case 'intensity':
            return Sk.ffi.callsim(a.Rational, Sk.ffi.referenceToPy(d.intensity, 'Rational'));
          }
        });
        d.__mul__ = Sk.ffi.functionPy(function (b, c) {
          Sk.ffi.checkRhsOperandType('multiply', 'Dimensions', Sk.ffi.isInstance(c, 'Dimensions'), c);
          var d = Sk.ffi.remapToJs(b), e = Sk.ffi.remapToJs(c), d = d.mul(e);
          return Sk.ffi.callsim(a.Dimensions, Sk.ffi.referenceToPy(d.M, 'Rational'), Sk.ffi.referenceToPy(d.L, 'Rational'), Sk.ffi.referenceToPy(d.T, 'Rational'), Sk.ffi.referenceToPy(d.Q, 'Rational'), Sk.ffi.referenceToPy(d.temperature, 'Rational'), Sk.ffi.referenceToPy(d.amount, 'Rational'), Sk.ffi.referenceToPy(d.intensity, 'Rational'));
        });
        d.__div__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b), e = Sk.ffi.remapToJs(c), d = d.div(e);
          return Sk.ffi.callsim(a.Dimensions, Sk.ffi.referenceToPy(d.M, 'Rational'), Sk.ffi.referenceToPy(d.L, 'Rational'), Sk.ffi.referenceToPy(d.T, 'Rational'), Sk.ffi.referenceToPy(d.Q, 'Rational'), Sk.ffi.referenceToPy(d.temperature, 'Rational'), Sk.ffi.referenceToPy(d.amount, 'Rational'), Sk.ffi.referenceToPy(d.intensity, 'Rational'));
        });
        d.__pow__ = Sk.ffi.functionPy(function (b, c) {
          Sk.ffi.checkFunctionArgs('**', arguments, 2, 2);
          var d = Sk.ffi.remapToJs(b), e = Sk.ffi.remapToJs(c), d = d.pow(e);
          return Sk.ffi.callsim(a.Dimensions, Sk.ffi.referenceToPy(d.M, 'Rational'), Sk.ffi.referenceToPy(d.L, 'Rational'), Sk.ffi.referenceToPy(d.T, 'Rational'), Sk.ffi.referenceToPy(d.Q, 'Rational'), Sk.ffi.referenceToPy(d.temperature, 'Rational'), Sk.ffi.referenceToPy(d.amount, 'Rational'), Sk.ffi.referenceToPy(d.intensity, 'Rational'));
        });
        d.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.builtin.stringToPy('' + a);
        });
        d.__repr__ = Sk.ffi.functionPy(function (a) {
          var b = 'M L T Q temperature amount intensity'.split(' ').map(function (b) {
              return Sk.ffi.gattr(a, b);
            }).map(function (a) {
              return Sk.ffi.remapToJs(Sk.ffi.callsim(a.__repr__, a));
            });
          return Sk.builtin.stringToPy('Dimensions(' + b.join(' , ') + ')');
        });
      }, 'Dimensions', []);
      a.Unit = Sk.ffi.buildClass(a, function (f, h) {
        h.__init__ = Sk.ffi.functionPy(function (a, c, d, e, f) {
          Sk.ffi.checkMethodArgs('Unit', arguments, 1, 4);
          var g = {};
          g.name = Sk.ffi.remapToJs(f);
          switch (Sk.ffi.getType(c)) {
          case Sk.ffi.PyType.FLOAT:
          case Sk.ffi.PyType.INT:
          case Sk.ffi.PyType.LONG:
            Sk.ffi.checkMethodArgs('Unit', arguments, 3, 4);
            var h = Sk.ffi.remapToJs(c), D = Sk.ffi.remapToJs(d), J = Sk.ffi.remapToJs(e);
            Sk.ffi.referenceToPy(new b.Unit(h, D, J), 'Unit', g, a);
            break;
          case Sk.ffi.PyType.INSTANCE:
            Sk.ffi.checkMethodArgs('Unit', arguments, 1, 1);
            Sk.ffi.referenceToPy(Sk.ffi.remapToJs(c), 'Unit', g, a);
            break;
          default:
            throw Error('Unit (__init__) ' + Sk.ffi.getType(c));
          }
        });
        h.__getattr__ = Sk.ffi.functionPy(function (c, d) {
          var f = Sk.ffi.remapToJs(c);
          switch (d) {
          case 'scale':
            return Sk.ffi.numberToFloatPy(f.scale);
          case 'dimensions':
            return Sk.ffi.callsim(a.Dimensions, Sk.ffi.referenceToPy(f.dimensions, 'Dimensions'));
          case 'labels':
            return Sk.ffi.remapToPy(f.labels);
          case 'name':
            return c.custom.name ? Sk.builtin.stringToPy(c.custom.name) : Sk.builtin.none.none$;
          case 'compatible':
            return Sk.ffi.callableToPy(a, 'compatible', function (a, b) {
              Sk.ffi.checkMethodArgs('compatible', arguments, 1, 1);
              Sk.ffi.checkArgType('other', 'Unit', e(b), b);
              var d = Sk.ffi.remapToJs(b);
              try {
                f.compatible(d);
              } catch (g) {
                throw Sk.ffi.assertionError(g.message);
              }
              return c;
            });
          case 'cos':
            return Sk.ffi.callableToPy(a, 'cos', function (c) {
              Sk.ffi.checkMethodArgs('cos', arguments, 0, 0);
              var d = f.dimensions, e = f.labels, d = new b.Unit(Sk.math.cos(f.scale), d, e);
              return Sk.ffi.callsim(a.Unit, Sk.ffi.referenceToPy(d, 'Unit'));
            });
          case 'sin':
            return Sk.ffi.callableToPy(a, 'sin', function (c) {
              Sk.ffi.checkMethodArgs('sin', arguments, 0, 0);
              var d = f.dimensions, e = f.labels, d = new b.Unit(Sk.math.sin(f.scale), d, e);
              return Sk.ffi.callsim(a.Unit, Sk.ffi.referenceToPy(d, 'Unit'));
            });
          default:
            throw Sk.ffi.err.attribute(d).isNotGetableOnType('Unit');
          }
        });
        h.__add__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b), e = Sk.ffi.remapToJs(c);
          try {
            var f = d.add(e);
            return Sk.ffi.callsim(a.Unit, Sk.ffi.numberToFloatPy(f.scale), Sk.ffi.referenceToPy(f.dimensions, 'Dimensions'), Sk.ffi.remapToPy(f.labels));
          } catch (g) {
            throw Sk.ffi.assertionError(g.message);
          }
        });
        h.__sub__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b), e = Sk.ffi.remapToJs(c);
          try {
            var f = d.sub(e);
            return Sk.ffi.callsim(a.Unit, Sk.ffi.numberToFloatPy(f.scale), Sk.ffi.referenceToPy(f.dimensions, 'Dimensions'), Sk.ffi.remapToPy(f.labels));
          } catch (g) {
            throw Sk.ffi.assertionError(g.message);
          }
        });
        h.__mod__ = Sk.ffi.functionPy(function (b, c) {
          var f = Sk.ffi.remapToJs(b);
          if (d(c)) {
            var f = Sk.ffi.gattr(c, 'quantity'), g = Sk.ffi.gattr(c, 'uom');
            return Sk.ffi.callsim(a.Measure, f, Sk.ffh.mul(b, g));
          }
          return Sk.ffi.isNum(c) || e(c) ? Sk.ffi.callsim(a.Unit, Sk.ffi.referenceToPy(f.mul(Sk.ffi.remapToJs(c)), 'Unit')) : Sk.ffi.callsim(a.Measure, c, b);
        });
        h.__rmod__ = Sk.ffi.functionPy(function (b, c) {
          return Sk.ffi.callsim(a.Measure, c, b);
        });
        h.__mul__ = Sk.ffi.functionPy(function (b, c) {
          var f = Sk.ffi.remapToJs(b);
          if (d(c)) {
            var f = Sk.ffi.gattr(c, 'quantity'), g = Sk.ffi.gattr(c, 'uom');
            return Sk.ffi.callsim(a.Measure, f, Sk.ffh.mul(b, g));
          }
          return Sk.ffi.isNum(c) || e(c) ? Sk.ffi.callsim(a.Unit, Sk.ffi.referenceToPy(f.mul(Sk.ffi.remapToJs(c)), 'Unit')) : Sk.ffi.callsim(a.Measure, c, b);
        });
        h.__rmul__ = Sk.ffi.functionPy(function (b, d) {
          Sk.ffi.checkLhsOperandType('multiply', c, Sk.ffi.isNum(d), d);
          var e = Sk.ffi.remapToJs(d), f = Sk.ffi.remapToJs(b);
          return Sk.ffi.callsim(a.Unit, Sk.ffi.numberToFloatPy(e * f.scale), Sk.ffi.referenceToPy(f.dimensions, 'Dimensions'), Sk.ffi.remapToPy(f.labels));
        });
        h.__div__ = Sk.ffi.functionPy(function (b, c) {
          var f = Sk.ffi.remapToJs(b);
          if (d(c)) {
            var f = Sk.ffi.gattr(c, 'quantity'), g = Sk.ffi.gattr(c, 'uom');
            return Sk.ffi.callsim(a.Measure, Sk.ffh.div(Sk.ffi.numberToFloatPy(1), f), Sk.ffh.div(b, g));
          }
          return Sk.ffi.isNum(c) || e(c) ? Sk.ffi.callsim(a.Unit, Sk.ffi.referenceToPy(f.div(Sk.ffi.remapToJs(c)), 'Unit')) : Sk.ffi.callsim(a.Measure, c, b);
        });
        h.__rdiv__ = Sk.ffi.functionPy(function (b, d) {
          Sk.ffi.checkLhsOperandType('multiply', c, Sk.ffi.isNum(d), d);
          var e = Sk.ffi.remapToJs(d), f = Sk.ffi.remapToJs(b);
          return Sk.ffi.callsim(a.Unit, Sk.ffi.referenceToPy(f.inverse().mul(e), 'Unit'));
        });
        h.__pow__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b), e = Sk.ffi.remapToJs(c), d = d.pow(e);
          return Sk.ffi.callsim(a.Unit, Sk.ffi.numberToFloatPy(d.scale), Sk.ffi.referenceToPy(d.dimensions, 'Dimensions'), Sk.ffi.remapToPy(d.labels));
        });
        h.__abs__ = Sk.ffi.functionPy(function (b) {
          b = Sk.ffi.remapToJs(b);
          return Sk.ffi.callsim(a.Unit, Sk.ffi.numberToFloatPy(Math.abs(b.scale)), Sk.ffi.referenceToPy(b.dimensions, 'Dimensions'), Sk.ffi.remapToPy(b.labels));
        });
        h.__magnitude__ = Sk.ffi.functionPy(function (b) {
          b = Sk.ffi.remapToJs(b);
          return Sk.ffi.callsim(a.Unit, Sk.ffi.numberToFloatPy(Math.abs(b.scale)), Sk.ffi.referenceToPy(b.dimensions, 'Dimensions'), Sk.ffi.remapToPy(b.labels));
        });
        h.__quadrance__ = Sk.ffi.functionPy(function (b) {
          b = Sk.ffi.remapToJs(b);
          return Sk.ffi.callsim(a.Unit, Sk.ffi.referenceToPy(b.pow(2), 'Unit'));
        });
        h.__sqrt__ = Sk.ffi.functionPy(function (b) {
          b = Sk.ffi.remapToJs(b);
          return Sk.ffi.callsim(a.Unit, Sk.ffi.referenceToPy(b.pow(0.5), 'Unit'));
        });
        h.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          for (var b = [
                [
                  -1,
                  1,
                  -3,
                  1,
                  2,
                  1,
                  2,
                  1,
                  0,
                  1,
                  0,
                  1,
                  0,
                  1,
                  'F/m'
                ],
                [
                  -1,
                  1,
                  -2,
                  1,
                  1,
                  1,
                  2,
                  1,
                  0,
                  1,
                  0,
                  1,
                  0,
                  1,
                  'S'
                ],
                [
                  -1,
                  1,
                  -2,
                  1,
                  2,
                  1,
                  2,
                  1,
                  0,
                  1,
                  0,
                  1,
                  0,
                  1,
                  'F'
                ],
                [
                  -1,
                  1,
                  3,
                  1,
                  -2,
                  1,
                  0,
                  1,
                  0,
                  1,
                  0,
                  1,
                  0,
                  1,
                  'N\xb7m ** 2/kg ** 2'
                ],
                [
                  0,
                  1,
                  0,
                  1,
                  -1,
                  1,
                  0,
                  1,
                  0,
                  1,
                  0,
                  1,
                  0,
                  1,
                  'Hz'
                ],
                [
                  0,
                  1,
                  0,
                  1,
                  -1,
                  1,
                  1,
                  1,
                  0,
                  1,
                  0,
                  1,
                  0,
                  1,
                  'A'
                ],
                [
                  0,
                  1,
                  1,
                  1,
                  -2,
                  1,
                  0,
                  1,
                  0,
                  1,
                  0,
                  1,
                  0,
                  1,
                  'm/s ** 2'
                ],
                [
                  0,
                  1,
                  1,
                  1,
                  -1,
                  1,
                  0,
                  1,
                  0,
                  1,
                  0,
                  1,
                  0,
                  1,
                  'm/s'
                ],
                [
                  1,
                  1,
                  1,
                  1,
                  -1,
                  1,
                  0,
                  1,
                  0,
                  1,
                  0,
                  1,
                  0,
                  1,
                  'kg\xb7m/s'
                ],
                [
                  1,
                  1,
                  -1,
                  1,
                  -2,
                  1,
                  0,
                  1,
                  0,
                  1,
                  0,
                  1,
                  0,
                  1,
                  'Pa'
                ],
                [
                  1,
                  1,
                  -1,
                  1,
                  -1,
                  1,
                  0,
                  1,
                  0,
                  1,
                  0,
                  1,
                  0,
                  1,
                  'Pa\xb7s'
                ],
                [
                  1,
                  1,
                  0,
                  1,
                  -3,
                  1,
                  0,
                  1,
                  0,
                  1,
                  0,
                  1,
                  0,
                  1,
                  'W/m ** 2'
                ],
                [
                  1,
                  1,
                  0,
                  1,
                  -2,
                  1,
                  0,
                  1,
                  0,
                  1,
                  0,
                  1,
                  0,
                  1,
                  'N/m'
                ],
                [
                  1,
                  1,
                  0,
                  1,
                  -1,
                  1,
                  -1,
                  1,
                  0,
                  1,
                  0,
                  1,
                  0,
                  1,
                  'T'
                ],
                [
                  1,
                  1,
                  1,
                  1,
                  -3,
                  1,
                  0,
                  1,
                  -1,
                  1,
                  0,
                  1,
                  0,
                  1,
                  'W/(m\xb7K)'
                ],
                [
                  1,
                  1,
                  1,
                  1,
                  -2,
                  1,
                  -1,
                  1,
                  0,
                  1,
                  0,
                  1,
                  0,
                  1,
                  'V/m'
                ],
                [
                  1,
                  1,
                  1,
                  1,
                  -2,
                  1,
                  0,
                  1,
                  0,
                  1,
                  0,
                  1,
                  0,
                  1,
                  'N'
                ],
                [
                  1,
                  1,
                  1,
                  1,
                  0,
                  1,
                  -2,
                  1,
                  0,
                  1,
                  0,
                  1,
                  0,
                  1,
                  'H/m'
                ],
                [
                  1,
                  1,
                  2,
                  1,
                  -2,
                  1,
                  0,
                  1,
                  -1,
                  1,
                  0,
                  1,
                  0,
                  1,
                  'J/K'
                ],
                [
                  0,
                  1,
                  2,
                  1,
                  -2,
                  1,
                  0,
                  1,
                  -1,
                  1,
                  0,
                  1,
                  0,
                  1,
                  'J/(kg\xb7K)'
                ],
                [
                  1,
                  1,
                  2,
                  1,
                  -2,
                  1,
                  0,
                  1,
                  -1,
                  1,
                  -1,
                  1,
                  0,
                  1,
                  'J/(mol\xb7K)'
                ],
                [
                  1,
                  1,
                  2,
                  1,
                  -2,
                  1,
                  0,
                  1,
                  0,
                  1,
                  -1,
                  1,
                  0,
                  1,
                  'J/mol'
                ],
                [
                  1,
                  1,
                  2,
                  1,
                  -2,
                  1,
                  0,
                  1,
                  0,
                  1,
                  0,
                  1,
                  0,
                  1,
                  'J'
                ],
                [
                  1,
                  1,
                  2,
                  1,
                  -1,
                  1,
                  0,
                  1,
                  0,
                  1,
                  0,
                  1,
                  0,
                  1,
                  'J\xb7s'
                ],
                [
                  1,
                  1,
                  2,
                  1,
                  -3,
                  1,
                  0,
                  1,
                  0,
                  1,
                  0,
                  1,
                  0,
                  1,
                  'W'
                ],
                [
                  1,
                  1,
                  2,
                  1,
                  -2,
                  1,
                  -1,
                  1,
                  0,
                  1,
                  0,
                  1,
                  0,
                  1,
                  'V'
                ],
                [
                  1,
                  1,
                  2,
                  1,
                  -1,
                  1,
                  -2,
                  1,
                  0,
                  1,
                  0,
                  1,
                  0,
                  1,
                  '\u03a9'
                ],
                [
                  1,
                  1,
                  2,
                  1,
                  0,
                  1,
                  -2,
                  1,
                  0,
                  1,
                  0,
                  1,
                  0,
                  1,
                  'H'
                ],
                [
                  1,
                  1,
                  2,
                  1,
                  -1,
                  1,
                  -1,
                  1,
                  0,
                  1,
                  0,
                  1,
                  0,
                  1,
                  'Wb'
                ]
              ], c = a.dimensions.M, d = a.dimensions.L, e = a.dimensions.T, f = a.dimensions.Q, g = a.dimensions.temperature, h = a.dimensions.amount, J = a.dimensions.intensity, F = 0, H = b.length; F < H; F++) {
            var z = b[F];
            if (c.numer === z[0] && c.denom === z[1] && d.numer === z[2] && d.denom === z[3] && e.numer === z[4] && e.denom === z[5] && f.numer === z[6] && f.denom === z[7] && g.numer === z[8] && g.denom === z[9] && h.numer === z[10] && h.denom === z[11] && J.numer === z[12] && J.denom === z[13])
              return 1 !== a.scale ? Sk.builtin.stringToPy(a.scale + ' * ' + z[14]) : Sk.builtin.stringToPy(z[14]);
          }
          return Sk.builtin.stringToPy('' + a);
        });
        h.__repr__ = Sk.ffi.functionPy(function (a) {
          var b = [{
                name: 'dimensions',
                kind: '__repr__'
              }].map(function (b) {
              return {
                value: Sk.ffi.gattr(a, b.name),
                prop: b
              };
            }).map(function (a) {
              return Sk.ffi.remapToJs(Sk.ffi.callsim(a.value[a.prop.kind], a.value));
            }), c = Sk.ffi.remapToJs(a), d = '' + c.scale, b = b[0], c = '[' + c.labels.map(function (a) {
              return '\'' + a + '\'';
            }).join(' , ') + ']';
          return Sk.builtin.stringToPy('Unit(' + [
            d,
            b,
            c
          ].join(' , ') + ')');
        });
      }, 'Unit', []);
      a.Measure = Sk.ffi.buildClass(a, function (b, h) {
        var l = function (b) {
            return function (c, e) {
              var g = Sk.ffi.remapToJs(c);
              if (d(e)) {
                var h = Sk.ffi.remapToJs(e);
                return Sk.ffi.callsim(a.Measure, b(g.qtyPy, h.qtyPy), Sk.ffh.mul(g.uomPy, h.uomPy));
              }
              if (f(e) && (h = b(g.qtyPy, e), 'undefined' !== typeof h))
                return Sk.ffi.callsim(a.Measure, h, g.uomPy);
            };
          }, k = function (b) {
            return function (c, d) {
              if (f(d)) {
                var e = b(d, Sk.ffi.gattr(c, 'quantity'));
                if ('undefined' !== typeof e)
                  return Sk.ffi.callsim(a.Measure, e, Sk.ffi.gattr(c, 'uom'));
              }
            };
          };
        h.__init__ = Sk.ffi.functionPy(function (b, c, d) {
          Sk.ffi.checkMethodArgs('Measure', arguments, 1, 2);
          if ('Measure' === Sk.ffi.typeName(c))
            Sk.ffi.referenceToPy(Sk.ffi.remapToJs(c), 'Measure', c.custom, b);
          else {
            var e = Sk.ffi.gattr(d, 'scale');
            if (1 === Sk.ffi.remapToJs(e)) {
              var f = {};
              f.qtyPy = c;
              f.uomPy = d;
            } else
              f = {}, f.qtyPy = Sk.ffh.mul(c, e), f.uomPy = Sk.ffi.callsim(a.Unit, Sk.ffi.numberToFloatPy(1), Sk.ffi.gattr(d, 'dimensions'), Sk.ffi.gattr(d, 'labels'), Sk.ffi.gattr(d, 'name'));
            Sk.ffi.referenceToPy(f, 'Measure', void 0, b);
          }
        });
        h.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var e = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'quantity':
            return e.qtyPy;
          case 'uom':
            return e.uomPy;
          case 'exp':
            return Sk.ffi.callableToPy(a, 'exp', function (b) {
              Sk.ffi.checkMethodArgs('exp', arguments, 0, 0);
              return Sk.ffi.callsim(a.Measure, Sk.ffi.callsim(Sk.ffi.gattr(e.qtyPy, 'exp')), e.uomPy);
            });
          case 'magnitude':
            return Sk.ffi.callableToPy(a, 'magnitude', function (b) {
              Sk.ffi.checkMethodArgs('magnitude', arguments, 0, 0);
              return Sk.ffi.callsim(a.Measure, Sk.ffi.callsim(Sk.ffi.gattr(e.qtyPy, 'magnitude')), e.uomPy);
            });
          case 'cross':
            return Sk.ffi.callableToPy(a, 'exp', function (b, c) {
              Sk.ffi.checkMethodArgs('cross', arguments, 1, 1);
              if (d(c)) {
                var f = Sk.ffi.remapToJs(c), g = Sk.ffi.callsim(Sk.ffi.gattr(e.qtyPy, 'cross'), f.qtyPy);
                return Sk.ffi.callsim(a.Measure, g, Sk.ffh.mul(e.uomPy, f.uomPy));
              }
              g = Sk.ffi.callsim(Sk.ffi.gattr(e.qtyPy, 'cross'), c);
              return Sk.ffi.callsim(a.Measure, g, e.uomPy);
            });
          case 'dot':
            return Sk.ffi.callableToPy(a, 'exp', function (b, c) {
              Sk.ffi.checkMethodArgs('dot', arguments, 1, 1);
              if (d(c)) {
                var f = Sk.ffi.remapToJs(c), g = Sk.ffi.callsim(Sk.ffi.gattr(e.qtyPy, 'dot'), f.qtyPy);
                return Sk.ffi.callsim(a.Measure, g, Sk.ffh.mul(e.uomPy, f.uomPy));
              }
              g = Sk.ffi.callsim(Sk.ffi.gattr(e.qtyPy, 'dot'), c);
              return Sk.ffi.callsim(a.Measure, g, e.uomPy);
            });
          }
        });
        h.__add__ = Sk.ffi.functionPy(function (b, c) {
          Sk.ffi.checkArgType('other', 'Measure', d(c), c);
          var e = Sk.ffi.remapToJs(b), f = Sk.ffi.remapToJs(c), g = Sk.ffh.add(e.qtyPy, f.qtyPy), e = Sk.ffi.callsim(Sk.ffi.gattr(e.uomPy, 'compatible'), f.uomPy);
          return Sk.ffi.callsim(a.Measure, g, e);
        });
        h.__sub__ = Sk.ffi.functionPy(function (b, c) {
          Sk.ffi.checkArgType('other', 'Measure', d(c), c);
          var e = Sk.ffi.remapToJs(b), f = Sk.ffi.remapToJs(c);
          return Sk.ffi.callsim(a.Measure, Sk.ffh.sub(e.qtyPy, f.qtyPy), Sk.ffi.callsim(Sk.ffi.gattr(e.uomPy, 'compatible'), f.uomPy));
        });
        h.__mod__ = Sk.ffi.functionPy(l(Sk.ffh.mod));
        h.__rmod__ = Sk.ffi.functionPy(k(Sk.ffh.mod));
        h.__mul__ = Sk.ffi.functionPy(l(Sk.ffh.mul));
        h.__rmul__ = Sk.ffi.functionPy(k(Sk.ffh.mul));
        h.__div__ = Sk.ffi.functionPy(function (b, c) {
          var f = Sk.ffi.remapToJs(b);
          if (d(c)) {
            var g = Sk.ffi.remapToJs(c);
            return Sk.ffi.callsim(a.Measure, Sk.ffh.div(f.qtyPy, g.qtyPy), Sk.ffh.div(f.uomPy, g.uomPy));
          }
          return e(c) ? Sk.ffi.callsim(a.Measure, f.qtyPy, Sk.ffh.div(f.uomPy, c)) : Sk.ffi.callsim(a.Measure, Sk.ffh.div(f.qtyPy, c), f.uomPy);
        });
        h.__rdiv__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          return Sk.ffi.callsim(a.Measure, Sk.ffh.div(c, d.qtyPy), Sk.ffh.div(Sk.ffi.numberToFloatPy(1), d.uomPy));
        });
        h.__xor__ = Sk.ffi.functionPy(l(Sk.ffh.xor));
        h.__rxor__ = Sk.ffi.functionPy(k(Sk.ffh.xor));
        h.__lshift__ = Sk.ffi.functionPy(l(Sk.ffh.lshift));
        h.__rlshift__ = Sk.ffi.functionPy(k(Sk.ffh.lshift));
        h.__rshift__ = Sk.ffi.functionPy(l(Sk.ffh.rshift));
        h.__rrshift__ = Sk.ffi.functionPy(k(Sk.ffh.rshift));
        h.__pow__ = Sk.ffi.functionPy(function (b, e) {
          var f = d(e);
          Sk.ffi.checkArgType('other', [
            'Measure',
            c
          ], Sk.ffi.isNum(e) || f, e);
          var g = Sk.ffi.remapToJs(b), h = Sk.ffi.remapToJs(e), k = Sk.ffh.pow(g.qtyPy, f ? h.qtyPy : e), f = Sk.ffh.pow(g.uomPy, f ? h.uomPy : e);
          return Sk.ffi.callsim(a.Measure, k, f);
        });
        h.__pos__ = Sk.ffi.functionPy(function (b) {
          var c = Sk.ffh.positive(Sk.ffi.gattr(b, 'quantity'));
          b = Sk.ffi.gattr(b, 'uom');
          return Sk.ffi.callsim(a.Measure, c, b);
        });
        h.__neg__ = Sk.ffi.functionPy(function (b) {
          var c = Sk.ffh.negative(Sk.ffi.gattr(b, 'quantity'));
          b = Sk.ffi.gattr(b, 'uom');
          return Sk.ffi.callsim(a.Measure, c, b);
        });
        h.__invert__ = Sk.ffi.functionPy(function (b) {
          var c = Sk.ffh.invert(Sk.ffi.gattr(b, 'quantity'));
          b = Sk.ffi.gattr(b, 'uom');
          return Sk.ffi.callsim(a.Measure, c, b);
        });
        h.__cos__ = Sk.ffi.functionPy(function (b) {
          var c = Sk.ffi.gattr(b, 'uom');
          if (!Sk.ffi.remapToJs(c).dimensions.dimensionless())
            throw new Sk.builtin.TypeError('Argument to cos function must be an angle.');
          b = Sk.ffh.cos(Sk.ffi.gattr(b, 'quantity'));
          return Sk.ffi.callsim(a.Measure, b, Sk.ffi.gattr(a.dimensionless, 'uom'));
        });
        h.__sin__ = Sk.ffi.functionPy(function (b) {
          var c = Sk.ffi.gattr(b, 'uom');
          if (!Sk.ffi.remapToJs(c).dimensions.dimensionless())
            throw new Sk.builtin.TypeError('Argument to sin function must be an angle.');
          b = Sk.ffh.sin(Sk.ffi.gattr(b, 'quantity'));
          return Sk.ffi.callsim(a.Measure, b, Sk.ffi.gattr(a.dimensionless, 'uom'));
        });
        h.__tan__ = Sk.ffi.functionPy(function (b) {
          var c = Sk.ffi.gattr(b, 'uom');
          if (!Sk.ffi.remapToJs(c).dimensions.dimensionless())
            throw new Sk.builtin.TypeError('Argument to tan function must be an angle.');
          b = Sk.ffh.tan(Sk.ffi.gattr(b, 'quantity'));
          return Sk.ffi.callsim(a.Measure, b, Sk.ffi.gattr(a.dimensionless, 'uom'));
        });
        h.__acos__ = Sk.ffi.functionPy(function (b) {
          var c = Sk.ffi.gattr(b, 'uom');
          Sk.ffi.remapToJs(c);
          b = Sk.ffh.acos(Sk.ffi.gattr(b, 'quantity'));
          return Sk.ffi.callsim(a.Measure, b, Sk.ffi.gattr(a.radian, 'uom'));
        });
        h.__asin__ = Sk.ffi.functionPy(function (b) {
          var c = Sk.ffi.gattr(b, 'uom');
          Sk.ffi.remapToJs(c);
          b = Sk.ffh.asin(Sk.ffi.gattr(b, 'quantity'));
          return Sk.ffi.callsim(a.Measure, b, Sk.ffi.gattr(a.radian, 'uom'));
        });
        h.__atan__ = Sk.ffi.functionPy(function (b) {
          var c = Sk.ffi.gattr(b, 'uom');
          Sk.ffi.remapToJs(c);
          b = Sk.ffh.atan(Sk.ffi.gattr(b, 'quantity'));
          return Sk.ffi.callsim(a.Measure, b, Sk.ffi.gattr(a.radian, 'uom'));
        });
        h.__exp__ = Sk.ffi.functionPy(function (b) {
          var c = Sk.ffh.exp(Sk.ffi.gattr(b, 'quantity'));
          b = Sk.ffi.gattr(b, 'uom');
          return Sk.ffi.callsim(a.Measure, c, b);
        });
        h.__abs__ = Sk.ffi.functionPy(function (b) {
          var c = Sk.ffh.abs(Sk.ffi.gattr(b, 'quantity'));
          b = Sk.ffh.abs(Sk.ffi.gattr(b, 'uom'));
          return Sk.ffi.callsim(a.Measure, c, b);
        });
        h.__magnitude__ = Sk.ffi.functionPy(function (b) {
          var c = Sk.ffh.magnitude(Sk.ffi.gattr(b, 'quantity'));
          b = Sk.ffh.magnitude(Sk.ffi.gattr(b, 'uom'));
          return Sk.ffi.callsim(a.Measure, c, b);
        });
        h.__quadrance__ = Sk.ffi.functionPy(function (b) {
          var c = Sk.ffh.quadrance(Sk.ffi.gattr(b, 'quantity'));
          b = Sk.ffh.quadrance(Sk.ffi.gattr(b, 'uom'));
          return Sk.ffi.callsim(a.Measure, c, b);
        });
        h.__sqrt__ = Sk.ffi.functionPy(function (b) {
          var c = Sk.ffh.sqrt(Sk.ffi.gattr(b, 'quantity'));
          b = Sk.ffh.sqrt(Sk.ffi.gattr(b, 'uom'));
          return Sk.ffi.callsim(a.Measure, c, b);
        });
        h.__str__ = Sk.ffi.functionPy(function (a) {
          var b = Sk.ffi.remapToJs(a);
          a = Sk.ffi.remapToJs(Sk.ffh.str(b.qtyPy));
          b = Sk.ffi.remapToJs(Sk.ffh.str(b.uomPy));
          return Sk.builtin.stringToPy(('' + a + ' ' + b).trim());
        });
        h.__repr__ = Sk.ffi.functionPy(function (a) {
          var b = Sk.ffi.remapToJs(a);
          a = Sk.ffi.remapToJs(Sk.ffh.repr(b.qtyPy));
          b = Sk.ffi.remapToJs(Sk.ffh.repr(b.uomPy));
          return Sk.builtin.stringToPy('Measure(' + a + ', ' + b + ')');
        });
      }, 'Measure', []);
      (function () {
        function c(b) {
          b = Sk.ffi.callsim(a.Unit, Sk.ffi.referenceToPy(b, 'Unit'));
          return Sk.ffi.callsim(a.Measure, d, b);
        }
        var d = Sk.ffi.numberToFloatPy(1);
        a.dimensionless = c(b.UNIT_DIMLESS);
        a.kilogram = c(b.UNIT_KILOGRAM);
        a.meter = c(b.UNIT_METER);
        a.second = c(b.UNIT_SECOND);
        a.ampere = c(b.UNIT_AMPERE);
        a.kelvin = c(b.UNIT_KELVIN);
        a.mole = c(b.UNIT_MOLE);
        a.candela = c(b.UNIT_CANDELA);
        a.coulomb = c(b.UNIT_COULOMB);
        a.gram = Sk.ffh.mul(a.milli, a.kilogram);
        a.cm = Sk.ffh.mul(a.centi, a.meter);
        a.newton = Sk.ffh.div(Sk.ffh.mul(a.kilogram, a.meter), Sk.ffh.mul(a.second, a.second));
        a.joule = Sk.ffh.mul(a.newton, a.meter);
        a.swirl = Sk.ffh.mul(a.joule, a.second);
        a.watt = Sk.ffh.div(a.joule, a.second);
        a.volt = Sk.ffh.div(a.joule, a.coulomb);
        a.tesla = Sk.ffh.div(a.swirl, Sk.ffh.mul(a.coulomb, Sk.ffh.mul(a.meter, a.meter)));
      }());
    };
  }.call(this));
  Sk.three = Sk.three || {};
  Sk.three.FACE_3 = 'Face3';
  Sk.three.MATERIAL = 'Material';
  Sk.three.MATRIX_3 = 'Matrix3';
  Sk.three.MATRIX_4 = 'Matrix4';
  Sk.three.MESH = 'Mesh';
  Sk.three.OBJECT_3D = 'Object3D';
  Sk.three.PARTICLE_SYSTEM = 'ParticleSystem';
  Sk.three.PARTICLE_SYSTEM_MATERIAL = 'ParticleSystemMaterial';
  Sk.three.ARROW_GEOMETRY = 'ArrowGeometry';
  Sk.three.VORTEX_GEOMETRY = 'VortexGeometry';
  Sk.three.cardinal = function (a, b, c) {
    function d(a) {
      return 'number' === typeof a ? a ? 0 > a ? -1 : 1 : isNaN(a) ? NaN : 0 : NaN;
    }
    var e = Math.abs(a), f = Math.abs(b), g = Math.abs(c);
    return e >= f ? e >= g ? new THREE.Vector3(d(a), 0, 0) : new THREE.Vector3(0, 0, d(c)) : f >= g ? new THREE.Vector3(0, d(b), 0) : new THREE.Vector3(0, 0, d(c));
  };
  goog.exportSymbol('Sk.three.cardinal', Sk.three.cardinal);
  Sk.three.vector3Cycle = function (a, b, c, d) {
    switch (d % 3) {
    case 0:
      return new THREE.Vector3(a, b, c);
    case 1:
      return new THREE.Vector3(c, a, b);
    case 2:
      return new THREE.Vector3(b, c, a);
    }
  };
  goog.exportSymbol('Sk.three.vector3Cycle', Sk.three.vector3Cycle);
  (function () {
    Sk.stdlib.defineThree = function (a, b) {
      function c(a) {
        return 'boolean' === typeof a;
      }
      function d(a) {
        return 'number' === typeof a;
      }
      function e(a) {
        return 'string' === typeof a;
      }
      function f(a) {
        return 'undefined' !== typeof a;
      }
      function g(a) {
        return Sk.ffi.isInstance(a, 'Euclidean3');
      }
      function h(b) {
        b = new THREE.Euclidean3(!1, new THREE.Vector3(0, 0, 0), b, 0);
        return Sk.ffi.callsim(a.Euclidean3, Sk.ffi.referenceToPy(b, 'Euclidean3'));
      }
      function l(a, b, c, d, e) {
        Sk.ffi.checkArgType('target', a, Sk.ffi.isInstance(b, a), b);
        e = e || c;
        Sk.ffi.checkArgType(e, 'Euclidean3', g(d), d);
        a = Sk.ffi.gattr(d, 'quaternion');
        Sk.ffi.checkArgType(e, 'Quaternion', Sk.ffi.isInstance(a, 'Quaternion'), a);
        b = Sk.ffi.remapToJs(b)[c];
        c = Sk.ffi.remapToJs(a);
        b.set(c.x, c.y, c.z, c.w);
      }
      function k(b) {
        b = new THREE.Euclidean3(!1, b, new THREE.Quaternion(0, 0, 0, 0), 0);
        return Sk.ffi.callsim(a.Euclidean3, Sk.ffi.referenceToPy(b, 'Euclidean3'));
      }
      function m(a, b) {
        if (f(b)) {
          Sk.ffi.checkArgType(a, 'Euclidean3', g(b), b);
          var c = Sk.ffi.gattr(b, 'vector');
          Sk.ffi.checkArgType(a, 'Vector3', Sk.ffi.isInstance(c, 'Vector3'), c);
          return Sk.ffi.remapToJs(c);
        }
      }
      function p(a, b, c, d) {
        a[b] = m(d || b, c);
      }
      function n(b) {
        if ('object' !== typeof b)
          throw Sk.ffi.assertionError('target must be an object.');
        if ('function' !== typeof b.add)
          throw Sk.ffi.assertionError('target must have an \'add\' function.');
        return Sk.ffi.callableToPy(a, 'add', function (a, c) {
          var d = Sk.ffi.remapToJs(c);
          b.add(d);
        });
      }
      function q(b) {
        return Sk.ffi.callableToPy(a, 'lookAt', function (a, c) {
          Sk.ffi.checkMethodArgs('lookAt', arguments, 1, 1);
          Sk.ffi.checkArgType('vector', 'Euclidean3', g(c), c);
          var d = Sk.ffi.gattr(c, 'vector');
          Sk.ffi.checkArgType('vector', 'Vector3', Sk.ffi.isInstance(d, 'Vector3'), d);
          Sk.ffi.remapToJs(b).lookAt(Sk.ffi.remapToJs(d));
          return b;
        });
      }
      function x(b) {
        if ('object' !== typeof b)
          throw Sk.ffi.assertionError('target must be an object.');
        if ('function' !== typeof b.remove)
          throw Sk.ffi.assertionError('target must have a \'remove\' function.');
        return Sk.ffi.callableToPy(a, 'add', function (a, c) {
          var d = Sk.ffi.remapToJs(c);
          b.remove(d);
        });
      }
      function D(b) {
        return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (c, d) {
          d.__init__ = Sk.ffi.functionPy(function (c) {
            var d = {};
            d.append = Sk.ffi.callableToPy(a, 'append', function (a, c) {
              b.push(m('vector', c));
            });
            Sk.ffi.referenceToPy(b, 'vertices', d, c);
          });
          d.__getattr__ = Sk.ffi.functionPy(function (a, b) {
            Sk.ffi.remapToJs(a);
            switch (b) {
            case 'append':
              return a.custom.append;
            }
          });
          d.__getitem__ = Sk.ffi.functionPy(function (a, c) {
            var d = Sk.ffi.remapToJs(c);
            return k(b[d]);
          });
          d.mp$length = function () {
            return b.length;
          };
          d.__str__ = Sk.ffi.functionPy(function (a) {
            return Sk.ffh.str(Sk.ffi.listPy(b.map(function (a) {
              return k(a);
            })));
          });
          d.__repr__ = Sk.ffi.functionPy(function (a) {
            return Sk.builtin.stringToPy('vertices');
          });
        }, 'vertices', []));
      }
      function J(b) {
        return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (c, d) {
          d.__init__ = Sk.ffi.functionPy(function (a) {
            Sk.ffi.referenceToPy(b, 'faces', void 0, a);
          });
          d.__getattr__ = Sk.ffi.functionPy(function (c, d) {
            switch (d) {
            case 'append':
              return Sk.ffi.callableToPy(a, 'append', function (a, c) {
                b.push(Sk.ffi.remapToJs(c));
              });
            }
          });
          d.__getitem__ = Sk.ffi.functionPy(function (a, c) {
            var d = Sk.ffi.remapToJs(c);
            return F(b[d]);
          });
          d.mp$length = function () {
            return b.length;
          };
          d.__str__ = Sk.ffi.functionPy(function (a) {
            return Sk.ffh.str(Sk.ffi.listPy(b.map(function (a) {
              return F(a);
            })));
          });
          d.__repr__ = Sk.ffi.functionPy(function (a) {
            return Sk.builtin.stringToPy('faces');
          });
        }, 'faces', []));
      }
      function F(b) {
        return Sk.ffi.callsim(a[Sk.three.FACE_3], Sk.ffi.referenceToPy(b, Sk.three.FACE_3));
      }
      function H(b) {
        return Sk.ffi.callsim(a.Color, Sk.ffi.referenceToPy(b, 'Color'));
      }
      function z(b) {
        return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (c, d) {
          d.__init__ = Sk.ffi.functionPy(function (a) {
            Sk.ffi.referenceToPy(b, 'colors', void 0, a);
          });
          d.__getattr__ = Sk.ffi.functionPy(function (c, d) {
            switch (d) {
            case 'append':
              return Sk.ffi.callableToPy(a, 'append', function (a, c) {
                b.push(Sk.ffi.remapToJs(c));
              });
            }
          });
          d.__getitem__ = Sk.ffi.functionPy(function (a, c) {
            var d = Sk.ffi.remapToJs(c);
            return H(b[d]);
          });
          d.mp$length = function () {
            return b.length;
          };
          d.__str__ = Sk.ffi.functionPy(function (a) {
            return Sk.ffh.str(Sk.ffi.listPy(b.map(function (a) {
              return H(a);
            })));
          });
          d.__repr__ = Sk.ffi.functionPy(function (a) {
            return Sk.builtin.stringToPy('colors');
          });
        }, 'vertices', []));
      }
      function G(b, c, d) {
        var e = Sk.ffi.remapToJs(b);
        switch (c) {
        case 'aspect':
          return Sk.ffi.numberToFloatPy(e.aspect);
        case 'position':
          return k(e.position);
        case 'quaternion':
          return Sk.ffi.callsim(a.Quaternion, Sk.ffi.referenceToPy(e.quaternion, 'Quaternion'));
        case 'rotation':
          return k(e.rotation);
        case 'eulerOrder':
          return Sk.builtin.stringToPy(e.eulerOrder);
        case 'scale':
          return k(e.scale);
        case 'up':
          return k(e.up);
        case 'useQuaternion':
          return e.useQuaternion;
        case 'lookAt':
          return q(b);
        case 'updateProjectionMatrix':
          return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
            b.__init__ = Sk.ffi.functionPy(function (a) {
              a.tp$name = 'updateProjectionMatrix';
            });
            b.__call__ = Sk.ffi.functionPy(function (a) {
              e[c]();
            });
            b.__str__ = Sk.ffi.functionPy(function (a) {
              return Sk.builtin.stringToPy('updateProjectionMatrix');
            });
            b.__repr__ = Sk.ffi.functionPy(function (a) {
              return Sk.builtin.stringToPy('updateProjectionMatrix');
            });
          }, 'updateProjectionMatrix', []));
        default:
          throw Sk.ffi.err.attribute(c).isNotSetableOnType(d);
        }
      }
      function E(a, b, c, d) {
        a = Sk.ffi.remapToJs(a);
        var f = Sk.ffi.remapToJs(c);
        switch (b) {
        case 'position':
        case 'rotation':
        case 'scale':
        case 'up':
          p(a, b, c);
          break;
        case 'quaternion':
          a.quaternion = f;
          break;
        case 'eulerOrder':
          if (e(f))
            a.eulerOrder = f;
          else
            throw Error(b + ' must be a string');
          break;
        case 'useQuaternion':
          a.useQuaternion = f;
          break;
        default:
          throw Sk.ffi.err.attribute(b).isNotSetableOnType(d);
        }
      }
      function C(b, c, d) {
        var e = Sk.ffi.remapToJs(c);
        switch (d) {
        case 'id':
          return Sk.ffi.numberToIntPy(e.id);
        case 'name':
          return Sk.builtin.stringToPy(e.name);
        case 'uuid':
          return Sk.builtin.stringToPy(e.uuid);
        case 'faces':
          return J(e.faces);
        case 'colors':
          return z(e.colors);
        case 'vertices':
          return D(e.vertices);
        case 'radius':
          return Sk.ffi.numberToFloatPy(e.radius);
        case 'width':
          return Sk.ffi.numberToFloatPy(e.width);
        case 'depth':
        case 'height':
          return Sk.ffi.numberToFloatPy(e.height);
        case 'applyMatrix':
          return Sk.ffi.callableToPy(a, d, function (a, b) {
            Sk.ffi.checkMethodArgs(d, arguments, 1, 1);
            Sk.ffi.checkArgType('matrix', Sk.three.MATRIX_4, Sk.ffi.isInstance(b, Sk.three.MATRIX_4), b);
            e.applyMatrix(Sk.ffi.remapToJs(b));
          });
        case 'computeFaceNormals':
          return Sk.ffi.callableToPy(a, d, function (a) {
            Sk.ffi.checkMethodArgs(d, arguments, 0, 0);
            e.computeFaceNormals();
          });
        default:
          throw Sk.ffi.err.attribute(d).isNotGetableOnType(b);
        }
      }
      function A(a, b, c, d) {
        b = Sk.ffi.remapToJs(b);
        switch (c) {
        case 'name':
          Sk.ffi.checkArgType('name', Sk.ffi.PyType.STR, Sk.builtin.isStringPy(d), d);
          b.name = Sk.builtin.stringToJs(d);
          break;
        default:
          throw Sk.ffi.err.attribute(c).isNotSetableOnType(a);
        }
      }
      function u(b, c, d) {
        var e = Sk.ffi.remapToJs(c);
        switch (d) {
        case 'color':
          return Sk.ffi.callsim(a.Color, Sk.ffi.referenceToPy(e.color, 'Color'));
        default:
          return Sk.three.object3DGetAttr(b, c, d);
        }
      }
      function t(a, b, c, d) {
        var e = Sk.ffi.remapToJs(b), f = Sk.ffi.remapToJs(d);
        switch (c) {
        case 'color':
          e.color = new THREE.Color(f);
          break;
        default:
          return Sk.three.object3DSetAttr(a, b, c, d);
        }
      }
      function y(b, c, d) {
        c = Sk.ffi.remapToJs(c);
        switch (d) {
        case 'emissive':
        case 'color':
          return Sk.ffi.callsim(a.Color, Sk.ffi.referenceToPy(c[d], 'Color'));
        case 'id':
          return Sk.ffi.numberToIntPy(c.id);
        case 'opacity':
        case 'overdraw':
          return Sk.ffi.numberToFloatPy(c.opacity);
        case 'name':
        case 'uuid':
          return Sk.builtin.stringToPy(c[d]);
        case 'needsUpdate':
        case 'transparent':
        case 'visible':
          return Sk.ffi.booleanToPy(c[d]);
        default:
          throw Sk.ffi.err.attribute(d).isNotGetableOnType(b);
        }
      }
      function v(a, b, c, d) {
        b = Sk.ffi.remapToJs(b);
        switch (c) {
        case 'name':
          Sk.ffi.checkArgType(c, Sk.ffi.PyType.STR, Sk.builtin.isStringPy(d), d);
          b[c] = Sk.builtin.stringToJs(d);
          break;
        case 'overdraw':
          Sk.ffi.checkArgType(c, Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(d), d);
          b[c] = Sk.ffi.remapToJs(d);
          break;
        case 'needsUpdate':
        case 'transparent':
        case 'visible':
          Sk.ffi.checkArgType(c, Sk.ffi.PyType.BOOL, Sk.ffi.isBool(d), d);
          b[c] = Sk.ffi.remapToJs(d);
          break;
        default:
          throw Sk.ffi.err.attribute(c).isNotSetableOnType(a);
        }
      }
      Sk.ffi.checkFunctionArgs('defineThree', arguments, 2, 2);
      Sk.builtin.defineNode(a);
      var s = Sk.ffi.PyType.INT, r = [
          Sk.ffi.PyType.FLOAT,
          Sk.ffi.PyType.INT,
          Sk.ffi.PyType.LONG
        ];
      Sk.stdlib.CylinderGeometry = function (a, b, c, d, e, f, g) {
        THREE.Geometry.call(this);
        this.radiusTop = a = void 0 !== a ? a : 20;
        this.radiusBottom = b = void 0 !== b ? b : 20;
        this.height = c = void 0 !== c ? c : 100;
        this.radialSegments = d = d || 8;
        this.heightSegments = e = e || 1;
        this.openEnded = f = void 0 !== f ? f : !1;
        var h = c / 2, k = Sk.stdlib.direction(g.x, g.y, g.z);
        Sk.stdlib.orientation(g.x, g.y, g.z);
        var l, m = [], n = [];
        for (l = 0; l <= e; l++) {
          var p = [], q = [], r = l / e, s = -r * c + h, t = r * (b - a) + a;
          for (g = 0; g < d; g++) {
            var u = g / d, x = 2 * u * Math.PI, x = Sk.three.vector3Cycle(s, t * Math.cos(x), t * Math.sin(x), k);
            this.vertices.push(x);
            p.push(this.vertices.length - 1);
            q.push(new THREE.Vector2(u, 1 - r));
          }
          m.push(p);
          n.push(q);
        }
        c = (b - a) / c;
        for (g = 0; g < d; g++)
          for (r = (g + 0) % d, s = (g + 1) % d, 0 !== a ? (p = this.vertices[m[0][r]].clone(), q = this.vertices[m[0][s]].clone()) : (p = this.vertices[m[1][r]].clone(), q = this.vertices[m[1][s]].clone()), l = p.getComponent((k + 2) % 3), t = p.getComponent((k + 1) % 3), p.setComponent((k + 0) % 3, Math.sqrt(l * l + t * t) * c), p.normalize(), l = q.getComponent((k + 2) % 3), t = q.getComponent((k + 1) % 3), q.setComponent((k + 0) % 3, Math.sqrt(l * l + t * t) * c), q.normalize(), l = 0; l < e; l++) {
            var t = m[l][r], u = m[l + 1][r], x = m[l + 1][s], y = m[l][s], v = p.clone(), w = p.clone(), z = q.clone(), B = q.clone(), A = n[l][r].clone(), D = n[l + 1][r].clone(), C = n[l + 1][s].clone(), E = n[l][s].clone();
            this.faces.push(new THREE.Face3(t, u, y, [
              v,
              w,
              B
            ]));
            this.faceVertexUvs[0].push([
              A,
              D,
              E
            ]);
            this.faces.push(new THREE.Face3(u, x, y, [
              w,
              z,
              B
            ]));
            this.faceVertexUvs[0].push([
              D,
              C,
              E
            ]);
          }
        if (!1 === f && 0 < a)
          for (this.vertices.push(Sk.three.vector3Cycle(+h, 0, 0, k)), g = 0; g < d; g++)
            r = (g + 0) % d, s = (g + 1) % d, t = m[0][r], u = m[0][s], x = this.vertices.length - 1, v = Sk.three.vector3Cycle(1, 0, 0, k), w = Sk.three.vector3Cycle(1, 0, 0, k), z = Sk.three.vector3Cycle(1, 0, 0, k), A = n[0][r].clone(), D = n[0][s].clone(), C = new THREE.Vector2(D.u, 0), this.faces.push(new THREE.Face3(t, u, x, [
              v,
              w,
              z
            ])), this.faceVertexUvs[0].push([
              A,
              D,
              C
            ]);
        if (!1 === f && 0 < b)
          for (this.vertices.push(Sk.three.vector3Cycle(-h, 0, 0, k)), g = 0; g < d; g++)
            r = (g + 0) % d, s = (g + 1) % d, t = m[e][s], u = m[e][r], x = this.vertices.length - 1, v = Sk.three.vector3Cycle(-1, 0, 0, k), w = Sk.three.vector3Cycle(-1, 0, 0, k), z = Sk.three.vector3Cycle(-1, 0, 0, k), A = n[e][s].clone(), D = n[e][r].clone(), C = new THREE.Vector2(D.u, 1), this.faces.push(new THREE.Face3(t, u, x, [
              v,
              w,
              z
            ])), this.faceVertexUvs[0].push([
              A,
              D,
              C
            ]);
        this.computeFaceNormals();
      };
      Sk.stdlib.CylinderGeometry.prototype = Object.create(THREE.Geometry.prototype);
      Sk.stdlib.PlaneGeometry = function (a, b, c, d) {
        THREE.Geometry.call(this);
        this.width = a;
        this.height = b;
        this.widthSegments = c || 1;
        this.heightSegments = d || 1;
        var e = a / 2, f = b / 2;
        c = this.widthSegments;
        d = this.heightSegments;
        var g = c + 1, h = d + 1, k = this.width / c, l = this.height / d, m = new THREE.Vector3(0, 0, 1);
        for (a = 0; a < h; a++)
          for (b = 0; b < g; b++)
            this.vertices.push(new THREE.Vector3(b * k - e, -(a * l - f), 0));
        for (a = 0; a < d; a++)
          for (b = 0; b < c; b++) {
            var n = b + g * a, e = b + g * (a + 1), f = b + 1 + g * (a + 1), h = b + 1 + g * a, k = new THREE.Vector2(b / c, 1 - a / d), l = new THREE.Vector2(b / c, 1 - (a + 1) / d), p = new THREE.Vector2((b + 1) / c, 1 - (a + 1) / d), q = new THREE.Vector2((b + 1) / c, 1 - a / d), n = new THREE.Face3(n, e, h);
            n.normal.copy(m);
            n.vertexNormals.push(m.clone(), m.clone(), m.clone());
            this.faces.push(n);
            this.faceVertexUvs[0].push([
              k,
              l,
              q
            ]);
            n = new THREE.Face3(e, f, h);
            n.normal.copy(m);
            n.vertexNormals.push(m.clone(), m.clone(), m.clone());
            this.faces.push(n);
            this.faceVertexUvs[0].push([
              l.clone(),
              p,
              q.clone()
            ]);
          }
      };
      Sk.stdlib.PlaneGeometry.prototype = Object.create(THREE.Geometry.prototype);
      Sk.three.RevolutionGeometry = function (a, b, c, d, e, f) {
        THREE.Geometry.call(this);
        c = c || 12;
        d = d || 0;
        e = e || 2 * Math.PI;
        var g = 0.0001 > Math.abs(2 * Math.PI - Math.abs(e - d)) ? c : c + 1, h = 1 / c, k = (e - d) * h;
        e = 0;
        for (var l = g; e < l; e++)
          for (var m = (d + e * k) / 2, n = Math.cos(m), m = Math.sin(m), p = new THREE.Quaternion(b.x * m, b.y * m, b.z * m, n), n = 0, m = a.length; n < m; n++) {
            var q = a[n], q = new THREE.Vector3(q.x, q.y, q.z);
            q.applyQuaternion(p);
            f && q.applyQuaternion(f);
            this.vertices.push(q);
          }
        b = 1 / (a.length - 1);
        d = a.length;
        g *= d;
        e = 0;
        for (l = c; e < l; e++)
          for (n = 0, m = a.length - 1; n < m; n++) {
            c = n + d * e;
            f = (c + d) % g;
            var k = (c + 1 + d) % g, p = (c + 1) % g, q = e * h, r = n * b, s = q + h, t = r + b;
            this.faces.push(new THREE.Face3(p, f, c % g));
            this.faceVertexUvs[0].push([
              new THREE.Vector2(q, r),
              new THREE.Vector2(s, r),
              new THREE.Vector2(q, t)
            ]);
            this.faces.push(new THREE.Face3(p, k, f));
            this.faceVertexUvs[0].push([
              new THREE.Vector2(s, r),
              new THREE.Vector2(s, t),
              new THREE.Vector2(q, t)
            ]);
          }
        this.computeFaceNormals();
        this.computeVertexNormals();
      };
      Sk.three.RevolutionGeometry.prototype = Object.create(THREE.Geometry.prototype);
      Sk.three.ArrowGeometry = function (a, b, c, d, e, f, g, h) {
        a = a || 1;
        b = b || new THREE.Quaternion(0, 0, 0, 1);
        d = (d || 1) * a;
        e = (e || 0.01) * a;
        f = (f || 0.08) * a;
        g = (g || 0.2) * a;
        h = h || new THREE.Vector3(0, 0, 1);
        var k = d - g, l = d / 2;
        a = function (a) {
          var b;
          b = a.x ? 2 : a.y ? 1 : 0;
          var c = 0 < a.x ? 1 : 0 > a.x ? -1 : 0 < a.y ? 1 : 0 > a.y ? -1 : 0 < a.z ? 1 : 0 > a.z ? -1 : 0, d = (b + 0) % 3, g = (b + 1) % 3, h = (b + 2) % 3;
          b = [
            [
              0,
              0,
              l * c
            ],
            [
              f,
              0,
              (k - l) * c
            ],
            [
              e,
              0,
              (k - l) * c
            ],
            [
              e,
              0,
              -l * c
            ],
            [
              0,
              0,
              -l * c
            ]
          ].map(function (a) {
            return new THREE.Vector3(a[d], a[g], a[h]);
          });
          a = new THREE.Quaternion(a.x, a.y, a.z, 0);
          return {
            points: b,
            generator: a
          };
        }(h);
        Sk.three.RevolutionGeometry.call(this, a.points, a.generator, c, 0, 2 * Math.PI, b);
      };
      Sk.three.ArrowGeometry.prototype = Object.create(Sk.three.RevolutionGeometry.prototype);
      Sk.stdlib.TorusGeometry = function (a, b, c, d, e) {
        THREE.Geometry.call(this);
        this.radius = a || 100;
        this.tube = b || 40;
        this.radialSegments = c || 8;
        this.tubularSegments = d || 6;
        this.arc = e || 2 * Math.PI;
        e = new THREE.Vector3();
        a = [];
        b = [];
        for (c = 0; c <= this.radialSegments; c++)
          for (d = 0; d <= this.tubularSegments; d++) {
            var f = d / this.tubularSegments * this.arc, g = 2 * c / this.radialSegments * Math.PI;
            e.x = this.radius * Math.cos(f);
            e.y = this.radius * Math.sin(f);
            var h = new THREE.Vector3();
            h.x = (this.radius + this.tube * Math.cos(g)) * Math.cos(f);
            h.y = (this.radius + this.tube * Math.cos(g)) * Math.sin(f);
            h.z = this.tube * Math.sin(g);
            this.vertices.push(h);
            a.push(new THREE.Vector2(d / this.tubularSegments, c / this.radialSegments));
            b.push(h.clone().sub(e).normalize());
          }
        for (c = 1; c <= this.radialSegments; c++)
          for (d = 1; d <= this.tubularSegments; d++) {
            e = (this.tubularSegments + 1) * c + d - 1;
            var f = (this.tubularSegments + 1) * (c - 1) + d - 1, g = (this.tubularSegments + 1) * (c - 1) + d, h = (this.tubularSegments + 1) * c + d, k = new THREE.Face3(e, f, h, [
                b[e],
                b[f],
                b[h]
              ]);
            k.normal.add(b[e]);
            k.normal.add(b[f]);
            k.normal.add(b[h]);
            k.normal.normalize();
            this.faces.push(k);
            this.faceVertexUvs[0].push([
              a[e].clone(),
              a[f].clone(),
              a[h].clone()
            ]);
            k = new THREE.Face3(f, g, h, [
              b[f],
              b[g],
              b[h]
            ]);
            k.normal.add(b[f]);
            k.normal.add(b[g]);
            k.normal.add(b[h]);
            k.normal.normalize();
            this.faces.push(k);
            this.faceVertexUvs[0].push([
              a[f].clone(),
              a[g].clone(),
              a[h].clone()
            ]);
          }
      };
      Sk.stdlib.TorusGeometry.prototype = Object.create(THREE.Geometry.prototype);
      Sk.three.VortexGeometry = function (a, b, c, d, e, f, g) {
        function h(a, b) {
          var c = b % k;
          return c === k - 1 ? h(a, b - 1) : n * ((b - c) / k + c * p);
        }
        THREE.Geometry.call(this);
        var k = 9;
        this.radius = a || 1;
        this.radiusCone = b || 0.08;
        this.radiusShaft = c || 0.01;
        this.lengthCone = d || 0.2;
        this.lengthShaft = e || 0.8;
        f = f || 6;
        this.circleSegments = f * k;
        this.radialSegments = g || 8;
        g = 2 * Math.PI;
        var l = this.radius, m = new THREE.Vector3();
        a = [];
        d = [];
        var n = g / f, p = this.lengthShaft / (this.lengthCone + this.lengthShaft) / (k - 2);
        for (f = 0; f <= this.radialSegments; f++) {
          e = g * f / this.radialSegments;
          var q = Math.cos(e), r = Math.sin(e);
          for (e = 0; e <= this.circleSegments; e++) {
            var s = h(this.circleSegments, e), t = Math.cos(s), s = Math.sin(s);
            m.x = l * t;
            m.y = l * s;
            var u = new THREE.Vector3(), x = e % k === k - 1 ? b : c;
            u.x = (l + x * q) * t;
            u.y = (l + x * q) * s;
            u.z = x * r;
            this.vertices.push(u);
            a.push(new THREE.Vector2(e / this.circleSegments, f / this.radialSegments));
            d.push(u.clone().sub(m).normalize());
          }
        }
        for (f = 1; f <= this.radialSegments; f++)
          for (e = 1; e <= this.circleSegments; e++)
            b = (this.circleSegments + 1) * f + e - 1, c = (this.circleSegments + 1) * (f - 1) + e - 1, g = (this.circleSegments + 1) * (f - 1) + e, l = (this.circleSegments + 1) * f + e, m = new THREE.Face3(b, c, l, [
              d[b],
              d[c],
              d[l]
            ]), m.normal.add(d[b]), m.normal.add(d[c]), m.normal.add(d[l]), m.normal.normalize(), this.faces.push(m), this.faceVertexUvs[0].push([
              a[b].clone(),
              a[c].clone(),
              a[l].clone()
            ]), m = new THREE.Face3(c, g, l, [
              d[c],
              d[g],
              d[l]
            ]), m.normal.add(d[c]), m.normal.add(d[g]), m.normal.add(d[l]), m.normal.normalize(), this.faces.push(m), this.faceVertexUvs[0].push([
              a[c].clone(),
              a[g].clone(),
              a[l].clone()
            ]);
      };
      Sk.three.VortexGeometry.prototype = Object.create(THREE.Geometry.prototype);
      var B = function (a) {
          return Sk.ffi.isInstance(a) && 'Geometry' == Sk.ffi.typeName(a).match('Geometry$') ? !0 : Sk.ffi.isObjectPy(a) ? !0 : !1;
        }, w = function (a) {
          return Sk.ffi.isInstance(a) && Sk.ffi.typeName(a).match(Sk.three.MATERIAL + '$') == Sk.three.MATERIAL ? !0 : Sk.ffi.isObjectPy(a) ? !0 : !1;
        };
      Sk.builtin.defineEuclidean3(a, THREE, b);
      a.Scene = Sk.ffi.buildClass(a, function (b, c) {
        c.__init__ = Sk.ffi.functionPy(function (a, b) {
          Sk.ffi.isUndefined(b) ? (Sk.ffi.checkMethodArgs('Scene', arguments, 0, 0), Sk.ffi.referenceToPy(new THREE.Scene(), 'Scene', void 0, a)) : Sk.ffi.isInstance(b, 'Scene') ? Sk.ffi.referenceToPy(Sk.ffi.remapToJs(b), 'Scene', void 0, a) : Sk.ffi.checkMethodArgs('Scene', arguments, 0, 0);
        });
        c.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'children':
            return Sk.ffi.listPy(d.children.map(function (b) {
              return Sk.ffi.callsim(a[Sk.three.OBJECT_3D], Sk.ffi.referenceToPy(b, Sk.three.OBJECT_3D));
            }));
          case 'position':
            return k(d.position);
          case 'quaternion':
            return Sk.ffi.callsim(a.Quaternion, Sk.ffi.referenceToPy(d.quaternion, 'Quaternion'));
          case 'rotation':
            return k(d.rotation);
          case 'eulerOrder':
            return Sk.builtin.stringToPy(d.eulerOrder);
          case 'scale':
            return k(d.scale);
          case 'up':
            return k(d.up);
          case 'useQuaternion':
            return d.useQuaternion;
          case 'lookAt':
            return q(b);
          case 'add':
            return n(d);
          case 'remove':
            return x(d);
          }
        });
        c.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          a = Sk.ffi.remapToJs(a);
          var d = Sk.ffi.remapToJs(c);
          switch (b) {
          case 'position':
          case 'rotation':
          case 'scale':
          case 'up':
            p(a, b, c);
            break;
          case 'quaternion':
            a.quaternion = d;
            break;
          case 'eulerOrder':
            if (e(d))
              a.eulerOrder = d;
            else
              throw Error(b + ' must be a string');
            break;
          case 'useQuaternion':
            a.useQuaternion = d;
            break;
          default:
            throw Error(b + ' is not a write attribute of Scene');
          }
        });
        c.__str__ = Sk.ffi.functionPy(function (a) {
          return Sk.builtin.stringToPy('Scene');
        });
      }, 'Scene', []);
      a.CanvasRenderer = Sk.ffi.buildClass(a, function (b, d) {
        d.__init__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(b);
          Sk.ffi.referenceToPy(new THREE.CanvasRenderer(c), 'CanvasRenderer', void 0, a);
        });
        d.setSize = Sk.ffi.functionPy(function (a, b, c) {
          a.v.setSize(Sk.ffi.remapToJs(b), Sk.ffi.remapToJs(c));
        });
        d.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'autoClear':
            return d.autoClear;
          case 'gammaInput':
            return d.gammaInput;
          case 'gammaOutput':
            return d.gammaOutput;
          case 'sortObjects':
            return d.sortObjects;
          case 'canvas':
          case 'domElement':
            return Sk.ffi.callsim(a.Node, Sk.ffi.referenceToPy(d.domElement, 'Node'));
          case 'render':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
              b.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'render';
              });
              b.__call__ = Sk.ffi.functionPy(function (a, b, c) {
                b = Sk.ffi.remapToJs(b);
                c = Sk.ffi.remapToJs(c);
                d.render(b, c);
              });
              b.__str__ = Sk.ffi.functionPy(function (a) {
                return Sk.builtin.stringToPy('render');
              });
              b.__repr__ = Sk.ffi.functionPy(function (a) {
                return Sk.builtin.stringToPy('render');
              });
            }, 'render', []));
          case 'getClearColor':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (b, c) {
              c.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'getClearColor';
              });
              c.__call__ = Sk.ffi.functionPy(function (b) {
                return Sk.ffi.callsim(a.Color, Sk.ffi.referenceToPy(d.getClearColor(), 'Color'));
              });
              c.__str__ = Sk.ffi.functionPy(function (a) {
                return Sk.builtin.stringToPy('getClearColor');
              });
              c.__repr__ = Sk.ffi.functionPy(function (a) {
                return Sk.builtin.stringToPy('getClearColor');
              });
            }, 'getClearColor', []));
          case 'setClearColor':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
              b.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'setClearColor';
              });
              b.__call__ = Sk.ffi.functionPy(function (a, b, c) {
                b = Sk.ffi.remapToJs(b);
                c = Sk.ffi.remapToJs(c);
                d.setClearColor(b, c);
              });
              b.__str__ = Sk.ffi.functionPy(function (a) {
                return Sk.builtin.stringToPy('setClearColor');
              });
              b.__repr__ = Sk.ffi.functionPy(function (a) {
                return Sk.builtin.stringToPy('setClearColor');
              });
            }, 'setClearColor', []));
          case 'setSize':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
              b.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'setSize';
              });
              b.__call__ = Sk.ffi.functionPy(function (a, b, c, e) {
                b = Sk.ffi.remapToJs(b);
                c = Sk.ffi.remapToJs(c);
                e = Sk.ffi.remapToJs(e);
                d.setSize(b, c, e);
              });
              b.__str__ = Sk.ffi.functionPy(function (a) {
                return Sk.builtin.stringToPy('setSize');
              });
              b.__repr__ = Sk.ffi.functionPy(function (a) {
                return Sk.builtin.stringToPy('setSize');
              });
            }, 'setSize', []));
          default:
            throw Sk.ffi.err.attribute(c).isNotGetableOnType('CanvasRenderer');
          }
        });
        d.__setattr__ = Sk.ffi.functionPy(function (a, b, d) {
          a = Sk.ffi.remapToJs(a);
          d = Sk.ffi.remapToJs(d);
          switch (b) {
          case 'autoClear':
            if (c(d))
              a.autoClear = d;
            else
              throw new Sk.builtin.TypeError('\'autoClear\' attribute must be a <type \'bool\'>.');
            break;
          case 'gammaInput':
            if (c(d))
              a.gammaInput = d;
            else
              throw new Sk.builtin.TypeError('\'gammaInput\' attribute must be a <type \'bool\'>.');
            break;
          case 'gammaOutput':
            if (c(d))
              a.gammaOutput = d;
            else
              throw new Sk.builtin.TypeError('\'gammaOutput\' attribute must be a <type \'bool\'>.');
            break;
          case 'sortObjects':
            if (c(d))
              a.sortObjects = d;
            else
              throw new Sk.builtin.TypeError('\'sortObjects\' attribute must be a <type \'bool\'>.');
            break;
          case 'size':
            b = Sk.ffi.remapToJs(d[0]);
            d = Sk.ffi.remapToJs(d[1]);
            a.setSize(b, d);
            break;
          default:
            throw Sk.ffi.err.attribute(b).isNotSetableOnType('CanvasRenderer');
          }
        });
        d.__str__ = Sk.ffi.functionPy(function (a) {
          a = a.v;
          var b = {};
          b.autoClear = a.autoClear;
          b.gammaInput = a.gammaInput;
          b.gammaOutput = a.gammaOutput;
          return Sk.builtin.stringToPy('CanvasRenderer(' + JSON.stringify(b) + ')');
        });
        d.__repr__ = Sk.ffi.functionPy(function (a) {
          return Sk.builtin.stringToPy('CanvasRenderer(' + [{ autoClear: a.v.autoClear }].map(function (a) {
            return JSON.stringify(a);
          }).join(', ') + ')');
        });
      }, 'CanvasRenderer', []);
      a.WebGLRenderer = Sk.ffi.buildClass(a, function (b, d) {
        d.__init__ = Sk.ffi.functionPy(function (a, b) {
          0 < Sk.ffi.checkMethodArgs('WebGLRenderer', arguments, 0, 1) && Sk.ffi.checkArgType('parameters', [
            Sk.ffi.PyType.OBJECT,
            Sk.ffi.PyType.DICT
          ], Sk.ffi.isObjectPy(b) || Sk.ffi.isDict(b), b);
          var c = Sk.ffi.remapToJs(b);
          Sk.ffi.referenceToPy(new THREE.WebGLRenderer(c), 'WebGLRenderer', void 0, a);
        });
        d.setSize = Sk.ffi.functionPy(function (a, b, c) {
          a.v.setSize(Sk.ffi.remapToJs(b), Sk.ffi.remapToJs(c));
        });
        d.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'autoClear':
            return Sk.ffi.booleanToPy(d.autoClear);
          case 'autoClearColor':
            return Sk.ffi.booleanToPy(d.autoClearColor);
          case 'gammaInput':
            return Sk.ffi.booleanToPy(d.gammaInput);
          case 'gammaOutput':
            return Sk.ffi.booleanToPy(d.gammaOutput);
          case 'sortObjects':
            return d.sortObjects;
          case 'canvas':
          case 'domElement':
            return Sk.ffi.callsim(a.Node, Sk.ffi.referenceToPy(d.domElement, 'Node'));
          case 'render':
            return Sk.ffi.callableToPy(a, 'render', function (a, b, c) {
              Sk.ffi.checkMethodArgs('render', arguments, 2, 2);
              var e = Sk.ffi.remapToJs(b), f = Sk.ffi.remapToJs(c);
              return Sk.ffi.remapToPy(d.render(e, f));
            });
          case 'getClearColor':
            return Sk.ffi.callableToPy(a, 'getClearColor', function (b) {
              Sk.ffi.checkMethodArgs('getClearColor', arguments, 0, 0);
              return Sk.ffi.callsim(a.Color, Sk.ffi.referenceToPy(d.getClearColor(), 'Color'));
            });
          case 'setClearColor':
            return Sk.ffi.callableToPy(a, 'setClearColor', function (a, b, c) {
              Sk.ffi.checkMethodArgs('setClearColor', arguments, 2, 2);
              Sk.ffi.checkArgType('color', [
                'Color',
                Sk.ffi.PyType.INT
              ], Sk.ffi.isInstance(b, 'Color') || Sk.ffi.isInt(b), b);
              Sk.ffi.checkArgType('alpha', r, Sk.ffi.isNum(c), c);
              var e = Sk.ffi.remapToJs(b), f = Sk.ffi.remapToJs(c);
              return Sk.ffi.remapToPy(d.setClearColor(e, f));
            });
          case 'setSize':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
              b.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'setSize';
              });
              b.__call__ = Sk.ffi.functionPy(function (a, b, c, e) {
                b = Sk.ffi.remapToJs(b);
                c = Sk.ffi.remapToJs(c);
                e = Sk.ffi.remapToJs(e);
                d.setSize(b, c, e);
              });
              b.__str__ = Sk.ffi.functionPy(function (a) {
                return Sk.builtin.stringToPy('setSize');
              });
              b.__repr__ = Sk.ffi.functionPy(function (a) {
                return Sk.builtin.stringToPy('setSize');
              });
            }, 'setSize', []));
          default:
            throw Sk.ffi.err.attribute(c).isNotGetableOnType('WebGLRenderer');
          }
        });
        d.__setattr__ = Sk.ffi.functionPy(function (a, b, d) {
          a = Sk.ffi.remapToJs(a);
          var e = Sk.ffi.remapToJs(d);
          switch (b) {
          case 'autoClear':
            if (c(e))
              a.autoClear = e;
            else
              throw new Sk.builtin.TypeError('\'autoClear\' attribute must be a <type \'bool\'>.');
            break;
          case 'autoClearColor':
            Sk.ffi.checkArgType('autoClearColor', Sk.ffi.PyType.BOOL, Sk.ffi.isBool(d), d);
            a.autoClearColor = Sk.ffi.remapToJs(d);
            break;
          case 'gammaInput':
            if (c(e))
              a.gammaInput = e;
            else
              throw new Sk.builtin.TypeError('\'gammaInput\' attribute must be a <type \'bool\'>.');
            break;
          case 'gammaOutput':
            if (c(e))
              a.gammaOutput = e;
            else
              throw new Sk.builtin.TypeError('\'gammaOutput\' attribute must be a <type \'bool\'>.');
            break;
          case 'sortObjects':
            if (c(e))
              a.sortObjects = e;
            else
              throw new Sk.builtin.TypeError('\'sortObjects\' attribute must be a <type \'bool\'>.');
            break;
          case 'size':
            b = Sk.ffi.remapToJs(e[0]);
            d = Sk.ffi.remapToJs(e[1]);
            a.setSize(b, d);
            break;
          default:
            throw Sk.ffi.err.attribute(b).isNotSetableOnType('WebGLRenderer');
          }
        });
        d.__str__ = Sk.ffi.functionPy(function (a) {
          a = a.v;
          var b = {};
          b.autoClear = a.autoClear;
          b.gammaInput = a.gammaInput;
          b.gammaOutput = a.gammaOutput;
          return Sk.builtin.stringToPy('WebGLRenderer(' + JSON.stringify(b) + ')');
        });
        d.__repr__ = Sk.ffi.functionPy(function (a) {
          return Sk.builtin.stringToPy('WebGLRenderer(' + [{ autoClear: a.v.autoClear }].map(function (a) {
            return JSON.stringify(a);
          }).join(', ') + ')');
        });
      }, 'WebGLRenderer', []);
      a.Color = Sk.ffi.buildClass(a, function (b, c) {
        c.__init__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(b);
          Sk.ffi.isUndefined(b) ? Sk.ffi.referenceToPy(new THREE.Color(), 'Color', void 0, a) : Sk.ffi.isInt(b) || Sk.builtin.isStringPy(b) ? Sk.ffi.referenceToPy(new THREE.Color(c), 'Color', void 0, a) : Sk.ffi.isInstance(b, 'Color') ? Sk.ffi.referenceToPy(c, 'Color', void 0, a) : Sk.ffi.checkArgType('value', [
            Sk.ffi.PyType.INT,
            Sk.ffi.PyType.STR,
            'Color'
          ], !1, c);
        });
        c.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'r':
            return Sk.ffi.numberToIntPy(d.r);
          case 'g':
            return Sk.ffi.numberToIntPy(d.g);
          case 'b':
            return Sk.ffi.numberToIntPy(d.b);
          case 'getHex':
            return Sk.ffi.callableToPy(a, c, function (a) {
              return Sk.ffi.numberToIntPy(d.getHex());
            });
          case 'getHexString':
            return Sk.ffi.callableToPy(a, 'getHexString', function (a) {
              return Sk.builtin.stringToPy(d.getHexString());
            });
          case 'setHex':
            return Sk.ffi.callableToPy(a, c, function (a, e) {
              Sk.ffi.checkMethodArgs(c, arguments, 1, 1);
              Sk.ffi.checkArgType('hex', Sk.ffi.PyType.INT, Sk.ffi.isInt(e), e);
              d.setHex(Sk.ffi.remapToJs(e));
              return b;
            });
          case 'setRGB':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, c) {
              c.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'setRGB';
              });
              c.__call__ = Sk.ffi.functionPy(function (a, c, e, f) {
                a = Sk.ffi.remapToJs(c);
                e = Sk.ffi.remapToJs(e);
                f = Sk.ffi.remapToJs(f);
                d.setRGB(a, e, f);
                return b;
              });
              c.__str__ = Sk.ffi.functionPy(function (a) {
                return Sk.builtin.stringToPy('setRGB');
              });
              c.__repr__ = Sk.ffi.functionPy(function (a) {
                return Sk.builtin.stringToPy('setRGB');
              });
            }, 'setRGB', []));
          default:
            throw Sk.ffi.err.attribute(c).isNotGetableOnType('Color');
          }
        });
        c.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          a = Sk.ffi.remapToJs(a);
          switch (b) {
          case 'r':
          case 'g':
          case 'b':
            Sk.ffi.checkArgType(b, [
              Sk.ffi.PyType.FLOAT,
              Sk.ffi.PyType.INT
            ], Sk.ffi.isFloat(c) || Sk.ffi.isInt(c), c);
            a.r = Sk.ffi.remapToJs(c);
            break;
          default:
            throw Sk.ffi.err.attribute(b).isNotSetableOnType('Color');
          }
        });
        c.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          var b = {};
          b.r = a.r;
          b.g = a.g;
          b.b = a.b;
          return Sk.builtin.stringToPy('Color(' + JSON.stringify(b) + ')');
        });
        c.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.builtin.stringToPy('Color(' + [
            a.r,
            a.g,
            a.b
          ].map(function (a) {
            return JSON.stringify(a);
          }).join(', ') + ')');
        });
      }, 'Color', []);
      a.PerspectiveCamera = Sk.ffi.buildClass(a, function (b, c) {
        c.__init__ = Sk.ffi.functionPy(function (a, b, c, d, e) {
          Sk.ffi.checkMethodArgs('PerspectiveCamera', arguments, 0, 4);
          Sk.ffi.isDefined(b) && Sk.ffi.checkArgType('fov', Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(b), b);
          Sk.ffi.isDefined(c) && Sk.ffi.checkArgType('aspect', Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(c), c);
          Sk.ffi.isDefined(d) && Sk.ffi.checkArgType('near', Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(d), d);
          Sk.ffi.isDefined(e) && Sk.ffi.checkArgType('far', Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(e), e);
          var f = Sk.ffi.remapToJs(b), g = Sk.ffi.remapToJs(c), h = Sk.ffi.remapToJs(d), k = Sk.ffi.remapToJs(e);
          Sk.ffi.referenceToPy(new THREE.PerspectiveCamera(f, g, h, k), 'PerspectiveCamera', void 0, a);
        });
        c.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'aspect':
            return Sk.ffi.numberToFloatPy(d.aspect);
          case 'position':
            return k(d.position);
          case 'quaternion':
            return Sk.ffi.callsim(a.Quaternion, Sk.ffi.referenceToPy(d.quaternion, 'Quaternion'));
          case 'rotation':
            return k(d.rotation);
          case 'eulerOrder':
            return Sk.builtin.stringToPy(d.eulerOrder);
          case 'scale':
            return k(d.scale);
          case 'up':
            return k(d.up);
          case 'useQuaternion':
            return d.useQuaternion;
          case 'lookAt':
            return q(b);
          case 'updateProjectionMatrix':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
              b.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'updateProjectionMatrix';
              });
              b.__call__ = Sk.ffi.functionPy(function (a) {
                d[c]();
              });
              b.__str__ = Sk.ffi.functionPy(function (a) {
                return Sk.builtin.stringToPy('updateProjectionMatrix');
              });
              b.__repr__ = Sk.ffi.functionPy(function (a) {
                return Sk.builtin.stringToPy('updateProjectionMatrix');
              });
            }, 'updateProjectionMatrix', []));
          default:
            return G(b, c, 'PerspectiveCamera');
          }
        });
        c.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          var d = Sk.ffi.remapToJs(a), f = Sk.ffi.remapToJs(c);
          switch (b) {
          case 'aspect':
            d.aspect = f;
            break;
          case 'position':
          case 'rotation':
          case 'scale':
          case 'up':
            p(d, b, c);
            break;
          case 'quaternion':
            d.quaternion = f;
            break;
          case 'eulerOrder':
            if (e(f))
              d.eulerOrder = f;
            else
              throw Error(b + ' must be a string');
            break;
          case 'useQuaternion':
            d.useQuaternion = f;
            break;
          default:
            return E(a, b, c, 'PerspectiveCamera');
          }
        });
        c.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          var b = {};
          b.fov = a.fov;
          b.aspect = a.aspect;
          b.near = a.near;
          b.far = a.far;
          return Sk.builtin.stringToPy('PerspectiveCamera(' + JSON.stringify(b) + ')');
        });
        c.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.builtin.stringToPy('PerspectiveCamera(' + [
            a.fov,
            a.aspect,
            a.near,
            a.far
          ].map(function (a) {
            return JSON.stringify(a);
          }).join(', ') + ')');
        });
      }, 'PerspectiveCamera', []);
      a.OrthographicCamera = Sk.ffi.buildClass(a, function (b, c) {
        c.__init__ = Sk.ffi.functionPy(function (a, b, c, d, e, f, g) {
          Sk.ffi.checkMethodArgs('OrthographicCamera', arguments, 0, 6);
          Sk.ffi.isDefined(b) && Sk.ffi.checkArgType('left', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(b), b);
          Sk.ffi.isDefined(c) && Sk.ffi.checkArgType('right', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(c), c);
          Sk.ffi.isDefined(d) && Sk.ffi.checkArgType('top', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(d), d);
          Sk.ffi.isDefined(e) && Sk.ffi.checkArgType('bottom', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(e), e);
          Sk.ffi.isDefined(f) && Sk.ffi.checkArgType('near', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(f), f);
          Sk.ffi.isDefined(g) && Sk.ffi.checkArgType('far', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(g), g);
          var h = Sk.ffi.remapToJs(b), k = Sk.ffi.remapToJs(c), l = Sk.ffi.remapToJs(d), m = Sk.ffi.remapToJs(e), n = Sk.ffi.remapToJs(f), p = Sk.ffi.remapToJs(g);
          Sk.ffi.referenceToPy(new THREE.OrthographicCamera(h, k, l, m, n, p), 'OrthographicCamera', void 0, a);
        });
        c.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'aspect':
            return Sk.ffi.numberToFloatPy(d.aspect);
          case 'position':
            return k(d.position);
          case 'quaternion':
            return Sk.ffi.callsim(a.Quaternion, Sk.ffi.referenceToPy(d.quaternion, 'Quaternion'));
          case 'rotation':
            return k(d.rotation);
          case 'eulerOrder':
            return Sk.builtin.stringToPy(d.eulerOrder);
          case 'scale':
            return k(d.scale);
          case 'up':
            return k(d.up);
          case 'useQuaternion':
            return d.useQuaternion;
          case 'lookAt':
            return q(b);
          case 'updateProjectionMatrix':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
              b.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'updateProjectionMatrix';
              });
              b.__call__ = Sk.ffi.functionPy(function (a) {
                d[c]();
              });
              b.__str__ = Sk.ffi.functionPy(function (a) {
                return Sk.builtin.stringToPy('updateProjectionMatrix');
              });
              b.__repr__ = Sk.ffi.functionPy(function (a) {
                return Sk.builtin.stringToPy('updateProjectionMatrix');
              });
            }, 'updateProjectionMatrix', []));
          default:
            return G(b, c, 'OrthographicCamera');
          }
        });
        c.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          var d = Sk.ffi.remapToJs(a), f = Sk.ffi.remapToJs(c);
          switch (b) {
          case 'left':
            d.left = f;
            break;
          case 'right':
            d.right = f;
            break;
          case 'top':
            d.top = f;
            break;
          case 'bottom':
            d.bottom = f;
            break;
          case 'position':
          case 'rotation':
          case 'scale':
          case 'up':
            p(d, b, c);
            break;
          case 'quaternion':
            d.quaternion = f;
            break;
          case 'eulerOrder':
            if (e(f))
              d.eulerOrder = f;
            else
              throw Error(b + ' must be a string');
            break;
          case 'useQuaternion':
            d.useQuaternion = f;
            break;
          default:
            return E(a, b, c, 'OrthographicCamera');
          }
        });
        c.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.builtin.stringToPy('OrthographicCamera(' + [
            a.left,
            a.right,
            a.top,
            a.bottom,
            a.near,
            a.far
          ].map(function (a) {
            return JSON.stringify(a);
          }).join(', ') + ')');
        });
        c.__str__ = Sk.ffi.functionPy(function (a) {
          return Sk.builtin.stringToPy('OrthographicCamera');
        });
      }, 'OrthographicCamera', []);
      a[Sk.three.ARROW_GEOMETRY] = Sk.ffi.buildClass(a, function (a, b) {
        b.__init__ = Sk.ffi.functionPy(function (a, b, c, d, e, f, g, h, k) {
          Sk.ffi.checkMethodArgs(Sk.three.ARROW_GEOMETRY, arguments, 0, 8);
          var l, m, n, p;
          if (Sk.ffi.isDefined(b)) {
            if (Sk.ffi.isInstance(b, Sk.three.ARROW_GEOMETRY)) {
              Sk.ffi.checkMethodArgs(Sk.three.ARROW_GEOMETRY, arguments, 1, 1);
              Sk.ffi.referenceToPy(Sk.ffi.remapToJs(b), Sk.three.ARROW_GEOMETRY, void 0, a);
              return;
            }
            Sk.ffi.checkArgType('scale', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(b), b);
            l = Sk.ffi.remapToJs(b);
          } else
            l = 1;
          Sk.ffi.isDefined(c) && !Sk.ffi.isNone(c) ? (Sk.ffi.checkArgType('attitude', 'Euclidean3', Sk.ffi.isInstance(c, 'Euclidean3'), c), m = Sk.ffi.remapToJs(c).quaternion) : m = new THREE.Quaternion(0, 0, 0, 1);
          Sk.ffi.isDefined(d) && Sk.ffi.checkArgType('segments', s, Sk.ffi.isInt(d), d);
          Sk.ffi.isDefined(e) ? (Sk.ffi.checkArgType('length', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(e), e), n = Sk.ffi.remapToJs(e) * l) : n = l;
          Sk.ffi.isDefined(k) ? (Sk.ffi.checkArgType('axis', 'Euclidean3', Sk.ffi.isInstance(k, 'Euclidean3'), k), p = Sk.ffi.remapToJs(k).vector) : p = new THREE.Vector3(0, 0, 1);
          var I = Sk.ffi.remapToJs(d);
          f = (Sk.ffi.remapToJs(f) || 0.01) * l;
          g = (Sk.ffi.remapToJs(g) || 0.08) * l;
          h = (Sk.ffi.remapToJs(h) || 0.2) * l;
          var q = n - h, r = n / 2;
          l = function (a) {
            var b;
            b = a.x ? 2 : a.y ? 1 : 0;
            var c = 0 < a.x ? 1 : 0 > a.x ? -1 : 0 < a.y ? 1 : 0 > a.y ? -1 : 0 < a.z ? 1 : 0 > a.z ? -1 : 0, d = (b + 0) % 3, e = (b + 1) % 3, h = (b + 2) % 3;
            b = [
              [
                0,
                0,
                r * c
              ],
              [
                g,
                0,
                (q - r) * c
              ],
              [
                f,
                0,
                (q - r) * c
              ],
              [
                f,
                0,
                -r * c
              ],
              [
                0,
                0,
                -r * c
              ]
            ].map(function (a) {
              return new THREE.Vector3(a[d], a[e], a[h]);
            });
            a = new THREE.Quaternion(a.x, a.y, a.z, 0);
            return {
              points: b,
              generator: a
            };
          }(p);
          Sk.ffi.referenceToPy(new Sk.three.RevolutionGeometry(l.points, l.generator, I, 0, 2 * Math.PI, m), Sk.three.ARROW_GEOMETRY, void 0, a);
        });
        b.__getattr__ = Sk.ffi.functionPy(function (a, b) {
          return C(Sk.three.ARROW_GEOMETRY, a, b);
        });
        b.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          return A(Sk.three.ARROW_GEOMETRY, a, b, c);
        });
        b.__str__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.remapToJs(a);
          var b = [].map(function (b) {
              return [
                b,
                Sk.ffi.remapToJs(Sk.ffh.str(Sk.ffi.gattr(a, b)))
              ].join('=');
            });
          return Sk.builtin.stringToPy(Sk.three.ARROW_GEOMETRY + '(' + b.join(', ') + ')');
        });
        b.__repr__ = Sk.ffi.functionPy(function (a) {
          return Sk.builtin.stringToPy(Sk.three.ARROW_GEOMETRY + '(' + [].map(function (a) {
            return JSON.stringify(a);
          }).join(', ') + ')');
        });
      }, Sk.three.ARROW_GEOMETRY, []);
      a.CircleGeometry = Sk.ffi.buildClass(a, function (a, b) {
        b.__init__ = Sk.ffi.functionPy(function (a, b, c, d, e) {
          Sk.ffi.checkMethodArgs('CircleGeometry', arguments, 0, 4);
          Sk.ffi.isDefined(b) && Sk.ffi.checkArgType('radius', r, Sk.ffi.isNum(b), b);
          Sk.ffi.isDefined(c) && Sk.ffi.checkArgType('segments', s, Sk.ffi.isInt(c), c);
          Sk.ffi.isDefined(d) && Sk.ffi.checkArgType('thetaStart', r, Sk.ffi.isNum(d), d);
          Sk.ffi.isDefined(e) && Sk.ffi.checkArgType('thetaLength', r, Sk.ffi.isNum(e), e);
          Sk.ffi.referenceToPy(new THREE.CircleGeometry(Sk.ffi.remapToJs(b), Sk.ffi.remapToJs(c), Sk.ffi.remapToJs(d), Sk.ffi.remapToJs(e)), 'CircleGeometry', void 0, a);
        });
        b.__getattr__ = Sk.ffi.functionPy(function (a, b) {
          return C('CircleGeometry', a, b);
        });
        b.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          return A('CircleGeometry', a, b, c);
        });
        b.__str__ = Sk.ffi.functionPy(function (a) {
          return Sk.builtin.stringToPy('CircleGeometry(' + JSON.stringify({}) + ')');
        });
        b.__repr__ = Sk.ffi.functionPy(function (a) {
          return Sk.builtin.stringToPy('CircleGeometry(' + [].map(function (a) {
            return JSON.stringify(a);
          }).join(', ') + ')');
        });
      }, 'CircleGeometry', []);
      a.BoxGeometry = Sk.ffi.buildClass(a, function (a, b) {
        b.__init__ = Sk.ffi.functionPy(function (a, b, c, d, e, f, g) {
          Sk.ffi.checkMethodArgs('BoxGeometry(width, height, depth, widthSegments, heightSegments, depthSegments)', arguments, 3, 6);
          Sk.ffi.checkArgType('width', Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(b), b);
          Sk.ffi.checkArgType('height', Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(c), c);
          Sk.ffi.checkArgType('depth', Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(d), d);
          Sk.ffi.isDefined(e) && Sk.ffi.checkArgType('widthSegments', s, Sk.ffi.isInt(e), e);
          Sk.ffi.isDefined(f) && Sk.ffi.checkArgType('heightSegments', s, Sk.ffi.isInt(f), f);
          Sk.ffi.isDefined(g) && Sk.ffi.checkArgType('depthSegments', s, Sk.ffi.isInt(g), g);
          var h = Sk.ffi.remapToJs(b), k = Sk.ffi.remapToJs(c), l = Sk.ffi.remapToJs(d), m = Sk.ffi.remapToJs(e), n = Sk.ffi.remapToJs(f), p = Sk.ffi.remapToJs(g);
          Sk.ffi.referenceToPy(new THREE.BoxGeometry(h, k, l, m, n, p), 'BoxGeometry', void 0, a);
        });
        b.__getattr__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a);
          switch (b) {
          case 'width':
          case 'height':
          case 'depth':
            return Sk.ffi.numberToFloatPy(c[b]);
          case 'widthSegments':
          case 'heightSegments':
          case 'depthSegments':
            return Sk.ffi.numberToIntPy(c[b]);
          default:
            return C('BoxGeometry', a, b);
          }
        });
        b.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          return A('BoxGeometry', a, b, c);
        });
        b.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          var b = {};
          b.width = a.width;
          b.height = a.height;
          b.depth = a.depth;
          return Sk.builtin.stringToPy('BoxGeometry(' + JSON.stringify(b) + ')');
        });
        b.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.builtin.stringToPy('BoxGeometry(' + [
            a.width,
            a.height,
            a.depth,
            a.widthSegments,
            a.heightSegments,
            a.depthSegments
          ].map(function (a) {
            return JSON.stringify(a);
          }).join(', ') + ')');
        });
      }, 'BoxGeometry', []);
      a.CubeGeometry = a.BoxGeometry;
      a.CylinderGeometry = Sk.ffi.buildClass(a, function (a, b) {
        b.__init__ = Sk.ffi.functionPy(function (a, b, c, d, e, f, g, h) {
          if (Sk.ffi.isInstance(b, 'CylinderGeometry'))
            Sk.ffi.referenceToPy(Sk.ffi.remapToJs(b), 'CylinderGeometry', void 0, a);
          else {
            Sk.ffi.checkMethodArgs('CylinderGeometry', arguments, 0, 7);
            Sk.ffi.checkArgType('radiusTop', r, Sk.ffi.isNum(b) || Sk.ffi.isUndefined(b), b);
            Sk.ffi.checkArgType('radiusBottom', r, Sk.ffi.isNum(c) || Sk.ffi.isUndefined(c), c);
            Sk.ffi.checkArgType('height', r, Sk.ffi.isNum(d) || Sk.ffi.isUndefined(d), d);
            Sk.ffi.checkArgType('radialSegments', Sk.ffi.PyType.INT, Sk.ffi.isInt(e) || Sk.ffi.isUndefined(e), e);
            Sk.ffi.checkArgType('heightSegments', Sk.ffi.PyType.INT, Sk.ffi.isInt(f) || Sk.ffi.isUndefined(f), f);
            Sk.ffi.checkArgType('openEnded', Sk.ffi.PyType.BOOL, Sk.ffi.isBool(g) || Sk.ffi.isUndefined(g), g);
            var k = Sk.ffi.remapToJs(b), l = Sk.ffi.remapToJs(c), m = Sk.ffi.remapToJs(d), n = Sk.ffi.remapToJs(e), p = Sk.ffi.remapToJs(f), q = Sk.ffi.remapToJs(g), I;
            Sk.ffi.isDefined(h) ? (Sk.ffi.checkArgType('axis', 'Euclidean3', Sk.ffi.isInstance(h, 'Euclidean3'), h), I = Sk.ffi.remapToJs(h).vector) : I = new THREE.Vector3(0, 0, 1);
            Sk.ffi.referenceToPy(new Sk.stdlib.CylinderGeometry(k, l, m, n, p, q, I), 'CylinderGeometry', void 0, a);
          }
        });
        b.__getattr__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a);
          switch (b) {
          case 'radiusTop':
            return Sk.ffi.numberToFloatPy(c.radiusTop);
          case 'radiusBottom':
            return Sk.ffi.numberToFloatPy(c.radiusBottom);
          case 'height':
            return Sk.ffi.numberToFloatPy(c.height);
          case 'radialSegments':
            return Sk.ffi.numberToIntPy(c.radialSegments);
          case 'heightSegments':
            return Sk.ffi.numberToIntPy(c.heightSegments);
          case 'openEnded':
            return Sk.ffi.booleanToPy(c.openEnded);
          default:
            return C('CylinderGeometry', a, b);
          }
        });
        b.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          return A('CylinderGeometry', a, b, c);
        });
        b.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          var b = {};
          b.radiusTop = a.radiusTop;
          b.radiusBottom = a.radiusBottom;
          b.height = a.height;
          b.openEnded = a.openEnded;
          return Sk.builtin.stringToPy('CylinderGeometry(' + JSON.stringify(b) + ')');
        });
        b.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.builtin.stringToPy('CylinderGeometry(' + [
            a.radiusTop,
            a.radiusBottom,
            a.height,
            a.radialSegments,
            a.heightSegments,
            a.openEnded
          ].map(function (a) {
            return JSON.stringify(a);
          }).join(', ') + ')');
        });
      }, 'CylinderGeometry', []);
      a.LatheGeometry = Sk.ffi.buildClass(a, function (a, b) {
        b.__init__ = Sk.ffi.functionPy(function (a, b, c, d, e) {
          Sk.ffi.checkMethodArgs('LatheGeometry', arguments, 1, 4);
          var f = Sk.ffi.remapToJs(b).map(function (a) {
              return new THREE.Vector3(a.x, a.y, a.z);
            }), g = new THREE.Quaternion(0, 0, 1, 0);
          Sk.ffi.referenceToPy(new Sk.three.RevolutionGeometry(f, g, Sk.ffi.remapToJs(c), Sk.ffi.remapToJs(d), Sk.ffi.remapToJs(e)), 'LatheGeometry', void 0, a);
        });
        b.__getattr__ = Sk.ffi.functionPy(function (a, b) {
          return C('LatheGeometry', a, b);
        });
        b.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          return A('LatheGeometry', a, b, c);
        });
        b.__str__ = Sk.ffi.functionPy(function (a) {
          return Sk.builtin.stringToPy('LatheGeometry(' + JSON.stringify({}) + ')');
        });
        b.__repr__ = Sk.ffi.functionPy(function (a) {
          return Sk.builtin.stringToPy('LatheGeometry(' + [].map(function (a) {
            return JSON.stringify(a);
          }).join(', ') + ')');
        });
      }, 'LatheGeometry', []);
      a.IcosahedronGeometry = Sk.ffi.buildClass(a, function (a, b) {
        b.__init__ = Sk.ffi.functionPy(function (a, b, c) {
          Sk.ffi.checkMethodArgs('IcosahedronGeometry', arguments, 0, 2);
          Sk.ffi.isDefined(b) && Sk.ffi.checkArgType('radius', r, Sk.ffi.isNum(b), b);
          Sk.ffi.isDefined(c) && Sk.ffi.checkArgType('detail', s, Sk.ffi.isInt(c), c);
          var d = Sk.ffi.remapToJs(b), e = Sk.ffi.remapToJs(c);
          Sk.ffi.referenceToPy(new THREE.IcosahedronGeometry(d, e), 'IcosahedronGeometry', void 0, a);
        });
        b.__getattr__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a);
          switch (b) {
          case 'radius':
            return Sk.ffi.numberToFloatPy(c.radius);
          case 'detail':
            return Sk.ffi.numberToIntPy(c.detail);
          default:
            throw Sk.ffi.err.attribute(b).isNotGetableOnType('IcosahedronGeometry');
          }
        });
        b.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          switch (b) {
          default:
            throw Sk.ffi.err.attribute(b).isNotSetableOnType('IcosahedronGeometry');
          }
        });
        b.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          var b = {};
          b.radius = a.radius;
          b.detail = a.detail;
          return Sk.builtin.stringToPy('IcosahedronGeometry(' + JSON.stringify(b) + ')');
        });
        b.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.builtin.stringToPy('IcosahedronGeometry(' + [
            a.radius,
            a.detail
          ].map(function (a) {
            return JSON.stringify(a);
          }).join(', ') + ')');
        });
      }, 'IcosahedronGeometry', []);
      a.OctahedronGeometry = Sk.ffi.buildClass(a, function (a, b) {
        b.__init__ = Sk.ffi.functionPy(function (a, b, c) {
          Sk.ffi.checkMethodArgs('OctahedronGeometry', arguments, 0, 2);
          Sk.ffi.isDefined(b) && Sk.ffi.checkArgType('radius', r, Sk.ffi.isNum(b), b);
          Sk.ffi.isDefined(c) && Sk.ffi.checkArgType('detail', s, Sk.ffi.isInt(c), c);
          var d = Sk.ffi.remapToJs(b), e = Sk.ffi.remapToJs(c), f = new THREE.OctahedronGeometry(d, e);
          f.radius = d;
          f.detail = e;
          Sk.ffi.referenceToPy(f, 'OctahedronGeometry', void 0, a);
        });
        b.__getattr__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a);
          switch (b) {
          case 'radius':
            return Sk.ffi.numberToFloatPy(c.radius);
          case 'detail':
            return Sk.ffi.numberToIntPy(c.detail);
          default:
            throw Sk.ffi.err.attribute(b).isNotGetableOnType('OctahedronGeometry');
          }
        });
        b.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          switch (b) {
          default:
            throw Sk.ffi.err.attribute(b).isNotSetableOnType('OctahedronGeometry');
          }
        });
        b.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          var b = {};
          b.radius = a.radius;
          b.detail = a.detail;
          return Sk.builtin.stringToPy('OctahedronGeometry(' + JSON.stringify(b) + ')');
        });
        b.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.builtin.stringToPy('OctahedronGeometry(' + [
            a.radius,
            a.detail
          ].map(function (a) {
            return JSON.stringify(a);
          }).join(', ') + ')');
        });
      }, 'OctahedronGeometry', []);
      a.PlaneGeometry = Sk.ffi.buildClass(a, function (a, b) {
        b.__init__ = Sk.ffi.functionPy(function (a, b, c, d, e) {
          Sk.ffi.checkMethodArgs('PlaneGeometry', arguments, 2, 4);
          Sk.ffi.checkArgType('width', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(b), b);
          Sk.ffi.checkArgType('depth', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(c), c);
          f(d) && Sk.ffi.checkArgType('widthSegments', Sk.ffi.PyType.INT, Sk.ffi.isInt(d), d);
          f(e) && Sk.ffi.checkArgType('heightSegments', Sk.ffi.PyType.INT, Sk.ffi.isInt(e), e);
          var g = Sk.ffi.remapToJs(b), h = Sk.ffi.remapToJs(c), k = Sk.ffi.remapToJs(d), l = Sk.ffi.remapToJs(e);
          Sk.ffi.referenceToPy(new Sk.stdlib.PlaneGeometry(g, h, k, l), 'PlaneGeometry', void 0, a);
        });
        b.__getattr__ = Sk.ffi.functionPy(function (a, b) {
          return C('PlaneGeometry', a, b);
        });
        b.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          return A('PlaneGeometry', a, b, c);
        });
        b.__str__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.remapToJs(a);
          var b = [
              'width',
              'height'
            ].map(function (b) {
              return [
                b,
                Sk.ffi.remapToJs(Sk.ffh.str(Sk.ffi.gattr(a, b)))
              ].join('=');
            });
          return Sk.builtin.stringToPy('PlaneGeometry(' + b.join(', ') + ')');
        });
        b.__repr__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.remapToJs(a);
          var b = [
              'width',
              'height'
            ].map(function (b) {
              return Sk.ffi.gattr(a, b);
            }).map(function (a) {
              return Sk.ffi.remapToJs(Sk.ffh.repr(a));
            });
          return Sk.builtin.stringToPy('PlaneGeometry(' + b.join(', ') + ')');
        });
      }, 'PlaneGeometry', []);
      a.RevolutionGeometry = Sk.ffi.buildClass(a, function (a, b) {
        b.__init__ = Sk.ffi.functionPy(function (a, b, c, d, e, f, g) {
          Sk.ffi.checkMethodArgs('RevolutionGeometry', arguments, 2, 5);
          Sk.ffi.checkArgType('points', Sk.ffi.PyType.LIST, Sk.ffi.isList(b), b);
          Sk.ffi.checkArgType('generator', 'Euclidean3', Sk.ffi.isInstance(c, 'Euclidean3'), c);
          Sk.ffi.isDefined(d) && Sk.ffi.checkArgType('segments', Sk.ffi.PyType.INT, Sk.ffi.isInt(d), d);
          Sk.ffi.isDefined(e) && Sk.ffi.checkArgType('phiStart', r, Sk.ffi.isNum(e), e);
          Sk.ffi.isDefined(f) && Sk.ffi.checkArgType('phiLength', r, Sk.ffi.isNum(f), f);
          Sk.ffi.isDefined(g) && Sk.ffi.checkArgType('attitude', 'Euclidean3', Sk.ffi.isInstance(g, 'Euclidean3'), g);
          var h = Sk.ffi.remapToJs(b).map(function (a) {
              return new THREE.Vector3(a.x, a.y, a.z);
            }), k = Sk.ffi.remapToJs(g), k = Sk.ffi.remapToJs(g) ? Sk.ffi.remapToJs(g).quaternion : void 0;
          Sk.ffi.referenceToPy(new Sk.three.RevolutionGeometry(h, Sk.ffi.remapToJs(c).quaternion, Sk.ffi.remapToJs(d), Sk.ffi.remapToJs(e), Sk.ffi.remapToJs(f), k), 'RevolutionGeometry', void 0, a);
        });
        b.__getattr__ = Sk.ffi.functionPy(function (a, b) {
          Sk.ffi.remapToJs(a);
          switch (b) {
          default:
            return C('RevolutionGeometry', a, b);
          }
        });
        b.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          Sk.ffi.remapToJs(a);
          Sk.ffi.remapToJs(c);
          switch (b) {
          default:
            return A('RevolutionGeometry', a, b, c);
          }
        });
        b.__str__ = Sk.ffi.functionPy(function (a) {
          return Sk.builtin.stringToPy('RevolutionGeometry(' + JSON.stringify({}) + ')');
        });
        b.__repr__ = Sk.ffi.functionPy(function (a) {
          return Sk.builtin.stringToPy('RevolutionGeometry(' + [].map(function (a) {
            return JSON.stringify(a);
          }).join(', ') + ')');
        });
      }, 'RevolutionGeometry', []);
      a.SphereGeometry = Sk.ffi.buildClass(a, function (a, b) {
        b.__init__ = Sk.ffi.functionPy(function (a, b, c, d, e, g, h, k) {
          if (Sk.ffi.isDefined(b)) {
            if (Sk.ffi.isInstance(b, 'SphereGeometry')) {
              Sk.ffi.checkMethodArgs('SphereGeometry', arguments, 1, 1);
              Sk.ffi.referenceToPy(Sk.ffi.remapToJs(b), 'SphereGeometry', void 0, a);
              return;
            }
            Sk.ffi.checkArgType('radius', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(b), b);
          }
          f(c) && Sk.ffi.checkArgType('widthSegments', Sk.ffi.PyType.INT, Sk.ffi.isInt(c), c);
          f(d) && Sk.ffi.checkArgType('heightSegments', Sk.ffi.PyType.INT, Sk.ffi.isInt(d), d);
          f(e) && Sk.ffi.checkArgType('phiStart', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(e), e);
          f(g) && Sk.ffi.checkArgType('phiLength', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(g), g);
          f(h) && Sk.ffi.checkArgType('thetaStart', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(h), h);
          f(k) && Sk.ffi.checkArgType('thetaLength', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(k), k);
          var l = Sk.ffi.remapToJs(b), m = Sk.ffi.remapToJs(c), n = Sk.ffi.remapToJs(d), p = Sk.ffi.remapToJs(e), q = Sk.ffi.remapToJs(g), I = Sk.ffi.remapToJs(h), r = Sk.ffi.remapToJs(k);
          Sk.ffi.referenceToPy(new THREE.SphereGeometry(l, m, n, p, q, I, r), 'SphereGeometry', void 0, a);
        });
        b.__getattr__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a);
          switch (b) {
          case 'radius':
            return Sk.ffi.numberToFloatPy(c.radius);
          case 'widthSegments':
            return Sk.ffi.numberToIntPy(c.widthSegments);
          case 'heightSegments':
            return Sk.ffi.numberToIntPy(c.heightSegments);
          case 'phiStart':
            return Sk.ffi.numberToFloatPy(c.phiStart);
          case 'phiLength':
            return Sk.ffi.numberToFloatPy(c.phiLength);
          case 'thetaStart':
            return Sk.ffi.numberToFloatPy(c.thetaStart);
          case 'thetaLength':
            return Sk.ffi.numberToFloatPy(c.thetaLength);
          default:
            return C('SphereGeometry', a, b);
          }
        });
        b.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          switch (b) {
          default:
            return A('SphereGeometry', a, b, c);
          }
        });
        b.__str__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.remapToJs(a);
          var b = 'radius widthSegments heightSegments phiStart phiLength thetaStart thetaLength'.split(' ').map(function (b) {
              return [
                b,
                Sk.ffi.remapToJs(Sk.ffh.str(Sk.ffi.gattr(a, b)))
              ].join('=');
            });
          return Sk.builtin.stringToPy('SphereGeometry(' + b.join(', ') + ')');
        });
        b.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.builtin.stringToPy('SphereGeometry(' + [
            a.radius,
            a.widthSegments,
            a.heightSegments,
            a.phiStart,
            a.phiLength,
            a.thetaStart,
            a.thetaLength
          ].map(function (a) {
            return JSON.stringify(a);
          }).join(', ') + ')');
        });
      }, 'SphereGeometry', []);
      a.TetrahedronGeometry = Sk.ffi.buildClass(a, function (a, b) {
        b.__init__ = Sk.ffi.functionPy(function (a, b, c) {
          Sk.ffi.checkMethodArgs('TetrahedronGeometry', arguments, 2, 2);
          Sk.ffi.checkArgType('radius', r, Sk.ffi.isNum(b), b);
          Sk.ffi.checkArgType('detail', s, Sk.ffi.isInt(c), c);
          var d = Sk.ffi.remapToJs(b), e = Sk.ffi.remapToJs(c), f = new THREE.TetrahedronGeometry(d, e);
          f.radius = d;
          f.detail = e;
          Sk.ffi.referenceToPy(f, 'TetrahedronGeometry', void 0, a);
        });
        b.__getattr__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a);
          switch (b) {
          case 'radius':
            return Sk.ffi.numberToFloatPy(c.radius);
          case 'detail':
            return Sk.ffi.numberToIntPy(c.detail);
          default:
            return C('TetrahedronGeometry', a, b);
          }
        });
        b.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          return A('TetrahedronGeometry', a, b, c);
        });
        b.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          var b = {};
          b.radius = a.radius;
          b.detail = a.detail;
          return Sk.builtin.stringToPy('TetrahedronGeometry(' + JSON.stringify(b) + ')');
        });
        b.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.builtin.stringToPy('TetrahedronGeometry(' + [
            a.radius,
            a.detail
          ].map(function (a) {
            return JSON.stringify(a);
          }).join(', ') + ')');
        });
      }, 'TetrahedronGeometry', []);
      a.TextGeometry = Sk.ffi.buildClass(a, function (a, b) {
        b.__init__ = Sk.ffi.functionPy(function (a, b, c) {
          b = Sk.ffi.remapToJs(b);
          c = Sk.ffi.remapToJs(c);
          a.v = new THREE.TextGeometry(b, c);
        });
        b.__getattr__ = Sk.ffi.functionPy(function (a, b) {
          return C('TextGeometry', a, b);
        });
        b.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          return A('TextGeometry', a, b, c);
        });
        b.__str__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.remapToJs(a);
          return Sk.builtin.stringToPy('TextGeometry(' + JSON.stringify({}) + ')');
        });
        b.__repr__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.remapToJs(a);
          return Sk.builtin.stringToPy('TextGeometry(' + [].map(function (a) {
            return JSON.stringify(a);
          }).join(', ') + ')');
        });
      }, 'TextGeometry', []);
      a.TorusGeometry = Sk.ffi.buildClass(a, function (a, b) {
        b.__init__ = Sk.ffi.functionPy(function (a, b, c, d, e, f) {
          Sk.ffi.checkMethodArgs('TorusGeometry', arguments, 0, 5);
          Sk.ffi.isDefined(b) && Sk.ffi.checkArgType('radius', r, Sk.ffi.isNum(b), b);
          Sk.ffi.isDefined(c) && Sk.ffi.checkArgType('tube', r, Sk.ffi.isNum(c), c);
          Sk.ffi.isDefined(d) && Sk.ffi.checkArgType('radialSegments', s, Sk.ffi.isInt(d), d);
          Sk.ffi.isDefined(e) && Sk.ffi.checkArgType('tubularSegments', s, Sk.ffi.isInt(e), e);
          Sk.ffi.isDefined(f) && Sk.ffi.checkArgType('arc', r, Sk.ffi.isNum(f), f);
          var g = Sk.ffi.remapToJs(b), h = Sk.ffi.remapToJs(c), k = Sk.ffi.remapToJs(d), l = Sk.ffi.remapToJs(e), m = Sk.ffi.remapToJs(f), g = new Sk.stdlib.TorusGeometry(g, h, k, l, m);
          Sk.ffi.referenceToPy(g, 'TorusGeometry', void 0, a);
        });
        b.__getattr__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a);
          switch (b) {
          case 'radius':
            return Sk.ffi.numberToFloatPy(c.radius);
          case 'tube':
            return Sk.ffi.numberToFloatPy(c.tube);
          case 'radialSegments':
            return Sk.ffi.numberToIntPy(c.radialSegments);
          case 'tubularSegments':
            return Sk.ffi.numberToIntPy(c.tubularSegments);
          case 'arc':
            return Sk.ffi.numberToFloatPy(c.arc);
          default:
            return C('TorusGeometry', a, b);
          }
        });
        b.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          return A('TorusGeometry', a, b, c);
        });
        b.__str__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.remapToJs(a);
          var b = [
              'radius',
              'tube',
              'radialSegments',
              'tubularSegments',
              'arc'
            ].map(function (b) {
              return [
                b,
                Sk.ffi.remapToJs(Sk.ffh.str(Sk.ffi.gattr(a, b)))
              ].join('=');
            });
          return Sk.builtin.stringToPy('TorusGeometry(' + b.join(', ') + ')');
        });
        b.__repr__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.remapToJs(a);
          var b = [
              'radius',
              'tube',
              'radialSegments',
              'tubularSegments',
              'arc'
            ].map(function (b) {
              return Sk.ffi.gattr(a, b);
            }).map(function (a) {
              return Sk.ffi.remapToJs(Sk.ffh.repr(a));
            });
          return Sk.builtin.stringToPy('TorusGeometry(' + b.join(', ') + ')');
        });
      }, 'TorusGeometry', []);
      a[Sk.three.VORTEX_GEOMETRY] = Sk.ffi.buildClass(a, function (a, b) {
        b.__init__ = Sk.ffi.functionPy(function (a, b, c, d, e, g, h, k) {
          Sk.ffi.checkMethodArgs(Sk.three.VORTEX_GEOMETRY + '(radius, radiusCone, radiusShaft, lengthCone, lengthShaft, arrowSegments, radialSegments)', arguments, 7, 7);
          Sk.ffi.checkArgType('radius', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(b), b);
          Sk.ffi.checkArgType('radiusCone', r, Sk.ffi.isNum(c), c);
          Sk.ffi.checkArgType('radiusShaft', r, Sk.ffi.isNum(d), d);
          var l = Sk.ffi.remapToJs(b), m = Sk.ffi.remapToJs(c), n = Sk.ffi.remapToJs(d), p = Sk.ffi.remapToJs(e), q = Sk.ffi.remapToJs(g);
          f(h) && Sk.ffi.checkArgType('widthSegments', Sk.ffi.PyType.INT, Sk.ffi.isInt(h), h);
          f(k) && Sk.ffi.checkArgType('heightSegments', Sk.ffi.PyType.INT, Sk.ffi.isInt(k), k);
          var I = Sk.ffi.remapToJs(h), s = Sk.ffi.remapToJs(k), l = new Sk.three.VortexGeometry(l, m, n, p, q, I, s);
          Sk.ffi.referenceToPy(l, Sk.three.VORTEX_GEOMETRY, void 0, a);
        });
        b.__getattr__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a);
          switch (b) {
          case 'radius':
            return Sk.ffi.numberToFloatPy(c.radius);
          case 'radiusCone':
            return Sk.ffi.numberToFloatPy(c.radiusCone);
          case 'radiusShaft':
            return Sk.ffi.numberToFloatPy(c.radiusShaft);
          case 'widthSegments':
            return Sk.ffi.numberToIntPy(c.widthSegments);
          case 'depthSegments':
          case 'heightSegments':
            return Sk.ffi.numberToIntPy(c.heightSegments);
          default:
            return C(Sk.three.VORTEX_GEOMETRY, a, b);
          }
        });
        b.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          return A(Sk.three.VORTEX_GEOMETRY, a, b, c);
        });
        b.__str__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.remapToJs(a);
          var b = [
              'radius',
              'radiusCone',
              'radiusShaft'
            ].map(function (b) {
              return [
                b,
                Sk.ffi.remapToJs(Sk.ffh.str(Sk.ffi.gattr(a, b)))
              ].join('=');
            });
          return Sk.builtin.stringToPy(Sk.three.VORTEX_GEOMETRY + '(' + b.join(', ') + ')');
        });
        b.__repr__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.remapToJs(a);
          var b = [
              'radius',
              'radiusCone',
              'radiusShaft'
            ].map(function (b) {
              return Sk.ffi.gattr(a, b);
            }).map(function (a) {
              return Sk.ffi.remapToJs(Sk.ffh.repr(a));
            });
          return Sk.builtin.stringToPy(Sk.three.VORTEX_GEOMETRY + '(' + b.join(', ') + ')');
        });
      }, Sk.three.VORTEX_GEOMETRY, []);
      a.Geometry = Sk.ffi.buildClass(a, function (a, b) {
        b.__init__ = Sk.ffi.functionPy(function (a, b) {
          f(b) ? Sk.ffi.referenceToPy(Sk.ffi.remapToJs(b), 'Geometry', void 0, a) : Sk.ffi.referenceToPy(new THREE.Geometry(), 'Geometry', void 0, a);
        });
        b.__getattr__ = Sk.ffi.functionPy(function (a, b) {
          return C('Geometry', a, b);
        });
        b.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          return A('Geometry', a, b, c);
        });
        b.__str__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.remapToJs(a);
          return Sk.builtin.stringToPy('Geometry(' + JSON.stringify({}) + ')');
        });
        b.__repr__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.remapToJs(a);
          return Sk.builtin.stringToPy('Geometry(' + [].map(function (a) {
            return JSON.stringify(a);
          }).join(', ') + ')');
        });
      }, 'Geometry', []);
      Sk.three.object3DGetAttr = function (b, c, d) {
        var e = Sk.ffi.remapToJs(c);
        switch (d) {
        case 'id':
          return Sk.ffi.numberToIntPy(e[d]);
        case 'name':
        case 'uuid':
        case 'eulerOrder':
          return Sk.builtin.stringToPy(e[d]);
        case 'attitude':
          return h(e.quaternion);
        case 'position':
        case 'rotation':
        case 'scale':
        case 'up':
          return k(e[d]);
        case 'matrixWorld':
          return Sk.ffi.callsim(a[Sk.three.MATRIX_4], Sk.ffi.referenceToPy(e[d], Sk.three.MATRIX_4));
        case 'quaternion':
          return Sk.ffi.callsim(a.Quaternion, Sk.ffi.referenceToPy(e.quaternion, 'Quaternion'));
        case 'useQuaternion':
        case 'visible':
          return Sk.ffi.booleanToPy(e[d]);
        case 'charge':
        case 'mass':
        case 'momentum':
        case 'velocity':
          var f = e[d];
          if (g(f))
            return f;
          throw Sk.ffi.err.attribute(d).isNotGetableOnType(b);
        case 'geometry':
          return Sk.ffi.callsim(a.Geometry, Sk.ffi.referenceToPy(e.geometry, 'Geometry'));
        case 'material':
          return Sk.ffi.callsim(a[Sk.three.MATERIAL], Sk.ffi.referenceToPy(e.material, Sk.three.MATERIAL));
        case 'add':
          return n(e);
        case 'remove':
          return x(e);
        case 'traverse':
          return Sk.ffi.callableToPy(a, d, function (b, f) {
            Sk.ffi.checkMethodArgs(d, arguments, 1, 1);
            Sk.ffi.checkArgType('callback', Sk.ffi.PyType.FUNCTION, Sk.ffi.isFunction(f), f);
            e[d](function (b) {
              b = Sk.ffi.callsim(a[Sk.three.OBJECT_3D], Sk.ffi.referenceToPy(b, Sk.three.OBJECT_3D));
              return Sk.ffi.remapToJs(Sk.ffi.callsim(f, b));
            });
            return c;
          });
        default:
          throw Sk.ffi.err.attribute(d).isNotGetableOnType(b);
        }
      };
      Sk.three.object3DSetAttr = function (a, b, c, d) {
        var e = Sk.ffi.remapToJs(b);
        switch (c) {
        case 'attitude':
          l(a, b, 'quaternion', d, c);
          break;
        case 'position':
        case 'rotation':
        case 'scale':
        case 'up':
          p(e, c, d);
          break;
        case 'quaternion':
          Sk.ffi.checkArgType(c, 'Quaternion', Sk.ffi.isInstance(d, 'Quaternion'), d);
          e[c] = Sk.ffi.remapToJs(d);
          break;
        case 'eulerOrder':
          Sk.ffi.checkArgType(c, Sk.ffi.PyType.STR, Sk.builtin.isStringPy(d), d);
          e[c] = Sk.builtin.stringToJs(d);
          break;
        case 'useQuaternion':
        case 'visible':
          Sk.ffi.checkArgType(c, Sk.ffi.PyType.BOOL, Sk.ffi.isBool(d), d);
          e[c] = Sk.ffi.remapToJs(d);
          break;
        case 'charge':
        case 'mass':
        case 'momentum':
        case 'velocity':
          Sk.ffi.checkArgType(c, 'Euclidean3', g(d), d);
          e[c] = d;
          break;
        default:
          throw Sk.ffi.err.attribute(c).isNotSetableOnType(a);
        }
      };
      a[Sk.three.OBJECT_3D] = Sk.ffi.buildClass(a, function (a, b) {
        b.__init__ = Sk.ffi.functionPy(function (a, b) {
          var c = f(b) ? Sk.ffi.remapToJs(b) : new THREE.Object3D();
          Sk.ffi.referenceToPy(c, Sk.three.OBJECT_3D, void 0, a);
        });
        b.__getattr__ = Sk.ffi.functionPy(function (a, b) {
          return Sk.three.object3DGetAttr(Sk.three.OBJECT_3D, a, b);
        });
        b.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          return Sk.three.object3DSetAttr(Sk.three.OBJECT_3D, a, b, c);
        });
        b.__str__ = Sk.ffi.functionPy(function (a) {
          return Sk.builtin.stringToPy(Sk.three.OBJECT_3D + '(' + JSON.stringify({}) + ')');
        });
        b.__repr__ = Sk.ffi.functionPy(function (a) {
          return Sk.builtin.stringToPy(Sk.three.OBJECT_3D + '(' + [].map(function (a) {
            return JSON.stringify(a);
          }).join(', ') + ')');
        });
      }, Sk.three.OBJECT_3D, []);
      a.AmbientLight = Sk.ffi.buildClass(a, function (a, b) {
        b.__init__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(b);
          Sk.ffi.referenceToPy(new THREE.AmbientLight(c), 'AmbientLight', void 0, a);
        });
        b.__getattr__ = Sk.ffi.functionPy(function (a, b) {
          return u('AmbientLight', a, b);
        });
        b.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          return t('AmbientLight', a, b, c);
        });
        b.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          var b = {};
          b.color = a.color;
          return Sk.builtin.stringToPy('AmbientLight(' + JSON.stringify(b) + ')');
        });
        b.__repr__ = Sk.ffi.functionPy(function (a) {
          a = [Sk.ffi.remapToJs(a).color];
          return Sk.builtin.stringToPy('AmbientLight(' + a.map(function (a) {
            return JSON.stringify(a);
          }).join(', ') + ')');
        });
      }, 'AmbientLight', []);
      a.DirectionalLight = Sk.ffi.buildClass(a, function (a, b) {
        b.__init__ = Sk.ffi.functionPy(function (a, b, c) {
          Sk.ffi.checkMethodArgs('DirectionalLight', arguments, 1, 2);
          Sk.ffi.checkArgType('intensity', r, Sk.ffi.isNum(c) || Sk.ffi.isUndefined(c), c);
          var d = Sk.ffi.remapToJs(b), e = Sk.ffi.remapToJs(c);
          Sk.ffi.referenceToPy(new THREE.DirectionalLight(d, e), 'DirectionalLight', void 0, a);
        });
        b.__getattr__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a);
          switch (b) {
          case 'intensity':
            return Sk.ffi.numberToFloatPy(c.intensity);
          default:
            return u('DirectionalLight', a, b);
          }
        });
        b.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          var d = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(c);
          switch (b) {
          case 'intensity':
            Sk.ffi.checkArgType('intensity', r, Sk.ffi.isNum(c), c);
            d.intensity = e;
            break;
          default:
            return t('DirectionalLight', a, b, c);
          }
        });
        b.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          var b = {};
          b.color = a.color;
          b.intensity = a.intensity;
          b.distance = a.distance;
          return Sk.builtin.stringToPy('DirectionalLight(' + JSON.stringify(b) + ')');
        });
        b.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.builtin.stringToPy('DirectionalLight(' + [
            a.color,
            a.intensity,
            a.distance
          ].map(function (a) {
            return JSON.stringify(a);
          }).join(', ') + ')');
        });
      }, 'DirectionalLight', []);
      a.PointLight = Sk.ffi.buildClass(a, function (a, b) {
        b.__init__ = Sk.ffi.functionPy(function (a, b, c, d) {
          Sk.ffi.checkMethodArgs('PointLight', arguments, 1, 3);
          Sk.ffi.checkArgType('color', [
            'Color',
            Sk.ffi.PyType.INT
          ], Sk.ffi.isInstance(b, 'Color') || Sk.ffi.isInt(b), b);
          Sk.ffi.checkArgType('intensity', r, Sk.ffi.isNum(c) || Sk.ffi.isUndefined(c), c);
          Sk.ffi.checkArgType('distance', r, Sk.ffi.isNum(d) || Sk.ffi.isUndefined(d), d);
          var e = Sk.ffi.remapToJs(b), f = Sk.ffi.remapToJs(c), g = Sk.ffi.remapToJs(d);
          Sk.ffi.referenceToPy(new THREE.PointLight(e, f, g), 'PointLight', void 0, a);
        });
        b.__getattr__ = Sk.ffi.functionPy(function (a, b) {
          switch (b) {
          case 'distance':
            return Sk.ffi.numberToFloatPy(Sk.ffi.remapToJs(a).distance);
          case 'intensity':
            return Sk.ffi.numberToFloatPy(Sk.ffi.remapToJs(a).intensity);
          default:
            return u('PointLight', a, b);
          }
        });
        b.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          switch (b) {
          case 'distance':
            Sk.ffi.checkArgType('distance', r, Sk.ffi.isNum(c), c);
            Sk.ffi.remapToJs(a).distance = Sk.ffi.remapToJs(c);
            break;
          case 'intensity':
            Sk.ffi.checkArgType('intensity', r, Sk.ffi.isNum(c), c);
            Sk.ffi.remapToJs(a).intensity = Sk.ffi.remapToJs(c);
            break;
          default:
            return t('PointLight', a, b, c);
          }
        });
        b.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          var b = {};
          b.color = a.color;
          b.intensity = a.intensity;
          b.distance = a.distance;
          return Sk.builtin.stringToPy('PointLight(' + JSON.stringify(b) + ')');
        });
        b.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.builtin.stringToPy('PointLight(' + [
            a.color,
            a.intensity,
            a.distance
          ].map(function (a) {
            return JSON.stringify(a);
          }).join(', ') + ')');
        });
      }, 'PointLight', []);
      a.Line = Sk.ffi.buildClass(a, function (b, c) {
        c.__init__ = Sk.ffi.functionPy(function (a, b, c, d) {
          b = Sk.ffi.remapToJs(b);
          c = Sk.ffi.remapToJs(c);
          d = Sk.ffi.remapToJs(d);
          a.v = new THREE.Line(b, c, d);
        });
        c.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'position':
            return k(d.position);
          case 'quaternion':
            return Sk.ffi.callsim(a.Quaternion, Sk.ffi.referenceToPy(d.quaternion, 'Quaternion'));
          case 'rotation':
            return k(d.rotation);
          case 'eulerOrder':
            return Sk.builtin.stringToPy(d.eulerOrder);
          case 'scale':
            return k(d.scale);
          case 'up':
            return k(d.up);
          case 'useQuaternion':
            return d.useQuaternion;
          case 'lookAt':
            return q(b);
          case 'type':
            return Sk.ffi.numberToIntPy(d.type);
          }
        });
        c.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          a = Sk.ffi.remapToJs(a);
          c = Sk.ffi.remapToJs(c);
          switch (b) {
          case 'type':
            if (d(c))
              a.type = c;
            else
              throw Error('type must be either LineStrip or LinePieces');
            break;
          default:
            throw Error(b + ' is not an attribute of Line');
          }
        });
        c.__str__ = Sk.ffi.functionPy(function (a) {
          return Sk.builtin.stringToPy('Line');
        });
        c.__repr__ = Sk.ffi.functionPy(function (a) {
          return Sk.builtin.stringToPy('Line');
        });
      }, 'Line', []);
      a.LineBasicMaterial = Sk.ffi.buildClass(a, function (b, c) {
        c.__init__ = Sk.ffi.functionPy(function (a, b) {
          a.tp$name = 'LineBasicMaterial';
          b = Sk.ffi.remapToJs(b);
          a.v = new THREE.LineBasicMaterial(b);
        });
        c.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          b = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'color':
            return Sk.ffi.callsim(a.Color, Sk.ffi.referenceToPy(b.color, 'Color'));
          case 'opacity':
            return Sk.ffi.numberToFloatPy(b.opacity);
          }
        });
        c.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          a = Sk.ffi.remapToJs(a);
          c = Sk.ffi.remapToJs(c);
          switch (b) {
          case 'color':
            b = c;
            b = f(b) ? b.hasOwnProperty('r') && b.hasOwnProperty('g') && b.hasOwnProperty('b') ? d(b.r) && d(b.g) && d(b.b) : !1 : !1;
            if (b)
              a.color = c;
            else
              throw new Sk.builtin.TypeError('\'opacity\' attribute must be a <type \'Color\'>.');
            break;
          case 'opacity':
            if (d(c))
              a.opacity = c;
            else
              throw new Sk.builtin.TypeError('\'opacity\' attribute must be a <type \'float\'>.');
            break;
          default:
            throw Error(b + ' is not an attribute of LineBasicMaterial');
          }
        });
        c.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          var b = {};
          b.color = a.color;
          b.opacity = a.opacity;
          return Sk.builtin.stringToPy('LineBasicMaterial(' + JSON.stringify(b) + ')');
        });
        c.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.builtin.stringToPy('LineBasicMaterial(' + [{}].map(function (a) {
            return JSON.stringify(a);
          }).join(', ') + ')');
        });
      }, 'LineBasicMaterial', []);
      Sk.three.meshGetAttr = function (b, c, d) {
        var e = Sk.ffi.remapToJs(c);
        switch (d) {
        case 'attitude':
          return h(e.quaternion);
        case 'id':
          return Sk.ffi.numberToIntPy(e.id);
        case 'geometry':
          return Sk.ffi.callsim(a.Geometry, Sk.ffi.referenceToPy(e.geometry, 'Geometry'));
        case 'material':
          return Sk.ffi.callsim(a[Sk.three.MATERIAL], Sk.ffi.referenceToPy(e.material, Sk.three.MATERIAL));
        case 'matrixAutoUpdate':
          return e.matrixAutoUpdate;
        case 'name':
          return Sk.builtin.stringToPy(e.name);
        case 'position':
          return k(e.position);
        case 'rotation':
          return k(e.rotation);
        case 'eulerOrder':
          return Sk.builtin.stringToPy(e.eulerOrder);
        case 'scale':
          return k(e.scale);
        case 'up':
          return k(e.up);
        case 'lookAt':
          return q(c);
        case 'rotateOnAxis':
          return Sk.ffi.callableToPy(a, 'rotateOnAxis', function (a, b, d) {
            Sk.ffi.checkMethodArgs('rotateOnAxis', arguments, 2, 2);
            Sk.ffi.checkArgType('axis', 'Vector3', Sk.ffi.isInstance(b, 'Vector3'), b);
            Sk.ffi.checkArgType('angle', r, Sk.ffi.isNum(d), d);
            e.rotateOnAxis(Sk.ffi.remapToJs(b), Sk.ffi.remapToJs(d));
            return c;
          });
        case 'rotateX':
        case 'rotateY':
        case 'rotateZ':
          return Sk.ffi.callableToPy(a, d, function (a, b) {
            Sk.ffi.checkMethodArgs(d, arguments, 1, 1);
            Sk.ffi.checkArgType('axis', r, Sk.ffi.isNum(b), b);
            e[d](Sk.ffi.remapToJs(b));
            return c;
          });
        case 'setGeometry':
          return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
            b.__init__ = Sk.ffi.functionPy(function (a) {
              a.tp$name = 'setGeometry';
            });
            b.__call__ = Sk.ffi.functionPy(function (a, b) {
              var c = Sk.ffi.remapToJs(b);
              e.setGeometry(c);
            });
            b.__str__ = Sk.ffi.functionPy(function (a) {
              return Sk.builtin.stringToPy('setGeometry');
            });
            b.__repr__ = Sk.ffi.functionPy(function (a) {
              return Sk.builtin.stringToPy('setGeometry');
            });
          }, 'setGeometry', []));
        case 'translateOnAxis':
          return Sk.ffi.callableToPy(a, 'translateOnAxis', function (a, b, d) {
            Sk.ffi.checkMethodArgs('translateOnAxis', arguments, 2, 2);
            Sk.ffi.checkArgType('axis', 'Vector3', Sk.ffi.isInstance(b, 'Vector3'), b);
            Sk.ffi.checkArgType('distance', r, Sk.ffi.isNum(d), d);
            e.translateOnAxis(Sk.ffi.remapToJs(b), Sk.ffi.remapToJs(d));
            return c;
          });
        case 'translateX':
        case 'translateY':
        case 'translateZ':
          return Sk.ffi.callableToPy(a, d, function (a, b) {
            Sk.ffi.checkMethodArgs(d, arguments, 1, 1);
            Sk.ffi.checkArgType('distance', r, Sk.ffi.isNum(b), b);
            e[d](Sk.ffi.remapToJs(b));
            return c;
          });
        case 'updateMatrix':
          return Sk.ffi.callableToPy(a, 'updateMatrix', function (a) {
            Sk.ffi.checkMethodArgs('updateMatrix', arguments, 0, 0);
            e.updateMatrix();
          });
        default:
          return Sk.three.object3DGetAttr(b, c, d);
        }
      };
      Sk.three.meshSetAttr = function (a, b, c, d) {
        var f = Sk.ffi.remapToJs(b), g = Sk.ffi.remapToJs(d);
        switch (c) {
        case 'attitude':
          l(Sk.three.MESH, b, 'quaternion', d, c);
          break;
        case 'matrixAutoUpdate':
          Sk.ffi.checkArgType('matrixAutoUpdate', Sk.ffi.PyType.BOOL, Sk.ffi.isBool(d), d);
          a = Sk.ffi.remapToJs(d);
          f.matrixAutoUpdate = a;
          break;
        case 'name':
          Sk.ffi.checkArgType('name', Sk.ffi.PyType.STR, Sk.builtin.isStringPy(d), d);
          f.name = g;
          break;
        case 'position':
        case 'rotation':
        case 'scale':
        case 'up':
          p(f, c, d);
          break;
        case 'quaternion':
          f.quaternion = g;
          break;
        case 'eulerOrder':
          if (e(g))
            f.eulerOrder = g;
          else
            throw Error(c + ' must be a string');
          break;
        case 'useQuaternion':
          f.useQuaternion = g;
          break;
        default:
          return Sk.three.object3DSetAttr(a, b, c, d);
        }
      };
      a[Sk.three.MESH] = Sk.ffi.buildClass(a, function (a, b) {
        b.__init__ = Sk.ffi.functionPy(function (a, b, c) {
          Sk.ffi.checkMethodArgs(Sk.three.MESH, arguments, 1, 2);
          Sk.ffi.checkArgType('geometry', 'Geometry', B(b), b);
          Sk.ffi.checkArgType('material', Sk.three.MATERIAL, w(c), c);
          Sk.ffi.referenceToPy(new THREE[Sk.three.MESH](Sk.ffi.remapToJs(b), Sk.ffi.remapToJs(c)), Sk.three.MESH, void 0, a);
        });
        b.__getattr__ = Sk.ffi.functionPy(function (a, b) {
          return Sk.three.meshGetAttr(Sk.three.MESH, a, b);
        });
        b.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          return Sk.three.meshSetAttr(Sk.three.MESH, a, b, c);
        });
        b.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          var b = {};
          b.id = a.id;
          b.name = a.name;
          return Sk.builtin.stringToPy(Sk.three.MESH + '(' + JSON.stringify(b) + ')');
        });
        b.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.builtin.stringToPy(Sk.three.MESH + '(' + [].map(function (a) {
            return JSON.stringify(a);
          }).join(', ') + ')');
        });
      }, Sk.three.MESH, []);
      a[Sk.three.MATERIAL] = Sk.ffi.buildClass(a, function (a, b) {
        b.__init__ = Sk.ffi.functionPy(function (a, b) {
          Sk.ffi.checkMethodArgs(Sk.three.MATERIAL, arguments, 0, 1);
          f(b) ? Sk.ffi.referenceToPy(Sk.ffi.remapToJs(b), Sk.three.MATERIAL, void 0, a) : Sk.ffi.referenceToPy(new THREE[Sk.three.MATERIAL](), Sk.three.MATERIAL, void 0, a);
        });
        b.__getattr__ = Sk.ffi.functionPy(function (a, b) {
          switch (b) {
          default:
            return y(Sk.three.MATERIAL, a, b);
          }
        });
        b.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          switch (b) {
          default:
            return v(Sk.three.MATERIAL, a, b, c);
          }
        });
        b.__str__ = Sk.ffi.functionPy(function (a) {
          return Sk.builtin.stringToPy(Sk.three.MATERIAL + '()');
        });
        b.__repr__ = Sk.ffi.functionPy(function (a) {
          return Sk.builtin.stringToPy(Sk.three.MATERIAL + '()');
        });
      }, Sk.three.MATERIAL, []);
      a.MeshBasicMaterial = Sk.ffi.buildClass(a, function (b, f) {
        f.__init__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(b);
          Sk.ffi.referenceToPy(new THREE.MeshBasicMaterial(c), 'MeshBasicMaterial', void 0, a);
        });
        f.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'color':
            return Sk.ffi.callsim(a.Color, Sk.ffi.referenceToPy(d.color, 'Color'));
          case 'wireframe':
            return d.wireframe;
          case 'wireframeLinewidth':
            return Sk.ffi.numberToFloatPy(d.wireframeLinewidth);
          default:
            return y('MeshBasicMaterial', b, c);
          }
        });
        f.__setattr__ = Sk.ffi.functionPy(function (a, b, f) {
          var g = Sk.ffi.remapToJs(a), h = Sk.ffi.remapToJs(f);
          switch (b) {
          case 'color':
            g.color = new THREE.Color(h);
            break;
          case 'name':
            if (e(h))
              g.name = h;
            else
              throw Error(b + ' must be a string');
            break;
          case 'opacity':
            if (d(h))
              g.opacity = h;
            else
              throw new Sk.builtin.TypeError('\'opacity\' attribute must be a <type \'float\'>.');
            break;
          case 'wireframe':
            if (c(h))
              g.wireframe = h;
            else
              throw Error(b + ' must be Boolean');
            break;
          case 'wireframeLinewidth':
            if (d(h))
              g.wireframeLinewidth = h;
            else
              throw Error(b + ' must be a number');
            break;
          default:
            return v('MeshBasicMaterial', a, b, f);
          }
        });
        f.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          var b = {};
          b.color = a.color;
          b.wireframe = a.wireframe;
          b.wireframeLinewidth = a.wireframeLinewidth;
          return Sk.builtin.stringToPy('MeshBasicMaterial(' + JSON.stringify(b) + ')');
        });
        f.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          var b = {};
          b.color = a.color;
          b.wireframe = a.wireframe;
          b.wireframeLinewidth = a.wireframeLinewidth;
          return Sk.builtin.stringToPy('MeshBasicMaterial(' + [b].map(function (a) {
            return JSON.stringify(a);
          }).join(', ') + ')');
        });
      }, 'MeshBasicMaterial', []);
      a.MeshLambertMaterial = Sk.ffi.buildClass(a, function (b, f) {
        f.__init__ = Sk.ffi.functionPy(function (a, b) {
          Sk.ffi.checkMethodArgs('MeshLambertMaterial', arguments, 0, 1);
          var c = Sk.ffi.remapToJs(b);
          Sk.ffi.referenceToPy(new THREE.MeshLambertMaterial(c), 'MeshLambertMaterial', void 0, a);
        });
        f.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'id':
            return Sk.ffi.numberToIntPy(d.id);
          case 'color':
            return Sk.ffi.callsim(a.Color, Sk.ffi.referenceToPy(d.color, 'Color'));
          case 'name':
            return Sk.builtin.stringToPy(d.name);
          case 'opacity':
            return Sk.ffi.numberToFloatPy(d.opacity);
          default:
            return y('MeshLambertMaterial', b, c);
          }
        });
        f.__setattr__ = Sk.ffi.functionPy(function (a, b, f) {
          var g = Sk.ffi.remapToJs(a), h = Sk.ffi.remapToJs(f);
          switch (b) {
          case 'color':
            g.color = new THREE.Color(h);
            break;
          case 'name':
            if (e(h))
              g.name = h;
            else
              throw Error(b + ' must be a string');
            break;
          case 'opacity':
            if (d(h))
              g.opacity = h;
            else
              throw new Sk.builtin.TypeError('\'opacity\' attribute must be a <type \'float\'>.');
            break;
          case 'wireframe':
            if (c(h))
              g.wireframe = h;
            else
              throw Error(b + ' must be Boolean');
            break;
          case 'wireframeLinewidth':
            if (d(h))
              g.wireframeLinewidth = h;
            else
              throw Error(b + ' must be a number');
            break;
          default:
            return v('MeshLambertMaterial', a, b, f);
          }
        });
        f.__str__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.remapToJs(a);
          return Sk.builtin.stringToPy('MeshLambertMaterial(' + JSON.stringify({}) + ')');
        });
        f.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          var b = {};
          b.color = a.color;
          return Sk.builtin.stringToPy('MeshLambertMaterial(' + [b].map(function (a) {
            return JSON.stringify(a);
          }).join(', ') + ')');
        });
      }, 'MeshLambertMaterial', []);
      a.MeshNormalMaterial = Sk.ffi.buildClass(a, function (a, b) {
        b.__init__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(b);
          Sk.ffi.referenceToPy(new THREE.MeshNormalMaterial(c), 'MeshNormalMaterial', void 0, a);
        });
        b.__getattr__ = Sk.ffi.functionPy(function (a, b) {
          return y('MeshNormalMaterial', a, b);
        });
        b.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          return v('MeshNormalMaterial', a, b, c);
        });
        b.__str__ = Sk.ffi.functionPy(function (a) {
          return Sk.builtin.stringToPy('MeshNormalMaterial(' + JSON.stringify({}) + ')');
        });
        b.__repr__ = Sk.ffi.functionPy(function (a) {
          return Sk.builtin.stringToPy('MeshNormalMaterial(' + [{}].map(function (a) {
            return JSON.stringify(a);
          }).join(', ') + ')');
        });
      }, 'MeshNormalMaterial', []);
      a.MeshPhongMaterial = Sk.ffi.buildClass(a, function (a, b) {
        b.__init__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(b);
          Sk.ffi.referenceToPy(new THREE.MeshPhongMaterial(c), 'MeshPhongMaterial', void 0, a);
        });
        b.__getattr__ = Sk.ffi.functionPy(function (a, b) {
          return y('MeshPhongMaterial', a, b);
        });
        b.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          return v('MeshPhongMaterial', a, b, c);
        });
        b.__str__ = Sk.ffi.functionPy(function (a) {
          return Sk.builtin.stringToPy('MeshPhongMaterial(' + JSON.stringify({}) + ')');
        });
        b.__repr__ = Sk.ffi.functionPy(function (a) {
          return Sk.builtin.stringToPy('MeshPhongMaterial(' + [{}].map(function (a) {
            return JSON.stringify(a);
          }).join(', ') + ')');
        });
      }, 'MeshPhongMaterial', []);
      a[Sk.three.PARTICLE_SYSTEM] = Sk.ffi.buildClass(a, function (a, b) {
        b.__init__ = Sk.ffi.functionPy(function (a, b, c) {
          Sk.ffi.checkMethodArgs(Sk.three.PARTICLE_SYSTEM, arguments, 0, 2);
          Sk.ffi.checkArgType('geometry', 'Geometry', B(b), b);
          Sk.ffi.checkArgType('material', Sk.three.MATERIAL, w(c), c);
          Sk.ffi.referenceToPy(new THREE.ParticleSystem(Sk.ffi.remapToJs(b), Sk.ffi.remapToJs(c)), Sk.three.PARTICLE_SYSTEM, void 0, a);
        });
        b.__getattr__ = Sk.ffi.functionPy(function (a, b) {
          switch (b) {
          default:
            return Sk.three.object3DGetAttr(Sk.three.PARTICLE_SYSTEM, a, b);
          }
        });
        b.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          switch (b) {
          default:
            return Sk.three.object3DSetAttr(Sk.three.PARTICLE_SYSTEM, a, b, c);
          }
        });
        b.__str__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.remapToJs(a);
          var b = [].map(function (b) {
              return Sk.ffi.gattr(a, b);
            }).map(function (a) {
              return Sk.ffi.remapToJs(Sk.ffh.str(a));
            });
          return Sk.builtin.stringToPy(Sk.three.PARTICLE_SYSTEM + '(' + b.join(', ') + ')');
        });
        b.__repr__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.remapToJs(a);
          var b = [].map(function (b) {
              return Sk.ffi.gattr(a, b);
            }).map(function (a) {
              return Sk.ffi.remapToJs(Sk.ffh.repr(a));
            });
          return Sk.builtin.stringToPy(Sk.three.PARTICLE_SYSTEM + '(' + b.join(', ') + ')');
        });
      }, Sk.three.PARTICLE_SYSTEM, []);
      a[Sk.three.PARTICLE_SYSTEM_MATERIAL] = Sk.ffi.buildClass(a, function (a, b) {
        b.__init__ = Sk.ffi.functionPy(function (a, b) {
          Sk.ffi.checkMethodArgs(Sk.three.PARTICLE_SYSTEM_MATERIAL, arguments, 0, 1);
          if (f(b) && ('object' !== typeof b || null !== b) && Sk.ffi.isInstance(b, Sk.three.PARTICLE_SYSTEM_MATERIAL))
            Sk.ffi.referenceToPy(Sk.ffi.remapToJs(b), Sk.three.PARTICLE_SYSTEM_MATERIAL, void 0, a);
          else {
            var c = Sk.ffi.remapToJs(b);
            Sk.ffi.referenceToPy(new THREE[Sk.three.PARTICLE_SYSTEM_MATERIAL](c), Sk.three.PARTICLE_SYSTEM_MATERIAL, void 0, a);
          }
        });
        b.__getattr__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a);
          switch (b) {
          case 'color':
            return H(c.color);
          case 'size':
            return Sk.ffi.numberToFloatPy(c.size);
          case 'sizeAttenuation':
            return Sk.ffi.booleanToPy(c.sizeAttenuation);
          case 'vertexColors':
            return Sk.ffi.booleanToPy(c.vertexColors);
          case 'fog':
            return Sk.ffi.booleanToPy(c.fog);
          default:
            return y(Sk.three.PARTICLE_SYSTEM_MATERIAL, a, b);
          }
        });
        b.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          var d = Sk.ffi.remapToJs(a);
          switch (b) {
          case 'color':
            Sk.ffi.checkArgType(b, 'Color', Sk.ffi.isInstance(c, 'Color'), c);
            d.color = Sk.ffi.remapToJs(c);
            break;
          case 'size':
            Sk.ffi.checkArgType(b, Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(c), c);
            d.size = Sk.ffi.remapToJs(c);
            break;
          case 'sizeAttenuation':
            Sk.ffi.checkArgType(b, Sk.ffi.PyType.BOOL, Sk.ffi.isBool(c), c);
            d.sizeAttenuation = Sk.ffi.remapToJs(c);
            break;
          case 'vertexColors':
            Sk.ffi.checkArgType(b, Sk.ffi.PyType.BOOL, Sk.ffi.isBool(c), c);
            d.vertexColors = Sk.ffi.remapToJs(c);
            break;
          case 'fog':
            Sk.ffi.checkArgType(b, Sk.ffi.PyType.BOOL, Sk.ffi.isBool(c), c);
            d.fog = Sk.ffi.remapToJs(c);
            break;
          default:
            return v(Sk.three.PARTICLE_SYSTEM_MATERIAL, a, b, c);
          }
        });
        b.__str__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.remapToJs(a);
          var b = [
              'color',
              'size',
              'sizeAttenuation',
              'vertexColors',
              'fog'
            ].map(function (b) {
              return [
                b,
                Sk.ffi.remapToJs(Sk.ffh.str(Sk.ffi.gattr(a, b)))
              ].join('=');
            });
          return Sk.builtin.stringToPy(Sk.three.PARTICLE_SYSTEM_MATERIAL + '(' + b.join(', ') + ')');
        });
        b.__repr__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.remapToJs(a);
          var b = [
              'color',
              'size',
              'sizeAttenuation',
              'vertexColors',
              'fog'
            ].map(function (b) {
              return Sk.ffi.gattr(a, b);
            }).map(function (a) {
              return Sk.ffi.remapToJs(Sk.ffh.repr(a));
            });
          return Sk.builtin.stringToPy(Sk.three.PARTICLE_SYSTEM_MATERIAL + '(' + b.join(', ') + ')');
        });
      }, Sk.three.PARTICLE_SYSTEM_MATERIAL, []);
      a[Sk.three.MATRIX_3] = Sk.ffi.buildClass(a, function (b, c) {
        c.__init__ = Sk.ffi.functionPy(function (a, b, c, d, e, g, h, k, l, m) {
          Sk.ffi.checkMethodArgs(Sk.three.MATRIX_3, arguments, 0, 9);
          if (f(b))
            if (Sk.ffi.isInstance(b, Sk.three.MATRIX_3))
              Sk.ffi.referenceToPy(Sk.ffi.remapToJs(b), Sk.three.MATRIX_3, void 0, a);
            else {
              Sk.ffi.checkMethodArgs(Sk.three.MATRIX_3, arguments, 9, 9);
              Sk.ffi.checkArgType('n11', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(b), b);
              Sk.ffi.checkArgType('n12', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(c), c);
              Sk.ffi.checkArgType('n13', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(d), d);
              Sk.ffi.checkArgType('n21', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(e), e);
              Sk.ffi.checkArgType('n22', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(g), g);
              Sk.ffi.checkArgType('n23', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(h), h);
              Sk.ffi.checkArgType('n31', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(k), k);
              Sk.ffi.checkArgType('n32', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(l), l);
              Sk.ffi.checkArgType('n33', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(m), m);
              var n = Sk.ffi.remapToJs(b), p = Sk.ffi.remapToJs(c), q = Sk.ffi.remapToJs(d), r = Sk.ffi.remapToJs(e), s = Sk.ffi.remapToJs(g), t = Sk.ffi.remapToJs(h), u = Sk.ffi.remapToJs(k), x = Sk.ffi.remapToJs(l), v = Sk.ffi.remapToJs(m);
              Sk.ffi.referenceToPy(new THREE.Matrix3(n, p, q, r, s, t, u, x, v), Sk.three.MATRIX_3, void 0, a);
            }
          else
            Sk.ffi.referenceToPy(new THREE.Matrix3(), Sk.three.MATRIX_3, void 0, a);
        });
        c.__mul__ = Sk.ffi.functionPy(function (b, c) {
          switch (Sk.ffi.getType(c)) {
          case Sk.ffi.PyType.INSTANCE:
            if (Sk.ffi.isInstance(c, Sk.three.MATRIX_3)) {
              var d = Sk.ffi.remapToJs(b).elements, e = d[0], f = d[3], g = d[6], h = d[1], k = d[4], l = d[7], m = d[2], n = d[5], p = d[8], d = Sk.ffi.remapToJs(c).elements, q = d[0], r = d[3], s = d[6], t = d[1], u = d[4], x = d[7], v = d[2], w = d[5], d = d[8], d = new THREE.Matrix3(e * q + f * t + g * v, e * r + f * u + g * w, e * s + f * x + g * d, h * q + k * t + l * v, h * r + k * u + l * w, h * s + k * x + l * d, m * q + n * t + p * v, m * r + n * u + p * w, m * s + n * x + p * d);
              return Sk.ffi.callsim(a[Sk.three.MATRIX_3], Sk.ffi.referenceToPy(d, Sk.three.MATRIX_3));
            }
            throw Sk.ffi.err.operand('other').toOperation('*').mustHaveType([
              Sk.ffi.PyType.FLOAT,
              Sk.three.MATRIX_3
            ]);
          case Sk.ffi.PyType.FLOAT:
            return d = Sk.ffi.remapToJs(b).elements, e = d[0], f = d[3], g = d[6], h = d[1], k = d[4], l = d[7], m = d[2], n = d[5], p = d[8], d = Sk.ffi.remapToJs(c), d = new THREE.Matrix3(e * d, f * d, g * d, h * d, k * d, l * d, m * d, n * d, p * d), Sk.ffi.callsim(a[Sk.three.MATRIX_3], Sk.ffi.referenceToPy(d, Sk.three.MATRIX_3));
          default:
            throw Sk.ffi.err.operand('other').toOperation('*').mustHaveType([
              Sk.ffi.PyType.FLOAT,
              Sk.three.MATRIX_3
            ]);
          }
        });
        c.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'clone':
            return Sk.ffi.callableToPy(a, c, function (b) {
              Sk.ffi.checkMethodArgs(c, arguments, 0, 0);
              return Sk.ffi.callsim(a[Sk.three.MATRIX_3], Sk.ffi.referenceToPy(d.clone(), Sk.three.MATRIX_3));
            });
          case 'copy':
            return Sk.ffi.callableToPy(a, c, function (a, e) {
              Sk.ffi.checkMethodArgs(c, arguments, 1, 1);
              Sk.ffi.checkArgType('matrix', Sk.three.MATRIX_3, Sk.ffi.isInstance(e, Sk.three.MATRIX_3), e);
              d.copy(Sk.ffi.remapToJs(e));
              return b;
            });
          case 'determinant':
            return Sk.ffi.callableToPy(a, c, function (a) {
              Sk.ffi.checkMethodArgs(c, arguments, 0, 0);
              return Sk.ffi.numberToFloatPy(d.determinant());
            });
          case 'getNormalMatrix':
            return Sk.ffi.callableToPy(a, c, function (a, e) {
              Sk.ffi.checkMethodArgs(c, arguments, 1, 1);
              Sk.ffi.checkArgType('m', Sk.three.MATRIX_4, Sk.ffi.isInstance(e, Sk.three.MATRIX_4), e);
              d.getNormalMatrix(Sk.ffi.remapToJs(e));
              return b;
            });
          case 'identity':
            return Sk.ffi.callableToPy(a, c, function (a) {
              Sk.ffi.checkMethodArgs(c, arguments, 0, 0);
              d.identity();
              return b;
            });
          case 'set':
            return Sk.ffi.callableToPy(a, c, function (a, e, f, g, h, k, l, m, n, p) {
              Sk.ffi.checkMethodArgs(c, arguments, 9, 9);
              Sk.ffi.checkArgType('n11', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(e), e);
              Sk.ffi.checkArgType('n12', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(f), f);
              Sk.ffi.checkArgType('n13', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(g), g);
              Sk.ffi.checkArgType('n21', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(h), h);
              Sk.ffi.checkArgType('n22', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(k), k);
              Sk.ffi.checkArgType('n23', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(l), l);
              Sk.ffi.checkArgType('n31', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(m), m);
              Sk.ffi.checkArgType('n32', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(n), n);
              Sk.ffi.checkArgType('n33', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(p), p);
              var q = Sk.ffi.remapToJs(e), r = Sk.ffi.remapToJs(f), s = Sk.ffi.remapToJs(g), t = Sk.ffi.remapToJs(h), u = Sk.ffi.remapToJs(k), x = Sk.ffi.remapToJs(l), v = Sk.ffi.remapToJs(m), w = Sk.ffi.remapToJs(n), I = Sk.ffi.remapToJs(p);
              d.set(q, r, s, t, u, x, v, w, I);
              return b;
            });
          case 'transpose':
            return Sk.ffi.callableToPy(a, c, function (a) {
              Sk.ffi.checkMethodArgs(c, arguments, 0, 0);
              d.transpose();
              return b;
            });
          default:
            throw Sk.ffi.err.attribute(c).isNotGetableOnType(Sk.three.MATRIX_3);
          }
        });
        c.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          switch (b) {
          default:
            throw Sk.ffi.err.attribute(b).isNotSetableOnType(Sk.three.MATRIX_3);
          }
        });
        c.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a).elements;
          a = [
            [
              a[0],
              a[3],
              a[6]
            ],
            [
              a[1],
              a[4],
              a[7]
            ],
            [
              a[2],
              a[5],
              a[8]
            ]
          ].map(function (a) {
            return a.map(function (a) {
              return Sk.ffi.remapToJs(Sk.ffh.str(Sk.ffi.numberToFloatPy(a)));
            }).join(' ');
          }).join('\n');
          return Sk.builtin.stringToPy(a);
        });
        c.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a).elements;
          a = [
            a[0],
            a[3],
            a[6],
            a[1],
            a[4],
            a[7],
            a[2],
            a[5],
            a[8]
          ].map(function (a) {
            return Sk.ffi.remapToJs(Sk.ffh.repr(Sk.ffi.numberToFloatPy(a)));
          }).join(', ');
          return Sk.builtin.stringToPy(Sk.three.MATRIX_3 + '(' + a + ')');
        });
      }, Sk.three.MATRIX_3, []);
      a[Sk.three.MATRIX_4] = Sk.ffi.buildClass(a, function (b, c) {
        c.__init__ = Sk.ffi.functionPy(function (a, b) {
          Sk.ffi.checkMethodArgs(Sk.three.MATRIX_4, arguments, 0, 1);
          f(b) && Sk.ffi.isInstance(b, Sk.three.MATRIX_4) ? Sk.ffi.referenceToPy(Sk.ffi.remapToJs(b), Sk.three.MATRIX_4, void 0, a) : Sk.ffi.referenceToPy(new THREE.Matrix4(), Sk.three.MATRIX_4, void 0, a);
        });
        c.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'makeRotationX':
            return Sk.ffi.callableToPy(a, c, function (b, e) {
              Sk.ffi.checkMethodArgs(c, arguments, 1, 1);
              Sk.ffi.checkArgType('theta', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(e), e);
              var f = Sk.ffi.remapToJs(e);
              return Sk.ffi.callsim(a[Sk.three.MATRIX_4], Sk.ffi.referenceToPy(d.makeRotationX(f), Sk.three.MATRIX_4));
            });
          default:
            throw Sk.ffi.err.attribute(c).isNotGetableOnType(Sk.three.MATRIX_4);
          }
        });
        c.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          switch (b) {
          default:
            throw Sk.ffi.err.attribute(b).isNotSetableOnType(Sk.three.MATRIX_4);
          }
        });
        c.__str__ = Sk.ffi.functionPy(function (a) {
          return Sk.builtin.stringToPy(Sk.three.MATRIX_4 + '()');
        });
        c.__repr__ = Sk.ffi.functionPy(function (a) {
          return Sk.builtin.stringToPy(Sk.three.MATRIX_4 + '()');
        });
      }, Sk.three.MATRIX_4, []);
      a[Sk.three.FACE_3] = Sk.ffi.buildClass(a, function (b, c) {
        c.__init__ = Sk.ffi.functionPy(function (a, b, c, d, e, g, h) {
          if (f(b) && Sk.ffi.isInstance(b, Sk.three.FACE_3)) {
            Sk.ffi.checkMethodArgs(Sk.three.FACE_3, arguments, 1, 1);
            var k = Sk.ffi.remapToJs(b);
            Sk.ffi.checkArgType('a', '!?', f(k), b);
            Sk.ffi.checkArgType('a', '?!', k instanceof THREE.Face3, b);
          } else {
            Sk.ffi.checkMethodArgs(Sk.three.FACE_3, arguments, 3, 6);
            Sk.ffi.checkArgType('a', s, Sk.ffi.isInt(b), b);
            Sk.ffi.checkArgType('b', s, Sk.ffi.isInt(c), c);
            Sk.ffi.checkArgType('c', s, Sk.ffi.isInt(d), d);
            f(e) && Sk.ffi.checkArgType('normal', 'Euclidean3', Sk.ffi.isInstance(e, 'Euclidean3'), e);
            var k = Sk.ffi.remapToJs(b), l = Sk.ffi.remapToJs(c), n = Sk.ffi.remapToJs(d), p = m('normal', e), q = Sk.ffi.remapToJs(g), r = Sk.ffi.remapToJs(h), k = new THREE.Face3(k, l, n, p, q, r);
          }
          Sk.ffi.referenceToPy(k, Sk.three.FACE_3, void 0, a);
        });
        c.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'a':
            return Sk.ffi.numberToIntPy(d.a);
          case 'b':
            return Sk.ffi.numberToIntPy(d.b);
          case 'c':
            return Sk.ffi.numberToIntPy(d.c);
          case 'color':
            return Sk.ffi.callsim(a.Color, Sk.ffi.referenceToPy(d.color, 'Color'));
          case 'centroid':
            return k(d.centroid);
          case 'normal':
            return k(d.normal);
          case 'vertexNormals':
            return Sk.ffi.listPy(d.vertexNormals.map(function (a) {
              return k(a);
            }));
          default:
            throw Sk.ffi.err.attribute(c).isNotGetableOnType(Sk.three.FACE_3);
          }
        });
        c.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          Sk.ffi.remapToJs(a);
          switch (b) {
          default:
            throw Sk.ffi.err.attribute(b).isNotSetableOnType(Sk.three.FACE_3);
          }
        });
        c.__str__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.remapToJs(a);
          var b = [
              'a',
              'b',
              'c',
              'normal'
            ].map(function (b) {
              return Sk.ffi.gattr(a, b);
            }).map(function (a) {
              return Sk.ffi.remapToJs(Sk.ffh.str(a));
            });
          return Sk.builtin.stringToPy(Sk.three.FACE_3 + '(' + b.join(', ') + ')');
        });
        c.__repr__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.remapToJs(a);
          var b = [
              'a',
              'b',
              'c',
              'normal'
            ].map(function (b) {
              return Sk.ffi.gattr(a, b);
            }).map(function (a) {
              return Sk.ffi.remapToJs(Sk.ffh.repr(a));
            });
          return Sk.builtin.stringToPy(Sk.three.FACE_3 + '(' + b.join(', ') + ')');
        });
      }, Sk.three.FACE_3, []);
      a.Intersection = Sk.ffi.buildClass(a, function (b, c) {
        c.__init__ = Sk.ffi.functionPy(function (a, b, c, d) {
          switch (Sk.ffi.checkMethodArgs('Intersection', arguments, 1, 3)) {
          case 1:
            Sk.ffi.checkMethodArgs('Intersection', arguments, 1, 1);
            Sk.ffi.referenceToPy(Sk.ffi.remapToJs(b), 'Intersection', void 0, a);
            break;
          default:
            Sk.ffi.checkMethodArgs('Intersection', arguments, 3, 3);
            Sk.ffi.checkArgType('distance', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(b), b);
            Sk.ffi.checkArgType('point', 'Euclidean3', Sk.ffi.isInstance(c, 'Euclidean3'), c);
            Sk.ffi.checkArgType('face', Sk.three.FACE_3, Sk.ffi.isInstance(d, Sk.three.FACE_3), d);
            var e = {};
            e.distance = Sk.ffi.remapToJs(b);
            e.point = m('point', c);
            e.face = Sk.ffi.remapToJs(d);
            Sk.ffi.referenceToPy(e, 'Intersection', void 0, a);
          }
        });
        c.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'distance':
            return Sk.ffi.numberToFloatPy(d.distance);
          case 'point':
            return k(d.point);
          case 'face':
            var e = d.face;
            return !f(e) || 'object' === typeof e && null === e ? Sk.builtin.none.none$ : Sk.ffi.callsim(a[Sk.three.FACE_3], Sk.ffi.referenceToPy(d.face, Sk.three.FACE_3));
          case 'object':
            return Sk.ffi.callsim(a[Sk.three.OBJECT_3D], Sk.ffi.referenceToPy(d.object, Sk.three.OBJECT_3D));
          default:
            throw Sk.ffi.err.attribute(c).isNotGetableOnType('Intersection');
          }
        });
        c.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          Sk.ffi.remapToJs(a);
          Sk.ffi.remapToJs(c);
          switch (b) {
          default:
            throw Sk.ffi.err.attribute(b).isNotSetableOnType('Intersection');
          }
        });
        c.__str__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.remapToJs(a);
          var b = [
              'distance',
              'point',
              'face'
            ].map(function (b) {
              return Sk.ffi.gattr(a, b);
            }).map(function (a) {
              return Sk.ffi.remapToJs(Sk.ffh.str(a));
            });
          return Sk.builtin.stringToPy('Intersection(' + b.join(', ') + ')');
        });
        c.__repr__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.remapToJs(a);
          var b = [
              'distance',
              'point',
              'face'
            ].map(function (b) {
              return Sk.ffi.gattr(a, b);
            }).map(function (a) {
              return Sk.ffi.remapToJs(Sk.ffh.repr(a));
            });
          return Sk.builtin.stringToPy('Intersection(' + b.join(', ') + ')');
        });
      }, 'Intersection', []);
      a.Plane = Sk.ffi.buildClass(a, function (b, c) {
        c.__init__ = Sk.ffi.functionPy(function (a, b, c) {
          Sk.ffi.checkMethodArgs('Plane', arguments, 0, 2);
          var d = m('normal', b);
          f(c) && Sk.ffi.checkArgType('offset', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(c), c);
          var e = Sk.ffi.remapToJs(c);
          Sk.ffi.referenceToPy(new THREE.Plane(d, e), 'Plane', void 0, a);
        });
        c.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'normal':
            return k(d.normal);
          case 'offset':
          case 'constant':
            return Sk.ffi.numberToFloatPy(d.constant);
          case 'copy':
            return Sk.ffi.callableToPy(a, c, function (a, e) {
              Sk.ffi.checkMethodArgs(c, arguments, 1, 1);
              Sk.ffi.checkArgType('plane', 'Plane', Sk.ffi.isInstance(e, 'Plane'), e);
              d.copy(Sk.ffi.remapToJs(e));
              return b;
            });
          case 'distanceToPoint':
            return Sk.ffi.callableToPy(a, c, function (a, b) {
              Sk.ffi.checkMethodArgs(c, arguments, 1, 1);
              return Sk.ffi.numberToFloatPy(d.distanceToPoint(m('point', b)));
            });
          case 'distanceToSphere':
            return Sk.ffi.callableToPy(a, c, function (a, b) {
              Sk.ffi.checkMethodArgs(c, arguments, 1, 1);
              Sk.ffi.checkArgType('sphere', 'Sphere', Sk.ffi.isInstance(b, 'Sphere'), b);
              return Sk.ffi.numberToFloatPy(d.distanceToSphere(Sk.ffi.remapToJs(b)));
            });
          default:
            throw Sk.ffi.err.attribute(c).isNotGetableOnType('Plane');
          }
        });
        c.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          Sk.ffi.remapToJs(a);
          Sk.ffi.remapToJs(c);
          switch (b) {
          default:
            throw Sk.ffi.err.attribute(b).isNotSetableOnType('Plane');
          }
        });
        c.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          a = [
            k(a.normal),
            Sk.ffi.numberToFloatPy(a.constant)
          ].map(function (a) {
            return Sk.ffi.remapToJs(Sk.ffh.str(a));
          });
          return Sk.builtin.stringToPy('Plane(' + a.join(', ') + ')');
        });
        c.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          a = [
            k(a.normal),
            Sk.ffi.numberToFloatPy(a.constant)
          ].map(function (a) {
            return Sk.ffi.remapToJs(Sk.ffh.repr(a));
          });
          return Sk.builtin.stringToPy('Plane(' + a.join(', ') + ')');
        });
      }, 'Plane', []);
      a.Projector = Sk.ffi.buildClass(a, function (b, c) {
        c.__init__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.checkMethodArgs('Projector', arguments, 0, 0);
          Sk.ffi.referenceToPy(new THREE.Projector(), 'Projector', void 0, a);
        });
        c.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'pickingRay':
            return Sk.ffi.callableToPy(a, c, function (b, e, f) {
              Sk.ffi.checkMethodArgs(c, arguments, 2, 2);
              var g = d.pickingRay(m('vector', e), Sk.ffi.remapToJs(f));
              return Sk.ffi.callsim(a.Raycaster, Sk.ffi.referenceToPy(g, 'Raycaster'));
            });
          case 'projectVector':
            return Sk.ffi.callableToPy(a, c, function (a, b, e) {
              Sk.ffi.checkMethodArgs(c, arguments, 2, 2);
              return k(d.projectVector(m('vector', b), Sk.ffi.remapToJs(e)));
            });
          case 'unprojectVector':
            return Sk.ffi.callableToPy(a, c, function (a, b, e) {
              Sk.ffi.checkMethodArgs(c, arguments, 2, 2);
              return k(d.unprojectVector(m('vector', b), Sk.ffi.remapToJs(e)));
            });
          default:
            throw Sk.ffi.err.attribute(c).isNotGetableOnType('Projector');
          }
        });
        c.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          Sk.ffi.remapToJs(a);
          Sk.ffi.remapToJs(c);
          switch (b) {
          default:
            throw Sk.ffi.err.attribute(b).isNotSetableOnType('Projector');
          }
        });
        c.__str__ = Sk.ffi.functionPy(function (a) {
          return Sk.builtin.stringToPy('Projector');
        });
        c.__repr__ = Sk.ffi.functionPy(function (a) {
          return Sk.builtin.stringToPy('Projector()');
        });
      }, 'Projector', []);
      a.Ray = Sk.ffi.buildClass(a, function (a, b) {
        b.__init__ = Sk.ffi.functionPy(function (a, b, c) {
          Sk.ffi.checkMethodArgs('Ray', arguments, 1, 2);
          if (Sk.ffi.isInstance(b, 'Ray'))
            Sk.ffi.referenceToPy(Sk.ffi.remapToJs(b), 'Ray', void 0, a);
          else {
            Sk.ffi.checkMethodArgs('Ray', arguments, 2, 2);
            var d = m('origin', b), e = m('direction', c);
            Sk.ffi.referenceToPy(new THREE.Ray(d, e), 'Ray', void 0, a);
          }
        });
        b.__getattr__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a);
          switch (b) {
          case 'origin':
          case 'direction':
            return k(c[b]);
          default:
            throw Sk.ffi.err.attribute(b).isNotGetableOnType('Ray');
          }
        });
        b.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          Sk.ffi.remapToJs(a);
          Sk.ffi.remapToJs(c);
          switch (b) {
          default:
            throw Sk.ffi.err.attribute(b).isNotSetableOnType('Ray');
          }
        });
        b.__str__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.remapToJs(a);
          var b = [
              'origin',
              'direction'
            ].map(function (b) {
              return Sk.ffi.gattr(a, b);
            }).map(function (a) {
              return Sk.ffi.remapToJs(Sk.ffh.str(a));
            });
          return Sk.builtin.stringToPy('Ray(' + b.join(', ') + ')');
        });
        b.__repr__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.remapToJs(a);
          var b = [
              'origin',
              'direction'
            ].map(function (b) {
              return Sk.ffi.gattr(a, b);
            }).map(function (a) {
              return Sk.ffi.remapToJs(Sk.ffh.repr(a));
            });
          return Sk.builtin.stringToPy('Ray(' + b.join(', ') + ')');
        });
      }, 'Ray', []);
      a.Raycaster = Sk.ffi.buildClass(a, function (b, c) {
        c.__init__ = Sk.ffi.functionPy(function (a, b, c, d, e) {
          Sk.ffi.checkMethodArgs('Raycaster', arguments, 0, 4);
          if (f(b) && Sk.ffi.isInstance(b, 'Raycaster'))
            Sk.ffi.referenceToPy(Sk.ffi.remapToJs(b), 'Raycaster', void 0, a);
          else {
            var g = m('origin', b), h = m('direction', c);
            f(d) && Sk.ffi.checkArgType('near', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(d), d);
            f(e) && Sk.ffi.checkArgType('far', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(e), e);
            var k = Sk.ffi.remapToJs(d);
            Sk.ffi.remapToJs(e);
            Sk.ffi.referenceToPy(new THREE.Raycaster(g, h, k), 'Raycaster', void 0, a);
          }
        });
        c.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'ray':
            return Sk.ffi.callsim(a.Ray, Sk.ffi.referenceToPy(d.ray, 'Ray'));
          case 'near':
          case 'far':
            return Sk.ffi.numberToFloatPy(d[c]);
          case 'intersectObjects':
            return Sk.ffi.callableToPy(a, c, function (b, e, f) {
              Sk.ffi.checkMethodArgs(c, arguments, 1, 2);
              Sk.ffi.checkArgType('objects', Sk.ffi.PyType.LIST, Sk.ffi.isList(e), e);
              var g = d.intersectObjects(Sk.ffi.remapToJs(e), Sk.ffi.remapToJs(f));
              return Sk.ffi.listPy(g.map(function (b) {
                return Sk.ffi.callsim(a.Intersection, Sk.ffi.referenceToPy(b, 'Intersection'));
              }));
            });
          case 'set':
            return Sk.ffi.callableToPy(a, c, function (a, e, f) {
              Sk.ffi.checkMethodArgs(c, arguments, 2, 2);
              d.set(m('origin', e), m('direction', f));
              return b;
            });
          default:
            throw Sk.ffi.err.attribute(c).isNotGetableOnType('Raycaster');
          }
        });
        c.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          Sk.ffi.remapToJs(a);
          Sk.ffi.remapToJs(c);
          switch (b) {
          default:
            throw Sk.ffi.err.attribute(b).isNotSetableOnType('Raycaster');
          }
        });
        c.__str__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.remapToJs(a);
          var b = [
              'ray',
              'near',
              'far'
            ].map(function (b) {
              return Sk.ffi.gattr(a, b);
            }).map(function (a) {
              return Sk.ffi.remapToJs(Sk.ffh.str(a));
            });
          return Sk.builtin.stringToPy('Raycaster(' + b.join(', ') + ')');
        });
        c.__repr__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.remapToJs(a);
          var b = [
              'ray',
              'near',
              'far'
            ].map(function (b) {
              return Sk.ffi.gattr(a, b);
            }).map(function (a) {
              return Sk.ffi.remapToJs(Sk.ffh.repr(a));
            });
          return Sk.builtin.stringToPy('Raycaster(' + b.join(', ') + ')');
        });
      }, 'Raycaster', []);
      a.Sphere = Sk.ffi.buildClass(a, function (b, c) {
        c.__init__ = Sk.ffi.functionPy(function (a, b, c) {
          Sk.ffi.checkMethodArgs('Sphere', arguments, 0, 2);
          var d = m('center', b);
          f(c) && Sk.ffi.checkArgType('radius', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(c), c);
          var e = Sk.ffi.remapToJs(c);
          Sk.ffi.referenceToPy(new THREE.Sphere(d, e), 'Sphere', void 0, a);
        });
        c.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'center':
            return k(d.center);
          case 'radius':
            return Sk.ffi.numberToFloatPy(d.radius);
          case 'copy':
            return Sk.ffi.callableToPy(a, c, function (a, e) {
              Sk.ffi.checkMethodArgs(c, arguments, 1, 1);
              Sk.ffi.checkArgType('sphere', 'Sphere', Sk.ffi.isInstance(e, 'Sphere'), e);
              d.copy(Sk.ffi.remapToJs(e));
              return b;
            });
          case 'containsPoint':
            return Sk.ffi.callableToPy(a, c, function (a, b) {
              Sk.ffi.checkMethodArgs(c, arguments, 1, 1);
              return Sk.ffi.booleanToPy(d.containsPoint(m('point', b)));
            });
          case 'distanceToPoint':
            return Sk.ffi.callableToPy(a, c, function (a, b) {
              Sk.ffi.checkMethodArgs(c, arguments, 1, 1);
              return Sk.ffi.numberToFloatPy(d.distanceToPoint(m('point', b)));
            });
          case 'intersectsSphere':
            return Sk.ffi.callableToPy(a, c, function (a, b) {
              Sk.ffi.checkMethodArgs(c, arguments, 1, 1);
              Sk.ffi.checkArgType('sphere', 'Sphere', Sk.ffi.isInstance(b, 'Sphere'), b);
              return Sk.ffi.booleanToPy(d.intersectsSphere(Sk.ffi.remapToJs(b)));
            });
          default:
            throw Sk.ffi.err.attribute(c).isNotGetableOnType('Sphere');
          }
        });
        c.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          Sk.ffi.remapToJs(a);
          Sk.ffi.remapToJs(c);
          switch (b) {
          default:
            throw Sk.ffi.err.attribute(b).isNotSetableOnType('Sphere');
          }
        });
        c.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          a = [
            k(a.center),
            Sk.ffi.numberToFloatPy(a.radius)
          ].map(function (a) {
            return Sk.ffi.remapToJs(Sk.ffh.str(a));
          });
          return Sk.builtin.stringToPy('Sphere(' + a.join(', ') + ')');
        });
        c.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          a = [
            k(a.center),
            Sk.ffi.numberToFloatPy(a.radius)
          ].map(function (a) {
            return Sk.ffi.remapToJs(Sk.ffh.repr(a));
          });
          return Sk.builtin.stringToPy('Sphere(' + a.join(', ') + ')');
        });
      }, 'Sphere', []);
      f(THREE) && (a.LineStrip = Sk.ffi.numberToIntPy(THREE.LineStrip), a.LinePieces = Sk.ffi.numberToIntPy(THREE.LinePieces), a.FlatShading = Sk.ffi.numberToIntPy(THREE.FlatShading), a.NoShading = Sk.ffi.numberToIntPy(THREE.NoShading), a.SmoothShading = Sk.ffi.numberToIntPy(THREE.SmoothShading), a.NoColors = Sk.ffi.numberToIntPy(THREE.NoColors), a.FaceColors = Sk.ffi.numberToIntPy(THREE.FaceColors), a.VertexColors = Sk.ffi.numberToIntPy(THREE.VertexColors), a.FrontSide = Sk.ffi.numberToIntPy(THREE.FrontSide), a.BackSide = Sk.ffi.numberToIntPy(THREE.BackSide), a.DoubleSide = Sk.ffi.numberToIntPy(THREE.DoubleSide));
    };
  }.call(this));
  (function () {
    var a = function (a, b) {
        var c, g, h, l, k;
        h = [];
        c = function (a, b) {
          var c;
          if (0 !== a) {
            0 <= a ? 0 < h.length && h.push('+') : h.push('-');
            c = Math.abs(a);
            if (1 === c)
              return h.push(b);
            h.push(c.toString());
            if ('1' !== b)
              return h.push('*'), h.push(b);
          }
        };
        g = l = 0;
        for (k = a.length - 1; 0 <= k ? l <= k : l >= k; g = 0 <= k ? ++l : --l)
          c(a[g], b[g]);
        return 0 < h.length ? h.join('') : '0';
      }, b = [
        Sk.ffi.PyType.FLOAT,
        Sk.ffi.PyType.INT,
        Sk.ffi.PyType.LONG
      ], c = Sk.ffi.PyType.INT;
    Sk.builtin.defineVector3 = function (d, e) {
      Sk.ffi.checkFunctionArgs('defineVector3', arguments, 2, 2);
      var f = function (a) {
          return Sk.ffi.isInstance(a, 'Vector3');
        }, g = function (a, b, c) {
          return Sk.ffi.callsim(d.Vector3, Sk.ffi.numberToFloatPy(a), Sk.ffi.numberToFloatPy(b), Sk.ffi.numberToFloatPy(c));
        };
      d.Vector3 = Sk.ffi.buildClass(d, function (h, l) {
        l.__init__ = Sk.ffi.functionPy(function (a, c, d, g) {
          Sk.ffi.checkMethodArgs('Vector3', arguments, 0, 4);
          if (Sk.ffi.isUndefined(c) && Sk.ffi.isUndefined(d) && Sk.ffi.isUndefined(g))
            Sk.ffi.referenceToPy(new e.Vector3(), 'Vector3', void 0, a);
          else
            switch (Sk.ffi.getType(c)) {
            case Sk.ffi.PyType.INSTANCE:
              Sk.ffi.checkMethodArgs('Vector3', arguments, 1, 1);
              Sk.ffi.checkArgType('x', 'Vector3', f(c), c);
              Sk.ffi.referenceToPy(Sk.ffi.remapToJs(c), 'Vector3', void 0, a);
              break;
            case Sk.ffi.PyType.FLOAT:
            case Sk.ffi.PyType.INT:
            case Sk.ffi.PyType.LONG:
              Sk.ffi.checkMethodArgs('Vector3', arguments, 3, 3);
              Sk.ffi.checkArgType('x', b, Sk.ffi.isNum(c), c);
              Sk.ffi.checkArgType('y', b, Sk.ffi.isNum(d), d);
              Sk.ffi.checkArgType('z', b, Sk.ffi.isNum(g), g);
              Sk.ffi.referenceToPy(new e.Vector3(Sk.ffi.remapToJs(c), Sk.ffi.remapToJs(d), Sk.ffi.remapToJs(g)), 'Vector3', void 0, a);
              break;
            default:
              Sk.ffi.checkArgType('x', [
                b,
                'Vector3'
              ], !1, c);
            }
        });
        l.__add__ = Sk.ffi.functionPy(function (a, b) {
          Sk.ffi.checkLhsOperandType('add', 'Vector3', f(a), a);
          Sk.ffi.checkRhsOperandType('add', 'Vector3', f(b), b);
          var c = Sk.ffi.remapToJs(a), d = Sk.ffi.remapToJs(b);
          return g(c.x + d.x, c.y + d.y, c.z + d.z);
        });
        l.__iadd__ = Sk.ffi.functionPy(function (a, b) {
          Sk.ffi.checkLhsOperandType('add', 'Vector3', f(a), a);
          Sk.ffi.checkRhsOperandType('add', 'Vector3', f(b), b);
          var c = Sk.ffi.remapToJs(a), d = Sk.ffi.remapToJs(b);
          c.x += d.x;
          c.y += d.y;
          c.z += d.z;
          return a;
        });
        l.__sub__ = Sk.ffi.functionPy(function (a, b) {
          Sk.ffi.checkLhsOperandType('subtract', 'Vector3', f(a), a);
          Sk.ffi.checkRhsOperandType('subtract', 'Vector3', f(b), b);
          var c = Sk.ffi.remapToJs(a), d = Sk.ffi.remapToJs(b);
          return g(c.x - d.x, c.y - d.y, c.z - d.z);
        });
        l.__isub__ = Sk.ffi.functionPy(function (a, b) {
          Sk.ffi.checkLhsOperandType('add', 'Vector3', f(a), a);
          Sk.ffi.checkRhsOperandType('add', 'Vector3', f(b), b);
          var c = Sk.ffi.remapToJs(a), d = Sk.ffi.remapToJs(b);
          c.x -= d.x;
          c.y -= d.y;
          c.z -= d.z;
          return a;
        });
        l.__mul__ = Sk.ffi.functionPy(function (a, c) {
          Sk.ffi.checkLhsOperandType('multiply', 'Vector3', f(a), a);
          Sk.ffi.checkRhsOperandType('multiply', b, Sk.ffi.isNum(c), c);
          var d = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(c);
          return g(d.x * e, d.y * e, d.z * e);
        });
        l.__rmul__ = Sk.ffi.functionPy(function (a, c) {
          Sk.ffi.checkLhsOperandType('multiply', b, Sk.ffi.isNum(c), c);
          Sk.ffi.checkRhsOperandType('multiply', 'Vector3', f(a), a);
          var d = Sk.ffi.remapToJs(c), e = Sk.ffi.remapToJs(a);
          return g(d * e.x, d * e.y, d * e.z);
        });
        l.__div__ = Sk.ffi.functionPy(function (a, c) {
          Sk.ffi.checkLhsOperandType('divide', 'Vector3', f(a), a);
          Sk.ffi.checkRhsOperandType('divide', b, Sk.ffi.isNum(c), c);
          var d = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(c);
          return g(d.x / e, d.y / e, d.z / e);
        });
        l.__rdiv__ = Sk.ffi.functionPy(function (a, c) {
          Sk.ffi.checkLhsOperandType('divide', b, Sk.ffi.isNum(c), c);
          Sk.ffi.checkRhsOperandType('divide', 'Vector3', f(a), a);
          var d = Sk.ffi.remapToJs(c), e = Sk.ffi.remapToJs(a);
          return g(e.x / d, e.y / d, e.z / d);
        });
        l.__getattr__ = Sk.ffi.functionPy(function (a, e) {
          var f = Sk.ffi.remapToJs(a);
          switch (e) {
          case 'x':
          case 'y':
          case 'z':
            return Sk.ffi.numberToFloatPy(f[e]);
          case 'applyQuaternion':
            return Sk.ffi.callableToPy(d, 'applyQuaternion', function (b, c) {
              Sk.ffi.checkMethodArgs('applyQuaternion', arguments, 1, 1);
              Sk.ffi.checkArgType('q', 'Quaternion', Sk.ffi.isInstance(c, 'Quaternion'), c);
              f.applyQuaternion(Sk.ffi.remapToJs(c));
              return a;
            });
          case 'clone':
            return Sk.ffi.callsim(Sk.ffi.buildClass(d, function (a, b) {
              b.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'clone';
              });
              b.__call__ = Sk.ffi.functionPy(function (a) {
                return g(f.x, f.y, f.z);
              });
            }, 'clone', []));
          case 'getComponent':
            return Sk.ffi.callableToPy(d, 'getComponent', function (a, b) {
              Sk.ffi.checkMethodArgs('getComponent', arguments, 1, 1);
              Sk.ffi.checkArgType('index', c, Sk.ffi.isNum(b), b);
              return Sk.ffi.numberToFloatPy(f.getComponent(Sk.ffi.remapToJs(b)));
            });
          case 'magnitude':
            return Sk.ffi.callsim(Sk.ffi.buildClass(d, function (a, b) {
              b.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'magnitude';
              });
              b.__call__ = Sk.ffi.functionPy(function (a) {
                return Sk.ffi.numberToFloatPy(f.length());
              });
            }, 'magnitude', []));
          case 'normalize':
            return Sk.ffi.callsim(Sk.ffi.buildClass(d, function (b, c) {
              c.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'normalize';
              });
              c.__call__ = Sk.ffi.functionPy(function (b) {
                Sk.ffi.checkMethodArgs('Vector3', arguments, 0, 0);
                f.normalize();
                return a;
              });
            }, 'normalize', []));
          case 'set':
            return Sk.ffi.callableToPy(d, 'set', function (c, d, e, g) {
              Sk.ffi.checkMethodArgs('set', arguments, 3, 3);
              Sk.ffi.checkArgType('x', b, Sk.ffi.isNum(d), d);
              Sk.ffi.checkArgType('y', b, Sk.ffi.isNum(e), e);
              Sk.ffi.checkArgType('z', b, Sk.ffi.isNum(g), g);
              d = Sk.ffi.remapToJs(d);
              e = Sk.ffi.remapToJs(e);
              g = Sk.ffi.remapToJs(g);
              f.set(d, e, g);
              return a;
            });
          case 'setComponent':
            return Sk.ffi.callableToPy(d, 'setComponent', function (d, e, g) {
              Sk.ffi.checkMethodArgs('setComponent', arguments, 2, 2);
              Sk.ffi.checkArgType('index', c, Sk.ffi.isInt(e), e);
              Sk.ffi.checkArgType('value', b, Sk.ffi.isNum(g), g);
              var h = Sk.ffi.remapToJs(e), l = Sk.ffi.remapToJs(g);
              f.setComponent(h, l);
              return a;
            });
          case 'setX':
          case 'setY':
          case 'setZ':
            return Sk.ffi.callableToPy(d, e, function (c, d) {
              Sk.ffi.checkMethodArgs(e, arguments, 1, 1);
              Sk.ffi.checkArgType('value', b, Sk.ffi.isNum(d), d);
              f[e](Sk.ffi.remapToJs(d));
              return a;
            });
          default:
            throw Sk.ffi.err.attribute(e).isNotGetableOnType('Vector3');
          }
        });
        l.__setattr__ = Sk.ffi.functionPy(function (a, c, d) {
          switch (c) {
          case 'x':
          case 'y':
          case 'z':
            Sk.ffi.checkArgType(c, b, Sk.ffi.isNum(d), d);
            Sk.ffi.remapToJs(a)[c] = Sk.ffi.remapToJs(d);
            break;
          default:
            throw Sk.ffi.err.attribute(c).isNotSetableOnType('Vector3');
          }
        });
        l.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.builtin.stringToPy('Vector3(' + [
            a.x,
            a.y,
            a.z
          ].join(', ') + ')');
        });
        l.__str__ = Sk.ffi.functionPy(function (b) {
          b = Sk.ffi.remapToJs(b);
          return Sk.builtin.stringToPy(a([
            b.x,
            b.y,
            b.z
          ], [
            'i',
            'j',
            'k'
          ]));
        });
      }, 'Vector3', []);
    };
  }.call(this));
  (function () {
    Sk.builtin.defineFractions = function (a, b, c) {
      Sk.ffi.checkFunctionArgs('defineFractions', arguments, 3, 3);
      var d = function (a) {
          return Sk.ffi.isInstance(a, b);
        }, e = [
          b,
          Sk.ffi.PyType.INT
        ];
      a[b] = Sk.ffi.buildClass(a, function (f, g) {
        g.__init__ = Sk.ffi.functionPy(function (a, e, f) {
          if (Sk.ffi.isUndefined(f))
            Sk.ffi.isUndefined(e) ? Sk.ffi.referenceToPy(c(0, 1), b, void 0, a) : d(e) ? (Sk.ffi.checkMethodArgs(b, arguments, 1, 1), Sk.ffi.referenceToPy(Sk.ffi.remapToJs(e), b, void 0, a)) : Sk.ffi.isNum(e) ? (Sk.ffi.checkArgType('numerator', Sk.ffi.PyType.INT, Sk.ffi.isInt(e), e), g = Sk.ffi.remapToJs(e), Sk.ffi.referenceToPy(c(g, 1), b, void 0, a)) : Sk.ffi.checkMethodArgs(b, arguments, 2, 2);
          else {
            Sk.ffi.checkMethodArgs(b, arguments, 2, 2);
            Sk.ffi.checkArgType('numerator', Sk.ffi.PyType.INT, Sk.ffi.isInt(e), e);
            Sk.ffi.checkArgType('denominator', Sk.ffi.PyType.INT, Sk.ffi.isInt(f), f);
            var g = Sk.ffi.remapToJs(e), p = Sk.ffi.remapToJs(f);
            if (0 != p)
              Sk.ffi.referenceToPy(c(g, p), b, void 0, a);
            else
              throw new Sk.builtin.ZeroDivisionError('denominator must not be zero');
          }
        });
        g.__getattr__ = Sk.ffi.functionPy(function (a, c) {
          var d = Sk.ffi.remapToJs(a);
          switch (c) {
          case 'numer':
          case 'numerator':
            return Sk.ffi.numberToIntPy(d.numer);
          case 'denom':
          case 'denominator':
            return Sk.ffi.numberToIntPy(d.denom);
          default:
            throw Sk.ffi.err.attribute(c).isNotGetableOnType(b);
          }
        });
        g.__add__ = Sk.ffi.functionPy(function (c, f) {
          Sk.ffi.checkRhsOperandType('add', e, d(f) || Sk.ffi.isInt(f), f);
          var g = Sk.ffi.remapToJs(c), m = Sk.ffi.remapToJs(f);
          return Sk.ffi.callsim(a[b], Sk.ffi.referenceToPy(g.add(m), b));
        });
        g.__radd__ = Sk.ffi.functionPy(function (d, f) {
          Sk.ffi.checkLhsOperandType('add', e, Sk.ffi.isInt(f), f);
          var g = Sk.ffi.remapToJs(d), m = c(Sk.ffi.remapToJs(f), 1);
          return Sk.ffi.callsim(a[b], Sk.ffi.referenceToPy(m.add(g), b));
        });
        g.__sub__ = Sk.ffi.functionPy(function (c, f) {
          Sk.ffi.checkRhsOperandType('subtract', e, d(f) || Sk.ffi.isInt(f), f);
          var g = Sk.ffi.remapToJs(c), m = Sk.ffi.remapToJs(f);
          return Sk.ffi.callsim(a[b], Sk.ffi.referenceToPy(g.sub(m), b));
        });
        g.__rsub__ = Sk.ffi.functionPy(function (d, f) {
          Sk.ffi.checkLhsOperandType('subtract', e, Sk.ffi.isInt(f), f);
          var g = Sk.ffi.remapToJs(d), m = c(Sk.ffi.remapToJs(f), 1);
          return Sk.ffi.callsim(a[b], Sk.ffi.referenceToPy(m.sub(g), b));
        });
        g.__mul__ = Sk.ffi.functionPy(function (c, d) {
          switch (Sk.ffi.getType(d)) {
          case Sk.ffi.PyType.INSTANCE:
            switch (Sk.ffi.typeName(d)) {
            case b:
              var e = Sk.ffi.remapToJs(c), f = Sk.ffi.remapToJs(d);
              return Sk.ffi.callsim(a[b], Sk.ffi.referenceToPy(e.mul(f), b));
            default:
              return;
            }
          case Sk.ffi.PyType.INT:
            return e = Sk.ffi.remapToJs(c), f = Sk.ffi.remapToJs(d), Sk.ffi.callsim(a[b], Sk.ffi.numberToIntPy(e.numer * f), Sk.ffi.numberToIntPy(e.denom));
          }
        });
        g.__rmul__ = Sk.ffi.functionPy(function (d, f) {
          Sk.ffi.checkLhsOperandType('multiply', e, Sk.ffi.isInt(f), f);
          var g = Sk.ffi.remapToJs(d), m = c(Sk.ffi.remapToJs(f), 1);
          return Sk.ffi.callsim(a[b], Sk.ffi.referenceToPy(m.mul(g), b));
        });
        g.__div__ = Sk.ffi.functionPy(function (c, f) {
          var g = Sk.ffi.remapToJs(c), m = Sk.ffi.remapToJs(f);
          if (Sk.ffi.isNum(f)) {
            if (Sk.ffi.checkRhsOperandType('divide', e, Sk.ffi.isInt(f), f), 0 != m)
              return Sk.ffi.callsim(a[b], Sk.ffi.numberToIntPy(g.numer), Sk.ffi.numberToIntPy(g.denom * m));
          } else if (Sk.ffi.checkRhsOperandType('divide', e, d(f), f), 0 != m.numer)
            return Sk.ffi.callsim(a[b], Sk.ffi.referenceToPy(g.div(m), b));
          throw new Sk.builtin.ZeroDivisionError('denominator must not be zero');
        });
        g.__rdiv__ = Sk.ffi.functionPy(function (d, f) {
          Sk.ffi.checkLhsOperandType('divide', e, Sk.ffi.isInt(f), f);
          var g = Sk.ffi.remapToJs(d), m = c(Sk.ffi.remapToJs(f), 1);
          if (0 != g.numer)
            return Sk.ffi.callsim(a[b], Sk.ffi.referenceToPy(m.div(g), b));
          throw new Sk.builtin.ZeroDivisionError('denominator must not be zero');
        });
        g.__eq__ = Sk.ffi.functionPy(function (a, b) {
          Sk.ffi.checkFunctionArgs('equal', arguments, 2, 2);
          if (d(a) && d(b)) {
            var c = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(b);
            return Sk.ffi.booleanToPy(c.equals(e));
          }
          return Sk.ffi.bool.False;
        });
        g.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.builtin.stringToPy(b + '(' + a.numer + ',' + a.denom + ')');
        });
        g.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.builtin.stringToPy('' + a);
        });
      }, b, []);
    };
  }.call(this));
  (function () {
    Sk.builtin.defineWorkbench = function (a) {
      function b(a) {
        a = document.getElementsByTagName(a);
        for (var b = a.length - 1; 0 <= b; b--) {
          var c = a[b];
          c.parentNode.removeChild(c);
        }
      }
      Sk.ffi.checkFunctionArgs('defineWorkbench', arguments, 1, 1);
      var c = function () {
          var a;
          a = Object.prototype.toString.call(window);
          return function (b) {
            var c, d;
            c = Object.prototype.toString.call(b);
            switch (a) {
            case '[object DOMWindow]':
            case '[object Window]':
            case '[object global]':
              return c === a;
            }
            if ('self' in b) {
              c = b.hasOwnProperty('self');
              try {
                c && (d = b.self), delete b.self, c && (b.self = d);
              } catch (l) {
                return !0;
              }
            }
            return !1;
          };
        }(), d = function (a) {
          if ('undefined' === typeof a || Sk.ffi.isNone(a))
            return window;
          var b = Sk.ffi.remapToJs(a);
          Sk.ffi.checkArgType('window', 'Window', c(b), a);
          return b;
        };
      a.Workbench2D = Sk.ffi.buildClass(a, function (c, f) {
        f.__init__ = Sk.ffi.functionPy(function (a, b, c) {
          Sk.ffi.checkMethodArgs('Workbench2D(canvas[, window])', arguments, 1, 2);
          Sk.ffi.checkArgType('canvas', [Sk.ffi.PyType.OBJECT], Sk.ffi.isObjectPy(b) || Sk.ffi.isInstance(b), b);
          var e = Sk.ffi.remapToJs(b), f = d(c);
          Sk.ffi.referenceToPy({
            canvas: e,
            window: f,
            onWindowResize: function (a) {
              a = f.innerHeight;
              e.width = f.innerWidth;
              e.height = a;
            }
          }, 'Workbench2D', void 0, a);
        });
        f.__getattr__ = Sk.ffi.functionPy(function (c, d) {
          var e = Sk.ffi.remapToJs(c), f = e.window, m = f.document;
          switch (d) {
          case 'setUp':
            return Sk.ffi.callableToPy(a, 'setUp', function (a) {
              Sk.ffi.checkMethodArgs('setUp', arguments, 0, 0);
              m.body.insertBefore(e.canvas, m.body.firstChild);
              f.addEventListener('resize', e.onWindowResize, !1);
              e.onWindowResize(null);
            });
          case 'tearDown':
            return Sk.ffi.callableToPy(a, 'tearDown', function (a) {
              f.removeEventListener('resize', e.onWindowResize, !1);
              b('canvas');
            });
          }
        });
      }, 'Workbench2D', []);
      a.Workbench3D = Sk.ffi.buildClass(a, function (c, f) {
        f.__init__ = Sk.ffi.functionPy(function (a, b, c, e, f) {
          Sk.ffi.checkMethodArgs('Workbench3D(canvas, renderer, camera[, window])', arguments, 3, 4);
          var p = Sk.ffi.remapToJs(b), n = Sk.ffi.remapToJs(c), q = Sk.ffi.remapToJs(e), x = d(f);
          Sk.ffi.referenceToPy({
            canvas: p,
            renderer: n,
            camera: q,
            window: x,
            onWindowResize: function (a) {
              a = x.innerWidth;
              var b = x.innerHeight;
              n.setSize(a, b);
              q.aspect = a / b;
              q.updateProjectionMatrix();
            }
          }, 'Workbench3D', void 0, a);
        });
        f.__getattr__ = Sk.ffi.functionPy(function (c, d) {
          var e = Sk.ffi.remapToJs(c), f = e.window, m = f.document;
          switch (d) {
          case 'setUp':
            return Sk.ffi.callableToPy(a, 'setUp', function (a) {
              m.body.insertBefore(e.canvas, m.body.firstChild);
              f.addEventListener('resize', e.onWindowResize, !1);
              e.onWindowResize(null);
            });
          case 'tearDown':
            return Sk.ffi.callableToPy(a, 'tearDown', function (a) {
              f.removeEventListener('resize', e.onWindowResize, !1);
              b('canvas');
            });
          }
        });
      }, 'Workbench3D', []);
    };
  }.call(this));
}());
Sk.builtinFiles = {
  'files': {
    'src/lib/pythonds/trees/binheap.py': '# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005\n# \n\n# this heap takes key value pairs, we will assume that the keys are integers\nclass BinHeap:\n    def __init__(self):\n        self.heapList = [0]\n        self.currentSize = 0\n\n\n    def buildHeap(self,alist):\n        i = len(alist) // 2\n        self.currentSize = len(alist)\n        self.heapList = [0] + alist[:]\n        print(len(self.heapList), i)\n        while (i > 0):\n            print(self.heapList, i)\n            self.percDown(i)\n            i = i - 1\n        print(self.heapList,i)\n                        \n    def percDown(self,i):\n        while (i * 2) <= self.currentSize:\n            mc = self.minChild(i)\n            if self.heapList[i] > self.heapList[mc]:\n                tmp = self.heapList[i]\n                self.heapList[i] = self.heapList[mc]\n                self.heapList[mc] = tmp\n            i = mc\n                \n    def minChild(self,i):\n        if i * 2 + 1 > self.currentSize:\n            return i * 2\n        else:\n            if self.heapList[i * 2] < self.heapList[i * 2 + 1]:\n                return i * 2\n            else:\n                return i * 2 + 1\n\n    def percUp(self,i):\n        while i // 2 > 0:\n            if self.heapList[i] < self.heapList[i//2]:\n               tmp = self.heapList[i // 2]\n               self.heapList[i // 2] = self.heapList[i]\n               self.heapList[i] = tmp\n            i = i // 2\n \n    def insert(self,k):\n        self.heapList.append(k)\n        self.currentSize = self.currentSize + 1\n        self.percUp(self.currentSize)\n\n    def delMin(self):\n        retval = self.heapList[1]\n        self.heapList[1] = self.heapList[self.currentSize]\n        self.currentSize = self.currentSize - 1\n        self.heapList.pop()\n        self.percDown(1)\n        return retval\n        \n    def isEmpty(self):\n        if currentSize == 0:\n            return True\n        else:\n            return False\n',
    'src/lib/fractions/__init__.js': '/**\n * fractions - Rational numbers\n *\n * David Holmes (david.geo.holmes@gmail.com)\n */\nvar $builtinmodule = function(name) {\n\n  var mod = {};\n\n  var FRACTION = "Fraction";\n\n  Sk.builtin.defineFractions(mod, FRACTION, function(n, d) {return new BLADE.Rational(n, d)});\n\n  return mod;\n};',
    'src/lib/pythonds/basic/stack.py': '# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005\n# \n#stack.py\r\n\r\nclass Stack:\r\n    def __init__(self):\r\n        self.items = []\r\n\r\n    def isEmpty(self):\r\n        return self.items == []\r\n\r\n    def push(self, item):\r\n        self.items.append(item)\r\n\r\n    def pop(self):\r\n        return self.items.pop()\r\n\r\n    def peek(self):\r\n        return self.items[len(self.items)-1]\r\n\r\n    def size(self):\r\n        return len(self.items)\r\n\r\n',
    'src/lib/pythonds/trees/bst.py': '#!/bin/env python3.1\n# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005, 2010\n# \n\nclass BinarySearchTree:\n    \'\'\'\n    Author:  Brad Miller\n    Date:  1/15/2005\n    Description:  Imlement a binary search tree with the following interface\n                  functions:  \n                  __contains__(y) <==> y in x\n                  __getitem__(y) <==> x[y]\n                  __init__()\n                  __len__() <==> len(x)\n                  __setitem__(k,v) <==> x[k] = v\n                  clear()\n                  get(k)\n                  items() \n                  keys() \n                  values()\n                  put(k,v)\n                  in\n                  del <==> \n    \'\'\'\n\n    def __init__(self):\n        self.root = None\n        self.size = 0\n    \n    def put(self,key,val):\n        if self.root:\n            self._put(key,val,self.root)\n        else:\n            self.root = TreeNode(key,val)\n        self.size = self.size + 1\n\n    def _put(self,key,val,currentNode):\n        if key < currentNode.key:\n            if currentNode.hasLeftChild():\n                self._put(key,val,currentNode.leftChild)\n            else:\n                currentNode.leftChild = TreeNode(key,val,parent=currentNode)\n        else:\n            if currentNode.hasRightChild():\n                self._put(key,val,currentNode.rightChild)\n            else:\n                currentNode.rightChild = TreeNode(key,val,parent=currentNode)\n            \n    def __setitem__(self,k,v):\n        self.put(k,v)\n\n    def get(self,key):\n        if self.root:\n            res = self._get(key,self.root)\n            if res:\n                return res.payload\n            else:\n                return None\n        else:\n            return None\n        \n    def _get(self,key,currentNode):\n        if not currentNode:\n            return None\n        elif currentNode.key == key:\n            return currentNode\n        elif key < currentNode.key:\n            return self._get(key,currentNode.leftChild)\n        else:\n            return self._get(key,currentNode.rightChild)\n            \n        \n    def __getitem__(self,key):\n        res = self.get(key)\n        if res:\n            return res\n        else:\n            raise KeyError(\'Error, key not in tree\')\n            \n\n    def __contains__(self,key):\n        if self._get(key,self.root):\n            return True\n        else:\n            return False\n        \n    def length(self):\n        return self.size\n\n    def __len__(self):\n        return self.size\n\n    def __iter__(self):\n        return self.root.__iter__()\n    \n    def delete(self,key):\n        if self.size > 1:\n            nodeToRemove = self._get(key,self.root)\n            if nodeToRemove:\n                self.remove(nodeToRemove)\n                self.size = self.size-1\n            else:\n                raise KeyError(\'Error, key not in tree\')\n        elif self.size == 1 and self.root.key == key:\n            self.root = None\n            self.size = self.size - 1\n        else:\n            raise KeyError(\'Error, key not in tree\')\n\n    def __delitem__(self,key):\n        self.delete(key)\n    \n    def remove(self,currentNode):\n        if currentNode.isLeaf(): #leaf\n            if currentNode == currentNode.parent.leftChild:\n                currentNode.parent.leftChild = None\n            else:\n                currentNode.parent.rightChild = None\n        elif currentNode.hasBothChildren(): #interior\n            succ = currentNode.findSuccessor()\n            succ.spliceOut()\n            currentNode.key = succ.key\n            currentNode.payload = succ.payload\n        else: # this node has one child\n            if currentNode.hasLeftChild():\n                if currentNode.isLeftChild():\n                    currentNode.leftChild.parent = currentNode.parent\n                    currentNode.parent.leftChild = currentNode.leftChild\n                elif currentNode.isRightChild():\n                    currentNode.leftChild.parent = currentNode.parent\n                    currentNode.parent.rightChild = currentNode.leftChild\n                else:\n                    currentNode.replaceNodeData(currentNode.leftChild.key,\n                                       currentNode.leftChild.payload,\n                                       currentNode.leftChild.leftChild,\n                                       currentNode.leftChild.rightChild)\n            else:\n                if currentNode.isLeftChild():\n                    currentNode.rightChild.parent = currentNode.parent\n                    currentNode.parent.leftChild = currentNode.rightChild\n                elif currentNode.isRightChild():\n                    currentNode.rightChild.parent = currentNode.parent\n                    currentNode.parent.rightChild = currentNode.rightChild\n                else:\n                    currentNode.replaceNodeData(currentNode.rightChild.key,\n                                       currentNode.rightChild.payload,\n                                       currentNode.rightChild.leftChild,\n                                       currentNode.rightChild.rightChild)\n\n    def inorder(self):\n        self._inorder(self.root)\n\n    def _inorder(self,tree):\n        if tree != None:\n            self._inorder(tree.leftChild)\n            print(tree.key)\n            self._inorder(tree.rightChild)\n\n    def postorder(self):\n        self._postorder(self.root)\n\n    def _postorder(self, tree):\n        if tree:\n            self._postorder(tree.rightChild)\n            self._postorder(tree.leftChild)\n            print(tree.key)            \n\n    def preorder(self):\n        self._preorder(self,self.root)\n\n    def _preorder(self,tree):\n        if tree:\n            print(tree.key)            \n            self._preorder(tree.leftChild)\n            self._preorder(tree.rightChild)\n\n                \nclass TreeNode:\n    def __init__(self,key,val,left=None,right=None,parent=None):\n        self.key = key\n        self.payload = val\n        self.leftChild = left\n        self.rightChild = right\n        self.parent = parent\n        self.balanceFactor = 0\n        \n    def hasLeftChild(self):\n        return self.leftChild\n\n    def hasRightChild(self):\n        return self.rightChild\n    \n    def isLeftChild(self):\n        return self.parent and self.parent.leftChild == self\n\n    def isRightChild(self):\n        return self.parent and self.parent.rightChild == self\n\n    def isRoot(self):\n        return not self.parent\n\n    def isLeaf(self):\n        return not (self.rightChild or self.leftChild)\n\n    def hasAnyChildren(self):\n        return self.rightChild or self.leftChild\n\n    def hasBothChildren(self):\n        return self.rightChild and self.leftChild\n    \n    def replaceNodeData(self,key,value,lc,rc):\n        self.key = key\n        self.payload = value\n        self.leftChild = lc\n        self.rightChild = rc\n        if self.hasLeftChild():\n            self.leftChild.parent = self\n        if self.hasRightChild():\n            self.rightChild.parent = self\n        \n    def findSuccessor(self):\n        succ = None\n        if self.hasRightChild():\n            succ = self.rightChild.findMin()\n        else:\n            if self.parent:\n                if self.isLeftChild():\n                    succ = self.parent\n                else:\n                    self.parent.rightChild = None\n                    succ = self.parent.findSuccessor()\n                    self.parent.rightChild = self\n        return succ\n\n\n    def spliceOut(self):\n        if self.isLeaf():\n            if self.isLeftChild():\n                self.parent.leftChild = None\n            else:\n                self.parent.rightChild = None\n        elif self.hasAnyChildren():\n            if self.hasLeftChild():\n                if self.isLeftChild():\n                    self.parent.leftChild = self.leftChild\n                else:\n                    self.parent.rightChild = self.leftChild\n                self.leftChild.parent = self.parent\n            else:\n                if self.isLeftChild():\n                    self.parent.leftChild = self.rightChild\n                else:\n                    self.parent.rightChild = self.rightChild\n                self.rightChild.parent = self.parent\n\n    def findMin(self):\n        current = self\n        while current.hasLeftChild():\n            current = current.leftChild\n        return current\n\n    def __iter__(self):\n        """The standard inorder traversal of a binary tree."""\n        if self:\n            if self.hasLeftChild():\n                for elem in self.leftChild:\n                    yield elem\n            yield self.key\n            if self.hasRightChild():\n                for elem in self.rightChild:\n                    yield elem\n\n            \n',
    'src/lib/time/__init__.js': '\n/*\n\tBarebones implementation of the Python time package.\n\n\tFor now, only the time() function is implemented.\n*/\n \nvar $builtinmodule = function(name)\n{\n    var mod = {};\n\n    mod.time = new Sk.builtin.func(function()\n    {\n      return Sk.builtin.numberToPy(new Date().getTime() / 1000);\n    });\n\n    return mod;\n}\n',
    'src/lib/image/__init__.js': 'var ImageMod; // the single identifier needed in the global scope\n\nif (! ImageMod) {\n    ImageMod = { };\n    ImageMod.canvasLib = [];\n}\n\n//  todo create an empty image by reading image data from a blank canvas of the appropriate size\n\nvar $builtinmodule = function(name) {\n    var mod = {};\n\n    var image = function($gbl, $loc) {\n        $loc.__init__ = new Sk.builtin.func(function(self,imageId) {\n            self.image = document.getElementById(imageId.v);\n            if (self.image == null) {\n                throw "There is no image on this page named: " + imageId.v;\n            }\n            self.width = self.image.width;\n            self.height = self.image.height;\n            self.canvas = document.createElement("canvas");\n            self.canvas.height = self.height;\n            self.canvas.width = self.width;\n            self.ctx = self.canvas.getContext("2d");\n            self.ctx.drawImage(self.image,0,0)\n            self.imagedata = self.ctx.getImageData(0,0,self.width,self.height);\n        });\n\n        $loc.getPixel = new Sk.builtin.func(function(self,x,y) {\n\t\t\tx = Sk.builtin.asnum$(x);\n\t\t\ty = Sk.builtin.asnum$(y);\n            var index = (y*4)*self.width+(x*4);\n            var red = self.imagedata.data[index]\n            var green = self.imagedata.data[index+1]\n            var blue = self.imagedata.data[index+2]\n            return Sk.misceval.callsim(mod.Pixel,red,green,blue);\n        });\n\n        $loc.setPixel = new Sk.builtin.func(function(self, x, y, pix) {\n\t\t\tx = Sk.builtin.asnum$(x);\n\t\t\ty = Sk.builtin.asnum$(y);\n            var index = (y*4)*self.width+(x*4);\n            self.imagedata.data[index] = Sk.misceval.callsim(pix.getRed,pix);\n            self.imagedata.data[index+1] = Sk.misceval.callsim(pix.getGreen,pix);\n            self.imagedata.data[index+2] = Sk.misceval.callsim(pix.getBlue,pix);\n            self.imagedata.data[index+3] = 255;\n        });\n\n        $loc.getHeight = new Sk.builtin.func(function(self) {\n            return self.image.height;\n        });\n\n        $loc.getWidth = new Sk.builtin.func(function(self,titlestring) {\n            return self.image.width;\n        });\n\n        $loc.draw = new Sk.builtin.func(function(self,win,ulx,uly) {\n\t\t\twin = Sk.builtin.asnum$(win);\n\t\t\tulx = Sk.builtin.asnum$(ulx);\n\t\t\tuly = Sk.builtin.asnum$(uly);\n            var can = Sk.misceval.callsim(win.getWin,win);\n            var ctx = can.getContext("2d");\n            //ctx.putImageData(self.imagedata,0,0,0,0,self.imagedata.width,self.imagedata.height);\n            if (! ulx) {\n                ulx = 0;\n                uly = 0;\n            }\n            ctx.putImageData(self.imagedata,ulx,uly);\n        });\n\n        // toList\n\n    }\n\n    mod.Image = Sk.misceval.buildClass(mod, image, \'Image\', []);\n\n    var eImage = function($gbl, $loc) {\n        $loc.__init__ = new Sk.builtin.func(function(self,width,height) {\n            self.width = Sk.builtin.asnum$(width);\n            self.height = Sk.builtin.asnum$(height);\n            self.canvas = document.createElement("canvas");\n            self.ctx = self.canvas.getContext(\'2d\');\n            self.canvas.height = self.height;\n            self.canvas.width = self.width;\n            self.imagedata = self.ctx.getImageData(0,0,self.width,self.height);\n        });\n\n    }\n\n    mod.EmptyImage = Sk.misceval.buildClass(mod, eImage, \'EmptyImage\', [mod.Image]);\n\n    // create a ListImage object\n\n    \n    var pixel = function($gbl, $loc) {\n        $loc.__init__ = new Sk.builtin.func(function(self,r,g,b) {\n            self.red = Sk.builtin.asnum$(r);\n            self.green = Sk.builtin.asnum$(g);\n            self.blue = Sk.builtin.asnum$(b);\n        });\n\n        $loc.getRed = new Sk.builtin.func(function(self) {\n           return self.red;\n        });\n\n        $loc.getGreen = new Sk.builtin.func(function(self) {\n           return self.green;\n        });\n\n        $loc.getBlue = new Sk.builtin.func(function(self) {\n           return self.blue;\n        });\n\n        $loc.setRed = new Sk.builtin.func(function(self,r) {\n           self.red = Sk.builtin.asnum$(r);\n        });\n\n        $loc.setGreen = new Sk.builtin.func(function(self,g) {\n           self.green = Sk.builtin.asnum$(g);\n        });\n\n        $loc.setBlue = new Sk.builtin.func(function(self,b) {\n           self.blue = Sk.builtin.asnum$(b);\n        });\n\n        $loc.__getitem__ = new Sk.builtin.func(function(self,k) {\n\t\t   k = Sk.builtin.asnum$(k);\n           if(k == 0) {\n               return self.red;\n           } else if (k == 1) {\n               return self.green;\n           } else if (k == 2) {\n               return self.blue;\n           }\n        });\n\n        $loc.__str__ = new Sk.builtin.func(function(self) {\n            return "[" + self.red + "," + self.green + "," + self.blue + "]"\n        });\n        \n        //getColorTuple\n        $loc.getColorTuple = new Sk.builtin.func(function(self,x,y) {\n\n        });\n\n        //setRange -- change from 0..255 to 0.0 .. 1.0\n        $loc.setRange = new Sk.builtin.func(function(self,mx) {\n            self.max = Sk.builtin.asnum$(mx);\n        });\n\n    }\n    mod.Pixel = Sk.misceval.buildClass(mod, pixel, \'Pixel\', []);\n\n\n\n    var screen = function($gbl, $loc) {\n        $loc.__init__ = new Sk.builtin.func(function(self,width,height) {\n            var currentCanvas = ImageMod.canvasLib[Sk.canvas];\n            if (currentCanvas === undefined) {\n                self.theScreen = document.getElementById(Sk.canvas);\n                if (width !== undefined) {\n                    self.theScreen.height = height;\n                    self.theScreen.width = width;\n                }\n\n                ImageMod.canvasLib[Sk.canvas] = self.theScreen;\n            } else {\n                self.theScreen = currentCanvas;\n                self.theScreen.height = self.theScreen.height;\n            }\n            self.theScreen.style.display = "block";\n        });\n\n        $loc.getWin = new Sk.builtin.func(function(self) {\n           return self.theScreen;\n        });\n\n        // exitonclick\n        $loc.exitonclick = new Sk.builtin.func(function(self) {\n            var canvas_id = self.theScreen.id;\n            self.theScreen.onclick = function() {\n                document.getElementById(canvas_id).style.display = \'none\';\n                document.getElementById(canvas_id).onclick = null;\n                delete ImageMod.canvasLib[canvas_id];\n            }\n\n        });\n        //getMouse\n    }\n\n    mod.ImageWin = Sk.misceval.buildClass(mod, screen, \'ImageWin\', []);\n\n    return mod\n}\n',
    'src/lib/browser/__init__.js': 'var $builtinmodule = function(name) {\n\n  var mod = {};\n\n  var DOCUMENT_CLASS = \'Document\';\n  var EVENT = \'Event\';\n  var NODE = \'Node\';\n  var WINDOW_CLASS = \'Window\';\n  var WINDOW_ANIMATION_RUNNER = \'WindowAnimationRunner\';\n  var WORKBENCH = \'Workbench\';\n  var METHOD_START = \'start\';\n\n  Sk.builtin.defineEvent(mod);\n\n  Sk.builtin.defineNode(mod);\n\n  mod[\'window\'] = new Sk.ffi.ObjectPy(window);\n  mod[\'document\'] = new Sk.ffi.ObjectPy(window.document);\n\n  mod[WINDOW_ANIMATION_RUNNER] = Sk.ffi.buildClass(mod, function($gbl, $loc) {\n\n    $loc.__init__ = Sk.ffi.functionPy(function(selfPy, tickPy, terminatePy, setUpPy, tearDownPy, windowPy) {\n\n      var prototype = WINDOW_ANIMATION_RUNNER + \'(tick, terminate, setUp, tearDown[, window])\';\n      Sk.ffi.checkMethodArgs(prototype, arguments, 4, 5);\n      Sk.ffi.checkArgType(\'tick\', Sk.ffi.PyType.FUNCTION, Sk.ffi.isFunction(tickPy));\n      Sk.ffi.checkArgType(\'terminate\', [Sk.ffi.PyType.FUNCTION, Sk.ffi.PyType.NONE], Sk.ffi.isFunction(terminatePy) || Sk.ffi.isNone(terminatePy));\n      Sk.ffi.checkArgType(\'setUp\', Sk.ffi.PyType.FUNCTION, Sk.ffi.isFunction(setUpPy));\n      Sk.ffi.checkArgType(\'tearDown\', Sk.ffi.PyType.FUNCTION, Sk.ffi.isFunction(tearDownPy));\n      if (Sk.ffi.isDefined(windowPy)) {\n        Sk.ffi.checkArgType(\'window\', [Sk.ffi.PyType.OBJECT, Sk.ffi.PyType.INSTANCE], Sk.ffi.isObjectPy(windowPy) || Sk.ffi.isInstance(windowPy, WINDOW_CLASS), windowPy);\n      }\n      var onDocumentKeyDown = function(event) {\n        if (event.keyCode == 27) {\n          var war = Sk.ffi.remapToJs(selfPy);\n          war.escKeyPressed = true;\n          event.preventDefault();\n        }\n      };\n      var WindowAnimationRunner = function() {\n        this.window = Sk.ffi.isDefined(windowPy) ? Sk.ffi.remapToJs(windowPy) : window;\n        this.startTime = null;\n        this.elapsed = null;\n        this.requestID = null;\n        this.escKeyPressed = false;\n        this.exceptionPy = Sk.builtin.none.none$;\n      };\n      WindowAnimationRunner.prototype = {\n        constructor: WindowAnimationRunner,\n        start: function() {\n          var war = this;\n          Sk.misceval.apply(setUpPy, undefined, undefined, undefined, []);\n          war.window.document.addEventListener(\'keydown\', onDocumentKeyDown, false);\n          var animate = function(timestamp) {\n            if (war.startTime) {\n              war.elapsed = timestamp - war.startTime;\n            }\n            else {\n              if (timestamp) {\n                war.startTime = timestamp;\n              }\n              else {\n                war.elapsed = 0;\n              }\n            }\n            var terminate = Sk.ffi.isFunction(terminatePy) ? function() {\n              var timePy = Sk.ffi.numberToFloatPy(war.elapsed / 1000);\n              var responsePy = Sk.misceval.apply(terminatePy, undefined, undefined, undefined, [timePy]);\n              return Sk.ffi.remapToJs(responsePy);\n            } : function() {return false;};\n            if (war.escKeyPressed || terminate()) {\n              war.window.cancelAnimationFrame(war.requestID);\n              war.window.document.removeEventListener(\'keydown\', onDocumentKeyDown, false);\n              try {\n                Sk.misceval.apply(tearDownPy, undefined, undefined, undefined, [war.exceptionPy]);\n              }\n              catch (e)\n              {\n                // For backwards compatibility, try again with zero arguments.\n                try\n                {\n                  Sk.misceval.apply(tearDownPy, undefined, undefined, undefined, []);\n                }\n                catch (e)\n                {\n                  // We\'re just going to have to eat this one or log it.\n                }\n              }\n            }\n            else\n            {\n              war.requestID = war.window.requestAnimationFrame(animate);\n              try\n              {\n                var timePy = Sk.ffi.numberToFloatPy(war.elapsed / 1000);\n                Sk.misceval.apply(tickPy, undefined, undefined, undefined, [timePy]);\n              }\n              catch (e)\n              {\n                war.exceptionPy = e;\n                war.escKeyPressed = true;\n              }\n            }\n          };\n          animate(null);\n        },\n        toString: function()\n        {\n          return WINDOW_ANIMATION_RUNNER;\n        }\n      };\n      Sk.ffi.referenceToPy(new WindowAnimationRunner(), WINDOW_ANIMATION_RUNNER, undefined, selfPy);\n    });\n    $loc.__getattr__ = Sk.ffi.functionPy(function(selfPy, name) {\n      var war = Sk.ffi.remapToJs(selfPy);\n      switch (name) {\n        case METHOD_START: {\n          return Sk.ffi.callableToPy(mod, METHOD_START, function(methodPy) {\n            Sk.ffi.checkMethodArgs(METHOD_START, arguments, 0, 0);\n            war.start();\n          });\n        }\n      }\n    });\n    $loc.__str__ = Sk.ffi.functionPy(function(selfPy) {\n      return Sk.builtin.stringToPy(WINDOW_ANIMATION_RUNNER);\n    });\n    $loc.__repr__ = Sk.ffi.functionPy(function(selfPy) {\n      return Sk.builtin.stringToPy(WINDOW_ANIMATION_RUNNER + \'(\' + \')\');\n    });\n  }, WINDOW_ANIMATION_RUNNER, []);\n\n  return mod;\n};\n',
    'src/lib/units/__init__.js': 'var $builtinmodule = function(name) {\n  var mod = {};\n  Sk.builtin.defineUnits(mod, BLADE);\n  return mod;\n};',
    'src/lib/pythonds/basic/__init__.py': '\n#__all__ = ["stack"]\n\n\n#from .stack import Stack\n#from .queue import Queue\n\n\n\n',
    'src/lib/geometry/__init__.js': 'var $builtinmodule = function(moduleNamePy) {\n  var mod = {};\n  Sk.stdlib.defineThree(mod, BLADE);\n  Sk.builtin.defineGeometry(mod, THREE, Sk.ffi.remapToJs(moduleNamePy));\n  Sk.builtin.defineProbeE3(mod, THREE);\n  return mod;\n};\n',
    'src/lib/sprite/__init__.js': '//\n//\n// Sprite Graphics Module for DaVinci.\n//\n// Based on the turtle module by Brad Miller.\n//\n// Dependencies:\n//   jQuery\n//\n//\n\nvar SpriteGraphics; // the single identifier needed in the global scope\n\nif (! SpriteGraphics) {\n  SpriteGraphics = {};\n}\n\n\n(function () {\n\n  var Degree2Rad = Math.PI / 180.0; // conversion factor for degrees to radians.\n  var Rad2Degree = 180.0 / Math.PI; // conversion factor for radians to degrees.\n\n  function SpriteCanvas(options) {\n    this.canvasID = SpriteGraphics.defaults.canvasID;\n    if (options.canvasID) {\n      this.canvasID = options.canvasID;\n    }\n\n    this.canvas = document.getElementById(this.canvasID);\n    this.context = this.canvas.getContext(\'2d\');\n    $(this.canvas).fadeIn();\n\n    this.lineScale = 1.0;\n    this.xptscale = 1.0;\n    this.yptscale = 1.0;\n\n    this.llx = -this.canvas.width / 2;\n    this.lly = -this.canvas.height / 2;\n    this.urx = this.canvas.width / 2;\n    this.ury = this.canvas.height / 2;\n    this.setup(this.canvas.width,this.canvas.height);\n    SpriteGraphics.canvasInit = true;\n    this.tlist = []\n\n    this.timeFactor = 5;\n    if (SpriteGraphics.defaults.animate) {\n      this.delay = 5 * this.timeFactor;\n    }\n    else {\n      this.delay = 0;\n    }\n    this.segmentLength = 10;\n    this.renderCounter = 1;\n    this.clearPoint = 0;\n    SpriteGraphics.canvasLib[this.canvasID] = this;\n    //  This can be set to false AFTER the program completes to turn off the fade out on the canvas as a result of exitonclick\n    Sk.tg.fadeOnExit = true;\n  }\n\n  SpriteCanvas.prototype.setup = function(width, height) {\n    this.canvas.width = width;\n    this.canvas.height = height;\n    this.lineScale = 1.0;\n    this.xptscale = 1.0;\n    this.yptscale = 1.0;\n\n    this.llx = -this.canvas.width / 2;\n    this.lly = -this.canvas.height / 2;\n    this.urx = this.canvas.width / 2;\n    this.ury = this.canvas.height / 2;\n    this.renderCounter = 1;\n    this.clearPoint = 0;\n    this.timeFactor = 5;\n    if (SpriteGraphics.defaults.animate) {\n      this.delay = 5 * this.timeFactor;\n    }\n    else {\n      this.delay = 0;\n    }\n\n    if (SpriteGraphics.canvasInit == false) {\n      this.context.save();\n      this.context.translate(this.canvas.width / 2, this.canvas.height / 2); // move 0,0 to center.\n      this.context.scale(1, -1); // scaling like this flips the y axis the right way.\n      SpriteGraphics.canvasInit = true;\n      SpriteGraphics.eventCount = 0;\n      SpriteGraphics.renderClock = 0;\n      SpriteGraphics.renderTime = 0;\n    }\n    else {\n      this.context.restore();\n      this.context.translate(this.canvas.width / 2, this.canvas.height / 2); // move 0,0 to center.\n      this.context.scale(1, -1); // scaling like this flips the y axis the right way.\n      this.context.clearRect(-this.canvas.width / 2, -this.canvas.height / 2, this.canvas.width, this.canvas.height);\n    }\n  }\n\n  SpriteCanvas.prototype.addToCanvas = function(t) {\n    this.tlist.push(t);\n  }\n\n  SpriteCanvas.prototype.onCanvas = function(t) {\n    return (this.tlist.indexOf(t) >= 0);\n  }\n\n  SpriteCanvas.prototype.isAnimating = function() {\n    return (this.tlist.length > 0);\n  }\n\n  SpriteCanvas.prototype.startAnimating = function(t) {\n    if (! this.isAnimating()) {\n      this.intervalId = setTimeout(render, this.delay);\n    }\n    // Added in case startAnimating is called after it\'s already been added.\n    if (!this.onCanvas(t)) {\n      this.addToCanvas(t);\n    }\n    Sk.isSpriteProgram = true;\n  }\n\n  SpriteCanvas.prototype.doneAnimating = function(t) {\n    this.tlist.splice(0,this.tlist.length);\n    clearTimeout(this.intervalId);\n    $(Sk.runButton).removeAttr(\'disabled\');\n  }\n\n  SpriteCanvas.prototype.cancelAnimation = function() {\n    if (this.intervalId) {\n      clearTimeout(this.intervalId);\n    }\n\n    for (var t in this.tlist) {\n      this.tlist[t].aCount = this.tlist[t].drawingEvents.length - 1;\n    }\n    render();\n  }\n\n  SpriteCanvas.prototype.setSpeedDelay = function(s) {\n    var df = 10 - (s % 11) + 1;\n    this.delay = df * this.timeFactor;\n  }\n\n  SpriteCanvas.prototype.setDelay = function(d) {\n    this.delay = d;\n  }\n\n  SpriteCanvas.prototype.getDelay = function(s) {\n    return this.delay;\n  }\n\n  SpriteCanvas.prototype.setCounter = function(s) {\n    if (!s || s <= 0) {\n      s = 1;\n    }\n    this.renderCounter = s;\n  }\n\n  SpriteCanvas.prototype.getCounter = function() {\n    return this.renderCounter;\n  }\n\n  SpriteCanvas.prototype.setworldcoordinates = function(llx, lly, urx, ury) {\n    this.context.restore();\n    this.context.scale(this.canvas.width / (urx - llx), -this.canvas.height / (ury - lly));\n    if (lly == 0) {\n      this.context.translate(-llx, lly - (ury - lly));\n    }\n    else if (lly > 0) {\n      this.context.translate(-llx, -lly * 2);\n    }\n    else {\n      this.context.translate(-llx, -ury);\n    }\n\n    var xlinescale = (urx - llx) / this.canvas.width;\n    var ylinescale = (ury - lly) / this.canvas.height;\n    this.xptscale = xlinescale;\n    this.yptscale = ylinescale;\n    this.lineScale = Math.min(xlinescale,ylinescale);\n    this.context.save();\n\n    this.llx = llx;\n    this.lly = lly;\n    this.urx = urx;\n    this.ury = ury;\n\n  }\n\n  SpriteCanvas.prototype.window_width = function() {\n    return this.canvas.width;\n  }\n\n  SpriteCanvas.prototype.window_height = function() {\n    return this.canvas.height;\n  }\n\n  SpriteCanvas.prototype.bgcolor = function(c) {\n    this.background_color = c;\n    $(this.canvas).css("background-color",c.v);\n  }\n\n  SpriteCanvas.prototype.setSegmentLength = function(s) {\n    this.segmentLength = s;\n  }\n\n  SpriteCanvas.prototype.getSegmentLength = function() {\n    return this.segmentLength;\n  }\n\n  // todo: if animating, this should be deferred until the proper time\n  SpriteCanvas.prototype.exitonclick = function () {\n    var canvas_id = this.canvasID;\n    var theCanvas = this;\n    $(this.canvas).click(function() {\n      if (! theCanvas.isAnimating()) {\n        if (Sk.tg.fadeOnExit) {\n         $("#"+canvas_id).hide();\n       }\n       $("#"+canvas_id).unbind(\'click\');\n       Sk.tg.canvasInit = false;\n       delete Sk.tg.canvasLib[canvas_id];\n     }\n   });\n  }\n\n  SpriteCanvas.prototype.sprites = function() {\n    return SpriteGraphics.spriteList;\n  }\n\n /**\n  * New version NOT attached to a sprite (as per real sprite)\n  */\n  SpriteCanvas.prototype.tracer = function(t, d) {\n    this.setCounter(t);\n    if (t == 0) {\n      for (var i in this.spriteList) {\n        this.spriteList[i].animate = false;\n      }\n      this.cancelAnimation();\n    }\n    if (d !== undefined) {\n      this.setDelay(d);\n    }\n  }\n\n  // check if all sprites are done\n  allDone = function() {\n    var allDone = true;\n    for (var tix in SpriteGraphics.spriteList) {\n      var theT = SpriteGraphics.spriteList[tix];\n      allDone = allDone && (theT.aCount >= theT.drawingEvents.length);\n    }\n    return allDone;\n  }\n\n  //\n  //  This is the function that provides the animation\n  //\n  render = function () {\n    var context = document.getElementById(SpriteGraphics.defaults.canvasID).getContext(\'2d\');\n    with (context) {\n      with (SpriteGraphics.canvasLib[SpriteGraphics.defaults.canvasID]) {\n        clearRect(llx, lly, (urx - llx), (ury - lly));\n      }\n      var incr = SpriteGraphics.canvasLib[SpriteGraphics.defaults.canvasID].getCounter();\n      var lastCanvas = null;\n\n      SpriteGraphics.renderClock += incr;\n\n      for (var tix in SpriteGraphics.spriteList) {\n        var t = SpriteGraphics.spriteList[tix]\n        lastCanvas = t.spriteCanvas \n        if (t.aCount >= t.drawingEvents.length) {\n          t.aCount = t.drawingEvents.length - 1;\n        }\n        moveTo(0, 0);\n        var currentPos = new Vector(0,0,0);\n        var currentHead = new Vector(1,0,0);\n        lineWidth = t.get_pen_width();\n        lineCap = \'round\';\n        lineJoin = \'round\';\n        strokeStyle = \'black\';\n        var filling = false;\n        if (isNaN(t.spriteCanvas.delay)) {\n          t.spriteCanvas.delay = 0\n        }\n        for (var i = t.clearPoint; (i <= t.aCount || t.spriteCanvas.delay == 0) && i < t.drawingEvents.length; i++) {\n          if (i > t.aCount) {\n            // If se jump past aCount, jump it ahead\n            t.aCount = i\n          }\n          var oper = t.drawingEvents[i];\n          var ts = oper[oper.length-1];\n          if (ts <= SpriteGraphics.renderClock || t.spriteCanvas.delay == 0) {\n            if (ts > SpriteGraphics.renderClock) {\n              // If we go past the render clock, jump it ahead\n              SpriteGraphics.renderClock = ts\n            }\n            if (oper[0] == "LT") {  //  line to\n              if (! filling) {\n                beginPath();\n                moveTo(oper[1], oper[2]);\n              }\n              lineTo(oper[3], oper[4]);\n              strokeStyle = oper[5];\n              stroke();\n              currentPos = new Vector(oper[3],oper[4],0);\n              if (! filling)\n                closePath();\n            }\n            else if (oper[0] == "MT") {  // move to\n              moveTo(oper[3], oper[4]);\n              currentPos = new Vector(oper[3],oper[4],0);\n            }\n            else if (oper[0] == "BF") {  // begin fill\n              beginPath();\n              moveTo(oper[1], oper[2]);\n              filling = true;\n            }\n            else if (oper[0] == "EF") {  // end fill\n              fillStyle = oper[3];\n              stroke();\n              fill();\n              closePath();\n              filling = false;\n            }\n            else if (oper[0] == "FC") {  // fill color\n              fillStyle = oper[1];\n            }\n            else if (oper[0] == "TC") {  // sprite color\n              strokeStyle = oper[1];\n            }\n            else if (oper[0] == "PW") {  // Pen width\n              lineWidth = oper[1];\n            }\n            else if (oper[0] == "DT") {  // Dot\n              var col = fillStyle;\n              fillStyle = oper[2];\n              var size = oper[1];\n              fillRect(oper[3] - size / 2, oper[4] - size / 2, size, size);\n              fillStyle = col;\n            }\n            else if (oper[0] == "CI") {  // Circle\n              if (!filling)\n                beginPath();\n              arc(oper[1], oper[2], oper[3], oper[4], oper[5], oper[6]);\n              currentPos = new Vector(oper[1]+Sk.math.cos(oper[5])*oper[3],\n                oper[2]+Sk.math.sin(oper[5])*oper[3],0);\n              stroke();\n              if (! filling) {\n                closePath();\n              }\n            }\n            else if (oper[0] == "WT") { // write\n              if (font)\n                font = oper[2];\n              scale(1, -1);\n              fillText(oper[1], oper[3], -oper[4]);\n              scale(1, -1);\n            } else if (oper[0] == "ST") {  // stamp\n              t.drawSprite(oper[3], new Vector(oper[1], oper[2], 0));\n            } else if (oper[0] == "HT") { // hide sprite\n              t.visible = false;\n            } else if (oper[0] == "SH") { // show sprite\n              t.visible = true;\n            } else if (oper[0] == "TT") {\n              currentHead = oper[1];\n            } else if (oper[0] == "CL") { // clear\n              clear_canvas(t.canvasID);\n              t.clearPoint = i; // Different from reset that calls clear because it leaves the sprites where they are\n            } else if (oper[0] == "DL") { // delay\n              var df = oper[1];\n              t.spriteCanvas.delay = df\n            } else if (oper[0] == "SC") { // speed change\n              var s = oper[1]\n              if (s < 0)\n                s = 0\n              if (s > 10)\n                s = 10\n              var df = (10 - (s % 11) + 1) * t.spriteCanvas.timeFactor  //  10\n              if (s == 0) {\n                df = 0\n              }\n              // t.spriteCanvas.intervalId = clearInterval(t.spriteCanvas.intervalId);\n              t.spriteCanvas.delay = df;\n              // t.spriteCanvas.intervalId = setInterval(render, t.spriteCanvas.delay)\n              if (oper[2]) {\n                t.spriteCanvas.setSegmentLength(oper[2]);\n              }\n            } else if (oper[0] == "NO") {\n              // no op\n            } else {\n            } // end of oper[0] test\n          } // end of if ts < render clock\n        } // end of for\n        t.aCount += incr;\n        if (t.visible) {\n          // draw the sprite\n          t.drawSprite(currentHead.toAngle(), currentPos); // just use currentHead\n        }\n      }\n      // if (t.aCount >= t.drawingEvents.length) {\n      if (SpriteGraphics.renderClock > SpriteGraphics.eventCount ){ // && allDone() ){\n        // t.spriteCanvas.doneAnimating(t);\n        if (lastCanvas) lastCanvas.doneAnimating(t);\n      }\n      else {\n        // t.spriteCanvas.intervalId = setTimeout(render, t.spriteCanvas.delay)\n        if (lastCanvas) {\n          lastCanvas.intervalId = setTimeout(render, lastCanvas.delay)\n        }\n      }\n    }\n  }\n\n  // Constructor for Sprite objects\n  function Sprite() {\n    if (arguments.length >= 1) {\n      this.initialize(arguments[0]);\n    }\n    else {\n      this.initialize();\n    }\n    SpriteGraphics.spriteList.push(this);\n  }\n\n  Sprite.prototype.go_home = function () {\n    // Put sprite in initial state\n    // sprite is headed to the right\n    // with position 0,0,0 in the middle of the canvas.\n    // x grows to the right\n    // y grows towards the top of the canvas\n    with (this) {\n      position = home;\n      context.moveTo(home[0], home[1]);\n      heading = new Vector([1.0, 0.0, 0.0]); // to the right; in sprite space x+ direction\n      normal = new Vector([0.0, 0.0, -1.0]); // in z- direction\n    }\n  };\n\n  Sprite.prototype.initialize = function () {\n    // Initialize the sprite.\n    var options = { };\n\n    if (arguments.length >= 1) {\n      options = arguments[0];\n    }\n\n    this.canvasID = SpriteGraphics.defaults.canvasID;\n    if (options.canvasID) {\n      this.canvasID = options.canvasID;\n    }\n    this.context = document.getElementById(this.canvasID).getContext(\'2d\');\n\n    this.animate = SpriteGraphics.defaults.animate;\n\n    with (this.context) {\n      if (SpriteGraphics.canvasInit == false) {\n        save();\n        translate(canvas.width / 2, canvas.height / 2); // move 0,0 to center.\n        scale(1, -1); // scaling like this flips the y axis the right way.\n        if (! SpriteGraphics.canvasLib[this.canvasID]) {\n          SpriteGraphics.canvasLib[this.canvasID] = new SpriteCanvas(options);\n        }\n        SpriteGraphics.canvasInit = true;\n      }\n      else {\n        clear_canvas(this.canvasID);\n      }\n\n      this.spriteCanvas = SpriteGraphics.canvasLib[this.canvasID];\n      this.home = new Vector([0.0, 0.0, 0.0]);\n      this.visible = true;\n      this.shapeStore = {};\n      this.shapeStore[\'turtle\'] = turtleShapePoints();\n      this.shapeStore[\'arrow\'] = defaultShapePoints();\n      this.shapeStore[\'circle\'] = circleShapePoints();\n      this.shapeStore[\'classic\'] = classicShapePoints();\n      this.currentShape = \'classic\';\n      this.drawingEvents = [];\n\n      this.filling = false;\n      this.pen = true;\n      this.penStyle = \'black\';\n      this.penWidth = 2;\n      this.fillStyle = \'black\';\n      this.position = [ ];\n      this.heading = [ ];\n      this.normal = [ ];\n      this.go_home();\n      this.aCount = 0;\n      this.clearPoint = 0;\n    }\n  }\n\n  function turtleShapePoints() {\n    var pl = [\n    [0,16],\n    [-2,14],\n    [-1,10],\n    [-4,7],\n    [-7,9],\n    [-9,8],\n    [-6,5],\n    [-7,1],\n    [-5,-3],\n    [-8,-6],\n    [-6,-8],\n    [-4,-5],\n    [0,-7],\n    [4,-5],\n    [6,-8],\n    [8,-6],\n    [5,-3],\n    [7,1],\n    [6,5],\n    [9,8],\n    [7,9],\n    [4,7],\n    [1,10],\n    [2,14]\n    ];\n    res = [];\n    for (p in pl) {\n      res.push(new Vector(pl[p]));\n    }\n    return res;\n  }\n\n  function defaultShapePoints() {\n    var pl = [\n    [-10,0],\n    [10,0],\n    [0,10]\n    ];\n    res = [];\n    for (p in pl) {\n      res.push(new Vector(pl[p]));\n    }\n    return res;\n  }\n\n  function circleShapePoints() {\n    var pl = [\n    [10,0],\n    [9.51,3.09],\n    [8.09,5.88],\n    [5.88,8.09],\n    [3.09,9.51],\n    [0,10],\n    [-3.09,9.51],\n    [-5.88,8.09],\n    [-8.09,5.88],\n    [-9.51,3.09],\n    [-10,0],\n    [-9.51,-3.09],\n    [-8.09,-5.88],\n    [-5.88,-8.09],\n    [-3.09,-9.51],\n    [-0.00,-10.00],\n    [3.09,-9.51],\n    [5.88,-8.09],\n    [8.09,-5.88],\n    [9.51,-3.09]\n    ];\n    res = [];\n    for (p in pl) {\n      res.push(new Vector(pl[p]));\n    }\n    return res;\n  }\n\n  function classicShapePoints() {\n    var pl = [\n    [0,0],\n    [-5,-9],\n    [0,-7],\n    [5,-9]\n    ];\n    res = [];\n    for (p in pl) {\n      res.push(new Vector(pl[p]));\n    }\n    return res;\n  }\n\n  Sprite.prototype.clean = function () {\n    // Clean the canvas\n    // Optional second argument is color\n    with (this) {\n      if (arguments.length >= 1) {\n        clear_canvas(canvasID, arguments[0]);\n      }\n      else {\n        clear_canvas(canvasID);\n      }\n      initialize();\n    }\n  }\n\n  Sprite.prototype.addDrawingEvent = function(eventList) {\n    SpriteGraphics.eventCount += 1;\n    eventList.push(SpriteGraphics.eventCount);\n    this.drawingEvents.push(eventList);\n  }\n\n  //  \n  //  Drawing Functions\n  //\n\n    // break a line into segments\n    // sp:  Vector of starting position\n    // ep:  Vector of ending position\n    // sl:  int length of segments\n    segmentLine = function(sp, ep, sL, pen) {\n      var head = ep.sub(sp).normalize();\n      var numSegs = Math.floor(ep.sub(sp).len() / sL);\n      var res = [];\n      var oldp = sp;\n      var newp;\n      var op = ""\n      if (pen)\n        op = "LT"\n      else\n        op = "MT"\n      for (var i = 0; i < numSegs; i++) {\n        newp = oldp.linear(1, sL, head);\n        res.push([op,oldp[0],oldp[1],newp[0],newp[1]]);\n        oldp = newp;\n      }\n      if (! ((oldp[0] == ep[0]) && (oldp[1] == ep[1])))\n        res.push([op, oldp[0], oldp[1], ep[0], ep[1]]);\n      return res;\n    }\n\n    Sprite.prototype.draw_line = function(newposition) {\n      with (this) {\n        with (context) {\n          if (! animate) {\n            if (! filling) {\n              beginPath();\n              moveTo(position[0], position[1]);\n            }\n            lineCap = \'round\';\n            lineJoin = \'round\';\n            lineWidth = get_pen_width();\n            strokeStyle = penStyle;\n            lineTo(newposition[0], newposition[1]);\n            stroke();\n            if (! filling)\n              closePath();\n          } else {\n            var r = segmentLine(position, newposition, spriteCanvas.getSegmentLength(), pen);\n            for (var s in r) {\n              r[s].push(penStyle);\n              addDrawingEvent(r[s]);\n            }\n            if (! spriteCanvas.isAnimating()) {\n              spriteCanvas.startAnimating(this);\n            } else {\n              if (! spriteCanvas.onCanvas(this))\n                spriteCanvas.addToCanvas(this);\n            }\n          }\n        }\n      }\n    }\n\n    Sprite.prototype.forward = function (d) {\n      with (this) {\n        var newposition = position.linear(1, d, heading);\n        goto(newposition);\n      }\n    }\n\n    Sprite.prototype.backward = function(d) {\n      this.forward(-d);\n    }\n\n    // This is an internal function that sets the position without doing any drawing\n    Sprite.prototype.teleport_to = function(nx, ny) {\n      if (nx instanceof Vector)\n        var newposition = nx;\n      else\n        var newposition = new Vector([nx,ny,0]);\n      this.context.moveTo(newposition[0], newposition[1]);\n      this.position = newposition;\n    }\n\n    Sprite.prototype.goto = function(nx, ny) {\n      if (nx instanceof Vector)\n        var newposition = nx;\n      else\n        var newposition = new Vector([nx,ny,0]);\n      with (this) {\n        if (pen) {\n          draw_line(newposition);\n        } else {\n          if (! animate) {\n            context.moveTo(newposition[0], newposition[1]);\n          } else {\n            var r = segmentLine(position, newposition, spriteCanvas.getSegmentLength(), pen);\n            for (var s in r)\n              addDrawingEvent(r[s]);\n            if (! spriteCanvas.isAnimating()) {\n              spriteCanvas.startAnimating(this);\n            } else {\n              if (! spriteCanvas.onCanvas(this))\n                spriteCanvas.addToCanvas(this);\n            }\n          }\n        }\n        position = newposition;\n      }\n    }\n\n    Sprite.prototype.delay = function(d) {\n      if (d != null) {\n        if (d < 0) {\n          d = -d;\n        }\n        if (!this.animate) {\n          this.spriteCanvas.setDelay(d);\n        } \n        else {\n          this.spriteCanvas.setDelay(d);\n          this.addDrawingEvent(["DL", d]);\n          this.addDrawingEvent(["NO"]);\n        }\n      }\n      return this.spriteCanvas.getDelay();\n    }\n\n    Sprite.prototype.speed = function(s,t) {\n      if (s > 0 && !this.animate) {\n        this.animate = true;\n        this.spriteCanvas.setSpeedDelay(s);\n      }\n      else if (s == 0 && !this.animate) {\n        this.spriteCanvas.setSpeedDelay(s);\n      }\n      else {\n        // this.animate = false;\n        // this.spriteCanvas.cancelAnimation();\n        this.addDrawingEvent(["SC", s, t]);\n        this.addDrawingEvent(["NO"]);\n      }\n      if (t) {\n        this.spriteCanvas.setSegmentLength(t);\n        // set the number of units to divide a segment into\n      }\n      else {\n        this.spriteCanvas.setSegmentLength(10);\n      }\n    }\n\n    Sprite.prototype.tracer = function(t, d) {\n      this.spriteCanvas.setCounter(t);\n      if (t == 0) {\n       this.animate=false;\n       this.spriteCanvas.cancelAnimation();\n     }\n     if (d !== undefined)\n       this.spriteCanvas.setDelay(d);\n   }\n\n   Sprite.prototype.getRenderCounter = function() {\n    return this.spriteCanvas.getCounter();\n  }\n\n  Sprite.prototype.turn = function (phi) {\n    with (this) {\n      var alpha = phi * Degree2Rad;\n      var left = normal.cross(heading);\n      var newheading = heading.rotateNormal(left, normal, alpha);\n      heading = newheading;\n\n      if (animate) {\n        addDrawingEvent(["TT",heading]);\n      }\n    }\n  }\n\n  Sprite.prototype.right = Sprite.prototype.turn;\n\n  Sprite.prototype.left = function(phi) {\n    this.turn(-phi);\n  }\n\n  Sprite.prototype.get_heading = function () {\n    if (SpriteGraphics.defaults.degrees)\n      return this.heading.toAngle()\n    else\n      return this.heading\n  }\n\n  Sprite.prototype.get_position = function () {\n    return this.position;\n  }\n\n  Sprite.prototype.getx = function () {\n    return this.position[0];\n  }\n\n  Sprite.prototype.gety = function () {\n    return this.position[1];\n  }\n\n  Sprite.prototype.set_heading = function(newhead) {\n    if ((typeof(newhead)).toLowerCase() === \'number\') {\n      this.heading = Vector.angle2vec(newhead);\n    } else {\n      this.heading = newhead;\n    }\n  }\n\n  Sprite.prototype.towards = function(to, y) {\n    // set heading vector to point towards another point.\n    if ((typeof(to)).toLowerCase() === \'number\')\n      to = new Vector(to, y, 0);\n    else if (! (to instanceof Vector)) {\n      to = new Vector(to);\n    }\n    var res = to.sub(this.position);\n    res = res.normalize();\n    if (SpriteGraphics.defaults.degrees)\n      return res.toAngle();\n    else\n      return res;\n  }\n\n  Sprite.prototype.distance = function(to, y) {\n    if ((typeof(to)).toLowerCase() === \'number\')\n      to = new Vector(to, y, 0);\n    return this.position.sub(new Vector(to)).len();\n  }\n\n  Sprite.prototype.dot = function() {\n    var size = 2;\n    if (arguments.length >= 1) size = arguments[0];\n    size = size * this.spriteCanvas.lineScale;\n    with (this) {\n      with (context) {\n        var color = penStyle;\n        var nc = arguments[1] || color;\n        if (! animate) {\n          fillStyle = nc;\n          fillRect(position[0] - size / 2, position[1] - size / 2, size, size);\n          fillStyle = color;\n        } else {\n          addDrawingEvent(["DT", size, nc, position[0], position[1]]);\n        }\n      }\n    }\n  }\n\n  Sprite.prototype.circle = function(radius, extent) {\n    if (extent === undefined) {\n      extent = 360\n    }\n    if (this.animate) {\n     var arcLen = Math.abs(radius * Math.PI * 2.0  * extent / 360);\n     var segLen = this.spriteCanvas.getSegmentLength();\n     if (arcLen <= segLen)\n      this.arc(radius,extent);\n    else {\n        //  Break the arc into segments for animation\n        var extentPart = (segLen / arcLen) * extent;\n        var extentLeft = extent;\n        while (Math.abs(extentLeft) > Math.abs(extentPart)) {\n          this.arc(radius, extentPart);\n          extentLeft = extentLeft - extentPart;\n        }\n        if (Math.abs(extentLeft) > 0.01)\n          this.arc(radius, extentLeft);\n      }\n    } else {\n      this.arc(radius,extent);\n    }\n  }\n  \n  Sprite.prototype.arc = function(radius, extent) {\n    //  Figure out where the sprite is and which way it\'s facing\n    var spriteHeading = this.get_heading()\n    var tx = this.position[0]\n    var ty = this.position[1]\n\n    //  Figure out the circle center\n    var cx = tx + (radius * Sk.math.cos((spriteHeading + 90) * Degree2Rad));\n    var cy = ty + (radius * Sk.math.sin((spriteHeading + 90) * Degree2Rad));\n\n    //  Canvas arc angles go CLOCKWISE, not COUNTERCLOCKWISE like Sprite\n\n    //  Figure out our arc angles\n    var startAngleDeg;\n    if (radius >= 0)\n      startAngleDeg = spriteHeading - 90;\n    else\n      startAngleDeg = spriteHeading + 90;\n\n    var endAngleDeg;\n    if (extent) {\n      if (radius >= 0)\n        endAngleDeg = startAngleDeg + extent;\n      else\n        endAngleDeg = startAngleDeg - extent;\n    }\n    else {\n      if (radius >= 0)\n        endAngleDeg = startAngleDeg + 360;\n      else\n        endAngleDeg = startAngleDeg - 360;\n    }\n\n    //  Canvas angles are opposite\n    startAngleDeg = 360 - startAngleDeg\n    endAngleDeg   = 360 - endAngleDeg\n\n    //  Becuase the y axis has been flipped in HTML5 Canvas with a tanslation, we need to adjust the angles\n    startAngleDeg = -startAngleDeg\n    endAngleDeg   = -endAngleDeg\n\n    //  Convert to radians\n    var startAngle = startAngleDeg * Degree2Rad;\n    var endAngle   = endAngleDeg   * Degree2Rad;\n\n\n    //  Do the drawing\n    if (! this.animate) {\n      if (!this.filling)\n        this.context.beginPath();\n      this.context.arc(cx, cy, Math.abs(radius), startAngle, endAngle, (radius * extent <= 0));\n      this.context.stroke();\n      if (!this.filling)\n        this.context.closePath();\n    }\n    else {\n      this.addDrawingEvent(["CI", cx, cy, Math.abs(radius), startAngle, endAngle, (radius * extent <= 0)]);\n    }\n\n    //  Move the sprite only if we have to\n    if (extent && (extent % 360) != 0) {\n      var turtleArc;\n      if (radius >= 0)\n        turtleArc = extent;\n      else \n        turtleArc = -extent;\n      var newHeading = (spriteHeading + turtleArc) % 360;\n      if (newHeading < 0)\n        newHeading = newHeading + 360;\n\n      var nx = cx + (radius * Sk.math.cos((newHeading - 90) * Degree2Rad));\n      var ny = cy + (radius * Sk.math.sin((newHeading - 90) * Degree2Rad));  //  y coord is inverted in sprite\n\n      //  Move it internally\n      this.set_heading(newHeading);\n      this.teleport_to(nx,ny);\n\n      //  If we\'re animating the sprite, move it on the screen\n      if (this.animate) {\n        this.addDrawingEvent(["TT", this.heading]);\n      }\n    }\n  }\n\n  Sprite.prototype.write = function(theText, move, align, font) {\n    if (! this.animate) {\n      if (font)\n        this.context.font = font.v;\n      this.context.scale(1, -1);\n      this.context.fillText(theText, this.position[0], -this.position[1]);\n      this.context.scale(1, -1);\n    } else {\n      var fontspec;\n      if (font)\n        fontspec = font.v\n      this.addDrawingEvent(["WT", theText, fontspec, this.position[0], this.position[1]]);\n    }\n  }\n\n  Sprite.prototype.setworldcoordinates = function(llx, lly, urx, ury) {\n    this.spriteCanvas.setworldcoordinates(llx, lly, urx, ury);\n  }\n\n  //\n  // Pen and Style functions\n  //\n  Sprite.prototype.pen_down = function () {\n    this.pen = true;\n  }\n\n  Sprite.prototype.down = Sprite.prototype.pen_down;\n\n  Sprite.prototype.pen_up = function () {\n    this.pen = false;\n  }\n\n  Sprite.prototype.up = Sprite.prototype.pen_up;\n\n  Sprite.prototype.get_pen = function () {\n    return this.pen;\n  }\n\n  Sprite.prototype.set_pen_width = function (w) {\n    if (this.animate)\n      this.addDrawingEvent(["PW", w * this.spriteCanvas.lineScale]);\n    else\n      this.penWidth = w;\n  }\n\n  Sprite.prototype.get_pen_width = function() {\n    return this.penWidth * this.spriteCanvas.lineScale;\n  }\n\n  Sprite.prototype.set_pen_color = function (c, g, b) {\n    if (typeof(c) == "string") {\n      this.penStyle = c;\n    }\n    else {\n      var rs\n      var gs\n      var bs\n      if (typeof( c) == "object" && c.length == 3) {\n        var c0 = Sk.builtin.asnum$(c[0]);\n        var c1 = Sk.builtin.asnum$(c[1]);\n        var c2 = Sk.builtin.asnum$(c[2]);\n      }\n      else {\n        var c0 = Sk.builtin.asnum$(c);\n        var c1 = Sk.builtin.asnum$(g);\n        var c2 = Sk.builtin.asnum$(b);\n      }\n      rs = c0.toString(16);\n      gs = c1.toString(16);\n      bs = c2.toString(16);\n      while (rs.length < 2) rs = "0" + rs;\n      while (gs.length < 2) gs = "0" + gs;\n      while (bs.length < 2) bs = "0" + bs;\n      c = "#" + rs + gs + bs;\n      this.penStyle = c;\n    }\n\n    this.context.strokeStyle = c;\n    if (this.animate)\n      this.addDrawingEvent(["TC", c]);\n  }\n\n  Sprite.prototype.set_fill_color = function (c, g, b) {\n    if (typeof(c) == "string") {\n      this.fillStyle = c;\n    }\n    else {\n      var rs\n      var gs\n      var bs\n      if (typeof( c) == "object" && c.length == 3) {\n        var c0 = Sk.builtin.asnum$(c[0]);\n        var c1 = Sk.builtin.asnum$(c[1]);\n        var c2 = Sk.builtin.asnum$(c[2]);\n      } else {\n        var c0 = Sk.builtin.asnum$(c);\n        var c1 = Sk.builtin.asnum$(g);\n        var c2 = Sk.builtin.asnum$(b);\n      }\n      rs = c0.toString(16)\n      gs = c1.toString(16)\n      bs = c2.toString(16)\n      while (rs.length < 2) rs = "0" + rs;\n      while (gs.length < 2) gs = "0" + gs;\n      while (bs.length < 2) bs = "0" + bs;\n      c = "#" + rs + gs + bs;\n      this.fillStyle = c;\n    }\n\n    this.context.fillStyle = c;\n    if (this.animate)\n      this.addDrawingEvent(["FC", c]);\n  }\n\n  Sprite.prototype.begin_fill = function () {\n    if (! this.animate) {\n      this.filling = true;\n      this.context.beginPath();\n      this.context.moveTo(this.position[0], this.position[1]);\n    }\n    else {\n      this.addDrawingEvent(["BF", this.position[0], this.position[1]]);\n    }\n  }\n\n  Sprite.prototype.end_fill = function () {\n    if (! this.animate) {\n      this.context.stroke();\n      this.context.fill();\n      this.context.closePath();\n      this.filling = false;\n    } else\n    this.addDrawingEvent(["EF", this.position[0], this.position[1], this.fillStyle]);\n  }\n\n  Sprite.prototype.showturtle = function() {\n    if (this.animate) {\n      this.addDrawingEvent(["SH"]);\n    }\n    this.visible = true;\n  }\n\n  Sprite.prototype.hideturtle = function() {\n    if (this.animate) {\n      this.addDrawingEvent(["HT"]);\n    }\n    this.visible = false;\n  }\n\n  Sprite.prototype.isvisible = function() {\n    return this.visible;\n  }\n\n  // \n  // Appearance\n  //\n\n  Sprite.prototype.shape = function(s) {\n    if (this.shapeStore[s])\n      this.currentShape = s;\n    else {\n    }\n  }\n\n  Sprite.prototype.drawSprite = function(heading, position) {\n    var rtPoints = [];\n    var plist = this.shapeStore[this.currentShape];\n    var head;\n    if (! (heading === undefined))\n      head = heading - 90.0;\n    else\n      head = this.heading.toAngle() - 90.0;\n    if (! position)\n      position = this.position\n    for (p in plist) {\n      rtPoints.push(plist[p].scale(this.spriteCanvas.xptscale,this.spriteCanvas.yptscale).rotate(head).add(position));\n    }\n    this.context.beginPath();\n    this.context.moveTo(rtPoints[0][0], rtPoints[0][1]);\n    for (var i = 1; i < rtPoints.length; i++) {\n      this.context.lineTo(rtPoints[i][0], rtPoints[i][1]);\n    }\n    this.context.closePath();\n    this.context.stroke();\n    if (this.fillStyle) {\n      this.context.fill();\n    }\n  }\n\n  Sprite.prototype.stamp = function() {\n    // either call drawSprite or just add a DT with current position and heading to the drawingEvents list.\n    if (this.animate) {\n      this.addDrawingEvent(["ST",this.position[0],this.position[1],this.heading.toAngle()]);\n    } else\n    this.drawSprite();\n  }\n\n  Sprite.prototype.clear = function () {\n    if (this.animate) {\n      this.addDrawingEvent(["CL"])\n    }\n    else {\n      clear_canvas(this.canvasID);\n    }\n  }\n\n  function clear_canvas(canId) {\n    with (document.getElementById(canId).getContext(\'2d\')) {\n      if (arguments.length >= 2) {\n        // fillStyle = arguments[1];\n        // fillRect(0, 0, canvas.width, canvas.height);\n      }\n      clearRect(-canvas.width / 2, -canvas.height / 2, canvas.width, canvas.height);\n    }\n  }\n\n\n  // Create a 3d Vector class for manipulating sprite heading, and position.\n\n  function Vector(x, y, z) {\n    if ((typeof(x)).toLowerCase() === \'number\') {\n      Array.prototype.push.call(this, x);\n      Array.prototype.push.call(this, y);\n      Array.prototype.push.call(this, z);\n    }\n    else {\n      for (var i in x) {\n        Array.prototype.push.call(this, x[i]);\n      }\n    }\n  }\n\n\n  // Create a vector object given a direction as an angle.\n  Vector.angle2vec = function(phi) {\n    var res = new Vector([0.0,0.0,0.0]);\n    phi = phi * Degree2Rad;\n    res[0] = Sk.math.cos(phi);\n    res[1] = Sk.math.sin(phi);\n    return res.normalize();\n  }\n\n  // This trick allows you to access a Vector object like an array\n  // myVec[0] == x\n  // myVec[1] == y\n  // myVec[2] == z\n  // we really only need the z for the convenience of rotating!\n  // If we were using Geometric Algebra we wouldn\'t need it at all and could stay in the plane.\n  Vector.prototype.addItem = function(item) {\n    Array.prototype.push.call(this, item);\n  }\n\n  Vector.prototype.linear = function(a, b, v) {\n    var result = [ ];\n    for (var c = 0; c <= 2; ++c) {\n      result[c] = a * this[c] + b * v[c];\n    }\n    return new Vector(result);\n  }\n\n  Vector.prototype.cross = function(v) {\n    // Return cross product of this and v\n    var result = [ ];\n    for (var c = 0; c <= 2; ++c) {\n      result[c] = this[(c + 1) % 3] * v[(c + 2) % 3] - this[(c + 2) % 3] * v[(c + 1) % 3];\n    }\n    return new Vector(result);\n  }\n\n  Vector.prototype.rotate = function(angle) {\n    // Rotate this counter clockwise by angle.\n    var perp = new Vector(-this[1], this[0], 0);\n    angle = angle * Degree2Rad;\n    var c = Sk.math.cos(angle);\n    var s = Sk.math.sin(angle);\n    return new Vector(this[0] * c + perp[0] * s, this[1] * c + perp[1] * s, 0);\n  }\n\n  Vector.prototype.rotateNormal = function(v, w, alpha) {\n    // Return rotation of this in direction of v about w over alpha\n    // Requires: v, w are vectors; alpha is angle in radians\n    //   this, v, w are orthonormal\n    return this.linear(Sk.math.cos(alpha), Sk.math.sin(alpha), v);\n  }\n\n  Vector.prototype.normalize = function() {\n    var n = this.len();\n    var res = this.div(n);\n    return res;\n  }\n\n  Vector.prototype.toAngle = function() {\n    // workaround for values getting set to +/i xxx e -16 fooling the +/- checks below\n    if (Math.abs(this[1]) < 0.00001) this[1] = 0.0;\n    if (Math.abs(this[0]) < 0.00001) this[0] = 0.0;\n    var rads = Math.atan(Math.abs(this[1]) / Math.abs(this[0]));\n    var deg = rads * Rad2Degree;\n    if (this[0] < 0 && this[1] > 0) deg = 180 - deg;\n    else if (this[0] < 0 && this[1] <= 0) deg = 180.0 + deg;\n    else if (this[0] >= 0 && this[1] < 0) deg = 360 - deg;\n    return deg;\n  }\n\n  // divide all vector components by the same value\n  Vector.prototype.div = function(n) {\n    res = []\n    res[0] = this[0] / n;\n    res[1] = this[1] / n;\n    res[2] = this[2] / n;\n    return new Vector(res);\n  }\n\n  // subtract one vector from another\n  Vector.prototype.sub = function(v) {\n    res = new Vector(0, 0, 0);\n    res[0] = this[0] - v[0];\n    res[1] = this[1] - v[1];\n    res[2] = this[2] - v[2];\n    return res;\n  }\n\n  Vector.prototype.add = function(v) {\n    res = new Vector(0, 0, 0);\n    res[0] = this[0] + v[0];\n    res[1] = this[1] + v[1];\n    res[2] = this[2] + v[2];\n    return res;\n  }\n\n  Vector.prototype.smul = function(k) {  // scalar multiplication\n    res = new Vector(0, 0, 0);\n    res[0] = this[0] * k;\n    res[1] = this[1] * k;\n    res[2] = this[2] * k;\n    return res;\n  }\n\n  Vector.prototype.scale = function(xs,ys) {\n    res = new Vector(0,0,0);\n    res[0] =  this[0] * ys;\n    res[1] =  this[1] * xs;\n    res[2] = 1.0;\n    return res;\n  }\n\n  Vector.prototype.len = function() {\n    return Math.sqrt(this[0] * this[0] + this[1] * this[1] + this[2] * this[2]);\n  }\n\n  SpriteGraphics.defaults = {canvasID: \'mycanvas\', degrees: true, animate: true};\n  SpriteGraphics.spriteList = [];\n  SpriteGraphics.Sprite = Sprite;\n  SpriteGraphics.SpriteCanvas = SpriteCanvas;\n  SpriteGraphics.canvasLib = {};\n  SpriteGraphics.clear_canvas = clear_canvas;\n  SpriteGraphics.Vector = Vector;\n  SpriteGraphics.canvasInit = false;\n  SpriteGraphics.eventCount = 0;\n  SpriteGraphics.renderClock = 0;\n  SpriteGraphics.renderTime  = 0;\n\n})();\n\nvar $builtinmodule = function(name) {\n\n  var mod = {};\n\n  Sk.builtin.defineEuclidean2(mod, BLADE);\n\n  // The exported name of the SPRITE class.\n  var SPRITE = "Sprite";\n\n  // First we create an object, this will end up being the class\n  Sk.tg = SpriteGraphics;\n\n  var checkArgs = function(expected, actual, func) {\n    if (actual != expected ) {\n      throw new Sk.builtin.TypeError(func + " takes exactly " + expected + " positional argument (" + actual + " given)");\n    }\n  }\n\n  var sprite = function($gbl, $loc) {\n\n    $loc.__init__ = new Sk.builtin.func(function(self, options) {\n      SpriteGraphics.defaults = {"canvasID": Sk.canvas, "animate": true, "degrees": true};\n      self.skType = SPRITE;\n      self.tp$name = SPRITE;\n      self.v = new SpriteGraphics.Sprite();\n      if (options instanceof Sk.builtin.dict) {\n        for (var iter = options.tp$iter(), k = iter.tp$iternext(); k !== undefined; k = iter.tp$iternext()) {\n          var v = options.mp$subscript(k);\n          if (v === undefined) {\n            v = null;\n          }\n          var kAsJs = Sk.ffi.remapToJs(k);\n          var vAsJs = Sk.ffi.remapToJs(v);\n          Sk.misceval.callsim(self[\'__setattr__\'], self, kAsJs, v);\n        }\n      }\n    });\n\n    $loc.__getattr__ = new Sk.builtin.func(function(self, key) {\n\n      var BACKWARD = "backward";\n      var BEGIN_FILL = "begin_fill";\n      // color is implemented as a callable attribute for compatibility.\n      var COLOR = "color";\n      var DOWN = "down";\n      var END_FILL = "end_fill";\n      // FILL_COLOR is implemented as a callable attribute for backwcompatibility.\n      var FILL_COLOR = "fillcolor";\n      var FORWARD = "forward";\n      var GOTO = "goto";\n      var LEFT = "left";\n      var POSITION = "position";\n      var RIGHT = "right";\n      // shape is implemented as a callable attribute for compatibility.\n      var SHAPE = "shape";\n      var STAMP = "stamp";\n      var UP = "up";\n      // Capture the target of the attribute operation.\n      var target = self.v;\n\n      switch(key) {\n        case BACKWARD: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = BACKWARD;\n            });\n\n            $loc.__call__ = new Sk.builtin.func(function(self, distance) {\n              distance = Sk.builtin.asnum$(distance);\n              checkArgs(2, arguments.length, BACKWARD);\n              target.forward(-distance);\n            });\n\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return Sk.builtin.stringToPy(BACKWARD)\n            })\n\n            $loc.__repr__ = new Sk.builtin.func(function(self, arg) {\n              return Sk.builtin.stringToPy(BACKWARD)\n            })\n\n          }, BACKWARD, []));\n        }\n        case BEGIN_FILL: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = BEGIN_FILL;\n            });\n\n            $loc.__call__ = new Sk.builtin.func(function(self) {\n              checkArgs(1, arguments.length, BEGIN_FILL);\n              target.begin_fill();\n            });\n\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return Sk.builtin.stringToPy(BEGIN_FILL)\n            })\n\n            $loc.__repr__ = new Sk.builtin.func(function(self, arg) {\n              return Sk.builtin.stringToPy(BEGIN_FILL)\n            })\n\n          }, BEGIN_FILL, []));\n        }\n        case COLOR: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = COLOR;\n            });\n\n            $loc.__call__ = new Sk.builtin.func(function(self, color, green, blue) {\n              if(color) {\n                if (blue) {\n                  target.set_pen_color(color, green, blue);\n                  target.set_fill_color(color, green, blue);\n                }\n                else {\n                  color = color.v || target.context.fillStyle;\n                  target.set_pen_color(color);\n                  target.set_fill_color(color);\n                }\n              }\n              else {\n                return [target.penStyle, target.fillStyle];\n              }\n            });\n\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return Sk.builtin.stringToPy(COLOR)\n            })\n\n            $loc.__repr__ = new Sk.builtin.func(function(self, arg) {\n              return Sk.builtin.stringToPy(COLOR)\n            })\n\n          }, COLOR, []));\n        }\n        case DOWN: {\n          return Sk.ffi.callableToPy(mod, DOWN, function(methodPy) {\n            Sk.ffi.checkMethodArgs(DOWN, arguments, 0, 0);\n            target.pen_down();\n          });\n        }\n        case END_FILL: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = END_FILL;\n            });\n\n            $loc.__call__ = new Sk.builtin.func(function(self) {\n              checkArgs(1, arguments.length, END_FILL);\n              target.end_fill();\n            });\n\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return Sk.builtin.stringToPy(END_FILL)\n            })\n\n            $loc.__repr__ = new Sk.builtin.func(function(self, arg) {\n              return Sk.builtin.stringToPy(END_FILL)\n            })\n\n          }, END_FILL, []));\n        }\n        case FILL_COLOR: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = FILL_COLOR;\n            });\n\n            $loc.__call__ = new Sk.builtin.func(function(self, color, green, blue) {\n              if (color) {\n                if (blue) {\n                  target.set_fill_color(color, green, blue);\n                }\n                else {\n                  color = color.v || target.context.fillStyle;\n                  target.set_fill_color(color);\n                }\n              }\n              else {\n                return target.fillStyle;\n              }\n            });\n\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return Sk.builtin.stringToPy(FILL_COLOR)\n            })\n\n            $loc.__repr__ = new Sk.builtin.func(function(self, arg) {\n              return Sk.builtin.stringToPy(FILL_COLOR)\n            })\n\n          }, FILL_COLOR, []));\n        }\n        case FORWARD: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = FORWARD;\n            });\n\n            $loc.__call__ = new Sk.builtin.func(function(self, distance) {\n              distance = Sk.builtin.asnum$(distance);\n              checkArgs(2, arguments.length, FORWARD);\n              target.forward(distance);\n            });\n\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return Sk.builtin.stringToPy(FORWARD)\n            })\n\n            $loc.__repr__ = new Sk.builtin.func(function(self, arg) {\n              return Sk.builtin.stringToPy(FORWARD)\n            })\n\n          }, FORWARD, []));\n        }\n        case GOTO: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = GOTO;\n            });\n\n            $loc.__call__ = new Sk.builtin.func(function(self, nx, ny) {\n              nx = Sk.builtin.asnum$(nx);\n              ny = Sk.builtin.asnum$(ny);\n              checkArgs(3, arguments.length, GOTO);\n              target.goto(nx, ny);\n            });\n\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return Sk.builtin.stringToPy(GOTO)\n            })\n\n            $loc.__repr__ = new Sk.builtin.func(function(self, arg) {\n              return Sk.builtin.stringToPy(GOTO)\n            })\n\n          }, GOTO, []));\n        }\n        case LEFT: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = LEFT;\n            });\n\n            $loc.__call__ = new Sk.builtin.func(function(self, angle) {\n              angle = Sk.builtin.asnum$(angle);\n              checkArgs(2, arguments.length, LEFT);\n              target.turn(-angle);\n            });\n\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return Sk.builtin.stringToPy(LEFT)\n            })\n\n            $loc.__repr__ = new Sk.builtin.func(function(self, arg) {\n              return Sk.builtin.stringToPy(LEFT)\n            })\n\n          }, LEFT, []));\n        }\n        case POSITION: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = POSITION;\n              checkArgs(1, arguments.length, POSITION);\n            });\n\n            $loc.__getattr__ = new Sk.builtin.func(function(self, key) {\n              switch(key) {\n                case "x": {\n                  var position = target.get_position();\n                  return Sk.builtin.numberToPy(position[0]);\n                }\n                break;\n                case "y": {\n                  var position = target.get_position();\n                  return Sk.builtin.numberToPy(position[1]);\n                }\n                break;\n                default: {\n                  // do nothing.\n                }\n              }\n            });\n\n            $loc.__setattr__ = new Sk.builtin.func(function(self, key, value) {\n              switch(key) {\n                case "x": {\n                  var nx = Sk.builtin.asnum$(value);\n                  checkArgs(3, arguments.length, key);\n                  target.goto(nx, target.gety());\n                }\n                break;\n                case "y": {\n                  var ny = Sk.builtin.asnum$(value);\n                  checkArgs(3, arguments.length, key);\n                  target.goto(target.getx(), ny);\n                }\n                break;\n                default: {\n                  // do nothing.\n                }\n              }\n            });\n\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return Sk.builtin.stringToPy(POSITION)\n            })\n\n            $loc.__repr__ = new Sk.builtin.func(function(self, arg) {\n              return Sk.builtin.stringToPy(POSITION)\n            })\n\n          }, POSITION, []));\n        }\n        case RIGHT: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = RIGHT;\n            });\n\n            $loc.__call__ = new Sk.builtin.func(function(self, angle) {\n              angle = Sk.builtin.asnum$(angle);\n              checkArgs(2, arguments.length, RIGHT);\n              target.turn(angle);\n            });\n\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return Sk.builtin.stringToPy(RIGHT)\n            })\n\n            $loc.__repr__ = new Sk.builtin.func(function(self, arg) {\n              return Sk.builtin.stringToPy(RIGHT)\n            })\n\n          }, RIGHT, []));\n        }\n        case SHAPE: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = SHAPE;\n            });\n\n            $loc.__call__ = new Sk.builtin.func(function(self, shape) {\n              checkArgs(2, arguments.length, SHAPE);\n              target.shape(shape.v);\n            });\n\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return Sk.builtin.stringToPy(SHAPE)\n            })\n\n            $loc.__repr__ = new Sk.builtin.func(function(self, arg) {\n              return Sk.builtin.stringToPy(SHAPE)\n            })\n\n          }, SHAPE, []));\n        }\n        case STAMP: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = STAMP;\n            });\n\n            $loc.__call__ = new Sk.builtin.func(function(self) {\n              checkArgs(1, arguments.length, STAMP);\n              target.stamp();\n            });\n\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return Sk.builtin.stringToPy(STAMP)\n            })\n\n            $loc.__repr__ = new Sk.builtin.func(function(self, arg) {\n              return Sk.builtin.stringToPy(STAMP)\n            })\n\n          }, STAMP, []));\n        }\n        case UP: {\n          return Sk.ffi.callableToPy(mod, UP, function(methodPy) {\n            Sk.ffi.checkMethodArgs(UP, arguments, 0, 0);\n            target.pen_up();\n          });\n        }\n        default: {\n          // Do nothing\n        }\n      }\n    });\n\n    $loc.__setattr__ = new Sk.builtin.func(function(selfPy, name, valuePy) {\n\n      var COLOR = "color";\n      var FILL_COLOR = "fillcolor";\n      var POSITION = "position";\n      var SHAPE = "shape";\n      var EUCLIDEAN_2 = "Euclidean2";\n\n      switch(name) {\n        case COLOR: {\n          if(valuePy) {\n            var color = valuePy.v || selfPy.v.context.fillStyle;\n            selfPy.v.set_pen_color(color);\n            selfPy.v.set_fill_color(color);\n          }\n        }\n        break;\n        case FILL_COLOR: {\n          if (valuePy) {\n            selfPy.v.set_fill_color(valuePy.v || selfPy.v.context.fillStyle);\n          }\n        }\n        break;\n        case POSITION: {\n          Sk.ffi.checkArgType("value", EUCLIDEAN_2, Sk.ffi.isInstance(valuePy) && Sk.ffi.typeName(valuePy) === EUCLIDEAN_2);\n          var xPy = Sk.ffi.gattr(valuePy, "x");\n          var yPy = Sk.ffi.gattr(valuePy, "y");\n          selfPy.v.goto(Sk.ffi.remapToJs(xPy), Sk.ffi.remapToJs(yPy));\n        }\n        break;\n        case SHAPE: {\n          if (valuePy) {\n            checkArgs(3, arguments.length, SHAPE);\n            selfPy.v.shape(valuePy.v);\n          }\n        }\n        break;\n        default: {\n//          throw new Sk.builtin.AttributeError("\'" + SPRITE + "\' object has no attribute setter \'" + name + "\'.");\n        }\n      }\n    });\n\n    $loc.setposition = new Sk.builtin.func(function(self,nx,ny) {\n      nx = Sk.builtin.asnum$(nx);\n      ny = Sk.builtin.asnum$(ny);\n      checkArgs(3,arguments.length,"setposition()");\n      self.v.up();\n      self.v.goto(nx,ny);\n      self.v.down();\n    });\n\n    $loc.setpos = $loc.setposition;\n\n    $loc.setheading = new Sk.builtin.func(function(self, newhead) {\n      newhead = Sk.builtin.asnum$(newhead);\n      checkArgs(2,arguments.length,"setheading()");\n      return self.v.set_heading(newhead);\n    });\n\n    $loc.seth = $loc.setheading;\n\n    $loc.home = new Sk.builtin.func(function(self) {\n      self.v.go_home();\n    });\n\n    $loc.dot = new Sk.builtin.func(function(self, /*opt*/ size, color) {\n      size = Sk.builtin.asnum$(size);\n      size = size || 1;\n      if (color) {\n        color = color.v || self.v.penStyle;\n      }\n      self.v.dot(size, color);\n    });\n\n    $loc.circle = new Sk.builtin.func(function(self, radius, extent) {\n      radius = Sk.builtin.asnum$(radius);\n      extent = Sk.builtin.asnum$(extent);\n      self.v.circle(radius, extent);\n    });\n\n    $loc.delay = new Sk.builtin.func(function(self, d) {\n      d = Sk.builtin.asnum$(d);\n      return self.v.delay(d);\n    });\n\n    $loc.speed = new Sk.builtin.func(function(self, s, t) {\n      s = Sk.builtin.asnum$(s);\n      t = Sk.builtin.asnum$(t);\n      self.v.speed(s,t);\n    });\n\n    $loc.tracer = new Sk.builtin.func(function(self, t, d) {\n      t = Sk.builtin.asnum$(t);\n      d = Sk.builtin.asnum$(d);\n      self.v.tracer(t, d);\n    });\n\n    $loc.update = new Sk.builtin.func(function(self) {\n      //  Dummy function to emulate update... when not animating, we don\'t save the drawing operations, so this is pointless for us\n    });\n\n    $loc.heading = new Sk.builtin.func(function(self) {\n      checkArgs(1,arguments.length,"heading()");\n      return self.v.get_heading();\n    });\n\n    $loc.xcor = new Sk.builtin.func(function(self) {\n      checkArgs(1,arguments.length,"xcor()");\n      var res = self.v.getx();\n      return res;\n    });\n\n    $loc.ycor = new Sk.builtin.func(function(self) {\n      checkArgs(1,arguments.length,"ycor()");\n      var res = self.v.gety();\n      return res;\n    });\n\n    $loc.towards = new Sk.builtin.func(function(self, tx, ty) {\n      tx = Sk.builtin.asnum$(tx);\n      ty = Sk.builtin.asnum$(ty);\n      if ((typeof(tx)).toLowerCase() === \'number\')\n        tx = [tx, ty, 0];\n      return self.v.towards(tx);\n    });\n\n    // tx can be either a number or a vector position.\n    // tx can not be a sprite at this time as multiple sprites have not been implemented yet.\n    $loc.distance = new Sk.builtin.func(function(self, tx, ty) {\n      tx = Sk.builtin.asnum$(tx);\n      ty = Sk.builtin.asnum$(ty);\n      if ((typeof(tx)).toLowerCase() === \'number\') {\n        tx = [tx, ty, 0];\n      }\n      else {\n        tx = [tx.v.getx(), tx.v.gety(), 0];\n      }\n      return self.v.distance(tx);\n    });\n\n    //\n    // Setting and Measurement\n    //\n\n    $loc.width = new Sk.builtin.func(function(self, w) {\n     w = Sk.builtin.asnum$(w);\n     checkArgs(2,arguments.length,"width()");\n     self.v.set_pen_width(w);\n   });\n\n    $loc.pensize = $loc.width;\n\n    $loc.isdown = new Sk.builtin.func(function(self) {\n      checkArgs(1,arguments.length,"isdown()");\n      return self.v.get_pen();\n    });\n\n    $loc.pencolor = new Sk.builtin.func(function(self, color, green, blue) {\n      if (color) {\n        if (blue) {\n          color = Sk.builtin.asnum$(color);\n          green = Sk.builtin.asnum$(green);\n          blue = Sk.builtin.asnum$(blue);\n          self.v.set_pen_color(color, green, blue);\n        }\n        else {\n          color = color.v || self.v.context.fillStyle;\n          self.v.set_pen_color(color);\n        }\n      }\n      else {\n        return self.v.penStyle;\n      }\n    });\n\n    $loc.color = new Sk.builtin.func(function(self, color, green, blue) {\n      if(color) {\n        if (blue) {\n          self.v.set_pen_color(color, green, blue);\n          self.v.set_fill_color(color, green, blue);\n        }\n        else {\n          color = color.v || self.v.context.fillStyle;\n          self.v.set_pen_color(color);\n          self.v.set_fill_color(color);\n        }\n      }\n      else {\n        return [self.v.penStyle, self.v.fillStyle];\n      }\n    });\n\n    $loc.fill = new Sk.builtin.func(function(self, fillt) {\n      if (fillt === undefined)\n        return self.v.filling;\n      if (fillt)\n        self.v.begin_fill();\n      else\n        self.v.end_fill();\n    });\n\n    //\n    // More drawing control\n    //\n\n    $loc.reset = new Sk.builtin.func(function(self) {\n      self.v.clean();\n    });\n\n    $loc.showturtle = new Sk.builtin.func(function(self) {\n      checkArgs(1,arguments.length,"showturtle()");\n      self.v.showturtle();\n    });\n\n    $loc.st = $loc.showturtle;\n\n    $loc.hideturtle = new Sk.builtin.func(function(self) {\n      checkArgs(1,arguments.length,"hideturtle()");\n      self.v.hideturtle();\n    });\n\n    $loc.ht = $loc.hideturtle;\n\n    $loc.isvisible = new Sk.builtin.func(function(self) {\n      checkArgs(1,arguments.length,"isvisible()");\n      self.v.isvisible()\n    });\n\n    // todo the move, align, and font parameters should be kwargs...\n    $loc.write = new Sk.builtin.func(function(self, mystr, move, align, font) {\n      self.v.write(mystr.v, move, align, font);\n    });\n\n    // todo clean  -- again multiple sprites\n\n    $loc.setworldcoordinates = new Sk.builtin.func(function(self, llx, lly, urx, ury) {\n      llx = Sk.builtin.asnum$(llx);\n      lly = Sk.builtin.asnum$(lly);\n      urx = Sk.builtin.asnum$(urx);\n      ury = Sk.builtin.asnum$(ury);\n      self.v.setworldcoordinates(llx, lly, urx, ury);\n    });\n\n    $loc.clear = new Sk.builtin.func(function(self) {\n      self.v.clear()\n    });\n  }\n\n  mod[SPRITE] = Sk.misceval.buildClass(mod, sprite, SPRITE, []);\n\n  var screen = function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self) {\n      SpriteGraphics.defaults = {canvasID: Sk.canvas, animate: true, degrees: true};\n      var currentCanvas = SpriteGraphics.canvasLib[SpriteGraphics.defaults.canvasID];\n      if (currentCanvas === undefined) {\n        self.theScreen = new SpriteGraphics.SpriteCanvas(SpriteGraphics.defaults);\n      } else {\n        self.theScreen = currentCanvas;\n      }\n    });\n\n    $loc.bgcolor = new Sk.builtin.func(function(self, c) {\n      self.theScreen.bgcolor(c);\n    });\n\n    $loc.setworldcoordinates = new Sk.builtin.func(function(self, llx,lly,urx,ury) {\n     llx = Sk.builtin.asnum$(llx);\n     lly = Sk.builtin.asnum$(lly);\n     urx = Sk.builtin.asnum$(urx);\n     ury = Sk.builtin.asnum$(ury);\n     self.theScreen.setworldcoordinates(llx,lly,urx,ury);\n   });\n\n    $loc.exitonclick = new Sk.builtin.func(function(self) {\n      self.theScreen.exitonclick();\n    });\n\n    $loc.title = new Sk.builtin.func(function(self,titlestring) {\n      // no op....\n    });\n\n    $loc.window_width = new Sk.builtin.func(function(self) {\n      return self.theScreen.window_width();\n    });\n\n    $loc.window_height = new Sk.builtin.func(function(self) {\n      return self.theScreen.window_height();\n    });\n\n    $loc.sprites = new Sk.builtin.func(function(self) {\n      return self.theScreen.sprites();\n    });\n\n    $loc.colormode = new Sk.builtin.func(function(self) {\n      //  Empty function to emulate compatibility\n    });\n\n    var myfunc = function(self, width, height, startx, starty) {\n      width = Sk.builtin.asnum$(width);\n      height = Sk.builtin.asnum$(height);\n      self.theScreen.setup(width,height);\n    }\n    // this should allow for named parameters\n    myfunc.co_varnames = [\'self\',\'width\',\'height\',\'startx\',\'starty\'];\n    myfunc.$defaults = [null,500,500,0,0];\n    $loc.setup = new Sk.builtin.func(myfunc);\n  }\n\n  mod.Screen = Sk.misceval.buildClass(mod, screen, \'Screen\', []);\n\n  mod.tracer = new Sk.builtin.func(function(t, d) {\n    t = Sk.builtin.asnum$(t);\n    d = Sk.builtin.asnum$(d);\n    for (var i in Sk.tg.canvasLib) {\n      Sk.tg.canvasLib[i].tracer(t, d);\n    }\n  });\n\n  mod.update = new Sk.builtin.func(function(self) {\n    //  Dummy function to emulate update... when not animating, we don\'t save the drawing operations, so this is pointless for us\n  });\n\n  return mod\n}\n',
    'src/lib/unittestgui/__init__.py': '__author__ = \'bmiller\'\n\nimport document\n\n\nclass unittest:\n    def __init__(self):\n        self.numPassed = 0\n        self.numFailed = 0\n        self.divid = document.currentDiv()\n        self.mydiv = document.getElementById(self.divid)\n        res = document.getElementById(self.divid+\'_unit_results\')\n        if res:\n            self.resdiv = res\n            res.innerHTML = \'\'\n        else:\n            self.resdiv = document.createElement(\'div\')\n            self.resdiv.setAttribute(\'id\',self.divid+\'_unit_results\')\n            self.resdiv.setAttribute(\'class\',\'unittest-results\')\n        self.mydiv.appendChild(self.resdiv)\n\n        self.tlist = []\n        testNames = {}\n        for name in dir(self):\n            if name[:4] == \'test\' and name not in testNames:\n                self.tlist.append(getattr(self,name))\n                testNames[name]=True\n\n    def setup(self):\n        pass\n\n    def tearDown(self):\n        pass\n\n    def main(self):\n        l = document.createElement(\'ul\')\n        self.resdiv.appendChild(l)\n        self.resList = l\n\n        for func in self.tlist:\n            try:\n                self.setup()\n                func()\n                self.tearDown()\n            except:\n                self.appendResult(\'Error\')\n                self.numFailed += 1\n        self.showSummary()\n\n    def assertEqual(self, actual, expected, feedback=""):\n        res = actual==expected\n        self.appendResult(res,str(actual)+\' to be equal to \',expected, feedback)\n\n    def assertNotEqual(actual, expected, feedback=""):\n        res = actual != expected\n        self.appendResult(res,str(actual)+\' to not equal \',expected,feedback)\n\n    def assertTrue(self,x, feedback=""):\n        res = x\n        self.appendResult(res,str(x)+\' to be \',True,feedback)\n\n    def assertFalse(self,x, feedback=""):\n        res = not x\n        self.appendResult(res,str(x)+\' to be \',False,feedback)\n\n    def assertIs(self,a,b, feedback=""):\n        res = a is b\n        self.appendResult(res,str(a)+\' to be the same object as \',b,feedback)\n\n    def assertIsNot(self,a,b, feedback=""):\n        res = a is not b\n        self.appendResult(res,str(a)+\' to not be the same object as \',b,feedback)\n\n    def assertIsNone(self,x, feedback=""):\n        res = x is None\n        self.appendResult(res,x,None,feedback)\n\n    def assertIsNotNone(self,x, feedback=""):\n        res = x is not None\n        self.appendResult(res,str(x)+\' to not be \',None,feedback)\n\n    def assertIn(self,a,b, feedback=""):\n        res = a in b\n        self.appendResult(res,str(a)+\' to be in \',b,feedback)\n\n    def assertNotIn(self,a,b, feedback=""):\n        res = a not in b\n        self.appendResult(res,str(a)+\' to not be in \',b,feedback)\n\n    def assertIsInstance(self,a,b, feedback=""):\n        res = isinstance(a,b)\n        self.appendResult(res,str(a)+\' to be an instance of \',b,feedback)\n\n    def assertNotIsInstance(self,a,b, feedback=""):\n        res = not isinstance(a,b)\n        self.appendResult(res,str(a)+\' to not be an instance of \',b,feedback)\n\n    def assertAlmostEqual(self,a,b, feedback=""):\n        res = round(a-b,7) == 0\n        self.appendResult(res,str(a)+\' to equal \',b,feedback)\n\n    def assertNotAlmostEqual(self,a,b, feedback=""):\n        res = round(a-b,7) != 0\n        self.appendResult(res,str(a)+\' to not equal \',b,feedback)\n\n    def assertGreater(self,a,b, feedback=""):\n        res = a > b\n        self.appendResult(res,str(a)+\' to be greater than \',b,feedback)\n\n    def assertGreaterEqual(self,a,b, feedback=""):\n        res = a >= b\n        self.appendResult(res,str(a)+\' to be greater than or equal to \',b,feedback)\n\n    def assertLess(self,a,b, feedback=""):\n        res = a < b\n        self.appendResult(res,str(a)+\' to be less than \',b,feedback)\n\n    def assertLessEqual(self,a,b, feedback=""):\n        res = a <= b\n        self.appendResult(res,str(a)+\' to be less than or equal to \',b,feedback)\n\n    def appendResult(self,res,actual,expected,feedback):\n        if res == \'Error\':\n            msg = \'Error\'\n        elif res:\n            msg = \'Pass\'\n            self.numPassed += 1\n        else:\n            msg = \'Fail: expected %s  %s \' % (str(actual),str(expected)) + feedback\n            self.numFailed += 1\n\n        pTag = document.createElement(\'li\')\n        pTag.innerHTML = msg\n        self.resList.appendChild(pTag)\n\n    def showSummary(self):\n        pct = self.numPassed / (self.numPassed+self.numFailed) * 100\n        pTag = document.createElement(\'p\')\n        pTag.innerHTML = "You passed: " + str(pct) + "% of the tests"\n        self.resdiv.appendChild(pTag)\n        if pct < 90:\n            self.resdiv.setCSS(\'background-color\',\'#de8e96\')\n        else:\n            self.resdiv.setCSS(\'background-color\',\'#83d382\')\n\n\n\n',
    'src/lib/matrix/__init__.js': 'var $builtinmodule = function(name) {\n  var mod = {};\n  Sk.builtin.defineMatrix(mod);\n  return mod;\n};',
    'src/lib/test/__init__.py': '__author__ = \'bmiller\'\n\ndef testEqual(actual, expected):\n    if type(expected) == type(1):\n        if actual == expected:\n            print(\'Pass\')\n            return True\n    elif type(expected) == type(1.11):\n        if abs(actual-expected) < 0.00001:\n            print(\'Pass\')\n            return True\n    else:\n        if actual == expected:\n            print(\'Pass\')\n            return True\n    print(\'Test Failed: expected \' + str(expected) + \' but got \' + str(actual))\n    return False\n\ndef testNotEqual(actual, expected):\n    pass\n\n',
    'src/builtin/sys.js': 'var $builtinmodule = function(name)\n{\n    var sys = {};\n\n    var args = [];\n    var argv = Sk.getSysArgv();\n    for (var i = 0; i < argv.length; ++i)\n    {\n        args.push(Sk.builtin.stringToPy(argv[i]));\n    }\n    sys.argv = new Sk.builtins[\'list\'](args);\n\n    sys.copyright = Sk.builtin.stringToPy("Copyright 2009-2010 Scott Graham.\\nAll Rights Reserved.\\n");\n\n    sys.modules = Sk.sysmodules;\n\n    sys.path = Sk.realsyspath;\n\n    sys.getExecutionLimit = Sk.ffi.functionPy(function()\n    {\n        return Sk.execLimit\n    });\n\n    sys.setExecutionLimit = Sk.ffi.functionPy(function(t)\n    {\n        if (t !==  undefined)\n        {\n            Sk.execLimit = t\n        }\n    });\n\n    sys.resetTimeout = Sk.ffi.functionPy(function()\n    {\n        Sk.execStart = new Date();\n    });\n\n    sys.debug = Sk.ffi.functionPy(function()\n    {\n        debugger;\n    });\n\n    return sys;\n};\n',
    'src/lib/pythonds/trees/balance.py': '#!/bin/env python3.1\n# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005, 2010\n# \n\nfrom .bst import BinarySearchTree, TreeNode\n\nclass AVLTree(BinarySearchTree):\n    \'\'\'\n    Author:  Brad Miller\n    Date:  1/15/2005\n    Description:  Imlement a binary search tree with the following interface\n                  functions:  \n                  __contains__(y) <==> y in x\n                  __getitem__(y) <==> x[y]\n                  __init__()\n                  __len__() <==> len(x)\n                  __setitem__(k,v) <==> x[k] = v\n                  clear()\n                  get(k)\n                  has_key(k)\n                  items() \n                  keys() \n                  values()\n                  put(k,v)\n    \'\'\'\n\n\n    def _put(self,key,val,currentNode):\n        if key < currentNode.key:\n            if currentNode.hasLeftChild():\n                self._put(key,val,currentNode.leftChild)\n            else:\n                currentNode.leftChild = TreeNode(key,val,parent=currentNode)\n                self.updateBalance(currentNode.leftChild)\n        else:\n            if currentNode.hasRightChild():\n                self._put(key,val,currentNode.rightChild)\n            else:\n                currentNode.rightChild = TreeNode(key,val,parent=currentNode)\n                self.updateBalance(currentNode.rightChild)                \n\n    def updateBalance(self,node):\n        if node.balanceFactor > 1 or node.balanceFactor < -1:\n            self.rebalance(node)\n            return\n        if node.parent != None:\n            if node.isLeftChild():\n                node.parent.balanceFactor += 1\n            elif node.isRightChild():\n                node.parent.balanceFactor -= 1\n\n            if node.parent.balanceFactor != 0:\n                self.updateBalance(node.parent)\n\n    def rebalance(self,node):\n        if node.balanceFactor < 0:\n            if node.rightChild.balanceFactor > 0:\n                # Do an LR Rotation\n                self.rotateRight(node.rightChild)\n                self.rotateLeft(node)\n            else:\n                # single left\n                self.rotateLeft(node)\n        elif node.balanceFactor > 0:\n            if node.leftChild.balanceFactor < 0:\n                # Do an RL Rotation\n                self.rotateLeft(node.leftChild)\n                self.rotateRight(node)\n            else:\n                # single right\n                self.rotateRight(node)\n\n    def rotateLeft(self,rotRoot):\n        newRoot = rotRoot.rightChild\n        rotRoot.rightChild = newRoot.leftChild\n        if newRoot.leftChild != None:\n            newRoot.leftChild.parent = rotRoot\n        newRoot.parent = rotRoot.parent\n        if rotRoot.isRoot():\n            self.root = newRoot\n        else:\n            if rotRoot.isLeftChild():\n                rotRoot.parent.leftChild = newRoot\n            else:\n                rotRoot.parent.rightChild = newRoot\n        newRoot.leftChild = rotRoot\n        rotRoot.parent = newRoot\n        rotRoot.balanceFactor = rotRoot.balanceFactor + 1 - min(newRoot.balanceFactor, 0)\n        newRoot.balanceFactor = newRoot.balanceFactor + 1 + max(rotRoot.balanceFactor, 0)\n\n\n    def rotateRight(self,rotRoot):\n        newRoot = rotRoot.leftChild\n        rotRoot.leftChild = newRoot.rightChild\n        if newRoot.rightChild != None:\n            newRoot.rightChild.parent = rotRoot\n        newRoot.parent = rotRoot.parent\n        if rotRoot.isRoot():\n            self.root = newRoot\n        else:\n            if rotRoot.isRightChild():\n                rotRoot.parent.rightChild = newRoot\n            else:\n                rotRoot.parent.leftChild = newRoot\n        newRoot.rightChild = rotRoot\n        rotRoot.parent = newRoot\n        rotRoot.balanceFactor = rotRoot.balanceFactor - 1 - max(newRoot.balanceFactor, 0)\n        newRoot.balanceFactor = newRoot.balanceFactor - 1 + min(rotRoot.balanceFactor, 0)\n        \n',
    'src/lib/urllib/request/__init__.js': 'var $builtinmodule = function(name)\n{\n  var request = {};\n\n\n  //~ Classes .................................................................\n\n  // Response class\n  //\n  // Response objects are returned by the request, get, post, etc.\n  // methods, allowing the user to access the response text, status\n  // code, and other information.\n\n  // ------------------------------------------------------------\n  var response = function($gbl, $loc) {\n\n    // ------------------------------------------------------------\n    $loc.__init__ = new Sk.builtin.func(function(self, xhr) {\n      self.data$ = xhr.responseText;\n      self.lineList = self.data$.split("\\n");\n      self.lineList = self.lineList.slice(0,-1);\n      for(var i =0 ; i < self.lineList.length; i++) {\n        self.lineList[i] = self.lineList[i]+\'\\n\';\n      }\n      self.currentLine = 0;\n      self.pos$ = 0;\n    });\n\n\n    // ------------------------------------------------------------\n    $loc.__str__ = new Sk.builtin.func(function(self) {\n      return Sk.builtin.stringToPy(\'<Response>\');\n    });\n\n\n    // ------------------------------------------------------------\n    $loc.__iter__ = new Sk.builtin.func(function(self) {\n      var allLines = self.lineList;\n\n      return Sk.builtin.makeGenerator(function() {\n          if (this.$index >= this.$lines.length) return undefined;\n          return Sk.builtin.stringToPy(this.$lines[this.$index++]);\n        }, {\n          $obj: self,\n          $index: 0,\n          $lines: allLines\n        });\n    });\n\n\n    // ------------------------------------------------------------\n    $loc.read = new Sk.builtin.func(function(self, size) {\n      if (self.closed) throw new Sk.builtin.ValueError("I/O operation on closed file");\n      var len = self.data$.length;\n      if (size === undefined) size = len;\n      var ret = Sk.builtin.stringToPy(self.data$.substr(self.pos$, size));\n      self.pos$ += size;\n      if (self.pos$ >= len) self.pos$ = len;\n      return ret;\n    });\n\n\n    // ------------------------------------------------------------\n    $loc.readline = new Sk.builtin.func(function(self, size) {\n      var line = "";\n      if (self.currentLine < self.lineList.length) {\n        line = self.lineList[self.currentLine];\n        self.currentLine++;\n      }\n      return Sk.builtin.stringToPy(line);\n    });\n\n\n    // ------------------------------------------------------------\n    $loc.readlines = new Sk.builtin.func(function(self, sizehint) {\n      var arr = [];\n      for(var i = self.currentLine; i < self.lineList.length; i++) {\n        arr.push(Sk.builtin.stringToPy(self.lineList[i]));\n      }\n      return new Sk.builtin.list(arr);\n    });\n\n  };\n\n  request.Response =\n    Sk.misceval.buildClass(request, response, \'Response\', []);\n\n\n  //~ Module functions ........................................................\n\n  // ------------------------------------------------------------\n  /**\n   * Constructs and sends a Request. Returns Response object.\n   *\n   * http://docs.python-requests.org/en/latest/api/#requests.request\n   *\n   * For now, this implementation doesn\'t actually construct a Request\n   * object; it just makes the request through jQuery.ajax and then\n   * constructs a Response.\n   */\n  request.urlopen = new Sk.builtin.func(function(url, data, timeout) {\n    var xmlhttp = new XMLHttpRequest();\n    xmlhttp.open("GET",url.v,false);\n    xmlhttp.send(null);\n\n    return Sk.misceval.callsim(request.Response,xmlhttp)\n  });\n\n\n  return request;\n};\n',
    'src/lib/pythonds/basic/queue.py': '# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005\n# \n#queue.py\r\n\r\nclass Queue:\r\n    def __init__(self):\r\n        self.items = []\r\n\r\n    def isEmpty(self):\r\n        return self.items == []\r\n\r\n    def enqueue(self, item):\r\n        self.items.insert(0,item)\r\n\r\n    def dequeue(self):\r\n        return self.items.pop()\r\n\r\n    def size(self):\r\n        return len(self.items)\r\n',
    'src/lib/three/__init__.js': 'var $builtinmodule = function(namePy) {\n  var mod = {};\n  Sk.stdlib.defineThree(mod, BLADE);\n  Sk.builtin.defineGeometry(mod, THREE, Sk.ffi.remapToJs(namePy));\n  return mod;\n}\n',
    'src/lib/numpy/__init__.js': 'var $builtinmodule = function(name) {\n  var mod = {};\n  Sk.builtin.defineNumPy(mod);\n  return mod;\n};\n',
    'src/lib/pythonds/graphs/adjGraph.py': '#\n#  adjGraph\n#\n#  Created by Brad Miller on 2005-02-24.\n#  Copyright (c) 2005 Brad Miller, David Ranum, Luther College. All rights reserved.\n#\n\nimport sys\nimport os\nimport unittest\n\nclass Graph:\n    def __init__(self):\n        self.vertices = {}\n        self.numVertices = 0\n        \n    def addVertex(self,key):\n        self.numVertices = self.numVertices + 1\n        newVertex = Vertex(key)\n        self.vertices[key] = newVertex\n        return newVertex\n    \n    def getVertex(self,n):\n        if n in self.vertices:\n            return self.vertices[n]\n        else:\n            return None\n\n    def __contains__(self,n):\n        return n in self.vertices\n    \n    def addEdge(self,f,t,cost=0):\n            if f not in self.vertices:\n                nv = self.addVertex(f)\n            if t not in self.vertices:\n                nv = self.addVertex(t)\n            self.vertices[f].addNeighbor(self.vertices[t],cost)\n    \n    def getVertices(self):\n        return list(self.vertices.keys())\n        \n    def __iter__(self):\n        return iter(self.vertices.values())\n                \nclass Vertex:\n    def __init__(self,num):\n        self.id = num\n        self.connectedTo = {}\n        self.color = \'white\'\n        self.dist = sys.maxsize\n        self.pred = None\n        self.disc = 0\n        self.fin = 0\n\n    # def __lt__(self,o):\n    #     return self.id < o.id\n    \n    def addNeighbor(self,nbr,weight=0):\n        self.connectedTo[nbr] = weight\n        \n    def setColor(self,color):\n        self.color = color\n        \n    def setDistance(self,d):\n        self.dist = d\n\n    def setPred(self,p):\n        self.pred = p\n\n    def setDiscovery(self,dtime):\n        self.disc = dtime\n        \n    def setFinish(self,ftime):\n        self.fin = ftime\n        \n    def getFinish(self):\n        return self.fin\n        \n    def getDiscovery(self):\n        return self.disc\n        \n    def getPred(self):\n        return self.pred\n        \n    def getDistance(self):\n        return self.dist\n        \n    def getColor(self):\n        return self.color\n    \n    def getConnections(self):\n        return self.connectedTo.keys()\n        \n    def getWeight(self,nbr):\n        return self.connectedTo[nbr]\n                \n    def __str__(self):\n        return str(self.id) + ":color " + self.color + ":disc " + str(self.disc) + ":fin " + str(self.fin) + ":dist " + str(self.dist) + ":pred \\n\\t[" + str(self.pred)+ "]\\n"\n    \n    def getId(self):\n        return self.id\n\nclass adjGraphTests(unittest.TestCase):\n    def setUp(self):\n        self.tGraph = Graph()\n        \n    def testMakeGraph(self):\n        gFile = open("test.dat")\n        for line in gFile:\n            fVertex, tVertex = line.split(\'|\')\n            fVertex = int(fVertex)\n            tVertex = int(tVertex)\n            self.tGraph.addEdge(fVertex,tVertex)\n        for i in self.tGraph:\n            adj = i.getAdj()\n            for k in adj:\n                print(i, k)\n\n        \nif __name__ == \'__main__\':\n    unittest.main()\n              \n',
    'src/lib/easel/__init__.js': 'var $builtinmodule = function(name) {\n  var mod = {};\n  Sk.builtin.defineEasel(mod, createjs, BLADE);\n  return mod;\n}\n',
    'src/lib/json/__init__.js': 'var $builtinmodule = function(name)\n{\n    var mod = {};\n\n    var FUNCTION_PARSE     = "parse";\n    var FUNCTION_STRINGIFY = "stringify";\n\n    mod[FUNCTION_PARSE] = Sk.ffi.functionPy(function(textPy, reviverPy) {\n        Sk.ffi.checkFunctionArgs(FUNCTION_PARSE, arguments, 1, 1);\n        Sk.ffi.checkArgType("text",    Sk.ffi.PyType.STR,   Sk.builtin.isStringPy(textPy));\n        Sk.ffi.checkArgType("reviver", Sk.ffi.PyType.FUNCTION, Sk.ffi.isUndefined(reviverPy) || isFunction(reviverPy));\n        var text = Sk.builtin.stringToJs(textPy);\n        var reviver = Sk.ffi.remapToJs(reviverPy);\n        return Sk.ffi.remapToPy(JSON.parse(text, reviver));\n    });\n\n    mod[FUNCTION_STRINGIFY] = Sk.ffi.functionPy(function(valuePy, replacerPy, spacePy) {\n        Sk.ffi.checkFunctionArgs(FUNCTION_STRINGIFY, arguments, 1, 3);\n        Sk.ffi.checkArgType("value", [Sk.ffi.PyType.OBJECT, Sk.ffi.PyType.DICT], Sk.ffi.isDict(valuePy));\n        Sk.ffi.checkArgType("replacer", [Sk.ffi.PyType.FUNCTION, Sk.ffi.PyType.NONE, Sk.ffi.PyType.UNDEFINED], Sk.ffi.isUndefined(replacerPy) || Sk.ffi.isNone(replacerPy) || Sk.ffi.isFunction(replacerPy));\n        Sk.ffi.checkArgType("space", [Sk.ffi.PyType.INT, Sk.ffi.PyType.UNDEFINED], Sk.ffi.isUndefined(spacePy) || Sk.ffi.isInt(spacePy));\n        var value = Sk.ffi.remapToJs(valuePy);\n        var replacer = Sk.ffi.remapToJs(replacerPy);\n        var space = Sk.ffi.remapToJs(spacePy);\n        return Sk.builtin.stringToPy(JSON.stringify(value, replacer, space));\n    });\n\n    return mod;\n}',
    'src/lib/turtle/__init__.js': '//\n//\n// Turtle Graphics Module for Skulpt\n//\n// Brad Miller\n//\n//\n//\n\n\nvar TurtleGraphics; // the single identifier needed in the global scope\n\nif (! TurtleGraphics) {\n    TurtleGraphics = { };\n}\n\n\n(function () {\n\n    // Define private constants\n\n    var Degree2Rad = Math.PI / 180.0; // conversion factor for degrees to radians\n    var Rad2Degree = 180.0 / Math.PI\n\n    //\n    // Define TurtleCanvas\n    // \n\n    function TurtleCanvas(options) {\n        this.canvasID = TurtleGraphics.defaults.canvasID;\n        if (options.canvasID) {\n            this.canvasID = options.canvasID;\n        }\n\n        this.canvas = document.getElementById(this.canvasID);\n        this.context = this.canvas.getContext(\'2d\');\n        //this.canvas.style.display = \'block\';\n        $(this.canvas).fadeIn();\n\n        this.lineScale = 1.0;\n        this.xptscale = 1.0;\n        this.yptscale = 1.0\n\n        this.llx = -this.canvas.width / 2;\n        this.lly = -this.canvas.height / 2;\n        this.urx = this.canvas.width / 2;\n        this.ury = this.canvas.height / 2;\n        this.setup(this.canvas.width,this.canvas.height);\n        TurtleGraphics.canvasInit = true;\n        this.tlist = []\n\n        this.timeFactor = 5;\n        if (TurtleGraphics.defaults.animate) {\n            this.delay = 5 * this.timeFactor;\n        } else {\n            this.delay = 0;\n        }\n        this.segmentLength = 10;\n        this.renderCounter = 1;\n        this.clearPoint = 0;\n        TurtleGraphics.canvasLib[this.canvasID] = this;\n        Sk.tg.fadeOnExit = true;    //  This can be set to false AFTER the program completes to turn off the fade out on the canvas as a result of exitonclick\n    }\n\n    TurtleCanvas.prototype.setup = function(width, height) {\n        this.canvas.width = width;\n        this.canvas.height = height;\n        this.lineScale = 1.0;\n        this.xptscale = 1.0;\n        this.yptscale = 1.0;\n\n        this.llx = -this.canvas.width / 2;\n        this.lly = -this.canvas.height / 2;\n        this.urx = this.canvas.width / 2;\n        this.ury = this.canvas.height / 2;\n        this.renderCounter = 1;\n        this.clearPoint = 0;\n        this.timeFactor = 5;\n        if (TurtleGraphics.defaults.animate ) {\n            this.delay = 5 * this.timeFactor;\n        } else {\n            this.delay = 0;\n        }\n\n        if (TurtleGraphics.canvasInit == false) {\n            this.context.save();\n            this.context.translate(this.canvas.width / 2, this.canvas.height / 2); // move 0,0 to center.\n            this.context.scale(1, -1); // scaling like this flips the y axis the right way.\n            TurtleGraphics.canvasInit = true;\n            TurtleGraphics.eventCount = 0;\n            TurtleGraphics.renderClock = 0;\n            TurtleGraphics.renderTime = 0;\n        } else {\n            this.context.restore();\n            this.context.translate(this.canvas.width / 2, this.canvas.height / 2); // move 0,0 to center.\n            this.context.scale(1, -1); // scaling like this flips the y axis the right way.\n            this.context.clearRect(-this.canvas.width / 2, -this.canvas.height / 2,\n                                    this.canvas.width, this.canvas.height);\n        }\n    }\n    TurtleCanvas.prototype.addToCanvas = function(t) {\n            this.tlist.push(t);\n    }\n\n    TurtleCanvas.prototype.onCanvas = function(t) {\n        return (this.tlist.indexOf(t) >= 0);\n    }\n\n    TurtleCanvas.prototype.isAnimating = function() {\n        return (this.tlist.length > 0)\n    }\n\n    TurtleCanvas.prototype.startAnimating = function(t) {\n        if (! this.isAnimating()) {\n            this.intervalId = setTimeout(render, this.delay);   //  setInterval(render, this.delay);\n        }\n        if (!this.onCanvas(t))  //  in case startAnimating is called after it\'s already been added\n            this.addToCanvas(t);\n        Sk.isTurtleProgram = true;\n    }\n\n    TurtleCanvas.prototype.doneAnimating = function(t) {\n        this.tlist.splice(0,this.tlist.length)\n        clearTimeout(this.intervalId)   \n        $(Sk.runButton).removeAttr(\'disabled\');\n    }\n\n    TurtleCanvas.prototype.cancelAnimation = function() {\n        if (this.intervalId) {\n            clearTimeout(this.intervalId)   //  clearInterval(this.intervalId);\n        }\n\n        for (var t in this.tlist) {\n            this.tlist[t].aCount = this.tlist[t].drawingEvents.length - 1;\n        }\n        render();\n    }\n\n    TurtleCanvas.prototype.setSpeedDelay = function(s)\n    {\n        var df = 10 - (s % 11) + 1;\n        this.delay = df * this.timeFactor;\n    }\n\n    TurtleCanvas.prototype.setDelay = function(d) {\n        this.delay = d;\n    }\n\n    TurtleCanvas.prototype.getDelay = function(s)\n    {\n        return this.delay;\n    }\n\n    TurtleCanvas.prototype.setCounter = function(s) {\n        if (!s || s <= 0)   //  Don\'t let this be less than 1\n            s = 1;\n        this.renderCounter = s;\n    }\n\n    TurtleCanvas.prototype.getCounter = function() {\n        return this.renderCounter;\n    }\n\n    TurtleCanvas.prototype.setworldcoordinates = function(llx, lly, urx, ury) {\n        this.context.restore();\n        this.context.scale(this.canvas.width / (urx - llx), -this.canvas.height / (ury - lly));\n        if (lly == 0)\n            this.context.translate(-llx, lly - (ury - lly));\n        else if (lly > 0)\n            this.context.translate(-llx, -lly * 2);\n        else\n            this.context.translate(-llx, -ury);\n\n        var xlinescale = (urx - llx) / this.canvas.width;\n        var ylinescale = (ury - lly) / this.canvas.height;\n        this.xptscale = xlinescale;\n        this.yptscale = ylinescale;\n        this.lineScale = Math.min(xlinescale,ylinescale)\n        this.context.save();\n\n        this.llx = llx;\n        this.lly = lly;\n        this.urx = urx;\n        this.ury = ury;\n\n    }\n\n    TurtleCanvas.prototype.window_width = function() {\n        return this.canvas.width;\n    }\n\n    TurtleCanvas.prototype.window_height = function() {\n        return this.canvas.height;\n    }\n\n    TurtleCanvas.prototype.bgcolor = function(c) {\n        this.background_color = c;\n        //this.canvas.style.setProperty("background-color", c.v);\n        $(this.canvas).css("background-color",c.v);\n    }\n\n    TurtleCanvas.prototype.setSegmentLength = function(s) {\n        this.segmentLength = s;\n    }\n\n    TurtleCanvas.prototype.getSegmentLength = function() {\n        return this.segmentLength;\n    }\n    \n    // todo: if animating, this should be deferred until the proper time\n    TurtleCanvas.prototype.exitonclick = function () {\n        var canvas_id = this.canvasID;\n        var theCanvas = this;\n        $(this.canvas).click(function() {\n            if (! theCanvas.isAnimating()) {\n                if (Sk.tg.fadeOnExit)   //  Let\'s this be configurable\n                    $("#"+canvas_id).hide();\n                $("#"+canvas_id).unbind(\'click\');\n                Sk.tg.canvasInit = false;\n                delete Sk.tg.canvasLib[canvas_id];\n            }\n        });\n    }\n\n    TurtleCanvas.prototype.turtles = function() {\n        return TurtleGraphics.turtleList;\n    }\n\n    TurtleCanvas.prototype.tracer = function(t, d) {    //  New version NOT attached to a turtle (as per real turtle)\n        this.setCounter(t);\n        if (t == 0) {\n            for (var i in this.turtleList)\n                this.turtleList[i].animate = false;\n            this.cancelAnimation();\n        }\n        if (d !== undefined)\n            this.setDelay(d);\n    }\n\n    // check if all turtles are done\n    allDone = function() {\n        var allDone = true;\n        for (var tix in TurtleGraphics.turtleList) {\n            var theT = TurtleGraphics.turtleList[tix];\n            allDone = allDone && (theT.aCount >= theT.drawingEvents.length);\n        }\n        return allDone;\n    }\n    //\n    //  This is the function that provides the animation\n    //\n    render = function () {\n        var context = document.getElementById(TurtleGraphics.defaults.canvasID).getContext(\'2d\');\n        with (context) {\n            with (TurtleGraphics.canvasLib[TurtleGraphics.defaults.canvasID]) {\n                clearRect(llx, lly, (urx - llx), (ury - lly));\n                //canvas.style.setProperty("background-color",TurtleGraphics.turtleCanvas.bgcolor.v);\n            }\n            var incr = TurtleGraphics.canvasLib[TurtleGraphics.defaults.canvasID].getCounter();\n            var lastCanvas = null\n\n            TurtleGraphics.renderClock += incr;\n\n            for (var tix in TurtleGraphics.turtleList) {\n                var t = TurtleGraphics.turtleList[tix]\n                lastCanvas = t.turtleCanvas \n                if (t.aCount >= t.drawingEvents.length)\n                    t.aCount = t.drawingEvents.length - 1;\n                moveTo(0, 0);\n                var currentPos = new Vector(0,0,0);\n                var currentHead = new Vector(1,0,0);\n                lineWidth = t.get_pen_width();\n                lineCap = \'round\';\n                lineJoin = \'round\';\n                strokeStyle = \'black\';\n                var filling = false;\n                if (isNaN(t.turtleCanvas.delay))\n                    t.turtleCanvas.delay = 0\n//              console.log(tix + " : " + t.clearPoint + " to " + t.aCount)\n                for (var i = t.clearPoint; (i <= t.aCount || t.turtleCanvas.delay == 0) && i < t.drawingEvents.length; i++) {\n                    if (i > t.aCount)   //  If se jump past aCount, jump it ahead\n                        t.aCount = i\n                    var oper = t.drawingEvents[i];\n                    var ts = oper[oper.length-1];\n//                  console.log(i + "/" + ts + oper [0] + "{" + oper [1] + "}" + t.turtleCanvas.delay)\n                    if (ts <= TurtleGraphics.renderClock || t.turtleCanvas.delay == 0) {\n                        if (ts > TurtleGraphics.renderClock)    //  If we go past the render clock, jump it ahead\n                            TurtleGraphics.renderClock = ts\n//                      console.log("<==")\n                        if (oper[0] == "LT") {  //  line to\n                            if (! filling) {\n                                beginPath();\n                                moveTo(oper[1], oper[2]);\n                            }\n                            lineTo(oper[3], oper[4]);\n                            strokeStyle = oper[5];\n                            stroke();\n                            currentPos = new Vector(oper[3],oper[4],0);\n                            if (! filling)\n                                closePath();\n                        }\n                        else if (oper[0] == "MT") {  // move to\n                            moveTo(oper[3], oper[4]);\n                            currentPos = new Vector(oper[3],oper[4],0);\n                        }\n                        else if (oper[0] == "BF") {  // begin fill\n                            beginPath();\n                            moveTo(oper[1], oper[2]);\n                            filling = true;\n                        }\n                        else if (oper[0] == "EF") {  // end fill\n                            fillStyle = oper[3];\n                            stroke();\n                            fill();\n                            closePath();\n                            filling = false;\n                        }\n                        else if (oper[0] == "FC") {  // fill color\n                            fillStyle = oper[1];\n                        }\n                        else if (oper[0] == "TC") {  // turtle color\n                            strokeStyle = oper[1];\n                        }\n                        else if (oper[0] == "PW") {  // Pen width\n                            lineWidth = oper[1];\n                        }\n                        else if (oper[0] == "DT") {  // Dot\n                            var col = fillStyle;\n                            fillStyle = oper[2];\n                            var size = oper[1];\n                            fillRect(oper[3] - size / 2, oper[4] - size / 2, size, size);\n                            fillStyle = col;\n                        }\n                        else if (oper[0] == "CI") {  // Circle\n                            if (!filling)\n                                beginPath();\n                            arc(oper[1], oper[2], oper[3], oper[4], oper[5], oper[6]);\n                            currentPos = new Vector(oper[1]+Sk.math.cos(oper[5])*oper[3],\n                                oper[2]+Sk.math.sin(oper[5])*oper[3],0);\n                            stroke();\n                            if (! filling) {\n                                closePath();\n                            }\n                        }\n                        else if (oper[0] == "WT") { // write\n                            if (font)\n                                font = oper[2];\n                            scale(1, -1);\n                            fillText(oper[1], oper[3], -oper[4]);\n                            scale(1, -1);\n                        } else if (oper[0] == "ST") {  // stamp\n                            t.drawturtle(oper[3], new Vector(oper[1], oper[2], 0));\n                        } else if (oper[0] == "HT") { // hide turtle\n                            t.visible = false;\n                        } else if (oper[0] == "SH") { // show turtle\n                            t.visible = true;\n                        } else if (oper[0] == "TT") {\n                            currentHead = oper[1];\n                        } else if (oper[0] == "CL") { // clear\n                            clear_canvas(t.canvasID);\n                            t.clearPoint = i;   // Different from reset that calls clear because it leaves the turtles where they are\n                        } else if (oper[0] == "DL") { // delay\n                            var df = oper[1]\n//                          console.log("animated delay set " + df)\n                            t.turtleCanvas.delay = df\n                        } else if (oper[0] == "SC") { // speed change\n                            var s = oper[1]\n                            if (s < 0)\n                                s = 0\n                            if (s > 10)\n                                s = 10\n                            var df = (10 - (s % 11) + 1) * t.turtleCanvas.timeFactor    //  10\n                            if (s == 0) {\n                                df = 0\n                            }\n                            //  t.turtleCanvas.intervalId = clearInterval(t.turtleCanvas.intervalId);\n                            t.turtleCanvas.delay = df;\n                            //  t.turtleCanvas.intervalId = setInterval(render, t.turtleCanvas.delay)\n                            if (oper[2]) {\n                                t.turtleCanvas.setSegmentLength(oper[2]);\n                            }\n                        } else if (oper[0] == "NO") { // no op\n                        } else {\n                            console.log("unknown op: " + oper[0]);\n                        } // end of oper[0] test\n                    } // end of if ts < render clock\n                } // end of for\n//              console.log(TurtleGraphics.renderClock + " / " + t.aCount)\n//              console.log("------------------------------")\n                t.aCount += incr;\n                if (t.visible) {\n                    // draw the turtle\n                    t.drawturtle(currentHead.toAngle(), currentPos); // just use currentHead\n                }\n            }\n            //if (t.aCount >= t.drawingEvents.length) {\n            if (TurtleGraphics.renderClock > TurtleGraphics.eventCount ){ // && allDone() ){\n//              t.turtleCanvas.doneAnimating(t);\n//              console.log("done animating")\n                if (lastCanvas) lastCanvas.doneAnimating(t);\n            } else {\n//              t.turtleCanvas.intervalId = setTimeout(render, t.turtleCanvas.delay)\n                if (lastCanvas) {\n                    lastCanvas.intervalId = setTimeout(render, lastCanvas.delay)\n                }\n            }\n        }\n    }\n\n\n\n    // Constructor for Turtle objects\n    function Turtle() {\n        if (arguments.length >= 1) {\n            this.initialize(arguments[0]);\n        }\n        else {\n            this.initialize();\n        }\n        TurtleGraphics.turtleList.push(this);\n    }\n\n\n    Turtle.prototype.go_home = function () {\n        // Put turtle in initial state\n        // turtle is headed to the right\n        // with location 0,0,0 in the middle of the canvas.\n        // x grows to the right\n        // y grows towards the top of the canvas\n        with (this) {\n            position = home;\n            context.moveTo(home[0], home[1]);\n            heading = new Vector([1.0, 0.0, 0.0]); // to the right; in turtle space x+ direction\n            normal = new Vector([0.0, 0.0, -1.0]); // in z- direction\n        }\n    };\n\n    Turtle.prototype.initialize = function () {\n        // Initialize the turtle.\n        var options = { };\n\n        if (arguments.length >= 1) {\n            options = arguments[0];\n        }\n\n        this.canvasID = TurtleGraphics.defaults.canvasID;\n        if (options.canvasID) {\n            this.canvasID = options.canvasID;\n        }\n        this.context = document.getElementById(this.canvasID).getContext(\'2d\');\n\n        this.animate = TurtleGraphics.defaults.animate;\n\n        with (this.context) {\n            if (TurtleGraphics.canvasInit == false) {   // This is a workaround until I understand skulpt re-running better\n                // the downside is that this limits us to a single turtle...\n                save();\n                translate(canvas.width / 2, canvas.height / 2); // move 0,0 to center.\n                scale(1, -1); // scaling like this flips the y axis the right way.\n                if (! TurtleGraphics.canvasLib[this.canvasID]) {\n                    TurtleGraphics.canvasLib[this.canvasID] = new TurtleCanvas(options);\n                }\n                TurtleGraphics.canvasInit = true;\n            } else {\n                clear_canvas(this.canvasID);\n            }\n\n            this.turtleCanvas = TurtleGraphics.canvasLib[this.canvasID];\n            this.home = new Vector([0.0, 0.0, 0.0]);\n            this.visible = true;\n            this.shapeStore = {};\n            this.shapeStore[\'turtle\'] = turtleShapePoints();\n            this.shapeStore[\'arrow\'] = defaultShapePoints();\n            this.shapeStore[\'circle\'] = circleShapePoints();\n            this.shapeStore[\'square\'] = squareShapePoints();\n            this.shapeStore[\'triangle\'] = triangleShapePoints();\n            this.shapeStore[\'blank\'] = [new Vector(0,0)];\n            this.shapeStore[\'classic\'] = classicShapePoints();\n            this.currentShape = \'classic\';\n            this.drawingEvents = [];\n\n            this.filling = false;\n            this.pen = true;\n            this.penStyle = \'black\';\n            this.penWidth = 2;\n            this.fillStyle = \'black\';\n            this.position = [ ];\n            this.heading = [ ];\n            this.normal = [ ];\n            this.go_home();\n            this.aCount = 0;\n            this.clearPoint = 0;\n        }\n    }\n    function turtleShapePoints() {\n        var pl = [\n            [0,16],\n            [-2,14],\n            [-1,10],\n            [-4,7],\n            [-7,9],\n            [-9,8],\n            [-6,5],\n            [-7,1],\n            [-5,-3],\n            [-8,-6],\n            [-6,-8],\n            [-4,-5],\n            [0,-7],\n            [4,-5],\n            [6,-8],\n            [8,-6],\n            [5,-3],\n            [7,1],\n            [6,5],\n            [9,8],\n            [7,9],\n            [4,7],\n            [1,10],\n            [2,14]\n        ];\n        res = [];\n        for (p in pl) {\n            res.push(new Vector(pl[p]));\n        }\n        return res;\n    }\n\n    function defaultShapePoints() {\n        var pl = [\n            [-10,0],\n            [10,0],\n            [0,10]\n        ];\n        res = [];\n        for (p in pl) {\n            res.push(new Vector(pl[p]));\n        }\n        return res;\n    }\n\n    function circleShapePoints() {\n        var pl = [\n            [10,0],\n            [9.51,3.09],\n            [8.09,5.88],\n            [5.88,8.09],\n            [3.09,9.51],\n            [0,10],\n            [-3.09,9.51],\n            [-5.88,8.09],\n            [-8.09,5.88],\n            [-9.51,3.09],\n            [-10,0],\n            [-9.51,-3.09],\n            [-8.09,-5.88],\n            [-5.88,-8.09],\n            [-3.09,-9.51],\n            [-0.00,-10.00],\n            [3.09,-9.51],\n            [5.88,-8.09],\n            [8.09,-5.88],\n            [9.51,-3.09]\n        ];\n        res = [];\n        for (p in pl) {\n            res.push(new Vector(pl[p]));\n        }\n        return res;\n    }\n\n    function triangleShapePoints() {\n        var pl = [\n            [10,-5.77],\n            [0,11.55],\n            [-10,-5.77]\n        ];\n\n        res = [];\n        for (p in pl) {\n            res.push(new Vector(pl[p]));\n        }\n        return res;\n\n    }\n\n    function squareShapePoints() {\n        var pl = [\n            [10,-10],\n            [10,10],\n            [-10,10],\n            [-10,-10]\n        ];\n\n        res = [];\n        for (p in pl) {\n            res.push(new Vector(pl[p]));\n        }\n        return res;\n\n    }\n\n    function classicShapePoints() {\n        var pl = [\n            [0,0],\n            [-5,-9],\n            [0,-7],\n            [5,-9]\n        ];\n\n        res = [];\n        for (p in pl) {\n            res.push(new Vector(pl[p]));\n        }\n        return res;\n\n    }\n\n    Turtle.prototype.clean = function () {\n        // Clean the canvas\n        // Optional second argument is color\n        with (this) {\n            if (arguments.length >= 1) {\n                clear_canvas(canvasID, arguments[0]);\n            }\n            else {\n                clear_canvas(canvasID);\n            }\n            initialize();\n        }\n    }\n\n    Turtle.prototype.addDrawingEvent = function(eventList) {\n        TurtleGraphics.eventCount += 1;\n        eventList.push(TurtleGraphics.eventCount);\n        this.drawingEvents.push(eventList);\n    }\n//  \n//  Drawing Functions\n//\n\n    // break a line into segments\n    // sp:  Vector of starting position\n    // ep:  Vector of ending position\n    // sl:  int length of segments\n    segmentLine = function(sp, ep, sL, pen) {\n        var head = ep.sub(sp).normalize();\n        var numSegs = Math.floor(ep.sub(sp).len() / sL);\n        var res = [];\n        var oldp = sp;\n        var newp;\n        var op = ""\n        if (pen)\n            op = "LT"\n        else\n            op = "MT"\n        for (var i = 0; i < numSegs; i++) {\n            newp = oldp.linear(1, sL, head);\n            res.push([op,oldp[0],oldp[1],newp[0],newp[1]]);\n            oldp = newp;\n        }\n        if (! ((oldp[0] == ep[0]) && (oldp[1] == ep[1])))\n            res.push([op, oldp[0], oldp[1], ep[0], ep[1]]);\n        return res;\n    }\n\n    Turtle.prototype.draw_line = function(newposition) {\n        with (this) {\n            with (context) {\n                if (! animate) {\n                    if (! filling) {\n                        beginPath();\n                        moveTo(position[0], position[1]);\n                    }\n                    lineCap = \'round\';\n                    lineJoin = \'round\';\n                    lineWidth = get_pen_width();\n                    strokeStyle = penStyle;\n                    lineTo(newposition[0], newposition[1]);\n                    stroke();\n                    if (! filling)\n                        closePath();\n                } else {\n                    var r = segmentLine(position, newposition, turtleCanvas.getSegmentLength(), pen);\n                    for (var s in r) {\n                        r[s].push(penStyle);\n                        addDrawingEvent(r[s]);\n                    }\n                    if (! turtleCanvas.isAnimating()) {\n                        turtleCanvas.startAnimating(this);\n                    } else {\n                        if (! turtleCanvas.onCanvas(this))\n                            turtleCanvas.addToCanvas(this);\n                    }\n                }\n            }\n        }\n\n    }\n\n\n    Turtle.prototype.forward = function (d) {\n        with (this) {\n            var newposition = position.linear(1, d, heading);\n            goto(newposition);\n        }\n    }\n\n    Turtle.prototype.backward = function(d) {\n        this.forward(-d);\n    }\n\n//  This is an internal function that sets the position without doing any drawing\n    Turtle.prototype.teleport_to = function(nx, ny) {\n        if (nx instanceof Vector)\n            var newposition = nx;\n        else\n            var newposition = new Vector([nx,ny,0]);\n        this.context.moveTo(newposition[0], newposition[1]);\n        this.position = newposition;\n    }\n\n    Turtle.prototype.goto = function(nx, ny) {\n        if (nx instanceof Vector)\n            var newposition = nx;\n        else\n            var newposition = new Vector([nx,ny,0]);\n        with (this) {\n            if (pen) {\n                draw_line(newposition);\n            } else {\n                if (! animate) {\n                    context.moveTo(newposition[0], newposition[1]);\n                } else {\n                    var r = segmentLine(position, newposition, turtleCanvas.getSegmentLength(), pen);\n                    for (var s in r)\n                        addDrawingEvent(r[s]);\n                    if (! turtleCanvas.isAnimating()) {\n                        turtleCanvas.startAnimating(this);\n                    } else {\n                        if (! turtleCanvas.onCanvas(this))\n                            turtleCanvas.addToCanvas(this);\n                    }\n                }\n            }\n            position = newposition;\n\n        }\n    }\n\n    Turtle.prototype.delay = function(d)\n    {\n        if (d != null) {\n            if (d < 0)\n                d = -d\n            if (!this.animate) \n                this.turtleCanvas.setDelay(d)\n            else {\n                this.turtleCanvas.setDelay(d)\n                this.addDrawingEvent(["DL", d])\n                this.addDrawingEvent(["NO"])\n            }\n        }\n        return this.turtleCanvas.getDelay();\n    }\n\n    Turtle.prototype.speed = function(s,t) {\n        if (s > 0 && !this.animate) {\n            this.animate = true;\n            this.turtleCanvas.setSpeedDelay(s)\n        } else if (s == 0 && !this.animate) {\n            this.turtleCanvas.setSpeedDelay(s)\n        } else {\n//          this.animate = false;\n//          this.turtleCanvas.cancelAnimation();\n            this.addDrawingEvent(["SC", s, t])\n            this.addDrawingEvent(["NO"])\n        }\n        if (t) {\n            this.turtleCanvas.setSegmentLength(t);\n            // set the number of units to divide a segment into\n        } else {\n            this.turtleCanvas.setSegmentLength(10);\n        }\n    }\n\n    Turtle.prototype.tracer = function(t, d) {\n        this.turtleCanvas.setCounter(t);\n        if (t == 0) {\n            this.animate=false;\n            this.turtleCanvas.cancelAnimation();\n        }\n        if (d !== undefined)\n            this.turtleCanvas.setDelay(d);\n    }\n\n    Turtle.prototype.getRenderCounter = function() {\n        return this.turtleCanvas.getCounter();\n    }\n\n    Turtle.prototype.turn = function (phi) {\n        with (this) {\n            var alpha = phi * Degree2Rad;\n            var left = normal.cross(heading);\n            var newheading = heading.rotateNormal(left, normal, alpha);\n            heading = newheading;\n\n            if (animate) {\n                addDrawingEvent(["TT",heading]);\n            }\n        }\n    }\n\n    Turtle.prototype.right = Turtle.prototype.turn;\n\n    Turtle.prototype.left = function(phi) {\n        this.turn(-phi);\n    }\n\n    Turtle.prototype.get_heading = function () {\n        if (TurtleGraphics.defaults.degrees)\n            return this.heading.toAngle()\n        else\n            return this.heading\n    }\n\n    Turtle.prototype.get_position = function () {\n        return this.position;\n    }\n\n    Turtle.prototype.getx = function () {\n        return this.position[0];\n    }\n\n    Turtle.prototype.gety = function () {\n        return this.position[1];\n    }\n\n    Turtle.prototype.set_heading = function(newhead) {\n        if ((typeof(newhead)).toLowerCase() === \'number\') {\n            this.heading = Vector.angle2vec(newhead);\n        } else {\n            this.heading = newhead;\n        }\n    }\n\n    Turtle.prototype.towards = function(to, y) {\n        // set heading vector to point towards another point.\n        if ((typeof(to)).toLowerCase() === \'number\')\n            to = new Vector(to, y, 0);\n        else if (! (to instanceof Vector)) {\n            to = new Vector(to);\n        }\n        var res = to.sub(this.position);\n        res = res.normalize();\n        if (TurtleGraphics.defaults.degrees) {\n            return res.toAngle();\n        }\n        else {\n            return res;\n        }\n    }\n\n    Turtle.prototype.distance = function(to, y) {\n        if ((typeof(to)).toLowerCase() === \'number\')\n            to = new Vector(to, y, 0);\n        return this.position.sub(new Vector(to)).len();\n    }\n\n    Turtle.prototype.dot = function() {\n        var size = 2;\n        if (arguments.length >= 1) size = arguments[0];\n        size = size * this.turtleCanvas.lineScale;\n        with (this) {\n            with (context) {\n                var color = penStyle;\n                var nc = arguments[1] || color;\n                if (! animate) {\n                    fillStyle = nc;\n                    fillRect(position[0] - size / 2, position[1] - size / 2, size, size);\n                    fillStyle = color;\n                } else {\n                    addDrawingEvent(["DT", size, nc, position[0], position[1]]);\n                }\n            }\n        }\n\n    }\n\n    Turtle.prototype.circle = function(radius, extent) {\n        if (extent === undefined) {\n            extent = 360\n        }\n        if (this.animate) {\n            var arcLen = Math.abs(radius * Math.PI * 2.0  * extent / 360);\n            var segLen = this.turtleCanvas.getSegmentLength();\n            if (arcLen <= segLen)\n                this.arc(radius,extent);\n            else {\n                //  Break the arc into segments for animation\n                var extentPart = (segLen / arcLen) * extent;\n                var extentLeft = extent;\n                while (Math.abs(extentLeft) > Math.abs(extentPart)) {\n                    this.arc(radius, extentPart);\n                    extentLeft = extentLeft - extentPart;\n                }\n                if (Math.abs(extentLeft) > 0.01)\n                    this.arc(radius, extentLeft);\n            }\n        } else {\n            this.arc(radius,extent);\n        }\n    }\n    \n    Turtle.prototype.arc = function(radius, extent) {\n        //  Figure out where the turtle is and which way it\'s facing\n        var turtleHeading = this.get_heading()\n        var tx = this.position[0]\n        var ty = this.position[1]\n\n        //  Figure out the circle center\n        var cx = tx + (radius * Sk.math.cos((turtleHeading + 90) * Degree2Rad));\n        var cy = ty + (radius * Sk.math.sin((turtleHeading + 90) * Degree2Rad));\n\n        //  Canvas arc angles go CLOCKWISE, not COUNTERCLOCKWISE like Turtle\n\n        //  Figure out our arc angles\n        var startAngleDeg;\n        if (radius >= 0)\n            startAngleDeg = turtleHeading - 90;\n        else\n            startAngleDeg = turtleHeading + 90;\n\n        var endAngleDeg;\n        if (extent) {\n            if (radius >= 0)\n                endAngleDeg = startAngleDeg + extent;\n            else\n                endAngleDeg = startAngleDeg - extent;\n        } else {\n            if (radius >= 0)\n                endAngleDeg = startAngleDeg + 360;\n            else\n                endAngleDeg = startAngleDeg - 360;\n        }\n\n        //  Canvas angles are opposite\n        startAngleDeg = 360 - startAngleDeg\n        endAngleDeg   = 360 - endAngleDeg\n\n        //  Becuase the y axis has been flipped in HTML5 Canvas with a tanslation, we need to adjust the angles\n        startAngleDeg = -startAngleDeg\n        endAngleDeg   = -endAngleDeg\n\n        //  Convert to radians\n        var startAngle = startAngleDeg * Degree2Rad;\n        var endAngle   = endAngleDeg   * Degree2Rad;\n\n\n        //  Do the drawing\n        if (! this.animate) {\n            if (!this.filling)\n                this.context.beginPath();\n            this.context.arc(cx, cy, Math.abs(radius), startAngle, endAngle, (radius * extent <= 0));\n            this.context.stroke();\n            if (!this.filling)\n                this.context.closePath();\n        } else {\n            this.addDrawingEvent(["CI", cx, cy, Math.abs(radius), startAngle, endAngle, (radius * extent <= 0)]);\n        }\n\n        //  Move the turtle only if we have to\n        if (extent && (extent % 360) != 0) {\n            var turtleArc;\n            if (radius >= 0)\n                turtleArc = extent;\n            else \n                turtleArc = -extent;\n            var newTurtleHeading = (turtleHeading + turtleArc) % 360;\n            if (newTurtleHeading < 0)\n                newTurtleHeading = newTurtleHeading + 360;\n\n            var nx = cx + (radius * Sk.math.cos((newTurtleHeading - 90) * Degree2Rad));\n            var ny = cy + (radius * Sk.math.sin((newTurtleHeading - 90) * Degree2Rad)); //  y coord is inverted in turtle\n\n            //  Move it internally\n            this.set_heading(newTurtleHeading);\n            this.teleport_to(nx,ny);\n\n            //  If we\'re animating the turtle, move it on the screen\n            if (this.animate) {\n                this.addDrawingEvent(["TT", this.heading]);\n            }\n        }\n\n    }\n\n    Turtle.prototype.write = function(theText, move, align, font) {\n        if (! this.animate) {\n            if (font)\n                this.context.font = font.v;\n            this.context.scale(1, -1);\n            this.context.fillText(theText, this.position[0], -this.position[1]);\n            this.context.scale(1, -1);\n        } else {\n            var fontspec;\n            if (font)\n                fontspec = font.v\n            this.addDrawingEvent(["WT", theText, fontspec, this.position[0], this.position[1]]);\n        }\n    }\n\n    Turtle.prototype.setworldcoordinates = function(llx, lly, urx, ury) {\n        this.turtleCanvas.setworldcoordinates(llx, lly, urx, ury);\n    }\n\n//\n// Pen and Style functions\n//\n    Turtle.prototype.pen_down = function () {\n        this.pen = true;\n    }\n\n    Turtle.prototype.down = Turtle.prototype.pen_down;\n\n    Turtle.prototype.pen_up = function () {\n        this.pen = false;\n    }\n\n    Turtle.prototype.up = Turtle.prototype.pen_up;\n\n    Turtle.prototype.get_pen = function () {\n        return this.pen;\n    }\n\n    Turtle.prototype.set_pen_width = function (w) {\n        if (this.animate)\n            this.addDrawingEvent(["PW", w * this.turtleCanvas.lineScale]);\n        else\n            this.penWidth = w;\n    }\n\n    Turtle.prototype.get_pen_width = function() {\n        return this.penWidth * this.turtleCanvas.lineScale;\n    }\n\n    Turtle.prototype.set_pen_color = function (c, g, b) {\n        if (typeof(c) == "string") {\n            this.penStyle = c;\n        } else {\n            var rs\n            var gs\n            var bs\n            if (typeof( c) == "object" && c.length == 3) {\n                var c0 = Sk.builtin.asnum$(c[0]);\n                var c1 = Sk.builtin.asnum$(c[1]);\n                var c2 = Sk.builtin.asnum$(c[2]);\n            } else {\n                var c0 = Sk.builtin.asnum$(c);\n                var c1 = Sk.builtin.asnum$(g);\n                var c2 = Sk.builtin.asnum$(b);\n            }\n            rs = c0.toString(16);\n            gs = c1.toString(16);\n            bs = c2.toString(16);\n            while (rs.length < 2) rs = "0" + rs;\n            while (gs.length < 2) gs = "0" + gs;\n            while (bs.length < 2) bs = "0" + bs;\n            c = "#" + rs + gs + bs;\n            this.penStyle = c;\n        }\n\n        this.context.strokeStyle = c;\n        if (this.animate)\n            this.addDrawingEvent(["TC", c]);\n    }\n\n    Turtle.prototype.set_fill_color = function (c, g, b) {\n        if (typeof(c) == "string") {\n            this.fillStyle = c;\n        } else {\n            var rs\n            var gs\n            var bs\n            if (typeof( c) == "object" && c.length == 3) {\n                var c0 = Sk.builtin.asnum$(c[0]);\n                var c1 = Sk.builtin.asnum$(c[1]);\n                var c2 = Sk.builtin.asnum$(c[2]);\n            } else {\n                var c0 = Sk.builtin.asnum$(c);\n                var c1 = Sk.builtin.asnum$(g);\n                var c2 = Sk.builtin.asnum$(b);\n            }\n            rs = c0.toString(16)\n            gs = c1.toString(16)\n            bs = c2.toString(16)\n            while (rs.length < 2) rs = "0" + rs;\n            while (gs.length < 2) gs = "0" + gs;\n            while (bs.length < 2) bs = "0" + bs;\n            c = "#" + rs + gs + bs;\n            this.fillStyle = c;\n        }\n\n        this.context.fillStyle = c;\n        if (this.animate)\n            this.addDrawingEvent(["FC", c]);\n    }\n\n    Turtle.prototype.begin_fill = function () {\n        if (! this.animate) {\n            this.filling = true;\n            this.context.beginPath();\n            this.context.moveTo(this.position[0], this.position[1]);\n        } else\n            this.addDrawingEvent(["BF", this.position[0], this.position[1]]);\n\n    }\n\n    Turtle.prototype.end_fill = function () {\n        if (! this.animate) {\n            this.context.stroke();\n            this.context.fill();\n            this.context.closePath();\n            this.filling = false;\n        } else\n            this.addDrawingEvent(["EF", this.position[0], this.position[1], this.fillStyle]);\n    }\n\n\n    Turtle.prototype.showturtle = function() {\n        if (this.animate) {\n            this.addDrawingEvent(["SH"]);\n        }\n        this.visible = true;\n    }\n\n    Turtle.prototype.hideturtle = function() {\n        if (this.animate) {\n            this.addDrawingEvent(["HT"]);\n        }\n        this.visible = false;\n    }\n\n    Turtle.prototype.isvisible = function() {\n        return this.visible;\n    }\n\n    // \n    // Appearance\n    //\n\n    Turtle.prototype.shape = function(s) {\n        if (this.shapeStore[s])\n            this.currentShape = s;\n        else {\n        }\n    }\n\n    Turtle.prototype.drawturtle = function(heading, position) {\n        var rtPoints = [];\n        var plist = this.shapeStore[this.currentShape];\n        var head;\n        if (! (heading === undefined))\n            head = heading - 90.0;\n        else\n            head = this.heading.toAngle() - 90.0;\n        if (! position)\n            position = this.position\n        for (p in plist) {\n            rtPoints.push(plist[p].scale(this.turtleCanvas.xptscale,this.turtleCanvas.yptscale).rotate(head).add(position));\n        }\n        this.context.beginPath();\n        this.context.moveTo(rtPoints[0][0], rtPoints[0][1]);\n        for (var i = 1; i < rtPoints.length; i++) {\n            this.context.lineTo(rtPoints[i][0], rtPoints[i][1]);\n        }\n        this.context.closePath();\n        this.context.stroke();\n        if (this.fillStyle) {\n            this.context.fill();\n        }\n    }\n\n    Turtle.prototype.stamp = function() {\n        // either call drawTurtle or just add a DT with current position and heading to the drawingEvents list.\n        if (this.animate) {\n            this.addDrawingEvent(["ST",this.position[0],this.position[1],this.heading.toAngle()]);\n        } else\n            this.drawturtle();\n    }\n    \n    Turtle.prototype.clear = function () {\n        if (this.animate) {\n            this.addDrawingEvent(["CL"])\n        } else {\n            clear_canvas(this.canvasID);\n        }\n    }\n\n    function clear_canvas(canId) {\n        with (document.getElementById(canId).getContext(\'2d\')) {\n            if (arguments.length >= 2) {\n//      fillStyle = arguments[1];\n//      fillRect(0, 0, canvas.width, canvas.height);\n            }\n            clearRect(-canvas.width / 2, -canvas.height / 2, canvas.width, canvas.height);\n        }\n    }\n\n\n    // Create a 3d Vector class for manipulating turtle heading, and position.\n\n    function Vector(x, y, z) {\n        if ((typeof(x)).toLowerCase() === \'number\') {\n            Array.prototype.push.call(this, x);\n            Array.prototype.push.call(this, y);\n            Array.prototype.push.call(this, z);\n        }\n        else {\n            for (var i in x) {\n                Array.prototype.push.call(this, x[i]);\n            }\n        }\n    }\n\n\n    // Create a vector object given a direction as an angle.\n    Vector.angle2vec = function(phi) {\n        var res = new Vector([0.0,0.0,0.0]);\n        phi = phi * Degree2Rad;\n        res[0] = Sk.math.cos(phi);\n        res[1] = Sk.math.sin(phi);\n        return res.normalize();\n    }\n\n    // This trick allows you to access a Vector object like an array\n    // myVec[0] == x\n    // myVec[1] == y\n    // myVec[2] == z\n    // we really only need the z for the convenience of rotating\n    Vector.prototype.addItem = function(item) {\n        Array.prototype.push.call(this, item);\n    }\n\n    Vector.prototype.linear = function(a, b, v) {\n        var result = [ ];\n        for (var c = 0; c <= 2; ++c) {\n            result[c] = a * this[c] + b * v[c];\n        }\n        return new Vector(result);\n    }\n\n    Vector.prototype.cross = function(v) {\n        // Return cross product of this and v\n        var result = [ ];\n        for (var c = 0; c <= 2; ++c) {\n            result[c] = this[(c + 1) % 3] * v[(c + 2) % 3] - this[(c + 2) % 3] * v[(c + 1) % 3];\n        }\n        return new Vector(result);\n    }\n\n    Vector.prototype.rotate = function(angle) {\n        // Rotate this counter clockwise by angle.\n        var perp = new Vector(-this[1], this[0], 0);\n        angle = angle * Degree2Rad;\n        var c = Sk.math.cos(angle);\n        var s = Sk.math.sin(angle);\n        return new Vector(this[0] * c + perp[0] * s, this[1] * c + perp[1] * s, 0);\n    }\n\n    Vector.prototype.rotateNormal = function(v, w, alpha) {\n        // Return rotation of this in direction of v about w over alpha\n        // Requires: v, w are vectors; alpha is angle in radians\n        //   this, v, w are orthonormal\n        return this.linear(Sk.math.cos(alpha), Sk.math.sin(alpha), v);\n    }\n\n    Vector.prototype.normalize = function() {\n        var n = this.len();\n        var res = this.div(n);\n        return res;\n    }\n\n    Vector.prototype.toAngle = function() {\n        // workaround for values getting set to +/i xxx e -16 fooling the +/- checks below\n        if (Math.abs(this[1]) < 0.00001) this[1] = 0.0;\n        if (Math.abs(this[0]) < 0.00001) this[0] = 0.0;\n        var rads = Math.atan(Math.abs(this[1]) / Math.abs(this[0]));\n        var deg = rads * Rad2Degree;\n        if (this[0] < 0 && this[1] > 0) deg = 180 - deg;\n        else if (this[0] < 0 && this[1] <= 0) deg = 180.0 + deg;\n        else if (this[0] >= 0 && this[1] < 0) deg = 360 - deg;\n        return deg;\n    }\n\n    // divide all vector components by the same value\n    Vector.prototype.div = function(n) {\n        res = []\n        res[0] = this[0] / n;\n        res[1] = this[1] / n;\n        res[2] = this[2] / n;\n        return new Vector(res);\n    }\n\n    // subtract one vector from another\n    Vector.prototype.sub = function(v) {\n        res = new Vector(0, 0, 0);\n        res[0] = this[0] - v[0];\n        res[1] = this[1] - v[1];\n        res[2] = this[2] - v[2];\n        return res;\n    }\n\n    Vector.prototype.add = function(v) {\n        res = new Vector(0, 0, 0);\n        res[0] = this[0] + v[0];\n        res[1] = this[1] + v[1];\n        res[2] = this[2] + v[2];\n        return res;\n    }\n\n    Vector.prototype.smul = function(k) {  // scalar multiplication\n        res = new Vector(0, 0, 0);\n        res[0] = this[0] * k;\n        res[1] = this[1] * k;\n        res[2] = this[2] * k;\n        return res;\n    }\n\n    Vector.prototype.scale = function(xs,ys) {\n        res = new Vector(0,0,0);\n        res[0] =  this[0] * ys;\n        res[1] =  this[1] * xs;\n        res[2] = 1.0;\n        return res;\n    }\n\n    Vector.prototype.len = function() {\n        return Math.sqrt(this[0] * this[0] + this[1] * this[1] + this[2] * this[2]);\n    }\n\n\n    TurtleGraphics.defaults = { canvasID: \'mycanvas\', degrees: true, animate: true }\n    TurtleGraphics.turtleList = [];\n    TurtleGraphics.Turtle = Turtle;\n    TurtleGraphics.TurtleCanvas = TurtleCanvas;\n    TurtleGraphics.canvasLib = {}\n    TurtleGraphics.clear_canvas = clear_canvas;\n    TurtleGraphics.Vector = Vector;\n    TurtleGraphics.canvasInit = false;\n    TurtleGraphics.eventCount = 0;\n    TurtleGraphics.renderClock = 0;\n    TurtleGraphics.renderTime  = 0;\n\n})();\n\n\n//\n// Wrapper around the Turtle Module starts here.\n//\n//\nvar $builtinmodule = function(name) {\n    var mod = {};\n    // First we create an object, this will end up being the class\n    // class\n    Sk.tg = TurtleGraphics;\n\n    var checkArgs = function(expected, actual, func) {\n        if (actual != expected ) {\n            throw new Sk.builtin.TypeError(func + " takes exactly " + expected +\n                    " positional argument (" + actual + " given)")\n        }\n    }\n\n    var turtle = function($gbl, $loc) {\n        $loc.__init__ = new Sk.builtin.func(function(self) {\n            TurtleGraphics.defaults = {canvasID: Sk.canvas, animate: true, degrees: true};\n            self.theTurtle = new TurtleGraphics.Turtle();\n        });\n\n//\n// Turtle Motion\n//\n        //\n        // Move and Draw\n        //\n        $loc.forward = new Sk.builtin.func(function(self, dist) {\n            dist = Sk.builtin.asnum$(dist);\n            checkArgs(2,arguments.length,"forward()");\n            self.theTurtle.forward(dist);\n        });\n\n        $loc.fd = $loc.forward;\n\n        $loc.backward = new Sk.builtin.func(function(self, dist) {\n            dist = Sk.builtin.asnum$(dist);\n            checkArgs(2,arguments.length,"backward()");\n            self.theTurtle.forward(-dist);\n        });\n\n        $loc.back = $loc.backward;\n        $loc.bk = $loc.backward;\n\n        $loc.right = new Sk.builtin.func(function(self, angle) {\n            angle = Sk.builtin.asnum$(angle);\n            checkArgs(2,arguments.length,"right()");\n            self.theTurtle.turn(angle);\n        });\n\n        $loc.rt = $loc.right;\n\n        $loc.left = new Sk.builtin.func(function(self, angle) {\n            angle = Sk.builtin.asnum$(angle);\n            checkArgs(2,arguments.length,"left()");\n            self.theTurtle.turn(-angle);\n        });\n\n        $loc.lt = $loc.left;\n\n        $loc.goto_$rw$ = new Sk.builtin.func(function(self, nx, ny) {\n            nx = Sk.builtin.asnum$(nx);\n            ny = Sk.builtin.asnum$(ny);\n            checkArgs(3,arguments.length,"goto()");\n            self.theTurtle.goto(nx, ny);\n        });\n\n        $loc.setposition = new Sk.builtin.func(function(self,nx,ny) {\n            nx = Sk.builtin.asnum$(nx);\n            ny = Sk.builtin.asnum$(ny);\n            checkArgs(3,arguments.length,"setposition()");\n            self.theTurtle.up();\n            self.theTurtle.goto(nx,ny);\n            self.theTurtle.down();\n        });\n        $loc.setpos = $loc.setposition;\n\n        $loc.setx = new Sk.builtin.func(function(self, nx) {\n            nx = Sk.builtin.asnum$(nx);\n            checkArgs(2,arguments.length,"setx()");\n            self.theTurtle.goto(nx, self.theTurtle.GetY());\n        });\n\n        $loc.sety = new Sk.builtin.func(function(self, ny) {\n            ny = Sk.builtin.asnum$(ny);\n            checkArgs(2,arguments.length,"sety()");\n            self.theTurtle.goto(self.theTurtle.GetX(), ny);\n        });\n\n        $loc.setheading = new Sk.builtin.func(function(self, newhead) {\n            newhead = Sk.builtin.asnum$(newhead);\n            checkArgs(2,arguments.length,"setheading()");\n            return self.theTurtle.set_heading(newhead);\n        });\n\n        $loc.seth = $loc.setheading;\n\n        $loc.home = new Sk.builtin.func(function(self) {\n            self.theTurtle.go_home();\n        });\n\n        $loc.dot = new Sk.builtin.func(function(self, /*opt*/ size, color) {\n            size = Sk.builtin.asnum$(size);\n            size = size || 1;\n            if (color) {\n                color = color.v || self.theTurtle.penStyle;\n            }\n            self.theTurtle.dot(size, color);\n        });\n\n        $loc.circle = new Sk.builtin.func(function(self, radius, extent) {\n            radius = Sk.builtin.asnum$(radius);\n            extent = Sk.builtin.asnum$(extent);\n            self.theTurtle.circle(radius, extent);\n        });\n\n        $loc.delay = new Sk.builtin.func(function(self, d) {\n            d = Sk.builtin.asnum$(d);\n            return self.theTurtle.delay(d);\n        });\n\n        $loc.speed = new Sk.builtin.func(function(self, s, t) {\n            s = Sk.builtin.asnum$(s);\n            t = Sk.builtin.asnum$(t);\n            self.theTurtle.speed(s,t);\n        });\n\n        $loc.tracer = new Sk.builtin.func(function(self, t, d) {\n            t = Sk.builtin.asnum$(t);\n            d = Sk.builtin.asnum$(d);\n            self.theTurtle.tracer(t, d);\n        });\n\n        $loc.update = new Sk.builtin.func(function(self) {\n            //  Dummy function to emulate update... when not animating, we don\'t save the drawing operations, so this is pointless for us\n        });\n\n        // todo:  stamp, clearstamp, clearstamps, undo, speed\n\n        //\n        // Tell Turtle\'s state\n        //\n        $loc.heading = new Sk.builtin.func(function(self) {\n            checkArgs(1,arguments.length,"heading()");\n            return Sk.builtin.numberToPy(self.theTurtle.get_heading());\n        });\n\n        $loc.position = new Sk.builtin.func(function(self) {\n            checkArgs(1,arguments.length,"position()");\n            var res = self.theTurtle.get_position();\n            var x = new Sk.builtin.tuple([Sk.builtin.numberToPy(res[0]),\n                                          Sk.builtin.numberToPy(res[1]) ]);\n            return x;\n        });\n\n        $loc.pos = $loc.position;\n\n        $loc.xcor = new Sk.builtin.func(function(self) {\n            checkArgs(1,arguments.length,"xcor()");\n            var res = self.theTurtle.getx();\n            return Sk.builtin.numberToPy(res);\n        });\n\n        $loc.ycor = new Sk.builtin.func(function(self) {\n            checkArgs(1,arguments.length,"ycor()");\n            var res = self.theTurtle.gety();\n            return Sk.builtin.numberToPy(res);\n        });\n\n        $loc.towards = new Sk.builtin.func(function(self, tx, ty) {\n            tx = Sk.builtin.asnum$(tx);\n            ty = Sk.builtin.asnum$(ty);\n            if ((typeof(tx)).toLowerCase() === \'number\') {\n                tx = [tx, ty, 0];\n            } else {\n                tx = [Sk.builtin.asnum$(tx.theTurtle.getx()),Sk.builtin.asnum$(tx.theTurtle.gety()),Sk.builtin.asnum$(0)]\n            }\n            return Sk.builtin.numberToPy(self.theTurtle.towards(tx));\n        });\n\n        // tx can be either a number or a vector position.\n        // tx can not be a turtle at this time as multiple turtles have not been implemented yet.\n        $loc.distance = new Sk.builtin.func(function(self, tx, ty) {\n            tx = Sk.builtin.asnum$(tx);\n            ty = Sk.builtin.asnum$(ty);\n            if ((typeof(tx)).toLowerCase() === \'number\') {\n                tx = [tx, ty, 0];\n            } else {\n                tx = [tx.theTurtle.getx(), tx.theTurtle.gety(), 0];\n            }\n            return Sk.builtin.numberToPy(self.theTurtle.distance(tx));\n        });\n\n        //\n        // Setting and Measurement\n        //\n\n        // todo:  degrees and radians...\n\n//\n// Pen Control\n//\n\n        //\n        // Drawing State\n        //\n\n        $loc.up = new Sk.builtin.func(function(self) {\n            checkArgs(1,arguments.length,"up()");\n            self.theTurtle.pen_up();\n        });\n\n        $loc.penup = $loc.up;\n        $loc.pu = $loc.up;\n\n        $loc.down = new Sk.builtin.func(function(self) {\n            checkArgs(1,arguments.length,"down()");\n            self.theTurtle.pen_down();\n        });\n\n        $loc.pendown = $loc.down;\n        $loc.pd = $loc.down;\n\n        $loc.width = new Sk.builtin.func(function(self, w) {\n            w = Sk.builtin.asnum$(w);\n            checkArgs(2,arguments.length,"width()");\n            self.theTurtle.set_pen_width(w);\n        });\n\n        $loc.pensize = $loc.width;\n\n        $loc.isdown = new Sk.builtin.func(function(self) {\n            checkArgs(1,arguments.length,"isdown()");\n            return self.theTurtle.get_pen();\n        });\n\n        // todo:  pen  -- return a dictionary full of pen stuff\n\n        //\n        // Color Control\n        //\n\n        $loc.fillcolor = new Sk.builtin.func(function(self, color, green, blue) {\n            if (color) {\n                if (blue) {\n                    self.theTurtle.set_fill_color(color, green, blue);\n                } else {\n                    color = color.v || self.theTurtle.context.fillStyle;\n                    self.theTurtle.set_fill_color(color);\n                }\n            } else\n                return self.theTurtle.fillStyle;\n        });\n\n        $loc.pencolor = new Sk.builtin.func(function(self, color, green, blue) {\n            if (color) {\n                if (blue) {\n                    color = Sk.builtin.asnum$(color);\n                    green = Sk.builtin.asnum$(green);\n                    blue = Sk.builtin.asnum$(blue);\n                    self.theTurtle.set_pen_color(color, green, blue);\n                } else {\n                    color = color.v || self.theTurtle.context.fillStyle;\n                    self.theTurtle.set_pen_color(color);\n                }\n            } else\n                return self.theTurtle.penStyle;\n        });\n\n        $loc.color = new Sk.builtin.func(function(self, color, green, blue) {\n            if(color) {\n                if (blue) {\n                    self.theTurtle.set_pen_color(color, green, blue);\n                    self.theTurtle.set_fill_color(color, green, blue);\n                } else {\n                    color = color.v || self.theTurtle.context.fillStyle;\n                    self.theTurtle.set_pen_color(color);\n                    self.theTurtle.set_fill_color(color);\n                }\n            } else \n                return [self.theTurtle.penStyle, self.theTurtle.fillStyle];            \n        });\n\n        //\n        //  Filling\n        //\n\n        $loc.begin_fill = new Sk.builtin.func(function(self) {\n            checkArgs(1,arguments.length,"begin_fill()");\n            self.theTurtle.begin_fill();\n        });\n\n        $loc.end_fill = new Sk.builtin.func(function(self) {\n            checkArgs(1,arguments.length,"end_fill()");\n            self.theTurtle.end_fill();\n        });\n\n        $loc.fill = new Sk.builtin.func(function(self, fillt) {\n            if (fillt === undefined)\n                return self.theTurtle.filling;\n            if (fillt)\n                self.theTurtle.begin_fill();\n            else\n                self.theTurtle.end_fill();\n        });\n\n        //\n        // More drawing control\n        //\n\n        $loc.reset = new Sk.builtin.func(function(self) {\n            self.theTurtle.clean();\n        });\n\n        $loc.showturtle = new Sk.builtin.func(function(self) {\n            checkArgs(1,arguments.length,"showturtle()");\n            self.theTurtle.showturtle();\n        });\n        $loc.st = $loc.showturtle;\n\n        $loc.hideturtle = new Sk.builtin.func(function(self) {\n            checkArgs(1,arguments.length,"hideturtle()");\n            self.theTurtle.hideturtle();\n        });\n        $loc.ht = $loc.hideturtle;\n\n        $loc.isvisible = new Sk.builtin.func(function(self) {\n            checkArgs(1,arguments.length,"isvisible()");\n            self.theTurtle.isvisible()\n        });\n\n        $loc.stamp = new Sk.builtin.func(function(self) {\n            checkArgs(1,arguments.length,"stamp()");\n            self.theTurtle.stamp();\n        });\n\n        $loc.shape = new Sk.builtin.func(function(self, s) {\n            checkArgs(2,arguments.length,"shape()");\n            self.theTurtle.shape(s.v);\n        });\n\n\n        // todo the move, align, and font parameters should be kwargs...\n        $loc.write = new Sk.builtin.func(function(self, mystr, move, align, font) {\n            self.theTurtle.write(mystr.v, move, align, font);\n        });\n\n        // todo clean  -- again multiple turtles\n\n        $loc.setworldcoordinates = new Sk.builtin.func(function(self, llx, lly, urx, ury) {\n            llx = Sk.builtin.asnum$(llx);\n            lly = Sk.builtin.asnum$(lly);\n            urx = Sk.builtin.asnum$(urx);\n            ury = Sk.builtin.asnum$(ury);\n            self.theTurtle.setworldcoordinates(llx, lly, urx, ury);\n        });\n\n        $loc.clear = new Sk.builtin.func(function(self) {\n            self.theTurtle.clear()\n        });\n\n    }\n\n    mod.Turtle = Sk.misceval.buildClass(mod, turtle, \'Turtle\', []);\n\n    var screen = function($gbl, $loc) {\n        $loc.__init__ = new Sk.builtin.func(function(self) {\n            TurtleGraphics.defaults = {canvasID: Sk.canvas, animate: true, degrees: true};\n            var currentCanvas = TurtleGraphics.canvasLib[TurtleGraphics.defaults.canvasID];\n            if (currentCanvas === undefined) {\n                self.theScreen = new TurtleGraphics.TurtleCanvas(TurtleGraphics.defaults);\n            } else {\n                self.theScreen = currentCanvas;\n            }\n        });\n\n        $loc.bgcolor = new Sk.builtin.func(function(self, c) {\n            self.theScreen.bgcolor(c);\n        });\n\n        $loc.setworldcoordinates = new Sk.builtin.func(function(self, llx,lly,urx,ury) {\n            llx = Sk.builtin.asnum$(llx);\n            lly = Sk.builtin.asnum$(lly);\n            urx = Sk.builtin.asnum$(urx);\n            ury = Sk.builtin.asnum$(ury);\n            self.theScreen.setworldcoordinates(llx,lly,urx,ury);\n        });\n\n        $loc.exitonclick = new Sk.builtin.func(function(self) {\n            self.theScreen.exitonclick();\n        });\n\n        $loc.title = new Sk.builtin.func(function(self,titlestring) {\n            // no op....\n        });\n\n        $loc.window_width = new Sk.builtin.func(function(self) {\n            return self.theScreen.window_width();\n        });\n\n        $loc.window_height = new Sk.builtin.func(function(self) {\n            return self.theScreen.window_height();\n        });\n\n        $loc.turtles = new Sk.builtin.func(function(self) {\n            return self.theScreen.turtles();\n        });\n\n        $loc.colormode = new Sk.builtin.func(function(self) {\n            //  Empty function to emulate compatibility\n        });\n        \n//        $loc.clear = new Sk.builtin.func(function(self) {\n//          \n//        });\n\n        var myfunc = function(self, width, height, startx, starty) {\n            width = Sk.builtin.asnum$(width);\n            height = Sk.builtin.asnum$(height);\n            self.theScreen.setup(width,height);\n        }\n        // this should allow for named parameters\n        myfunc.co_varnames = [\'self\',\'width\',\'height\',\'startx\',\'starty\'];\n        myfunc.$defaults = [null,500,500,0,0];\n        $loc.setup = new Sk.builtin.func(myfunc);\n    }\n\n    mod.Screen = Sk.misceval.buildClass(mod, screen, \'Screen\', []);\n\n    mod.tracer = new Sk.builtin.func(function(t, d) {\n        t = Sk.builtin.asnum$(t);\n        d = Sk.builtin.asnum$(d);\n        for (var i in Sk.tg.canvasLib)\n            Sk.tg.canvasLib[i].tracer(t, d);\n    });\n\n    mod.update = new Sk.builtin.func(function(self) {\n        //  Dummy function to emulate update... when not animating, we don\'t save the drawing operations, so this is pointless for us\n    });\n\n\n    return mod\n}\n',
    'src/lib/http/__init__.js': 'var $builtinmodule = function(name)\n{\n  var mod = {};\n  Sk.builtin.defineHttp(mod);\n  return mod;\n};\n',
    'src/builtin/unittest.py': '#!/usr/bin/env python\n\'\'\'\nPython unit testing framework, based on Erich Gamma\'s JUnit and Kent Beck\'s\nSmalltalk testing framework.\n\nThis module contains the core framework classes that form the basis of\nspecific test cases and suites (TestCase, TestSuite etc.), and also a\ntext-based utility class for running the tests and reporting the results\n (TextTestRunner).\n\nSimple usage:\n\n    import unittest\n\n    class IntegerArithmenticTestCase(unittest.TestCase):\n        def testAdd(self):  ## test method names begin \'test*\'\n            self.assertEquals((1 + 2), 3)\n            self.assertEquals(0 + 1, 1)\n        def testMultiply(self):\n            self.assertEquals((0 * 10), 0)\n            self.assertEquals((5 * 8), 40)\n\n    if __name__ == \'__main__\':\n        unittest.main()\n\nFurther information is available in the bundled documentation, and from\n\n  http://docs.python.org/lib/module-unittest.html\n\nCopyright (c) 1999-2003 Steve Purcell\nThis module is free software, and you may redistribute it and/or modify\nit under the same terms as Python itself, so long as this copyright message\nand disclaimer are retained in their original form.\n\nIN NO EVENT SHALL THE AUTHOR BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,\nSPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OF\nTHIS CODE, EVEN IF THE AUTHOR HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\nDAMAGE.\n\nTHE AUTHOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\nPARTICULAR PURPOSE.  THE CODE PROVIDED HEREUNDER IS ON AN "AS IS" BASIS,\nAND THERE IS NO OBLIGATION WHATSOEVER TO PROVIDE MAINTENANCE,\nSUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n\'\'\'\n\n__author__ = "Steve Purcell"\n__email__ = "stephen_purcell at yahoo dot com"\n__version__ = "#Revision: 1.63 $"[11:-2]\n\nimport time\nimport sys\nimport traceback\nimport os\nimport types\n\n##############################################################################\n# Exported classes and functions\n##############################################################################\n__all__ = [\'TestResult\', \'TestCase\', \'TestSuite\', \'TextTestRunner\',\n           \'TestLoader\', \'FunctionTestCase\', \'main\', \'defaultTestLoader\']\n\n# Expose obsolete functions for backwards compatibility\n__all__.extend([\'getTestCaseNames\', \'makeSuite\', \'findTestCases\'])\n\n\n##############################################################################\n# Backward compatibility\n##############################################################################\nif sys.version_info[:2] < (2, 2):\n    def isinstance(obj, clsinfo):\n        import __builtin__\n        if type(clsinfo) in (tuple, list):\n            for cls in clsinfo:\n                if cls is type: cls = types.ClassType\n                if __builtin__.isinstance(obj, cls):\n                    return 1\n            return 0\n        else: return __builtin__.isinstance(obj, clsinfo)\n\ndef _CmpToKey(mycmp):\n    \'Convert a cmp= function into a key= function\'\n    class K(object):\n        def __init__(self, obj):\n            self.obj = obj\n        def __lt__(self, other):\n            return mycmp(self.obj, other.obj) == -1\n    return K\n\n##############################################################################\n# Test framework core\n##############################################################################\n\n# All classes defined herein are \'new-style\' classes, allowing use of \'super()\'\n__metaclass__ = type\n\ndef _strclass(cls):\n    return "%s.%s" % (cls.__module__, cls.__name__)\n\n__unittest = 1\n\nclass TestResult:\n    """Holder for test result information.\n\n    Test results are automatically managed by the TestCase and TestSuite\n    classes, and do not need to be explicitly manipulated by writers of tests.\n\n    Each instance holds the total number of tests run, and collections of\n    failures and errors that occurred among those test runs. The collections\n    contain tuples of (testcase, exceptioninfo), where exceptioninfo is the\n    formatted traceback of the error that occurred.\n    """\n    def __init__(self):\n        self.failures = []\n        self.errors = []\n        self.testsRun = 0\n        self.shouldStop = False\n\n    def startTest(self, test):\n        "Called when the given test is about to be run"\n        self.testsRun = self.testsRun + 1\n\n    def stopTest(self, test):\n        "Called when the given test has been run"\n        pass\n\n    def addError(self, test, err):\n        """Called when an error has occurred. \'err\' is a tuple of values as\n        returned by sys.exc_info().\n        """\n        self.errors.append((test, self._exc_info_to_string(err, test)))\n\n    def addFailure(self, test, err):\n        """Called when an error has occurred. \'err\' is a tuple of values as\n        returned by sys.exc_info()."""\n        self.failures.append((test, self._exc_info_to_string(err, test)))\n\n    def addSuccess(self, test):\n        "Called when a test has completed successfully"\n        pass\n\n    def wasSuccessful(self):\n        "Tells whether or not this result was a success"\n        return len(self.failures) == len(self.errors) == 0\n\n    def stop(self):\n        "Indicates that the tests should be aborted"\n        self.shouldStop = True\n\n    def _exc_info_to_string(self, err, test):\n        """Converts a sys.exc_info()-style tuple of values into a string."""\n        exctype, value, tb = err\n        # Skip test runner traceback levels\n        while tb and self._is_relevant_tb_level(tb):\n            tb = tb.tb_next\n        if exctype is test.failureException:\n            # Skip assert*() traceback levels\n            length = self._count_relevant_tb_levels(tb)\n            return \'\'.join(traceback.format_exception(exctype, value, tb, length))\n        return \'\'.join(traceback.format_exception(exctype, value, tb))\n\n    def _is_relevant_tb_level(self, tb):\n        return \'__unittest\' in tb.tb_frame.f_globals\n\n    def _count_relevant_tb_levels(self, tb):\n        length = 0\n        while tb and not self._is_relevant_tb_level(tb):\n            length += 1\n            tb = tb.tb_next\n        return length\n\n    def __repr__(self):\n        return "<%s run=%i errors=%i failures=%i>" % \\\n               (_strclass(self.__class__), self.testsRun, len(self.errors),\n                len(self.failures))\n\nclass TestCase:\n    """A class whose instances are single test cases.\n\n    By default, the test code itself should be placed in a method named\n    \'runTest\'.\n\n    If the fixture may be used for many test cases, create as\n    many test methods as are needed. When instantiating such a TestCase\n    subclass, specify in the constructor arguments the name of the test method\n    that the instance is to execute.\n\n    Test authors should subclass TestCase for their own tests. Construction\n    and deconstruction of the test\'s environment (\'fixture\') can be\n    implemented by overriding the \'setUp\' and \'tearDown\' methods respectively.\n\n    If it is necessary to override the __init__ method, the base class\n    __init__ method must always be called. It is important that subclasses\n    should not change the signature of their __init__ method, since instances\n    of the classes are instantiated automatically by parts of the framework\n    in order to be run.\n    """\n\n    # This attribute determines which exception will be raised when\n    # the instance\'s assertion methods fail; test methods raising this\n    # exception will be deemed to have \'failed\' rather than \'errored\'\n\n    failureException = AssertionError\n\n    def __init__(self, methodName=\'runTest\'):\n        """Create an instance of the class that will use the named test\n           method when executed. Raises a ValueError if the instance does\n           not have a method with the specified name.\n        """\n        try:\n            self._testMethodName = methodName\n            testMethod = getattr(self, methodName)\n            self._testMethodDoc = testMethod.__doc__\n        except AttributeError:\n            raise ValueError, "no such test method in %s: %s" % \\\n                  (self.__class__, methodName)\n\n    def setUp(self):\n        "Hook method for setting up the test fixture before exercising it."\n        pass\n\n    def tearDown(self):\n        "Hook method for deconstructing the test fixture after testing it."\n        pass\n\n    def countTestCases(self):\n        return 1\n\n    def defaultTestResult(self):\n        return TestResult()\n\n    def shortDescription(self):\n        """Returns a one-line description of the test, or None if no\n        description has been provided.\n\n        The default implementation of this method returns the first line of\n        the specified test method\'s docstring.\n        """\n        doc = self._testMethodDoc\n        return doc and doc.split("\\n")[0].strip() or None\n\n    def id(self):\n        return "%s.%s" % (_strclass(self.__class__), self._testMethodName)\n\n    def __eq__(self, other):\n        if type(self) is not type(other):\n            return False\n\n        return self._testMethodName == other._testMethodName\n\n    def __ne__(self, other):\n        return not self == other\n\n    def __hash__(self):\n        return hash((type(self), self._testMethodName))\n\n    def __str__(self):\n        return "%s (%s)" % (self._testMethodName, _strclass(self.__class__))\n\n    def __repr__(self):\n        return "<%s testMethod=%s>" % \\\n               (_strclass(self.__class__), self._testMethodName)\n\n    def run(self, result=None):\n        if result is None: result = self.defaultTestResult()\n        result.startTest(self)\n        testMethod = getattr(self, self._testMethodName)\n        try:\n            try:\n                self.setUp()\n            except KeyboardInterrupt:\n                raise\n            except:\n                result.addError(self, self._exc_info())\n                return\n\n            ok = False\n            try:\n                testMethod()\n                ok = True\n            except self.failureException:\n                result.addFailure(self, self._exc_info())\n            except KeyboardInterrupt:\n                raise\n            except:\n                result.addError(self, self._exc_info())\n\n            try:\n                self.tearDown()\n            except KeyboardInterrupt:\n                raise\n            except:\n                result.addError(self, self._exc_info())\n                ok = False\n            if ok: result.addSuccess(self)\n        finally:\n            result.stopTest(self)\n\n    def __call__(self, *args, **kwds):\n        return self.run(*args, **kwds)\n\n    def debug(self):\n        """Run the test without collecting errors in a TestResult"""\n        self.setUp()\n        getattr(self, self._testMethodName)()\n        self.tearDown()\n\n    def _exc_info(self):\n        """Return a version of sys.exc_info() with the traceback frame\n           minimised; usually the top level of the traceback frame is not\n           needed.\n        """\n        return sys.exc_info()\n\n    def fail(self, msg=None):\n        """Fail immediately, with the given message."""\n        raise self.failureException, msg\n\n    def failIf(self, expr, msg=None):\n        "Fail the test if the expression is true."\n        if expr: raise self.failureException, msg\n\n    def failUnless(self, expr, msg=None):\n        """Fail the test unless the expression is true."""\n        if not expr: raise self.failureException, msg\n\n    def failUnlessRaises(self, excClass, callableObj, *args, **kwargs):\n        """Fail unless an exception of class excClass is thrown\n           by callableObj when invoked with arguments args and keyword\n           arguments kwargs. If a different type of exception is\n           thrown, it will not be caught, and the test case will be\n           deemed to have suffered an error, exactly as for an\n           unexpected exception.\n        """\n        try:\n            callableObj(*args, **kwargs)\n        except excClass:\n            return\n        else:\n            if hasattr(excClass,\'__name__\'): excName = excClass.__name__\n            else: excName = str(excClass)\n            raise self.failureException, "%s not raised" % excName\n\n    def failUnlessEqual(self, first, second, msg=None):\n        """Fail if the two objects are unequal as determined by the \'==\'\n           operator.\n        """\n        if not first == second:\n            raise self.failureException, \\\n                  (msg or \'%r != %r\' % (first, second))\n\n    def failIfEqual(self, first, second, msg=None):\n        """Fail if the two objects are equal as determined by the \'==\'\n           operator.\n        """\n        if first == second:\n            raise self.failureException, \\\n                  (msg or \'%r == %r\' % (first, second))\n\n    def failUnlessAlmostEqual(self, first, second, places=7, msg=None):\n        """Fail if the two objects are unequal as determined by their\n           difference rounded to the given number of decimal places\n           (default 7) and comparing to zero.\n\n           Note that decimal places (from zero) are usually not the same\n           as significant digits (measured from the most signficant digit).\n        """\n        if round(abs(second-first), places) != 0:\n            raise self.failureException, \\\n                  (msg or \'%r != %r within %r places\' % (first, second, places))\n\n    def failIfAlmostEqual(self, first, second, places=7, msg=None):\n        """Fail if the two objects are equal as determined by their\n           difference rounded to the given number of decimal places\n           (default 7) and comparing to zero.\n\n           Note that decimal places (from zero) are usually not the same\n           as significant digits (measured from the most signficant digit).\n        """\n        if round(abs(second-first), places) == 0:\n            raise self.failureException, \\\n                  (msg or \'%r == %r within %r places\' % (first, second, places))\n\n    # Synonyms for assertion methods\n\n    assertEqual = assertEquals = failUnlessEqual\n\n    assertNotEqual = assertNotEquals = failIfEqual\n\n    assertAlmostEqual = assertAlmostEquals = failUnlessAlmostEqual\n\n    assertNotAlmostEqual = assertNotAlmostEquals = failIfAlmostEqual\n\n    assertRaises = failUnlessRaises\n\n    assert_ = assertTrue = failUnless\n\n    assertFalse = failIf\n\n\n\nclass TestSuite:\n    """A test suite is a composite test consisting of a number of TestCases.\n\n    For use, create an instance of TestSuite, then add test case instances.\n    When all tests have been added, the suite can be passed to a test\n    runner, such as TextTestRunner. It will run the individual test cases\n    in the order in which they were added, aggregating the results. When\n    subclassing, do not forget to call the base class constructor.\n    """\n    def __init__(self, tests=()):\n        self._tests = []\n        self.addTests(tests)\n\n    def __repr__(self):\n        return "<%s tests=%s>" % (_strclass(self.__class__), self._tests)\n\n    __str__ = __repr__\n\n    def __eq__(self, other):\n        if type(self) is not type(other):\n            return False\n        return self._tests == other._tests\n\n    def __ne__(self, other):\n        return not self == other\n\n    # Can\'t guarantee hash invariant, so flag as unhashable\n    __hash__ = None\n\n    def __iter__(self):\n        return iter(self._tests)\n\n    def countTestCases(self):\n        cases = 0\n        for test in self._tests:\n            cases += test.countTestCases()\n        return cases\n\n    def addTest(self, test):\n        # sanity checks\n        if not hasattr(test, \'__call__\'):\n            raise TypeError("the test to add must be callable")\n        if (isinstance(test, (type, types.ClassType)) and\n            issubclass(test, (TestCase, TestSuite))):\n            raise TypeError("TestCases and TestSuites must be instantiated "\n                            "before passing them to addTest()")\n        self._tests.append(test)\n\n    def addTests(self, tests):\n        if isinstance(tests, basestring):\n            raise TypeError("tests must be an iterable of tests, not a string")\n        for test in tests:\n            self.addTest(test)\n\n    def run(self, result):\n        for test in self._tests:\n            if result.shouldStop:\n                break\n            test(result)\n        return result\n\n    def __call__(self, *args, **kwds):\n        return self.run(*args, **kwds)\n\n    def debug(self):\n        """Run the tests without collecting errors in a TestResult"""\n        for test in self._tests: test.debug()\n\n\nclass FunctionTestCase(TestCase):\n    """A test case that wraps a test function.\n\n    This is useful for slipping pre-existing test functions into the\n    unittest framework. Optionally, set-up and tidy-up functions can be\n    supplied. As with TestCase, the tidy-up (\'tearDown\') function will\n    always be called if the set-up (\'setUp\') function ran successfully.\n    """\n\n    def __init__(self, testFunc, setUp=None, tearDown=None,\n                 description=None):\n        TestCase.__init__(self)\n        self.__setUpFunc = setUp\n        self.__tearDownFunc = tearDown\n        self.__testFunc = testFunc\n        self.__description = description\n\n    def setUp(self):\n        if self.__setUpFunc is not None:\n            self.__setUpFunc()\n\n    def tearDown(self):\n        if self.__tearDownFunc is not None:\n            self.__tearDownFunc()\n\n    def runTest(self):\n        self.__testFunc()\n\n    def id(self):\n        return self.__testFunc.__name__\n\n    def __eq__(self, other):\n        if type(self) is not type(other):\n            return False\n\n        return self.__setUpFunc == other.__setUpFunc and \\\n               self.__tearDownFunc == other.__tearDownFunc and \\\n               self.__testFunc == other.__testFunc and \\\n               self.__description == other.__description\n\n    def __ne__(self, other):\n        return not self == other\n\n    def __hash__(self):\n        return hash((type(self), self.__setUpFunc, self.__tearDownFunc,\n                                           self.__testFunc, self.__description))\n\n    def __str__(self):\n        return "%s (%s)" % (_strclass(self.__class__), self.__testFunc.__name__)\n\n    def __repr__(self):\n        return "<%s testFunc=%s>" % (_strclass(self.__class__), self.__testFunc)\n\n    def shortDescription(self):\n        if self.__description is not None: return self.__description\n        doc = self.__testFunc.__doc__\n        return doc and doc.split("\\n")[0].strip() or None\n\n\n\n##############################################################################\n# Locating and loading tests\n##############################################################################\n\nclass TestLoader:\n    """This class is responsible for loading tests according to various\n    criteria and returning them wrapped in a TestSuite\n    """\n    testMethodPrefix = \'test\'\n    sortTestMethodsUsing = cmp\n    suiteClass = TestSuite\n\n    def loadTestsFromTestCase(self, testCaseClass):\n        """Return a suite of all tests cases contained in testCaseClass"""\n        if issubclass(testCaseClass, TestSuite):\n            raise TypeError("Test cases should not be derived from TestSuite. Maybe you meant to derive from TestCase?")\n        testCaseNames = self.getTestCaseNames(testCaseClass)\n        if not testCaseNames and hasattr(testCaseClass, \'runTest\'):\n            testCaseNames = [\'runTest\']\n        return self.suiteClass(map(testCaseClass, testCaseNames))\n\n    def loadTestsFromModule(self, module):\n        """Return a suite of all tests cases contained in the given module"""\n        tests = []\n        for name in dir(module):\n            obj = getattr(module, name)\n            if (isinstance(obj, (type, types.ClassType)) and\n                issubclass(obj, TestCase)):\n                tests.append(self.loadTestsFromTestCase(obj))\n        return self.suiteClass(tests)\n\n    def loadTestsFromName(self, name, module=None):\n        """Return a suite of all tests cases given a string specifier.\n\n        The name may resolve either to a module, a test case class, a\n        test method within a test case class, or a callable object which\n        returns a TestCase or TestSuite instance.\n\n        The method optionally resolves the names relative to a given module.\n        """\n        parts = name.split(\'.\')\n        if module is None:\n            parts_copy = parts[:]\n            while parts_copy:\n                try:\n                    module = __import__(\'.\'.join(parts_copy))\n                    break\n                except ImportError:\n                    del parts_copy[-1]\n                    if not parts_copy: raise\n            parts = parts[1:]\n        obj = module\n        for part in parts:\n            parent, obj = obj, getattr(obj, part)\n\n        if type(obj) == types.ModuleType:\n            return self.loadTestsFromModule(obj)\n        elif (isinstance(obj, (type, types.ClassType)) and\n              issubclass(obj, TestCase)):\n            return self.loadTestsFromTestCase(obj)\n        elif (type(obj) == types.UnboundMethodType and\n              isinstance(parent, (type, types.ClassType)) and\n              issubclass(parent, TestCase)):\n            return TestSuite([parent(obj.__name__)])\n        elif isinstance(obj, TestSuite):\n            return obj\n        elif hasattr(obj, \'__call__\'):\n            test = obj()\n            if isinstance(test, TestSuite):\n                return test\n            elif isinstance(test, TestCase):\n                return TestSuite([test])\n            else:\n                raise TypeError("calling %s returned %s, not a test" %\n                                (obj, test))\n        else:\n            raise TypeError("don\'t know how to make test from: %s" % obj)\n\n    def loadTestsFromNames(self, names, module=None):\n        """Return a suite of all tests cases found using the given sequence\n        of string specifiers. See \'loadTestsFromName()\'.\n        """\n        suites = [self.loadTestsFromName(name, module) for name in names]\n        return self.suiteClass(suites)\n\n    def getTestCaseNames(self, testCaseClass):\n        """Return a sorted sequence of method names found within testCaseClass\n        """\n        def isTestMethod(attrname, testCaseClass=testCaseClass, prefix=self.testMethodPrefix):\n            return attrname.startswith(prefix) and hasattr(getattr(testCaseClass, attrname), \'__call__\')\n        testFnNames = filter(isTestMethod, dir(testCaseClass))\n        if self.sortTestMethodsUsing:\n            testFnNames.sort(key=_CmpToKey(self.sortTestMethodsUsing))\n        return testFnNames\n\n\n\ndefaultTestLoader = TestLoader()\n\n\n##############################################################################\n# Patches for old functions: these functions should be considered obsolete\n##############################################################################\n\ndef _makeLoader(prefix, sortUsing, suiteClass=None):\n    loader = TestLoader()\n    loader.sortTestMethodsUsing = sortUsing\n    loader.testMethodPrefix = prefix\n    if suiteClass: loader.suiteClass = suiteClass\n    return loader\n\ndef getTestCaseNames(testCaseClass, prefix, sortUsing=cmp):\n    return _makeLoader(prefix, sortUsing).getTestCaseNames(testCaseClass)\n\ndef makeSuite(testCaseClass, prefix=\'test\', sortUsing=cmp, suiteClass=TestSuite):\n    return _makeLoader(prefix, sortUsing, suiteClass).loadTestsFromTestCase(testCaseClass)\n\ndef findTestCases(module, prefix=\'test\', sortUsing=cmp, suiteClass=TestSuite):\n    return _makeLoader(prefix, sortUsing, suiteClass).loadTestsFromModule(module)\n\n\n##############################################################################\n# Text UI\n##############################################################################\n\nclass _WritelnDecorator:\n    """Used to decorate file-like objects with a handy \'writeln\' method"""\n    def __init__(self,stream):\n        self.stream = stream\n\n    def __getattr__(self, attr):\n        return getattr(self.stream,attr)\n\n    def writeln(self, arg=None):\n        if arg: self.write(arg)\n        self.write(\'\\n\') # text-mode streams translate to \\r\\n if needed\n\n\nclass _TextTestResult(TestResult):\n    """A test result class that can print formatted text results to a stream.\n\n    Used by TextTestRunner.\n    """\n    separator1 = \'=\' * 70\n    separator2 = \'-\' * 70\n\n    def __init__(self, stream, descriptions, verbosity):\n        TestResult.__init__(self)\n        self.stream = stream\n        self.showAll = verbosity > 1\n        self.dots = verbosity == 1\n        self.descriptions = descriptions\n\n    def getDescription(self, test):\n        if self.descriptions:\n            return test.shortDescription() or str(test)\n        else:\n            return str(test)\n\n    def startTest(self, test):\n        TestResult.startTest(self, test)\n        if self.showAll:\n            self.stream.write(self.getDescription(test))\n            self.stream.write(" ... ")\n            self.stream.flush()\n\n    def addSuccess(self, test):\n        TestResult.addSuccess(self, test)\n        if self.showAll:\n            self.stream.writeln("ok")\n        elif self.dots:\n            self.stream.write(\'.\')\n            self.stream.flush()\n\n    def addError(self, test, err):\n        TestResult.addError(self, test, err)\n        if self.showAll:\n            self.stream.writeln("ERROR")\n        elif self.dots:\n            self.stream.write(\'E\')\n            self.stream.flush()\n\n    def addFailure(self, test, err):\n        TestResult.addFailure(self, test, err)\n        if self.showAll:\n            self.stream.writeln("FAIL")\n        elif self.dots:\n            self.stream.write(\'F\')\n            self.stream.flush()\n\n    def printErrors(self):\n        if self.dots or self.showAll:\n            self.stream.writeln()\n        self.printErrorList(\'ERROR\', self.errors)\n        self.printErrorList(\'FAIL\', self.failures)\n\n    def printErrorList(self, flavour, errors):\n        for test, err in errors:\n            self.stream.writeln(self.separator1)\n            self.stream.writeln("%s: %s" % (flavour,self.getDescription(test)))\n            self.stream.writeln(self.separator2)\n            self.stream.writeln("%s" % err)\n\n\nclass TextTestRunner:\n    """A test runner class that displays results in textual form.\n\n    It prints out the names of tests as they are run, errors as they\n    occur, and a summary of the results at the end of the test run.\n    """\n    def __init__(self, stream=sys.stderr, descriptions=1, verbosity=1):\n        self.stream = _WritelnDecorator(stream)\n        self.descriptions = descriptions\n        self.verbosity = verbosity\n\n    def _makeResult(self):\n        return _TextTestResult(self.stream, self.descriptions, self.verbosity)\n\n    def run(self, test):\n        "Run the given test case or test suite."\n        result = self._makeResult()\n        startTime = time.time()\n        test(result)\n        stopTime = time.time()\n        timeTaken = stopTime - startTime\n        result.printErrors()\n        self.stream.writeln(result.separator2)\n        run = result.testsRun\n        self.stream.writeln("Ran %d test%s in %.3fs" %\n                            (run, run != 1 and "s" or "", timeTaken))\n        self.stream.writeln()\n        if not result.wasSuccessful():\n            self.stream.write("FAILED (")\n            failed, errored = map(len, (result.failures, result.errors))\n            if failed:\n                self.stream.write("failures=%d" % failed)\n            if errored:\n                if failed: self.stream.write(", ")\n                self.stream.write("errors=%d" % errored)\n            self.stream.writeln(")")\n        else:\n            self.stream.writeln("OK")\n        return result\n\n\n\n##############################################################################\n# Facilities for running tests from the command line\n##############################################################################\n\nclass TestProgram:\n    """A command-line program that runs a set of tests; this is primarily\n       for making test modules conveniently executable.\n    """\n    USAGE = """\\\nUsage: %(progName)s [options] [test] [...]\n\nOptions:\n  -h, --help       Show this message\n  -v, --verbose    Verbose output\n  -q, --quiet      Minimal output\n\nExamples:\n  %(progName)s                               - run default set of tests\n  %(progName)s MyTestSuite                   - run suite \'MyTestSuite\'\n  %(progName)s MyTestCase.testSomething      - run MyTestCase.testSomething\n  %(progName)s MyTestCase                    - run all \'test*\' test methods\n                                               in MyTestCase\n"""\n    def __init__(self, module=\'__main__\', defaultTest=None,\n                 argv=None, testRunner=None,\n                 testLoader=defaultTestLoader):\n        if type(module) == type(\'\'):\n            self.module = __import__(module)\n            for part in module.split(\'.\')[1:]:\n                self.module = getattr(self.module, part)\n        else:\n            self.module = module\n        if argv is None:\n            argv = sys.argv\n        self.verbosity = 1\n        self.defaultTest = defaultTest\n        self.testRunner = testRunner\n        self.testLoader = testLoader\n        self.progName = os.path.basename(argv[0])\n        self.parseArgs(argv)\n        self.runTests()\n\n    def usageExit(self, msg=None):\n        if msg: print msg\n        print self.USAGE % self.__dict__\n        sys.exit(2)\n\n    def parseArgs(self, argv):\n        import getopt\n        try:\n            options, args = getopt.getopt(argv[1:], \'hHvq\',\n                                          [\'help\',\'verbose\',\'quiet\'])\n            for opt, value in options:\n                if opt in (\'-h\',\'-H\',\'--help\'):\n                    self.usageExit()\n                if opt in (\'-q\',\'--quiet\'):\n                    self.verbosity = 0\n                if opt in (\'-v\',\'--verbose\'):\n                    self.verbosity = 2\n            if len(args) == 0 and self.defaultTest is None:\n                self.test = self.testLoader.loadTestsFromModule(self.module)\n                return\n            if len(args) > 0:\n                self.testNames = args\n            else:\n                self.testNames = (self.defaultTest,)\n            self.createTests()\n        except getopt.error, msg:\n            self.usageExit(msg)\n\n    def createTests(self):\n        self.test = self.testLoader.loadTestsFromNames(self.testNames,\n                                                       self.module)\n\n    def runTests(self):\n        if self.testRunner is None:\n            self.testRunner = TextTestRunner\n\n        if isinstance(self.testRunner, (type, types.ClassType)):\n            try:\n                testRunner = self.testRunner(verbosity=self.verbosity)\n            except TypeError:\n                # didn\'t accept the verbosity argument\n                testRunner = self.testRunner()\n        else:\n            # it is assumed to be a TestRunner instance\n            testRunner = self.testRunner\n        result = testRunner.run(self.test)\n        sys.exit(not result.wasSuccessful())\n\nmain = TestProgram\n\n\n##############################################################################\n# Executing this module from the command line\n##############################################################################\n\nif __name__ == "__main__":\n    main(module=None)\n',
    'src/lib/pythonds/graphs/__init__.py': '\n\nfrom .adjGraph import Graph\nfrom .adjGraph import Vertex\nfrom .priorityQueue import PriorityQueue\n',
    'src/lib/workbench/__init__.js': 'var $builtinmodule = function(name) {\n  var mod = {};\n  Sk.builtin.defineWorkbench(mod);\n  return mod;\n}\n',
    'src/lib/pythonds/graphs/priorityQueue.py': '# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005\n# \nimport unittest\n\n# this implementation of binary heap takes key value pairs,\n# we will assume that the keys are all comparable\n\nclass PriorityQueue:\n    def __init__(self):\n        self.heapArray = [(0,0)]\n        self.currentSize = 0\n\n    def buildHeap(self,alist):\n        self.currentSize = len(alist)\n        self.heapArray = [(0,0)]\n        for i in alist:\n            self.heapArray.append(i)\n        i = len(alist) // 2            \n        while (i > 0):\n            self.percDown(i)\n            i = i - 1\n                        \n    def percDown(self,i):\n        while (i * 2) <= self.currentSize:\n            mc = self.minChild(i)\n            if self.heapArray[i][0] > self.heapArray[mc][0]:\n                tmp = self.heapArray[i]\n                self.heapArray[i] = self.heapArray[mc]\n                self.heapArray[mc] = tmp\n            i = mc\n                \n    def minChild(self,i):\n        if i*2 > self.currentSize:\n            return -1\n        else:\n            if i*2 + 1 > self.currentSize:\n                return i*2\n            else:\n                if self.heapArray[i*2][0] < self.heapArray[i*2+1][0]:\n                    return i*2\n                else:\n                    return i*2+1\n\n    def percUp(self,i):\n        while i // 2 > 0:\n            if self.heapArray[i][0] < self.heapArray[i//2][0]:\n               tmp = self.heapArray[i//2]\n               self.heapArray[i//2] = self.heapArray[i]\n               self.heapArray[i] = tmp\n            i = i//2\n \n    def add(self,k):\n        self.heapArray.append(k)\n        self.currentSize = self.currentSize + 1\n        self.percUp(self.currentSize)\n\n    def delMin(self):\n        retval = self.heapArray[1][1]\n        self.heapArray[1] = self.heapArray[self.currentSize]\n        self.currentSize = self.currentSize - 1\n        self.heapArray.pop()\n        self.percDown(1)\n        return retval\n        \n    def isEmpty(self):\n        if self.currentSize == 0:\n            return True\n        else:\n            return False\n\n    def decreaseKey(self,val,amt):\n        # this is a little wierd, but we need to find the heap thing to decrease by\n        # looking at its value\n        done = False\n        i = 1\n        myKey = 0\n        while not done and i <= self.currentSize:\n            if self.heapArray[i][1] == val:\n                done = True\n                myKey = i\n            else:\n                i = i + 1\n        if myKey > 0:\n            self.heapArray[myKey] = (amt,self.heapArray[myKey][1])\n            self.percUp(myKey)\n            \n    def __contains__(self,vtx):\n        for pair in self.heapArray:\n            if pair[1] == vtx:\n                return True\n        return False\n        \nclass TestBinHeap(unittest.TestCase):\n    def setUp(self):\n        self.theHeap = PriorityQueue()\n        self.theHeap.add((2,\'x\'))\n        self.theHeap.add((3,\'y\'))\n        self.theHeap.add((5,\'z\'))\n        self.theHeap.add((6,\'a\'))\n        self.theHeap.add((4,\'d\'))\n\n\n    def testInsert(self):\n        assert self.theHeap.currentSize == 5\n\n    def testDelmin(self):\n        assert self.theHeap.delMin() == \'x\'\n        assert self.theHeap.delMin() == \'y\'\n    \n    def testDecKey(self):\n        self.theHeap.decreaseKey(\'d\',1)\n        assert self.theHeap.delMin() == \'d\'\n        \nif __name__ == \'__main__\':\n    unittest.main()\n',
    'src/lib/pythonds/__init__.py': '',
    'src/lib/cmath/__init__.js': 'var $builtinmodule = function(name)\n{\n  var mod = {};\n  Sk.builtin.defineComplex(mod, "complex");\n  return mod;\n};\n',
    'src/lib/pythonds/basic/deque.py': '# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005\n# \n#deque.py\r\n\r\n\r\nclass Deque:\r\n    def __init__(self):\r\n        self.items = []\r\n\r\n    def isEmpty(self):\r\n        return self.items == []\r\n\r\n    def addFront(self, item):\r\n        self.items.append(item)\r\n\r\n    def addRear(self, item):\r\n        self.items.insert(0,item)\r\n\r\n    def removeFront(self):\r\n        return self.items.pop()\r\n\r\n    def removeRear(self):\r\n        return self.items.pop(0)\r\n\r\n    def size(self):\r\n        return len(self.items)\r\n',
    'src/lib/lorentz/__init__.js': 'var $builtinmodule = function(name) {\n  var mod = {};\n  Sk.builtin.defineLorentzian(mod, BLADE);\n  return mod;\n}\n',
    'src/lib/processing/__init__.js': 'var $builtinmodule = function(name)\n{\n    var mod = {};\n    var imList = [];\n    var looping = true;\n\n    // We need this to store a reference to the actual processing object which is not created\n    // until the run function is called.  Even then the processing object is passed by the\n    // processing-js sytem as a parameter to the sketchProc function.  Why not set it to None here\n    //\n\n    // See:  http://processingjs.org/reference/\n\n    mod.processing = null\n    mod.p = null\n\n    mod.CENTER = Sk.ffi.numberToIntPy(3);\n    mod.RADIUS = Sk.ffi.numberToIntPy(2);\n    mod.CORNERS = Sk.ffi.numberToIntPy(1);\n    mod.CORNER = Sk.ffi.numberToIntPy(0);\n    mod.RGB = Sk.ffi.numberToIntPy(1);\n    mod.HSB = Sk.ffi.numberToIntPy(3);\n    mod.CMYK = Sk.ffi.numberToIntPy(5);\n    mod.MITER = Sk.builtin.stringToPy(\'miter\');\n    mod.BEVEL = Sk.builtin.stringToPy(\'bevel\');\n    mod.ROUND = Sk.builtin.stringToPy(\'round\');\n    mod.SQUARE = Sk.builtin.stringToPy(\'butt\');\n    mod.PROJECT = Sk.builtin.stringToPy(\'square\');\n\n// 2D - Primitives\n    mod.line = new Sk.builtin.func(function(x1, y1, x2, y2) {\n        mod.processing.line(x1.v, y1.v, x2.v, y2.v);\n    });\n    \n    mod.ellipse = new Sk.builtin.func(function(x,y,r1,r2) {\n        mod.processing.ellipse(x.v,y.v,r1.v,r2.v)\n        \n    });\n\n    mod.point = new Sk.builtin.func(function(x1,y1) {\n        mod.processing.point(x1.v,y1.v)\n    });\n        \n    mod.arc = new Sk.builtin.func(function(x, y, width, height, start, stop) {\n        mod.processing.arc(x.v, y.v, width.v, height.v, start.v, stop.v)\n    });\n\n    mod.quad = new Sk.builtin.func(function(x1, y1, x2, y2, x3, y3, x4, y4) {\n        mod.processing.quad(x1.v, y1.v, x2.v, y2.v, x3.v, y3.v, x4.v, y4.v)\n    });\n            \n    mod.rect = new Sk.builtin.func(function(x, y, width, height, radius) {\n        if (typeof(radius) == \'undefined\') {\n            var rad = 0\n        } else {\n            var rad = radius.v\n        }\n        mod.processing.rect(x.v, y.v, width.v, height.v, rad)\n    });\n    \n    mod.triangle = new Sk.builtin.func(function(x1, y1, x2, y2, x3, y3) {\n            mod.processing.triangle(x1.v, y1.v, x2.v, y2.v, x3.v, y3.v)\n        });\n            \n\n    // 3D Primitives\n\n    // todo:  box, sphere, sphereDetail\n\n    // Color\n    mod.background = new Sk.builtin.func(function(r,g,b) {\n\n        if (typeof(g) !== \'undefined\')\n            g = g.v\n        if (typeof(b) !== \'undefined\')\n            b = b.v\n\n        mod.processing.background(r.v,g,b)\n        \n    });\n\n    mod.fill = new Sk.builtin.func(function(r,g,b) {\n        // r will be either:\n        //      a number in which case the fill will be grayscale\n        //      a color object\n        // g, and b may be undefined.  If they hold values it will\n        // be assumed that we have an r,g,b color tuple\n        if (typeof(g) !== \'undefined\')\n            g = g.v\n        if (typeof(b) !== \'undefined\')\n            b = b.v\n    \n        mod.processing.fill(r.v,g,b)\n        \n    });\n\n\n    mod.stroke = new Sk.builtin.func(function(r,g,b) {\n\n        if (typeof(g) !== \'undefined\')\n            g = g.v\n        if (typeof(b) !== \'undefined\')\n            b = b.v\n\n        mod.processing.stroke(r.v,g,b)\n        \n    });\n\n    mod.noStroke = new Sk.builtin.func(function() {\n        mod.processing.noStroke()\n    });\n    \n\n    mod.colorMode = new Sk.builtin.func(function(model, maxV) {\n        if (typeof(maxV) === \'undefined\')\n            maxV = 255\n        else\n            maxV = maxV.v\n        mod.processing.colorMode(model.v, maxV)\n    });\n\n    mod.noFill = new Sk.builtin.func(function() {\n            mod.processing.noFill()\n        });\n            \n\n    // Environment\n\n    mod.loop = new Sk.builtin.func(function() {\n            if (mod.processing === null) {\n                throw new Sk.builtin.Exception("Loop should be called in setup")\n            }\n            looping = true;\n            mod.processing.loop()\n        });\n            \n    mod.noLoop = new Sk.builtin.func(function() {\n        if (mod.processing === null) {\n            throw new Sk.builtin.Exception("noLoop should be called in setup")\n        }\n        looping = false;\n        mod.processing.noLoop()\n    });\n    \n    mod.frameRate = new Sk.builtin.func(function(fr) {\n        mod.processing.frameRate(fr.v)\n        \n    });\n\n    mod.size = new Sk.builtin.func(function(h,w) {\n        mod.processing.size(h.v,w.v)\n        \n    });\n\n    mod.exitp = new Sk.builtin.func(function(h,w) {\n        mod.processing.exit()\n    });\n\n\n    mod.mouseX = new Sk.builtin.func(function() {\n        return Sk.ffi.numberToIntPy(mod.processing.mouseX);\n        \n    });\n\n    mod.mouseY = new Sk.builtin.func(function() {\n        return Sk.ffi.numberToIntPy(mod.processing.mouseY);\n        \n    });\n\n    // Attributes\n    mod.rectMode = new Sk.builtin.func(function(mode) {\n        mod.processing.rectMode(mode.v)\n    });\n\n    mod.strokeWeight = new Sk.builtin.func(function(wt) {\n        mod.processing.strokeWeight(wt.v)\n        \n    });\n\n    mod.smooth = new Sk.builtin.func(function() {\n        mod.processing.smooth()\n    });\n\n    mod.noSmooth = new Sk.builtin.func(function() {\n        mod.processing.noSmooth()\n        });\n            \n    mod.ellipseMode = new Sk.builtin.func(function(mode) {\n        mod.processing.ellipseMode(mode.v)\n        });\n\n    mod.strokeCap = new Sk.builtin.func(function(mode) {\n        mod.processing.strokeCap(mode.v)\n        });\n\n    mod.strokeJoin = new Sk.builtin.func(function(mode) {\n        mod.processing.strokeJoin(mode.v)\n    });\n    \n\n\n    // Transforms\n\n    mod.rotate = new Sk.builtin.func(function(rads) {\n        // rotation in radians\n        mod.processing.rotate(rads.v)\n        \n    });\n\n    mod.scale = new Sk.builtin.func(function(sx, sy, sz) {\n        if (typeof(sy) == \'undefined\') {\n            sy = 1.0\n        } else \n            sy = sy.v\n        if (typeof(sz) == \'undefined\') {\n            sz = 1.0\n        } else\n            sz = sz.v\n        mod.processing.scale(sx.v, sy, sz)\n    });\n\n    mod.translate = new Sk.builtin.func(function(sx, sy, sz) {\n        if (typeof(sy) == \'undefined\') {\n            sy = 1.0\n        } else \n            sy = sy.v\n        if (typeof(sz) == \'undefined\') {\n            sz = 1.0\n        } else\n            sz = sz.v\n        mod.processing.translate(sx.v, sy, sz)\n    });\n\n    // todo:  applyMatrix, popMatrix, printMatrix??, pushMatrix, resetMatrix, rotate{X,Y,Z}\n    \n\n    //  //////////////////////////////////////////////////////////////////////\n    //  Run\n    // \n    //  Create the processing context and setup of calls to setup, draw etc.\n    //\n    //\n    //  //////////////////////////////////////////////////////////////////////    \n    mod.run = new Sk.builtin.func(function() {\n        function sketchProc(processing) {\n            mod.processing = processing\n\n            // processing.setup = function() {\n            //     if Sk.globals[\'setup\']\n            //         Sk.misceval.callsim(Sk.globals[\'setup\'])\n            // }\n\n            \n            processing.draw = function() {\n                // if there are pending image loads then just use the natural looping calls to \n                // retry until all the images are loaded.  If noLoop was called in setup then make\n                // sure to revert to that after all the images in hand.\n                var wait = false\n                for (var i in imList) {\n                    if (imList[i].width == 0) {\n                        wait = true\n                    }\n                }\n                if (wait == true) {\n                    if (looping == true) \n                        return\n                    else {\n                        processing.loop()\n                        return\n                    }\n\n                } else {\n                    if (looping == false)\n                        processing.noLoop()\n                }\n\n                mod.frameCount = processing.frameCount  \n                if (Sk.globals[\'draw\'])\n                    Sk.misceval.callsim(Sk.globals[\'draw\'])\n            }\n            \n            var callBacks = [\'setup\', \'mouseMoved\',\'mouseClicked\', \'mouseDragged\', \'mouseMoved\', \'mouseOut\',\n             \'mouseOver\', \'mousePressed\', \'mouseReleased\', \'keyPressed\', \'keyReleased\', \'keyTyped\'\n             ];\n\n             for(var cb in callBacks) {\n                if (Sk.globals[callBacks[cb]]) {\n                    console.log(\'defining \' + callBacks[cb])                    \n                    processing[callBacks[cb]] = new Function("Sk.misceval.callsim(Sk.globals[\'"+callBacks[cb]+"\']);")\n                }\n            }\n        }\n        \n        var canvas = document.getElementById(Sk.canvas)\n        $(canvas).show()\n        mod.p = new Processing(canvas, sketchProc)\n\n        \n    });\n\n    var mouseClass = function($gbl, $loc) {\n\n        $loc.__getattr__ = new Sk.builtin.func(function(self,key) {\n            if (key == \'x\') \n                return mod.processing.mouseX;\n            else if (key == \'y\') \n                return mod.processing.mouseY;\n            else if (key == \'px\')\n                return mod.processing.pmouseX;\n            else if (key == \'py\')\n                return mod.processing.pmouseY;\n            else if (key == \'pressed\')\n                return mod.processing.mousePressed;\n            else if (key == \'button\')\n                return mod.processing.mouseButton\n        });\n\n\n    }\n\n\n    mod.Mouse = Sk.misceval.buildClass(mod, mouseClass, \'Mouse\', []);\n\n    mod.mouse = Sk.misceval.callsim(mod.Mouse)\n\n    var keyboardClass = function($gbl, $loc) {\n\n        $loc.__getattr__ = new Sk.builtin.func(function(self,key) {\n            if (key == \'key\') {\n                console.log(mod.processing.key)\n                return Sk.builtin.stringToPy(mod.processing.key.toString())\n            }\n            else if (key == \'keyCode\') \n                return mod.processing.keyCode\n            else if (key == \'keyPressed\')\n                return new Sk.builtin.StringPy(mod.processing.keyPressed) // todo bool\n        });\n\n\n    }\n\n    mod.Keyboard = Sk.misceval.buildClass(mod,keyboardClass,\'Keyboard\', [])\n\n    mod.keyboard = Sk.misceval.callsim(mod.Keyboard)\n\n\n\n    var environmentClass = function($gbl, $loc) {\n\n        $loc.__getattr__ = new Sk.builtin.func(function(self,key) {\n            if (key == \'frameCount\') \n                return mod.processing.frameCount\n            else if (key == \'frameRate\') \n                return mod.processing.frameRate\n            else if (key == \'height\')\n                return mod.processing.height\n            else if (key == \'width\')\n                return mod.processing.width\n            else if (key == \'online\')\n                return mod.processing.online\n            else if (key == \'focused\')\n                return mod.processing.focused\n        });\n\n\n    }\n\n    mod.Environment = Sk.misceval.buildClass(mod,environmentClass,\'Environment\', [])\n\n    mod.environment = Sk.misceval.callsim(mod.Environment)\n\n    var screenClass = function($gbl, $loc) {\n\n        $loc.__init__ = new Sk.builtin.func(function(self) {\n            self.pixels = null;\n        });\n\n        $loc.__getattr__ = new Sk.builtin.func(function(self,key) {\n            if (key == \'height\')\n                return mod.processing.height\n            else if (key == \'width\')\n                return mod.processing.width\n            else if (key == \'pixels\')\n                if (self.pixels == null) {\n                    self.pixels = new Sk.builtin.list(mod.processing.pixels.toArray())\n                }\n                return self.pixels\n        });\n\n    }\n\n    mod.Screen = Sk.misceval.buildClass(mod,screenClass,\'Screen\', [])\n\n    mod.screen = Sk.misceval.callsim(mod.Screen)\n\n    mod.loadPixels = new Sk.builtin.func(function() {\n        mod.processing.loadPixels()\n        console.log(mod.processing.pixels)\n    });\n    \n\n    var colorClass = function($gbl, $loc) {\n        /* images are loaded async.. so its best to preload them */\n        $loc.__init__ = new Sk.builtin.func(function(self, val1, val2, val3, alpha) {\n            if (typeof(val2) !== \'undefined\')\n                val2 = val2.v\n            if (typeof(val3) !== \'undefined\')\n                val3 = val3.v\n            if (typeof(alpha) !== \'undefined\')\n                alpha = alpha.v\n            self.v = mod.processing.color(val1.v, val2, val3, alpha)\n        })\n    \n    }\n\n    mod.color = Sk.misceval.buildClass(mod,colorClass,\'color\', [])\n\n    mod.red = new Sk.builtin.func(function(clr) {\n        return Sk.ffi.numberToIntPy(mod.processing.red(clr.v));\n    });\n    \n    mod.green = new Sk.builtin.func(function(clr) {\n        return Sk.ffi.numberToIntPy(mod.processing.green(clr.v));\n    });\n\n    mod.blue = new Sk.builtin.func(function(clr) {\n        return Sk.ffi.numberToIntPy(mod.processing.blue(clr.v));\n    });\n\n    // Image class and functions\n    //\n    var imageClass = function($gbl, $loc) {\n        /* images are loaded async.. so its best to preload them */\n        $loc.__init__ = new Sk.builtin.func(function(self,im) {\n            self.v = im\n            self.width = Sk.ffi.numberToIntPy(im.width);\n            self.height = Sk.ffi.numberToIntPy(im.height);\n        })\n\n        $loc.__getattr__ = new Sk.builtin.func(function(self,key) {\n            if (key == \'width\') return self.v.width;\n            if (key == \'height\') return self.v.height;\n        });\n    \n    }\n\n    mod.PImage = Sk.misceval.buildClass(mod,imageClass,\'PImage\', [])\n\n    mod.loadImage = new Sk.builtin.func(function(imfile) {\n        var i = mod.processing.loadImage(imfile.v);\n        imList.push(i);\n        return Sk.misceval.callsim(mod.PImage,i);\n    });\n    \n\n    mod.image = new Sk.builtin.func(function(im,x,y) {\n        if (im.v.width > 0)\n            mod.processing.image(im.v,x.v,y.v,im.v.width,im.v.height)\n    });\n\n    mod.get = new Sk.builtin.func(function(x,y) {\n        var clr = mod.processing.get(x.v,y.v)\n        return Sk.misceval.callsim(mod.color,\n            Sk.ffi.numberToIntPy(mod.processing.red(clr)),\n            Sk.ffi.numberToIntPy(mod.processing.green(clr)),\n            Sk.ffi.numberToIntPy(mod.processing.blue(clr)));\n    });\n\n    mod.set = new Sk.builtin.func(function(x, y, color) {\n        mod.processing.set(x.v, y.v, color.v)\n    });\n    \n// todo  -- add a color class for creating color objects.\n\n\n    return mod;\n}\n',
    'src/lib/pythonds/trees/__init__.py': '\n# from .binaryTree import BinaryTree\n# from .balance import AVLTree\n# from .bst import BinarySearchTree\n# from .binheap import BinHeap\n\n\n',
    'src/lib/pythonds/trees/binaryTree.py': '# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005\n# \n\nclass BinaryTree:\n    """\n    A recursive implementation of Binary Tree\n    Using links and Nodes approach.\n    """    \n    def __init__(self,rootObj):\n        self.key = rootObj\n        self.leftChild = None\n        self.rightChild = None\n\n    def insertLeft(self,newNode):\n        if self.leftChild == None:\n            self.leftChild = BinaryTree(newNode)\n        else:\n            t = BinaryTree(newNode)\n            t.left = self.leftChild\n            self.leftChild = t\n    \n    def insertRight(self,newNode):\n        if self.rightChild == None:\n            self.rightChild = BinaryTree(newNode)\n        else:\n            t = BinaryTree(newNode)\n            t.right = self.rightChild\n            self.rightChild = t\n\n    def isLeaf(self):\n        return ((not self.leftChild) and (not self.rightChild))\n\n    def getRightChild(self):\n        return self.rightChild\n\n    def getLeftChild(self):\n        return self.leftChild\n\n    def setRootVal(self,obj):\n        self.key = obj\n\n    def getRootVal(self,):\n        return self.key\n\n    def inorder(self):\n        if self.leftChild:\n            self.leftChild.inorder()\n        print(self.key)\n        if self.rightChild:\n            self.rightChild.inorder()\n\n    def postorder(self):\n        if self.leftChild:\n            self.leftChild.postorder()\n        if self.rightChild:\n            self.rightChild.postorder()\n        print(self.key)\n\n\n    def preorder(self):\n        print(self.key)\n        if self.leftChild:\n            self.leftChild.preorder()\n        if self.rightChild:\n            self.rightChild.preorder()\n\n    def printexp(self):\n        if self.leftChild:\n            print(\'(\')\n            self.leftChild.printexp()\n        print(self.key)\n        if self.rightChild:\n            self.rightChild.printexp()\n            print(\')\')\n\n    def postordereval(self):\n        opers = {\'+\':operator.add, \'-\':operator.sub, \'*\':operator.mul, \'/\':operator.truediv}\n        res1 = None\n        res2 = None\n        if self.leftChild:\n            res1 = self.leftChild.postordereval()  #// \\label{peleft}\n        if self.rightChild:\n            res2 = self.rightChild.postordereval() #// \\label{peright}\n        if res1 and res2:\n            return opers[self.key](res1,res2) #// \\label{peeval}\n        else:\n            return self.key\n\ndef inorder(tree):\n    if tree != None:\n        inorder(tree.getLeftChild())\n        print(tree.getRootVal())\n        inorder(tree.getRightChild())\n\ndef printexp(tree):\n    if tree.leftChild:\n        print(\'(\')\n        printexp(tree.getLeftChild())\n    print(tree.getRootVal())\n    if tree.rightChild:\n        printexp(tree.getRightChild())\n        print(\')\') \n\ndef printexp(tree):\n    sVal = ""\n    if tree:\n        sVal = \'(\' + printexp(tree.getLeftChild())\n        sVal = sVal + str(tree.getRootVal())\n        sVal = sVal + printexp(tree.getRightChild()) + \')\'\n    return sVal\n\ndef postordereval(tree):\n    opers = {\'+\':operator.add, \'-\':operator.sub, \'*\':operator.mul, \'/\':operator.truediv}\n    res1 = None\n    res2 = None\n    if tree:\n        res1 = postordereval(tree.getLeftChild())  #// \\label{peleft}\n        res2 = postordereval(tree.getRightChild()) #// \\label{peright}\n        if res1 and res2:\n            return opers[tree.getRootVal()](res1,res2) #// \\label{peeval}\n        else:\n            return tree.getRootVal()\n\ndef height(tree):\n    if tree == None:\n        return -1\n    else:\n        return 1 + max(height(tree.leftChild),height(tree.rightChild))\n\n# t = BinaryTree(7)\n# t.insertLeft(3)\n# t.insertRight(9)\n# inorder(t)\n# import operator\n# x = BinaryTree(\'*\')\n# x.insertLeft(\'+\')\n# l = x.getLeftChild()\n# l.insertLeft(4)\n# l.insertRight(5)\n# x.insertRight(7)\n# print(printexp(x))\n# print(postordereval(x))\n# print(height(x))\n',
    'src/lib/math/__init__.js': 'var $builtinmodule = function(name) {\n  var mod = {};\n  Sk.builtin.defineMath(mod);\n  return mod;\n};',
    'src/lib/e3ga/__init__.js': 'var $builtinmodule = function(name) {\n  var mod = {};\n  Sk.builtin.defineEuclidean3(mod, THREE, BLADE);\n  return mod;\n}\n',
    'src/lib/re/__init__.js': 'var $builtinmodule = function(name)\n{\n    var mod = {};\n\n    // Constants (mostly unsupported)\n    mod.I = 2;\n    mod.IGNORECASE = 2;\n    // mod.L = 4;\n    // mod.LOCALE = 4;\n    mod.M = 8;\n    mod.MULTILINE = 8;\n    // mod.S = 16;\n    // mod.DOTALL = 16;\n    // mod.U = 32;\n    // mod.UNICODE = 32;\n    // mod.X = 64;\n    // mod.VERBOSE = 64;\n\n    var validGroups = ["(?:", "(?=", "(?!"];\n\n    var convert = function(pattern) {\n        var newpattern;\n        var match;\n        var i;\n\n        // Look for disallowed constructs\n        match = pattern.match(/\\(\\?./g);\n        if (match) {\n            for (i=0; i<match.length; i++) {\n                if (validGroups.indexOf(match[i]) == -1) {\n                    throw new Sk.builtin.ValueError("Disallowed group in pattern: \'"\n                                                    + match[i] + "\'");\n                };\n            };\n        };\n\n        newpattern = pattern.replace(\'/\\\\/g\', \'\\\\\\\\\');\n        newpattern = pattern.replace(/([^\\\\]){,(?![^\\[]*\\])/g, \'$1{0,\');\n\n        return newpattern;\n    };\n\n    var getFlags = function(flags) {\n        var jsflags = "g";\n        if ((flags & mod.IGNORECASE) == mod.IGNORECASE) {\n            jsflags += "i";\n        };\n        if ((flags & mod.MULTILINE) == mod.MULTILINE) {\n            jsflags += "m";\n        }; \n        return jsflags;\n    };\n\n    mod.split = Sk.nativejs.func(function split(pattern, string, maxsplit, flags) {\n        Sk.builtin.pyCheckArgs("split", arguments, 2, 4);\n        if (!Sk.builtin.isStringPy(pattern)) {\n            throw new Sk.builtin.TypeError("pattern must be a string");\n        };\n        if (!Sk.builtin.isStringPy(string)) {\n            throw new Sk.builtin.TypeError("string must be a string");\n        };\n        if (maxsplit === undefined) {\n            maxsplit = 0;\n        };\n        if (!Sk.builtin.checkNumber(maxsplit)) {\n            throw new Sk.builtin.TypeError("maxsplit must be a number");\n        };\n        if (flags === undefined) {\n            flags = 0;\n        };\n        if (!Sk.builtin.checkNumber(flags)) {\n            throw new Sk.builtin.TypeError("flags must be a number");\n        };\n\n    maxsplit = Sk.builtin.asnum$(maxsplit);\n        var pat = Sk.builtin.stringToJs(pattern);\n        var str = Sk.builtin.stringToJs(string);\n        \n        // Convert pat from Python to Javascript regex syntax\n        pat = convert(pat);\n        //print("Pat: " + pat);\n        //print("Str: " + str);\n\n        var captured = !(pat.match(/^\\(.*\\)$/) === null);\n        //print("Captured: ", captured);\n\n        var jsflags = getFlags(flags);\n        //print("Flags: ", jsflags);\n\n        var regex = new RegExp(pat, jsflags);\n\n        var result = [];\n        var match;\n        var index = 0;\n        var splits = 0;\n        while ((match = regex.exec(str)) != null)\n        {\n            //print("Matched \'" + match[0] + "\' at position " + match.index + \n            //      "; next search at " + regex.lastIndex);\n            if (match.index === regex.lastIndex)\n            {\n                // empty match\n                break;\n            };\n            result.push(Sk.builtin.stringToPy(str.substring(index, match.index)));\n            if (captured)\n            {\n                // Add matching pattern, too\n                result.push(Sk.builtin.stringToPy(match[0]));\n            };\n            index = regex.lastIndex;\n            splits += 1;\n            if (maxsplit && (splits >= maxsplit))\n            {\n                break;\n            };\n        };\n        result.push(Sk.builtin.stringToPy(str.substring(index)));\n\n        return new Sk.builtin.list(result);\n    });\n\n    mod.findall = Sk.nativejs.func(function findall(pattern, string, flags) {\n        Sk.builtin.pyCheckArgs("findall", arguments, 2, 3);\n        if (!Sk.builtin.isStringPy(pattern)) {\n            throw new Sk.builtin.TypeError("pattern must be a string");\n        };\n        if (!Sk.builtin.isStringPy(string)) {\n            throw new Sk.builtin.TypeError("string must be a string");\n        };\n        if (flags === undefined) {\n            flags = 0;\n        };\n        if (!Sk.builtin.checkNumber(flags)) {\n            throw new Sk.builtin.TypeError("flags must be a number");\n        };\n\n        var pat = Sk.builtin.stringToJs(pattern);\n        var str = Sk.builtin.stringToJs(string);\n        \n        // Convert pat from Python to Javascript regex syntax\n        pat = convert(pat);\n        //print("Pat: " + pat);\n        //print("Str: " + str);\n\n        var jsflags = getFlags(flags);\n        //print("Flags: ", jsflags);\n\n        var regex = new RegExp(pat, jsflags);\n\n    var newline_at_end = new RegExp(/\\n$/);\n    if (str.match(newline_at_end)) {\n        str = str.slice(0,-1);\n    }\n\n        var result = [];\n        var match;\n        while ((match = regex.exec(str)) != null)\n        {\n            //print("Matched \'" + match[0] + "\' at position " + match.index + \n            //      "; next search at " + regex.lastIndex);\n            // print("match: " + JSON.stringify(match));\n            if (match.length < 2)\n            {\n                result.push(Sk.builtin.stringToPy(match[0]));\n            }\n            else if (match.length === 2)\n            {\n                result.push(Sk.builtin.stringToPy(match[1]));\n            }\n            else\n            {\n                var groups = [];\n                for (var i=1; i<match.length; i++)\n                {\n                    groups.push(new Sk.builtin.StringPy(match[i]));  \n                };\n                result.push(new Sk.builtin.tuple(groups));\n            };\n            if (match.index === regex.lastIndex)\n            {\n                regex.lastIndex += 1;\n            };\n        };\n\n        return new Sk.builtin.list(result);\n    });\n\n\n    var matchobj = function($gbl, $loc) {\n        $loc.__init__ = new Sk.builtin.func(function(self,thematch, pattern, string) {\n            self.thematch = thematch;\n        self.re = pattern;\n        self.string = string;\n        });\n\n    $loc.groups = new Sk.builtin.func(function(self) {\n        return new Sk.builtin.tuple(self.thematch.v.slice(1))\n    });\n\n    $loc.group = new Sk.builtin.func(function(self,grpnum) {\n        if (grpnum === undefined) {\n                grpnum = 0;\n            }\n            else {\n                grpnum = Sk.builtin.asnum$(grpnum);\n            }\n        if(grpnum >= self.thematch.v.length) {\n        throw new Sk.builtin.IndexError("Index out of range: " + grpnum);\n        }\n        return self.thematch.v[grpnum]\n    });\n\n    }\n\n    mod.MatchObject = Sk.misceval.buildClass(mod, matchobj, \'MatchObject\', []);\n\n    // Internal function to return a Python list of strings \n    // From a JS regular expression string\n    mod._findre = function(res, string) {\n    res = res.replace(/([^\\\\]){,(?![^\\[]*\\])/g, \'$1{0,\');\n        var re = eval(res);\n    var patt = new RegExp(\'\\n$\');\n    if (string.v.match(patt))\n        var matches = string.v.slice(0,-1).match(re);\n    else\n            var matches = string.v.match(re);\n        retval = new Sk.builtin.list();\n        if ( matches == null ) return retval;\n        for (var i = 0; i < matches.length; ++i)\n        {\n            var sitem = Sk.builtin.stringToPy(matches[i]);\n            retval.v.push(sitem);\n        }\n        return retval;\n    }\n\n    mod.search = new Sk.builtin.func(function(pattern, string, flags) {\n    Sk.builtin.pyCheckArgs(\'search\', arguments, 2, 3);\n        if (!Sk.builtin.isStringPy(pattern))\n        {\n            throw new Sk.builtin.TypeError("pattern must be a string");\n        };\n        if (!Sk.builtin.isStringPy(string))\n        {\n            throw new Sk.builtin.TypeError("string must be a string");\n        };\n        if (flags === undefined)\n        {\n            flags = 0;\n        };\n        if (!Sk.builtin.checkNumber(flags))\n        {\n            throw new Sk.builtin.TypeError("flags must be a number");\n        };\n        var res = "/" + Sk.builtin.stringToJs(pattern).replace(/\\//g,"\\\\/")+"/";\n        lst = mod._findre(res, string);\n        if ( lst.v.length < 1 ) return Sk.builtin.none.none$;\n        var mob = Sk.misceval.callsim(mod.MatchObject, lst, pattern, string);\n        return mob;\n    });\n\n    mod.match = new Sk.builtin.func(function(pattern, string, flags) {\n    Sk.builtin.pyCheckArgs(\'match\', arguments, 2, 3);\n        if (!Sk.builtin.isStringPy(pattern))\n        {\n            throw new Sk.builtin.TypeError("pattern must be a string");\n        };\n        if (!Sk.builtin.isStringPy(string))\n        {\n            throw new Sk.builtin.TypeError("string must be a string");\n        };\n        if (flags === undefined)\n        {\n            flags = 0;\n        };\n        if (!Sk.builtin.checkNumber(flags))\n        {\n            throw new Sk.builtin.TypeError("flags must be a number");\n        };\n        var res = "/^" + Sk.builtin.stringToJs(pattern).replace(/\\//g,"\\\\/")+"/";\n        lst = mod._findre(res,string);\n        if ( lst.v.length < 1 ) return Sk.builtin.none.none$;\n        var mob = Sk.misceval.callsim(mod.MatchObject, lst, pattern, string);\n        return mob;\n    });\n\n    return mod;\n}\n',
    'src/lib/urllib/__init__.js': 'var $builtinmodule = function(name)\n{\n  var mod = {};\n  Sk.builtin.defineUrlLib(mod);\n  return mod;\n};\n',
    'src/lib/random/__init__.js': '\n/*\n  I\'ve wrapped Makoto Matsumoto and Takuji Nishimura\'s code in a namespace\n  so it\'s better encapsulated. Now you can have multiple random number generators\n  and they won\'t stomp all over eachother\'s state.\n  \n  If you want to use this as a substitute for Math.random(), use the random()\n  method like so:\n  \n  var m = new MersenneTwister();\n  var randomNumber = m.random();\n  \n  You can also call the other genrand_{foo}() methods on the instance.\n\n  If you want to use a specific seed in order to get a repeatable random\n  sequence, pass an integer into the constructor:\n\n  var m = new MersenneTwister(123);\n\n  and that will always produce the same random sequence.\n\n  Sean McCullough (banksean@gmail.com)\n*/\n\n/* \n   A C-program for MT19937, with initialization improved 2002/1/26.\n   Coded by Takuji Nishimura and Makoto Matsumoto.\n \n   Before using, initialize the state by using init_genrand(seed)  \n   or init_by_array(init_key, key_length).\n \n   Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,\n   All rights reserved.                          \n \n   Redistribution and use in source and binary forms, with or without\n   modification, are permitted provided that the following conditions\n   are met:\n \n     1. Redistributions of source code must retain the above copyright\n        notice, this list of conditions and the following disclaimer.\n \n     2. Redistributions in binary form must reproduce the above copyright\n        notice, this list of conditions and the following disclaimer in the\n        documentation and/or other materials provided with the distribution.\n \n     3. The names of its contributors may not be used to endorse or promote \n        products derived from this software without specific prior written \n        permission.\n \n   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n   A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n \n \n   Any feedback is very welcome.\n   http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html\n   email: m-mat @ math.sci.hiroshima-u.ac.jp (remove space)\n*/\n\nvar MersenneTwister = function(seed) {\n  if (seed == undefined) {\n    seed = new Date().getTime();\n  }\n  /* Period parameters */\n  this.N = 624;\n  this.M = 397;\n  this.MATRIX_A = 0x9908b0df;   /* constant vector a */\n  this.UPPER_MASK = 0x80000000; /* most significant w-r bits */\n  this.LOWER_MASK = 0x7fffffff; /* least significant r bits */\n \n  this.mt = new Array(this.N); /* the array for the state vector */\n  this.mti=this.N+1; /* mti==N+1 means mt[N] is not initialized */\n\n  this.init_genrand(seed);\n};\n \n/* initializes mt[N] with a seed */\nMersenneTwister.prototype.init_genrand = function(s) {\n  this.mt[0] = s >>> 0;\n  for (this.mti=1; this.mti<this.N; this.mti++) {\n      var s = this.mt[this.mti-1] ^ (this.mt[this.mti-1] >>> 30);\n   this.mt[this.mti] = (((((s & 0xffff0000) >>> 16) * 1812433253) << 16) + (s & 0x0000ffff) * 1812433253)\n  + this.mti;\n      /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */\n      /* In the previous versions, MSBs of the seed affect   */\n      /* only MSBs of the array mt[].                        */\n      /* 2002/01/09 modified by Makoto Matsumoto             */\n      this.mt[this.mti] >>>= 0;\n      /* for >32 bit machines */\n  }\n};\n\n/* initialize by an array with array-length */\n/* init_key is the array for initializing keys */\n/* key_length is its length */\n/* slight change for C++, 2004/2/26 */\nMersenneTwister.prototype.init_by_array = function(init_key, key_length) {\n  var i, j, k;\n  this.init_genrand(19650218);\n  i=1; j=0;\n  k = (this.N>key_length ? this.N : key_length);\n  for (; k; k--) {\n    var s = this.mt[i-1] ^ (this.mt[i-1] >>> 30)\n    this.mt[i] = (this.mt[i] ^ (((((s & 0xffff0000) >>> 16) * 1664525) << 16) + ((s & 0x0000ffff) * 1664525)))\n      + init_key[j] + j; /* non linear */\n    this.mt[i] >>>= 0; /* for WORDSIZE > 32 machines */\n    i++; j++;\n    if (i>=this.N) { this.mt[0] = this.mt[this.N-1]; i=1; }\n    if (j>=key_length) j=0;\n  }\n  for (k=this.N-1; k; k--) {\n    var s = this.mt[i-1] ^ (this.mt[i-1] >>> 30);\n    this.mt[i] = (this.mt[i] ^ (((((s & 0xffff0000) >>> 16) * 1566083941) << 16) + (s & 0x0000ffff) * 1566083941))\n      - i; /* non linear */\n    this.mt[i] >>>= 0; /* for WORDSIZE > 32 machines */\n    i++;\n    if (i>=this.N) { this.mt[0] = this.mt[this.N-1]; i=1; }\n  }\n\n  this.mt[0] = 0x80000000; /* MSB is 1; assuring non-zero initial array */ \n};\n\n/* generates a random number on [0,0xffffffff]-interval */\nMersenneTwister.prototype.genrand_int32 = function() {\n  var y;\n  var mag01 = new Array(0x0, this.MATRIX_A);\n  /* mag01[x] = x * MATRIX_A  for x=0,1 */\n\n  if (this.mti >= this.N) { /* generate N words at one time */\n    var kk;\n\n    if (this.mti == this.N+1)   /* if init_genrand() has not been called, */\n      this.init_genrand(5489); /* a default initial seed is used */\n\n    for (kk=0;kk<this.N-this.M;kk++) {\n      y = (this.mt[kk]&this.UPPER_MASK)|(this.mt[kk+1]&this.LOWER_MASK);\n      this.mt[kk] = this.mt[kk+this.M] ^ (y >>> 1) ^ mag01[y & 0x1];\n    }\n    for (;kk<this.N-1;kk++) {\n      y = (this.mt[kk]&this.UPPER_MASK)|(this.mt[kk+1]&this.LOWER_MASK);\n      this.mt[kk] = this.mt[kk+(this.M-this.N)] ^ (y >>> 1) ^ mag01[y & 0x1];\n    }\n    y = (this.mt[this.N-1]&this.UPPER_MASK)|(this.mt[0]&this.LOWER_MASK);\n    this.mt[this.N-1] = this.mt[this.M-1] ^ (y >>> 1) ^ mag01[y & 0x1];\n\n    this.mti = 0;\n  }\n\n  y = this.mt[this.mti++];\n\n  /* Tempering */\n  y ^= (y >>> 11);\n  y ^= (y << 7) & 0x9d2c5680;\n  y ^= (y << 15) & 0xefc60000;\n  y ^= (y >>> 18);\n\n  return y >>> 0;\n};\n\n/* generates a random number on [0,0x7fffffff]-interval */\nMersenneTwister.prototype.genrand_int31 = function() {\n  return (this.genrand_int32()>>>1);\n};\n\n/* generates a random number on [0,1]-real-interval */\nMersenneTwister.prototype.genrand_real1 = function() {\n  return this.genrand_int32()*(1.0/4294967295.0);\n  /* divided by 2^32-1 */\n};\n\n/* generates a random number on [0,1)-real-interval */\nMersenneTwister.prototype.random = function() {\n  return this.genrand_int32()*(1.0/4294967296.0); \n  /* divided by 2^32 */\n};\n\n/* generates a random number on (0,1)-real-interval */\nMersenneTwister.prototype.genrand_real3 = function() {\n  return (this.genrand_int32() + 0.5)*(1.0/4294967296.0);\n  /* divided by 2^32 */\n};\n\n/* generates a random number on [0,1) with 53-bit resolution*/\nMersenneTwister.prototype.genrand_res53 = function() {\n  var a=this.genrand_int32()>>>5, b=this.genrand_int32()>>>6;\n  return(a*67108864.0+b)*(1.0/9007199254740992.0);\n};\n\n/* These real versions are due to Isaku Wada, 2002/01/09 added */\n\nvar $builtinmodule = function(name) {\n\n  var mod = {};\n\n  var myGenerator = new MersenneTwister();\n\n  mod.seed = new Sk.builtin.func(function(x) {\n    Sk.builtin.pyCheckArgs("seed", arguments, 0, 1);\n    x = Sk.builtin.asnum$(x);\n\n    if (arguments.length > 0)\n      myGenerator = new MersenneTwister(x);\n    else\n      myGenerator = new MersenneTwister();\n    return Sk.builtin.none.none$;\n  });\n\n  mod.random = new Sk.builtin.func(function() {\n    Sk.builtin.pyCheckArgs("random", arguments, 0, 0);\n    return Sk.builtin.numberToPy(myGenerator.genrand_res53());\n  });\n\n  var toInt = function(num) {\n    return num | 0;\n  };\n\n  var randrange = function(start, stop, step)\n  {\n    // Ported from CPython 2.7\n    var width, n, ret;\n\n    if (!Sk.builtin.checkInt(start))\n    {\n      throw new Sk.builtin.ValueError("non-integer first argument for randrange()");\n    };\n\n    if (stop === undefined)\n    {\n      // Random in [0, start)\n      return toInt(myGenerator.genrand_res53() * start);\n    };\n\n    if (!Sk.builtin.checkInt(stop)) {\n      throw new Sk.builtin.ValueError("non-integer stop for randrange()");\n    };\n\n    if (step === undefined)\n    {\n      step = 1;\n    };\n\n    width = stop - start;\n\n    if ((step == 1) && (width > 0))\n    {\n      // Random in [start, stop), must use toInt on product for correct results with negative ranges\n      ret = start + toInt(myGenerator.genrand_res53() * width);\n      return Sk.ffi.numberToIntPy(ret);\n    };\n\n    if (step == 1)\n    {\n      throw new Sk.builtin.ValueError("empty range for randrange() (" + start + ", " + stop + ", " + width + ")");\n    };\n\n    if (!Sk.builtin.checkInt(step))\n    {\n      throw new Sk.builtin.ValueError("non-integer step for randrange()");\n    };\n\n    if (step > 0) {\n      n = toInt((width + step - 1) / step);\n    } else if (step < 0) {\n      n = toInt((width + step + 1) / step);\n    } else {\n      throw new Sk.builtin.ValueError("zero step for randrange()");\n    };\n\n    if (n <= 0) {\n      throw new Sk.builtin.ValueError("empty range for randrange()");\n    };\n\n    // Random in range(start, stop, step)\n    ret = start + (step * toInt(myGenerator.genrand_res53() * n));\n    return Sk.ffi.numberToIntPy(ret);\n  };\n\n  mod.randint = new Sk.builtin.func(function(a, b) {\n    Sk.builtin.pyCheckArgs("randint", arguments, 2, 2);\n\n    a = Sk.builtin.asnum$(a);\n    b = Sk.builtin.asnum$(b);\n    return randrange(a, b+1);\n  });\n\n  mod.randrange = new Sk.builtin.func(function(start, stop, step) {\n    Sk.builtin.pyCheckArgs("randrange", arguments, 1, 3);\n\n    start = Sk.builtin.asnum$(start);\n    stop = Sk.builtin.asnum$(stop);\n    step = Sk.builtin.asnum$(step);\n    return randrange(start, stop, step);\n  });\n\n  mod.choice = new Sk.builtin.func(function(seq) {\n    Sk.builtin.pyCheckArgs("choice", arguments, 1, 1);\n    Sk.builtin.pyCheckType("seq", "sequence", Sk.builtin.checkSequence(seq));\n\n    if (seq.sq$length !== undefined) {\n      var r = toInt(myGenerator.genrand_res53() * seq.sq$length());\n      return seq.mp$subscript(r);\n    }\n    else {\n      throw new Sk.builtin.TypeError("object has no length");\n    }\n  });\n\n  mod.shuffle = new Sk.builtin.func(function(x) {\n    Sk.builtin.pyCheckArgs("shuffle", arguments, 1, 1);\n    Sk.builtin.pyCheckType("x", "sequence", Sk.builtin.checkSequence(x));\n\n    if (x.sq$length !== undefined) {\n      if (x.mp$ass_subscript !== undefined) {\n        for (var i = x.sq$length() - 1; i > 0; i -= 1) {\n            var r = toInt(myGenerator.genrand_res53() * (i + 1));\n            var tmp = x.mp$subscript(r);\n            x.mp$ass_subscript(r, x.mp$subscript(i));\n            x.mp$ass_subscript(i, tmp);\n        };\n      }\n      else {\n        throw new Sk.builtin.TypeError("object is immutable");\n      };\n    }\n    else {\n      throw new Sk.builtin.TypeError("object has no length");\n    }\n    return Sk.builtin.none.none$;\n  });\n\n  mod[\'uniform\'] = new Sk.builtin.func(function(minPy, maxPy) {\n    Sk.ffi.checkFunctionArgs("uniform", arguments, 2, 2);\n    Sk.ffi.checkArgType("min", [Sk.ffi.PyType.FLOAT], Sk.ffi.isNum(minPy), minPy);\n    Sk.ffi.checkArgType("max", [Sk.ffi.PyType.FLOAT], Sk.ffi.isNum(maxPy), maxPy);\n    var min = Sk.ffi.remapToJs(minPy);\n    var max = Sk.ffi.remapToJs(maxPy);\n    var x = myGenerator.genrand_res53();\n    var y = x * (max - min) + min;\n    return Sk.ffi.numberToFloatPy(y);\n  });\n\n  return mod;\n};',
    'src/lib/symbolic/__init__.js': 'var $builtinmodule = function(name) {\n  var mod = {};\n  Sk.builtin.defineSymbolic(mod, "symbolic");\n  return mod;\n};\n',
    'src/builtin/this.py': 's = """Gur Mra bs Clguba, ol Gvz Crgref\n\nOrnhgvshy vf orggre guna htyl.\nRkcyvpvg vf orggre guna vzcyvpvg.\nFvzcyr vf orggre guna pbzcyrk.\nPbzcyrk vf orggre guna pbzcyvpngrq.\nSyng vf orggre guna arfgrq.\nFcnefr vf orggre guna qrafr.\nErnqnovyvgl pbhagf.\nFcrpvny pnfrf nera\'g fcrpvny rabhtu gb oernx gur ehyrf.\nNygubhtu cenpgvpnyvgl orngf chevgl.\nReebef fubhyq arire cnff fvyragyl.\nHayrff rkcyvpvgyl fvyraprq.\nVa gur snpr bs nzovthvgl, ershfr gur grzcgngvba gb thrff.\nGurer fubhyq or bar-- naq cersrenoyl bayl bar --boivbhf jnl gb qb vg.\nNygubhtu gung jnl znl abg or boivbhf ng svefg hayrff lbh\'er Qhgpu.\nAbj vf orggre guna arire.\nNygubhtu arire vf bsgra orggre guna *evtug* abj.\nVs gur vzcyrzragngvba vf uneq gb rkcynva, vg\'f n onq vqrn.\nVs gur vzcyrzragngvba vf rnfl gb rkcynva, vg znl or n tbbq vqrn.\nAnzrfcnprf ner bar ubaxvat terng vqrn -- yrg\'f qb zber bs gubfr!"""\n\nd = {}\nfor c in (65, 97):\n    for i in range(26):\n        d[chr(i+c)] = chr((i+13) % 26 + c)\n\nprint "".join([d.get(c, c) for c in s])\n',
    'src/lib/e2ga/__init__.js': 'var $builtinmodule = function(name) {\n  var mod = {};\n  Sk.builtin.defineEuclidean2(mod, BLADE);\n  return mod;\n}\n'
  }
};
!function ($) {
  'use strict';
  var Carousel = function (element, options) {
    this.$element = $(element);
    this.$indicators = this.$element.find('.carousel-indicators');
    this.options = options;
    this.options.pause == 'hover' && this.$element.on('mouseenter', $.proxy(this.pause, this)).on('mouseleave', $.proxy(this.cycle, this));
  };
  Carousel.prototype = {
    cycle: function (e) {
      if (!e)
        this.paused = false;
      if (this.interval)
        clearInterval(this.interval);
      this.options.interval && !this.paused && (this.interval = setInterval($.proxy(this.next, this), this.options.interval));
      return this;
    },
    getActiveIndex: function () {
      this.$active = this.$element.find('.item.active');
      this.$items = this.$active.parent().children();
      return this.$items.index(this.$active);
    },
    to: function (pos) {
      var activeIndex = this.getActiveIndex(), that = this;
      if (pos > this.$items.length - 1 || pos < 0)
        return;
      if (this.sliding) {
        return this.$element.one('slid', function () {
          that.to(pos);
        });
      }
      if (activeIndex == pos) {
        return this.pause().cycle();
      }
      return this.slide(pos > activeIndex ? 'next' : 'prev', $(this.$items[pos]));
    },
    pause: function (e) {
      if (!e)
        this.paused = true;
      if (this.$element.find('.next, .prev').length && $.support.transition.end) {
        this.$element.trigger($.support.transition.end);
        this.cycle(true);
      }
      clearInterval(this.interval);
      this.interval = null;
      return this;
    },
    next: function () {
      if (this.sliding)
        return;
      return this.slide('next');
    },
    prev: function () {
      if (this.sliding)
        return;
      return this.slide('prev');
    },
    slide: function (type, next) {
      var $active = this.$element.find('.item.active'), $next = next || $active[type](), isCycling = this.interval, direction = type == 'next' ? 'left' : 'right', fallback = type == 'next' ? 'first' : 'last', that = this, e;
      this.sliding = true;
      isCycling && this.pause();
      $next = $next.length ? $next : this.$element.find('.item')[fallback]();
      e = $.Event('slide', {
        relatedTarget: $next[0],
        direction: direction
      });
      if ($next.hasClass('active'))
        return;
      if (this.$indicators.length) {
        this.$indicators.find('.active').removeClass('active');
        this.$element.one('slid', function () {
          var $nextIndicator = $(that.$indicators.children()[that.getActiveIndex()]);
          $nextIndicator && $nextIndicator.addClass('active');
        });
      }
      if ($.support.transition && this.$element.hasClass('slide')) {
        this.$element.trigger(e);
        if (e.isDefaultPrevented())
          return;
        $next.addClass(type);
        $next[0].offsetWidth;
        $active.addClass(direction);
        $next.addClass(direction);
        this.$element.one($.support.transition.end, function () {
          $next.removeClass([
            type,
            direction
          ].join(' ')).addClass('active');
          $active.removeClass([
            'active',
            direction
          ].join(' '));
          that.sliding = false;
          setTimeout(function () {
            that.$element.trigger('slid');
          }, 0);
        });
      } else {
        this.$element.trigger(e);
        if (e.isDefaultPrevented())
          return;
        $active.removeClass('active');
        $next.addClass('active');
        this.sliding = false;
        this.$element.trigger('slid');
      }
      isCycling && this.cycle();
      return this;
    }
  };
  var old = $.fn.carousel;
  $.fn.carousel = function (option) {
    return this.each(function () {
      var $this = $(this), data = $this.data('carousel'), options = $.extend({}, $.fn.carousel.defaults, typeof option == 'object' && option), action = typeof option == 'string' ? option : options.slide;
      if (!data)
        $this.data('carousel', data = new Carousel(this, options));
      if (typeof option == 'number')
        data.to(option);
      else if (action)
        data[action]();
      else if (options.interval)
        data.pause().cycle();
    });
  };
  $.fn.carousel.defaults = {
    interval: 5000,
    pause: 'hover'
  };
  $.fn.carousel.Constructor = Carousel;
  $.fn.carousel.noConflict = function () {
    $.fn.carousel = old;
    return this;
  };
  $(document).on('click.carousel.data-api', '[data-slide], [data-slide-to]', function (e) {
    var $this = $(this), href, $target = $($this.attr('data-target') || (href = $this.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '')), options = $.extend({}, $target.data(), $this.data()), slideIndex;
    $target.carousel(options);
    if (slideIndex = $this.attr('data-slide-to')) {
      $target.data('carousel').pause().to(slideIndex).cycle();
    }
    e.preventDefault();
  });
}(window.jQuery);
!function ($) {
  'use strict';
  var Collapse = function (element, options) {
    this.$element = $(element);
    this.options = $.extend({}, $.fn.collapse.defaults, options);
    if (this.options.parent) {
      this.$parent = $(this.options.parent);
    }
    this.options.toggle && this.toggle();
  };
  Collapse.prototype = {
    constructor: Collapse,
    dimension: function () {
      var hasWidth = this.$element.hasClass('width');
      return hasWidth ? 'width' : 'height';
    },
    show: function () {
      var dimension, scroll, actives, hasData;
      if (this.transitioning || this.$element.hasClass('in'))
        return;
      dimension = this.dimension();
      scroll = $.camelCase([
        'scroll',
        dimension
      ].join('-'));
      actives = this.$parent && this.$parent.find('> .accordion-group > .in');
      if (actives && actives.length) {
        hasData = actives.data('collapse');
        if (hasData && hasData.transitioning)
          return;
        actives.collapse('hide');
        hasData || actives.data('collapse', null);
      }
      this.$element[dimension](0);
      this.transition('addClass', $.Event('show'), 'shown');
      $.support.transition && this.$element[dimension](this.$element[0][scroll]);
    },
    hide: function () {
      var dimension;
      if (this.transitioning || !this.$element.hasClass('in'))
        return;
      dimension = this.dimension();
      this.reset(this.$element[dimension]());
      this.transition('removeClass', $.Event('hide'), 'hidden');
      this.$element[dimension](0);
    },
    reset: function (size) {
      var dimension = this.dimension();
      this.$element.removeClass('collapse')[dimension](size || 'auto')[0].offsetWidth;
      this.$element[size !== null ? 'addClass' : 'removeClass']('collapse');
      return this;
    },
    transition: function (method, startEvent, completeEvent) {
      var that = this, complete = function () {
          if (startEvent.type == 'show')
            that.reset();
          that.transitioning = 0;
          that.$element.trigger(completeEvent);
        };
      this.$element.trigger(startEvent);
      if (startEvent.isDefaultPrevented())
        return;
      this.transitioning = 1;
      this.$element[method]('in');
      $.support.transition && this.$element.hasClass('collapse') ? this.$element.one($.support.transition.end, complete) : complete();
    },
    toggle: function () {
      this[this.$element.hasClass('in') ? 'hide' : 'show']();
    }
  };
  var old = $.fn.collapse;
  $.fn.collapse = function (option) {
    return this.each(function () {
      var $this = $(this), data = $this.data('collapse'), options = $.extend({}, $.fn.collapse.defaults, $this.data(), typeof option == 'object' && option);
      if (!data)
        $this.data('collapse', data = new Collapse(this, options));
      if (typeof option == 'string')
        data[option]();
    });
  };
  $.fn.collapse.defaults = { toggle: true };
  $.fn.collapse.Constructor = Collapse;
  $.fn.collapse.noConflict = function () {
    $.fn.collapse = old;
    return this;
  };
  $(document).on('click.collapse.data-api', '[data-toggle=collapse]', function (e) {
    var $this = $(this), href, target = $this.attr('data-target') || e.preventDefault() || (href = $this.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, ''), option = $(target).data('collapse') ? 'toggle' : $this.data();
    $this[$(target).hasClass('in') ? 'addClass' : 'removeClass']('collapsed');
    $(target).collapse(option);
  });
}(window.jQuery);
!function ($) {
  'use strict';
  var toggle = '[data-toggle=dropdown]', Dropdown = function (element) {
      var $el = $(element).on('click.dropdown.data-api', this.toggle);
      $('html').on('click.dropdown.data-api', function () {
        $el.parent().removeClass('open');
      });
    };
  Dropdown.prototype = {
    constructor: Dropdown,
    toggle: function (e) {
      var $this = $(this), $parent, isActive;
      if ($this.is('.disabled, :disabled'))
        return;
      $parent = getParent($this);
      isActive = $parent.hasClass('open');
      clearMenus();
      if (!isActive) {
        if ('ontouchstart' in document.documentElement) {
          $('<div class="dropdown-backdrop"/>').insertBefore($(this)).on('click', clearMenus);
        }
        $parent.toggleClass('open');
      }
      $this.focus();
      return false;
    },
    keydown: function (e) {
      var $this, $items, $active, $parent, isActive, index;
      if (!/(38|40|27)/.test(e.keyCode))
        return;
      $this = $(this);
      e.preventDefault();
      e.stopPropagation();
      if ($this.is('.disabled, :disabled'))
        return;
      $parent = getParent($this);
      isActive = $parent.hasClass('open');
      if (!isActive || isActive && e.keyCode == 27) {
        if (e.which == 27)
          $parent.find(toggle).focus();
        return $this.click();
      }
      $items = $('[role=menu] li:not(.divider):visible a', $parent);
      if (!$items.length)
        return;
      index = $items.index($items.filter(':focus'));
      if (e.keyCode == 38 && index > 0)
        index--;
      if (e.keyCode == 40 && index < $items.length - 1)
        index++;
      if (!~index)
        index = 0;
      $items.eq(index).focus();
    }
  };
  function clearMenus() {
    $('.dropdown-backdrop').remove();
    $(toggle).each(function () {
      getParent($(this)).removeClass('open');
    });
  }
  function getParent($this) {
    var selector = $this.attr('data-target'), $parent;
    if (!selector) {
      selector = $this.attr('href');
      selector = selector && /#/.test(selector) && selector.replace(/.*(?=#[^\s]*$)/, '');
    }
    $parent = selector && $(selector);
    if (!$parent || !$parent.length)
      $parent = $this.parent();
    return $parent;
  }
  var old = $.fn.dropdown;
  $.fn.dropdown = function (option) {
    return this.each(function () {
      var $this = $(this), data = $this.data('dropdown');
      if (!data)
        $this.data('dropdown', data = new Dropdown(this));
      if (typeof option == 'string')
        data[option].call($this);
    });
  };
  $.fn.dropdown.Constructor = Dropdown;
  $.fn.dropdown.noConflict = function () {
    $.fn.dropdown = old;
    return this;
  };
  $(document).on('click.dropdown.data-api', clearMenus).on('click.dropdown.data-api', '.dropdown form', function (e) {
    e.stopPropagation();
  }).on('click.dropdown.data-api', toggle, Dropdown.prototype.toggle).on('keydown.dropdown.data-api', toggle + ', [role=menu]', Dropdown.prototype.keydown);
}(window.jQuery);
!function ($) {
  'use strict';
  var Modal = function (element, options) {
    this.options = options;
    this.$element = $(element).delegate('[data-dismiss="modal"]', 'click.dismiss.modal', $.proxy(this.hide, this));
    this.options.remote && this.$element.find('.modal-body').load(this.options.remote);
  };
  Modal.prototype = {
    constructor: Modal,
    toggle: function () {
      return this[!this.isShown ? 'show' : 'hide']();
    },
    show: function () {
      var that = this, e = $.Event('show');
      this.$element.trigger(e);
      if (this.isShown || e.isDefaultPrevented())
        return;
      this.isShown = true;
      this.escape();
      this.backdrop(function () {
        var transition = $.support.transition && that.$element.hasClass('fade');
        if (!that.$element.parent().length) {
          that.$element.appendTo(document.body);
        }
        that.$element.show();
        if (transition) {
          that.$element[0].offsetWidth;
        }
        that.$element.addClass('in').attr('aria-hidden', false);
        that.enforceFocus();
        transition ? that.$element.one($.support.transition.end, function () {
          that.$element.focus().trigger('shown');
        }) : that.$element.focus().trigger('shown');
      });
    },
    hide: function (e) {
      e && e.preventDefault();
      var that = this;
      e = $.Event('hide');
      this.$element.trigger(e);
      if (!this.isShown || e.isDefaultPrevented())
        return;
      this.isShown = false;
      this.escape();
      $(document).off('focusin.modal');
      this.$element.removeClass('in').attr('aria-hidden', true);
      $.support.transition && this.$element.hasClass('fade') ? this.hideWithTransition() : this.hideModal();
    },
    enforceFocus: function () {
      var that = this;
      $(document).on('focusin.modal', function (e) {
        if (that.$element[0] !== e.target && !that.$element.has(e.target).length) {
          that.$element.focus();
        }
      });
    },
    escape: function () {
      var that = this;
      if (this.isShown && this.options.keyboard) {
        this.$element.on('keyup.dismiss.modal', function (e) {
          e.which == 27 && that.hide();
        });
      } else if (!this.isShown) {
        this.$element.off('keyup.dismiss.modal');
      }
    },
    hideWithTransition: function () {
      var that = this, timeout = setTimeout(function () {
          that.$element.off($.support.transition.end);
          that.hideModal();
        }, 500);
      this.$element.one($.support.transition.end, function () {
        clearTimeout(timeout);
        that.hideModal();
      });
    },
    hideModal: function () {
      var that = this;
      this.$element.hide();
      this.backdrop(function () {
        that.removeBackdrop();
        that.$element.trigger('hidden');
      });
    },
    removeBackdrop: function () {
      this.$backdrop && this.$backdrop.remove();
      this.$backdrop = null;
    },
    backdrop: function (callback) {
      var that = this, animate = this.$element.hasClass('fade') ? 'fade' : '';
      if (this.isShown && this.options.backdrop) {
        var doAnimate = $.support.transition && animate;
        this.$backdrop = $('<div class="modal-backdrop ' + animate + '" />').appendTo(document.body);
        this.$backdrop.click(this.options.backdrop == 'static' ? $.proxy(this.$element[0].focus, this.$element[0]) : $.proxy(this.hide, this));
        if (doAnimate)
          this.$backdrop[0].offsetWidth;
        this.$backdrop.addClass('in');
        if (!callback)
          return;
        doAnimate ? this.$backdrop.one($.support.transition.end, callback) : callback();
      } else if (!this.isShown && this.$backdrop) {
        this.$backdrop.removeClass('in');
        $.support.transition && this.$element.hasClass('fade') ? this.$backdrop.one($.support.transition.end, callback) : callback();
      } else if (callback) {
        callback();
      }
    }
  };
  var old = $.fn.modal;
  $.fn.modal = function (option) {
    return this.each(function () {
      var $this = $(this), data = $this.data('modal'), options = $.extend({}, $.fn.modal.defaults, $this.data(), typeof option == 'object' && option);
      if (!data)
        $this.data('modal', data = new Modal(this, options));
      if (typeof option == 'string')
        data[option]();
      else if (options.show)
        data.show();
    });
  };
  $.fn.modal.defaults = {
    backdrop: true,
    keyboard: true,
    show: true
  };
  $.fn.modal.Constructor = Modal;
  $.fn.modal.noConflict = function () {
    $.fn.modal = old;
    return this;
  };
  $(document).on('click.modal.data-api', '[data-toggle="modal"]', function (e) {
    var $this = $(this), href = $this.attr('href'), $target = $($this.attr('data-target') || href && href.replace(/.*(?=#[^\s]+$)/, '')), option = $target.data('modal') ? 'toggle' : $.extend({ remote: !/#/.test(href) && href }, $target.data(), $this.data());
    e.preventDefault();
    $target.modal(option).one('hide', function () {
      $this.focus();
    });
  });
}(window.jQuery);
!function ($) {
  'use strict';
  var Tab = function (element) {
    this.element = $(element);
  };
  Tab.prototype = {
    constructor: Tab,
    show: function () {
      var $this = this.element, $ul = $this.closest('ul:not(.dropdown-menu)'), selector = $this.attr('data-target'), previous, $target, e;
      if (!selector) {
        selector = $this.attr('href');
        selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '');
      }
      if ($this.parent('li').hasClass('active'))
        return;
      previous = $ul.find('.active:last a')[0];
      e = $.Event('show', { relatedTarget: previous });
      $this.trigger(e);
      if (e.isDefaultPrevented())
        return;
      $target = $(selector);
      this.activate($this.parent('li'), $ul);
      this.activate($target, $target.parent(), function () {
        $this.trigger({
          type: 'shown',
          relatedTarget: previous
        });
      });
    },
    activate: function (element, container, callback) {
      var $active = container.find('> .active'), transition = callback && $.support.transition && $active.hasClass('fade');
      function next() {
        $active.removeClass('active').find('> .dropdown-menu > .active').removeClass('active');
        element.addClass('active');
        if (transition) {
          element[0].offsetWidth;
          element.addClass('in');
        } else {
          element.removeClass('fade');
        }
        if (element.parent('.dropdown-menu')) {
          element.closest('li.dropdown').addClass('active');
        }
        callback && callback();
      }
      transition ? $active.one($.support.transition.end, next) : next();
      $active.removeClass('in');
    }
  };
  var old = $.fn.tab;
  $.fn.tab = function (option) {
    return this.each(function () {
      var $this = $(this), data = $this.data('tab');
      if (!data)
        $this.data('tab', data = new Tab(this));
      if (typeof option == 'string')
        data[option]();
    });
  };
  $.fn.tab.Constructor = Tab;
  $.fn.tab.noConflict = function () {
    $.fn.tab = old;
    return this;
  };
  $(document).on('click.tab.data-api', '[data-toggle="tab"], [data-toggle="pill"]', function (e) {
    e.preventDefault();
    $(this).tab('show');
  });
}(window.jQuery);
!function ($) {
  'use strict';
  $(function () {
    $.support.transition = function () {
      var transitionEnd = function () {
          var el = document.createElement('bootstrap'), transEndEventNames = {
              'WebkitTransition': 'webkitTransitionEnd',
              'MozTransition': 'transitionend',
              'OTransition': 'oTransitionEnd otransitionend',
              'transition': 'transitionend'
            }, name;
          for (name in transEndEventNames) {
            if (el.style[name] !== undefined) {
              return transEndEventNames[name];
            }
          }
        }();
      return transitionEnd && { end: transitionEnd };
    }();
  });
}(window.jQuery);
(function (window, document, undefined) {
  'use strict';
  var lowercase = function (string) {
    return isString(string) ? string.toLowerCase() : string;
  };
  var uppercase = function (string) {
    return isString(string) ? string.toUpperCase() : string;
  };
  var manualLowercase = function (s) {
    return isString(s) ? s.replace(/[A-Z]/g, function (ch) {
      return String.fromCharCode(ch.charCodeAt(0) | 32);
    }) : s;
  };
  var manualUppercase = function (s) {
    return isString(s) ? s.replace(/[a-z]/g, function (ch) {
      return String.fromCharCode(ch.charCodeAt(0) & ~32);
    }) : s;
  };
  if ('i' !== 'I'.toLowerCase()) {
    lowercase = manualLowercase;
    uppercase = manualUppercase;
  }
  var msie = int((/msie (\d+)/.exec(lowercase(navigator.userAgent)) || [])[1]), jqLite, jQuery, slice = [].slice, push = [].push, toString = Object.prototype.toString, angular = window.angular || (window.angular = {}), angularModule, nodeName_, uid = [
      '0',
      '0',
      '0'
    ];
  function isArrayLike(obj) {
    if (!obj || typeof obj.length !== 'number')
      return false;
    if (typeof obj.hasOwnProperty != 'function' && typeof obj.constructor != 'function') {
      return true;
    } else {
      return obj instanceof JQLite || jQuery && obj instanceof jQuery || toString.call(obj) !== '[object Object]' || typeof obj.callee === 'function';
    }
  }
  function forEach(obj, iterator, context) {
    var key;
    if (obj) {
      if (isFunction(obj)) {
        for (key in obj) {
          if (key != 'prototype' && key != 'length' && key != 'name' && obj.hasOwnProperty(key)) {
            iterator.call(context, obj[key], key);
          }
        }
      } else if (obj.forEach && obj.forEach !== forEach) {
        obj.forEach(iterator, context);
      } else if (isArrayLike(obj)) {
        for (key = 0; key < obj.length; key++)
          iterator.call(context, obj[key], key);
      } else {
        for (key in obj) {
          if (obj.hasOwnProperty(key)) {
            iterator.call(context, obj[key], key);
          }
        }
      }
    }
    return obj;
  }
  function sortedKeys(obj) {
    var keys = [];
    for (var key in obj) {
      if (obj.hasOwnProperty(key)) {
        keys.push(key);
      }
    }
    return keys.sort();
  }
  function forEachSorted(obj, iterator, context) {
    var keys = sortedKeys(obj);
    for (var i = 0; i < keys.length; i++) {
      iterator.call(context, obj[keys[i]], keys[i]);
    }
    return keys;
  }
  function reverseParams(iteratorFn) {
    return function (value, key) {
      iteratorFn(key, value);
    };
  }
  function nextUid() {
    var index = uid.length;
    var digit;
    while (index) {
      index--;
      digit = uid[index].charCodeAt(0);
      if (digit == 57) {
        uid[index] = 'A';
        return uid.join('');
      }
      if (digit == 90) {
        uid[index] = '0';
      } else {
        uid[index] = String.fromCharCode(digit + 1);
        return uid.join('');
      }
    }
    uid.unshift('0');
    return uid.join('');
  }
  function setHashKey(obj, h) {
    if (h) {
      obj.$$hashKey = h;
    } else {
      delete obj.$$hashKey;
    }
  }
  function extend(dst) {
    var h = dst.$$hashKey;
    forEach(arguments, function (obj) {
      if (obj !== dst) {
        forEach(obj, function (value, key) {
          dst[key] = value;
        });
      }
    });
    setHashKey(dst, h);
    return dst;
  }
  function int(str) {
    return parseInt(str, 10);
  }
  function inherit(parent, extra) {
    return extend(new (extend(function () {
    }, { prototype: parent }))(), extra);
  }
  function noop() {
  }
  noop.$inject = [];
  function identity($) {
    return $;
  }
  identity.$inject = [];
  function valueFn(value) {
    return function () {
      return value;
    };
  }
  function isUndefined(value) {
    return typeof value == 'undefined';
  }
  function isDefined(value) {
    return typeof value != 'undefined';
  }
  function isObject(value) {
    return value != null && typeof value == 'object';
  }
  function isString(value) {
    return typeof value == 'string';
  }
  function isNumber(value) {
    return typeof value == 'number';
  }
  function isDate(value) {
    return toString.apply(value) == '[object Date]';
  }
  function isArray(value) {
    return toString.apply(value) == '[object Array]';
  }
  function isFunction(value) {
    return typeof value == 'function';
  }
  function isRegExp(value) {
    return toString.apply(value) == '[object RegExp]';
  }
  function isWindow(obj) {
    return obj && obj.document && obj.location && obj.alert && obj.setInterval;
  }
  function isScope(obj) {
    return obj && obj.$evalAsync && obj.$watch;
  }
  function isFile(obj) {
    return toString.apply(obj) === '[object File]';
  }
  function isBoolean(value) {
    return typeof value == 'boolean';
  }
  var trim = function () {
      if (!String.prototype.trim) {
        return function (value) {
          return isString(value) ? value.replace(/^\s*/, '').replace(/\s*$/, '') : value;
        };
      }
      return function (value) {
        return isString(value) ? value.trim() : value;
      };
    }();
  function isElement(node) {
    return node && (node.nodeName || node.bind && node.find);
  }
  function makeMap(str) {
    var obj = {}, items = str.split(','), i;
    for (i = 0; i < items.length; i++)
      obj[items[i]] = true;
    return obj;
  }
  if (msie < 9) {
    nodeName_ = function (element) {
      element = element.nodeName ? element : element[0];
      return element.scopeName && element.scopeName != 'HTML' ? uppercase(element.scopeName + ':' + element.nodeName) : element.nodeName;
    };
  } else {
    nodeName_ = function (element) {
      return element.nodeName ? element.nodeName : element[0].nodeName;
    };
  }
  function map(obj, iterator, context) {
    var results = [];
    forEach(obj, function (value, index, list) {
      results.push(iterator.call(context, value, index, list));
    });
    return results;
  }
  function size(obj, ownPropsOnly) {
    var size = 0, key;
    if (isArray(obj) || isString(obj)) {
      return obj.length;
    } else if (isObject(obj)) {
      for (key in obj)
        if (!ownPropsOnly || obj.hasOwnProperty(key))
          size++;
    }
    return size;
  }
  function includes(array, obj) {
    return indexOf(array, obj) != -1;
  }
  function indexOf(array, obj) {
    if (array.indexOf)
      return array.indexOf(obj);
    for (var i = 0; i < array.length; i++) {
      if (obj === array[i])
        return i;
    }
    return -1;
  }
  function arrayRemove(array, value) {
    var index = indexOf(array, value);
    if (index >= 0)
      array.splice(index, 1);
    return value;
  }
  function isLeafNode(node) {
    if (node) {
      switch (node.nodeName) {
      case 'OPTION':
      case 'PRE':
      case 'TITLE':
        return true;
      }
    }
    return false;
  }
  function copy(source, destination) {
    if (isWindow(source) || isScope(source))
      throw Error('Can\'t copy Window or Scope');
    if (!destination) {
      destination = source;
      if (source) {
        if (isArray(source)) {
          destination = copy(source, []);
        } else if (isDate(source)) {
          destination = new Date(source.getTime());
        } else if (isRegExp(source)) {
          destination = new RegExp(source.source);
        } else if (isObject(source)) {
          destination = copy(source, {});
        }
      }
    } else {
      if (source === destination)
        throw Error('Can\'t copy equivalent objects or arrays');
      if (isArray(source)) {
        destination.length = 0;
        for (var i = 0; i < source.length; i++) {
          destination.push(copy(source[i]));
        }
      } else {
        var h = destination.$$hashKey;
        forEach(destination, function (value, key) {
          delete destination[key];
        });
        for (var key in source) {
          destination[key] = copy(source[key]);
        }
        setHashKey(destination, h);
      }
    }
    return destination;
  }
  function shallowCopy(src, dst) {
    dst = dst || {};
    for (var key in src) {
      if (src.hasOwnProperty(key) && key.substr(0, 2) !== '$$') {
        dst[key] = src[key];
      }
    }
    return dst;
  }
  function equals(o1, o2) {
    if (o1 === o2)
      return true;
    if (o1 === null || o2 === null)
      return false;
    if (o1 !== o1 && o2 !== o2)
      return true;
    var t1 = typeof o1, t2 = typeof o2, length, key, keySet;
    if (t1 == t2) {
      if (t1 == 'object') {
        if (isArray(o1)) {
          if (!isArray(o2))
            return false;
          if ((length = o1.length) == o2.length) {
            for (key = 0; key < length; key++) {
              if (!equals(o1[key], o2[key]))
                return false;
            }
            return true;
          }
        } else if (isDate(o1)) {
          return isDate(o2) && o1.getTime() == o2.getTime();
        } else if (isRegExp(o1) && isRegExp(o2)) {
          return o1.toString() == o2.toString();
        } else {
          if (isScope(o1) || isScope(o2) || isWindow(o1) || isWindow(o2) || isArray(o2))
            return false;
          keySet = {};
          for (key in o1) {
            if (key.charAt(0) === '$' || isFunction(o1[key]))
              continue;
            if (!equals(o1[key], o2[key]))
              return false;
            keySet[key] = true;
          }
          for (key in o2) {
            if (!keySet[key] && key.charAt(0) !== '$' && o2[key] !== undefined && !isFunction(o2[key]))
              return false;
          }
          return true;
        }
      }
    }
    return false;
  }
  function concat(array1, array2, index) {
    return array1.concat(slice.call(array2, index));
  }
  function sliceArgs(args, startIndex) {
    return slice.call(args, startIndex || 0);
  }
  function bind(self, fn) {
    var curryArgs = arguments.length > 2 ? sliceArgs(arguments, 2) : [];
    if (isFunction(fn) && !(fn instanceof RegExp)) {
      return curryArgs.length ? function () {
        return arguments.length ? fn.apply(self, curryArgs.concat(slice.call(arguments, 0))) : fn.apply(self, curryArgs);
      } : function () {
        return arguments.length ? fn.apply(self, arguments) : fn.call(self);
      };
    } else {
      return fn;
    }
  }
  function toJsonReplacer(key, value) {
    var val = value;
    if (/^\$+/.test(key)) {
      val = undefined;
    } else if (isWindow(value)) {
      val = '$WINDOW';
    } else if (value && document === value) {
      val = '$DOCUMENT';
    } else if (isScope(value)) {
      val = '$SCOPE';
    }
    return val;
  }
  function toJson(obj, pretty) {
    if (typeof obj === 'undefined')
      return undefined;
    return JSON.stringify(obj, toJsonReplacer, pretty ? '  ' : null);
  }
  function fromJson(json) {
    return isString(json) ? JSON.parse(json) : json;
  }
  function toBoolean(value) {
    if (value && value.length !== 0) {
      var v = lowercase('' + value);
      value = !(v == 'f' || v == '0' || v == 'false' || v == 'no' || v == 'n' || v == '[]');
    } else {
      value = false;
    }
    return value;
  }
  function startingTag(element) {
    element = jqLite(element).clone();
    try {
      element.html('');
    } catch (e) {
    }
    var TEXT_NODE = 3;
    var elemHtml = jqLite('<div>').append(element).html();
    try {
      return element[0].nodeType === TEXT_NODE ? lowercase(elemHtml) : elemHtml.match(/^(<[^>]+>)/)[1].replace(/^<([\w\-]+)/, function (match, nodeName) {
        return '<' + lowercase(nodeName);
      });
    } catch (e) {
      return lowercase(elemHtml);
    }
  }
  function tryDecodeURIComponent(value) {
    try {
      return decodeURIComponent(value);
    } catch (e) {
    }
  }
  function parseKeyValue(keyValue) {
    var obj = {}, key_value, key;
    forEach((keyValue || '').split('&'), function (keyValue) {
      if (keyValue) {
        key_value = keyValue.split('=');
        key = tryDecodeURIComponent(key_value[0]);
        if (isDefined(key)) {
          obj[key] = isDefined(key_value[1]) ? tryDecodeURIComponent(key_value[1]) : true;
        }
      }
    });
    return obj;
  }
  function toKeyValue(obj) {
    var parts = [];
    forEach(obj, function (value, key) {
      parts.push(encodeUriQuery(key, true) + (value === true ? '' : '=' + encodeUriQuery(value, true)));
    });
    return parts.length ? parts.join('&') : '';
  }
  function encodeUriSegment(val) {
    return encodeUriQuery(val, true).replace(/%26/gi, '&').replace(/%3D/gi, '=').replace(/%2B/gi, '+');
  }
  function encodeUriQuery(val, pctEncodeSpaces) {
    return encodeURIComponent(val).replace(/%40/gi, '@').replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%20/g, pctEncodeSpaces ? '%20' : '+');
  }
  function angularInit(element, bootstrap) {
    var elements = [element], appElement, module, names = [
        'ng:app',
        'ng-app',
        'x-ng-app',
        'data-ng-app'
      ], NG_APP_CLASS_REGEXP = /\sng[:\-]app(:\s*([\w\d_]+);?)?\s/;
    function append(element) {
      element && elements.push(element);
    }
    forEach(names, function (name) {
      names[name] = true;
      append(document.getElementById(name));
      name = name.replace(':', '\\:');
      if (element.querySelectorAll) {
        forEach(element.querySelectorAll('.' + name), append);
        forEach(element.querySelectorAll('.' + name + '\\:'), append);
        forEach(element.querySelectorAll('[' + name + ']'), append);
      }
    });
    forEach(elements, function (element) {
      if (!appElement) {
        var className = ' ' + element.className + ' ';
        var match = NG_APP_CLASS_REGEXP.exec(className);
        if (match) {
          appElement = element;
          module = (match[2] || '').replace(/\s+/g, ',');
        } else {
          forEach(element.attributes, function (attr) {
            if (!appElement && names[attr.name]) {
              appElement = element;
              module = attr.value;
            }
          });
        }
      }
    });
    if (appElement) {
      bootstrap(appElement, module ? [module] : []);
    }
  }
  function bootstrap(element, modules) {
    var doBootstrap = function () {
      element = jqLite(element);
      modules = modules || [];
      modules.unshift([
        '$provide',
        function ($provide) {
          $provide.value('$rootElement', element);
        }
      ]);
      modules.unshift('ng');
      var injector = createInjector(modules);
      injector.invoke([
        '$rootScope',
        '$rootElement',
        '$compile',
        '$injector',
        function (scope, element, compile, injector) {
          scope.$apply(function () {
            element.data('$injector', injector);
            compile(element)(scope);
          });
        }
      ]);
      return injector;
    };
    var NG_DEFER_BOOTSTRAP = /^NG_DEFER_BOOTSTRAP!/;
    if (window && !NG_DEFER_BOOTSTRAP.test(window.name)) {
      return doBootstrap();
    }
    window.name = window.name.replace(NG_DEFER_BOOTSTRAP, '');
    angular.resumeBootstrap = function (extraModules) {
      forEach(extraModules, function (module) {
        modules.push(module);
      });
      doBootstrap();
    };
  }
  var SNAKE_CASE_REGEXP = /[A-Z]/g;
  function snake_case(name, separator) {
    separator = separator || '_';
    return name.replace(SNAKE_CASE_REGEXP, function (letter, pos) {
      return (pos ? separator : '') + letter.toLowerCase();
    });
  }
  function bindJQuery() {
    jQuery = window.jQuery;
    if (jQuery) {
      jqLite = jQuery;
      extend(jQuery.fn, {
        scope: JQLitePrototype.scope,
        controller: JQLitePrototype.controller,
        injector: JQLitePrototype.injector,
        inheritedData: JQLitePrototype.inheritedData
      });
      JQLitePatchJQueryRemove('remove', true, true, false);
      JQLitePatchJQueryRemove('empty', false, false, false);
      JQLitePatchJQueryRemove('html', false, false, true);
    } else {
      jqLite = JQLite;
    }
    angular.element = jqLite;
  }
  function assertArg(arg, name, reason) {
    if (!arg) {
      throw new Error('Argument \'' + (name || '?') + '\' is ' + (reason || 'required'));
    }
    return arg;
  }
  function assertArgFn(arg, name, acceptArrayAnnotation) {
    if (acceptArrayAnnotation && isArray(arg)) {
      arg = arg[arg.length - 1];
    }
    assertArg(isFunction(arg), name, 'not a function, got ' + (arg && typeof arg == 'object' ? arg.constructor.name || 'Object' : typeof arg));
    return arg;
  }
  function getter(obj, path, bindFnToScope) {
    if (!path)
      return obj;
    var keys = path.split('.');
    var key;
    var lastInstance = obj;
    var len = keys.length;
    for (var i = 0; i < len; i++) {
      key = keys[i];
      if (obj) {
        obj = (lastInstance = obj)[key];
      }
    }
    if (!bindFnToScope && isFunction(obj)) {
      return bind(lastInstance, obj);
    }
    return obj;
  }
  function setupModuleLoader(window) {
    function ensure(obj, name, factory) {
      return obj[name] || (obj[name] = factory());
    }
    return ensure(ensure(window, 'angular', Object), 'module', function () {
      var modules = {};
      return function module(name, requires, configFn) {
        if (requires && modules.hasOwnProperty(name)) {
          modules[name] = null;
        }
        return ensure(modules, name, function () {
          if (!requires) {
            throw Error('No module: ' + name);
          }
          var invokeQueue = [];
          var runBlocks = [];
          var config = invokeLater('$injector', 'invoke');
          var moduleInstance = {
              _invokeQueue: invokeQueue,
              _runBlocks: runBlocks,
              requires: requires,
              name: name,
              provider: invokeLater('$provide', 'provider'),
              factory: invokeLater('$provide', 'factory'),
              service: invokeLater('$provide', 'service'),
              value: invokeLater('$provide', 'value'),
              constant: invokeLater('$provide', 'constant', 'unshift'),
              filter: invokeLater('$filterProvider', 'register'),
              controller: invokeLater('$controllerProvider', 'register'),
              directive: invokeLater('$compileProvider', 'directive'),
              config: config,
              run: function (block) {
                runBlocks.push(block);
                return this;
              }
            };
          if (configFn) {
            config(configFn);
          }
          return moduleInstance;
          function invokeLater(provider, method, insertMethod) {
            return function () {
              invokeQueue[insertMethod || 'push']([
                provider,
                method,
                arguments
              ]);
              return moduleInstance;
            };
          }
        });
      };
    });
  }
  var version = {
      full: '1.0.8',
      major: 1,
      minor: 0,
      dot: 8,
      codeName: 'bubble-burst'
    };
  function publishExternalAPI(angular) {
    extend(angular, {
      'bootstrap': bootstrap,
      'copy': copy,
      'extend': extend,
      'equals': equals,
      'element': jqLite,
      'forEach': forEach,
      'injector': createInjector,
      'noop': noop,
      'bind': bind,
      'toJson': toJson,
      'fromJson': fromJson,
      'identity': identity,
      'isUndefined': isUndefined,
      'isDefined': isDefined,
      'isString': isString,
      'isFunction': isFunction,
      'isObject': isObject,
      'isNumber': isNumber,
      'isElement': isElement,
      'isArray': isArray,
      'version': version,
      'isDate': isDate,
      'lowercase': lowercase,
      'uppercase': uppercase,
      'callbacks': { counter: 0 }
    });
    angularModule = setupModuleLoader(window);
    try {
      angularModule('ngLocale');
    } catch (e) {
      angularModule('ngLocale', []).provider('$locale', $LocaleProvider);
    }
    angularModule('ng', ['ngLocale'], [
      '$provide',
      function ngModule($provide) {
        $provide.provider('$compile', $CompileProvider).directive({
          a: htmlAnchorDirective,
          input: inputDirective,
          textarea: inputDirective,
          form: formDirective,
          script: scriptDirective,
          select: selectDirective,
          style: styleDirective,
          option: optionDirective,
          ngBind: ngBindDirective,
          ngBindHtmlUnsafe: ngBindHtmlUnsafeDirective,
          ngBindTemplate: ngBindTemplateDirective,
          ngClass: ngClassDirective,
          ngClassEven: ngClassEvenDirective,
          ngClassOdd: ngClassOddDirective,
          ngCsp: ngCspDirective,
          ngCloak: ngCloakDirective,
          ngController: ngControllerDirective,
          ngForm: ngFormDirective,
          ngHide: ngHideDirective,
          ngInclude: ngIncludeDirective,
          ngInit: ngInitDirective,
          ngNonBindable: ngNonBindableDirective,
          ngPluralize: ngPluralizeDirective,
          ngRepeat: ngRepeatDirective,
          ngShow: ngShowDirective,
          ngStyle: ngStyleDirective,
          ngSwitch: ngSwitchDirective,
          ngSwitchWhen: ngSwitchWhenDirective,
          ngSwitchDefault: ngSwitchDefaultDirective,
          ngOptions: ngOptionsDirective,
          ngView: ngViewDirective,
          ngTransclude: ngTranscludeDirective,
          ngModel: ngModelDirective,
          ngList: ngListDirective,
          ngChange: ngChangeDirective,
          required: requiredDirective,
          ngRequired: requiredDirective,
          ngValue: ngValueDirective
        }).directive(ngAttributeAliasDirectives).directive(ngEventDirectives);
        $provide.provider({
          $anchorScroll: $AnchorScrollProvider,
          $browser: $BrowserProvider,
          $cacheFactory: $CacheFactoryProvider,
          $controller: $ControllerProvider,
          $document: $DocumentProvider,
          $exceptionHandler: $ExceptionHandlerProvider,
          $filter: $FilterProvider,
          $interpolate: $InterpolateProvider,
          $http: $HttpProvider,
          $httpBackend: $HttpBackendProvider,
          $location: $LocationProvider,
          $log: $LogProvider,
          $parse: $ParseProvider,
          $route: $RouteProvider,
          $routeParams: $RouteParamsProvider,
          $rootScope: $RootScopeProvider,
          $q: $QProvider,
          $sniffer: $SnifferProvider,
          $templateCache: $TemplateCacheProvider,
          $timeout: $TimeoutProvider,
          $window: $WindowProvider
        });
      }
    ]);
  }
  var jqCache = JQLite.cache = {}, jqName = JQLite.expando = 'ng-' + new Date().getTime(), jqId = 1, addEventListenerFn = window.document.addEventListener ? function (element, type, fn) {
      element.addEventListener(type, fn, false);
    } : function (element, type, fn) {
      element.attachEvent('on' + type, fn);
    }, removeEventListenerFn = window.document.removeEventListener ? function (element, type, fn) {
      element.removeEventListener(type, fn, false);
    } : function (element, type, fn) {
      element.detachEvent('on' + type, fn);
    };
  function jqNextId() {
    return ++jqId;
  }
  var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g;
  var MOZ_HACK_REGEXP = /^moz([A-Z])/;
  function camelCase(name) {
    return name.replace(SPECIAL_CHARS_REGEXP, function (_, separator, letter, offset) {
      return offset ? letter.toUpperCase() : letter;
    }).replace(MOZ_HACK_REGEXP, 'Moz$1');
  }
  function JQLitePatchJQueryRemove(name, dispatchThis, filterElems, getterIfNoArguments) {
    var originalJqFn = jQuery.fn[name];
    originalJqFn = originalJqFn.$original || originalJqFn;
    removePatch.$original = originalJqFn;
    jQuery.fn[name] = removePatch;
    function removePatch(param) {
      var list = filterElems && param ? [this.filter(param)] : [this], fireEvent = dispatchThis, set, setIndex, setLength, element, childIndex, childLength, children;
      if (!getterIfNoArguments || param != null) {
        while (list.length) {
          set = list.shift();
          for (setIndex = 0, setLength = set.length; setIndex < setLength; setIndex++) {
            element = jqLite(set[setIndex]);
            if (fireEvent) {
              element.triggerHandler('$destroy');
            } else {
              fireEvent = !fireEvent;
            }
            for (childIndex = 0, childLength = (children = element.children()).length; childIndex < childLength; childIndex++) {
              list.push(jQuery(children[childIndex]));
            }
          }
        }
      }
      return originalJqFn.apply(this, arguments);
    }
  }
  function JQLite(element) {
    if (element instanceof JQLite) {
      return element;
    }
    if (!(this instanceof JQLite)) {
      if (isString(element) && element.charAt(0) != '<') {
        throw Error('selectors not implemented');
      }
      return new JQLite(element);
    }
    if (isString(element)) {
      var div = document.createElement('div');
      div.innerHTML = '<div>&#160;</div>' + element;
      div.removeChild(div.firstChild);
      JQLiteAddNodes(this, div.childNodes);
      this.remove();
    } else {
      JQLiteAddNodes(this, element);
    }
  }
  function JQLiteClone(element) {
    return element.cloneNode(true);
  }
  function JQLiteDealoc(element) {
    JQLiteRemoveData(element);
    for (var i = 0, children = element.childNodes || []; i < children.length; i++) {
      JQLiteDealoc(children[i]);
    }
  }
  function JQLiteUnbind(element, type, fn) {
    var events = JQLiteExpandoStore(element, 'events'), handle = JQLiteExpandoStore(element, 'handle');
    if (!handle)
      return;
    if (isUndefined(type)) {
      forEach(events, function (eventHandler, type) {
        removeEventListenerFn(element, type, eventHandler);
        delete events[type];
      });
    } else {
      if (isUndefined(fn)) {
        removeEventListenerFn(element, type, events[type]);
        delete events[type];
      } else {
        arrayRemove(events[type] || [], fn);
      }
    }
  }
  function JQLiteRemoveData(element) {
    var expandoId = element[jqName], expandoStore = jqCache[expandoId];
    if (expandoStore) {
      if (expandoStore.handle) {
        expandoStore.events.$destroy && expandoStore.handle({}, '$destroy');
        JQLiteUnbind(element);
      }
      delete jqCache[expandoId];
      element[jqName] = undefined;
    }
  }
  function JQLiteExpandoStore(element, key, value) {
    var expandoId = element[jqName], expandoStore = jqCache[expandoId || -1];
    if (isDefined(value)) {
      if (!expandoStore) {
        element[jqName] = expandoId = jqNextId();
        expandoStore = jqCache[expandoId] = {};
      }
      expandoStore[key] = value;
    } else {
      return expandoStore && expandoStore[key];
    }
  }
  function JQLiteData(element, key, value) {
    var data = JQLiteExpandoStore(element, 'data'), isSetter = isDefined(value), keyDefined = !isSetter && isDefined(key), isSimpleGetter = keyDefined && !isObject(key);
    if (!data && !isSimpleGetter) {
      JQLiteExpandoStore(element, 'data', data = {});
    }
    if (isSetter) {
      data[key] = value;
    } else {
      if (keyDefined) {
        if (isSimpleGetter) {
          return data && data[key];
        } else {
          extend(data, key);
        }
      } else {
        return data;
      }
    }
  }
  function JQLiteHasClass(element, selector) {
    return (' ' + element.className + ' ').replace(/[\n\t]/g, ' ').indexOf(' ' + selector + ' ') > -1;
  }
  function JQLiteRemoveClass(element, cssClasses) {
    if (cssClasses) {
      forEach(cssClasses.split(' '), function (cssClass) {
        element.className = trim((' ' + element.className + ' ').replace(/[\n\t]/g, ' ').replace(' ' + trim(cssClass) + ' ', ' '));
      });
    }
  }
  function JQLiteAddClass(element, cssClasses) {
    if (cssClasses) {
      forEach(cssClasses.split(' '), function (cssClass) {
        if (!JQLiteHasClass(element, cssClass)) {
          element.className = trim(element.className + ' ' + trim(cssClass));
        }
      });
    }
  }
  function JQLiteAddNodes(root, elements) {
    if (elements) {
      elements = !elements.nodeName && isDefined(elements.length) && !isWindow(elements) ? elements : [elements];
      for (var i = 0; i < elements.length; i++) {
        root.push(elements[i]);
      }
    }
  }
  function JQLiteController(element, name) {
    return JQLiteInheritedData(element, '$' + (name || 'ngController') + 'Controller');
  }
  function JQLiteInheritedData(element, name, value) {
    element = jqLite(element);
    if (element[0].nodeType == 9) {
      element = element.find('html');
    }
    while (element.length) {
      if (value = element.data(name))
        return value;
      element = element.parent();
    }
  }
  var JQLitePrototype = JQLite.prototype = {
      ready: function (fn) {
        var fired = false;
        function trigger() {
          if (fired)
            return;
          fired = true;
          fn();
        }
        this.bind('DOMContentLoaded', trigger);
        JQLite(window).bind('load', trigger);
      },
      toString: function () {
        var value = [];
        forEach(this, function (e) {
          value.push('' + e);
        });
        return '[' + value.join(', ') + ']';
      },
      eq: function (index) {
        return index >= 0 ? jqLite(this[index]) : jqLite(this[this.length + index]);
      },
      length: 0,
      push: push,
      sort: [].sort,
      splice: [].splice
    };
  var BOOLEAN_ATTR = {};
  forEach('multiple,selected,checked,disabled,readOnly,required'.split(','), function (value) {
    BOOLEAN_ATTR[lowercase(value)] = value;
  });
  var BOOLEAN_ELEMENTS = {};
  forEach('input,select,option,textarea,button,form'.split(','), function (value) {
    BOOLEAN_ELEMENTS[uppercase(value)] = true;
  });
  function getBooleanAttrName(element, name) {
    var booleanAttr = BOOLEAN_ATTR[name.toLowerCase()];
    return booleanAttr && BOOLEAN_ELEMENTS[element.nodeName] && booleanAttr;
  }
  forEach({
    data: JQLiteData,
    inheritedData: JQLiteInheritedData,
    scope: function (element) {
      return JQLiteInheritedData(element, '$scope');
    },
    controller: JQLiteController,
    injector: function (element) {
      return JQLiteInheritedData(element, '$injector');
    },
    removeAttr: function (element, name) {
      element.removeAttribute(name);
    },
    hasClass: JQLiteHasClass,
    css: function (element, name, value) {
      name = camelCase(name);
      if (isDefined(value)) {
        element.style[name] = value;
      } else {
        var val;
        if (msie <= 8) {
          val = element.currentStyle && element.currentStyle[name];
          if (val === '')
            val = 'auto';
        }
        val = val || element.style[name];
        if (msie <= 8) {
          val = val === '' ? undefined : val;
        }
        return val;
      }
    },
    attr: function (element, name, value) {
      var lowercasedName = lowercase(name);
      if (BOOLEAN_ATTR[lowercasedName]) {
        if (isDefined(value)) {
          if (!!value) {
            element[name] = true;
            element.setAttribute(name, lowercasedName);
          } else {
            element[name] = false;
            element.removeAttribute(lowercasedName);
          }
        } else {
          return element[name] || (element.attributes.getNamedItem(name) || noop).specified ? lowercasedName : undefined;
        }
      } else if (isDefined(value)) {
        element.setAttribute(name, value);
      } else if (element.getAttribute) {
        var ret = element.getAttribute(name, 2);
        return ret === null ? undefined : ret;
      }
    },
    prop: function (element, name, value) {
      if (isDefined(value)) {
        element[name] = value;
      } else {
        return element[name];
      }
    },
    text: extend(msie < 9 ? function (element, value) {
      if (element.nodeType == 1) {
        if (isUndefined(value))
          return element.innerText;
        element.innerText = value;
      } else {
        if (isUndefined(value))
          return element.nodeValue;
        element.nodeValue = value;
      }
    } : function (element, value) {
      if (isUndefined(value)) {
        return element.textContent;
      }
      element.textContent = value;
    }, { $dv: '' }),
    val: function (element, value) {
      if (isUndefined(value)) {
        if (nodeName_(element) === 'SELECT' && element.multiple) {
          var result = [];
          forEach(element.options, function (option) {
            if (option.selected) {
              result.push(option.value || option.text);
            }
          });
          return result.length === 0 ? null : result;
        }
        return element.value;
      }
      element.value = value;
    },
    html: function (element, value) {
      if (isUndefined(value)) {
        return element.innerHTML;
      }
      for (var i = 0, childNodes = element.childNodes; i < childNodes.length; i++) {
        JQLiteDealoc(childNodes[i]);
      }
      element.innerHTML = value;
    }
  }, function (fn, name) {
    JQLite.prototype[name] = function (arg1, arg2) {
      var i, key;
      if ((fn.length == 2 && (fn !== JQLiteHasClass && fn !== JQLiteController) ? arg1 : arg2) === undefined) {
        if (isObject(arg1)) {
          for (i = 0; i < this.length; i++) {
            if (fn === JQLiteData) {
              fn(this[i], arg1);
            } else {
              for (key in arg1) {
                fn(this[i], key, arg1[key]);
              }
            }
          }
          return this;
        } else {
          if (this.length)
            return fn(this[0], arg1, arg2);
        }
      } else {
        for (i = 0; i < this.length; i++) {
          fn(this[i], arg1, arg2);
        }
        return this;
      }
      return fn.$dv;
    };
  });
  function createEventHandler(element, events) {
    var eventHandler = function (event, type) {
      if (!event.preventDefault) {
        event.preventDefault = function () {
          event.returnValue = false;
        };
      }
      if (!event.stopPropagation) {
        event.stopPropagation = function () {
          event.cancelBubble = true;
        };
      }
      if (!event.target) {
        event.target = event.srcElement || document;
      }
      if (isUndefined(event.defaultPrevented)) {
        var prevent = event.preventDefault;
        event.preventDefault = function () {
          event.defaultPrevented = true;
          prevent.call(event);
        };
        event.defaultPrevented = false;
      }
      event.isDefaultPrevented = function () {
        return event.defaultPrevented;
      };
      forEach(events[type || event.type], function (fn) {
        fn.call(element, event);
      });
      if (msie <= 8) {
        event.preventDefault = null;
        event.stopPropagation = null;
        event.isDefaultPrevented = null;
      } else {
        delete event.preventDefault;
        delete event.stopPropagation;
        delete event.isDefaultPrevented;
      }
    };
    eventHandler.elem = element;
    return eventHandler;
  }
  forEach({
    removeData: JQLiteRemoveData,
    dealoc: JQLiteDealoc,
    bind: function bindFn(element, type, fn) {
      var events = JQLiteExpandoStore(element, 'events'), handle = JQLiteExpandoStore(element, 'handle');
      if (!events)
        JQLiteExpandoStore(element, 'events', events = {});
      if (!handle)
        JQLiteExpandoStore(element, 'handle', handle = createEventHandler(element, events));
      forEach(type.split(' '), function (type) {
        var eventFns = events[type];
        if (!eventFns) {
          if (type == 'mouseenter' || type == 'mouseleave') {
            var contains = document.body.contains || document.body.compareDocumentPosition ? function (a, b) {
                var adown = a.nodeType === 9 ? a.documentElement : a, bup = b && b.parentNode;
                return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
              } : function (a, b) {
                if (b) {
                  while (b = b.parentNode) {
                    if (b === a) {
                      return true;
                    }
                  }
                }
                return false;
              };
            events[type] = [];
            var eventmap = {
                mouseleave: 'mouseout',
                mouseenter: 'mouseover'
              };
            bindFn(element, eventmap[type], function (event) {
              var ret, target = this, related = event.relatedTarget;
              if (!related || related !== target && !contains(target, related)) {
                handle(event, type);
              }
            });
          } else {
            addEventListenerFn(element, type, handle);
            events[type] = [];
          }
          eventFns = events[type];
        }
        eventFns.push(fn);
      });
    },
    unbind: JQLiteUnbind,
    replaceWith: function (element, replaceNode) {
      var index, parent = element.parentNode;
      JQLiteDealoc(element);
      forEach(new JQLite(replaceNode), function (node) {
        if (index) {
          parent.insertBefore(node, index.nextSibling);
        } else {
          parent.replaceChild(node, element);
        }
        index = node;
      });
    },
    children: function (element) {
      var children = [];
      forEach(element.childNodes, function (element) {
        if (element.nodeType === 1)
          children.push(element);
      });
      return children;
    },
    contents: function (element) {
      return element.childNodes || [];
    },
    append: function (element, node) {
      forEach(new JQLite(node), function (child) {
        if (element.nodeType === 1)
          element.appendChild(child);
      });
    },
    prepend: function (element, node) {
      if (element.nodeType === 1) {
        var index = element.firstChild;
        forEach(new JQLite(node), function (child) {
          element.insertBefore(child, index);
        });
      }
    },
    wrap: function (element, wrapNode) {
      wrapNode = jqLite(wrapNode)[0];
      var parent = element.parentNode;
      if (parent) {
        parent.replaceChild(wrapNode, element);
      }
      wrapNode.appendChild(element);
    },
    remove: function (element) {
      JQLiteDealoc(element);
      var parent = element.parentNode;
      if (parent)
        parent.removeChild(element);
    },
    after: function (element, newElement) {
      var index = element, parent = element.parentNode;
      forEach(new JQLite(newElement), function (node) {
        parent.insertBefore(node, index.nextSibling);
        index = node;
      });
    },
    addClass: JQLiteAddClass,
    removeClass: JQLiteRemoveClass,
    toggleClass: function (element, selector, condition) {
      if (isUndefined(condition)) {
        condition = !JQLiteHasClass(element, selector);
      }
      (condition ? JQLiteAddClass : JQLiteRemoveClass)(element, selector);
    },
    parent: function (element) {
      var parent = element.parentNode;
      return parent && parent.nodeType !== 11 ? parent : null;
    },
    next: function (element) {
      if (element.nextElementSibling) {
        return element.nextElementSibling;
      }
      var elm = element.nextSibling;
      while (elm != null && elm.nodeType !== 1) {
        elm = elm.nextSibling;
      }
      return elm;
    },
    find: function (element, selector) {
      return element.getElementsByTagName(selector);
    },
    clone: JQLiteClone,
    triggerHandler: function (element, eventName) {
      var eventFns = (JQLiteExpandoStore(element, 'events') || {})[eventName];
      forEach(eventFns, function (fn) {
        fn.call(element, null);
      });
    }
  }, function (fn, name) {
    JQLite.prototype[name] = function (arg1, arg2) {
      var value;
      for (var i = 0; i < this.length; i++) {
        if (value == undefined) {
          value = fn(this[i], arg1, arg2);
          if (value !== undefined) {
            value = jqLite(value);
          }
        } else {
          JQLiteAddNodes(value, fn(this[i], arg1, arg2));
        }
      }
      return value == undefined ? this : value;
    };
  });
  function hashKey(obj) {
    var objType = typeof obj, key;
    if (objType == 'object' && obj !== null) {
      if (typeof (key = obj.$$hashKey) == 'function') {
        key = obj.$$hashKey();
      } else if (key === undefined) {
        key = obj.$$hashKey = nextUid();
      }
    } else {
      key = obj;
    }
    return objType + ':' + key;
  }
  function HashMap(array) {
    forEach(array, this.put, this);
  }
  HashMap.prototype = {
    put: function (key, value) {
      this[hashKey(key)] = value;
    },
    get: function (key) {
      return this[hashKey(key)];
    },
    remove: function (key) {
      var value = this[key = hashKey(key)];
      delete this[key];
      return value;
    }
  };
  function HashQueueMap() {
  }
  HashQueueMap.prototype = {
    push: function (key, value) {
      var array = this[key = hashKey(key)];
      if (!array) {
        this[key] = [value];
      } else {
        array.push(value);
      }
    },
    shift: function (key) {
      var array = this[key = hashKey(key)];
      if (array) {
        if (array.length == 1) {
          delete this[key];
          return array[0];
        } else {
          return array.shift();
        }
      }
    },
    peek: function (key) {
      var array = this[hashKey(key)];
      if (array) {
        return array[0];
      }
    }
  };
  var FN_ARGS = /^function\s*[^\(]*\(\s*([^\)]*)\)/m;
  var FN_ARG_SPLIT = /,/;
  var FN_ARG = /^\s*(_?)(\S+?)\1\s*$/;
  var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm;
  function annotate(fn) {
    var $inject, fnText, argDecl, last;
    if (typeof fn == 'function') {
      if (!($inject = fn.$inject)) {
        $inject = [];
        fnText = fn.toString().replace(STRIP_COMMENTS, '');
        argDecl = fnText.match(FN_ARGS);
        forEach(argDecl[1].split(FN_ARG_SPLIT), function (arg) {
          arg.replace(FN_ARG, function (all, underscore, name) {
            $inject.push(name);
          });
        });
        fn.$inject = $inject;
      }
    } else if (isArray(fn)) {
      last = fn.length - 1;
      assertArgFn(fn[last], 'fn');
      $inject = fn.slice(0, last);
    } else {
      assertArgFn(fn, 'fn', true);
    }
    return $inject;
  }
  function createInjector(modulesToLoad) {
    var INSTANTIATING = {}, providerSuffix = 'Provider', path = [], loadedModules = new HashMap(), providerCache = {
        $provide: {
          provider: supportObject(provider),
          factory: supportObject(factory),
          service: supportObject(service),
          value: supportObject(value),
          constant: supportObject(constant),
          decorator: decorator
        }
      }, providerInjector = createInternalInjector(providerCache, function () {
        throw Error('Unknown provider: ' + path.join(' <- '));
      }), instanceCache = {}, instanceInjector = instanceCache.$injector = createInternalInjector(instanceCache, function (servicename) {
        var provider = providerInjector.get(servicename + providerSuffix);
        return instanceInjector.invoke(provider.$get, provider);
      });
    forEach(loadModules(modulesToLoad), function (fn) {
      instanceInjector.invoke(fn || noop);
    });
    return instanceInjector;
    function supportObject(delegate) {
      return function (key, value) {
        if (isObject(key)) {
          forEach(key, reverseParams(delegate));
        } else {
          return delegate(key, value);
        }
      };
    }
    function provider(name, provider_) {
      if (isFunction(provider_) || isArray(provider_)) {
        provider_ = providerInjector.instantiate(provider_);
      }
      if (!provider_.$get) {
        throw Error('Provider ' + name + ' must define $get factory method.');
      }
      return providerCache[name + providerSuffix] = provider_;
    }
    function factory(name, factoryFn) {
      return provider(name, { $get: factoryFn });
    }
    function service(name, constructor) {
      return factory(name, [
        '$injector',
        function ($injector) {
          return $injector.instantiate(constructor);
        }
      ]);
    }
    function value(name, value) {
      return factory(name, valueFn(value));
    }
    function constant(name, value) {
      providerCache[name] = value;
      instanceCache[name] = value;
    }
    function decorator(serviceName, decorFn) {
      var origProvider = providerInjector.get(serviceName + providerSuffix), orig$get = origProvider.$get;
      origProvider.$get = function () {
        var origInstance = instanceInjector.invoke(orig$get, origProvider);
        return instanceInjector.invoke(decorFn, null, { $delegate: origInstance });
      };
    }
    function loadModules(modulesToLoad) {
      var runBlocks = [];
      forEach(modulesToLoad, function (module) {
        if (loadedModules.get(module))
          return;
        loadedModules.put(module, true);
        if (isString(module)) {
          var moduleFn = angularModule(module);
          runBlocks = runBlocks.concat(loadModules(moduleFn.requires)).concat(moduleFn._runBlocks);
          try {
            for (var invokeQueue = moduleFn._invokeQueue, i = 0, ii = invokeQueue.length; i < ii; i++) {
              var invokeArgs = invokeQueue[i], provider = invokeArgs[0] == '$injector' ? providerInjector : providerInjector.get(invokeArgs[0]);
              provider[invokeArgs[1]].apply(provider, invokeArgs[2]);
            }
          } catch (e) {
            if (e.message)
              e.message += ' from ' + module;
            throw e;
          }
        } else if (isFunction(module)) {
          try {
            runBlocks.push(providerInjector.invoke(module));
          } catch (e) {
            if (e.message)
              e.message += ' from ' + module;
            throw e;
          }
        } else if (isArray(module)) {
          try {
            runBlocks.push(providerInjector.invoke(module));
          } catch (e) {
            if (e.message)
              e.message += ' from ' + String(module[module.length - 1]);
            throw e;
          }
        } else {
          assertArgFn(module, 'module');
        }
      });
      return runBlocks;
    }
    function createInternalInjector(cache, factory) {
      function getService(serviceName) {
        if (typeof serviceName !== 'string') {
          throw Error('Service name expected');
        }
        if (cache.hasOwnProperty(serviceName)) {
          if (cache[serviceName] === INSTANTIATING) {
            throw Error('Circular dependency: ' + path.join(' <- '));
          }
          return cache[serviceName];
        } else {
          try {
            path.unshift(serviceName);
            cache[serviceName] = INSTANTIATING;
            return cache[serviceName] = factory(serviceName);
          } finally {
            path.shift();
          }
        }
      }
      function invoke(fn, self, locals) {
        var args = [], $inject = annotate(fn), length, i, key;
        for (i = 0, length = $inject.length; i < length; i++) {
          key = $inject[i];
          args.push(locals && locals.hasOwnProperty(key) ? locals[key] : getService(key));
        }
        if (!fn.$inject) {
          fn = fn[length];
        }
        switch (self ? -1 : args.length) {
        case 0:
          return fn();
        case 1:
          return fn(args[0]);
        case 2:
          return fn(args[0], args[1]);
        case 3:
          return fn(args[0], args[1], args[2]);
        case 4:
          return fn(args[0], args[1], args[2], args[3]);
        case 5:
          return fn(args[0], args[1], args[2], args[3], args[4]);
        case 6:
          return fn(args[0], args[1], args[2], args[3], args[4], args[5]);
        case 7:
          return fn(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
        case 8:
          return fn(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7]);
        case 9:
          return fn(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8]);
        case 10:
          return fn(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9]);
        default:
          return fn.apply(self, args);
        }
      }
      function instantiate(Type, locals) {
        var Constructor = function () {
          }, instance, returnedValue;
        Constructor.prototype = (isArray(Type) ? Type[Type.length - 1] : Type).prototype;
        instance = new Constructor();
        returnedValue = invoke(Type, instance, locals);
        return isObject(returnedValue) ? returnedValue : instance;
      }
      return {
        invoke: invoke,
        instantiate: instantiate,
        get: getService,
        annotate: annotate
      };
    }
  }
  function $AnchorScrollProvider() {
    var autoScrollingEnabled = true;
    this.disableAutoScrolling = function () {
      autoScrollingEnabled = false;
    };
    this.$get = [
      '$window',
      '$location',
      '$rootScope',
      function ($window, $location, $rootScope) {
        var document = $window.document;
        function getFirstAnchor(list) {
          var result = null;
          forEach(list, function (element) {
            if (!result && lowercase(element.nodeName) === 'a')
              result = element;
          });
          return result;
        }
        function scroll() {
          var hash = $location.hash(), elm;
          if (!hash)
            $window.scrollTo(0, 0);
          else if (elm = document.getElementById(hash))
            elm.scrollIntoView();
          else if (elm = getFirstAnchor(document.getElementsByName(hash)))
            elm.scrollIntoView();
          else if (hash === 'top')
            $window.scrollTo(0, 0);
        }
        if (autoScrollingEnabled) {
          $rootScope.$watch(function autoScrollWatch() {
            return $location.hash();
          }, function autoScrollWatchAction() {
            $rootScope.$evalAsync(scroll);
          });
        }
        return scroll;
      }
    ];
  }
  function Browser(window, document, $log, $sniffer) {
    var self = this, rawDocument = document[0], location = window.location, history = window.history, setTimeout = window.setTimeout, clearTimeout = window.clearTimeout, pendingDeferIds = {};
    self.isMock = false;
    var outstandingRequestCount = 0;
    var outstandingRequestCallbacks = [];
    self.$$completeOutstandingRequest = completeOutstandingRequest;
    self.$$incOutstandingRequestCount = function () {
      outstandingRequestCount++;
    };
    function completeOutstandingRequest(fn) {
      try {
        fn.apply(null, sliceArgs(arguments, 1));
      } finally {
        outstandingRequestCount--;
        if (outstandingRequestCount === 0) {
          while (outstandingRequestCallbacks.length) {
            try {
              outstandingRequestCallbacks.pop()();
            } catch (e) {
              $log.error(e);
            }
          }
        }
      }
    }
    self.notifyWhenNoOutstandingRequests = function (callback) {
      forEach(pollFns, function (pollFn) {
        pollFn();
      });
      if (outstandingRequestCount === 0) {
        callback();
      } else {
        outstandingRequestCallbacks.push(callback);
      }
    };
    var pollFns = [], pollTimeout;
    self.addPollFn = function (fn) {
      if (isUndefined(pollTimeout))
        startPoller(100, setTimeout);
      pollFns.push(fn);
      return fn;
    };
    function startPoller(interval, setTimeout) {
      (function check() {
        forEach(pollFns, function (pollFn) {
          pollFn();
        });
        pollTimeout = setTimeout(check, interval);
      }());
    }
    var lastBrowserUrl = location.href, baseElement = document.find('base'), replacedUrl = null;
    self.url = function (url, replace) {
      if (url) {
        if (lastBrowserUrl == url)
          return;
        lastBrowserUrl = url;
        if ($sniffer.history) {
          if (replace)
            history.replaceState(null, '', url);
          else {
            history.pushState(null, '', url);
            baseElement.attr('href', baseElement.attr('href'));
          }
        } else {
          if (replace) {
            location.replace(url);
            replacedUrl = url;
          } else {
            location.href = url;
            replacedUrl = null;
          }
        }
        return self;
      } else {
        return replacedUrl || location.href.replace(/%27/g, '\'');
      }
    };
    var urlChangeListeners = [], urlChangeInit = false;
    function fireUrlChange() {
      if (lastBrowserUrl == self.url())
        return;
      lastBrowserUrl = self.url();
      forEach(urlChangeListeners, function (listener) {
        listener(self.url());
      });
    }
    self.onUrlChange = function (callback) {
      if (!urlChangeInit) {
        if ($sniffer.history)
          jqLite(window).bind('popstate', fireUrlChange);
        if ($sniffer.hashchange)
          jqLite(window).bind('hashchange', fireUrlChange);
        else
          self.addPollFn(fireUrlChange);
        urlChangeInit = true;
      }
      urlChangeListeners.push(callback);
      return callback;
    };
    self.baseHref = function () {
      var href = baseElement.attr('href');
      return href ? href.replace(/^https?\:\/\/[^\/]*/, '') : '';
    };
    var lastCookies = {};
    var lastCookieString = '';
    var cookiePath = self.baseHref();
    self.cookies = function (name, value) {
      var cookieLength, cookieArray, cookie, i, index;
      if (name) {
        if (value === undefined) {
          rawDocument.cookie = escape(name) + '=;path=' + cookiePath + ';expires=Thu, 01 Jan 1970 00:00:00 GMT';
        } else {
          if (isString(value)) {
            cookieLength = (rawDocument.cookie = escape(name) + '=' + escape(value) + ';path=' + cookiePath).length + 1;
            if (cookieLength > 4096) {
              $log.warn('Cookie \'' + name + '\' possibly not set or overflowed because it was too large (' + cookieLength + ' > 4096 bytes)!');
            }
          }
        }
      } else {
        if (rawDocument.cookie !== lastCookieString) {
          lastCookieString = rawDocument.cookie;
          cookieArray = lastCookieString.split('; ');
          lastCookies = {};
          for (i = 0; i < cookieArray.length; i++) {
            cookie = cookieArray[i];
            index = cookie.indexOf('=');
            if (index > 0) {
              var name = unescape(cookie.substring(0, index));
              if (lastCookies[name] === undefined) {
                lastCookies[name] = unescape(cookie.substring(index + 1));
              }
            }
          }
        }
        return lastCookies;
      }
    };
    self.defer = function (fn, delay) {
      var timeoutId;
      outstandingRequestCount++;
      timeoutId = setTimeout(function () {
        delete pendingDeferIds[timeoutId];
        completeOutstandingRequest(fn);
      }, delay || 0);
      pendingDeferIds[timeoutId] = true;
      return timeoutId;
    };
    self.defer.cancel = function (deferId) {
      if (pendingDeferIds[deferId]) {
        delete pendingDeferIds[deferId];
        clearTimeout(deferId);
        completeOutstandingRequest(noop);
        return true;
      }
      return false;
    };
  }
  function $BrowserProvider() {
    this.$get = [
      '$window',
      '$log',
      '$sniffer',
      '$document',
      function ($window, $log, $sniffer, $document) {
        return new Browser($window, $document, $log, $sniffer);
      }
    ];
  }
  function $CacheFactoryProvider() {
    this.$get = function () {
      var caches = {};
      function cacheFactory(cacheId, options) {
        if (cacheId in caches) {
          throw Error('cacheId ' + cacheId + ' taken');
        }
        var size = 0, stats = extend({}, options, { id: cacheId }), data = {}, capacity = options && options.capacity || Number.MAX_VALUE, lruHash = {}, freshEnd = null, staleEnd = null;
        return caches[cacheId] = {
          put: function (key, value) {
            var lruEntry = lruHash[key] || (lruHash[key] = { key: key });
            refresh(lruEntry);
            if (isUndefined(value))
              return;
            if (!(key in data))
              size++;
            data[key] = value;
            if (size > capacity) {
              this.remove(staleEnd.key);
            }
          },
          get: function (key) {
            var lruEntry = lruHash[key];
            if (!lruEntry)
              return;
            refresh(lruEntry);
            return data[key];
          },
          remove: function (key) {
            var lruEntry = lruHash[key];
            if (!lruEntry)
              return;
            if (lruEntry == freshEnd)
              freshEnd = lruEntry.p;
            if (lruEntry == staleEnd)
              staleEnd = lruEntry.n;
            link(lruEntry.n, lruEntry.p);
            delete lruHash[key];
            delete data[key];
            size--;
          },
          removeAll: function () {
            data = {};
            size = 0;
            lruHash = {};
            freshEnd = staleEnd = null;
          },
          destroy: function () {
            data = null;
            stats = null;
            lruHash = null;
            delete caches[cacheId];
          },
          info: function () {
            return extend({}, stats, { size: size });
          }
        };
        function refresh(entry) {
          if (entry != freshEnd) {
            if (!staleEnd) {
              staleEnd = entry;
            } else if (staleEnd == entry) {
              staleEnd = entry.n;
            }
            link(entry.n, entry.p);
            link(entry, freshEnd);
            freshEnd = entry;
            freshEnd.n = null;
          }
        }
        function link(nextEntry, prevEntry) {
          if (nextEntry != prevEntry) {
            if (nextEntry)
              nextEntry.p = prevEntry;
            if (prevEntry)
              prevEntry.n = nextEntry;
          }
        }
      }
      cacheFactory.info = function () {
        var info = {};
        forEach(caches, function (cache, cacheId) {
          info[cacheId] = cache.info();
        });
        return info;
      };
      cacheFactory.get = function (cacheId) {
        return caches[cacheId];
      };
      return cacheFactory;
    };
  }
  function $TemplateCacheProvider() {
    this.$get = [
      '$cacheFactory',
      function ($cacheFactory) {
        return $cacheFactory('templates');
      }
    ];
  }
  var NON_ASSIGNABLE_MODEL_EXPRESSION = 'Non-assignable model expression: ';
  $CompileProvider.$inject = ['$provide'];
  function $CompileProvider($provide) {
    var hasDirectives = {}, Suffix = 'Directive', COMMENT_DIRECTIVE_REGEXP = /^\s*directive\:\s*([\d\w\-_]+)\s+(.*)$/, CLASS_DIRECTIVE_REGEXP = /(([\d\w\-_]+)(?:\:([^;]+))?;?)/, MULTI_ROOT_TEMPLATE_ERROR = 'Template must have exactly one root element. was: ', urlSanitizationWhitelist = /^\s*(https?|ftp|mailto|file):/;
    this.directive = function registerDirective(name, directiveFactory) {
      if (isString(name)) {
        assertArg(directiveFactory, 'directive');
        if (!hasDirectives.hasOwnProperty(name)) {
          hasDirectives[name] = [];
          $provide.factory(name + Suffix, [
            '$injector',
            '$exceptionHandler',
            function ($injector, $exceptionHandler) {
              var directives = [];
              forEach(hasDirectives[name], function (directiveFactory) {
                try {
                  var directive = $injector.invoke(directiveFactory);
                  if (isFunction(directive)) {
                    directive = { compile: valueFn(directive) };
                  } else if (!directive.compile && directive.link) {
                    directive.compile = valueFn(directive.link);
                  }
                  directive.priority = directive.priority || 0;
                  directive.name = directive.name || name;
                  directive.require = directive.require || directive.controller && directive.name;
                  directive.restrict = directive.restrict || 'A';
                  directives.push(directive);
                } catch (e) {
                  $exceptionHandler(e);
                }
              });
              return directives;
            }
          ]);
        }
        hasDirectives[name].push(directiveFactory);
      } else {
        forEach(name, reverseParams(registerDirective));
      }
      return this;
    };
    this.urlSanitizationWhitelist = function (regexp) {
      if (isDefined(regexp)) {
        urlSanitizationWhitelist = regexp;
        return this;
      }
      return urlSanitizationWhitelist;
    };
    this.$get = [
      '$injector',
      '$interpolate',
      '$exceptionHandler',
      '$http',
      '$templateCache',
      '$parse',
      '$controller',
      '$rootScope',
      '$document',
      function ($injector, $interpolate, $exceptionHandler, $http, $templateCache, $parse, $controller, $rootScope, $document) {
        var Attributes = function (element, attr) {
          this.$$element = element;
          this.$attr = attr || {};
        };
        Attributes.prototype = {
          $normalize: directiveNormalize,
          $set: function (key, value, writeAttr, attrName) {
            var booleanKey = getBooleanAttrName(this.$$element[0], key), $$observers = this.$$observers, normalizedVal;
            if (booleanKey) {
              this.$$element.prop(key, value);
              attrName = booleanKey;
            }
            this[key] = value;
            if (attrName) {
              this.$attr[key] = attrName;
            } else {
              attrName = this.$attr[key];
              if (!attrName) {
                this.$attr[key] = attrName = snake_case(key, '-');
              }
            }
            if (nodeName_(this.$$element[0]) === 'A' && key === 'href') {
              urlSanitizationNode.setAttribute('href', value);
              normalizedVal = urlSanitizationNode.href;
              if (normalizedVal !== '' && !normalizedVal.match(urlSanitizationWhitelist)) {
                this[key] = value = 'unsafe:' + normalizedVal;
              }
            }
            if (writeAttr !== false) {
              if (value === null || value === undefined) {
                this.$$element.removeAttr(attrName);
              } else {
                this.$$element.attr(attrName, value);
              }
            }
            $$observers && forEach($$observers[key], function (fn) {
              try {
                fn(value);
              } catch (e) {
                $exceptionHandler(e);
              }
            });
          },
          $observe: function (key, fn) {
            var attrs = this, $$observers = attrs.$$observers || (attrs.$$observers = {}), listeners = $$observers[key] || ($$observers[key] = []);
            listeners.push(fn);
            $rootScope.$evalAsync(function () {
              if (!listeners.$$inter) {
                fn(attrs[key]);
              }
            });
            return fn;
          }
        };
        var urlSanitizationNode = $document[0].createElement('a'), startSymbol = $interpolate.startSymbol(), endSymbol = $interpolate.endSymbol(), denormalizeTemplate = startSymbol == '{{' || endSymbol == '}}' ? identity : function denormalizeTemplate(template) {
            return template.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol);
          };
        return compile;
        function compile($compileNodes, transcludeFn, maxPriority) {
          if (!($compileNodes instanceof jqLite)) {
            $compileNodes = jqLite($compileNodes);
          }
          forEach($compileNodes, function (node, index) {
            if (node.nodeType == 3 && node.nodeValue.match(/\S+/)) {
              $compileNodes[index] = jqLite(node).wrap('<span></span>').parent()[0];
            }
          });
          var compositeLinkFn = compileNodes($compileNodes, transcludeFn, $compileNodes, maxPriority);
          return function publicLinkFn(scope, cloneConnectFn) {
            assertArg(scope, 'scope');
            var $linkNode = cloneConnectFn ? JQLitePrototype.clone.call($compileNodes) : $compileNodes;
            for (var i = 0, ii = $linkNode.length; i < ii; i++) {
              var node = $linkNode[i];
              if (node.nodeType == 1 || node.nodeType == 9) {
                $linkNode.eq(i).data('$scope', scope);
              }
            }
            safeAddClass($linkNode, 'ng-scope');
            if (cloneConnectFn)
              cloneConnectFn($linkNode, scope);
            if (compositeLinkFn)
              compositeLinkFn(scope, $linkNode, $linkNode);
            return $linkNode;
          };
        }
        function wrongMode(localName, mode) {
          throw Error('Unsupported \'' + mode + '\' for \'' + localName + '\'.');
        }
        function safeAddClass($element, className) {
          try {
            $element.addClass(className);
          } catch (e) {
          }
        }
        function compileNodes(nodeList, transcludeFn, $rootElement, maxPriority) {
          var linkFns = [], nodeLinkFn, childLinkFn, directives, attrs, linkFnFound;
          for (var i = 0; i < nodeList.length; i++) {
            attrs = new Attributes();
            directives = collectDirectives(nodeList[i], [], attrs, maxPriority);
            nodeLinkFn = directives.length ? applyDirectivesToNode(directives, nodeList[i], attrs, transcludeFn, $rootElement) : null;
            childLinkFn = nodeLinkFn && nodeLinkFn.terminal || !nodeList[i].childNodes || !nodeList[i].childNodes.length ? null : compileNodes(nodeList[i].childNodes, nodeLinkFn ? nodeLinkFn.transclude : transcludeFn);
            linkFns.push(nodeLinkFn);
            linkFns.push(childLinkFn);
            linkFnFound = linkFnFound || nodeLinkFn || childLinkFn;
          }
          return linkFnFound ? compositeLinkFn : null;
          function compositeLinkFn(scope, nodeList, $rootElement, boundTranscludeFn) {
            var nodeLinkFn, childLinkFn, node, childScope, childTranscludeFn, i, ii, n;
            var stableNodeList = [];
            for (i = 0, ii = nodeList.length; i < ii; i++) {
              stableNodeList.push(nodeList[i]);
            }
            for (i = 0, n = 0, ii = linkFns.length; i < ii; n++) {
              node = stableNodeList[n];
              nodeLinkFn = linkFns[i++];
              childLinkFn = linkFns[i++];
              if (nodeLinkFn) {
                if (nodeLinkFn.scope) {
                  childScope = scope.$new(isObject(nodeLinkFn.scope));
                  jqLite(node).data('$scope', childScope);
                } else {
                  childScope = scope;
                }
                childTranscludeFn = nodeLinkFn.transclude;
                if (childTranscludeFn || !boundTranscludeFn && transcludeFn) {
                  nodeLinkFn(childLinkFn, childScope, node, $rootElement, function (transcludeFn) {
                    return function (cloneFn) {
                      var transcludeScope = scope.$new();
                      transcludeScope.$$transcluded = true;
                      return transcludeFn(transcludeScope, cloneFn).bind('$destroy', bind(transcludeScope, transcludeScope.$destroy));
                    };
                  }(childTranscludeFn || transcludeFn));
                } else {
                  nodeLinkFn(childLinkFn, childScope, node, undefined, boundTranscludeFn);
                }
              } else if (childLinkFn) {
                childLinkFn(scope, node.childNodes, undefined, boundTranscludeFn);
              }
            }
          }
        }
        function collectDirectives(node, directives, attrs, maxPriority) {
          var nodeType = node.nodeType, attrsMap = attrs.$attr, match, className;
          switch (nodeType) {
          case 1:
            addDirective(directives, directiveNormalize(nodeName_(node).toLowerCase()), 'E', maxPriority);
            for (var attr, name, nName, value, nAttrs = node.attributes, j = 0, jj = nAttrs && nAttrs.length; j < jj; j++) {
              attr = nAttrs[j];
              if (!msie || msie >= 8 || attr.specified) {
                name = attr.name;
                nName = directiveNormalize(name.toLowerCase());
                attrsMap[nName] = name;
                attrs[nName] = value = trim(msie && name == 'href' ? decodeURIComponent(node.getAttribute(name, 2)) : attr.value);
                if (getBooleanAttrName(node, nName)) {
                  attrs[nName] = true;
                }
                addAttrInterpolateDirective(node, directives, value, nName);
                addDirective(directives, nName, 'A', maxPriority);
              }
            }
            className = node.className;
            if (isString(className) && className !== '') {
              while (match = CLASS_DIRECTIVE_REGEXP.exec(className)) {
                nName = directiveNormalize(match[2]);
                if (addDirective(directives, nName, 'C', maxPriority)) {
                  attrs[nName] = trim(match[3]);
                }
                className = className.substr(match.index + match[0].length);
              }
            }
            break;
          case 3:
            addTextInterpolateDirective(directives, node.nodeValue);
            break;
          case 8:
            try {
              match = COMMENT_DIRECTIVE_REGEXP.exec(node.nodeValue);
              if (match) {
                nName = directiveNormalize(match[1]);
                if (addDirective(directives, nName, 'M', maxPriority)) {
                  attrs[nName] = trim(match[2]);
                }
              }
            } catch (e) {
            }
            break;
          }
          directives.sort(byPriority);
          return directives;
        }
        function applyDirectivesToNode(directives, compileNode, templateAttrs, transcludeFn, jqCollection) {
          var terminalPriority = -Number.MAX_VALUE, preLinkFns = [], postLinkFns = [], newScopeDirective = null, newIsolateScopeDirective = null, templateDirective = null, $compileNode = templateAttrs.$$element = jqLite(compileNode), directive, directiveName, $template, transcludeDirective, childTranscludeFn = transcludeFn, controllerDirectives, linkFn, directiveValue;
          for (var i = 0, ii = directives.length; i < ii; i++) {
            directive = directives[i];
            $template = undefined;
            if (terminalPriority > directive.priority) {
              break;
            }
            if (directiveValue = directive.scope) {
              assertNoDuplicate('isolated scope', newIsolateScopeDirective, directive, $compileNode);
              if (isObject(directiveValue)) {
                safeAddClass($compileNode, 'ng-isolate-scope');
                newIsolateScopeDirective = directive;
              }
              safeAddClass($compileNode, 'ng-scope');
              newScopeDirective = newScopeDirective || directive;
            }
            directiveName = directive.name;
            if (directiveValue = directive.controller) {
              controllerDirectives = controllerDirectives || {};
              assertNoDuplicate('\'' + directiveName + '\' controller', controllerDirectives[directiveName], directive, $compileNode);
              controllerDirectives[directiveName] = directive;
            }
            if (directiveValue = directive.transclude) {
              assertNoDuplicate('transclusion', transcludeDirective, directive, $compileNode);
              transcludeDirective = directive;
              terminalPriority = directive.priority;
              if (directiveValue == 'element') {
                $template = jqLite(compileNode);
                $compileNode = templateAttrs.$$element = jqLite(document.createComment(' ' + directiveName + ': ' + templateAttrs[directiveName] + ' '));
                compileNode = $compileNode[0];
                replaceWith(jqCollection, jqLite($template[0]), compileNode);
                childTranscludeFn = compile($template, transcludeFn, terminalPriority);
              } else {
                $template = jqLite(JQLiteClone(compileNode)).contents();
                $compileNode.html('');
                childTranscludeFn = compile($template, transcludeFn);
              }
            }
            if (directiveValue = directive.template) {
              assertNoDuplicate('template', templateDirective, directive, $compileNode);
              templateDirective = directive;
              directiveValue = denormalizeTemplate(directiveValue);
              if (directive.replace) {
                $template = jqLite('<div>' + trim(directiveValue) + '</div>').contents();
                compileNode = $template[0];
                if ($template.length != 1 || compileNode.nodeType !== 1) {
                  throw new Error(MULTI_ROOT_TEMPLATE_ERROR + directiveValue);
                }
                replaceWith(jqCollection, $compileNode, compileNode);
                var newTemplateAttrs = { $attr: {} };
                directives = directives.concat(collectDirectives(compileNode, directives.splice(i + 1, directives.length - (i + 1)), newTemplateAttrs));
                mergeTemplateAttributes(templateAttrs, newTemplateAttrs);
                ii = directives.length;
              } else {
                $compileNode.html(directiveValue);
              }
            }
            if (directive.templateUrl) {
              assertNoDuplicate('template', templateDirective, directive, $compileNode);
              templateDirective = directive;
              nodeLinkFn = compileTemplateUrl(directives.splice(i, directives.length - i), nodeLinkFn, $compileNode, templateAttrs, jqCollection, directive.replace, childTranscludeFn);
              ii = directives.length;
            } else if (directive.compile) {
              try {
                linkFn = directive.compile($compileNode, templateAttrs, childTranscludeFn);
                if (isFunction(linkFn)) {
                  addLinkFns(null, linkFn);
                } else if (linkFn) {
                  addLinkFns(linkFn.pre, linkFn.post);
                }
              } catch (e) {
                $exceptionHandler(e, startingTag($compileNode));
              }
            }
            if (directive.terminal) {
              nodeLinkFn.terminal = true;
              terminalPriority = Math.max(terminalPriority, directive.priority);
            }
          }
          nodeLinkFn.scope = newScopeDirective && newScopeDirective.scope;
          nodeLinkFn.transclude = transcludeDirective && childTranscludeFn;
          return nodeLinkFn;
          function addLinkFns(pre, post) {
            if (pre) {
              pre.require = directive.require;
              preLinkFns.push(pre);
            }
            if (post) {
              post.require = directive.require;
              postLinkFns.push(post);
            }
          }
          function getControllers(require, $element) {
            var value, retrievalMethod = 'data', optional = false;
            if (isString(require)) {
              while ((value = require.charAt(0)) == '^' || value == '?') {
                require = require.substr(1);
                if (value == '^') {
                  retrievalMethod = 'inheritedData';
                }
                optional = optional || value == '?';
              }
              value = $element[retrievalMethod]('$' + require + 'Controller');
              if (!value && !optional) {
                throw Error('No controller: ' + require);
              }
              return value;
            } else if (isArray(require)) {
              value = [];
              forEach(require, function (require) {
                value.push(getControllers(require, $element));
              });
            }
            return value;
          }
          function nodeLinkFn(childLinkFn, scope, linkNode, $rootElement, boundTranscludeFn) {
            var attrs, $element, i, ii, linkFn, controller;
            if (compileNode === linkNode) {
              attrs = templateAttrs;
            } else {
              attrs = shallowCopy(templateAttrs, new Attributes(jqLite(linkNode), templateAttrs.$attr));
            }
            $element = attrs.$$element;
            if (newIsolateScopeDirective) {
              var LOCAL_REGEXP = /^\s*([@=&])\s*(\w*)\s*$/;
              var parentScope = scope.$parent || scope;
              forEach(newIsolateScopeDirective.scope, function (definiton, scopeName) {
                var match = definiton.match(LOCAL_REGEXP) || [], attrName = match[2] || scopeName, mode = match[1], lastValue, parentGet, parentSet;
                scope.$$isolateBindings[scopeName] = mode + attrName;
                switch (mode) {
                case '@': {
                    attrs.$observe(attrName, function (value) {
                      scope[scopeName] = value;
                    });
                    attrs.$$observers[attrName].$$scope = parentScope;
                    break;
                  }
                case '=': {
                    parentGet = $parse(attrs[attrName]);
                    parentSet = parentGet.assign || function () {
                      lastValue = scope[scopeName] = parentGet(parentScope);
                      throw Error(NON_ASSIGNABLE_MODEL_EXPRESSION + attrs[attrName] + ' (directive: ' + newIsolateScopeDirective.name + ')');
                    };
                    lastValue = scope[scopeName] = parentGet(parentScope);
                    scope.$watch(function parentValueWatch() {
                      var parentValue = parentGet(parentScope);
                      if (parentValue !== scope[scopeName]) {
                        if (parentValue !== lastValue) {
                          lastValue = scope[scopeName] = parentValue;
                        } else {
                          parentSet(parentScope, parentValue = lastValue = scope[scopeName]);
                        }
                      }
                      return parentValue;
                    });
                    break;
                  }
                case '&': {
                    parentGet = $parse(attrs[attrName]);
                    scope[scopeName] = function (locals) {
                      return parentGet(parentScope, locals);
                    };
                    break;
                  }
                default: {
                    throw Error('Invalid isolate scope definition for directive ' + newIsolateScopeDirective.name + ': ' + definiton);
                  }
                }
              });
            }
            if (controllerDirectives) {
              forEach(controllerDirectives, function (directive) {
                var locals = {
                    $scope: scope,
                    $element: $element,
                    $attrs: attrs,
                    $transclude: boundTranscludeFn
                  };
                controller = directive.controller;
                if (controller == '@') {
                  controller = attrs[directive.name];
                }
                $element.data('$' + directive.name + 'Controller', $controller(controller, locals));
              });
            }
            for (i = 0, ii = preLinkFns.length; i < ii; i++) {
              try {
                linkFn = preLinkFns[i];
                linkFn(scope, $element, attrs, linkFn.require && getControllers(linkFn.require, $element));
              } catch (e) {
                $exceptionHandler(e, startingTag($element));
              }
            }
            childLinkFn && childLinkFn(scope, linkNode.childNodes, undefined, boundTranscludeFn);
            for (i = 0, ii = postLinkFns.length; i < ii; i++) {
              try {
                linkFn = postLinkFns[i];
                linkFn(scope, $element, attrs, linkFn.require && getControllers(linkFn.require, $element));
              } catch (e) {
                $exceptionHandler(e, startingTag($element));
              }
            }
          }
        }
        function addDirective(tDirectives, name, location, maxPriority) {
          var match = false;
          if (hasDirectives.hasOwnProperty(name)) {
            for (var directive, directives = $injector.get(name + Suffix), i = 0, ii = directives.length; i < ii; i++) {
              try {
                directive = directives[i];
                if ((maxPriority === undefined || maxPriority > directive.priority) && directive.restrict.indexOf(location) != -1) {
                  tDirectives.push(directive);
                  match = true;
                }
              } catch (e) {
                $exceptionHandler(e);
              }
            }
          }
          return match;
        }
        function mergeTemplateAttributes(dst, src) {
          var srcAttr = src.$attr, dstAttr = dst.$attr, $element = dst.$$element;
          forEach(dst, function (value, key) {
            if (key.charAt(0) != '$') {
              if (src[key]) {
                value += (key === 'style' ? ';' : ' ') + src[key];
              }
              dst.$set(key, value, true, srcAttr[key]);
            }
          });
          forEach(src, function (value, key) {
            if (key == 'class') {
              safeAddClass($element, value);
              dst['class'] = (dst['class'] ? dst['class'] + ' ' : '') + value;
            } else if (key == 'style') {
              $element.attr('style', $element.attr('style') + ';' + value);
            } else if (key.charAt(0) != '$' && !dst.hasOwnProperty(key)) {
              dst[key] = value;
              dstAttr[key] = srcAttr[key];
            }
          });
        }
        function compileTemplateUrl(directives, beforeTemplateNodeLinkFn, $compileNode, tAttrs, $rootElement, replace, childTranscludeFn) {
          var linkQueue = [], afterTemplateNodeLinkFn, afterTemplateChildLinkFn, beforeTemplateCompileNode = $compileNode[0], origAsyncDirective = directives.shift(), derivedSyncDirective = extend({}, origAsyncDirective, {
              controller: null,
              templateUrl: null,
              transclude: null,
              scope: null
            });
          $compileNode.html('');
          $http.get(origAsyncDirective.templateUrl, { cache: $templateCache }).success(function (content) {
            var compileNode, tempTemplateAttrs, $template;
            content = denormalizeTemplate(content);
            if (replace) {
              $template = jqLite('<div>' + trim(content) + '</div>').contents();
              compileNode = $template[0];
              if ($template.length != 1 || compileNode.nodeType !== 1) {
                throw new Error(MULTI_ROOT_TEMPLATE_ERROR + content);
              }
              tempTemplateAttrs = { $attr: {} };
              replaceWith($rootElement, $compileNode, compileNode);
              collectDirectives(compileNode, directives, tempTemplateAttrs);
              mergeTemplateAttributes(tAttrs, tempTemplateAttrs);
            } else {
              compileNode = beforeTemplateCompileNode;
              $compileNode.html(content);
            }
            directives.unshift(derivedSyncDirective);
            afterTemplateNodeLinkFn = applyDirectivesToNode(directives, compileNode, tAttrs, childTranscludeFn);
            afterTemplateChildLinkFn = compileNodes($compileNode[0].childNodes, childTranscludeFn);
            while (linkQueue.length) {
              var controller = linkQueue.pop(), linkRootElement = linkQueue.pop(), beforeTemplateLinkNode = linkQueue.pop(), scope = linkQueue.pop(), linkNode = compileNode;
              if (beforeTemplateLinkNode !== beforeTemplateCompileNode) {
                linkNode = JQLiteClone(compileNode);
                replaceWith(linkRootElement, jqLite(beforeTemplateLinkNode), linkNode);
              }
              afterTemplateNodeLinkFn(function () {
                beforeTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, linkNode, $rootElement, controller);
              }, scope, linkNode, $rootElement, controller);
            }
            linkQueue = null;
          }).error(function (response, code, headers, config) {
            throw Error('Failed to load template: ' + config.url);
          });
          return function delayedNodeLinkFn(ignoreChildLinkFn, scope, node, rootElement, controller) {
            if (linkQueue) {
              linkQueue.push(scope);
              linkQueue.push(node);
              linkQueue.push(rootElement);
              linkQueue.push(controller);
            } else {
              afterTemplateNodeLinkFn(function () {
                beforeTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, node, rootElement, controller);
              }, scope, node, rootElement, controller);
            }
          };
        }
        function byPriority(a, b) {
          return b.priority - a.priority;
        }
        function assertNoDuplicate(what, previousDirective, directive, element) {
          if (previousDirective) {
            throw Error('Multiple directives [' + previousDirective.name + ', ' + directive.name + '] asking for ' + what + ' on: ' + startingTag(element));
          }
        }
        function addTextInterpolateDirective(directives, text) {
          var interpolateFn = $interpolate(text, true);
          if (interpolateFn) {
            directives.push({
              priority: 0,
              compile: valueFn(function textInterpolateLinkFn(scope, node) {
                var parent = node.parent(), bindings = parent.data('$binding') || [];
                bindings.push(interpolateFn);
                safeAddClass(parent.data('$binding', bindings), 'ng-binding');
                scope.$watch(interpolateFn, function interpolateFnWatchAction(value) {
                  node[0].nodeValue = value;
                });
              })
            });
          }
        }
        function addAttrInterpolateDirective(node, directives, value, name) {
          var interpolateFn = $interpolate(value, true);
          if (!interpolateFn)
            return;
          directives.push({
            priority: 100,
            compile: valueFn(function attrInterpolateLinkFn(scope, element, attr) {
              var $$observers = attr.$$observers || (attr.$$observers = {});
              if (name === 'class') {
                interpolateFn = $interpolate(attr[name], true);
              }
              attr[name] = undefined;
              ($$observers[name] || ($$observers[name] = [])).$$inter = true;
              (attr.$$observers && attr.$$observers[name].$$scope || scope).$watch(interpolateFn, function interpolateFnWatchAction(value) {
                attr.$set(name, value);
              });
            })
          });
        }
        function replaceWith($rootElement, $element, newNode) {
          var oldNode = $element[0], parent = oldNode.parentNode, i, ii;
          if ($rootElement) {
            for (i = 0, ii = $rootElement.length; i < ii; i++) {
              if ($rootElement[i] == oldNode) {
                $rootElement[i] = newNode;
                break;
              }
            }
          }
          if (parent) {
            parent.replaceChild(newNode, oldNode);
          }
          newNode[jqLite.expando] = oldNode[jqLite.expando];
          $element[0] = newNode;
        }
      }
    ];
  }
  var PREFIX_REGEXP = /^(x[\:\-_]|data[\:\-_])/i;
  function directiveNormalize(name) {
    return camelCase(name.replace(PREFIX_REGEXP, ''));
  }
  function nodesetLinkingFn(scope, nodeList, rootElement, boundTranscludeFn) {
  }
  function directiveLinkingFn(nodesetLinkingFn, scope, node, rootElement, boundTranscludeFn) {
  }
  function $ControllerProvider() {
    var controllers = {};
    this.register = function (name, constructor) {
      if (isObject(name)) {
        extend(controllers, name);
      } else {
        controllers[name] = constructor;
      }
    };
    this.$get = [
      '$injector',
      '$window',
      function ($injector, $window) {
        return function (constructor, locals) {
          if (isString(constructor)) {
            var name = constructor;
            constructor = controllers.hasOwnProperty(name) ? controllers[name] : getter(locals.$scope, name, true) || getter($window, name, true);
            assertArgFn(constructor, name, true);
          }
          return $injector.instantiate(constructor, locals);
        };
      }
    ];
  }
  function $DocumentProvider() {
    this.$get = [
      '$window',
      function (window) {
        return jqLite(window.document);
      }
    ];
  }
  function $ExceptionHandlerProvider() {
    this.$get = [
      '$log',
      function ($log) {
        return function (exception, cause) {
          $log.error.apply($log, arguments);
        };
      }
    ];
  }
  function $InterpolateProvider() {
    var startSymbol = '{{';
    var endSymbol = '}}';
    this.startSymbol = function (value) {
      if (value) {
        startSymbol = value;
        return this;
      } else {
        return startSymbol;
      }
    };
    this.endSymbol = function (value) {
      if (value) {
        endSymbol = value;
        return this;
      } else {
        return endSymbol;
      }
    };
    this.$get = [
      '$parse',
      function ($parse) {
        var startSymbolLength = startSymbol.length, endSymbolLength = endSymbol.length;
        function $interpolate(text, mustHaveExpression) {
          var startIndex, endIndex, index = 0, parts = [], length = text.length, hasInterpolation = false, fn, exp, concat = [];
          while (index < length) {
            if ((startIndex = text.indexOf(startSymbol, index)) != -1 && (endIndex = text.indexOf(endSymbol, startIndex + startSymbolLength)) != -1) {
              index != startIndex && parts.push(text.substring(index, startIndex));
              parts.push(fn = $parse(exp = text.substring(startIndex + startSymbolLength, endIndex)));
              fn.exp = exp;
              index = endIndex + endSymbolLength;
              hasInterpolation = true;
            } else {
              index != length && parts.push(text.substring(index));
              index = length;
            }
          }
          if (!(length = parts.length)) {
            parts.push('');
            length = 1;
          }
          if (!mustHaveExpression || hasInterpolation) {
            concat.length = length;
            fn = function (context) {
              for (var i = 0, ii = length, part; i < ii; i++) {
                if (typeof (part = parts[i]) == 'function') {
                  part = part(context);
                  if (part == null || part == undefined) {
                    part = '';
                  } else if (typeof part != 'string') {
                    part = toJson(part);
                  }
                }
                concat[i] = part;
              }
              return concat.join('');
            };
            fn.exp = text;
            fn.parts = parts;
            return fn;
          }
        }
        $interpolate.startSymbol = function () {
          return startSymbol;
        };
        $interpolate.endSymbol = function () {
          return endSymbol;
        };
        return $interpolate;
      }
    ];
  }
  var URL_MATCH = /^([^:]+):\/\/(\w+:{0,1}\w*@)?(\{?[\w\.-]*\}?)(:([0-9]+))?(\/[^\?#]*)?(\?([^#]*))?(#(.*))?$/, PATH_MATCH = /^([^\?#]*)?(\?([^#]*))?(#(.*))?$/, HASH_MATCH = PATH_MATCH, DEFAULT_PORTS = {
      'http': 80,
      'https': 443,
      'ftp': 21
    };
  function encodePath(path) {
    var segments = path.split('/'), i = segments.length;
    while (i--) {
      segments[i] = encodeUriSegment(segments[i]);
    }
    return segments.join('/');
  }
  function stripHash(url) {
    return url.split('#')[0];
  }
  function matchUrl(url, obj) {
    var match = URL_MATCH.exec(url);
    match = {
      protocol: match[1],
      host: match[3],
      port: int(match[5]) || DEFAULT_PORTS[match[1]] || null,
      path: match[6] || '/',
      search: match[8],
      hash: match[10]
    };
    if (obj) {
      obj.$$protocol = match.protocol;
      obj.$$host = match.host;
      obj.$$port = match.port;
    }
    return match;
  }
  function composeProtocolHostPort(protocol, host, port) {
    return protocol + '://' + host + (port == DEFAULT_PORTS[protocol] ? '' : ':' + port);
  }
  function pathPrefixFromBase(basePath) {
    return basePath.substr(0, basePath.lastIndexOf('/'));
  }
  function convertToHtml5Url(url, basePath, hashPrefix) {
    var match = matchUrl(url);
    if (decodeURIComponent(match.path) != basePath || isUndefined(match.hash) || match.hash.indexOf(hashPrefix) !== 0) {
      return url;
    } else {
      return composeProtocolHostPort(match.protocol, match.host, match.port) + pathPrefixFromBase(basePath) + match.hash.substr(hashPrefix.length);
    }
  }
  function convertToHashbangUrl(url, basePath, hashPrefix) {
    var match = matchUrl(url);
    if (decodeURIComponent(match.path) == basePath && !isUndefined(match.hash) && match.hash.indexOf(hashPrefix) === 0) {
      return url;
    } else {
      var search = match.search && '?' + match.search || '', hash = match.hash && '#' + match.hash || '', pathPrefix = pathPrefixFromBase(basePath), path = match.path.substr(pathPrefix.length);
      if (match.path.indexOf(pathPrefix) !== 0) {
        throw Error('Invalid url "' + url + '", missing path prefix "' + pathPrefix + '" !');
      }
      return composeProtocolHostPort(match.protocol, match.host, match.port) + basePath + '#' + hashPrefix + path + search + hash;
    }
  }
  function LocationUrl(url, pathPrefix, appBaseUrl) {
    pathPrefix = pathPrefix || '';
    this.$$parse = function (newAbsoluteUrl) {
      var match = matchUrl(newAbsoluteUrl, this);
      if (match.path.indexOf(pathPrefix) !== 0) {
        throw Error('Invalid url "' + newAbsoluteUrl + '", missing path prefix "' + pathPrefix + '" !');
      }
      this.$$path = decodeURIComponent(match.path.substr(pathPrefix.length));
      this.$$search = parseKeyValue(match.search);
      this.$$hash = match.hash && decodeURIComponent(match.hash) || '';
      this.$$compose();
    };
    this.$$compose = function () {
      var search = toKeyValue(this.$$search), hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
      this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
      this.$$absUrl = composeProtocolHostPort(this.$$protocol, this.$$host, this.$$port) + pathPrefix + this.$$url;
    };
    this.$$rewriteAppUrl = function (absoluteLinkUrl) {
      if (absoluteLinkUrl.indexOf(appBaseUrl) == 0) {
        return absoluteLinkUrl;
      }
    };
    this.$$parse(url);
  }
  function LocationHashbangUrl(url, hashPrefix, appBaseUrl) {
    var basePath;
    this.$$parse = function (url) {
      var match = matchUrl(url, this);
      if (match.hash && match.hash.indexOf(hashPrefix) !== 0) {
        throw Error('Invalid url "' + url + '", missing hash prefix "' + hashPrefix + '" !');
      }
      basePath = match.path + (match.search ? '?' + match.search : '');
      match = HASH_MATCH.exec((match.hash || '').substr(hashPrefix.length));
      if (match[1]) {
        this.$$path = (match[1].charAt(0) == '/' ? '' : '/') + decodeURIComponent(match[1]);
      } else {
        this.$$path = '';
      }
      this.$$search = parseKeyValue(match[3]);
      this.$$hash = match[5] && decodeURIComponent(match[5]) || '';
      this.$$compose();
    };
    this.$$compose = function () {
      var search = toKeyValue(this.$$search), hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
      this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
      this.$$absUrl = composeProtocolHostPort(this.$$protocol, this.$$host, this.$$port) + basePath + (this.$$url ? '#' + hashPrefix + this.$$url : '');
    };
    this.$$rewriteAppUrl = function (absoluteLinkUrl) {
      if (absoluteLinkUrl.indexOf(appBaseUrl) == 0) {
        return absoluteLinkUrl;
      }
    };
    this.$$parse(url);
  }
  LocationUrl.prototype = {
    $$replace: false,
    absUrl: locationGetter('$$absUrl'),
    url: function (url, replace) {
      if (isUndefined(url))
        return this.$$url;
      var match = PATH_MATCH.exec(url);
      if (match[1])
        this.path(decodeURIComponent(match[1]));
      if (match[2] || match[1])
        this.search(match[3] || '');
      this.hash(match[5] || '', replace);
      return this;
    },
    protocol: locationGetter('$$protocol'),
    host: locationGetter('$$host'),
    port: locationGetter('$$port'),
    path: locationGetterSetter('$$path', function (path) {
      return path.charAt(0) == '/' ? path : '/' + path;
    }),
    search: function (search, paramValue) {
      if (isUndefined(search))
        return this.$$search;
      if (isDefined(paramValue)) {
        if (paramValue === null) {
          delete this.$$search[search];
        } else {
          this.$$search[search] = paramValue;
        }
      } else {
        this.$$search = isString(search) ? parseKeyValue(search) : search;
      }
      this.$$compose();
      return this;
    },
    hash: locationGetterSetter('$$hash', identity),
    replace: function () {
      this.$$replace = true;
      return this;
    }
  };
  LocationHashbangUrl.prototype = inherit(LocationUrl.prototype);
  function LocationHashbangInHtml5Url(url, hashPrefix, appBaseUrl, baseExtra) {
    LocationHashbangUrl.apply(this, arguments);
    this.$$rewriteAppUrl = function (absoluteLinkUrl) {
      if (absoluteLinkUrl.indexOf(appBaseUrl) == 0) {
        return appBaseUrl + baseExtra + '#' + hashPrefix + absoluteLinkUrl.substr(appBaseUrl.length);
      }
    };
  }
  LocationHashbangInHtml5Url.prototype = inherit(LocationHashbangUrl.prototype);
  function locationGetter(property) {
    return function () {
      return this[property];
    };
  }
  function locationGetterSetter(property, preprocess) {
    return function (value) {
      if (isUndefined(value))
        return this[property];
      this[property] = preprocess(value);
      this.$$compose();
      return this;
    };
  }
  function $LocationProvider() {
    var hashPrefix = '', html5Mode = false;
    this.hashPrefix = function (prefix) {
      if (isDefined(prefix)) {
        hashPrefix = prefix;
        return this;
      } else {
        return hashPrefix;
      }
    };
    this.html5Mode = function (mode) {
      if (isDefined(mode)) {
        html5Mode = mode;
        return this;
      } else {
        return html5Mode;
      }
    };
    this.$get = [
      '$rootScope',
      '$browser',
      '$sniffer',
      '$rootElement',
      function ($rootScope, $browser, $sniffer, $rootElement) {
        var $location, basePath, pathPrefix, initUrl = $browser.url(), initUrlParts = matchUrl(initUrl), appBaseUrl;
        if (html5Mode) {
          basePath = $browser.baseHref() || '/';
          pathPrefix = pathPrefixFromBase(basePath);
          appBaseUrl = composeProtocolHostPort(initUrlParts.protocol, initUrlParts.host, initUrlParts.port) + pathPrefix + '/';
          if ($sniffer.history) {
            $location = new LocationUrl(convertToHtml5Url(initUrl, basePath, hashPrefix), pathPrefix, appBaseUrl);
          } else {
            $location = new LocationHashbangInHtml5Url(convertToHashbangUrl(initUrl, basePath, hashPrefix), hashPrefix, appBaseUrl, basePath.substr(pathPrefix.length + 1));
          }
        } else {
          appBaseUrl = composeProtocolHostPort(initUrlParts.protocol, initUrlParts.host, initUrlParts.port) + (initUrlParts.path || '') + (initUrlParts.search ? '?' + initUrlParts.search : '') + '#' + hashPrefix + '/';
          $location = new LocationHashbangUrl(initUrl, hashPrefix, appBaseUrl);
        }
        $rootElement.bind('click', function (event) {
          if (event.ctrlKey || event.metaKey || event.which == 2)
            return;
          var elm = jqLite(event.target);
          while (lowercase(elm[0].nodeName) !== 'a') {
            if (elm[0] === $rootElement[0] || !(elm = elm.parent())[0])
              return;
          }
          var absHref = elm.prop('href'), rewrittenUrl = $location.$$rewriteAppUrl(absHref);
          if (absHref && !elm.attr('target') && rewrittenUrl) {
            $location.$$parse(rewrittenUrl);
            $rootScope.$apply();
            event.preventDefault();
            window.angular['ff-684208-preventDefault'] = true;
          }
        });
        if ($location.absUrl() != initUrl) {
          $browser.url($location.absUrl(), true);
        }
        $browser.onUrlChange(function (newUrl) {
          if ($location.absUrl() != newUrl) {
            if ($rootScope.$broadcast('$locationChangeStart', newUrl, $location.absUrl()).defaultPrevented) {
              $browser.url($location.absUrl());
              return;
            }
            $rootScope.$evalAsync(function () {
              var oldUrl = $location.absUrl();
              $location.$$parse(newUrl);
              afterLocationChange(oldUrl);
            });
            if (!$rootScope.$$phase)
              $rootScope.$digest();
          }
        });
        var changeCounter = 0;
        $rootScope.$watch(function $locationWatch() {
          var oldUrl = $browser.url();
          var currentReplace = $location.$$replace;
          if (!changeCounter || oldUrl != $location.absUrl()) {
            changeCounter++;
            $rootScope.$evalAsync(function () {
              if ($rootScope.$broadcast('$locationChangeStart', $location.absUrl(), oldUrl).defaultPrevented) {
                $location.$$parse(oldUrl);
              } else {
                $browser.url($location.absUrl(), currentReplace);
                afterLocationChange(oldUrl);
              }
            });
          }
          $location.$$replace = false;
          return changeCounter;
        });
        return $location;
        function afterLocationChange(oldUrl) {
          $rootScope.$broadcast('$locationChangeSuccess', $location.absUrl(), oldUrl);
        }
      }
    ];
  }
  function $LogProvider() {
    this.$get = [
      '$window',
      function ($window) {
        return {
          log: consoleLog('log'),
          warn: consoleLog('warn'),
          info: consoleLog('info'),
          error: consoleLog('error')
        };
        function formatError(arg) {
          if (arg instanceof Error) {
            if (arg.stack) {
              arg = arg.message && arg.stack.indexOf(arg.message) === -1 ? 'Error: ' + arg.message + '\n' + arg.stack : arg.stack;
            } else if (arg.sourceURL) {
              arg = arg.message + '\n' + arg.sourceURL + ':' + arg.line;
            }
          }
          return arg;
        }
        function consoleLog(type) {
          var console = $window.console || {}, logFn = console[type] || console.log || noop;
          if (logFn.apply) {
            return function () {
              var args = [];
              forEach(arguments, function (arg) {
                args.push(formatError(arg));
              });
              return logFn.apply(console, args);
            };
          }
          return function (arg1, arg2) {
            logFn(arg1, arg2);
          };
        }
      }
    ];
  }
  var OPERATORS = {
      'null': function () {
        return null;
      },
      'true': function () {
        return true;
      },
      'false': function () {
        return false;
      },
      undefined: noop,
      '+': function (self, locals, a, b) {
        a = a(self, locals);
        b = b(self, locals);
        if (isDefined(a)) {
          if (isDefined(b)) {
            return a + b;
          }
          return a;
        }
        return isDefined(b) ? b : undefined;
      },
      '-': function (self, locals, a, b) {
        a = a(self, locals);
        b = b(self, locals);
        return (isDefined(a) ? a : 0) - (isDefined(b) ? b : 0);
      },
      '*': function (self, locals, a, b) {
        return a(self, locals) * b(self, locals);
      },
      '/': function (self, locals, a, b) {
        return a(self, locals) / b(self, locals);
      },
      '%': function (self, locals, a, b) {
        return a(self, locals) % b(self, locals);
      },
      '^': function (self, locals, a, b) {
        return a(self, locals) ^ b(self, locals);
      },
      '=': noop,
      '==': function (self, locals, a, b) {
        return a(self, locals) == b(self, locals);
      },
      '!=': function (self, locals, a, b) {
        return a(self, locals) != b(self, locals);
      },
      '<': function (self, locals, a, b) {
        return a(self, locals) < b(self, locals);
      },
      '>': function (self, locals, a, b) {
        return a(self, locals) > b(self, locals);
      },
      '<=': function (self, locals, a, b) {
        return a(self, locals) <= b(self, locals);
      },
      '>=': function (self, locals, a, b) {
        return a(self, locals) >= b(self, locals);
      },
      '&&': function (self, locals, a, b) {
        return a(self, locals) && b(self, locals);
      },
      '||': function (self, locals, a, b) {
        return a(self, locals) || b(self, locals);
      },
      '&': function (self, locals, a, b) {
        return a(self, locals) & b(self, locals);
      },
      '|': function (self, locals, a, b) {
        return b(self, locals)(self, locals, a(self, locals));
      },
      '!': function (self, locals, a) {
        return !a(self, locals);
      }
    };
  var ESCAPE = {
      'n': '\n',
      'f': '\f',
      'r': '\r',
      't': '\t',
      'v': '\x0B',
      '\'': '\'',
      '"': '"'
    };
  function lex(text, csp) {
    var tokens = [], token, index = 0, json = [], ch, lastCh = ':';
    while (index < text.length) {
      ch = text.charAt(index);
      if (is('"\'')) {
        readString(ch);
      } else if (isNumber(ch) || is('.') && isNumber(peek())) {
        readNumber();
      } else if (isIdent(ch)) {
        readIdent();
        if (was('{,') && json[0] == '{' && (token = tokens[tokens.length - 1])) {
          token.json = token.text.indexOf('.') == -1;
        }
      } else if (is('(){}[].,;:')) {
        tokens.push({
          index: index,
          text: ch,
          json: was(':[,') && is('{[') || is('}]:,')
        });
        if (is('{['))
          json.unshift(ch);
        if (is('}]'))
          json.shift();
        index++;
      } else if (isWhitespace(ch)) {
        index++;
        continue;
      } else {
        var ch2 = ch + peek(), fn = OPERATORS[ch], fn2 = OPERATORS[ch2];
        if (fn2) {
          tokens.push({
            index: index,
            text: ch2,
            fn: fn2
          });
          index += 2;
        } else if (fn) {
          tokens.push({
            index: index,
            text: ch,
            fn: fn,
            json: was('[,:') && is('+-')
          });
          index += 1;
        } else {
          throwError('Unexpected next character ', index, index + 1);
        }
      }
      lastCh = ch;
    }
    return tokens;
    function is(chars) {
      return chars.indexOf(ch) != -1;
    }
    function was(chars) {
      return chars.indexOf(lastCh) != -1;
    }
    function peek() {
      return index + 1 < text.length ? text.charAt(index + 1) : false;
    }
    function isNumber(ch) {
      return '0' <= ch && ch <= '9';
    }
    function isWhitespace(ch) {
      return ch == ' ' || ch == '\r' || ch == '\t' || ch == '\n' || ch == '\x0B' || ch == '\xa0';
    }
    function isIdent(ch) {
      return 'a' <= ch && ch <= 'z' || 'A' <= ch && ch <= 'Z' || '_' == ch || ch == '$';
    }
    function isExpOperator(ch) {
      return ch == '-' || ch == '+' || isNumber(ch);
    }
    function throwError(error, start, end) {
      end = end || index;
      throw Error('Lexer Error: ' + error + ' at column' + (isDefined(start) ? 's ' + start + '-' + index + ' [' + text.substring(start, end) + ']' : ' ' + end) + ' in expression [' + text + '].');
    }
    function readNumber() {
      var number = '';
      var start = index;
      while (index < text.length) {
        var ch = lowercase(text.charAt(index));
        if (ch == '.' || isNumber(ch)) {
          number += ch;
        } else {
          var peekCh = peek();
          if (ch == 'e' && isExpOperator(peekCh)) {
            number += ch;
          } else if (isExpOperator(ch) && peekCh && isNumber(peekCh) && number.charAt(number.length - 1) == 'e') {
            number += ch;
          } else if (isExpOperator(ch) && (!peekCh || !isNumber(peekCh)) && number.charAt(number.length - 1) == 'e') {
            throwError('Invalid exponent');
          } else {
            break;
          }
        }
        index++;
      }
      number = 1 * number;
      tokens.push({
        index: start,
        text: number,
        json: true,
        fn: function () {
          return number;
        }
      });
    }
    function readIdent() {
      var ident = '', start = index, lastDot, peekIndex, methodName, ch;
      while (index < text.length) {
        ch = text.charAt(index);
        if (ch == '.' || isIdent(ch) || isNumber(ch)) {
          if (ch == '.')
            lastDot = index;
          ident += ch;
        } else {
          break;
        }
        index++;
      }
      if (lastDot) {
        peekIndex = index;
        while (peekIndex < text.length) {
          ch = text.charAt(peekIndex);
          if (ch == '(') {
            methodName = ident.substr(lastDot - start + 1);
            ident = ident.substr(0, lastDot - start);
            index = peekIndex;
            break;
          }
          if (isWhitespace(ch)) {
            peekIndex++;
          } else {
            break;
          }
        }
      }
      var token = {
          index: start,
          text: ident
        };
      if (OPERATORS.hasOwnProperty(ident)) {
        token.fn = token.json = OPERATORS[ident];
      } else {
        var getter = getterFn(ident, csp);
        token.fn = extend(function (self, locals) {
          return getter(self, locals);
        }, {
          assign: function (self, value) {
            return setter(self, ident, value);
          }
        });
      }
      tokens.push(token);
      if (methodName) {
        tokens.push({
          index: lastDot,
          text: '.',
          json: false
        });
        tokens.push({
          index: lastDot + 1,
          text: methodName,
          json: false
        });
      }
    }
    function readString(quote) {
      var start = index;
      index++;
      var string = '';
      var rawString = quote;
      var escape = false;
      while (index < text.length) {
        var ch = text.charAt(index);
        rawString += ch;
        if (escape) {
          if (ch == 'u') {
            var hex = text.substring(index + 1, index + 5);
            if (!hex.match(/[\da-f]{4}/i))
              throwError('Invalid unicode escape [\\u' + hex + ']');
            index += 4;
            string += String.fromCharCode(parseInt(hex, 16));
          } else {
            var rep = ESCAPE[ch];
            if (rep) {
              string += rep;
            } else {
              string += ch;
            }
          }
          escape = false;
        } else if (ch == '\\') {
          escape = true;
        } else if (ch == quote) {
          index++;
          tokens.push({
            index: start,
            text: rawString,
            string: string,
            json: true,
            fn: function () {
              return string;
            }
          });
          return;
        } else {
          string += ch;
        }
        index++;
      }
      throwError('Unterminated quote', start);
    }
  }
  function parser(text, json, $filter, csp) {
    var ZERO = valueFn(0), value, tokens = lex(text, csp), assignment = _assignment, functionCall = _functionCall, fieldAccess = _fieldAccess, objectIndex = _objectIndex, filterChain = _filterChain;
    if (json) {
      assignment = logicalOR;
      functionCall = fieldAccess = objectIndex = filterChain = function () {
        throwError('is not valid json', {
          text: text,
          index: 0
        });
      };
      value = primary();
    } else {
      value = statements();
    }
    if (tokens.length !== 0) {
      throwError('is an unexpected token', tokens[0]);
    }
    return value;
    function throwError(msg, token) {
      throw Error('Syntax Error: Token \'' + token.text + '\' ' + msg + ' at column ' + (token.index + 1) + ' of the expression [' + text + '] starting at [' + text.substring(token.index) + '].');
    }
    function peekToken() {
      if (tokens.length === 0)
        throw Error('Unexpected end of expression: ' + text);
      return tokens[0];
    }
    function peek(e1, e2, e3, e4) {
      if (tokens.length > 0) {
        var token = tokens[0];
        var t = token.text;
        if (t == e1 || t == e2 || t == e3 || t == e4 || !e1 && !e2 && !e3 && !e4) {
          return token;
        }
      }
      return false;
    }
    function expect(e1, e2, e3, e4) {
      var token = peek(e1, e2, e3, e4);
      if (token) {
        if (json && !token.json) {
          throwError('is not valid json', token);
        }
        tokens.shift();
        return token;
      }
      return false;
    }
    function consume(e1) {
      if (!expect(e1)) {
        throwError('is unexpected, expecting [' + e1 + ']', peek());
      }
    }
    function unaryFn(fn, right) {
      return function (self, locals) {
        return fn(self, locals, right);
      };
    }
    function binaryFn(left, fn, right) {
      return function (self, locals) {
        return fn(self, locals, left, right);
      };
    }
    function statements() {
      var statements = [];
      while (true) {
        if (tokens.length > 0 && !peek('}', ')', ';', ']'))
          statements.push(filterChain());
        if (!expect(';')) {
          return statements.length == 1 ? statements[0] : function (self, locals) {
            var value;
            for (var i = 0; i < statements.length; i++) {
              var statement = statements[i];
              if (statement)
                value = statement(self, locals);
            }
            return value;
          };
        }
      }
    }
    function _filterChain() {
      var left = expression();
      var token;
      while (true) {
        if (token = expect('|')) {
          left = binaryFn(left, token.fn, filter());
        } else {
          return left;
        }
      }
    }
    function filter() {
      var token = expect();
      var fn = $filter(token.text);
      var argsFn = [];
      while (true) {
        if (token = expect(':')) {
          argsFn.push(expression());
        } else {
          var fnInvoke = function (self, locals, input) {
            var args = [input];
            for (var i = 0; i < argsFn.length; i++) {
              args.push(argsFn[i](self, locals));
            }
            return fn.apply(self, args);
          };
          return function () {
            return fnInvoke;
          };
        }
      }
    }
    function expression() {
      return assignment();
    }
    function _assignment() {
      var left = logicalOR();
      var right;
      var token;
      if (token = expect('=')) {
        if (!left.assign) {
          throwError('implies assignment but [' + text.substring(0, token.index) + '] can not be assigned to', token);
        }
        right = logicalOR();
        return function (scope, locals) {
          return left.assign(scope, right(scope, locals), locals);
        };
      } else {
        return left;
      }
    }
    function logicalOR() {
      var left = logicalAND();
      var token;
      while (true) {
        if (token = expect('||')) {
          left = binaryFn(left, token.fn, logicalAND());
        } else {
          return left;
        }
      }
    }
    function logicalAND() {
      var left = equality();
      var token;
      if (token = expect('&&')) {
        left = binaryFn(left, token.fn, logicalAND());
      }
      return left;
    }
    function equality() {
      var left = relational();
      var token;
      if (token = expect('==', '!=')) {
        left = binaryFn(left, token.fn, equality());
      }
      return left;
    }
    function relational() {
      var left = additive();
      var token;
      if (token = expect('<', '>', '<=', '>=')) {
        left = binaryFn(left, token.fn, relational());
      }
      return left;
    }
    function additive() {
      var left = multiplicative();
      var token;
      while (token = expect('+', '-')) {
        left = binaryFn(left, token.fn, multiplicative());
      }
      return left;
    }
    function multiplicative() {
      var left = unary();
      var token;
      while (token = expect('*', '/', '%')) {
        left = binaryFn(left, token.fn, unary());
      }
      return left;
    }
    function unary() {
      var token;
      if (expect('+')) {
        return primary();
      } else if (token = expect('-')) {
        return binaryFn(ZERO, token.fn, unary());
      } else if (token = expect('!')) {
        return unaryFn(token.fn, unary());
      } else {
        return primary();
      }
    }
    function primary() {
      var primary;
      if (expect('(')) {
        primary = filterChain();
        consume(')');
      } else if (expect('[')) {
        primary = arrayDeclaration();
      } else if (expect('{')) {
        primary = object();
      } else {
        var token = expect();
        primary = token.fn;
        if (!primary) {
          throwError('not a primary expression', token);
        }
      }
      var next, context;
      while (next = expect('(', '[', '.')) {
        if (next.text === '(') {
          primary = functionCall(primary, context);
          context = null;
        } else if (next.text === '[') {
          context = primary;
          primary = objectIndex(primary);
        } else if (next.text === '.') {
          context = primary;
          primary = fieldAccess(primary);
        } else {
          throwError('IMPOSSIBLE');
        }
      }
      return primary;
    }
    function _fieldAccess(object) {
      var field = expect().text;
      var getter = getterFn(field, csp);
      return extend(function (scope, locals, self) {
        return getter(self || object(scope, locals), locals);
      }, {
        assign: function (scope, value, locals) {
          return setter(object(scope, locals), field, value);
        }
      });
    }
    function _objectIndex(obj) {
      var indexFn = expression();
      consume(']');
      return extend(function (self, locals) {
        var o = obj(self, locals), i = indexFn(self, locals), v, p;
        if (!o)
          return undefined;
        v = o[i];
        if (v && v.then) {
          p = v;
          if (!('$$v' in v)) {
            p.$$v = undefined;
            p.then(function (val) {
              p.$$v = val;
            });
          }
          v = v.$$v;
        }
        return v;
      }, {
        assign: function (self, value, locals) {
          return obj(self, locals)[indexFn(self, locals)] = value;
        }
      });
    }
    function _functionCall(fn, contextGetter) {
      var argsFn = [];
      if (peekToken().text != ')') {
        do {
          argsFn.push(expression());
        } while (expect(','));
      }
      consume(')');
      return function (scope, locals) {
        var args = [], context = contextGetter ? contextGetter(scope, locals) : scope;
        for (var i = 0; i < argsFn.length; i++) {
          args.push(argsFn[i](scope, locals));
        }
        var fnPtr = fn(scope, locals, context) || noop;
        return fnPtr.apply ? fnPtr.apply(context, args) : fnPtr(args[0], args[1], args[2], args[3], args[4]);
      };
    }
    function arrayDeclaration() {
      var elementFns = [];
      if (peekToken().text != ']') {
        do {
          elementFns.push(expression());
        } while (expect(','));
      }
      consume(']');
      return function (self, locals) {
        var array = [];
        for (var i = 0; i < elementFns.length; i++) {
          array.push(elementFns[i](self, locals));
        }
        return array;
      };
    }
    function object() {
      var keyValues = [];
      if (peekToken().text != '}') {
        do {
          var token = expect(), key = token.string || token.text;
          consume(':');
          var value = expression();
          keyValues.push({
            key: key,
            value: value
          });
        } while (expect(','));
      }
      consume('}');
      return function (self, locals) {
        var object = {};
        for (var i = 0; i < keyValues.length; i++) {
          var keyValue = keyValues[i];
          object[keyValue.key] = keyValue.value(self, locals);
        }
        return object;
      };
    }
  }
  function setter(obj, path, setValue) {
    var element = path.split('.');
    for (var i = 0; element.length > 1; i++) {
      var key = element.shift();
      var propertyObj = obj[key];
      if (!propertyObj) {
        propertyObj = {};
        obj[key] = propertyObj;
      }
      obj = propertyObj;
    }
    obj[element.shift()] = setValue;
    return setValue;
  }
  var getterFnCache = {};
  function cspSafeGetterFn(key0, key1, key2, key3, key4) {
    return function (scope, locals) {
      var pathVal = locals && locals.hasOwnProperty(key0) ? locals : scope, promise;
      if (pathVal === null || pathVal === undefined)
        return pathVal;
      pathVal = pathVal[key0];
      if (pathVal && pathVal.then) {
        if (!('$$v' in pathVal)) {
          promise = pathVal;
          promise.$$v = undefined;
          promise.then(function (val) {
            promise.$$v = val;
          });
        }
        pathVal = pathVal.$$v;
      }
      if (!key1 || pathVal === null || pathVal === undefined)
        return pathVal;
      pathVal = pathVal[key1];
      if (pathVal && pathVal.then) {
        if (!('$$v' in pathVal)) {
          promise = pathVal;
          promise.$$v = undefined;
          promise.then(function (val) {
            promise.$$v = val;
          });
        }
        pathVal = pathVal.$$v;
      }
      if (!key2 || pathVal === null || pathVal === undefined)
        return pathVal;
      pathVal = pathVal[key2];
      if (pathVal && pathVal.then) {
        if (!('$$v' in pathVal)) {
          promise = pathVal;
          promise.$$v = undefined;
          promise.then(function (val) {
            promise.$$v = val;
          });
        }
        pathVal = pathVal.$$v;
      }
      if (!key3 || pathVal === null || pathVal === undefined)
        return pathVal;
      pathVal = pathVal[key3];
      if (pathVal && pathVal.then) {
        if (!('$$v' in pathVal)) {
          promise = pathVal;
          promise.$$v = undefined;
          promise.then(function (val) {
            promise.$$v = val;
          });
        }
        pathVal = pathVal.$$v;
      }
      if (!key4 || pathVal === null || pathVal === undefined)
        return pathVal;
      pathVal = pathVal[key4];
      if (pathVal && pathVal.then) {
        if (!('$$v' in pathVal)) {
          promise = pathVal;
          promise.$$v = undefined;
          promise.then(function (val) {
            promise.$$v = val;
          });
        }
        pathVal = pathVal.$$v;
      }
      return pathVal;
    };
  }
  function getterFn(path, csp) {
    if (getterFnCache.hasOwnProperty(path)) {
      return getterFnCache[path];
    }
    var pathKeys = path.split('.'), pathKeysLength = pathKeys.length, fn;
    if (csp) {
      fn = pathKeysLength < 6 ? cspSafeGetterFn(pathKeys[0], pathKeys[1], pathKeys[2], pathKeys[3], pathKeys[4]) : function (scope, locals) {
        var i = 0, val;
        do {
          val = cspSafeGetterFn(pathKeys[i++], pathKeys[i++], pathKeys[i++], pathKeys[i++], pathKeys[i++])(scope, locals);
          locals = undefined;
          scope = val;
        } while (i < pathKeysLength);
        return val;
      };
    } else {
      var code = 'var l, fn, p;\n';
      forEach(pathKeys, function (key, index) {
        code += 'if(s === null || s === undefined) return s;\n' + 'l=s;\n' + 's=' + (index ? 's' : '((k&&k.hasOwnProperty("' + key + '"))?k:s)') + '["' + key + '"]' + ';\n' + 'if (s && s.then) {\n' + ' if (!("$$v" in s)) {\n' + ' p=s;\n' + ' p.$$v = undefined;\n' + ' p.then(function(v) {p.$$v=v;});\n' + '}\n' + ' s=s.$$v\n' + '}\n';
      });
      code += 'return s;';
      fn = Function('s', 'k', code);
      fn.toString = function () {
        return code;
      };
    }
    return getterFnCache[path] = fn;
  }
  function $ParseProvider() {
    var cache = {};
    this.$get = [
      '$filter',
      '$sniffer',
      function ($filter, $sniffer) {
        return function (exp) {
          switch (typeof exp) {
          case 'string':
            return cache.hasOwnProperty(exp) ? cache[exp] : cache[exp] = parser(exp, false, $filter, $sniffer.csp);
          case 'function':
            return exp;
          default:
            return noop;
          }
        };
      }
    ];
  }
  function $QProvider() {
    this.$get = [
      '$rootScope',
      '$exceptionHandler',
      function ($rootScope, $exceptionHandler) {
        return qFactory(function (callback) {
          $rootScope.$evalAsync(callback);
        }, $exceptionHandler);
      }
    ];
  }
  function qFactory(nextTick, exceptionHandler) {
    var defer = function () {
      var pending = [], value, deferred;
      deferred = {
        resolve: function (val) {
          if (pending) {
            var callbacks = pending;
            pending = undefined;
            value = ref(val);
            if (callbacks.length) {
              nextTick(function () {
                var callback;
                for (var i = 0, ii = callbacks.length; i < ii; i++) {
                  callback = callbacks[i];
                  value.then(callback[0], callback[1]);
                }
              });
            }
          }
        },
        reject: function (reason) {
          deferred.resolve(reject(reason));
        },
        promise: {
          then: function (callback, errback) {
            var result = defer();
            var wrappedCallback = function (value) {
              try {
                result.resolve((callback || defaultCallback)(value));
              } catch (e) {
                result.reject(e);
                exceptionHandler(e);
              }
            };
            var wrappedErrback = function (reason) {
              try {
                result.resolve((errback || defaultErrback)(reason));
              } catch (e) {
                result.reject(e);
                exceptionHandler(e);
              }
            };
            if (pending) {
              pending.push([
                wrappedCallback,
                wrappedErrback
              ]);
            } else {
              value.then(wrappedCallback, wrappedErrback);
            }
            return result.promise;
          }
        }
      };
      return deferred;
    };
    var ref = function (value) {
      if (value && value.then)
        return value;
      return {
        then: function (callback) {
          var result = defer();
          nextTick(function () {
            result.resolve(callback(value));
          });
          return result.promise;
        }
      };
    };
    var reject = function (reason) {
      return {
        then: function (callback, errback) {
          var result = defer();
          nextTick(function () {
            result.resolve((errback || defaultErrback)(reason));
          });
          return result.promise;
        }
      };
    };
    var when = function (value, callback, errback) {
      var result = defer(), done;
      var wrappedCallback = function (value) {
        try {
          return (callback || defaultCallback)(value);
        } catch (e) {
          exceptionHandler(e);
          return reject(e);
        }
      };
      var wrappedErrback = function (reason) {
        try {
          return (errback || defaultErrback)(reason);
        } catch (e) {
          exceptionHandler(e);
          return reject(e);
        }
      };
      nextTick(function () {
        ref(value).then(function (value) {
          if (done)
            return;
          done = true;
          result.resolve(ref(value).then(wrappedCallback, wrappedErrback));
        }, function (reason) {
          if (done)
            return;
          done = true;
          result.resolve(wrappedErrback(reason));
        });
      });
      return result.promise;
    };
    function defaultCallback(value) {
      return value;
    }
    function defaultErrback(reason) {
      return reject(reason);
    }
    function all(promises) {
      var deferred = defer(), counter = promises.length, results = [];
      if (counter) {
        forEach(promises, function (promise, index) {
          ref(promise).then(function (value) {
            if (index in results)
              return;
            results[index] = value;
            if (!--counter)
              deferred.resolve(results);
          }, function (reason) {
            if (index in results)
              return;
            deferred.reject(reason);
          });
        });
      } else {
        deferred.resolve(results);
      }
      return deferred.promise;
    }
    return {
      defer: defer,
      reject: reject,
      when: when,
      all: all
    };
  }
  function $RouteProvider() {
    var routes = {};
    this.when = function (path, route) {
      routes[path] = extend({ reloadOnSearch: true }, route);
      if (path) {
        var redirectPath = path[path.length - 1] == '/' ? path.substr(0, path.length - 1) : path + '/';
        routes[redirectPath] = { redirectTo: path };
      }
      return this;
    };
    this.otherwise = function (params) {
      this.when(null, params);
      return this;
    };
    this.$get = [
      '$rootScope',
      '$location',
      '$routeParams',
      '$q',
      '$injector',
      '$http',
      '$templateCache',
      function ($rootScope, $location, $routeParams, $q, $injector, $http, $templateCache) {
        var forceReload = false, $route = {
            routes: routes,
            reload: function () {
              forceReload = true;
              $rootScope.$evalAsync(updateRoute);
            }
          };
        $rootScope.$on('$locationChangeSuccess', updateRoute);
        return $route;
        function switchRouteMatcher(on, when) {
          when = '^' + when.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&') + '$';
          var regex = '', params = [], dst = {};
          var re = /:(\w+)/g, paramMatch, lastMatchedIndex = 0;
          while ((paramMatch = re.exec(when)) !== null) {
            regex += when.slice(lastMatchedIndex, paramMatch.index);
            regex += '([^\\/]*)';
            params.push(paramMatch[1]);
            lastMatchedIndex = re.lastIndex;
          }
          regex += when.substr(lastMatchedIndex);
          var match = on.match(new RegExp(regex));
          if (match) {
            forEach(params, function (name, index) {
              dst[name] = match[index + 1];
            });
          }
          return match ? dst : null;
        }
        function updateRoute() {
          var next = parseRoute(), last = $route.current;
          if (next && last && next.$$route === last.$$route && equals(next.pathParams, last.pathParams) && !next.reloadOnSearch && !forceReload) {
            last.params = next.params;
            copy(last.params, $routeParams);
            $rootScope.$broadcast('$routeUpdate', last);
          } else if (next || last) {
            forceReload = false;
            $rootScope.$broadcast('$routeChangeStart', next, last);
            $route.current = next;
            if (next) {
              if (next.redirectTo) {
                if (isString(next.redirectTo)) {
                  $location.path(interpolate(next.redirectTo, next.params)).search(next.params).replace();
                } else {
                  $location.url(next.redirectTo(next.pathParams, $location.path(), $location.search())).replace();
                }
              }
            }
            $q.when(next).then(function () {
              if (next) {
                var keys = [], values = [], template;
                forEach(next.resolve || {}, function (value, key) {
                  keys.push(key);
                  values.push(isString(value) ? $injector.get(value) : $injector.invoke(value));
                });
                if (isDefined(template = next.template)) {
                } else if (isDefined(template = next.templateUrl)) {
                  template = $http.get(template, { cache: $templateCache }).then(function (response) {
                    return response.data;
                  });
                }
                if (isDefined(template)) {
                  keys.push('$template');
                  values.push(template);
                }
                return $q.all(values).then(function (values) {
                  var locals = {};
                  forEach(values, function (value, index) {
                    locals[keys[index]] = value;
                  });
                  return locals;
                });
              }
            }).then(function (locals) {
              if (next == $route.current) {
                if (next) {
                  next.locals = locals;
                  copy(next.params, $routeParams);
                }
                $rootScope.$broadcast('$routeChangeSuccess', next, last);
              }
            }, function (error) {
              if (next == $route.current) {
                $rootScope.$broadcast('$routeChangeError', next, last, error);
              }
            });
          }
        }
        function parseRoute() {
          var params, match;
          forEach(routes, function (route, path) {
            if (!match && (params = switchRouteMatcher($location.path(), path))) {
              match = inherit(route, {
                params: extend({}, $location.search(), params),
                pathParams: params
              });
              match.$$route = route;
            }
          });
          return match || routes[null] && inherit(routes[null], {
            params: {},
            pathParams: {}
          });
        }
        function interpolate(string, params) {
          var result = [];
          forEach((string || '').split(':'), function (segment, i) {
            if (i == 0) {
              result.push(segment);
            } else {
              var segmentMatch = segment.match(/(\w+)(.*)/);
              var key = segmentMatch[1];
              result.push(params[key]);
              result.push(segmentMatch[2] || '');
              delete params[key];
            }
          });
          return result.join('');
        }
      }
    ];
  }
  function $RouteParamsProvider() {
    this.$get = valueFn({});
  }
  function $RootScopeProvider() {
    var TTL = 10;
    this.digestTtl = function (value) {
      if (arguments.length) {
        TTL = value;
      }
      return TTL;
    };
    this.$get = [
      '$injector',
      '$exceptionHandler',
      '$parse',
      function ($injector, $exceptionHandler, $parse) {
        function Scope() {
          this.$id = nextUid();
          this.$$phase = this.$parent = this.$$watchers = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = null;
          this['this'] = this.$root = this;
          this.$$destroyed = false;
          this.$$asyncQueue = [];
          this.$$listeners = {};
          this.$$isolateBindings = {};
        }
        Scope.prototype = {
          $new: function (isolate) {
            var Child, child;
            if (isFunction(isolate)) {
              throw Error('API-CHANGE: Use $controller to instantiate controllers.');
            }
            if (isolate) {
              child = new Scope();
              child.$root = this.$root;
            } else {
              Child = function () {
              };
              Child.prototype = this;
              child = new Child();
              child.$id = nextUid();
            }
            child['this'] = child;
            child.$$listeners = {};
            child.$parent = this;
            child.$$asyncQueue = [];
            child.$$watchers = child.$$nextSibling = child.$$childHead = child.$$childTail = null;
            child.$$prevSibling = this.$$childTail;
            if (this.$$childHead) {
              this.$$childTail.$$nextSibling = child;
              this.$$childTail = child;
            } else {
              this.$$childHead = this.$$childTail = child;
            }
            return child;
          },
          $watch: function (watchExp, listener, objectEquality) {
            var scope = this, get = compileToFn(watchExp, 'watch'), array = scope.$$watchers, watcher = {
                fn: listener,
                last: initWatchVal,
                get: get,
                exp: watchExp,
                eq: !!objectEquality
              };
            if (!isFunction(listener)) {
              var listenFn = compileToFn(listener || noop, 'listener');
              watcher.fn = function (newVal, oldVal, scope) {
                listenFn(scope);
              };
            }
            if (!array) {
              array = scope.$$watchers = [];
            }
            array.unshift(watcher);
            return function () {
              arrayRemove(array, watcher);
            };
          },
          $digest: function () {
            var watch, value, last, watchers, asyncQueue, length, dirty, ttl = TTL, next, current, target = this, watchLog = [], logIdx, logMsg;
            beginPhase('$digest');
            do {
              dirty = false;
              current = target;
              do {
                asyncQueue = current.$$asyncQueue;
                while (asyncQueue.length) {
                  try {
                    current.$eval(asyncQueue.shift());
                  } catch (e) {
                    $exceptionHandler(e);
                  }
                }
                if (watchers = current.$$watchers) {
                  length = watchers.length;
                  while (length--) {
                    try {
                      watch = watchers[length];
                      if (watch && (value = watch.get(current)) !== (last = watch.last) && !(watch.eq ? equals(value, last) : typeof value == 'number' && typeof last == 'number' && isNaN(value) && isNaN(last))) {
                        dirty = true;
                        watch.last = watch.eq ? copy(value) : value;
                        watch.fn(value, last === initWatchVal ? value : last, current);
                        if (ttl < 5) {
                          logIdx = 4 - ttl;
                          if (!watchLog[logIdx])
                            watchLog[logIdx] = [];
                          logMsg = isFunction(watch.exp) ? 'fn: ' + (watch.exp.name || watch.exp.toString()) : watch.exp;
                          logMsg += '; newVal: ' + toJson(value) + '; oldVal: ' + toJson(last);
                          watchLog[logIdx].push(logMsg);
                        }
                      }
                    } catch (e) {
                      $exceptionHandler(e);
                    }
                  }
                }
                if (!(next = current.$$childHead || current !== target && current.$$nextSibling)) {
                  while (current !== target && !(next = current.$$nextSibling)) {
                    current = current.$parent;
                  }
                }
              } while (current = next);
              if (dirty && !ttl--) {
                clearPhase();
                throw Error(TTL + ' $digest() iterations reached. Aborting!\n' + 'Watchers fired in the last 5 iterations: ' + toJson(watchLog));
              }
            } while (dirty || asyncQueue.length);
            clearPhase();
          },
          $destroy: function () {
            if ($rootScope == this || this.$$destroyed)
              return;
            var parent = this.$parent;
            this.$broadcast('$destroy');
            this.$$destroyed = true;
            if (parent.$$childHead == this)
              parent.$$childHead = this.$$nextSibling;
            if (parent.$$childTail == this)
              parent.$$childTail = this.$$prevSibling;
            if (this.$$prevSibling)
              this.$$prevSibling.$$nextSibling = this.$$nextSibling;
            if (this.$$nextSibling)
              this.$$nextSibling.$$prevSibling = this.$$prevSibling;
            this.$parent = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = null;
          },
          $eval: function (expr, locals) {
            return $parse(expr)(this, locals);
          },
          $evalAsync: function (expr) {
            this.$$asyncQueue.push(expr);
          },
          $apply: function (expr) {
            try {
              beginPhase('$apply');
              return this.$eval(expr);
            } catch (e) {
              $exceptionHandler(e);
            } finally {
              clearPhase();
              try {
                $rootScope.$digest();
              } catch (e) {
                $exceptionHandler(e);
                throw e;
              }
            }
          },
          $on: function (name, listener) {
            var namedListeners = this.$$listeners[name];
            if (!namedListeners) {
              this.$$listeners[name] = namedListeners = [];
            }
            namedListeners.push(listener);
            return function () {
              namedListeners[indexOf(namedListeners, listener)] = null;
            };
          },
          $emit: function (name, args) {
            var empty = [], namedListeners, scope = this, stopPropagation = false, event = {
                name: name,
                targetScope: scope,
                stopPropagation: function () {
                  stopPropagation = true;
                },
                preventDefault: function () {
                  event.defaultPrevented = true;
                },
                defaultPrevented: false
              }, listenerArgs = concat([event], arguments, 1), i, length;
            do {
              namedListeners = scope.$$listeners[name] || empty;
              event.currentScope = scope;
              for (i = 0, length = namedListeners.length; i < length; i++) {
                if (!namedListeners[i]) {
                  namedListeners.splice(i, 1);
                  i--;
                  length--;
                  continue;
                }
                try {
                  namedListeners[i].apply(null, listenerArgs);
                  if (stopPropagation)
                    return event;
                } catch (e) {
                  $exceptionHandler(e);
                }
              }
              scope = scope.$parent;
            } while (scope);
            return event;
          },
          $broadcast: function (name, args) {
            var target = this, current = target, next = target, event = {
                name: name,
                targetScope: target,
                preventDefault: function () {
                  event.defaultPrevented = true;
                },
                defaultPrevented: false
              }, listenerArgs = concat([event], arguments, 1), listeners, i, length;
            do {
              current = next;
              event.currentScope = current;
              listeners = current.$$listeners[name] || [];
              for (i = 0, length = listeners.length; i < length; i++) {
                if (!listeners[i]) {
                  listeners.splice(i, 1);
                  i--;
                  length--;
                  continue;
                }
                try {
                  listeners[i].apply(null, listenerArgs);
                } catch (e) {
                  $exceptionHandler(e);
                }
              }
              if (!(next = current.$$childHead || current !== target && current.$$nextSibling)) {
                while (current !== target && !(next = current.$$nextSibling)) {
                  current = current.$parent;
                }
              }
            } while (current = next);
            return event;
          }
        };
        var $rootScope = new Scope();
        return $rootScope;
        function beginPhase(phase) {
          if ($rootScope.$$phase) {
            throw Error($rootScope.$$phase + ' already in progress');
          }
          $rootScope.$$phase = phase;
        }
        function clearPhase() {
          $rootScope.$$phase = null;
        }
        function compileToFn(exp, name) {
          var fn = $parse(exp);
          assertArgFn(fn, name);
          return fn;
        }
        function initWatchVal() {
        }
      }
    ];
  }
  function $SnifferProvider() {
    this.$get = [
      '$window',
      function ($window) {
        var eventSupport = {}, android = int((/android (\d+)/.exec(lowercase($window.navigator.userAgent)) || [])[1]);
        return {
          history: !!($window.history && $window.history.pushState && !(android < 4)),
          hashchange: 'onhashchange' in $window && (!$window.document.documentMode || $window.document.documentMode > 7),
          hasEvent: function (event) {
            if (event == 'input' && msie == 9)
              return false;
            if (isUndefined(eventSupport[event])) {
              var divElm = $window.document.createElement('div');
              eventSupport[event] = 'on' + event in divElm;
            }
            return eventSupport[event];
          },
          csp: false
        };
      }
    ];
  }
  function $WindowProvider() {
    this.$get = valueFn(window);
  }
  function parseHeaders(headers) {
    var parsed = {}, key, val, i;
    if (!headers)
      return parsed;
    forEach(headers.split('\n'), function (line) {
      i = line.indexOf(':');
      key = lowercase(trim(line.substr(0, i)));
      val = trim(line.substr(i + 1));
      if (key) {
        if (parsed[key]) {
          parsed[key] += ', ' + val;
        } else {
          parsed[key] = val;
        }
      }
    });
    return parsed;
  }
  function headersGetter(headers) {
    var headersObj = isObject(headers) ? headers : undefined;
    return function (name) {
      if (!headersObj)
        headersObj = parseHeaders(headers);
      if (name) {
        return headersObj[lowercase(name)] || null;
      }
      return headersObj;
    };
  }
  function transformData(data, headers, fns) {
    if (isFunction(fns))
      return fns(data, headers);
    forEach(fns, function (fn) {
      data = fn(data, headers);
    });
    return data;
  }
  function isSuccess(status) {
    return 200 <= status && status < 300;
  }
  function $HttpProvider() {
    var JSON_START = /^\s*(\[|\{[^\{])/, JSON_END = /[\}\]]\s*$/, PROTECTION_PREFIX = /^\)\]\}',?\n/;
    var $config = this.defaults = {
        transformResponse: [function (data) {
            if (isString(data)) {
              data = data.replace(PROTECTION_PREFIX, '');
              if (JSON_START.test(data) && JSON_END.test(data))
                data = fromJson(data, true);
            }
            return data;
          }],
        transformRequest: [function (d) {
            return isObject(d) && !isFile(d) ? toJson(d) : d;
          }],
        headers: {
          common: {
            'Accept': 'application/json, text/plain, */*',
            'X-Requested-With': 'XMLHttpRequest'
          },
          post: { 'Content-Type': 'application/json;charset=utf-8' },
          put: { 'Content-Type': 'application/json;charset=utf-8' }
        }
      };
    var providerResponseInterceptors = this.responseInterceptors = [];
    this.$get = [
      '$httpBackend',
      '$browser',
      '$cacheFactory',
      '$rootScope',
      '$q',
      '$injector',
      function ($httpBackend, $browser, $cacheFactory, $rootScope, $q, $injector) {
        var defaultCache = $cacheFactory('$http'), responseInterceptors = [];
        forEach(providerResponseInterceptors, function (interceptor) {
          responseInterceptors.push(isString(interceptor) ? $injector.get(interceptor) : $injector.invoke(interceptor));
        });
        function $http(config) {
          config.method = uppercase(config.method);
          var reqTransformFn = config.transformRequest || $config.transformRequest, respTransformFn = config.transformResponse || $config.transformResponse, reqHeaders = extend({}, config.headers), defHeaders = extend({ 'X-XSRF-TOKEN': $browser.cookies()['XSRF-TOKEN'] }, $config.headers.common, $config.headers[lowercase(config.method)]), reqData, defHeaderName, lowercaseDefHeaderName, headerName, promise;
          defaultHeadersIteration:
            for (defHeaderName in defHeaders) {
              lowercaseDefHeaderName = lowercase(defHeaderName);
              for (headerName in config.headers) {
                if (lowercase(headerName) === lowercaseDefHeaderName) {
                  continue defaultHeadersIteration;
                }
              }
              reqHeaders[defHeaderName] = defHeaders[defHeaderName];
            }
          if (isUndefined(config.data)) {
            for (var header in reqHeaders) {
              if (lowercase(header) === 'content-type') {
                delete reqHeaders[header];
                break;
              }
            }
          }
          reqData = transformData(config.data, headersGetter(reqHeaders), reqTransformFn);
          promise = sendReq(config, reqData, reqHeaders);
          promise = promise.then(transformResponse, transformResponse);
          forEach(responseInterceptors, function (interceptor) {
            promise = interceptor(promise);
          });
          promise.success = function (fn) {
            promise.then(function (response) {
              fn(response.data, response.status, response.headers, config);
            });
            return promise;
          };
          promise.error = function (fn) {
            promise.then(null, function (response) {
              fn(response.data, response.status, response.headers, config);
            });
            return promise;
          };
          return promise;
          function transformResponse(response) {
            var resp = extend({}, response, { data: transformData(response.data, response.headers, respTransformFn) });
            return isSuccess(response.status) ? resp : $q.reject(resp);
          }
        }
        $http.pendingRequests = [];
        createShortMethods('get', 'delete', 'head', 'jsonp');
        createShortMethodsWithData('post', 'put');
        $http.defaults = $config;
        return $http;
        function createShortMethods(names) {
          forEach(arguments, function (name) {
            $http[name] = function (url, config) {
              return $http(extend(config || {}, {
                method: name,
                url: url
              }));
            };
          });
        }
        function createShortMethodsWithData(name) {
          forEach(arguments, function (name) {
            $http[name] = function (url, data, config) {
              return $http(extend(config || {}, {
                method: name,
                url: url,
                data: data
              }));
            };
          });
        }
        function sendReq(config, reqData, reqHeaders) {
          var deferred = $q.defer(), promise = deferred.promise, cache, cachedResp, url = buildUrl(config.url, config.params);
          $http.pendingRequests.push(config);
          promise.then(removePendingReq, removePendingReq);
          if (config.cache && config.method == 'GET') {
            cache = isObject(config.cache) ? config.cache : defaultCache;
          }
          if (cache) {
            cachedResp = cache.get(url);
            if (cachedResp) {
              if (cachedResp.then) {
                cachedResp.then(removePendingReq, removePendingReq);
                return cachedResp;
              } else {
                if (isArray(cachedResp)) {
                  resolvePromise(cachedResp[1], cachedResp[0], copy(cachedResp[2]));
                } else {
                  resolvePromise(cachedResp, 200, {});
                }
              }
            } else {
              cache.put(url, promise);
            }
          }
          if (!cachedResp) {
            $httpBackend(config.method, url, reqData, done, reqHeaders, config.timeout, config.withCredentials);
          }
          return promise;
          function done(status, response, headersString) {
            if (cache) {
              if (isSuccess(status)) {
                cache.put(url, [
                  status,
                  response,
                  parseHeaders(headersString)
                ]);
              } else {
                cache.remove(url);
              }
            }
            resolvePromise(response, status, headersString);
            $rootScope.$apply();
          }
          function resolvePromise(response, status, headers) {
            status = Math.max(status, 0);
            (isSuccess(status) ? deferred.resolve : deferred.reject)({
              data: response,
              status: status,
              headers: headersGetter(headers),
              config: config
            });
          }
          function removePendingReq() {
            var idx = indexOf($http.pendingRequests, config);
            if (idx !== -1)
              $http.pendingRequests.splice(idx, 1);
          }
        }
        function buildUrl(url, params) {
          if (!params)
            return url;
          var parts = [];
          forEachSorted(params, function (value, key) {
            if (value == null || value == undefined)
              return;
            if (isObject(value)) {
              value = toJson(value);
            }
            parts.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));
          });
          return url + (url.indexOf('?') == -1 ? '?' : '&') + parts.join('&');
        }
      }
    ];
  }
  var XHR = window.XMLHttpRequest || function () {
      try {
        return new ActiveXObject('Msxml2.XMLHTTP.6.0');
      } catch (e1) {
      }
      try {
        return new ActiveXObject('Msxml2.XMLHTTP.3.0');
      } catch (e2) {
      }
      try {
        return new ActiveXObject('Msxml2.XMLHTTP');
      } catch (e3) {
      }
      throw new Error('This browser does not support XMLHttpRequest.');
    };
  function $HttpBackendProvider() {
    this.$get = [
      '$browser',
      '$window',
      '$document',
      function ($browser, $window, $document) {
        return createHttpBackend($browser, XHR, $browser.defer, $window.angular.callbacks, $document[0], $window.location.protocol.replace(':', ''));
      }
    ];
  }
  function createHttpBackend($browser, XHR, $browserDefer, callbacks, rawDocument, locationProtocol) {
    return function (method, url, post, callback, headers, timeout, withCredentials) {
      $browser.$$incOutstandingRequestCount();
      url = url || $browser.url();
      if (lowercase(method) == 'jsonp') {
        var callbackId = '_' + (callbacks.counter++).toString(36);
        callbacks[callbackId] = function (data) {
          callbacks[callbackId].data = data;
        };
        jsonpReq(url.replace('JSON_CALLBACK', 'angular.callbacks.' + callbackId), function () {
          if (callbacks[callbackId].data) {
            completeRequest(callback, 200, callbacks[callbackId].data);
          } else {
            completeRequest(callback, -2);
          }
          delete callbacks[callbackId];
        });
      } else {
        var xhr = new XHR();
        xhr.open(method, url, true);
        forEach(headers, function (value, key) {
          if (value)
            xhr.setRequestHeader(key, value);
        });
        var status;
        xhr.onreadystatechange = function () {
          if (xhr.readyState == 4) {
            var responseHeaders = xhr.getAllResponseHeaders();
            var value, simpleHeaders = [
                'Cache-Control',
                'Content-Language',
                'Content-Type',
                'Expires',
                'Last-Modified',
                'Pragma'
              ];
            if (!responseHeaders) {
              responseHeaders = '';
              forEach(simpleHeaders, function (header) {
                var value = xhr.getResponseHeader(header);
                if (value) {
                  responseHeaders += header + ': ' + value + '\n';
                }
              });
            }
            completeRequest(callback, status || xhr.status, xhr.responseText, responseHeaders);
          }
        };
        if (withCredentials) {
          xhr.withCredentials = true;
        }
        xhr.send(post || '');
        if (timeout > 0) {
          $browserDefer(function () {
            status = -1;
            xhr.abort();
          }, timeout);
        }
      }
      function completeRequest(callback, status, response, headersString) {
        var protocol = (url.match(URL_MATCH) || [
            '',
            locationProtocol
          ])[1];
        status = protocol == 'file' ? response ? 200 : 404 : status;
        status = status == 1223 ? 204 : status;
        callback(status, response, headersString);
        $browser.$$completeOutstandingRequest(noop);
      }
    };
    function jsonpReq(url, done) {
      var script = rawDocument.createElement('script'), doneWrapper = function () {
          rawDocument.body.removeChild(script);
          if (done)
            done();
        };
      script.type = 'text/javascript';
      script.src = url;
      if (msie) {
        script.onreadystatechange = function () {
          if (/loaded|complete/.test(script.readyState))
            doneWrapper();
        };
      } else {
        script.onload = script.onerror = doneWrapper;
      }
      rawDocument.body.appendChild(script);
    }
  }
  function $LocaleProvider() {
    this.$get = function () {
      return {
        id: 'en-us',
        NUMBER_FORMATS: {
          DECIMAL_SEP: '.',
          GROUP_SEP: ',',
          PATTERNS: [
            {
              minInt: 1,
              minFrac: 0,
              maxFrac: 3,
              posPre: '',
              posSuf: '',
              negPre: '-',
              negSuf: '',
              gSize: 3,
              lgSize: 3
            },
            {
              minInt: 1,
              minFrac: 2,
              maxFrac: 2,
              posPre: '\xa4',
              posSuf: '',
              negPre: '(\xa4',
              negSuf: ')',
              gSize: 3,
              lgSize: 3
            }
          ],
          CURRENCY_SYM: '$'
        },
        DATETIME_FORMATS: {
          MONTH: 'January,February,March,April,May,June,July,August,September,October,November,December'.split(','),
          SHORTMONTH: 'Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec'.split(','),
          DAY: 'Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday'.split(','),
          SHORTDAY: 'Sun,Mon,Tue,Wed,Thu,Fri,Sat'.split(','),
          AMPMS: [
            'AM',
            'PM'
          ],
          medium: 'MMM d, y h:mm:ss a',
          short: 'M/d/yy h:mm a',
          fullDate: 'EEEE, MMMM d, y',
          longDate: 'MMMM d, y',
          mediumDate: 'MMM d, y',
          shortDate: 'M/d/yy',
          mediumTime: 'h:mm:ss a',
          shortTime: 'h:mm a'
        },
        pluralCat: function (num) {
          if (num === 1) {
            return 'one';
          }
          return 'other';
        }
      };
    };
  }
  function $TimeoutProvider() {
    this.$get = [
      '$rootScope',
      '$browser',
      '$q',
      '$exceptionHandler',
      function ($rootScope, $browser, $q, $exceptionHandler) {
        var deferreds = {};
        function timeout(fn, delay, invokeApply) {
          var deferred = $q.defer(), promise = deferred.promise, skipApply = isDefined(invokeApply) && !invokeApply, timeoutId, cleanup;
          timeoutId = $browser.defer(function () {
            try {
              deferred.resolve(fn());
            } catch (e) {
              deferred.reject(e);
              $exceptionHandler(e);
            } finally {
              delete deferreds[promise.$$timeoutId];
            }
            if (!skipApply)
              $rootScope.$apply();
          }, delay);
          promise.$$timeoutId = timeoutId;
          deferreds[timeoutId] = deferred;
          return promise;
        }
        timeout.cancel = function (promise) {
          if (promise && promise.$$timeoutId in deferreds) {
            deferreds[promise.$$timeoutId].reject('canceled');
            delete deferreds[promise.$$timeoutId];
            return $browser.defer.cancel(promise.$$timeoutId);
          }
          return false;
        };
        return timeout;
      }
    ];
  }
  $FilterProvider.$inject = ['$provide'];
  function $FilterProvider($provide) {
    var suffix = 'Filter';
    function register(name, factory) {
      return $provide.factory(name + suffix, factory);
    }
    this.register = register;
    this.$get = [
      '$injector',
      function ($injector) {
        return function (name) {
          return $injector.get(name + suffix);
        };
      }
    ];
    register('currency', currencyFilter);
    register('date', dateFilter);
    register('filter', filterFilter);
    register('json', jsonFilter);
    register('limitTo', limitToFilter);
    register('lowercase', lowercaseFilter);
    register('number', numberFilter);
    register('orderBy', orderByFilter);
    register('uppercase', uppercaseFilter);
  }
  function filterFilter() {
    return function (array, expression) {
      if (!isArray(array))
        return array;
      var predicates = [];
      predicates.check = function (value) {
        for (var j = 0; j < predicates.length; j++) {
          if (!predicates[j](value)) {
            return false;
          }
        }
        return true;
      };
      var search = function (obj, text) {
        if (text.charAt(0) === '!') {
          return !search(obj, text.substr(1));
        }
        switch (typeof obj) {
        case 'boolean':
        case 'number':
        case 'string':
          return ('' + obj).toLowerCase().indexOf(text) > -1;
        case 'object':
          for (var objKey in obj) {
            if (objKey.charAt(0) !== '$' && search(obj[objKey], text)) {
              return true;
            }
          }
          return false;
        case 'array':
          for (var i = 0; i < obj.length; i++) {
            if (search(obj[i], text)) {
              return true;
            }
          }
          return false;
        default:
          return false;
        }
      };
      switch (typeof expression) {
      case 'boolean':
      case 'number':
      case 'string':
        expression = { $: expression };
      case 'object':
        for (var key in expression) {
          if (key == '$') {
            (function () {
              var text = ('' + expression[key]).toLowerCase();
              if (!text)
                return;
              predicates.push(function (value) {
                return search(value, text);
              });
            }());
          } else {
            (function () {
              var path = key;
              var text = ('' + expression[key]).toLowerCase();
              if (!text)
                return;
              predicates.push(function (value) {
                return search(getter(value, path), text);
              });
            }());
          }
        }
        break;
      case 'function':
        predicates.push(expression);
        break;
      default:
        return array;
      }
      var filtered = [];
      for (var j = 0; j < array.length; j++) {
        var value = array[j];
        if (predicates.check(value)) {
          filtered.push(value);
        }
      }
      return filtered;
    };
  }
  currencyFilter.$inject = ['$locale'];
  function currencyFilter($locale) {
    var formats = $locale.NUMBER_FORMATS;
    return function (amount, currencySymbol) {
      if (isUndefined(currencySymbol))
        currencySymbol = formats.CURRENCY_SYM;
      return formatNumber(amount, formats.PATTERNS[1], formats.GROUP_SEP, formats.DECIMAL_SEP, 2).replace(/\u00A4/g, currencySymbol);
    };
  }
  numberFilter.$inject = ['$locale'];
  function numberFilter($locale) {
    var formats = $locale.NUMBER_FORMATS;
    return function (number, fractionSize) {
      return formatNumber(number, formats.PATTERNS[0], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize);
    };
  }
  var DECIMAL_SEP = '.';
  function formatNumber(number, pattern, groupSep, decimalSep, fractionSize) {
    if (isNaN(number) || !isFinite(number))
      return '';
    var isNegative = number < 0;
    number = Math.abs(number);
    var numStr = number + '', formatedText = '', parts = [];
    var hasExponent = false;
    if (numStr.indexOf('e') !== -1) {
      var match = numStr.match(/([\d\.]+)e(-?)(\d+)/);
      if (match && match[2] == '-' && match[3] > fractionSize + 1) {
        numStr = '0';
      } else {
        formatedText = numStr;
        hasExponent = true;
      }
    }
    if (!hasExponent) {
      var fractionLen = (numStr.split(DECIMAL_SEP)[1] || '').length;
      if (isUndefined(fractionSize)) {
        fractionSize = Math.min(Math.max(pattern.minFrac, fractionLen), pattern.maxFrac);
      }
      var pow = Math.pow(10, fractionSize);
      number = Math.round(number * pow) / pow;
      var fraction = ('' + number).split(DECIMAL_SEP);
      var whole = fraction[0];
      fraction = fraction[1] || '';
      var pos = 0, lgroup = pattern.lgSize, group = pattern.gSize;
      if (whole.length >= lgroup + group) {
        pos = whole.length - lgroup;
        for (var i = 0; i < pos; i++) {
          if ((pos - i) % group === 0 && i !== 0) {
            formatedText += groupSep;
          }
          formatedText += whole.charAt(i);
        }
      }
      for (i = pos; i < whole.length; i++) {
        if ((whole.length - i) % lgroup === 0 && i !== 0) {
          formatedText += groupSep;
        }
        formatedText += whole.charAt(i);
      }
      while (fraction.length < fractionSize) {
        fraction += '0';
      }
      if (fractionSize && fractionSize !== '0')
        formatedText += decimalSep + fraction.substr(0, fractionSize);
    } else {
      if (fractionSize > 0 && number > -1 && number < 1) {
        formatedText = number.toFixed(fractionSize);
      }
    }
    parts.push(isNegative ? pattern.negPre : pattern.posPre);
    parts.push(formatedText);
    parts.push(isNegative ? pattern.negSuf : pattern.posSuf);
    return parts.join('');
  }
  function padNumber(num, digits, trim) {
    var neg = '';
    if (num < 0) {
      neg = '-';
      num = -num;
    }
    num = '' + num;
    while (num.length < digits)
      num = '0' + num;
    if (trim)
      num = num.substr(num.length - digits);
    return neg + num;
  }
  function dateGetter(name, size, offset, trim) {
    offset = offset || 0;
    return function (date) {
      var value = date['get' + name]();
      if (offset > 0 || value > -offset)
        value += offset;
      if (value === 0 && offset == -12)
        value = 12;
      return padNumber(value, size, trim);
    };
  }
  function dateStrGetter(name, shortForm) {
    return function (date, formats) {
      var value = date['get' + name]();
      var get = uppercase(shortForm ? 'SHORT' + name : name);
      return formats[get][value];
    };
  }
  function timeZoneGetter(date) {
    var zone = -1 * date.getTimezoneOffset();
    var paddedZone = zone >= 0 ? '+' : '';
    paddedZone += padNumber(Math[zone > 0 ? 'floor' : 'ceil'](zone / 60), 2) + padNumber(Math.abs(zone % 60), 2);
    return paddedZone;
  }
  function ampmGetter(date, formats) {
    return date.getHours() < 12 ? formats.AMPMS[0] : formats.AMPMS[1];
  }
  var DATE_FORMATS = {
      yyyy: dateGetter('FullYear', 4),
      yy: dateGetter('FullYear', 2, 0, true),
      y: dateGetter('FullYear', 1),
      MMMM: dateStrGetter('Month'),
      MMM: dateStrGetter('Month', true),
      MM: dateGetter('Month', 2, 1),
      M: dateGetter('Month', 1, 1),
      dd: dateGetter('Date', 2),
      d: dateGetter('Date', 1),
      HH: dateGetter('Hours', 2),
      H: dateGetter('Hours', 1),
      hh: dateGetter('Hours', 2, -12),
      h: dateGetter('Hours', 1, -12),
      mm: dateGetter('Minutes', 2),
      m: dateGetter('Minutes', 1),
      ss: dateGetter('Seconds', 2),
      s: dateGetter('Seconds', 1),
      EEEE: dateStrGetter('Day'),
      EEE: dateStrGetter('Day', true),
      a: ampmGetter,
      Z: timeZoneGetter
    };
  var DATE_FORMATS_SPLIT = /((?:[^yMdHhmsaZE']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|d+|H+|h+|m+|s+|a|Z))(.*)/, NUMBER_STRING = /^\d+$/;
  dateFilter.$inject = ['$locale'];
  function dateFilter($locale) {
    var R_ISO8601_STR = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
    function jsonStringToDate(string) {
      var match;
      if (match = string.match(R_ISO8601_STR)) {
        var date = new Date(0), tzHour = 0, tzMin = 0;
        if (match[9]) {
          tzHour = int(match[9] + match[10]);
          tzMin = int(match[9] + match[11]);
        }
        date.setUTCFullYear(int(match[1]), int(match[2]) - 1, int(match[3]));
        date.setUTCHours(int(match[4] || 0) - tzHour, int(match[5] || 0) - tzMin, int(match[6] || 0), int(match[7] || 0));
        return date;
      }
      return string;
    }
    return function (date, format) {
      var text = '', parts = [], fn, match;
      format = format || 'mediumDate';
      format = $locale.DATETIME_FORMATS[format] || format;
      if (isString(date)) {
        if (NUMBER_STRING.test(date)) {
          date = int(date);
        } else {
          date = jsonStringToDate(date);
        }
      }
      if (isNumber(date)) {
        date = new Date(date);
      }
      if (!isDate(date)) {
        return date;
      }
      while (format) {
        match = DATE_FORMATS_SPLIT.exec(format);
        if (match) {
          parts = concat(parts, match, 1);
          format = parts.pop();
        } else {
          parts.push(format);
          format = null;
        }
      }
      forEach(parts, function (value) {
        fn = DATE_FORMATS[value];
        text += fn ? fn(date, $locale.DATETIME_FORMATS) : value.replace(/(^'|'$)/g, '').replace(/''/g, '\'');
      });
      return text;
    };
  }
  function jsonFilter() {
    return function (object) {
      return toJson(object, true);
    };
  }
  var lowercaseFilter = valueFn(lowercase);
  var uppercaseFilter = valueFn(uppercase);
  function limitToFilter() {
    return function (array, limit) {
      if (!(array instanceof Array))
        return array;
      limit = int(limit);
      var out = [], i, n;
      if (!array || !(array instanceof Array))
        return out;
      if (limit > array.length)
        limit = array.length;
      else if (limit < -array.length)
        limit = -array.length;
      if (limit > 0) {
        i = 0;
        n = limit;
      } else {
        i = array.length + limit;
        n = array.length;
      }
      for (; i < n; i++) {
        out.push(array[i]);
      }
      return out;
    };
  }
  orderByFilter.$inject = ['$parse'];
  function orderByFilter($parse) {
    return function (array, sortPredicate, reverseOrder) {
      if (!isArray(array))
        return array;
      if (!sortPredicate)
        return array;
      sortPredicate = isArray(sortPredicate) ? sortPredicate : [sortPredicate];
      sortPredicate = map(sortPredicate, function (predicate) {
        var descending = false, get = predicate || identity;
        if (isString(predicate)) {
          if (predicate.charAt(0) == '+' || predicate.charAt(0) == '-') {
            descending = predicate.charAt(0) == '-';
            predicate = predicate.substring(1);
          }
          get = $parse(predicate);
        }
        return reverseComparator(function (a, b) {
          return compare(get(a), get(b));
        }, descending);
      });
      var arrayCopy = [];
      for (var i = 0; i < array.length; i++) {
        arrayCopy.push(array[i]);
      }
      return arrayCopy.sort(reverseComparator(comparator, reverseOrder));
      function comparator(o1, o2) {
        for (var i = 0; i < sortPredicate.length; i++) {
          var comp = sortPredicate[i](o1, o2);
          if (comp !== 0)
            return comp;
        }
        return 0;
      }
      function reverseComparator(comp, descending) {
        return toBoolean(descending) ? function (a, b) {
          return comp(b, a);
        } : comp;
      }
      function compare(v1, v2) {
        var t1 = typeof v1;
        var t2 = typeof v2;
        if (t1 == t2) {
          if (t1 == 'string') {
            v1 = v1.toLowerCase();
            v2 = v2.toLowerCase();
          }
          if (v1 === v2)
            return 0;
          return v1 < v2 ? -1 : 1;
        } else {
          return t1 < t2 ? -1 : 1;
        }
      }
    };
  }
  function ngDirective(directive) {
    if (isFunction(directive)) {
      directive = { link: directive };
    }
    directive.restrict = directive.restrict || 'AC';
    return valueFn(directive);
  }
  var htmlAnchorDirective = valueFn({
      restrict: 'E',
      compile: function (element, attr) {
        if (msie <= 8) {
          if (!attr.href && !attr.name) {
            attr.$set('href', '');
          }
          element.append(document.createComment('IE fix'));
        }
        return function (scope, element) {
          element.bind('click', function (event) {
            if (!element.attr('href')) {
              event.preventDefault();
            }
          });
        };
      }
    });
  var ngAttributeAliasDirectives = {};
  forEach(BOOLEAN_ATTR, function (propName, attrName) {
    var normalized = directiveNormalize('ng-' + attrName);
    ngAttributeAliasDirectives[normalized] = function () {
      return {
        priority: 100,
        compile: function () {
          return function (scope, element, attr) {
            scope.$watch(attr[normalized], function ngBooleanAttrWatchAction(value) {
              attr.$set(attrName, !!value);
            });
          };
        }
      };
    };
  });
  forEach([
    'src',
    'href'
  ], function (attrName) {
    var normalized = directiveNormalize('ng-' + attrName);
    ngAttributeAliasDirectives[normalized] = function () {
      return {
        priority: 99,
        link: function (scope, element, attr) {
          attr.$observe(normalized, function (value) {
            if (!value)
              return;
            attr.$set(attrName, value);
            if (msie)
              element.prop(attrName, attr[attrName]);
          });
        }
      };
    };
  });
  var nullFormCtrl = {
      $addControl: noop,
      $removeControl: noop,
      $setValidity: noop,
      $setDirty: noop
    };
  FormController.$inject = [
    '$element',
    '$attrs',
    '$scope'
  ];
  function FormController(element, attrs) {
    var form = this, parentForm = element.parent().controller('form') || nullFormCtrl, invalidCount = 0, errors = form.$error = {};
    form.$name = attrs.name || attrs.ngForm;
    form.$dirty = false;
    form.$pristine = true;
    form.$valid = true;
    form.$invalid = false;
    parentForm.$addControl(form);
    element.addClass(PRISTINE_CLASS);
    toggleValidCss(true);
    function toggleValidCss(isValid, validationErrorKey) {
      validationErrorKey = validationErrorKey ? '-' + snake_case(validationErrorKey, '-') : '';
      element.removeClass((isValid ? INVALID_CLASS : VALID_CLASS) + validationErrorKey).addClass((isValid ? VALID_CLASS : INVALID_CLASS) + validationErrorKey);
    }
    form.$addControl = function (control) {
      if (control.$name && !form.hasOwnProperty(control.$name)) {
        form[control.$name] = control;
      }
    };
    form.$removeControl = function (control) {
      if (control.$name && form[control.$name] === control) {
        delete form[control.$name];
      }
      forEach(errors, function (queue, validationToken) {
        form.$setValidity(validationToken, true, control);
      });
    };
    form.$setValidity = function (validationToken, isValid, control) {
      var queue = errors[validationToken];
      if (isValid) {
        if (queue) {
          arrayRemove(queue, control);
          if (!queue.length) {
            invalidCount--;
            if (!invalidCount) {
              toggleValidCss(isValid);
              form.$valid = true;
              form.$invalid = false;
            }
            errors[validationToken] = false;
            toggleValidCss(true, validationToken);
            parentForm.$setValidity(validationToken, true, form);
          }
        }
      } else {
        if (!invalidCount) {
          toggleValidCss(isValid);
        }
        if (queue) {
          if (includes(queue, control))
            return;
        } else {
          errors[validationToken] = queue = [];
          invalidCount++;
          toggleValidCss(false, validationToken);
          parentForm.$setValidity(validationToken, false, form);
        }
        queue.push(control);
        form.$valid = false;
        form.$invalid = true;
      }
    };
    form.$setDirty = function () {
      element.removeClass(PRISTINE_CLASS).addClass(DIRTY_CLASS);
      form.$dirty = true;
      form.$pristine = false;
      parentForm.$setDirty();
    };
  }
  var formDirectiveFactory = function (isNgForm) {
    return [
      '$timeout',
      function ($timeout) {
        var formDirective = {
            name: 'form',
            restrict: 'E',
            controller: FormController,
            compile: function () {
              return {
                pre: function (scope, formElement, attr, controller) {
                  if (!attr.action) {
                    var preventDefaultListener = function (event) {
                      event.preventDefault ? event.preventDefault() : event.returnValue = false;
                    };
                    addEventListenerFn(formElement[0], 'submit', preventDefaultListener);
                    formElement.bind('$destroy', function () {
                      $timeout(function () {
                        removeEventListenerFn(formElement[0], 'submit', preventDefaultListener);
                      }, 0, false);
                    });
                  }
                  var parentFormCtrl = formElement.parent().controller('form'), alias = attr.name || attr.ngForm;
                  if (alias) {
                    scope[alias] = controller;
                  }
                  if (parentFormCtrl) {
                    formElement.bind('$destroy', function () {
                      parentFormCtrl.$removeControl(controller);
                      if (alias) {
                        scope[alias] = undefined;
                      }
                      extend(controller, nullFormCtrl);
                    });
                  }
                }
              };
            }
          };
        return isNgForm ? extend(copy(formDirective), { restrict: 'EAC' }) : formDirective;
      }
    ];
  };
  var formDirective = formDirectiveFactory();
  var ngFormDirective = formDirectiveFactory(true);
  var URL_REGEXP = /^(ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-\/]))?$/;
  var EMAIL_REGEXP = /^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,6}$/;
  var NUMBER_REGEXP = /^\s*(\-|\+)?(\d+|(\d*(\.\d*)))\s*$/;
  var inputType = {
      'text': textInputType,
      'number': numberInputType,
      'url': urlInputType,
      'email': emailInputType,
      'radio': radioInputType,
      'checkbox': checkboxInputType,
      'hidden': noop,
      'button': noop,
      'submit': noop,
      'reset': noop
    };
  function isEmpty(value) {
    return isUndefined(value) || value === '' || value === null || value !== value;
  }
  function textInputType(scope, element, attr, ctrl, $sniffer, $browser) {
    var listener = function () {
      var value = trim(element.val());
      if (ctrl.$viewValue !== value) {
        scope.$apply(function () {
          ctrl.$setViewValue(value);
        });
      }
    };
    if ($sniffer.hasEvent('input')) {
      element.bind('input', listener);
    } else {
      var timeout;
      var deferListener = function () {
        if (!timeout) {
          timeout = $browser.defer(function () {
            listener();
            timeout = null;
          });
        }
      };
      element.bind('keydown', function (event) {
        var key = event.keyCode;
        if (key === 91 || 15 < key && key < 19 || 37 <= key && key <= 40)
          return;
        deferListener();
      });
      element.bind('change', listener);
      if ($sniffer.hasEvent('paste')) {
        element.bind('paste cut', deferListener);
      }
    }
    ctrl.$render = function () {
      element.val(isEmpty(ctrl.$viewValue) ? '' : ctrl.$viewValue);
    };
    var pattern = attr.ngPattern, patternValidator;
    var validate = function (regexp, value) {
      if (isEmpty(value) || regexp.test(value)) {
        ctrl.$setValidity('pattern', true);
        return value;
      } else {
        ctrl.$setValidity('pattern', false);
        return undefined;
      }
    };
    if (pattern) {
      if (pattern.match(/^\/(.*)\/$/)) {
        pattern = new RegExp(pattern.substr(1, pattern.length - 2));
        patternValidator = function (value) {
          return validate(pattern, value);
        };
      } else {
        patternValidator = function (value) {
          var patternObj = scope.$eval(pattern);
          if (!patternObj || !patternObj.test) {
            throw new Error('Expected ' + pattern + ' to be a RegExp but was ' + patternObj);
          }
          return validate(patternObj, value);
        };
      }
      ctrl.$formatters.push(patternValidator);
      ctrl.$parsers.push(patternValidator);
    }
    if (attr.ngMinlength) {
      var minlength = int(attr.ngMinlength);
      var minLengthValidator = function (value) {
        if (!isEmpty(value) && value.length < minlength) {
          ctrl.$setValidity('minlength', false);
          return undefined;
        } else {
          ctrl.$setValidity('minlength', true);
          return value;
        }
      };
      ctrl.$parsers.push(minLengthValidator);
      ctrl.$formatters.push(minLengthValidator);
    }
    if (attr.ngMaxlength) {
      var maxlength = int(attr.ngMaxlength);
      var maxLengthValidator = function (value) {
        if (!isEmpty(value) && value.length > maxlength) {
          ctrl.$setValidity('maxlength', false);
          return undefined;
        } else {
          ctrl.$setValidity('maxlength', true);
          return value;
        }
      };
      ctrl.$parsers.push(maxLengthValidator);
      ctrl.$formatters.push(maxLengthValidator);
    }
  }
  function numberInputType(scope, element, attr, ctrl, $sniffer, $browser) {
    textInputType(scope, element, attr, ctrl, $sniffer, $browser);
    ctrl.$parsers.push(function (value) {
      var empty = isEmpty(value);
      if (empty || NUMBER_REGEXP.test(value)) {
        ctrl.$setValidity('number', true);
        return value === '' ? null : empty ? value : parseFloat(value);
      } else {
        ctrl.$setValidity('number', false);
        return undefined;
      }
    });
    ctrl.$formatters.push(function (value) {
      return isEmpty(value) ? '' : '' + value;
    });
    if (attr.min) {
      var min = parseFloat(attr.min);
      var minValidator = function (value) {
        if (!isEmpty(value) && value < min) {
          ctrl.$setValidity('min', false);
          return undefined;
        } else {
          ctrl.$setValidity('min', true);
          return value;
        }
      };
      ctrl.$parsers.push(minValidator);
      ctrl.$formatters.push(minValidator);
    }
    if (attr.max) {
      var max = parseFloat(attr.max);
      var maxValidator = function (value) {
        if (!isEmpty(value) && value > max) {
          ctrl.$setValidity('max', false);
          return undefined;
        } else {
          ctrl.$setValidity('max', true);
          return value;
        }
      };
      ctrl.$parsers.push(maxValidator);
      ctrl.$formatters.push(maxValidator);
    }
    ctrl.$formatters.push(function (value) {
      if (isEmpty(value) || isNumber(value)) {
        ctrl.$setValidity('number', true);
        return value;
      } else {
        ctrl.$setValidity('number', false);
        return undefined;
      }
    });
  }
  function urlInputType(scope, element, attr, ctrl, $sniffer, $browser) {
    textInputType(scope, element, attr, ctrl, $sniffer, $browser);
    var urlValidator = function (value) {
      if (isEmpty(value) || URL_REGEXP.test(value)) {
        ctrl.$setValidity('url', true);
        return value;
      } else {
        ctrl.$setValidity('url', false);
        return undefined;
      }
    };
    ctrl.$formatters.push(urlValidator);
    ctrl.$parsers.push(urlValidator);
  }
  function emailInputType(scope, element, attr, ctrl, $sniffer, $browser) {
    textInputType(scope, element, attr, ctrl, $sniffer, $browser);
    var emailValidator = function (value) {
      if (isEmpty(value) || EMAIL_REGEXP.test(value)) {
        ctrl.$setValidity('email', true);
        return value;
      } else {
        ctrl.$setValidity('email', false);
        return undefined;
      }
    };
    ctrl.$formatters.push(emailValidator);
    ctrl.$parsers.push(emailValidator);
  }
  function radioInputType(scope, element, attr, ctrl) {
    if (isUndefined(attr.name)) {
      element.attr('name', nextUid());
    }
    element.bind('click', function () {
      if (element[0].checked) {
        scope.$apply(function () {
          ctrl.$setViewValue(attr.value);
        });
      }
    });
    ctrl.$render = function () {
      var value = attr.value;
      element[0].checked = value == ctrl.$viewValue;
    };
    attr.$observe('value', ctrl.$render);
  }
  function checkboxInputType(scope, element, attr, ctrl) {
    var trueValue = attr.ngTrueValue, falseValue = attr.ngFalseValue;
    if (!isString(trueValue))
      trueValue = true;
    if (!isString(falseValue))
      falseValue = false;
    element.bind('click', function () {
      scope.$apply(function () {
        ctrl.$setViewValue(element[0].checked);
      });
    });
    ctrl.$render = function () {
      element[0].checked = ctrl.$viewValue;
    };
    ctrl.$formatters.push(function (value) {
      return value === trueValue;
    });
    ctrl.$parsers.push(function (value) {
      return value ? trueValue : falseValue;
    });
  }
  var inputDirective = [
      '$browser',
      '$sniffer',
      function ($browser, $sniffer) {
        return {
          restrict: 'E',
          require: '?ngModel',
          link: function (scope, element, attr, ctrl) {
            if (ctrl) {
              (inputType[lowercase(attr.type)] || inputType.text)(scope, element, attr, ctrl, $sniffer, $browser);
            }
          }
        };
      }
    ];
  var VALID_CLASS = 'ng-valid', INVALID_CLASS = 'ng-invalid', PRISTINE_CLASS = 'ng-pristine', DIRTY_CLASS = 'ng-dirty';
  var NgModelController = [
      '$scope',
      '$exceptionHandler',
      '$attrs',
      '$element',
      '$parse',
      function ($scope, $exceptionHandler, $attr, $element, $parse) {
        this.$viewValue = Number.NaN;
        this.$modelValue = Number.NaN;
        this.$parsers = [];
        this.$formatters = [];
        this.$viewChangeListeners = [];
        this.$pristine = true;
        this.$dirty = false;
        this.$valid = true;
        this.$invalid = false;
        this.$name = $attr.name;
        var ngModelGet = $parse($attr.ngModel), ngModelSet = ngModelGet.assign;
        if (!ngModelSet) {
          throw Error(NON_ASSIGNABLE_MODEL_EXPRESSION + $attr.ngModel + ' (' + startingTag($element) + ')');
        }
        this.$render = noop;
        var parentForm = $element.inheritedData('$formController') || nullFormCtrl, invalidCount = 0, $error = this.$error = {};
        $element.addClass(PRISTINE_CLASS);
        toggleValidCss(true);
        function toggleValidCss(isValid, validationErrorKey) {
          validationErrorKey = validationErrorKey ? '-' + snake_case(validationErrorKey, '-') : '';
          $element.removeClass((isValid ? INVALID_CLASS : VALID_CLASS) + validationErrorKey).addClass((isValid ? VALID_CLASS : INVALID_CLASS) + validationErrorKey);
        }
        this.$setValidity = function (validationErrorKey, isValid) {
          if ($error[validationErrorKey] === !isValid)
            return;
          if (isValid) {
            if ($error[validationErrorKey])
              invalidCount--;
            if (!invalidCount) {
              toggleValidCss(true);
              this.$valid = true;
              this.$invalid = false;
            }
          } else {
            toggleValidCss(false);
            this.$invalid = true;
            this.$valid = false;
            invalidCount++;
          }
          $error[validationErrorKey] = !isValid;
          toggleValidCss(isValid, validationErrorKey);
          parentForm.$setValidity(validationErrorKey, isValid, this);
        };
        this.$setViewValue = function (value) {
          this.$viewValue = value;
          if (this.$pristine) {
            this.$dirty = true;
            this.$pristine = false;
            $element.removeClass(PRISTINE_CLASS).addClass(DIRTY_CLASS);
            parentForm.$setDirty();
          }
          forEach(this.$parsers, function (fn) {
            value = fn(value);
          });
          if (this.$modelValue !== value) {
            this.$modelValue = value;
            ngModelSet($scope, value);
            forEach(this.$viewChangeListeners, function (listener) {
              try {
                listener();
              } catch (e) {
                $exceptionHandler(e);
              }
            });
          }
        };
        var ctrl = this;
        $scope.$watch(function ngModelWatch() {
          var value = ngModelGet($scope);
          if (ctrl.$modelValue !== value) {
            var formatters = ctrl.$formatters, idx = formatters.length;
            ctrl.$modelValue = value;
            while (idx--) {
              value = formatters[idx](value);
            }
            if (ctrl.$viewValue !== value) {
              ctrl.$viewValue = value;
              ctrl.$render();
            }
          }
        });
      }
    ];
  var ngModelDirective = function () {
    return {
      require: [
        'ngModel',
        '^?form'
      ],
      controller: NgModelController,
      link: function (scope, element, attr, ctrls) {
        var modelCtrl = ctrls[0], formCtrl = ctrls[1] || nullFormCtrl;
        formCtrl.$addControl(modelCtrl);
        element.bind('$destroy', function () {
          formCtrl.$removeControl(modelCtrl);
        });
      }
    };
  };
  var ngChangeDirective = valueFn({
      require: 'ngModel',
      link: function (scope, element, attr, ctrl) {
        ctrl.$viewChangeListeners.push(function () {
          scope.$eval(attr.ngChange);
        });
      }
    });
  var requiredDirective = function () {
    return {
      require: '?ngModel',
      link: function (scope, elm, attr, ctrl) {
        if (!ctrl)
          return;
        attr.required = true;
        var validator = function (value) {
          if (attr.required && (isEmpty(value) || value === false)) {
            ctrl.$setValidity('required', false);
            return;
          } else {
            ctrl.$setValidity('required', true);
            return value;
          }
        };
        ctrl.$formatters.push(validator);
        ctrl.$parsers.unshift(validator);
        attr.$observe('required', function () {
          validator(ctrl.$viewValue);
        });
      }
    };
  };
  var ngListDirective = function () {
    return {
      require: 'ngModel',
      link: function (scope, element, attr, ctrl) {
        var match = /\/(.*)\//.exec(attr.ngList), separator = match && new RegExp(match[1]) || attr.ngList || ',';
        var parse = function (viewValue) {
          var list = [];
          if (viewValue) {
            forEach(viewValue.split(separator), function (value) {
              if (value)
                list.push(trim(value));
            });
          }
          return list;
        };
        ctrl.$parsers.push(parse);
        ctrl.$formatters.push(function (value) {
          if (isArray(value)) {
            return value.join(', ');
          }
          return undefined;
        });
      }
    };
  };
  var CONSTANT_VALUE_REGEXP = /^(true|false|\d+)$/;
  var ngValueDirective = function () {
    return {
      priority: 100,
      compile: function (tpl, tplAttr) {
        if (CONSTANT_VALUE_REGEXP.test(tplAttr.ngValue)) {
          return function (scope, elm, attr) {
            attr.$set('value', scope.$eval(attr.ngValue));
          };
        } else {
          return function (scope, elm, attr) {
            scope.$watch(attr.ngValue, function valueWatchAction(value) {
              attr.$set('value', value);
            });
          };
        }
      }
    };
  };
  var ngBindDirective = ngDirective(function (scope, element, attr) {
      element.addClass('ng-binding').data('$binding', attr.ngBind);
      scope.$watch(attr.ngBind, function ngBindWatchAction(value) {
        element.text(value == undefined ? '' : value);
      });
    });
  var ngBindTemplateDirective = [
      '$interpolate',
      function ($interpolate) {
        return function (scope, element, attr) {
          var interpolateFn = $interpolate(element.attr(attr.$attr.ngBindTemplate));
          element.addClass('ng-binding').data('$binding', interpolateFn);
          attr.$observe('ngBindTemplate', function (value) {
            element.text(value);
          });
        };
      }
    ];
  var ngBindHtmlUnsafeDirective = [function () {
        return function (scope, element, attr) {
          element.addClass('ng-binding').data('$binding', attr.ngBindHtmlUnsafe);
          scope.$watch(attr.ngBindHtmlUnsafe, function ngBindHtmlUnsafeWatchAction(value) {
            element.html(value || '');
          });
        };
      }];
  function classDirective(name, selector) {
    name = 'ngClass' + name;
    return ngDirective(function (scope, element, attr) {
      var oldVal = undefined;
      scope.$watch(attr[name], ngClassWatchAction, true);
      attr.$observe('class', function (value) {
        var ngClass = scope.$eval(attr[name]);
        ngClassWatchAction(ngClass, ngClass);
      });
      if (name !== 'ngClass') {
        scope.$watch('$index', function ($index, old$index) {
          var mod = $index & 1;
          if (mod !== old$index & 1) {
            if (mod === selector) {
              addClass(scope.$eval(attr[name]));
            } else {
              removeClass(scope.$eval(attr[name]));
            }
          }
        });
      }
      function ngClassWatchAction(newVal) {
        if (selector === true || scope.$index % 2 === selector) {
          if (oldVal && !equals(newVal, oldVal)) {
            removeClass(oldVal);
          }
          addClass(newVal);
        }
        oldVal = copy(newVal);
      }
      function removeClass(classVal) {
        if (isObject(classVal) && !isArray(classVal)) {
          classVal = map(classVal, function (v, k) {
            if (v)
              return k;
          });
        }
        element.removeClass(isArray(classVal) ? classVal.join(' ') : classVal);
      }
      function addClass(classVal) {
        if (isObject(classVal) && !isArray(classVal)) {
          classVal = map(classVal, function (v, k) {
            if (v)
              return k;
          });
        }
        if (classVal) {
          element.addClass(isArray(classVal) ? classVal.join(' ') : classVal);
        }
      }
    });
  }
  var ngClassDirective = classDirective('', true);
  var ngClassOddDirective = classDirective('Odd', 0);
  var ngClassEvenDirective = classDirective('Even', 1);
  var ngCloakDirective = ngDirective({
      compile: function (element, attr) {
        attr.$set('ngCloak', undefined);
        element.removeClass('ng-cloak');
      }
    });
  var ngControllerDirective = [function () {
        return {
          scope: true,
          controller: '@'
        };
      }];
  var ngCspDirective = [
      '$sniffer',
      function ($sniffer) {
        return {
          priority: 1000,
          compile: function () {
            $sniffer.csp = true;
          }
        };
      }
    ];
  var ngEventDirectives = {};
  forEach('click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave submit'.split(' '), function (name) {
    var directiveName = directiveNormalize('ng-' + name);
    ngEventDirectives[directiveName] = [
      '$parse',
      function ($parse) {
        return function (scope, element, attr) {
          var fn = $parse(attr[directiveName]);
          element.bind(lowercase(name), function (event) {
            scope.$apply(function () {
              fn(scope, { $event: event });
            });
          });
        };
      }
    ];
  });
  var ngIncludeDirective = [
      '$http',
      '$templateCache',
      '$anchorScroll',
      '$compile',
      function ($http, $templateCache, $anchorScroll, $compile) {
        return {
          restrict: 'ECA',
          terminal: true,
          compile: function (element, attr) {
            var srcExp = attr.ngInclude || attr.src, onloadExp = attr.onload || '', autoScrollExp = attr.autoscroll;
            return function (scope, element) {
              var changeCounter = 0, childScope;
              var clearContent = function () {
                if (childScope) {
                  childScope.$destroy();
                  childScope = null;
                }
                element.html('');
              };
              scope.$watch(srcExp, function ngIncludeWatchAction(src) {
                var thisChangeId = ++changeCounter;
                if (src) {
                  $http.get(src, { cache: $templateCache }).success(function (response) {
                    if (thisChangeId !== changeCounter)
                      return;
                    if (childScope)
                      childScope.$destroy();
                    childScope = scope.$new();
                    element.html(response);
                    $compile(element.contents())(childScope);
                    if (isDefined(autoScrollExp) && (!autoScrollExp || scope.$eval(autoScrollExp))) {
                      $anchorScroll();
                    }
                    childScope.$emit('$includeContentLoaded');
                    scope.$eval(onloadExp);
                  }).error(function () {
                    if (thisChangeId === changeCounter)
                      clearContent();
                  });
                } else
                  clearContent();
              });
            };
          }
        };
      }
    ];
  var ngInitDirective = ngDirective({
      compile: function () {
        return {
          pre: function (scope, element, attrs) {
            scope.$eval(attrs.ngInit);
          }
        };
      }
    });
  var ngNonBindableDirective = ngDirective({
      terminal: true,
      priority: 1000
    });
  var ngPluralizeDirective = [
      '$locale',
      '$interpolate',
      function ($locale, $interpolate) {
        var BRACE = /{}/g;
        return {
          restrict: 'EA',
          link: function (scope, element, attr) {
            var numberExp = attr.count, whenExp = element.attr(attr.$attr.when), offset = attr.offset || 0, whens = scope.$eval(whenExp), whensExpFns = {}, startSymbol = $interpolate.startSymbol(), endSymbol = $interpolate.endSymbol();
            forEach(whens, function (expression, key) {
              whensExpFns[key] = $interpolate(expression.replace(BRACE, startSymbol + numberExp + '-' + offset + endSymbol));
            });
            scope.$watch(function ngPluralizeWatch() {
              var value = parseFloat(scope.$eval(numberExp));
              if (!isNaN(value)) {
                if (!(value in whens))
                  value = $locale.pluralCat(value - offset);
                return whensExpFns[value](scope, element, true);
              } else {
                return '';
              }
            }, function ngPluralizeWatchAction(newVal) {
              element.text(newVal);
            });
          }
        };
      }
    ];
  var ngRepeatDirective = ngDirective({
      transclude: 'element',
      priority: 1000,
      terminal: true,
      compile: function (element, attr, linker) {
        return function (scope, iterStartElement, attr) {
          var expression = attr.ngRepeat;
          var match = expression.match(/^\s*(.+)\s+in\s+(.*)\s*$/), lhs, rhs, valueIdent, keyIdent;
          if (!match) {
            throw Error('Expected ngRepeat in form of \'_item_ in _collection_\' but got \'' + expression + '\'.');
          }
          lhs = match[1];
          rhs = match[2];
          match = lhs.match(/^(?:([\$\w]+)|\(([\$\w]+)\s*,\s*([\$\w]+)\))$/);
          if (!match) {
            throw Error('\'item\' in \'item in collection\' should be identifier or (key, value) but got \'' + lhs + '\'.');
          }
          valueIdent = match[3] || match[1];
          keyIdent = match[2];
          var lastOrder = new HashQueueMap();
          scope.$watch(function ngRepeatWatch(scope) {
            var index, length, collection = scope.$eval(rhs), cursor = iterStartElement, nextOrder = new HashQueueMap(), arrayBound, childScope, key, value, array, last;
            if (!isArray(collection)) {
              array = [];
              for (key in collection) {
                if (collection.hasOwnProperty(key) && key.charAt(0) != '$') {
                  array.push(key);
                }
              }
              array.sort();
            } else {
              array = collection || [];
            }
            arrayBound = array.length - 1;
            for (index = 0, length = array.length; index < length; index++) {
              key = collection === array ? index : array[index];
              value = collection[key];
              last = lastOrder.shift(value);
              if (last) {
                childScope = last.scope;
                nextOrder.push(value, last);
                if (index === last.index) {
                  cursor = last.element;
                } else {
                  last.index = index;
                  cursor.after(last.element);
                  cursor = last.element;
                }
              } else {
                childScope = scope.$new();
              }
              childScope[valueIdent] = value;
              if (keyIdent)
                childScope[keyIdent] = key;
              childScope.$index = index;
              childScope.$first = index === 0;
              childScope.$last = index === arrayBound;
              childScope.$middle = !(childScope.$first || childScope.$last);
              if (!last) {
                linker(childScope, function (clone) {
                  cursor.after(clone);
                  last = {
                    scope: childScope,
                    element: cursor = clone,
                    index: index
                  };
                  nextOrder.push(value, last);
                });
              }
            }
            for (key in lastOrder) {
              if (lastOrder.hasOwnProperty(key)) {
                array = lastOrder[key];
                while (array.length) {
                  value = array.pop();
                  value.element.remove();
                  value.scope.$destroy();
                }
              }
            }
            lastOrder = nextOrder;
          });
        };
      }
    });
  var ngShowDirective = ngDirective(function (scope, element, attr) {
      scope.$watch(attr.ngShow, function ngShowWatchAction(value) {
        element.css('display', toBoolean(value) ? '' : 'none');
      });
    });
  var ngHideDirective = ngDirective(function (scope, element, attr) {
      scope.$watch(attr.ngHide, function ngHideWatchAction(value) {
        element.css('display', toBoolean(value) ? 'none' : '');
      });
    });
  var ngStyleDirective = ngDirective(function (scope, element, attr) {
      scope.$watch(attr.ngStyle, function ngStyleWatchAction(newStyles, oldStyles) {
        if (oldStyles && newStyles !== oldStyles) {
          forEach(oldStyles, function (val, style) {
            element.css(style, '');
          });
        }
        if (newStyles)
          element.css(newStyles);
      }, true);
    });
  var NG_SWITCH = 'ng-switch';
  var ngSwitchDirective = valueFn({
      restrict: 'EA',
      require: 'ngSwitch',
      controller: [
        '$scope',
        function ngSwitchController() {
          this.cases = {};
        }
      ],
      link: function (scope, element, attr, ctrl) {
        var watchExpr = attr.ngSwitch || attr.on, selectedTransclude, selectedElement, selectedScope;
        scope.$watch(watchExpr, function ngSwitchWatchAction(value) {
          if (selectedElement) {
            selectedScope.$destroy();
            selectedElement.remove();
            selectedElement = selectedScope = null;
          }
          if (selectedTransclude = ctrl.cases['!' + value] || ctrl.cases['?']) {
            scope.$eval(attr.change);
            selectedScope = scope.$new();
            selectedTransclude(selectedScope, function (caseElement) {
              selectedElement = caseElement;
              element.append(caseElement);
            });
          }
        });
      }
    });
  var ngSwitchWhenDirective = ngDirective({
      transclude: 'element',
      priority: 500,
      require: '^ngSwitch',
      compile: function (element, attrs, transclude) {
        return function (scope, element, attr, ctrl) {
          ctrl.cases['!' + attrs.ngSwitchWhen] = transclude;
        };
      }
    });
  var ngSwitchDefaultDirective = ngDirective({
      transclude: 'element',
      priority: 500,
      require: '^ngSwitch',
      compile: function (element, attrs, transclude) {
        return function (scope, element, attr, ctrl) {
          ctrl.cases['?'] = transclude;
        };
      }
    });
  var ngTranscludeDirective = ngDirective({
      controller: [
        '$transclude',
        '$element',
        function ($transclude, $element) {
          $transclude(function (clone) {
            $element.append(clone);
          });
        }
      ]
    });
  var ngViewDirective = [
      '$http',
      '$templateCache',
      '$route',
      '$anchorScroll',
      '$compile',
      '$controller',
      function ($http, $templateCache, $route, $anchorScroll, $compile, $controller) {
        return {
          restrict: 'ECA',
          terminal: true,
          link: function (scope, element, attr) {
            var lastScope, onloadExp = attr.onload || '';
            scope.$on('$routeChangeSuccess', update);
            update();
            function destroyLastScope() {
              if (lastScope) {
                lastScope.$destroy();
                lastScope = null;
              }
            }
            function clearContent() {
              element.html('');
              destroyLastScope();
            }
            function update() {
              var locals = $route.current && $route.current.locals, template = locals && locals.$template;
              if (template) {
                element.html(template);
                destroyLastScope();
                var link = $compile(element.contents()), current = $route.current, controller;
                lastScope = current.scope = scope.$new();
                if (current.controller) {
                  locals.$scope = lastScope;
                  controller = $controller(current.controller, locals);
                  element.children().data('$ngControllerController', controller);
                }
                link(lastScope);
                lastScope.$emit('$viewContentLoaded');
                lastScope.$eval(onloadExp);
                $anchorScroll();
              } else {
                clearContent();
              }
            }
          }
        };
      }
    ];
  var scriptDirective = [
      '$templateCache',
      function ($templateCache) {
        return {
          restrict: 'E',
          terminal: true,
          compile: function (element, attr) {
            if (attr.type == 'text/ng-template') {
              var templateUrl = attr.id, text = element[0].text;
              $templateCache.put(templateUrl, text);
            }
          }
        };
      }
    ];
  var ngOptionsDirective = valueFn({ terminal: true });
  var selectDirective = [
      '$compile',
      '$parse',
      function ($compile, $parse) {
        var NG_OPTIONS_REGEXP = /^\s*(.*?)(?:\s+as\s+(.*?))?(?:\s+group\s+by\s+(.*))?\s+for\s+(?:([\$\w][\$\w\d]*)|(?:\(\s*([\$\w][\$\w\d]*)\s*,\s*([\$\w][\$\w\d]*)\s*\)))\s+in\s+(.*)$/, nullModelCtrl = { $setViewValue: noop };
        return {
          restrict: 'E',
          require: [
            'select',
            '?ngModel'
          ],
          controller: [
            '$element',
            '$scope',
            '$attrs',
            function ($element, $scope, $attrs) {
              var self = this, optionsMap = {}, ngModelCtrl = nullModelCtrl, nullOption, unknownOption;
              self.databound = $attrs.ngModel;
              self.init = function (ngModelCtrl_, nullOption_, unknownOption_) {
                ngModelCtrl = ngModelCtrl_;
                nullOption = nullOption_;
                unknownOption = unknownOption_;
              };
              self.addOption = function (value) {
                optionsMap[value] = true;
                if (ngModelCtrl.$viewValue == value) {
                  $element.val(value);
                  if (unknownOption.parent())
                    unknownOption.remove();
                }
              };
              self.removeOption = function (value) {
                if (this.hasOption(value)) {
                  delete optionsMap[value];
                  if (ngModelCtrl.$viewValue == value) {
                    this.renderUnknownOption(value);
                  }
                }
              };
              self.renderUnknownOption = function (val) {
                var unknownVal = '? ' + hashKey(val) + ' ?';
                unknownOption.val(unknownVal);
                $element.prepend(unknownOption);
                $element.val(unknownVal);
                unknownOption.prop('selected', true);
              };
              self.hasOption = function (value) {
                return optionsMap.hasOwnProperty(value);
              };
              $scope.$on('$destroy', function () {
                self.renderUnknownOption = noop;
              });
            }
          ],
          link: function (scope, element, attr, ctrls) {
            if (!ctrls[1])
              return;
            var selectCtrl = ctrls[0], ngModelCtrl = ctrls[1], multiple = attr.multiple, optionsExp = attr.ngOptions, nullOption = false, emptyOption, optionTemplate = jqLite(document.createElement('option')), optGroupTemplate = jqLite(document.createElement('optgroup')), unknownOption = optionTemplate.clone();
            for (var i = 0, children = element.children(), ii = children.length; i < ii; i++) {
              if (children[i].value == '') {
                emptyOption = nullOption = children.eq(i);
                break;
              }
            }
            selectCtrl.init(ngModelCtrl, nullOption, unknownOption);
            if (multiple && (attr.required || attr.ngRequired)) {
              var requiredValidator = function (value) {
                ngModelCtrl.$setValidity('required', !attr.required || value && value.length);
                return value;
              };
              ngModelCtrl.$parsers.push(requiredValidator);
              ngModelCtrl.$formatters.unshift(requiredValidator);
              attr.$observe('required', function () {
                requiredValidator(ngModelCtrl.$viewValue);
              });
            }
            if (optionsExp)
              Options(scope, element, ngModelCtrl);
            else if (multiple)
              Multiple(scope, element, ngModelCtrl);
            else
              Single(scope, element, ngModelCtrl, selectCtrl);
            function Single(scope, selectElement, ngModelCtrl, selectCtrl) {
              ngModelCtrl.$render = function () {
                var viewValue = ngModelCtrl.$viewValue;
                if (selectCtrl.hasOption(viewValue)) {
                  if (unknownOption.parent())
                    unknownOption.remove();
                  selectElement.val(viewValue);
                  if (viewValue === '')
                    emptyOption.prop('selected', true);
                } else {
                  if (isUndefined(viewValue) && emptyOption) {
                    selectElement.val('');
                  } else {
                    selectCtrl.renderUnknownOption(viewValue);
                  }
                }
              };
              selectElement.bind('change', function () {
                scope.$apply(function () {
                  if (unknownOption.parent())
                    unknownOption.remove();
                  ngModelCtrl.$setViewValue(selectElement.val());
                });
              });
            }
            function Multiple(scope, selectElement, ctrl) {
              var lastView;
              ctrl.$render = function () {
                var items = new HashMap(ctrl.$viewValue);
                forEach(selectElement.find('option'), function (option) {
                  option.selected = isDefined(items.get(option.value));
                });
              };
              scope.$watch(function selectMultipleWatch() {
                if (!equals(lastView, ctrl.$viewValue)) {
                  lastView = copy(ctrl.$viewValue);
                  ctrl.$render();
                }
              });
              selectElement.bind('change', function () {
                scope.$apply(function () {
                  var array = [];
                  forEach(selectElement.find('option'), function (option) {
                    if (option.selected) {
                      array.push(option.value);
                    }
                  });
                  ctrl.$setViewValue(array);
                });
              });
            }
            function Options(scope, selectElement, ctrl) {
              var match;
              if (!(match = optionsExp.match(NG_OPTIONS_REGEXP))) {
                throw Error('Expected ngOptions in form of \'_select_ (as _label_)? for (_key_,)?_value_ in _collection_\'' + ' but got \'' + optionsExp + '\'.');
              }
              var displayFn = $parse(match[2] || match[1]), valueName = match[4] || match[6], keyName = match[5], groupByFn = $parse(match[3] || ''), valueFn = $parse(match[2] ? match[1] : valueName), valuesFn = $parse(match[7]), optionGroupsCache = [[{
                      element: selectElement,
                      label: ''
                    }]];
              if (nullOption) {
                $compile(nullOption)(scope);
                nullOption.removeClass('ng-scope');
                nullOption.remove();
              }
              selectElement.html('');
              selectElement.bind('change', function () {
                scope.$apply(function () {
                  var optionGroup, collection = valuesFn(scope) || [], locals = {}, key, value, optionElement, index, groupIndex, length, groupLength;
                  if (multiple) {
                    value = [];
                    for (groupIndex = 0, groupLength = optionGroupsCache.length; groupIndex < groupLength; groupIndex++) {
                      optionGroup = optionGroupsCache[groupIndex];
                      for (index = 1, length = optionGroup.length; index < length; index++) {
                        if ((optionElement = optionGroup[index].element)[0].selected) {
                          key = optionElement.val();
                          if (keyName)
                            locals[keyName] = key;
                          locals[valueName] = collection[key];
                          value.push(valueFn(scope, locals));
                        }
                      }
                    }
                  } else {
                    key = selectElement.val();
                    if (key == '?') {
                      value = undefined;
                    } else if (key == '') {
                      value = null;
                    } else {
                      locals[valueName] = collection[key];
                      if (keyName)
                        locals[keyName] = key;
                      value = valueFn(scope, locals);
                    }
                  }
                  ctrl.$setViewValue(value);
                });
              });
              ctrl.$render = render;
              scope.$watch(render);
              function render() {
                var optionGroups = { '': [] }, optionGroupNames = [''], optionGroupName, optionGroup, option, existingParent, existingOptions, existingOption, modelValue = ctrl.$modelValue, values = valuesFn(scope) || [], keys = keyName ? sortedKeys(values) : values, groupLength, length, groupIndex, index, locals = {}, selected, selectedSet = false, lastElement, element, label;
                if (multiple) {
                  selectedSet = new HashMap(modelValue);
                }
                for (index = 0; length = keys.length, index < length; index++) {
                  locals[valueName] = values[keyName ? locals[keyName] = keys[index] : index];
                  optionGroupName = groupByFn(scope, locals) || '';
                  if (!(optionGroup = optionGroups[optionGroupName])) {
                    optionGroup = optionGroups[optionGroupName] = [];
                    optionGroupNames.push(optionGroupName);
                  }
                  if (multiple) {
                    selected = selectedSet.remove(valueFn(scope, locals)) != undefined;
                  } else {
                    selected = modelValue === valueFn(scope, locals);
                    selectedSet = selectedSet || selected;
                  }
                  label = displayFn(scope, locals);
                  label = label === undefined ? '' : label;
                  optionGroup.push({
                    id: keyName ? keys[index] : index,
                    label: label,
                    selected: selected
                  });
                }
                if (!multiple) {
                  if (nullOption || modelValue === null) {
                    optionGroups[''].unshift({
                      id: '',
                      label: '',
                      selected: !selectedSet
                    });
                  } else if (!selectedSet) {
                    optionGroups[''].unshift({
                      id: '?',
                      label: '',
                      selected: true
                    });
                  }
                }
                for (groupIndex = 0, groupLength = optionGroupNames.length; groupIndex < groupLength; groupIndex++) {
                  optionGroupName = optionGroupNames[groupIndex];
                  optionGroup = optionGroups[optionGroupName];
                  if (optionGroupsCache.length <= groupIndex) {
                    existingParent = {
                      element: optGroupTemplate.clone().attr('label', optionGroupName),
                      label: optionGroup.label
                    };
                    existingOptions = [existingParent];
                    optionGroupsCache.push(existingOptions);
                    selectElement.append(existingParent.element);
                  } else {
                    existingOptions = optionGroupsCache[groupIndex];
                    existingParent = existingOptions[0];
                    if (existingParent.label != optionGroupName) {
                      existingParent.element.attr('label', existingParent.label = optionGroupName);
                    }
                  }
                  lastElement = null;
                  for (index = 0, length = optionGroup.length; index < length; index++) {
                    option = optionGroup[index];
                    if (existingOption = existingOptions[index + 1]) {
                      lastElement = existingOption.element;
                      if (existingOption.label !== option.label) {
                        lastElement.text(existingOption.label = option.label);
                      }
                      if (existingOption.id !== option.id) {
                        lastElement.val(existingOption.id = option.id);
                      }
                      if (lastElement[0].selected !== option.selected) {
                        lastElement.prop('selected', existingOption.selected = option.selected);
                      }
                    } else {
                      if (option.id === '' && nullOption) {
                        element = nullOption;
                      } else {
                        (element = optionTemplate.clone()).val(option.id).attr('selected', option.selected).text(option.label);
                      }
                      existingOptions.push(existingOption = {
                        element: element,
                        label: option.label,
                        id: option.id,
                        selected: option.selected
                      });
                      if (lastElement) {
                        lastElement.after(element);
                      } else {
                        existingParent.element.append(element);
                      }
                      lastElement = element;
                    }
                  }
                  index++;
                  while (existingOptions.length > index) {
                    existingOptions.pop().element.remove();
                  }
                }
                while (optionGroupsCache.length > groupIndex) {
                  optionGroupsCache.pop()[0].element.remove();
                }
              }
            }
          }
        };
      }
    ];
  var optionDirective = [
      '$interpolate',
      function ($interpolate) {
        var nullSelectCtrl = {
            addOption: noop,
            removeOption: noop
          };
        return {
          restrict: 'E',
          priority: 100,
          compile: function (element, attr) {
            if (isUndefined(attr.value)) {
              var interpolateFn = $interpolate(element.text(), true);
              if (!interpolateFn) {
                attr.$set('value', element.text());
              }
            }
            return function (scope, element, attr) {
              var selectCtrlName = '$selectController', parent = element.parent(), selectCtrl = parent.data(selectCtrlName) || parent.parent().data(selectCtrlName);
              if (selectCtrl && selectCtrl.databound) {
                element.prop('selected', false);
              } else {
                selectCtrl = nullSelectCtrl;
              }
              if (interpolateFn) {
                scope.$watch(interpolateFn, function interpolateWatchAction(newVal, oldVal) {
                  attr.$set('value', newVal);
                  if (newVal !== oldVal)
                    selectCtrl.removeOption(oldVal);
                  selectCtrl.addOption(newVal);
                });
              } else {
                selectCtrl.addOption(attr.value);
              }
              element.bind('$destroy', function () {
                selectCtrl.removeOption(attr.value);
              });
            };
          }
        };
      }
    ];
  var styleDirective = valueFn({
      restrict: 'E',
      terminal: true
    });
  bindJQuery();
  publishExternalAPI(angular);
  jqLite(document).ready(function () {
    angularInit(document, bootstrap);
  });
}(window, document));
angular.element(document).find('head').append('<style type="text/css">@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak{display:none !important;}ng\\:form{display:block;}</style>');
(function () {
  var root = this;
  var previousUnderscore = root._;
  var breaker = {};
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;
  var push = ArrayProto.push, slice = ArrayProto.slice, concat = ArrayProto.concat, toString = ObjProto.toString, hasOwnProperty = ObjProto.hasOwnProperty;
  var nativeForEach = ArrayProto.forEach, nativeMap = ArrayProto.map, nativeReduce = ArrayProto.reduce, nativeReduceRight = ArrayProto.reduceRight, nativeFilter = ArrayProto.filter, nativeEvery = ArrayProto.every, nativeSome = ArrayProto.some, nativeIndexOf = ArrayProto.indexOf, nativeLastIndexOf = ArrayProto.lastIndexOf, nativeIsArray = Array.isArray, nativeKeys = Object.keys, nativeBind = FuncProto.bind;
  var _ = function (obj) {
    if (obj instanceof _)
      return obj;
    if (!(this instanceof _))
      return new _(obj);
    this._wrapped = obj;
  };
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }
  _.VERSION = '1.6.0';
  var each = _.each = _.forEach = function (obj, iterator, context) {
      if (obj == null)
        return obj;
      if (nativeForEach && obj.forEach === nativeForEach) {
        obj.forEach(iterator, context);
      } else if (obj.length === +obj.length) {
        for (var i = 0, length = obj.length; i < length; i++) {
          if (iterator.call(context, obj[i], i, obj) === breaker)
            return;
        }
      } else {
        var keys = _.keys(obj);
        for (var i = 0, length = keys.length; i < length; i++) {
          if (iterator.call(context, obj[keys[i]], keys[i], obj) === breaker)
            return;
        }
      }
      return obj;
    };
  _.map = _.collect = function (obj, iterator, context) {
    var results = [];
    if (obj == null)
      return results;
    if (nativeMap && obj.map === nativeMap)
      return obj.map(iterator, context);
    each(obj, function (value, index, list) {
      results.push(iterator.call(context, value, index, list));
    });
    return results;
  };
  var reduceError = 'Reduce of empty array with no initial value';
  _.reduce = _.foldl = _.inject = function (obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null)
      obj = [];
    if (nativeReduce && obj.reduce === nativeReduce) {
      if (context)
        iterator = _.bind(iterator, context);
      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
    }
    each(obj, function (value, index, list) {
      if (!initial) {
        memo = value;
        initial = true;
      } else {
        memo = iterator.call(context, memo, value, index, list);
      }
    });
    if (!initial)
      throw new TypeError(reduceError);
    return memo;
  };
  _.reduceRight = _.foldr = function (obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null)
      obj = [];
    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
      if (context)
        iterator = _.bind(iterator, context);
      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
    }
    var length = obj.length;
    if (length !== +length) {
      var keys = _.keys(obj);
      length = keys.length;
    }
    each(obj, function (value, index, list) {
      index = keys ? keys[--length] : --length;
      if (!initial) {
        memo = obj[index];
        initial = true;
      } else {
        memo = iterator.call(context, memo, obj[index], index, list);
      }
    });
    if (!initial)
      throw new TypeError(reduceError);
    return memo;
  };
  _.find = _.detect = function (obj, predicate, context) {
    var result;
    any(obj, function (value, index, list) {
      if (predicate.call(context, value, index, list)) {
        result = value;
        return true;
      }
    });
    return result;
  };
  _.filter = _.select = function (obj, predicate, context) {
    var results = [];
    if (obj == null)
      return results;
    if (nativeFilter && obj.filter === nativeFilter)
      return obj.filter(predicate, context);
    each(obj, function (value, index, list) {
      if (predicate.call(context, value, index, list))
        results.push(value);
    });
    return results;
  };
  _.reject = function (obj, predicate, context) {
    return _.filter(obj, function (value, index, list) {
      return !predicate.call(context, value, index, list);
    }, context);
  };
  _.every = _.all = function (obj, predicate, context) {
    predicate || (predicate = _.identity);
    var result = true;
    if (obj == null)
      return result;
    if (nativeEvery && obj.every === nativeEvery)
      return obj.every(predicate, context);
    each(obj, function (value, index, list) {
      if (!(result = result && predicate.call(context, value, index, list)))
        return breaker;
    });
    return !!result;
  };
  var any = _.some = _.any = function (obj, predicate, context) {
      predicate || (predicate = _.identity);
      var result = false;
      if (obj == null)
        return result;
      if (nativeSome && obj.some === nativeSome)
        return obj.some(predicate, context);
      each(obj, function (value, index, list) {
        if (result || (result = predicate.call(context, value, index, list)))
          return breaker;
      });
      return !!result;
    };
  _.contains = _.include = function (obj, target) {
    if (obj == null)
      return false;
    if (nativeIndexOf && obj.indexOf === nativeIndexOf)
      return obj.indexOf(target) != -1;
    return any(obj, function (value) {
      return value === target;
    });
  };
  _.invoke = function (obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function (value) {
      return (isFunc ? method : value[method]).apply(value, args);
    });
  };
  _.pluck = function (obj, key) {
    return _.map(obj, _.property(key));
  };
  _.where = function (obj, attrs) {
    return _.filter(obj, _.matches(attrs));
  };
  _.findWhere = function (obj, attrs) {
    return _.find(obj, _.matches(attrs));
  };
  _.max = function (obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.max.apply(Math, obj);
    }
    var result = -Infinity, lastComputed = -Infinity;
    each(obj, function (value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      if (computed > lastComputed) {
        result = value;
        lastComputed = computed;
      }
    });
    return result;
  };
  _.min = function (obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.min.apply(Math, obj);
    }
    var result = Infinity, lastComputed = Infinity;
    each(obj, function (value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      if (computed < lastComputed) {
        result = value;
        lastComputed = computed;
      }
    });
    return result;
  };
  _.shuffle = function (obj) {
    var rand;
    var index = 0;
    var shuffled = [];
    each(obj, function (value) {
      rand = _.random(index++);
      shuffled[index - 1] = shuffled[rand];
      shuffled[rand] = value;
    });
    return shuffled;
  };
  _.sample = function (obj, n, guard) {
    if (n == null || guard) {
      if (obj.length !== +obj.length)
        obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    return _.shuffle(obj).slice(0, Math.max(0, n));
  };
  var lookupIterator = function (value) {
    if (value == null)
      return _.identity;
    if (_.isFunction(value))
      return value;
    return _.property(value);
  };
  _.sortBy = function (obj, iterator, context) {
    iterator = lookupIterator(iterator);
    return _.pluck(_.map(obj, function (value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iterator.call(context, value, index, list)
      };
    }).sort(function (left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0)
          return 1;
        if (a < b || b === void 0)
          return -1;
      }
      return left.index - right.index;
    }), 'value');
  };
  var group = function (behavior) {
    return function (obj, iterator, context) {
      var result = {};
      iterator = lookupIterator(iterator);
      each(obj, function (value, index) {
        var key = iterator.call(context, value, index, obj);
        behavior(result, key, value);
      });
      return result;
    };
  };
  _.groupBy = group(function (result, key, value) {
    _.has(result, key) ? result[key].push(value) : result[key] = [value];
  });
  _.indexBy = group(function (result, key, value) {
    result[key] = value;
  });
  _.countBy = group(function (result, key) {
    _.has(result, key) ? result[key]++ : result[key] = 1;
  });
  _.sortedIndex = function (array, obj, iterator, context) {
    iterator = lookupIterator(iterator);
    var value = iterator.call(context, obj);
    var low = 0, high = array.length;
    while (low < high) {
      var mid = low + high >>> 1;
      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;
    }
    return low;
  };
  _.toArray = function (obj) {
    if (!obj)
      return [];
    if (_.isArray(obj))
      return slice.call(obj);
    if (obj.length === +obj.length)
      return _.map(obj, _.identity);
    return _.values(obj);
  };
  _.size = function (obj) {
    if (obj == null)
      return 0;
    return obj.length === +obj.length ? obj.length : _.keys(obj).length;
  };
  _.first = _.head = _.take = function (array, n, guard) {
    if (array == null)
      return void 0;
    if (n == null || guard)
      return array[0];
    if (n < 0)
      return [];
    return slice.call(array, 0, n);
  };
  _.initial = function (array, n, guard) {
    return slice.call(array, 0, array.length - (n == null || guard ? 1 : n));
  };
  _.last = function (array, n, guard) {
    if (array == null)
      return void 0;
    if (n == null || guard)
      return array[array.length - 1];
    return slice.call(array, Math.max(array.length - n, 0));
  };
  _.rest = _.tail = _.drop = function (array, n, guard) {
    return slice.call(array, n == null || guard ? 1 : n);
  };
  _.compact = function (array) {
    return _.filter(array, _.identity);
  };
  var flatten = function (input, shallow, output) {
    if (shallow && _.every(input, _.isArray)) {
      return concat.apply(output, input);
    }
    each(input, function (value) {
      if (_.isArray(value) || _.isArguments(value)) {
        shallow ? push.apply(output, value) : flatten(value, shallow, output);
      } else {
        output.push(value);
      }
    });
    return output;
  };
  _.flatten = function (array, shallow) {
    return flatten(array, shallow, []);
  };
  _.without = function (array) {
    return _.difference(array, slice.call(arguments, 1));
  };
  _.partition = function (array, predicate) {
    var pass = [], fail = [];
    each(array, function (elem) {
      (predicate(elem) ? pass : fail).push(elem);
    });
    return [
      pass,
      fail
    ];
  };
  _.uniq = _.unique = function (array, isSorted, iterator, context) {
    if (_.isFunction(isSorted)) {
      context = iterator;
      iterator = isSorted;
      isSorted = false;
    }
    var initial = iterator ? _.map(array, iterator, context) : array;
    var results = [];
    var seen = [];
    each(initial, function (value, index) {
      if (isSorted ? !index || seen[seen.length - 1] !== value : !_.contains(seen, value)) {
        seen.push(value);
        results.push(array[index]);
      }
    });
    return results;
  };
  _.union = function () {
    return _.uniq(_.flatten(arguments, true));
  };
  _.intersection = function (array) {
    var rest = slice.call(arguments, 1);
    return _.filter(_.uniq(array), function (item) {
      return _.every(rest, function (other) {
        return _.contains(other, item);
      });
    });
  };
  _.difference = function (array) {
    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));
    return _.filter(array, function (value) {
      return !_.contains(rest, value);
    });
  };
  _.zip = function () {
    var length = _.max(_.pluck(arguments, 'length').concat(0));
    var results = new Array(length);
    for (var i = 0; i < length; i++) {
      results[i] = _.pluck(arguments, '' + i);
    }
    return results;
  };
  _.object = function (list, values) {
    if (list == null)
      return {};
    var result = {};
    for (var i = 0, length = list.length; i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };
  _.indexOf = function (array, item, isSorted) {
    if (array == null)
      return -1;
    var i = 0, length = array.length;
    if (isSorted) {
      if (typeof isSorted == 'number') {
        i = isSorted < 0 ? Math.max(0, length + isSorted) : isSorted;
      } else {
        i = _.sortedIndex(array, item);
        return array[i] === item ? i : -1;
      }
    }
    if (nativeIndexOf && array.indexOf === nativeIndexOf)
      return array.indexOf(item, isSorted);
    for (; i < length; i++)
      if (array[i] === item)
        return i;
    return -1;
  };
  _.lastIndexOf = function (array, item, from) {
    if (array == null)
      return -1;
    var hasIndex = from != null;
    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {
      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);
    }
    var i = hasIndex ? from : array.length;
    while (i--)
      if (array[i] === item)
        return i;
    return -1;
  };
  _.range = function (start, stop, step) {
    if (arguments.length <= 1) {
      stop = start || 0;
      start = 0;
    }
    step = arguments[2] || 1;
    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var idx = 0;
    var range = new Array(length);
    while (idx < length) {
      range[idx++] = start;
      start += step;
    }
    return range;
  };
  var ctor = function () {
  };
  _.bind = function (func, context) {
    var args, bound;
    if (nativeBind && func.bind === nativeBind)
      return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func))
      throw new TypeError();
    args = slice.call(arguments, 2);
    return bound = function () {
      if (!(this instanceof bound))
        return func.apply(context, args.concat(slice.call(arguments)));
      ctor.prototype = func.prototype;
      var self = new ctor();
      ctor.prototype = null;
      var result = func.apply(self, args.concat(slice.call(arguments)));
      if (Object(result) === result)
        return result;
      return self;
    };
  };
  _.partial = function (func) {
    var boundArgs = slice.call(arguments, 1);
    return function () {
      var position = 0;
      var args = boundArgs.slice();
      for (var i = 0, length = args.length; i < length; i++) {
        if (args[i] === _)
          args[i] = arguments[position++];
      }
      while (position < arguments.length)
        args.push(arguments[position++]);
      return func.apply(this, args);
    };
  };
  _.bindAll = function (obj) {
    var funcs = slice.call(arguments, 1);
    if (funcs.length === 0)
      throw new Error('bindAll must be passed function names');
    each(funcs, function (f) {
      obj[f] = _.bind(obj[f], obj);
    });
    return obj;
  };
  _.memoize = function (func, hasher) {
    var memo = {};
    hasher || (hasher = _.identity);
    return function () {
      var key = hasher.apply(this, arguments);
      return _.has(memo, key) ? memo[key] : memo[key] = func.apply(this, arguments);
    };
  };
  _.delay = function (func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function () {
      return func.apply(null, args);
    }, wait);
  };
  _.defer = function (func) {
    return _.delay.apply(_, [
      func,
      1
    ].concat(slice.call(arguments, 1)));
  };
  _.throttle = function (func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    options || (options = {});
    var later = function () {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      context = args = null;
    };
    return function () {
      var now = _.now();
      if (!previous && options.leading === false)
        previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0) {
        clearTimeout(timeout);
        timeout = null;
        previous = now;
        result = func.apply(context, args);
        context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };
  _.debounce = function (func, wait, immediate) {
    var timeout, args, context, timestamp, result;
    var later = function () {
      var last = _.now() - timestamp;
      if (last < wait) {
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          context = args = null;
        }
      }
    };
    return function () {
      context = this;
      args = arguments;
      timestamp = _.now();
      var callNow = immediate && !timeout;
      if (!timeout) {
        timeout = setTimeout(later, wait);
      }
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }
      return result;
    };
  };
  _.once = function (func) {
    var ran = false, memo;
    return function () {
      if (ran)
        return memo;
      ran = true;
      memo = func.apply(this, arguments);
      func = null;
      return memo;
    };
  };
  _.wrap = function (func, wrapper) {
    return _.partial(wrapper, func);
  };
  _.compose = function () {
    var funcs = arguments;
    return function () {
      var args = arguments;
      for (var i = funcs.length - 1; i >= 0; i--) {
        args = [funcs[i].apply(this, args)];
      }
      return args[0];
    };
  };
  _.after = function (times, func) {
    return function () {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };
  _.keys = function (obj) {
    if (!_.isObject(obj))
      return [];
    if (nativeKeys)
      return nativeKeys(obj);
    var keys = [];
    for (var key in obj)
      if (_.has(obj, key))
        keys.push(key);
    return keys;
  };
  _.values = function (obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = new Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };
  _.pairs = function (obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = new Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [
        keys[i],
        obj[keys[i]]
      ];
    }
    return pairs;
  };
  _.invert = function (obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };
  _.functions = _.methods = function (obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key]))
        names.push(key);
    }
    return names.sort();
  };
  _.extend = function (obj) {
    each(slice.call(arguments, 1), function (source) {
      if (source) {
        for (var prop in source) {
          obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };
  _.pick = function (obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    each(keys, function (key) {
      if (key in obj)
        copy[key] = obj[key];
    });
    return copy;
  };
  _.omit = function (obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    for (var key in obj) {
      if (!_.contains(keys, key))
        copy[key] = obj[key];
    }
    return copy;
  };
  _.defaults = function (obj) {
    each(slice.call(arguments, 1), function (source) {
      if (source) {
        for (var prop in source) {
          if (obj[prop] === void 0)
            obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };
  _.clone = function (obj) {
    if (!_.isObject(obj))
      return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };
  _.tap = function (obj, interceptor) {
    interceptor(obj);
    return obj;
  };
  var eq = function (a, b, aStack, bStack) {
    if (a === b)
      return a !== 0 || 1 / a == 1 / b;
    if (a == null || b == null)
      return a === b;
    if (a instanceof _)
      a = a._wrapped;
    if (b instanceof _)
      b = b._wrapped;
    var className = toString.call(a);
    if (className != toString.call(b))
      return false;
    switch (className) {
    case '[object String]':
      return a == String(b);
    case '[object Number]':
      return a != +a ? b != +b : a == 0 ? 1 / a == 1 / b : a == +b;
    case '[object Date]':
    case '[object Boolean]':
      return +a == +b;
    case '[object RegExp]':
      return a.source == b.source && a.global == b.global && a.multiline == b.multiline && a.ignoreCase == b.ignoreCase;
    }
    if (typeof a != 'object' || typeof b != 'object')
      return false;
    var length = aStack.length;
    while (length--) {
      if (aStack[length] == a)
        return bStack[length] == b;
    }
    var aCtor = a.constructor, bCtor = b.constructor;
    if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor && _.isFunction(bCtor) && bCtor instanceof bCtor) && ('constructor' in a && 'constructor' in b)) {
      return false;
    }
    aStack.push(a);
    bStack.push(b);
    var size = 0, result = true;
    if (className == '[object Array]') {
      size = a.length;
      result = size == b.length;
      if (result) {
        while (size--) {
          if (!(result = eq(a[size], b[size], aStack, bStack)))
            break;
        }
      }
    } else {
      for (var key in a) {
        if (_.has(a, key)) {
          size++;
          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack)))
            break;
        }
      }
      if (result) {
        for (key in b) {
          if (_.has(b, key) && !size--)
            break;
        }
        result = !size;
      }
    }
    aStack.pop();
    bStack.pop();
    return result;
  };
  _.isEqual = function (a, b) {
    return eq(a, b, [], []);
  };
  _.isEmpty = function (obj) {
    if (obj == null)
      return true;
    if (_.isArray(obj) || _.isString(obj))
      return obj.length === 0;
    for (var key in obj)
      if (_.has(obj, key))
        return false;
    return true;
  };
  _.isElement = function (obj) {
    return !!(obj && obj.nodeType === 1);
  };
  _.isArray = nativeIsArray || function (obj) {
    return toString.call(obj) == '[object Array]';
  };
  _.isObject = function (obj) {
    return obj === Object(obj);
  };
  each([
    'Arguments',
    'Function',
    'String',
    'Number',
    'Date',
    'RegExp'
  ], function (name) {
    _['is' + name] = function (obj) {
      return toString.call(obj) == '[object ' + name + ']';
    };
  });
  if (!_.isArguments(arguments)) {
    _.isArguments = function (obj) {
      return !!(obj && _.has(obj, 'callee'));
    };
  }
  if (typeof /./ !== 'function') {
    _.isFunction = function (obj) {
      return typeof obj === 'function';
    };
  }
  _.isFinite = function (obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };
  _.isNaN = function (obj) {
    return _.isNumber(obj) && obj != +obj;
  };
  _.isBoolean = function (obj) {
    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
  };
  _.isNull = function (obj) {
    return obj === null;
  };
  _.isUndefined = function (obj) {
    return obj === void 0;
  };
  _.has = function (obj, key) {
    return hasOwnProperty.call(obj, key);
  };
  _.noConflict = function () {
    root._ = previousUnderscore;
    return this;
  };
  _.identity = function (value) {
    return value;
  };
  _.constant = function (value) {
    return function () {
      return value;
    };
  };
  _.property = function (key) {
    return function (obj) {
      return obj[key];
    };
  };
  _.matches = function (attrs) {
    return function (obj) {
      if (obj === attrs)
        return true;
      for (var key in attrs) {
        if (attrs[key] !== obj[key])
          return false;
      }
      return true;
    };
  };
  _.times = function (n, iterator, context) {
    var accum = Array(Math.max(0, n));
    for (var i = 0; i < n; i++)
      accum[i] = iterator.call(context, i);
    return accum;
  };
  _.random = function (min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };
  _.now = Date.now || function () {
    return new Date().getTime();
  };
  var entityMap = {
      escape: {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        '\'': '&#x27;'
      }
    };
  entityMap.unescape = _.invert(entityMap.escape);
  var entityRegexes = {
      escape: new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),
      unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')
    };
  _.each([
    'escape',
    'unescape'
  ], function (method) {
    _[method] = function (string) {
      if (string == null)
        return '';
      return ('' + string).replace(entityRegexes[method], function (match) {
        return entityMap[method][match];
      });
    };
  });
  _.result = function (object, property) {
    if (object == null)
      return void 0;
    var value = object[property];
    return _.isFunction(value) ? value.call(object) : value;
  };
  _.mixin = function (obj) {
    each(_.functions(obj), function (name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function () {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result.call(this, func.apply(_, args));
      };
    });
  };
  var idCounter = 0;
  _.uniqueId = function (prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };
  _.templateSettings = {
    evaluate: /<%([\s\S]+?)%>/g,
    interpolate: /<%=([\s\S]+?)%>/g,
    escape: /<%-([\s\S]+?)%>/g
  };
  var noMatch = /(.)^/;
  var escapes = {
      '\'': '\'',
      '\\': '\\',
      '\r': 'r',
      '\n': 'n',
      '\t': 't',
      '\u2028': 'u2028',
      '\u2029': 'u2029'
    };
  var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;
  _.template = function (text, data, settings) {
    var render;
    settings = _.defaults({}, settings, _.templateSettings);
    var matcher = new RegExp([
        (settings.escape || noMatch).source,
        (settings.interpolate || noMatch).source,
        (settings.evaluate || noMatch).source
      ].join('|') + '|$', 'g');
    var index = 0;
    var source = '__p+=\'';
    text.replace(matcher, function (match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escaper, function (match) {
        return '\\' + escapes[match];
      });
      if (escape) {
        source += '\'+\n((__t=(' + escape + '))==null?\'\':_.escape(__t))+\n\'';
      }
      if (interpolate) {
        source += '\'+\n((__t=(' + interpolate + '))==null?\'\':__t)+\n\'';
      }
      if (evaluate) {
        source += '\';\n' + evaluate + '\n__p+=\'';
      }
      index = offset + match.length;
      return match;
    });
    source += '\';\n';
    if (!settings.variable)
      source = 'with(obj||{}){\n' + source + '}\n';
    source = 'var __t,__p=\'\',__j=Array.prototype.join,' + 'print=function(){__p+=__j.call(arguments,\'\');};\n' + source + 'return __p;\n';
    try {
      render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }
    if (data)
      return render(data, _);
    var template = function (data) {
      return render.call(this, data, _);
    };
    template.source = 'function(' + (settings.variable || 'obj') + '){\n' + source + '}';
    return template;
  };
  _.chain = function (obj) {
    return _(obj).chain();
  };
  var result = function (obj) {
    return this._chain ? _(obj).chain() : obj;
  };
  _.mixin(_);
  each([
    'pop',
    'push',
    'reverse',
    'shift',
    'sort',
    'splice',
    'unshift'
  ], function (name) {
    var method = ArrayProto[name];
    _.prototype[name] = function () {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name == 'shift' || name == 'splice') && obj.length === 0)
        delete obj[0];
      return result.call(this, obj);
    };
  });
  each([
    'concat',
    'join',
    'slice'
  ], function (name) {
    var method = ArrayProto[name];
    _.prototype[name] = function () {
      return result.call(this, method.apply(this._wrapped, arguments));
    };
  });
  _.extend(_.prototype, {
    chain: function () {
      this._chain = true;
      return this;
    },
    value: function () {
      return this._wrapped;
    }
  });
  if (typeof define === 'function' && define.amd) {
    define('underscore', [], function () {
      return _;
    });
  }
}.call(this));
(function (root, undef) {
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, slice = ArrayProto.slice, hasOwnProp = ObjProto.hasOwnProperty, nativeForEach = ArrayProto.forEach, breaker = {};
  var _ = {
      forEach: function (obj, iterator, context) {
        var i, l, key;
        if (obj === null) {
          return;
        }
        if (nativeForEach && obj.forEach === nativeForEach) {
          obj.forEach(iterator, context);
        } else if (obj.length === +obj.length) {
          for (i = 0, l = obj.length; i < l; i++) {
            if (i in obj && iterator.call(context, obj[i], i, obj) === breaker) {
              return;
            }
          }
        } else {
          for (key in obj) {
            if (hasOwnProp.call(obj, key)) {
              if (iterator.call(context, obj[key], key, obj) === breaker) {
                return;
              }
            }
          }
        }
      },
      extend: function (obj) {
        this.forEach(slice.call(arguments, 1), function (source) {
          for (var prop in source) {
            obj[prop] = source[prop];
          }
        });
        return obj;
      }
    };
  var Jed = function (options) {
    this.defaults = {
      'locale_data': {
        'messages': {
          '': {
            'domain': 'messages',
            'lang': 'en',
            'plural_forms': 'nplurals=2; plural=(n != 1);'
          }
        }
      },
      'domain': 'messages'
    };
    this.options = _.extend({}, this.defaults, options);
    this.textdomain(this.options.domain);
    if (options.domain && !this.options.locale_data[this.options.domain]) {
      throw new Error('Text domain set to non-existent domain: `' + options.domain + '`');
    }
  };
  Jed.context_delimiter = String.fromCharCode(4);
  function getPluralFormFunc(plural_form_string) {
    return Jed.PF.compile(plural_form_string || 'nplurals=2; plural=(n != 1);');
  }
  function Chain(key, i18n) {
    this._key = key;
    this._i18n = i18n;
  }
  _.extend(Chain.prototype, {
    onDomain: function (domain) {
      this._domain = domain;
      return this;
    },
    withContext: function (context) {
      this._context = context;
      return this;
    },
    ifPlural: function (num, pkey) {
      this._val = num;
      this._pkey = pkey;
      return this;
    },
    fetch: function (sArr) {
      if ({}.toString.call(sArr) != '[object Array]') {
        sArr = [].slice.call(arguments);
      }
      return (sArr && sArr.length ? Jed.sprintf : function (x) {
        return x;
      })(this._i18n.dcnpgettext(this._domain, this._context, this._key, this._pkey, this._val), sArr);
    }
  });
  _.extend(Jed.prototype, {
    translate: function (key) {
      return new Chain(key, this);
    },
    textdomain: function (domain) {
      if (!domain) {
        return this._textdomain;
      }
      this._textdomain = domain;
    },
    gettext: function (key) {
      return this.dcnpgettext.call(this, undef, undef, key);
    },
    dgettext: function (domain, key) {
      return this.dcnpgettext.call(this, domain, undef, key);
    },
    dcgettext: function (domain, key) {
      return this.dcnpgettext.call(this, domain, undef, key);
    },
    ngettext: function (skey, pkey, val) {
      return this.dcnpgettext.call(this, undef, undef, skey, pkey, val);
    },
    dngettext: function (domain, skey, pkey, val) {
      return this.dcnpgettext.call(this, domain, undef, skey, pkey, val);
    },
    dcngettext: function (domain, skey, pkey, val) {
      return this.dcnpgettext.call(this, domain, undef, skey, pkey, val);
    },
    pgettext: function (context, key) {
      return this.dcnpgettext.call(this, undef, context, key);
    },
    dpgettext: function (domain, context, key) {
      return this.dcnpgettext.call(this, domain, context, key);
    },
    dcpgettext: function (domain, context, key) {
      return this.dcnpgettext.call(this, domain, context, key);
    },
    npgettext: function (context, skey, pkey, val) {
      return this.dcnpgettext.call(this, undef, context, skey, pkey, val);
    },
    dnpgettext: function (domain, context, skey, pkey, val) {
      return this.dcnpgettext.call(this, domain, context, skey, pkey, val);
    },
    dcnpgettext: function (domain, context, singular_key, plural_key, val) {
      plural_key = plural_key || singular_key;
      domain = domain || this._textdomain;
      val = typeof val == 'undefined' ? 1 : val;
      var fallback;
      if (!this.options) {
        fallback = new Jed();
        return fallback.dcnpgettext.call(fallback, undefined, undefined, singular_key, plural_key, val);
      }
      if (!this.options.locale_data) {
        throw new Error('No locale data provided.');
      }
      if (!this.options.locale_data[domain]) {
        throw new Error('Domain `' + domain + '` was not found.');
      }
      if (!this.options.locale_data[domain]['']) {
        throw new Error('No locale meta information provided.');
      }
      if (!singular_key) {
        throw new Error('No translation key found.');
      }
      if (typeof val != 'number') {
        val = parseInt(val, 10);
        if (isNaN(val)) {
          throw new Error('The number that was passed in is not a number.');
        }
      }
      var key = context ? context + Jed.context_delimiter + singular_key : singular_key, locale_data = this.options.locale_data, dict = locale_data[domain], pluralForms = dict[''].plural_forms || (locale_data.messages || this.defaults.locale_data.messages)[''].plural_forms, val_idx = getPluralFormFunc(pluralForms)(val) + 1, val_list, res;
      if (!dict) {
        throw new Error('No domain named `' + domain + '` could be found.');
      }
      val_list = dict[key];
      if (!val_list || val_idx >= val_list.length) {
        if (this.options.missing_key_callback) {
          this.options.missing_key_callback(key);
        }
        res = [
          null,
          singular_key,
          plural_key
        ];
        return res[getPluralFormFunc(pluralForms)(val) + 1];
      }
      res = val_list[val_idx];
      if (!res) {
        res = [
          null,
          singular_key,
          plural_key
        ];
        return res[getPluralFormFunc(pluralForms)(val) + 1];
      }
      return res;
    }
  });
  var sprintf = function () {
      function get_type(variable) {
        return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase();
      }
      function str_repeat(input, multiplier) {
        for (var output = []; multiplier > 0; output[--multiplier] = input) {
        }
        return output.join('');
      }
      var str_format = function () {
        if (!str_format.cache.hasOwnProperty(arguments[0])) {
          str_format.cache[arguments[0]] = str_format.parse(arguments[0]);
        }
        return str_format.format.call(null, str_format.cache[arguments[0]], arguments);
      };
      str_format.format = function (parse_tree, argv) {
        var cursor = 1, tree_length = parse_tree.length, node_type = '', arg, output = [], i, k, match, pad, pad_character, pad_length;
        for (i = 0; i < tree_length; i++) {
          node_type = get_type(parse_tree[i]);
          if (node_type === 'string') {
            output.push(parse_tree[i]);
          } else if (node_type === 'array') {
            match = parse_tree[i];
            if (match[2]) {
              arg = argv[cursor];
              for (k = 0; k < match[2].length; k++) {
                if (!arg.hasOwnProperty(match[2][k])) {
                  throw sprintf('[sprintf] property "%s" does not exist', match[2][k]);
                }
                arg = arg[match[2][k]];
              }
            } else if (match[1]) {
              arg = argv[match[1]];
            } else {
              arg = argv[cursor++];
            }
            if (/[^s]/.test(match[8]) && get_type(arg) != 'number') {
              throw sprintf('[sprintf] expecting number but found %s', get_type(arg));
            }
            if (typeof arg == 'undefined' || arg === null) {
              arg = '';
            }
            switch (match[8]) {
            case 'b':
              arg = arg.toString(2);
              break;
            case 'c':
              arg = String.fromCharCode(arg);
              break;
            case 'd':
              arg = parseInt(arg, 10);
              break;
            case 'e':
              arg = match[7] ? arg.toExponential(match[7]) : arg.toExponential();
              break;
            case 'f':
              arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg);
              break;
            case 'o':
              arg = arg.toString(8);
              break;
            case 's':
              arg = (arg = String(arg)) && match[7] ? arg.substring(0, match[7]) : arg;
              break;
            case 'u':
              arg = Math.abs(arg);
              break;
            case 'x':
              arg = arg.toString(16);
              break;
            case 'X':
              arg = arg.toString(16).toUpperCase();
              break;
            }
            arg = /[def]/.test(match[8]) && match[3] && arg >= 0 ? '+' + arg : arg;
            pad_character = match[4] ? match[4] == '0' ? '0' : match[4].charAt(1) : ' ';
            pad_length = match[6] - String(arg).length;
            pad = match[6] ? str_repeat(pad_character, pad_length) : '';
            output.push(match[5] ? arg + pad : pad + arg);
          }
        }
        return output.join('');
      };
      str_format.cache = {};
      str_format.parse = function (fmt) {
        var _fmt = fmt, match = [], parse_tree = [], arg_names = 0;
        while (_fmt) {
          if ((match = /^[^\x25]+/.exec(_fmt)) !== null) {
            parse_tree.push(match[0]);
          } else if ((match = /^\x25{2}/.exec(_fmt)) !== null) {
            parse_tree.push('%');
          } else if ((match = /^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-fosuxX])/.exec(_fmt)) !== null) {
            if (match[2]) {
              arg_names |= 1;
              var field_list = [], replacement_field = match[2], field_match = [];
              if ((field_match = /^([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
                field_list.push(field_match[1]);
                while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {
                  if ((field_match = /^\.([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
                    field_list.push(field_match[1]);
                  } else if ((field_match = /^\[(\d+)\]/.exec(replacement_field)) !== null) {
                    field_list.push(field_match[1]);
                  } else {
                    throw '[sprintf] huh?';
                  }
                }
              } else {
                throw '[sprintf] huh?';
              }
              match[2] = field_list;
            } else {
              arg_names |= 2;
            }
            if (arg_names === 3) {
              throw '[sprintf] mixing positional and named placeholders is not (yet) supported';
            }
            parse_tree.push(match);
          } else {
            throw '[sprintf] huh?';
          }
          _fmt = _fmt.substring(match[0].length);
        }
        return parse_tree;
      };
      return str_format;
    }();
  var vsprintf = function (fmt, argv) {
    argv.unshift(fmt);
    return sprintf.apply(null, argv);
  };
  Jed.parse_plural = function (plural_forms, n) {
    plural_forms = plural_forms.replace(/n/g, n);
    return Jed.parse_expression(plural_forms);
  };
  Jed.sprintf = function (fmt, args) {
    if ({}.toString.call(args) == '[object Array]') {
      return vsprintf(fmt, [].slice.call(args));
    }
    return sprintf.apply(this, [].slice.call(arguments));
  };
  Jed.prototype.sprintf = function () {
    return Jed.sprintf.apply(this, arguments);
  };
  Jed.PF = {};
  Jed.PF.parse = function (p) {
    var plural_str = Jed.PF.extractPluralExpr(p);
    return Jed.PF.parser.parse.call(Jed.PF.parser, plural_str);
  };
  Jed.PF.compile = function (p) {
    function imply(val) {
      return val === true ? 1 : val ? val : 0;
    }
    var ast = Jed.PF.parse(p);
    return function (n) {
      return imply(Jed.PF.interpreter(ast)(n));
    };
  };
  Jed.PF.interpreter = function (ast) {
    return function (n) {
      var res;
      switch (ast.type) {
      case 'GROUP':
        return Jed.PF.interpreter(ast.expr)(n);
      case 'TERNARY':
        if (Jed.PF.interpreter(ast.expr)(n)) {
          return Jed.PF.interpreter(ast.truthy)(n);
        }
        return Jed.PF.interpreter(ast.falsey)(n);
      case 'OR':
        return Jed.PF.interpreter(ast.left)(n) || Jed.PF.interpreter(ast.right)(n);
      case 'AND':
        return Jed.PF.interpreter(ast.left)(n) && Jed.PF.interpreter(ast.right)(n);
      case 'LT':
        return Jed.PF.interpreter(ast.left)(n) < Jed.PF.interpreter(ast.right)(n);
      case 'GT':
        return Jed.PF.interpreter(ast.left)(n) > Jed.PF.interpreter(ast.right)(n);
      case 'LTE':
        return Jed.PF.interpreter(ast.left)(n) <= Jed.PF.interpreter(ast.right)(n);
      case 'GTE':
        return Jed.PF.interpreter(ast.left)(n) >= Jed.PF.interpreter(ast.right)(n);
      case 'EQ':
        return Jed.PF.interpreter(ast.left)(n) == Jed.PF.interpreter(ast.right)(n);
      case 'NEQ':
        return Jed.PF.interpreter(ast.left)(n) != Jed.PF.interpreter(ast.right)(n);
      case 'MOD':
        return Jed.PF.interpreter(ast.left)(n) % Jed.PF.interpreter(ast.right)(n);
      case 'VAR':
        return n;
      case 'NUM':
        return ast.val;
      default:
        throw new Error('Invalid Token found.');
      }
    };
  };
  Jed.PF.extractPluralExpr = function (p) {
    p = p.replace(/^\s\s*/, '').replace(/\s\s*$/, '');
    if (!/;\s*$/.test(p)) {
      p = p.concat(';');
    }
    var nplurals_re = /nplurals\=(\d+);/, plural_re = /plural\=(.*);/, nplurals_matches = p.match(nplurals_re), res = {}, plural_matches;
    if (nplurals_matches.length > 1) {
      res.nplurals = nplurals_matches[1];
    } else {
      throw new Error('nplurals not found in plural_forms string: ' + p);
    }
    p = p.replace(nplurals_re, '');
    plural_matches = p.match(plural_re);
    if (!(plural_matches && plural_matches.length > 1)) {
      throw new Error('`plural` expression not found: ' + p);
    }
    return plural_matches[1];
  };
  Jed.PF.parser = function () {
    var parser = {
        trace: function trace() {
        },
        yy: {},
        symbols_: {
          'error': 2,
          'expressions': 3,
          'e': 4,
          'EOF': 5,
          '?': 6,
          ':': 7,
          '||': 8,
          '&&': 9,
          '<': 10,
          '<=': 11,
          '>': 12,
          '>=': 13,
          '!=': 14,
          '==': 15,
          '%': 16,
          '(': 17,
          ')': 18,
          'n': 19,
          'NUMBER': 20,
          '$accept': 0,
          '$end': 1
        },
        terminals_: {
          2: 'error',
          5: 'EOF',
          6: '?',
          7: ':',
          8: '||',
          9: '&&',
          10: '<',
          11: '<=',
          12: '>',
          13: '>=',
          14: '!=',
          15: '==',
          16: '%',
          17: '(',
          18: ')',
          19: 'n',
          20: 'NUMBER'
        },
        productions_: [
          0,
          [
            3,
            2
          ],
          [
            4,
            5
          ],
          [
            4,
            3
          ],
          [
            4,
            3
          ],
          [
            4,
            3
          ],
          [
            4,
            3
          ],
          [
            4,
            3
          ],
          [
            4,
            3
          ],
          [
            4,
            3
          ],
          [
            4,
            3
          ],
          [
            4,
            3
          ],
          [
            4,
            3
          ],
          [
            4,
            1
          ],
          [
            4,
            1
          ]
        ],
        performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
          var $0 = $$.length - 1;
          switch (yystate) {
          case 1:
            return {
              type: 'GROUP',
              expr: $$[$0 - 1]
            };
            break;
          case 2:
            this.$ = {
              type: 'TERNARY',
              expr: $$[$0 - 4],
              truthy: $$[$0 - 2],
              falsey: $$[$0]
            };
            break;
          case 3:
            this.$ = {
              type: 'OR',
              left: $$[$0 - 2],
              right: $$[$0]
            };
            break;
          case 4:
            this.$ = {
              type: 'AND',
              left: $$[$0 - 2],
              right: $$[$0]
            };
            break;
          case 5:
            this.$ = {
              type: 'LT',
              left: $$[$0 - 2],
              right: $$[$0]
            };
            break;
          case 6:
            this.$ = {
              type: 'LTE',
              left: $$[$0 - 2],
              right: $$[$0]
            };
            break;
          case 7:
            this.$ = {
              type: 'GT',
              left: $$[$0 - 2],
              right: $$[$0]
            };
            break;
          case 8:
            this.$ = {
              type: 'GTE',
              left: $$[$0 - 2],
              right: $$[$0]
            };
            break;
          case 9:
            this.$ = {
              type: 'NEQ',
              left: $$[$0 - 2],
              right: $$[$0]
            };
            break;
          case 10:
            this.$ = {
              type: 'EQ',
              left: $$[$0 - 2],
              right: $$[$0]
            };
            break;
          case 11:
            this.$ = {
              type: 'MOD',
              left: $$[$0 - 2],
              right: $$[$0]
            };
            break;
          case 12:
            this.$ = {
              type: 'GROUP',
              expr: $$[$0 - 1]
            };
            break;
          case 13:
            this.$ = { type: 'VAR' };
            break;
          case 14:
            this.$ = {
              type: 'NUM',
              val: Number(yytext)
            };
            break;
          }
        },
        table: [
          {
            3: 1,
            4: 2,
            17: [
              1,
              3
            ],
            19: [
              1,
              4
            ],
            20: [
              1,
              5
            ]
          },
          { 1: [3] },
          {
            5: [
              1,
              6
            ],
            6: [
              1,
              7
            ],
            8: [
              1,
              8
            ],
            9: [
              1,
              9
            ],
            10: [
              1,
              10
            ],
            11: [
              1,
              11
            ],
            12: [
              1,
              12
            ],
            13: [
              1,
              13
            ],
            14: [
              1,
              14
            ],
            15: [
              1,
              15
            ],
            16: [
              1,
              16
            ]
          },
          {
            4: 17,
            17: [
              1,
              3
            ],
            19: [
              1,
              4
            ],
            20: [
              1,
              5
            ]
          },
          {
            5: [
              2,
              13
            ],
            6: [
              2,
              13
            ],
            7: [
              2,
              13
            ],
            8: [
              2,
              13
            ],
            9: [
              2,
              13
            ],
            10: [
              2,
              13
            ],
            11: [
              2,
              13
            ],
            12: [
              2,
              13
            ],
            13: [
              2,
              13
            ],
            14: [
              2,
              13
            ],
            15: [
              2,
              13
            ],
            16: [
              2,
              13
            ],
            18: [
              2,
              13
            ]
          },
          {
            5: [
              2,
              14
            ],
            6: [
              2,
              14
            ],
            7: [
              2,
              14
            ],
            8: [
              2,
              14
            ],
            9: [
              2,
              14
            ],
            10: [
              2,
              14
            ],
            11: [
              2,
              14
            ],
            12: [
              2,
              14
            ],
            13: [
              2,
              14
            ],
            14: [
              2,
              14
            ],
            15: [
              2,
              14
            ],
            16: [
              2,
              14
            ],
            18: [
              2,
              14
            ]
          },
          {
            1: [
              2,
              1
            ]
          },
          {
            4: 18,
            17: [
              1,
              3
            ],
            19: [
              1,
              4
            ],
            20: [
              1,
              5
            ]
          },
          {
            4: 19,
            17: [
              1,
              3
            ],
            19: [
              1,
              4
            ],
            20: [
              1,
              5
            ]
          },
          {
            4: 20,
            17: [
              1,
              3
            ],
            19: [
              1,
              4
            ],
            20: [
              1,
              5
            ]
          },
          {
            4: 21,
            17: [
              1,
              3
            ],
            19: [
              1,
              4
            ],
            20: [
              1,
              5
            ]
          },
          {
            4: 22,
            17: [
              1,
              3
            ],
            19: [
              1,
              4
            ],
            20: [
              1,
              5
            ]
          },
          {
            4: 23,
            17: [
              1,
              3
            ],
            19: [
              1,
              4
            ],
            20: [
              1,
              5
            ]
          },
          {
            4: 24,
            17: [
              1,
              3
            ],
            19: [
              1,
              4
            ],
            20: [
              1,
              5
            ]
          },
          {
            4: 25,
            17: [
              1,
              3
            ],
            19: [
              1,
              4
            ],
            20: [
              1,
              5
            ]
          },
          {
            4: 26,
            17: [
              1,
              3
            ],
            19: [
              1,
              4
            ],
            20: [
              1,
              5
            ]
          },
          {
            4: 27,
            17: [
              1,
              3
            ],
            19: [
              1,
              4
            ],
            20: [
              1,
              5
            ]
          },
          {
            6: [
              1,
              7
            ],
            8: [
              1,
              8
            ],
            9: [
              1,
              9
            ],
            10: [
              1,
              10
            ],
            11: [
              1,
              11
            ],
            12: [
              1,
              12
            ],
            13: [
              1,
              13
            ],
            14: [
              1,
              14
            ],
            15: [
              1,
              15
            ],
            16: [
              1,
              16
            ],
            18: [
              1,
              28
            ]
          },
          {
            6: [
              1,
              7
            ],
            7: [
              1,
              29
            ],
            8: [
              1,
              8
            ],
            9: [
              1,
              9
            ],
            10: [
              1,
              10
            ],
            11: [
              1,
              11
            ],
            12: [
              1,
              12
            ],
            13: [
              1,
              13
            ],
            14: [
              1,
              14
            ],
            15: [
              1,
              15
            ],
            16: [
              1,
              16
            ]
          },
          {
            5: [
              2,
              3
            ],
            6: [
              2,
              3
            ],
            7: [
              2,
              3
            ],
            8: [
              2,
              3
            ],
            9: [
              1,
              9
            ],
            10: [
              1,
              10
            ],
            11: [
              1,
              11
            ],
            12: [
              1,
              12
            ],
            13: [
              1,
              13
            ],
            14: [
              1,
              14
            ],
            15: [
              1,
              15
            ],
            16: [
              1,
              16
            ],
            18: [
              2,
              3
            ]
          },
          {
            5: [
              2,
              4
            ],
            6: [
              2,
              4
            ],
            7: [
              2,
              4
            ],
            8: [
              2,
              4
            ],
            9: [
              2,
              4
            ],
            10: [
              1,
              10
            ],
            11: [
              1,
              11
            ],
            12: [
              1,
              12
            ],
            13: [
              1,
              13
            ],
            14: [
              1,
              14
            ],
            15: [
              1,
              15
            ],
            16: [
              1,
              16
            ],
            18: [
              2,
              4
            ]
          },
          {
            5: [
              2,
              5
            ],
            6: [
              2,
              5
            ],
            7: [
              2,
              5
            ],
            8: [
              2,
              5
            ],
            9: [
              2,
              5
            ],
            10: [
              2,
              5
            ],
            11: [
              2,
              5
            ],
            12: [
              2,
              5
            ],
            13: [
              2,
              5
            ],
            14: [
              2,
              5
            ],
            15: [
              2,
              5
            ],
            16: [
              1,
              16
            ],
            18: [
              2,
              5
            ]
          },
          {
            5: [
              2,
              6
            ],
            6: [
              2,
              6
            ],
            7: [
              2,
              6
            ],
            8: [
              2,
              6
            ],
            9: [
              2,
              6
            ],
            10: [
              2,
              6
            ],
            11: [
              2,
              6
            ],
            12: [
              2,
              6
            ],
            13: [
              2,
              6
            ],
            14: [
              2,
              6
            ],
            15: [
              2,
              6
            ],
            16: [
              1,
              16
            ],
            18: [
              2,
              6
            ]
          },
          {
            5: [
              2,
              7
            ],
            6: [
              2,
              7
            ],
            7: [
              2,
              7
            ],
            8: [
              2,
              7
            ],
            9: [
              2,
              7
            ],
            10: [
              2,
              7
            ],
            11: [
              2,
              7
            ],
            12: [
              2,
              7
            ],
            13: [
              2,
              7
            ],
            14: [
              2,
              7
            ],
            15: [
              2,
              7
            ],
            16: [
              1,
              16
            ],
            18: [
              2,
              7
            ]
          },
          {
            5: [
              2,
              8
            ],
            6: [
              2,
              8
            ],
            7: [
              2,
              8
            ],
            8: [
              2,
              8
            ],
            9: [
              2,
              8
            ],
            10: [
              2,
              8
            ],
            11: [
              2,
              8
            ],
            12: [
              2,
              8
            ],
            13: [
              2,
              8
            ],
            14: [
              2,
              8
            ],
            15: [
              2,
              8
            ],
            16: [
              1,
              16
            ],
            18: [
              2,
              8
            ]
          },
          {
            5: [
              2,
              9
            ],
            6: [
              2,
              9
            ],
            7: [
              2,
              9
            ],
            8: [
              2,
              9
            ],
            9: [
              2,
              9
            ],
            10: [
              2,
              9
            ],
            11: [
              2,
              9
            ],
            12: [
              2,
              9
            ],
            13: [
              2,
              9
            ],
            14: [
              2,
              9
            ],
            15: [
              2,
              9
            ],
            16: [
              1,
              16
            ],
            18: [
              2,
              9
            ]
          },
          {
            5: [
              2,
              10
            ],
            6: [
              2,
              10
            ],
            7: [
              2,
              10
            ],
            8: [
              2,
              10
            ],
            9: [
              2,
              10
            ],
            10: [
              2,
              10
            ],
            11: [
              2,
              10
            ],
            12: [
              2,
              10
            ],
            13: [
              2,
              10
            ],
            14: [
              2,
              10
            ],
            15: [
              2,
              10
            ],
            16: [
              1,
              16
            ],
            18: [
              2,
              10
            ]
          },
          {
            5: [
              2,
              11
            ],
            6: [
              2,
              11
            ],
            7: [
              2,
              11
            ],
            8: [
              2,
              11
            ],
            9: [
              2,
              11
            ],
            10: [
              2,
              11
            ],
            11: [
              2,
              11
            ],
            12: [
              2,
              11
            ],
            13: [
              2,
              11
            ],
            14: [
              2,
              11
            ],
            15: [
              2,
              11
            ],
            16: [
              2,
              11
            ],
            18: [
              2,
              11
            ]
          },
          {
            5: [
              2,
              12
            ],
            6: [
              2,
              12
            ],
            7: [
              2,
              12
            ],
            8: [
              2,
              12
            ],
            9: [
              2,
              12
            ],
            10: [
              2,
              12
            ],
            11: [
              2,
              12
            ],
            12: [
              2,
              12
            ],
            13: [
              2,
              12
            ],
            14: [
              2,
              12
            ],
            15: [
              2,
              12
            ],
            16: [
              2,
              12
            ],
            18: [
              2,
              12
            ]
          },
          {
            4: 30,
            17: [
              1,
              3
            ],
            19: [
              1,
              4
            ],
            20: [
              1,
              5
            ]
          },
          {
            5: [
              2,
              2
            ],
            6: [
              1,
              7
            ],
            7: [
              2,
              2
            ],
            8: [
              1,
              8
            ],
            9: [
              1,
              9
            ],
            10: [
              1,
              10
            ],
            11: [
              1,
              11
            ],
            12: [
              1,
              12
            ],
            13: [
              1,
              13
            ],
            14: [
              1,
              14
            ],
            15: [
              1,
              15
            ],
            16: [
              1,
              16
            ],
            18: [
              2,
              2
            ]
          }
        ],
        defaultActions: {
          6: [
            2,
            1
          ]
        },
        parseError: function parseError(str, hash) {
          throw new Error(str);
        },
        parse: function parse(input) {
          var self = this, stack = [0], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
          this.lexer.setInput(input);
          this.lexer.yy = this.yy;
          this.yy.lexer = this.lexer;
          if (typeof this.lexer.yylloc == 'undefined')
            this.lexer.yylloc = {};
          var yyloc = this.lexer.yylloc;
          lstack.push(yyloc);
          if (typeof this.yy.parseError === 'function')
            this.parseError = this.yy.parseError;
          function popStack(n) {
            stack.length = stack.length - 2 * n;
            vstack.length = vstack.length - n;
            lstack.length = lstack.length - n;
          }
          function lex() {
            var token;
            token = self.lexer.lex() || 1;
            if (typeof token !== 'number') {
              token = self.symbols_[token] || token;
            }
            return token;
          }
          var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
          while (true) {
            state = stack[stack.length - 1];
            if (this.defaultActions[state]) {
              action = this.defaultActions[state];
            } else {
              if (symbol == null)
                symbol = lex();
              action = table[state] && table[state][symbol];
            }
            _handle_error:
              if (typeof action === 'undefined' || !action.length || !action[0]) {
                if (!recovering) {
                  expected = [];
                  for (p in table[state])
                    if (this.terminals_[p] && p > 2) {
                      expected.push('\'' + this.terminals_[p] + '\'');
                    }
                  var errStr = '';
                  if (this.lexer.showPosition) {
                    errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + this.lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ', got \'' + this.terminals_[symbol] + '\'';
                  } else {
                    errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == 1 ? 'end of input' : '\'' + (this.terminals_[symbol] || symbol) + '\'');
                  }
                  this.parseError(errStr, {
                    text: this.lexer.match,
                    token: this.terminals_[symbol] || symbol,
                    line: this.lexer.yylineno,
                    loc: yyloc,
                    expected: expected
                  });
                }
                if (recovering == 3) {
                  if (symbol == EOF) {
                    throw new Error(errStr || 'Parsing halted.');
                  }
                  yyleng = this.lexer.yyleng;
                  yytext = this.lexer.yytext;
                  yylineno = this.lexer.yylineno;
                  yyloc = this.lexer.yylloc;
                  symbol = lex();
                }
                while (1) {
                  if (TERROR.toString() in table[state]) {
                    break;
                  }
                  if (state == 0) {
                    throw new Error(errStr || 'Parsing halted.');
                  }
                  popStack(1);
                  state = stack[stack.length - 1];
                }
                preErrorSymbol = symbol;
                symbol = TERROR;
                state = stack[stack.length - 1];
                action = table[state] && table[state][TERROR];
                recovering = 3;
              }
            if (action[0] instanceof Array && action.length > 1) {
              throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
            }
            switch (action[0]) {
            case 1:
              stack.push(symbol);
              vstack.push(this.lexer.yytext);
              lstack.push(this.lexer.yylloc);
              stack.push(action[1]);
              symbol = null;
              if (!preErrorSymbol) {
                yyleng = this.lexer.yyleng;
                yytext = this.lexer.yytext;
                yylineno = this.lexer.yylineno;
                yyloc = this.lexer.yylloc;
                if (recovering > 0)
                  recovering--;
              } else {
                symbol = preErrorSymbol;
                preErrorSymbol = null;
              }
              break;
            case 2:
              len = this.productions_[action[1]][1];
              yyval.$ = vstack[vstack.length - len];
              yyval._$ = {
                first_line: lstack[lstack.length - (len || 1)].first_line,
                last_line: lstack[lstack.length - 1].last_line,
                first_column: lstack[lstack.length - (len || 1)].first_column,
                last_column: lstack[lstack.length - 1].last_column
              };
              r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);
              if (typeof r !== 'undefined') {
                return r;
              }
              if (len) {
                stack = stack.slice(0, -1 * len * 2);
                vstack = vstack.slice(0, -1 * len);
                lstack = lstack.slice(0, -1 * len);
              }
              stack.push(this.productions_[action[1]][0]);
              vstack.push(yyval.$);
              lstack.push(yyval._$);
              newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
              stack.push(newState);
              break;
            case 3:
              return true;
            }
          }
          return true;
        }
      };
    var lexer = function () {
        var lexer = {
            EOF: 1,
            parseError: function parseError(str, hash) {
              if (this.yy.parseError) {
                this.yy.parseError(str, hash);
              } else {
                throw new Error(str);
              }
            },
            setInput: function (input) {
              this._input = input;
              this._more = this._less = this.done = false;
              this.yylineno = this.yyleng = 0;
              this.yytext = this.matched = this.match = '';
              this.conditionStack = ['INITIAL'];
              this.yylloc = {
                first_line: 1,
                first_column: 0,
                last_line: 1,
                last_column: 0
              };
              return this;
            },
            input: function () {
              var ch = this._input[0];
              this.yytext += ch;
              this.yyleng++;
              this.match += ch;
              this.matched += ch;
              var lines = ch.match(/\n/);
              if (lines)
                this.yylineno++;
              this._input = this._input.slice(1);
              return ch;
            },
            unput: function (ch) {
              this._input = ch + this._input;
              return this;
            },
            more: function () {
              this._more = true;
              return this;
            },
            pastInput: function () {
              var past = this.matched.substr(0, this.matched.length - this.match.length);
              return (past.length > 20 ? '...' : '') + past.substr(-20).replace(/\n/g, '');
            },
            upcomingInput: function () {
              var next = this.match;
              if (next.length < 20) {
                next += this._input.substr(0, 20 - next.length);
              }
              return (next.substr(0, 20) + (next.length > 20 ? '...' : '')).replace(/\n/g, '');
            },
            showPosition: function () {
              var pre = this.pastInput();
              var c = new Array(pre.length + 1).join('-');
              return pre + this.upcomingInput() + '\n' + c + '^';
            },
            next: function () {
              if (this.done) {
                return this.EOF;
              }
              if (!this._input)
                this.done = true;
              var token, match, col, lines;
              if (!this._more) {
                this.yytext = '';
                this.match = '';
              }
              var rules = this._currentRules();
              for (var i = 0; i < rules.length; i++) {
                match = this._input.match(this.rules[rules[i]]);
                if (match) {
                  lines = match[0].match(/\n.*/g);
                  if (lines)
                    this.yylineno += lines.length;
                  this.yylloc = {
                    first_line: this.yylloc.last_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.last_column,
                    last_column: lines ? lines[lines.length - 1].length - 1 : this.yylloc.last_column + match[0].length
                  };
                  this.yytext += match[0];
                  this.match += match[0];
                  this.matches = match;
                  this.yyleng = this.yytext.length;
                  this._more = false;
                  this._input = this._input.slice(match[0].length);
                  this.matched += match[0];
                  token = this.performAction.call(this, this.yy, this, rules[i], this.conditionStack[this.conditionStack.length - 1]);
                  if (token)
                    return token;
                  else
                    return;
                }
              }
              if (this._input === '') {
                return this.EOF;
              } else {
                this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
                  text: '',
                  token: null,
                  line: this.yylineno
                });
              }
            },
            lex: function lex() {
              var r = this.next();
              if (typeof r !== 'undefined') {
                return r;
              } else {
                return this.lex();
              }
            },
            begin: function begin(condition) {
              this.conditionStack.push(condition);
            },
            popState: function popState() {
              return this.conditionStack.pop();
            },
            _currentRules: function _currentRules() {
              return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
            },
            topState: function () {
              return this.conditionStack[this.conditionStack.length - 2];
            },
            pushState: function begin(condition) {
              this.begin(condition);
            }
          };
        lexer.performAction = function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
          var YYSTATE = YY_START;
          switch ($avoiding_name_collisions) {
          case 0:
            break;
          case 1:
            return 20;
            break;
          case 2:
            return 19;
            break;
          case 3:
            return 8;
            break;
          case 4:
            return 9;
            break;
          case 5:
            return 6;
            break;
          case 6:
            return 7;
            break;
          case 7:
            return 11;
            break;
          case 8:
            return 13;
            break;
          case 9:
            return 10;
            break;
          case 10:
            return 12;
            break;
          case 11:
            return 14;
            break;
          case 12:
            return 15;
            break;
          case 13:
            return 16;
            break;
          case 14:
            return 17;
            break;
          case 15:
            return 18;
            break;
          case 16:
            return 5;
            break;
          case 17:
            return 'INVALID';
            break;
          }
        };
        lexer.rules = [
          /^\s+/,
          /^[0-9]+(\.[0-9]+)?\b/,
          /^n\b/,
          /^\|\|/,
          /^&&/,
          /^\?/,
          /^:/,
          /^<=/,
          /^>=/,
          /^</,
          /^>/,
          /^!=/,
          /^==/,
          /^%/,
          /^\(/,
          /^\)/,
          /^$/,
          /^./
        ];
        lexer.conditions = {
          'INITIAL': {
            'rules': [
              0,
              1,
              2,
              3,
              4,
              5,
              6,
              7,
              8,
              9,
              10,
              11,
              12,
              13,
              14,
              15,
              16,
              17
            ],
            'inclusive': true
          }
        };
        return lexer;
      }();
    parser.lexer = lexer;
    return parser;
  }();
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = Jed;
    }
    exports.Jed = Jed;
  } else {
    if (typeof define === 'function' && define.amd) {
      define('jed', function () {
        return Jed;
      });
    }
    root['Jed'] = Jed;
  }
}(this));
(function () {
  var ACE_NAMESPACE = 'ace';
  var global = function () {
      return this;
    }();
  if (!ACE_NAMESPACE && typeof requirejs !== 'undefined')
    return;
  var _define = function (module, deps, payload) {
    if (typeof module !== 'string') {
      if (_define.original)
        _define.original.apply(window, arguments);
      else {
        console.error('dropping module because define wasn\'t a string.');
        console.trace();
      }
      return;
    }
    if (arguments.length == 2)
      payload = deps;
    if (!_define.modules) {
      _define.modules = {};
      _define.payloads = {};
    }
    _define.payloads[module] = payload;
    _define.modules[module] = null;
  };
  var _require = function (parentId, module, callback) {
    if (Object.prototype.toString.call(module) === '[object Array]') {
      var params = [];
      for (var i = 0, l = module.length; i < l; ++i) {
        var dep = lookup(parentId, module[i]);
        if (!dep && _require.original)
          return _require.original.apply(window, arguments);
        params.push(dep);
      }
      if (callback) {
        callback.apply(null, params);
      }
    } else if (typeof module === 'string') {
      var payload = lookup(parentId, module);
      if (!payload && _require.original)
        return _require.original.apply(window, arguments);
      if (callback) {
        callback();
      }
      return payload;
    } else {
      if (_require.original)
        return _require.original.apply(window, arguments);
    }
  };
  var normalizeModule = function (parentId, moduleName) {
    if (moduleName.indexOf('!') !== -1) {
      var chunks = moduleName.split('!');
      return normalizeModule(parentId, chunks[0]) + '!' + normalizeModule(parentId, chunks[1]);
    }
    if (moduleName.charAt(0) == '.') {
      var base = parentId.split('/').slice(0, -1).join('/');
      moduleName = base + '/' + moduleName;
      while (moduleName.indexOf('.') !== -1 && previous != moduleName) {
        var previous = moduleName;
        moduleName = moduleName.replace(/\/\.\//, '/').replace(/[^\/]+\/\.\.\//, '');
      }
    }
    return moduleName;
  };
  var lookup = function (parentId, moduleName) {
    moduleName = normalizeModule(parentId, moduleName);
    var module = _define.modules[moduleName];
    if (!module) {
      module = _define.payloads[moduleName];
      if (typeof module === 'function') {
        var exports = {};
        var mod = {
            id: moduleName,
            uri: '',
            exports: exports,
            packaged: true
          };
        var req = function (module, callback) {
          return _require(moduleName, module, callback);
        };
        var returnValue = module(req, exports, mod);
        exports = returnValue || mod.exports;
        _define.modules[moduleName] = exports;
        delete _define.payloads[moduleName];
      }
      module = _define.modules[moduleName] = exports || module;
    }
    return module;
  };
  function exportAce(ns) {
    var require = function (module, callback) {
      return _require('', module, callback);
    };
    var root = global;
    if (ns) {
      if (!global[ns])
        global[ns] = {};
      root = global[ns];
    }
    if (!root.define || !root.define.packaged) {
      _define.original = root.define;
      root.define = _define;
      root.define.packaged = true;
    }
    if (!root.require || !root.require.packaged) {
      _require.original = root.require;
      root.require = require;
      root.require.packaged = true;
    }
  }
  exportAce(ACE_NAMESPACE);
}());
ace.define('ace/ace', [
  'require',
  'exports',
  'module',
  'ace/lib/fixoldbrowsers',
  'ace/lib/dom',
  'ace/lib/event',
  'ace/editor',
  'ace/edit_session',
  'ace/undomanager',
  'ace/virtual_renderer',
  'ace/multi_select',
  'ace/worker/worker_client',
  'ace/keyboard/hash_handler',
  'ace/placeholder',
  'ace/mode/folding/fold_mode',
  'ace/theme/textmate',
  'ace/ext/error_marker',
  'ace/config'
], function (require, exports, module) {
  require('./lib/fixoldbrowsers');
  var dom = require('./lib/dom');
  var event = require('./lib/event');
  var Editor = require('./editor').Editor;
  var EditSession = require('./edit_session').EditSession;
  var UndoManager = require('./undomanager').UndoManager;
  var Renderer = require('./virtual_renderer').VirtualRenderer;
  var MultiSelect = require('./multi_select').MultiSelect;
  require('./worker/worker_client');
  require('./keyboard/hash_handler');
  require('./placeholder');
  require('./mode/folding/fold_mode');
  require('./theme/textmate');
  require('./ext/error_marker');
  exports.config = require('./config');
  exports.require = require;
  exports.edit = function (el) {
    if (typeof el == 'string') {
      var _id = el;
      var el = document.getElementById(_id);
      if (!el)
        throw new Error('ace.edit can\'t find div #' + _id);
    }
    if (el.env && el.env.editor instanceof Editor)
      return el.env.editor;
    var doc = exports.createEditSession(dom.getInnerText(el));
    el.innerHTML = '';
    var editor = new Editor(new Renderer(el));
    new MultiSelect(editor);
    editor.setSession(doc);
    var env = {
        document: doc,
        editor: editor,
        onResize: editor.resize.bind(editor, null)
      };
    event.addListener(window, 'resize', env.onResize);
    editor.on('destroy', function () {
      event.removeListener(window, 'resize', env.onResize);
    });
    el.env = editor.env = env;
    return editor;
  };
  exports.createEditSession = function (text, mode) {
    var doc = new EditSession(text, mode);
    doc.setUndoManager(new UndoManager());
    return doc;
  };
  exports.EditSession = EditSession;
  exports.UndoManager = UndoManager;
});
ace.define('ace/mode/behaviour', [
  'require',
  'exports',
  'module'
], function (require, exports, module) {
  var Behaviour = function () {
    this.$behaviours = {};
  };
  (function () {
    this.add = function (name, action, callback) {
      switch (undefined) {
      case this.$behaviours:
        this.$behaviours = {};
      case this.$behaviours[name]:
        this.$behaviours[name] = {};
      }
      this.$behaviours[name][action] = callback;
    };
    this.addBehaviours = function (behaviours) {
      for (var key in behaviours) {
        for (var action in behaviours[key]) {
          this.add(key, action, behaviours[key][action]);
        }
      }
    };
    this.remove = function (name) {
      if (this.$behaviours && this.$behaviours[name]) {
        delete this.$behaviours[name];
      }
    };
    this.inherit = function (mode, filter) {
      if (typeof mode === 'function') {
        var behaviours = new mode().getBehaviours(filter);
      } else {
        var behaviours = mode.getBehaviours(filter);
      }
      this.addBehaviours(behaviours);
    };
    this.getBehaviours = function (filter) {
      if (!filter) {
        return this.$behaviours;
      } else {
        var ret = {};
        for (var i = 0; i < filter.length; i++) {
          if (this.$behaviours[filter[i]]) {
            ret[filter[i]] = this.$behaviours[filter[i]];
          }
        }
        return ret;
      }
    };
  }.call(Behaviour.prototype));
  exports.Behaviour = Behaviour;
});
ace.define('ace/unicode', [
  'require',
  'exports',
  'module'
], function (require, exports, module) {
  exports.packages = {};
  addUnicodePackage({
    L: '0041-005A0061-007A00AA00B500BA00C0-00D600D8-00F600F8-02C102C6-02D102E0-02E402EC02EE0370-037403760377037A-037D03860388-038A038C038E-03A103A3-03F503F7-0481048A-05250531-055605590561-058705D0-05EA05F0-05F20621-064A066E066F0671-06D306D506E506E606EE06EF06FA-06FC06FF07100712-072F074D-07A507B107CA-07EA07F407F507FA0800-0815081A082408280904-0939093D09500958-0961097109720979-097F0985-098C098F09900993-09A809AA-09B009B209B6-09B909BD09CE09DC09DD09DF-09E109F009F10A05-0A0A0A0F0A100A13-0A280A2A-0A300A320A330A350A360A380A390A59-0A5C0A5E0A72-0A740A85-0A8D0A8F-0A910A93-0AA80AAA-0AB00AB20AB30AB5-0AB90ABD0AD00AE00AE10B05-0B0C0B0F0B100B13-0B280B2A-0B300B320B330B35-0B390B3D0B5C0B5D0B5F-0B610B710B830B85-0B8A0B8E-0B900B92-0B950B990B9A0B9C0B9E0B9F0BA30BA40BA8-0BAA0BAE-0BB90BD00C05-0C0C0C0E-0C100C12-0C280C2A-0C330C35-0C390C3D0C580C590C600C610C85-0C8C0C8E-0C900C92-0CA80CAA-0CB30CB5-0CB90CBD0CDE0CE00CE10D05-0D0C0D0E-0D100D12-0D280D2A-0D390D3D0D600D610D7A-0D7F0D85-0D960D9A-0DB10DB3-0DBB0DBD0DC0-0DC60E01-0E300E320E330E40-0E460E810E820E840E870E880E8A0E8D0E94-0E970E99-0E9F0EA1-0EA30EA50EA70EAA0EAB0EAD-0EB00EB20EB30EBD0EC0-0EC40EC60EDC0EDD0F000F40-0F470F49-0F6C0F88-0F8B1000-102A103F1050-1055105A-105D106110651066106E-10701075-1081108E10A0-10C510D0-10FA10FC1100-1248124A-124D1250-12561258125A-125D1260-1288128A-128D1290-12B012B2-12B512B8-12BE12C012C2-12C512C8-12D612D8-13101312-13151318-135A1380-138F13A0-13F41401-166C166F-167F1681-169A16A0-16EA1700-170C170E-17111720-17311740-17511760-176C176E-17701780-17B317D717DC1820-18771880-18A818AA18B0-18F51900-191C1950-196D1970-19741980-19AB19C1-19C71A00-1A161A20-1A541AA71B05-1B331B45-1B4B1B83-1BA01BAE1BAF1C00-1C231C4D-1C4F1C5A-1C7D1CE9-1CEC1CEE-1CF11D00-1DBF1E00-1F151F18-1F1D1F20-1F451F48-1F4D1F50-1F571F591F5B1F5D1F5F-1F7D1F80-1FB41FB6-1FBC1FBE1FC2-1FC41FC6-1FCC1FD0-1FD31FD6-1FDB1FE0-1FEC1FF2-1FF41FF6-1FFC2071207F2090-209421022107210A-211321152119-211D212421262128212A-212D212F-2139213C-213F2145-2149214E218321842C00-2C2E2C30-2C5E2C60-2CE42CEB-2CEE2D00-2D252D30-2D652D6F2D80-2D962DA0-2DA62DA8-2DAE2DB0-2DB62DB8-2DBE2DC0-2DC62DC8-2DCE2DD0-2DD62DD8-2DDE2E2F300530063031-3035303B303C3041-3096309D-309F30A1-30FA30FC-30FF3105-312D3131-318E31A0-31B731F0-31FF3400-4DB54E00-9FCBA000-A48CA4D0-A4FDA500-A60CA610-A61FA62AA62BA640-A65FA662-A66EA67F-A697A6A0-A6E5A717-A71FA722-A788A78BA78CA7FB-A801A803-A805A807-A80AA80C-A822A840-A873A882-A8B3A8F2-A8F7A8FBA90A-A925A930-A946A960-A97CA984-A9B2A9CFAA00-AA28AA40-AA42AA44-AA4BAA60-AA76AA7AAA80-AAAFAAB1AAB5AAB6AAB9-AABDAAC0AAC2AADB-AADDABC0-ABE2AC00-D7A3D7B0-D7C6D7CB-D7FBF900-FA2DFA30-FA6DFA70-FAD9FB00-FB06FB13-FB17FB1DFB1F-FB28FB2A-FB36FB38-FB3CFB3EFB40FB41FB43FB44FB46-FBB1FBD3-FD3DFD50-FD8FFD92-FDC7FDF0-FDFBFE70-FE74FE76-FEFCFF21-FF3AFF41-FF5AFF66-FFBEFFC2-FFC7FFCA-FFCFFFD2-FFD7FFDA-FFDC',
    Ll: '0061-007A00AA00B500BA00DF-00F600F8-00FF01010103010501070109010B010D010F01110113011501170119011B011D011F01210123012501270129012B012D012F01310133013501370138013A013C013E014001420144014601480149014B014D014F01510153015501570159015B015D015F01610163016501670169016B016D016F0171017301750177017A017C017E-0180018301850188018C018D019201950199-019B019E01A101A301A501A801AA01AB01AD01B001B401B601B901BA01BD-01BF01C601C901CC01CE01D001D201D401D601D801DA01DC01DD01DF01E101E301E501E701E901EB01ED01EF01F001F301F501F901FB01FD01FF02010203020502070209020B020D020F02110213021502170219021B021D021F02210223022502270229022B022D022F02310233-0239023C023F0240024202470249024B024D024F-02930295-02AF037103730377037B-037D039003AC-03CE03D003D103D5-03D703D903DB03DD03DF03E103E303E503E703E903EB03ED03EF-03F303F503F803FB03FC0430-045F04610463046504670469046B046D046F04710473047504770479047B047D047F0481048B048D048F04910493049504970499049B049D049F04A104A304A504A704A904AB04AD04AF04B104B304B504B704B904BB04BD04BF04C204C404C604C804CA04CC04CE04CF04D104D304D504D704D904DB04DD04DF04E104E304E504E704E904EB04ED04EF04F104F304F504F704F904FB04FD04FF05010503050505070509050B050D050F05110513051505170519051B051D051F0521052305250561-05871D00-1D2B1D62-1D771D79-1D9A1E011E031E051E071E091E0B1E0D1E0F1E111E131E151E171E191E1B1E1D1E1F1E211E231E251E271E291E2B1E2D1E2F1E311E331E351E371E391E3B1E3D1E3F1E411E431E451E471E491E4B1E4D1E4F1E511E531E551E571E591E5B1E5D1E5F1E611E631E651E671E691E6B1E6D1E6F1E711E731E751E771E791E7B1E7D1E7F1E811E831E851E871E891E8B1E8D1E8F1E911E931E95-1E9D1E9F1EA11EA31EA51EA71EA91EAB1EAD1EAF1EB11EB31EB51EB71EB91EBB1EBD1EBF1EC11EC31EC51EC71EC91ECB1ECD1ECF1ED11ED31ED51ED71ED91EDB1EDD1EDF1EE11EE31EE51EE71EE91EEB1EED1EEF1EF11EF31EF51EF71EF91EFB1EFD1EFF-1F071F10-1F151F20-1F271F30-1F371F40-1F451F50-1F571F60-1F671F70-1F7D1F80-1F871F90-1F971FA0-1FA71FB0-1FB41FB61FB71FBE1FC2-1FC41FC61FC71FD0-1FD31FD61FD71FE0-1FE71FF2-1FF41FF61FF7210A210E210F2113212F21342139213C213D2146-2149214E21842C30-2C5E2C612C652C662C682C6A2C6C2C712C732C742C76-2C7C2C812C832C852C872C892C8B2C8D2C8F2C912C932C952C972C992C9B2C9D2C9F2CA12CA32CA52CA72CA92CAB2CAD2CAF2CB12CB32CB52CB72CB92CBB2CBD2CBF2CC12CC32CC52CC72CC92CCB2CCD2CCF2CD12CD32CD52CD72CD92CDB2CDD2CDF2CE12CE32CE42CEC2CEE2D00-2D25A641A643A645A647A649A64BA64DA64FA651A653A655A657A659A65BA65DA65FA663A665A667A669A66BA66DA681A683A685A687A689A68BA68DA68FA691A693A695A697A723A725A727A729A72BA72DA72F-A731A733A735A737A739A73BA73DA73FA741A743A745A747A749A74BA74DA74FA751A753A755A757A759A75BA75DA75FA761A763A765A767A769A76BA76DA76FA771-A778A77AA77CA77FA781A783A785A787A78CFB00-FB06FB13-FB17FF41-FF5A',
    Lu: '0041-005A00C0-00D600D8-00DE01000102010401060108010A010C010E01100112011401160118011A011C011E01200122012401260128012A012C012E01300132013401360139013B013D013F0141014301450147014A014C014E01500152015401560158015A015C015E01600162016401660168016A016C016E017001720174017601780179017B017D018101820184018601870189-018B018E-0191019301940196-0198019C019D019F01A001A201A401A601A701A901AC01AE01AF01B1-01B301B501B701B801BC01C401C701CA01CD01CF01D101D301D501D701D901DB01DE01E001E201E401E601E801EA01EC01EE01F101F401F6-01F801FA01FC01FE02000202020402060208020A020C020E02100212021402160218021A021C021E02200222022402260228022A022C022E02300232023A023B023D023E02410243-02460248024A024C024E03700372037603860388-038A038C038E038F0391-03A103A3-03AB03CF03D2-03D403D803DA03DC03DE03E003E203E403E603E803EA03EC03EE03F403F703F903FA03FD-042F04600462046404660468046A046C046E04700472047404760478047A047C047E0480048A048C048E04900492049404960498049A049C049E04A004A204A404A604A804AA04AC04AE04B004B204B404B604B804BA04BC04BE04C004C104C304C504C704C904CB04CD04D004D204D404D604D804DA04DC04DE04E004E204E404E604E804EA04EC04EE04F004F204F404F604F804FA04FC04FE05000502050405060508050A050C050E05100512051405160518051A051C051E0520052205240531-055610A0-10C51E001E021E041E061E081E0A1E0C1E0E1E101E121E141E161E181E1A1E1C1E1E1E201E221E241E261E281E2A1E2C1E2E1E301E321E341E361E381E3A1E3C1E3E1E401E421E441E461E481E4A1E4C1E4E1E501E521E541E561E581E5A1E5C1E5E1E601E621E641E661E681E6A1E6C1E6E1E701E721E741E761E781E7A1E7C1E7E1E801E821E841E861E881E8A1E8C1E8E1E901E921E941E9E1EA01EA21EA41EA61EA81EAA1EAC1EAE1EB01EB21EB41EB61EB81EBA1EBC1EBE1EC01EC21EC41EC61EC81ECA1ECC1ECE1ED01ED21ED41ED61ED81EDA1EDC1EDE1EE01EE21EE41EE61EE81EEA1EEC1EEE1EF01EF21EF41EF61EF81EFA1EFC1EFE1F08-1F0F1F18-1F1D1F28-1F2F1F38-1F3F1F48-1F4D1F591F5B1F5D1F5F1F68-1F6F1FB8-1FBB1FC8-1FCB1FD8-1FDB1FE8-1FEC1FF8-1FFB21022107210B-210D2110-211221152119-211D212421262128212A-212D2130-2133213E213F214521832C00-2C2E2C602C62-2C642C672C692C6B2C6D-2C702C722C752C7E-2C802C822C842C862C882C8A2C8C2C8E2C902C922C942C962C982C9A2C9C2C9E2CA02CA22CA42CA62CA82CAA2CAC2CAE2CB02CB22CB42CB62CB82CBA2CBC2CBE2CC02CC22CC42CC62CC82CCA2CCC2CCE2CD02CD22CD42CD62CD82CDA2CDC2CDE2CE02CE22CEB2CEDA640A642A644A646A648A64AA64CA64EA650A652A654A656A658A65AA65CA65EA662A664A666A668A66AA66CA680A682A684A686A688A68AA68CA68EA690A692A694A696A722A724A726A728A72AA72CA72EA732A734A736A738A73AA73CA73EA740A742A744A746A748A74AA74CA74EA750A752A754A756A758A75AA75CA75EA760A762A764A766A768A76AA76CA76EA779A77BA77DA77EA780A782A784A786A78BFF21-FF3A',
    Lt: '01C501C801CB01F21F88-1F8F1F98-1F9F1FA8-1FAF1FBC1FCC1FFC',
    Lm: '02B0-02C102C6-02D102E0-02E402EC02EE0374037A0559064006E506E607F407F507FA081A0824082809710E460EC610FC17D718431AA71C78-1C7D1D2C-1D611D781D9B-1DBF2071207F2090-20942C7D2D6F2E2F30053031-3035303B309D309E30FC-30FEA015A4F8-A4FDA60CA67FA717-A71FA770A788A9CFAA70AADDFF70FF9EFF9F',
    Lo: '01BB01C0-01C3029405D0-05EA05F0-05F20621-063F0641-064A066E066F0671-06D306D506EE06EF06FA-06FC06FF07100712-072F074D-07A507B107CA-07EA0800-08150904-0939093D09500958-096109720979-097F0985-098C098F09900993-09A809AA-09B009B209B6-09B909BD09CE09DC09DD09DF-09E109F009F10A05-0A0A0A0F0A100A13-0A280A2A-0A300A320A330A350A360A380A390A59-0A5C0A5E0A72-0A740A85-0A8D0A8F-0A910A93-0AA80AAA-0AB00AB20AB30AB5-0AB90ABD0AD00AE00AE10B05-0B0C0B0F0B100B13-0B280B2A-0B300B320B330B35-0B390B3D0B5C0B5D0B5F-0B610B710B830B85-0B8A0B8E-0B900B92-0B950B990B9A0B9C0B9E0B9F0BA30BA40BA8-0BAA0BAE-0BB90BD00C05-0C0C0C0E-0C100C12-0C280C2A-0C330C35-0C390C3D0C580C590C600C610C85-0C8C0C8E-0C900C92-0CA80CAA-0CB30CB5-0CB90CBD0CDE0CE00CE10D05-0D0C0D0E-0D100D12-0D280D2A-0D390D3D0D600D610D7A-0D7F0D85-0D960D9A-0DB10DB3-0DBB0DBD0DC0-0DC60E01-0E300E320E330E40-0E450E810E820E840E870E880E8A0E8D0E94-0E970E99-0E9F0EA1-0EA30EA50EA70EAA0EAB0EAD-0EB00EB20EB30EBD0EC0-0EC40EDC0EDD0F000F40-0F470F49-0F6C0F88-0F8B1000-102A103F1050-1055105A-105D106110651066106E-10701075-1081108E10D0-10FA1100-1248124A-124D1250-12561258125A-125D1260-1288128A-128D1290-12B012B2-12B512B8-12BE12C012C2-12C512C8-12D612D8-13101312-13151318-135A1380-138F13A0-13F41401-166C166F-167F1681-169A16A0-16EA1700-170C170E-17111720-17311740-17511760-176C176E-17701780-17B317DC1820-18421844-18771880-18A818AA18B0-18F51900-191C1950-196D1970-19741980-19AB19C1-19C71A00-1A161A20-1A541B05-1B331B45-1B4B1B83-1BA01BAE1BAF1C00-1C231C4D-1C4F1C5A-1C771CE9-1CEC1CEE-1CF12135-21382D30-2D652D80-2D962DA0-2DA62DA8-2DAE2DB0-2DB62DB8-2DBE2DC0-2DC62DC8-2DCE2DD0-2DD62DD8-2DDE3006303C3041-3096309F30A1-30FA30FF3105-312D3131-318E31A0-31B731F0-31FF3400-4DB54E00-9FCBA000-A014A016-A48CA4D0-A4F7A500-A60BA610-A61FA62AA62BA66EA6A0-A6E5A7FB-A801A803-A805A807-A80AA80C-A822A840-A873A882-A8B3A8F2-A8F7A8FBA90A-A925A930-A946A960-A97CA984-A9B2AA00-AA28AA40-AA42AA44-AA4BAA60-AA6FAA71-AA76AA7AAA80-AAAFAAB1AAB5AAB6AAB9-AABDAAC0AAC2AADBAADCABC0-ABE2AC00-D7A3D7B0-D7C6D7CB-D7FBF900-FA2DFA30-FA6DFA70-FAD9FB1DFB1F-FB28FB2A-FB36FB38-FB3CFB3EFB40FB41FB43FB44FB46-FBB1FBD3-FD3DFD50-FD8FFD92-FDC7FDF0-FDFBFE70-FE74FE76-FEFCFF66-FF6FFF71-FF9DFFA0-FFBEFFC2-FFC7FFCA-FFCFFFD2-FFD7FFDA-FFDC',
    M: '0300-036F0483-04890591-05BD05BF05C105C205C405C505C70610-061A064B-065E067006D6-06DC06DE-06E406E706E806EA-06ED07110730-074A07A6-07B007EB-07F30816-0819081B-08230825-08270829-082D0900-0903093C093E-094E0951-0955096209630981-098309BC09BE-09C409C709C809CB-09CD09D709E209E30A01-0A030A3C0A3E-0A420A470A480A4B-0A4D0A510A700A710A750A81-0A830ABC0ABE-0AC50AC7-0AC90ACB-0ACD0AE20AE30B01-0B030B3C0B3E-0B440B470B480B4B-0B4D0B560B570B620B630B820BBE-0BC20BC6-0BC80BCA-0BCD0BD70C01-0C030C3E-0C440C46-0C480C4A-0C4D0C550C560C620C630C820C830CBC0CBE-0CC40CC6-0CC80CCA-0CCD0CD50CD60CE20CE30D020D030D3E-0D440D46-0D480D4A-0D4D0D570D620D630D820D830DCA0DCF-0DD40DD60DD8-0DDF0DF20DF30E310E34-0E3A0E47-0E4E0EB10EB4-0EB90EBB0EBC0EC8-0ECD0F180F190F350F370F390F3E0F3F0F71-0F840F860F870F90-0F970F99-0FBC0FC6102B-103E1056-1059105E-10601062-10641067-106D1071-10741082-108D108F109A-109D135F1712-17141732-1734175217531772177317B6-17D317DD180B-180D18A91920-192B1930-193B19B0-19C019C819C91A17-1A1B1A55-1A5E1A60-1A7C1A7F1B00-1B041B34-1B441B6B-1B731B80-1B821BA1-1BAA1C24-1C371CD0-1CD21CD4-1CE81CED1CF21DC0-1DE61DFD-1DFF20D0-20F02CEF-2CF12DE0-2DFF302A-302F3099309AA66F-A672A67CA67DA6F0A6F1A802A806A80BA823-A827A880A881A8B4-A8C4A8E0-A8F1A926-A92DA947-A953A980-A983A9B3-A9C0AA29-AA36AA43AA4CAA4DAA7BAAB0AAB2-AAB4AAB7AAB8AABEAABFAAC1ABE3-ABEAABECABEDFB1EFE00-FE0FFE20-FE26',
    Mn: '0300-036F0483-04870591-05BD05BF05C105C205C405C505C70610-061A064B-065E067006D6-06DC06DF-06E406E706E806EA-06ED07110730-074A07A6-07B007EB-07F30816-0819081B-08230825-08270829-082D0900-0902093C0941-0948094D0951-095509620963098109BC09C1-09C409CD09E209E30A010A020A3C0A410A420A470A480A4B-0A4D0A510A700A710A750A810A820ABC0AC1-0AC50AC70AC80ACD0AE20AE30B010B3C0B3F0B41-0B440B4D0B560B620B630B820BC00BCD0C3E-0C400C46-0C480C4A-0C4D0C550C560C620C630CBC0CBF0CC60CCC0CCD0CE20CE30D41-0D440D4D0D620D630DCA0DD2-0DD40DD60E310E34-0E3A0E47-0E4E0EB10EB4-0EB90EBB0EBC0EC8-0ECD0F180F190F350F370F390F71-0F7E0F80-0F840F860F870F90-0F970F99-0FBC0FC6102D-10301032-10371039103A103D103E10581059105E-10601071-1074108210851086108D109D135F1712-17141732-1734175217531772177317B7-17BD17C617C9-17D317DD180B-180D18A91920-19221927192819321939-193B1A171A181A561A58-1A5E1A601A621A65-1A6C1A73-1A7C1A7F1B00-1B031B341B36-1B3A1B3C1B421B6B-1B731B801B811BA2-1BA51BA81BA91C2C-1C331C361C371CD0-1CD21CD4-1CE01CE2-1CE81CED1DC0-1DE61DFD-1DFF20D0-20DC20E120E5-20F02CEF-2CF12DE0-2DFF302A-302F3099309AA66FA67CA67DA6F0A6F1A802A806A80BA825A826A8C4A8E0-A8F1A926-A92DA947-A951A980-A982A9B3A9B6-A9B9A9BCAA29-AA2EAA31AA32AA35AA36AA43AA4CAAB0AAB2-AAB4AAB7AAB8AABEAABFAAC1ABE5ABE8ABEDFB1EFE00-FE0FFE20-FE26',
    Mc: '0903093E-09400949-094C094E0982098309BE-09C009C709C809CB09CC09D70A030A3E-0A400A830ABE-0AC00AC90ACB0ACC0B020B030B3E0B400B470B480B4B0B4C0B570BBE0BBF0BC10BC20BC6-0BC80BCA-0BCC0BD70C01-0C030C41-0C440C820C830CBE0CC0-0CC40CC70CC80CCA0CCB0CD50CD60D020D030D3E-0D400D46-0D480D4A-0D4C0D570D820D830DCF-0DD10DD8-0DDF0DF20DF30F3E0F3F0F7F102B102C10311038103B103C105610571062-10641067-106D108310841087-108C108F109A-109C17B617BE-17C517C717C81923-19261929-192B193019311933-193819B0-19C019C819C91A19-1A1B1A551A571A611A631A641A6D-1A721B041B351B3B1B3D-1B411B431B441B821BA11BA61BA71BAA1C24-1C2B1C341C351CE11CF2A823A824A827A880A881A8B4-A8C3A952A953A983A9B4A9B5A9BAA9BBA9BD-A9C0AA2FAA30AA33AA34AA4DAA7BABE3ABE4ABE6ABE7ABE9ABEAABEC',
    Me: '0488048906DE20DD-20E020E2-20E4A670-A672',
    N: '0030-003900B200B300B900BC-00BE0660-066906F0-06F907C0-07C90966-096F09E6-09EF09F4-09F90A66-0A6F0AE6-0AEF0B66-0B6F0BE6-0BF20C66-0C6F0C78-0C7E0CE6-0CEF0D66-0D750E50-0E590ED0-0ED90F20-0F331040-10491090-10991369-137C16EE-16F017E0-17E917F0-17F91810-18191946-194F19D0-19DA1A80-1A891A90-1A991B50-1B591BB0-1BB91C40-1C491C50-1C5920702074-20792080-20892150-21822185-21892460-249B24EA-24FF2776-27932CFD30073021-30293038-303A3192-31953220-32293251-325F3280-328932B1-32BFA620-A629A6E6-A6EFA830-A835A8D0-A8D9A900-A909A9D0-A9D9AA50-AA59ABF0-ABF9FF10-FF19',
    Nd: '0030-00390660-066906F0-06F907C0-07C90966-096F09E6-09EF0A66-0A6F0AE6-0AEF0B66-0B6F0BE6-0BEF0C66-0C6F0CE6-0CEF0D66-0D6F0E50-0E590ED0-0ED90F20-0F291040-10491090-109917E0-17E91810-18191946-194F19D0-19DA1A80-1A891A90-1A991B50-1B591BB0-1BB91C40-1C491C50-1C59A620-A629A8D0-A8D9A900-A909A9D0-A9D9AA50-AA59ABF0-ABF9FF10-FF19',
    Nl: '16EE-16F02160-21822185-218830073021-30293038-303AA6E6-A6EF',
    No: '00B200B300B900BC-00BE09F4-09F90BF0-0BF20C78-0C7E0D70-0D750F2A-0F331369-137C17F0-17F920702074-20792080-20892150-215F21892460-249B24EA-24FF2776-27932CFD3192-31953220-32293251-325F3280-328932B1-32BFA830-A835',
    P: '0021-00230025-002A002C-002F003A003B003F0040005B-005D005F007B007D00A100AB00B700BB00BF037E0387055A-055F0589058A05BE05C005C305C605F305F40609060A060C060D061B061E061F066A-066D06D40700-070D07F7-07F90830-083E0964096509700DF40E4F0E5A0E5B0F04-0F120F3A-0F3D0F850FD0-0FD4104A-104F10FB1361-13681400166D166E169B169C16EB-16ED1735173617D4-17D617D8-17DA1800-180A1944194519DE19DF1A1E1A1F1AA0-1AA61AA8-1AAD1B5A-1B601C3B-1C3F1C7E1C7F1CD32010-20272030-20432045-20512053-205E207D207E208D208E2329232A2768-277527C527C627E6-27EF2983-299829D8-29DB29FC29FD2CF9-2CFC2CFE2CFF2E00-2E2E2E302E313001-30033008-30113014-301F3030303D30A030FBA4FEA4FFA60D-A60FA673A67EA6F2-A6F7A874-A877A8CEA8CFA8F8-A8FAA92EA92FA95FA9C1-A9CDA9DEA9DFAA5C-AA5FAADEAADFABEBFD3EFD3FFE10-FE19FE30-FE52FE54-FE61FE63FE68FE6AFE6BFF01-FF03FF05-FF0AFF0C-FF0FFF1AFF1BFF1FFF20FF3B-FF3DFF3FFF5BFF5DFF5F-FF65',
    Pd: '002D058A05BE140018062010-20152E172E1A301C303030A0FE31FE32FE58FE63FF0D',
    Ps: '0028005B007B0F3A0F3C169B201A201E2045207D208D23292768276A276C276E27702772277427C527E627E827EA27EC27EE2983298529872989298B298D298F299129932995299729D829DA29FC2E222E242E262E283008300A300C300E3010301430163018301A301DFD3EFE17FE35FE37FE39FE3BFE3DFE3FFE41FE43FE47FE59FE5BFE5DFF08FF3BFF5BFF5FFF62',
    Pe: '0029005D007D0F3B0F3D169C2046207E208E232A2769276B276D276F27712773277527C627E727E927EB27ED27EF298429862988298A298C298E2990299229942996299829D929DB29FD2E232E252E272E293009300B300D300F3011301530173019301B301E301FFD3FFE18FE36FE38FE3AFE3CFE3EFE40FE42FE44FE48FE5AFE5CFE5EFF09FF3DFF5DFF60FF63',
    Pi: '00AB2018201B201C201F20392E022E042E092E0C2E1C2E20',
    Pf: '00BB2019201D203A2E032E052E0A2E0D2E1D2E21',
    Pc: '005F203F20402054FE33FE34FE4D-FE4FFF3F',
    Po: '0021-00230025-0027002A002C002E002F003A003B003F0040005C00A100B700BF037E0387055A-055F058905C005C305C605F305F40609060A060C060D061B061E061F066A-066D06D40700-070D07F7-07F90830-083E0964096509700DF40E4F0E5A0E5B0F04-0F120F850FD0-0FD4104A-104F10FB1361-1368166D166E16EB-16ED1735173617D4-17D617D8-17DA1800-18051807-180A1944194519DE19DF1A1E1A1F1AA0-1AA61AA8-1AAD1B5A-1B601C3B-1C3F1C7E1C7F1CD3201620172020-20272030-2038203B-203E2041-20432047-205120532055-205E2CF9-2CFC2CFE2CFF2E002E012E06-2E082E0B2E0E-2E162E182E192E1B2E1E2E1F2E2A-2E2E2E302E313001-3003303D30FBA4FEA4FFA60D-A60FA673A67EA6F2-A6F7A874-A877A8CEA8CFA8F8-A8FAA92EA92FA95FA9C1-A9CDA9DEA9DFAA5C-AA5FAADEAADFABEBFE10-FE16FE19FE30FE45FE46FE49-FE4CFE50-FE52FE54-FE57FE5F-FE61FE68FE6AFE6BFF01-FF03FF05-FF07FF0AFF0CFF0EFF0FFF1AFF1BFF1FFF20FF3CFF61FF64FF65',
    S: '0024002B003C-003E005E0060007C007E00A2-00A900AC00AE-00B100B400B600B800D700F702C2-02C502D2-02DF02E5-02EB02ED02EF-02FF03750384038503F604820606-0608060B060E060F06E906FD06FE07F609F209F309FA09FB0AF10B700BF3-0BFA0C7F0CF10CF20D790E3F0F01-0F030F13-0F170F1A-0F1F0F340F360F380FBE-0FC50FC7-0FCC0FCE0FCF0FD5-0FD8109E109F13601390-139917DB194019E0-19FF1B61-1B6A1B74-1B7C1FBD1FBF-1FC11FCD-1FCF1FDD-1FDF1FED-1FEF1FFD1FFE20442052207A-207C208A-208C20A0-20B8210021012103-21062108210921142116-2118211E-2123212521272129212E213A213B2140-2144214A-214D214F2190-2328232B-23E82400-24262440-244A249C-24E92500-26CD26CF-26E126E326E8-26FF2701-27042706-2709270C-27272729-274B274D274F-27522756-275E2761-276727942798-27AF27B1-27BE27C0-27C427C7-27CA27CC27D0-27E527F0-29822999-29D729DC-29FB29FE-2B4C2B50-2B592CE5-2CEA2E80-2E992E9B-2EF32F00-2FD52FF0-2FFB300430123013302030363037303E303F309B309C319031913196-319F31C0-31E33200-321E322A-32503260-327F328A-32B032C0-32FE3300-33FF4DC0-4DFFA490-A4C6A700-A716A720A721A789A78AA828-A82BA836-A839AA77-AA79FB29FDFCFDFDFE62FE64-FE66FE69FF04FF0BFF1C-FF1EFF3EFF40FF5CFF5EFFE0-FFE6FFE8-FFEEFFFCFFFD',
    Sm: '002B003C-003E007C007E00AC00B100D700F703F60606-060820442052207A-207C208A-208C2140-2144214B2190-2194219A219B21A021A321A621AE21CE21CF21D221D421F4-22FF2308-230B23202321237C239B-23B323DC-23E125B725C125F8-25FF266F27C0-27C427C7-27CA27CC27D0-27E527F0-27FF2900-29822999-29D729DC-29FB29FE-2AFF2B30-2B442B47-2B4CFB29FE62FE64-FE66FF0BFF1C-FF1EFF5CFF5EFFE2FFE9-FFEC',
    Sc: '002400A2-00A5060B09F209F309FB0AF10BF90E3F17DB20A0-20B8A838FDFCFE69FF04FFE0FFE1FFE5FFE6',
    Sk: '005E006000A800AF00B400B802C2-02C502D2-02DF02E5-02EB02ED02EF-02FF0375038403851FBD1FBF-1FC11FCD-1FCF1FDD-1FDF1FED-1FEF1FFD1FFE309B309CA700-A716A720A721A789A78AFF3EFF40FFE3',
    So: '00A600A700A900AE00B000B60482060E060F06E906FD06FE07F609FA0B700BF3-0BF80BFA0C7F0CF10CF20D790F01-0F030F13-0F170F1A-0F1F0F340F360F380FBE-0FC50FC7-0FCC0FCE0FCF0FD5-0FD8109E109F13601390-1399194019E0-19FF1B61-1B6A1B74-1B7C210021012103-21062108210921142116-2118211E-2123212521272129212E213A213B214A214C214D214F2195-2199219C-219F21A121A221A421A521A7-21AD21AF-21CD21D021D121D321D5-21F32300-2307230C-231F2322-2328232B-237B237D-239A23B4-23DB23E2-23E82400-24262440-244A249C-24E92500-25B625B8-25C025C2-25F72600-266E2670-26CD26CF-26E126E326E8-26FF2701-27042706-2709270C-27272729-274B274D274F-27522756-275E2761-276727942798-27AF27B1-27BE2800-28FF2B00-2B2F2B452B462B50-2B592CE5-2CEA2E80-2E992E9B-2EF32F00-2FD52FF0-2FFB300430123013302030363037303E303F319031913196-319F31C0-31E33200-321E322A-32503260-327F328A-32B032C0-32FE3300-33FF4DC0-4DFFA490-A4C6A828-A82BA836A837A839AA77-AA79FDFDFFE4FFE8FFEDFFEEFFFCFFFD',
    Z: '002000A01680180E2000-200A20282029202F205F3000',
    Zs: '002000A01680180E2000-200A202F205F3000',
    Zl: '2028',
    Zp: '2029',
    C: '0000-001F007F-009F00AD03780379037F-0383038B038D03A20526-05300557055805600588058B-059005C8-05CF05EB-05EF05F5-0605061C061D0620065F06DD070E070F074B074C07B2-07BF07FB-07FF082E082F083F-08FF093A093B094F095609570973-097809800984098D098E0991099209A909B109B3-09B509BA09BB09C509C609C909CA09CF-09D609D8-09DB09DE09E409E509FC-0A000A040A0B-0A0E0A110A120A290A310A340A370A3A0A3B0A3D0A43-0A460A490A4A0A4E-0A500A52-0A580A5D0A5F-0A650A76-0A800A840A8E0A920AA90AB10AB40ABA0ABB0AC60ACA0ACE0ACF0AD1-0ADF0AE40AE50AF00AF2-0B000B040B0D0B0E0B110B120B290B310B340B3A0B3B0B450B460B490B4A0B4E-0B550B58-0B5B0B5E0B640B650B72-0B810B840B8B-0B8D0B910B96-0B980B9B0B9D0BA0-0BA20BA5-0BA70BAB-0BAD0BBA-0BBD0BC3-0BC50BC90BCE0BCF0BD1-0BD60BD8-0BE50BFB-0C000C040C0D0C110C290C340C3A-0C3C0C450C490C4E-0C540C570C5A-0C5F0C640C650C70-0C770C800C810C840C8D0C910CA90CB40CBA0CBB0CC50CC90CCE-0CD40CD7-0CDD0CDF0CE40CE50CF00CF3-0D010D040D0D0D110D290D3A-0D3C0D450D490D4E-0D560D58-0D5F0D640D650D76-0D780D800D810D840D97-0D990DB20DBC0DBE0DBF0DC7-0DC90DCB-0DCE0DD50DD70DE0-0DF10DF5-0E000E3B-0E3E0E5C-0E800E830E850E860E890E8B0E8C0E8E-0E930E980EA00EA40EA60EA80EA90EAC0EBA0EBE0EBF0EC50EC70ECE0ECF0EDA0EDB0EDE-0EFF0F480F6D-0F700F8C-0F8F0F980FBD0FCD0FD9-0FFF10C6-10CF10FD-10FF1249124E124F12571259125E125F1289128E128F12B112B612B712BF12C112C612C712D7131113161317135B-135E137D-137F139A-139F13F5-13FF169D-169F16F1-16FF170D1715-171F1737-173F1754-175F176D17711774-177F17B417B517DE17DF17EA-17EF17FA-17FF180F181A-181F1878-187F18AB-18AF18F6-18FF191D-191F192C-192F193C-193F1941-1943196E196F1975-197F19AC-19AF19CA-19CF19DB-19DD1A1C1A1D1A5F1A7D1A7E1A8A-1A8F1A9A-1A9F1AAE-1AFF1B4C-1B4F1B7D-1B7F1BAB-1BAD1BBA-1BFF1C38-1C3A1C4A-1C4C1C80-1CCF1CF3-1CFF1DE7-1DFC1F161F171F1E1F1F1F461F471F4E1F4F1F581F5A1F5C1F5E1F7E1F7F1FB51FC51FD41FD51FDC1FF01FF11FF51FFF200B-200F202A-202E2060-206F20722073208F2095-209F20B9-20CF20F1-20FF218A-218F23E9-23FF2427-243F244B-245F26CE26E226E4-26E727002705270A270B2728274C274E2753-2755275F27602795-279727B027BF27CB27CD-27CF2B4D-2B4F2B5A-2BFF2C2F2C5F2CF2-2CF82D26-2D2F2D66-2D6E2D70-2D7F2D97-2D9F2DA72DAF2DB72DBF2DC72DCF2DD72DDF2E32-2E7F2E9A2EF4-2EFF2FD6-2FEF2FFC-2FFF3040309730983100-3104312E-3130318F31B8-31BF31E4-31EF321F32FF4DB6-4DBF9FCC-9FFFA48D-A48FA4C7-A4CFA62C-A63FA660A661A674-A67BA698-A69FA6F8-A6FFA78D-A7FAA82C-A82FA83A-A83FA878-A87FA8C5-A8CDA8DA-A8DFA8FC-A8FFA954-A95EA97D-A97FA9CEA9DA-A9DDA9E0-A9FFAA37-AA3FAA4EAA4FAA5AAA5BAA7C-AA7FAAC3-AADAAAE0-ABBFABEEABEFABFA-ABFFD7A4-D7AFD7C7-D7CAD7FC-F8FFFA2EFA2FFA6EFA6FFADA-FAFFFB07-FB12FB18-FB1CFB37FB3DFB3FFB42FB45FBB2-FBD2FD40-FD4FFD90FD91FDC8-FDEFFDFEFDFFFE1A-FE1FFE27-FE2FFE53FE67FE6C-FE6FFE75FEFD-FF00FFBF-FFC1FFC8FFC9FFD0FFD1FFD8FFD9FFDD-FFDFFFE7FFEF-FFFBFFFEFFFF',
    Cc: '0000-001F007F-009F',
    Cf: '00AD0600-060306DD070F17B417B5200B-200F202A-202E2060-2064206A-206FFEFFFFF9-FFFB',
    Co: 'E000-F8FF',
    Cs: 'D800-DFFF',
    Cn: '03780379037F-0383038B038D03A20526-05300557055805600588058B-059005C8-05CF05EB-05EF05F5-05FF06040605061C061D0620065F070E074B074C07B2-07BF07FB-07FF082E082F083F-08FF093A093B094F095609570973-097809800984098D098E0991099209A909B109B3-09B509BA09BB09C509C609C909CA09CF-09D609D8-09DB09DE09E409E509FC-0A000A040A0B-0A0E0A110A120A290A310A340A370A3A0A3B0A3D0A43-0A460A490A4A0A4E-0A500A52-0A580A5D0A5F-0A650A76-0A800A840A8E0A920AA90AB10AB40ABA0ABB0AC60ACA0ACE0ACF0AD1-0ADF0AE40AE50AF00AF2-0B000B040B0D0B0E0B110B120B290B310B340B3A0B3B0B450B460B490B4A0B4E-0B550B58-0B5B0B5E0B640B650B72-0B810B840B8B-0B8D0B910B96-0B980B9B0B9D0BA0-0BA20BA5-0BA70BAB-0BAD0BBA-0BBD0BC3-0BC50BC90BCE0BCF0BD1-0BD60BD8-0BE50BFB-0C000C040C0D0C110C290C340C3A-0C3C0C450C490C4E-0C540C570C5A-0C5F0C640C650C70-0C770C800C810C840C8D0C910CA90CB40CBA0CBB0CC50CC90CCE-0CD40CD7-0CDD0CDF0CE40CE50CF00CF3-0D010D040D0D0D110D290D3A-0D3C0D450D490D4E-0D560D58-0D5F0D640D650D76-0D780D800D810D840D97-0D990DB20DBC0DBE0DBF0DC7-0DC90DCB-0DCE0DD50DD70DE0-0DF10DF5-0E000E3B-0E3E0E5C-0E800E830E850E860E890E8B0E8C0E8E-0E930E980EA00EA40EA60EA80EA90EAC0EBA0EBE0EBF0EC50EC70ECE0ECF0EDA0EDB0EDE-0EFF0F480F6D-0F700F8C-0F8F0F980FBD0FCD0FD9-0FFF10C6-10CF10FD-10FF1249124E124F12571259125E125F1289128E128F12B112B612B712BF12C112C612C712D7131113161317135B-135E137D-137F139A-139F13F5-13FF169D-169F16F1-16FF170D1715-171F1737-173F1754-175F176D17711774-177F17DE17DF17EA-17EF17FA-17FF180F181A-181F1878-187F18AB-18AF18F6-18FF191D-191F192C-192F193C-193F1941-1943196E196F1975-197F19AC-19AF19CA-19CF19DB-19DD1A1C1A1D1A5F1A7D1A7E1A8A-1A8F1A9A-1A9F1AAE-1AFF1B4C-1B4F1B7D-1B7F1BAB-1BAD1BBA-1BFF1C38-1C3A1C4A-1C4C1C80-1CCF1CF3-1CFF1DE7-1DFC1F161F171F1E1F1F1F461F471F4E1F4F1F581F5A1F5C1F5E1F7E1F7F1FB51FC51FD41FD51FDC1FF01FF11FF51FFF2065-206920722073208F2095-209F20B9-20CF20F1-20FF218A-218F23E9-23FF2427-243F244B-245F26CE26E226E4-26E727002705270A270B2728274C274E2753-2755275F27602795-279727B027BF27CB27CD-27CF2B4D-2B4F2B5A-2BFF2C2F2C5F2CF2-2CF82D26-2D2F2D66-2D6E2D70-2D7F2D97-2D9F2DA72DAF2DB72DBF2DC72DCF2DD72DDF2E32-2E7F2E9A2EF4-2EFF2FD6-2FEF2FFC-2FFF3040309730983100-3104312E-3130318F31B8-31BF31E4-31EF321F32FF4DB6-4DBF9FCC-9FFFA48D-A48FA4C7-A4CFA62C-A63FA660A661A674-A67BA698-A69FA6F8-A6FFA78D-A7FAA82C-A82FA83A-A83FA878-A87FA8C5-A8CDA8DA-A8DFA8FC-A8FFA954-A95EA97D-A97FA9CEA9DA-A9DDA9E0-A9FFAA37-AA3FAA4EAA4FAA5AAA5BAA7C-AA7FAAC3-AADAAAE0-ABBFABEEABEFABFA-ABFFD7A4-D7AFD7C7-D7CAD7FC-D7FFFA2EFA2FFA6EFA6FFADA-FAFFFB07-FB12FB18-FB1CFB37FB3DFB3FFB42FB45FBB2-FBD2FD40-FD4FFD90FD91FDC8-FDEFFDFEFDFFFE1A-FE1FFE27-FE2FFE53FE67FE6C-FE6FFE75FEFDFEFEFF00FFBF-FFC1FFC8FFC9FFD0FFD1FFD8FFD9FFDD-FFDFFFE7FFEF-FFF8FFFEFFFF'
  });
  function addUnicodePackage(pack) {
    var codePoint = /\w{4}/g;
    for (var name in pack)
      exports.packages[name] = pack[name].replace(codePoint, '\\u$&');
  }
  ;
});
ace.define('ace/token_iterator', [
  'require',
  'exports',
  'module'
], function (require, exports, module) {
  var TokenIterator = function (session, initialRow, initialColumn) {
    this.$session = session;
    this.$row = initialRow;
    this.$rowTokens = session.getTokens(initialRow);
    var token = session.getTokenAt(initialRow, initialColumn);
    this.$tokenIndex = token ? token.index : -1;
  };
  (function () {
    this.stepBackward = function () {
      this.$tokenIndex -= 1;
      while (this.$tokenIndex < 0) {
        this.$row -= 1;
        if (this.$row < 0) {
          this.$row = 0;
          return null;
        }
        this.$rowTokens = this.$session.getTokens(this.$row);
        this.$tokenIndex = this.$rowTokens.length - 1;
      }
      return this.$rowTokens[this.$tokenIndex];
    };
    this.stepForward = function () {
      this.$tokenIndex += 1;
      var rowCount;
      while (this.$tokenIndex >= this.$rowTokens.length) {
        this.$row += 1;
        if (!rowCount)
          rowCount = this.$session.getLength();
        if (this.$row >= rowCount) {
          this.$row = rowCount - 1;
          return null;
        }
        this.$rowTokens = this.$session.getTokens(this.$row);
        this.$tokenIndex = 0;
      }
      return this.$rowTokens[this.$tokenIndex];
    };
    this.getCurrentToken = function () {
      return this.$rowTokens[this.$tokenIndex];
    };
    this.getCurrentTokenRow = function () {
      return this.$row;
    };
    this.getCurrentTokenColumn = function () {
      var rowTokens = this.$rowTokens;
      var tokenIndex = this.$tokenIndex;
      var column = rowTokens[tokenIndex].start;
      if (column !== undefined)
        return column;
      column = 0;
      while (tokenIndex > 0) {
        tokenIndex -= 1;
        column += rowTokens[tokenIndex].value.length;
      }
      return column;
    };
  }.call(TokenIterator.prototype));
  exports.TokenIterator = TokenIterator;
});
ace.define('ace/mode/text_highlight_rules', [
  'require',
  'exports',
  'module',
  'ace/lib/lang'
], function (require, exports, module) {
  var lang = require('../lib/lang');
  var TextHighlightRules = function () {
    this.$rules = {
      'start': [
        {
          token: 'empty_line',
          regex: '^$'
        },
        { defaultToken: 'text' }
      ]
    };
  };
  (function () {
    this.addRules = function (rules, prefix) {
      if (!prefix) {
        for (var key in rules)
          this.$rules[key] = rules[key];
        return;
      }
      for (var key in rules) {
        var state = rules[key];
        for (var i = 0; i < state.length; i++) {
          var rule = state[i];
          if (rule.next) {
            if (typeof rule.next != 'string') {
              if (rule.nextState && rule.nextState.indexOf(prefix) !== 0)
                rule.nextState = prefix + rule.nextState;
            } else {
              if (rule.next.indexOf(prefix) !== 0)
                rule.next = prefix + rule.next;
            }
          }
        }
        this.$rules[prefix + key] = state;
      }
    };
    this.getRules = function () {
      return this.$rules;
    };
    this.embedRules = function (HighlightRules, prefix, escapeRules, states, append) {
      var embedRules = typeof HighlightRules == 'function' ? new HighlightRules().getRules() : HighlightRules;
      if (states) {
        for (var i = 0; i < states.length; i++)
          states[i] = prefix + states[i];
      } else {
        states = [];
        for (var key in embedRules)
          states.push(prefix + key);
      }
      this.addRules(embedRules, prefix);
      if (escapeRules) {
        var addRules = Array.prototype[append ? 'push' : 'unshift'];
        for (var i = 0; i < states.length; i++)
          addRules.apply(this.$rules[states[i]], lang.deepCopy(escapeRules));
      }
      if (!this.$embeds)
        this.$embeds = [];
      this.$embeds.push(prefix);
    };
    this.getEmbeds = function () {
      return this.$embeds;
    };
    var pushState = function (currentState, stack) {
      if (currentState != 'start' || stack.length)
        stack.unshift(this.nextState, currentState);
      return this.nextState;
    };
    var popState = function (currentState, stack) {
      stack.shift();
      return stack.shift() || 'start';
    };
    this.normalizeRules = function () {
      var id = 0;
      var rules = this.$rules;
      function processState(key) {
        var state = rules[key];
        state.processed = true;
        for (var i = 0; i < state.length; i++) {
          var rule = state[i];
          if (!rule.regex && rule.start) {
            rule.regex = rule.start;
            if (!rule.next)
              rule.next = [];
            rule.next.push({ defaultToken: rule.token }, {
              token: rule.token + '.end',
              regex: rule.end || rule.start,
              next: 'pop'
            });
            rule.token = rule.token + '.start';
            rule.push = true;
          }
          var next = rule.next || rule.push;
          if (next && Array.isArray(next)) {
            var stateName = rule.stateName;
            if (!stateName) {
              stateName = rule.token;
              if (typeof stateName != 'string')
                stateName = stateName[0] || '';
              if (rules[stateName])
                stateName += id++;
            }
            rules[stateName] = next;
            rule.next = stateName;
            processState(stateName);
          } else if (next == 'pop') {
            rule.next = popState;
          }
          if (rule.push) {
            rule.nextState = rule.next || rule.push;
            rule.next = pushState;
            delete rule.push;
          }
          if (rule.rules) {
            for (var r in rule.rules) {
              if (rules[r]) {
                if (rules[r].push)
                  rules[r].push.apply(rules[r], rule.rules[r]);
              } else {
                rules[r] = rule.rules[r];
              }
            }
          }
          if (rule.include || typeof rule == 'string') {
            var includeName = rule.include || rule;
            var toInsert = rules[includeName];
          } else if (Array.isArray(rule))
            toInsert = rule;
          if (toInsert) {
            var args = [
                i,
                1
              ].concat(toInsert);
            if (rule.noEscape)
              args = args.filter(function (x) {
                return !x.next;
              });
            state.splice.apply(state, args);
            i--;
            toInsert = null;
          }
          if (rule.keywordMap) {
            rule.token = this.createKeywordMapper(rule.keywordMap, rule.defaultToken || 'text', rule.caseInsensitive);
            delete rule.defaultToken;
          }
        }
      }
      ;
      Object.keys(rules).forEach(processState, this);
    };
    this.createKeywordMapper = function (map, defaultToken, ignoreCase, splitChar) {
      var keywords = Object.create(null);
      Object.keys(map).forEach(function (className) {
        var a = map[className];
        if (ignoreCase)
          a = a.toLowerCase();
        var list = a.split(splitChar || '|');
        for (var i = list.length; i--;)
          keywords[list[i]] = className;
      });
      if (Object.getPrototypeOf(keywords)) {
        keywords.__proto__ = null;
      }
      this.$keywordList = Object.keys(keywords);
      map = null;
      return ignoreCase ? function (value) {
        return keywords[value.toLowerCase()] || defaultToken;
      } : function (value) {
        return keywords[value] || defaultToken;
      };
    };
    this.getKeywords = function () {
      return this.$keywords;
    };
  }.call(TextHighlightRules.prototype));
  exports.TextHighlightRules = TextHighlightRules;
});
ace.define('ace/anchor', [
  'require',
  'exports',
  'module',
  'ace/lib/oop',
  'ace/lib/event_emitter'
], function (require, exports, module) {
  var oop = require('./lib/oop');
  var EventEmitter = require('./lib/event_emitter').EventEmitter;
  var Anchor = exports.Anchor = function (doc, row, column) {
      this.$onChange = this.onChange.bind(this);
      this.attach(doc);
      if (typeof column == 'undefined')
        this.setPosition(row.row, row.column);
      else
        this.setPosition(row, column);
    };
  (function () {
    oop.implement(this, EventEmitter);
    this.getPosition = function () {
      return this.$clipPositionToDocument(this.row, this.column);
    };
    this.getDocument = function () {
      return this.document;
    };
    this.$insertRight = false;
    this.onChange = function (e) {
      var delta = e.data;
      var range = delta.range;
      if (range.start.row == range.end.row && range.start.row != this.row)
        return;
      if (range.start.row > this.row)
        return;
      if (range.start.row == this.row && range.start.column > this.column)
        return;
      var row = this.row;
      var column = this.column;
      var start = range.start;
      var end = range.end;
      if (delta.action === 'insertText') {
        if (start.row === row && start.column <= column) {
          if (start.column === column && this.$insertRight) {
          } else if (start.row === end.row) {
            column += end.column - start.column;
          } else {
            column -= start.column;
            row += end.row - start.row;
          }
        } else if (start.row !== end.row && start.row < row) {
          row += end.row - start.row;
        }
      } else if (delta.action === 'insertLines') {
        if (start.row <= row) {
          row += end.row - start.row;
        }
      } else if (delta.action === 'removeText') {
        if (start.row === row && start.column < column) {
          if (end.column >= column)
            column = start.column;
          else
            column = Math.max(0, column - (end.column - start.column));
        } else if (start.row !== end.row && start.row < row) {
          if (end.row === row)
            column = Math.max(0, column - end.column) + start.column;
          row -= end.row - start.row;
        } else if (end.row === row) {
          row -= end.row - start.row;
          column = Math.max(0, column - end.column) + start.column;
        }
      } else if (delta.action == 'removeLines') {
        if (start.row <= row) {
          if (end.row <= row)
            row -= end.row - start.row;
          else {
            row = start.row;
            column = 0;
          }
        }
      }
      this.setPosition(row, column, true);
    };
    this.setPosition = function (row, column, noClip) {
      var pos;
      if (noClip) {
        pos = {
          row: row,
          column: column
        };
      } else {
        pos = this.$clipPositionToDocument(row, column);
      }
      if (this.row == pos.row && this.column == pos.column)
        return;
      var old = {
          row: this.row,
          column: this.column
        };
      this.row = pos.row;
      this.column = pos.column;
      this._signal('change', {
        old: old,
        value: pos
      });
    };
    this.detach = function () {
      this.document.removeEventListener('change', this.$onChange);
    };
    this.attach = function (doc) {
      this.document = doc || this.document;
      this.document.on('change', this.$onChange);
    };
    this.$clipPositionToDocument = function (row, column) {
      var pos = {};
      if (row >= this.document.getLength()) {
        pos.row = Math.max(0, this.document.getLength() - 1);
        pos.column = this.document.getLine(pos.row).length;
      } else if (row < 0) {
        pos.row = 0;
        pos.column = 0;
      } else {
        pos.row = row;
        pos.column = Math.min(this.document.getLine(pos.row).length, Math.max(0, column));
      }
      if (column < 0)
        pos.column = 0;
      return pos;
    };
  }.call(Anchor.prototype));
});
ace.define('ace/background_tokenizer', [
  'require',
  'exports',
  'module',
  'ace/lib/oop',
  'ace/lib/event_emitter'
], function (require, exports, module) {
  var oop = require('./lib/oop');
  var EventEmitter = require('./lib/event_emitter').EventEmitter;
  var BackgroundTokenizer = function (tokenizer, editor) {
    this.running = false;
    this.lines = [];
    this.states = [];
    this.currentLine = 0;
    this.tokenizer = tokenizer;
    var self = this;
    this.$worker = function () {
      if (!self.running) {
        return;
      }
      var workerStart = new Date();
      var currentLine = self.currentLine;
      var endLine = -1;
      var doc = self.doc;
      while (self.lines[currentLine])
        currentLine++;
      var startLine = currentLine;
      var len = doc.getLength();
      var processedLines = 0;
      self.running = false;
      while (currentLine < len) {
        self.$tokenizeRow(currentLine);
        endLine = currentLine;
        do {
          currentLine++;
        } while (self.lines[currentLine]);
        processedLines++;
        if (processedLines % 5 == 0 && new Date() - workerStart > 20) {
          self.running = setTimeout(self.$worker, 20);
          self.currentLine = currentLine;
          return;
        }
      }
      self.currentLine = currentLine;
      if (startLine <= endLine)
        self.fireUpdateEvent(startLine, endLine);
    };
  };
  (function () {
    oop.implement(this, EventEmitter);
    this.setTokenizer = function (tokenizer) {
      this.tokenizer = tokenizer;
      this.lines = [];
      this.states = [];
      this.start(0);
    };
    this.setDocument = function (doc) {
      this.doc = doc;
      this.lines = [];
      this.states = [];
      this.stop();
    };
    this.fireUpdateEvent = function (firstRow, lastRow) {
      var data = {
          first: firstRow,
          last: lastRow
        };
      this._signal('update', { data: data });
    };
    this.start = function (startRow) {
      this.currentLine = Math.min(startRow || 0, this.currentLine, this.doc.getLength());
      this.lines.splice(this.currentLine, this.lines.length);
      this.states.splice(this.currentLine, this.states.length);
      this.stop();
      this.running = setTimeout(this.$worker, 700);
    };
    this.scheduleStart = function () {
      if (!this.running)
        this.running = setTimeout(this.$worker, 700);
    };
    this.$updateOnChange = function (delta) {
      var range = delta.range;
      var startRow = range.start.row;
      var len = range.end.row - startRow;
      if (len === 0) {
        this.lines[startRow] = null;
      } else if (delta.action == 'removeText' || delta.action == 'removeLines') {
        this.lines.splice(startRow, len + 1, null);
        this.states.splice(startRow, len + 1, null);
      } else {
        var args = Array(len + 1);
        args.unshift(startRow, 1);
        this.lines.splice.apply(this.lines, args);
        this.states.splice.apply(this.states, args);
      }
      this.currentLine = Math.min(startRow, this.currentLine, this.doc.getLength());
      this.stop();
    };
    this.stop = function () {
      if (this.running)
        clearTimeout(this.running);
      this.running = false;
    };
    this.getTokens = function (row) {
      return this.lines[row] || this.$tokenizeRow(row);
    };
    this.getState = function (row) {
      if (this.currentLine == row)
        this.$tokenizeRow(row);
      return this.states[row] || 'start';
    };
    this.$tokenizeRow = function (row) {
      var line = this.doc.getLine(row);
      var state = this.states[row - 1];
      var data = this.tokenizer.getLineTokens(line, state, row);
      if (this.states[row] + '' !== data.state + '') {
        this.states[row] = data.state;
        this.lines[row + 1] = null;
        if (this.currentLine > row + 1)
          this.currentLine = row + 1;
      } else if (this.currentLine == row) {
        this.currentLine = row + 1;
      }
      return this.lines[row] = data.tokens;
    };
  }.call(BackgroundTokenizer.prototype));
  exports.BackgroundTokenizer = BackgroundTokenizer;
});
ace.define('ace/search_highlight', [
  'require',
  'exports',
  'module',
  'ace/lib/lang',
  'ace/lib/oop',
  'ace/range'
], function (require, exports, module) {
  var lang = require('./lib/lang');
  var oop = require('./lib/oop');
  var Range = require('./range').Range;
  var SearchHighlight = function (regExp, clazz, type) {
    this.setRegexp(regExp);
    this.clazz = clazz;
    this.type = type || 'text';
  };
  (function () {
    this.MAX_RANGES = 500;
    this.setRegexp = function (regExp) {
      if (this.regExp + '' == regExp + '')
        return;
      this.regExp = regExp;
      this.cache = [];
    };
    this.update = function (html, markerLayer, session, config) {
      if (!this.regExp)
        return;
      var start = config.firstRow, end = config.lastRow;
      for (var i = start; i <= end; i++) {
        var ranges = this.cache[i];
        if (ranges == null) {
          ranges = lang.getMatchOffsets(session.getLine(i), this.regExp);
          if (ranges.length > this.MAX_RANGES)
            ranges = ranges.slice(0, this.MAX_RANGES);
          ranges = ranges.map(function (match) {
            return new Range(i, match.offset, i, match.offset + match.length);
          });
          this.cache[i] = ranges.length ? ranges : '';
        }
        for (var j = ranges.length; j--;) {
          markerLayer.drawSingleLineMarker(html, ranges[j].toScreenRange(session), this.clazz, config);
        }
      }
    };
  }.call(SearchHighlight.prototype));
  exports.SearchHighlight = SearchHighlight;
});
ace.define('ace/edit_session/folding', [
  'require',
  'exports',
  'module',
  'ace/range',
  'ace/edit_session/fold_line',
  'ace/edit_session/fold',
  'ace/token_iterator'
], function (require, exports, module) {
  var Range = require('../range').Range;
  var FoldLine = require('./fold_line').FoldLine;
  var Fold = require('./fold').Fold;
  var TokenIterator = require('../token_iterator').TokenIterator;
  function Folding() {
    this.getFoldAt = function (row, column, side) {
      var foldLine = this.getFoldLine(row);
      if (!foldLine)
        return null;
      var folds = foldLine.folds;
      for (var i = 0; i < folds.length; i++) {
        var fold = folds[i];
        if (fold.range.contains(row, column)) {
          if (side == 1 && fold.range.isEnd(row, column)) {
            continue;
          } else if (side == -1 && fold.range.isStart(row, column)) {
            continue;
          }
          return fold;
        }
      }
    };
    this.getFoldsInRange = function (range) {
      var start = range.start;
      var end = range.end;
      var foldLines = this.$foldData;
      var foundFolds = [];
      start.column += 1;
      end.column -= 1;
      for (var i = 0; i < foldLines.length; i++) {
        var cmp = foldLines[i].range.compareRange(range);
        if (cmp == 2) {
          continue;
        } else if (cmp == -2) {
          break;
        }
        var folds = foldLines[i].folds;
        for (var j = 0; j < folds.length; j++) {
          var fold = folds[j];
          cmp = fold.range.compareRange(range);
          if (cmp == -2) {
            break;
          } else if (cmp == 2) {
            continue;
          } else if (cmp == 42) {
            break;
          }
          foundFolds.push(fold);
        }
      }
      start.column -= 1;
      end.column += 1;
      return foundFolds;
    };
    this.getFoldsInRangeList = function (ranges) {
      if (Array.isArray(ranges)) {
        var folds = [];
        ranges.forEach(function (range) {
          folds = folds.concat(this.getFoldsInRange(range));
        }, this);
      } else {
        var folds = this.getFoldsInRange(ranges);
      }
      return folds;
    };
    this.getAllFolds = function () {
      var folds = [];
      var foldLines = this.$foldData;
      for (var i = 0; i < foldLines.length; i++)
        for (var j = 0; j < foldLines[i].folds.length; j++)
          folds.push(foldLines[i].folds[j]);
      return folds;
    };
    this.getFoldStringAt = function (row, column, trim, foldLine) {
      foldLine = foldLine || this.getFoldLine(row);
      if (!foldLine)
        return null;
      var lastFold = { end: { column: 0 } };
      var str, fold;
      for (var i = 0; i < foldLine.folds.length; i++) {
        fold = foldLine.folds[i];
        var cmp = fold.range.compareEnd(row, column);
        if (cmp == -1) {
          str = this.getLine(fold.start.row).substring(lastFold.end.column, fold.start.column);
          break;
        } else if (cmp === 0) {
          return null;
        }
        lastFold = fold;
      }
      if (!str)
        str = this.getLine(fold.start.row).substring(lastFold.end.column);
      if (trim == -1)
        return str.substring(0, column - lastFold.end.column);
      else if (trim == 1)
        return str.substring(column - lastFold.end.column);
      else
        return str;
    };
    this.getFoldLine = function (docRow, startFoldLine) {
      var foldData = this.$foldData;
      var i = 0;
      if (startFoldLine)
        i = foldData.indexOf(startFoldLine);
      if (i == -1)
        i = 0;
      for (i; i < foldData.length; i++) {
        var foldLine = foldData[i];
        if (foldLine.start.row <= docRow && foldLine.end.row >= docRow) {
          return foldLine;
        } else if (foldLine.end.row > docRow) {
          return null;
        }
      }
      return null;
    };
    this.getNextFoldLine = function (docRow, startFoldLine) {
      var foldData = this.$foldData;
      var i = 0;
      if (startFoldLine)
        i = foldData.indexOf(startFoldLine);
      if (i == -1)
        i = 0;
      for (i; i < foldData.length; i++) {
        var foldLine = foldData[i];
        if (foldLine.end.row >= docRow) {
          return foldLine;
        }
      }
      return null;
    };
    this.getFoldedRowCount = function (first, last) {
      var foldData = this.$foldData, rowCount = last - first + 1;
      for (var i = 0; i < foldData.length; i++) {
        var foldLine = foldData[i], end = foldLine.end.row, start = foldLine.start.row;
        if (end >= last) {
          if (start < last) {
            if (start >= first)
              rowCount -= last - start;
            else
              rowCount = 0;
          }
          break;
        } else if (end >= first) {
          if (start >= first)
            rowCount -= end - start;
          else
            rowCount -= end - first + 1;
        }
      }
      return rowCount;
    };
    this.$addFoldLine = function (foldLine) {
      this.$foldData.push(foldLine);
      this.$foldData.sort(function (a, b) {
        return a.start.row - b.start.row;
      });
      return foldLine;
    };
    this.addFold = function (placeholder, range) {
      var foldData = this.$foldData;
      var added = false;
      var fold;
      if (placeholder instanceof Fold)
        fold = placeholder;
      else {
        fold = new Fold(range, placeholder);
        fold.collapseChildren = range.collapseChildren;
      }
      this.$clipRangeToDocument(fold.range);
      var startRow = fold.start.row;
      var startColumn = fold.start.column;
      var endRow = fold.end.row;
      var endColumn = fold.end.column;
      if (!(startRow < endRow || startRow == endRow && startColumn <= endColumn - 2))
        throw new Error('The range has to be at least 2 characters width');
      var startFold = this.getFoldAt(startRow, startColumn, 1);
      var endFold = this.getFoldAt(endRow, endColumn, -1);
      if (startFold && endFold == startFold)
        return startFold.addSubFold(fold);
      if (startFold && !startFold.range.isStart(startRow, startColumn) || endFold && !endFold.range.isEnd(endRow, endColumn)) {
        throw new Error('A fold can\'t intersect already existing fold' + fold.range + startFold.range);
      }
      var folds = this.getFoldsInRange(fold.range);
      if (folds.length > 0) {
        this.removeFolds(folds);
        folds.forEach(function (subFold) {
          fold.addSubFold(subFold);
        });
      }
      for (var i = 0; i < foldData.length; i++) {
        var foldLine = foldData[i];
        if (endRow == foldLine.start.row) {
          foldLine.addFold(fold);
          added = true;
          break;
        } else if (startRow == foldLine.end.row) {
          foldLine.addFold(fold);
          added = true;
          if (!fold.sameRow) {
            var foldLineNext = foldData[i + 1];
            if (foldLineNext && foldLineNext.start.row == endRow) {
              foldLine.merge(foldLineNext);
              break;
            }
          }
          break;
        } else if (endRow <= foldLine.start.row) {
          break;
        }
      }
      if (!added)
        foldLine = this.$addFoldLine(new FoldLine(this.$foldData, fold));
      if (this.$useWrapMode)
        this.$updateWrapData(foldLine.start.row, foldLine.start.row);
      else
        this.$updateRowLengthCache(foldLine.start.row, foldLine.start.row);
      this.$modified = true;
      this._emit('changeFold', {
        data: fold,
        action: 'add'
      });
      return fold;
    };
    this.addFolds = function (folds) {
      folds.forEach(function (fold) {
        this.addFold(fold);
      }, this);
    };
    this.removeFold = function (fold) {
      var foldLine = fold.foldLine;
      var startRow = foldLine.start.row;
      var endRow = foldLine.end.row;
      var foldLines = this.$foldData;
      var folds = foldLine.folds;
      if (folds.length == 1) {
        foldLines.splice(foldLines.indexOf(foldLine), 1);
      } else if (foldLine.range.isEnd(fold.end.row, fold.end.column)) {
        folds.pop();
        foldLine.end.row = folds[folds.length - 1].end.row;
        foldLine.end.column = folds[folds.length - 1].end.column;
      } else if (foldLine.range.isStart(fold.start.row, fold.start.column)) {
        folds.shift();
        foldLine.start.row = folds[0].start.row;
        foldLine.start.column = folds[0].start.column;
      } else if (fold.sameRow) {
        folds.splice(folds.indexOf(fold), 1);
      } else {
        var newFoldLine = foldLine.split(fold.start.row, fold.start.column);
        folds = newFoldLine.folds;
        folds.shift();
        newFoldLine.start.row = folds[0].start.row;
        newFoldLine.start.column = folds[0].start.column;
      }
      if (!this.$updating) {
        if (this.$useWrapMode)
          this.$updateWrapData(startRow, endRow);
        else
          this.$updateRowLengthCache(startRow, endRow);
      }
      this.$modified = true;
      this._emit('changeFold', {
        data: fold,
        action: 'remove'
      });
    };
    this.removeFolds = function (folds) {
      var cloneFolds = [];
      for (var i = 0; i < folds.length; i++) {
        cloneFolds.push(folds[i]);
      }
      cloneFolds.forEach(function (fold) {
        this.removeFold(fold);
      }, this);
      this.$modified = true;
    };
    this.expandFold = function (fold) {
      this.removeFold(fold);
      fold.subFolds.forEach(function (subFold) {
        fold.restoreRange(subFold);
        this.addFold(subFold);
      }, this);
      if (fold.collapseChildren > 0) {
        this.foldAll(fold.start.row + 1, fold.end.row, fold.collapseChildren - 1);
      }
      fold.subFolds = [];
    };
    this.expandFolds = function (folds) {
      folds.forEach(function (fold) {
        this.expandFold(fold);
      }, this);
    };
    this.unfold = function (location, expandInner) {
      var range, folds;
      if (location == null) {
        range = new Range(0, 0, this.getLength(), 0);
        expandInner = true;
      } else if (typeof location == 'number')
        range = new Range(location, 0, location, this.getLine(location).length);
      else if ('row' in location)
        range = Range.fromPoints(location, location);
      else
        range = location;
      folds = this.getFoldsInRangeList(range);
      if (expandInner) {
        this.removeFolds(folds);
      } else {
        var subFolds = folds;
        while (subFolds.length) {
          this.expandFolds(subFolds);
          subFolds = this.getFoldsInRangeList(range);
        }
      }
      if (folds.length)
        return folds;
    };
    this.isRowFolded = function (docRow, startFoldRow) {
      return !!this.getFoldLine(docRow, startFoldRow);
    };
    this.getRowFoldEnd = function (docRow, startFoldRow) {
      var foldLine = this.getFoldLine(docRow, startFoldRow);
      return foldLine ? foldLine.end.row : docRow;
    };
    this.getRowFoldStart = function (docRow, startFoldRow) {
      var foldLine = this.getFoldLine(docRow, startFoldRow);
      return foldLine ? foldLine.start.row : docRow;
    };
    this.getFoldDisplayLine = function (foldLine, endRow, endColumn, startRow, startColumn) {
      if (startRow == null) {
        startRow = foldLine.start.row;
        startColumn = 0;
      }
      if (endRow == null) {
        endRow = foldLine.end.row;
        endColumn = this.getLine(endRow).length;
      }
      var doc = this.doc;
      var textLine = '';
      foldLine.walk(function (placeholder, row, column, lastColumn) {
        if (row < startRow)
          return;
        if (row == startRow) {
          if (column < startColumn)
            return;
          lastColumn = Math.max(startColumn, lastColumn);
        }
        if (placeholder != null) {
          textLine += placeholder;
        } else {
          textLine += doc.getLine(row).substring(lastColumn, column);
        }
      }, endRow, endColumn);
      return textLine;
    };
    this.getDisplayLine = function (row, endColumn, startRow, startColumn) {
      var foldLine = this.getFoldLine(row);
      if (!foldLine) {
        var line;
        line = this.doc.getLine(row);
        return line.substring(startColumn || 0, endColumn || line.length);
      } else {
        return this.getFoldDisplayLine(foldLine, row, endColumn, startRow, startColumn);
      }
    };
    this.$cloneFoldData = function () {
      var fd = [];
      fd = this.$foldData.map(function (foldLine) {
        var folds = foldLine.folds.map(function (fold) {
            return fold.clone();
          });
        return new FoldLine(fd, folds);
      });
      return fd;
    };
    this.toggleFold = function (tryToUnfold) {
      var selection = this.selection;
      var range = selection.getRange();
      var fold;
      var bracketPos;
      if (range.isEmpty()) {
        var cursor = range.start;
        fold = this.getFoldAt(cursor.row, cursor.column);
        if (fold) {
          this.expandFold(fold);
          return;
        } else if (bracketPos = this.findMatchingBracket(cursor)) {
          if (range.comparePoint(bracketPos) == 1) {
            range.end = bracketPos;
          } else {
            range.start = bracketPos;
            range.start.column++;
            range.end.column--;
          }
        } else if (bracketPos = this.findMatchingBracket({
            row: cursor.row,
            column: cursor.column + 1
          })) {
          if (range.comparePoint(bracketPos) == 1)
            range.end = bracketPos;
          else
            range.start = bracketPos;
          range.start.column++;
        } else {
          range = this.getCommentFoldRange(cursor.row, cursor.column) || range;
        }
      } else {
        var folds = this.getFoldsInRange(range);
        if (tryToUnfold && folds.length) {
          this.expandFolds(folds);
          return;
        } else if (folds.length == 1) {
          fold = folds[0];
        }
      }
      if (!fold)
        fold = this.getFoldAt(range.start.row, range.start.column);
      if (fold && fold.range.toString() == range.toString()) {
        this.expandFold(fold);
        return;
      }
      var placeholder = '...';
      if (!range.isMultiLine()) {
        placeholder = this.getTextRange(range);
        if (placeholder.length < 4)
          return;
        placeholder = placeholder.trim().substring(0, 2) + '..';
      }
      this.addFold(placeholder, range);
    };
    this.getCommentFoldRange = function (row, column, dir) {
      var iterator = new TokenIterator(this, row, column);
      var token = iterator.getCurrentToken();
      if (token && /^comment|string/.test(token.type)) {
        var range = new Range();
        var re = new RegExp(token.type.replace(/\..*/, '\\.'));
        if (dir != 1) {
          do {
            token = iterator.stepBackward();
          } while (token && re.test(token.type));
          iterator.stepForward();
        }
        range.start.row = iterator.getCurrentTokenRow();
        range.start.column = iterator.getCurrentTokenColumn() + 2;
        iterator = new TokenIterator(this, row, column);
        if (dir != -1) {
          do {
            token = iterator.stepForward();
          } while (token && re.test(token.type));
          token = iterator.stepBackward();
        } else
          token = iterator.getCurrentToken();
        range.end.row = iterator.getCurrentTokenRow();
        range.end.column = iterator.getCurrentTokenColumn() + token.value.length - 2;
        return range;
      }
    };
    this.foldAll = function (startRow, endRow, depth) {
      if (depth == undefined)
        depth = 100000;
      var foldWidgets = this.foldWidgets;
      if (!foldWidgets)
        return;
      endRow = endRow || this.getLength();
      startRow = startRow || 0;
      for (var row = startRow; row < endRow; row++) {
        if (foldWidgets[row] == null)
          foldWidgets[row] = this.getFoldWidget(row);
        if (foldWidgets[row] != 'start')
          continue;
        var range = this.getFoldWidgetRange(row);
        if (range && range.isMultiLine() && range.end.row <= endRow && range.start.row >= startRow) {
          row = range.end.row;
          try {
            var fold = this.addFold('...', range);
            if (fold)
              fold.collapseChildren = depth;
          } catch (e) {
          }
        }
      }
    };
    this.$foldStyles = {
      'manual': 1,
      'markbegin': 1,
      'markbeginend': 1
    };
    this.$foldStyle = 'markbegin';
    this.setFoldStyle = function (style) {
      if (!this.$foldStyles[style])
        throw new Error('invalid fold style: ' + style + '[' + Object.keys(this.$foldStyles).join(', ') + ']');
      if (this.$foldStyle == style)
        return;
      this.$foldStyle = style;
      if (style == 'manual')
        this.unfold();
      var mode = this.$foldMode;
      this.$setFolding(null);
      this.$setFolding(mode);
    };
    this.$setFolding = function (foldMode) {
      if (this.$foldMode == foldMode)
        return;
      this.$foldMode = foldMode;
      this.removeListener('change', this.$updateFoldWidgets);
      this._emit('changeAnnotation');
      if (!foldMode || this.$foldStyle == 'manual') {
        this.foldWidgets = null;
        return;
      }
      this.foldWidgets = [];
      this.getFoldWidget = foldMode.getFoldWidget.bind(foldMode, this, this.$foldStyle);
      this.getFoldWidgetRange = foldMode.getFoldWidgetRange.bind(foldMode, this, this.$foldStyle);
      this.$updateFoldWidgets = this.updateFoldWidgets.bind(this);
      this.on('change', this.$updateFoldWidgets);
    };
    this.getParentFoldRangeData = function (row, ignoreCurrent) {
      var fw = this.foldWidgets;
      if (!fw || ignoreCurrent && fw[row])
        return {};
      var i = row - 1, firstRange;
      while (i >= 0) {
        var c = fw[i];
        if (c == null)
          c = fw[i] = this.getFoldWidget(i);
        if (c == 'start') {
          var range = this.getFoldWidgetRange(i);
          if (!firstRange)
            firstRange = range;
          if (range && range.end.row >= row)
            break;
        }
        i--;
      }
      return {
        range: i !== -1 && range,
        firstRange: firstRange
      };
    };
    this.onFoldWidgetClick = function (row, e) {
      e = e.domEvent;
      var options = {
          children: e.shiftKey,
          all: e.ctrlKey || e.metaKey,
          siblings: e.altKey
        };
      var range = this.$toggleFoldWidget(row, options);
      if (!range) {
        var el = e.target || e.srcElement;
        if (el && /ace_fold-widget/.test(el.className))
          el.className += ' ace_invalid';
      }
    };
    this.$toggleFoldWidget = function (row, options) {
      if (!this.getFoldWidget)
        return;
      var type = this.getFoldWidget(row);
      var line = this.getLine(row);
      var dir = type === 'end' ? -1 : 1;
      var fold = this.getFoldAt(row, dir === -1 ? 0 : line.length, dir);
      if (fold) {
        if (options.children || options.all)
          this.removeFold(fold);
        else
          this.expandFold(fold);
        return;
      }
      var range = this.getFoldWidgetRange(row, true);
      if (range && !range.isMultiLine()) {
        fold = this.getFoldAt(range.start.row, range.start.column, 1);
        if (fold && range.isEqual(fold.range)) {
          this.removeFold(fold);
          return;
        }
      }
      if (options.siblings) {
        var data = this.getParentFoldRangeData(row);
        if (data.range) {
          var startRow = data.range.start.row + 1;
          var endRow = data.range.end.row;
        }
        this.foldAll(startRow, endRow, options.all ? 10000 : 0);
      } else if (options.children) {
        endRow = range ? range.end.row : this.getLength();
        this.foldAll(row + 1, range.end.row, options.all ? 10000 : 0);
      } else if (range) {
        if (options.all)
          range.collapseChildren = 10000;
        this.addFold('...', range);
      }
      return range;
    };
    this.toggleFoldWidget = function (toggleParent) {
      var row = this.selection.getCursor().row;
      row = this.getRowFoldStart(row);
      var range = this.$toggleFoldWidget(row, {});
      if (range)
        return;
      var data = this.getParentFoldRangeData(row, true);
      range = data.range || data.firstRange;
      if (range) {
        row = range.start.row;
        var fold = this.getFoldAt(row, this.getLine(row).length, 1);
        if (fold) {
          this.removeFold(fold);
        } else {
          this.addFold('...', range);
        }
      }
    };
    this.updateFoldWidgets = function (e) {
      var delta = e.data;
      var range = delta.range;
      var firstRow = range.start.row;
      var len = range.end.row - firstRow;
      if (len === 0) {
        this.foldWidgets[firstRow] = null;
      } else if (delta.action == 'removeText' || delta.action == 'removeLines') {
        this.foldWidgets.splice(firstRow, len + 1, null);
      } else {
        var args = Array(len + 1);
        args.unshift(firstRow, 1);
        this.foldWidgets.splice.apply(this.foldWidgets, args);
      }
    };
  }
  exports.Folding = Folding;
});
ace.define('ace/edit_session/fold_line', [
  'require',
  'exports',
  'module',
  'ace/range'
], function (require, exports, module) {
  var Range = require('../range').Range;
  function FoldLine(foldData, folds) {
    this.foldData = foldData;
    if (Array.isArray(folds)) {
      this.folds = folds;
    } else {
      folds = this.folds = [folds];
    }
    var last = folds[folds.length - 1];
    this.range = new Range(folds[0].start.row, folds[0].start.column, last.end.row, last.end.column);
    this.start = this.range.start;
    this.end = this.range.end;
    this.folds.forEach(function (fold) {
      fold.setFoldLine(this);
    }, this);
  }
  (function () {
    this.shiftRow = function (shift) {
      this.start.row += shift;
      this.end.row += shift;
      this.folds.forEach(function (fold) {
        fold.start.row += shift;
        fold.end.row += shift;
      });
    };
    this.addFold = function (fold) {
      if (fold.sameRow) {
        if (fold.start.row < this.startRow || fold.endRow > this.endRow) {
          throw new Error('Can\'t add a fold to this FoldLine as it has no connection');
        }
        this.folds.push(fold);
        this.folds.sort(function (a, b) {
          return -a.range.compareEnd(b.start.row, b.start.column);
        });
        if (this.range.compareEnd(fold.start.row, fold.start.column) > 0) {
          this.end.row = fold.end.row;
          this.end.column = fold.end.column;
        } else if (this.range.compareStart(fold.end.row, fold.end.column) < 0) {
          this.start.row = fold.start.row;
          this.start.column = fold.start.column;
        }
      } else if (fold.start.row == this.end.row) {
        this.folds.push(fold);
        this.end.row = fold.end.row;
        this.end.column = fold.end.column;
      } else if (fold.end.row == this.start.row) {
        this.folds.unshift(fold);
        this.start.row = fold.start.row;
        this.start.column = fold.start.column;
      } else {
        throw new Error('Trying to add fold to FoldRow that doesn\'t have a matching row');
      }
      fold.foldLine = this;
    };
    this.containsRow = function (row) {
      return row >= this.start.row && row <= this.end.row;
    };
    this.walk = function (callback, endRow, endColumn) {
      var lastEnd = 0, folds = this.folds, fold, comp, stop, isNewRow = true;
      if (endRow == null) {
        endRow = this.end.row;
        endColumn = this.end.column;
      }
      for (var i = 0; i < folds.length; i++) {
        fold = folds[i];
        comp = fold.range.compareStart(endRow, endColumn);
        if (comp == -1) {
          callback(null, endRow, endColumn, lastEnd, isNewRow);
          return;
        }
        stop = callback(null, fold.start.row, fold.start.column, lastEnd, isNewRow);
        stop = !stop && callback(fold.placeholder, fold.start.row, fold.start.column, lastEnd);
        if (stop || comp == 0) {
          return;
        }
        isNewRow = !fold.sameRow;
        lastEnd = fold.end.column;
      }
      callback(null, endRow, endColumn, lastEnd, isNewRow);
    };
    this.getNextFoldTo = function (row, column) {
      var fold, cmp;
      for (var i = 0; i < this.folds.length; i++) {
        fold = this.folds[i];
        cmp = fold.range.compareEnd(row, column);
        if (cmp == -1) {
          return {
            fold: fold,
            kind: 'after'
          };
        } else if (cmp == 0) {
          return {
            fold: fold,
            kind: 'inside'
          };
        }
      }
      return null;
    };
    this.addRemoveChars = function (row, column, len) {
      var ret = this.getNextFoldTo(row, column), fold, folds;
      if (ret) {
        fold = ret.fold;
        if (ret.kind == 'inside' && fold.start.column != column && fold.start.row != row) {
          window.console && window.console.log(row, column, fold);
        } else if (fold.start.row == row) {
          folds = this.folds;
          var i = folds.indexOf(fold);
          if (i == 0) {
            this.start.column += len;
          }
          for (i; i < folds.length; i++) {
            fold = folds[i];
            fold.start.column += len;
            if (!fold.sameRow) {
              return;
            }
            fold.end.column += len;
          }
          this.end.column += len;
        }
      }
    };
    this.split = function (row, column) {
      var fold = this.getNextFoldTo(row, column).fold;
      var folds = this.folds;
      var foldData = this.foldData;
      if (!fold)
        return null;
      var i = folds.indexOf(fold);
      var foldBefore = folds[i - 1];
      this.end.row = foldBefore.end.row;
      this.end.column = foldBefore.end.column;
      folds = folds.splice(i, folds.length - i);
      var newFoldLine = new FoldLine(foldData, folds);
      foldData.splice(foldData.indexOf(this) + 1, 0, newFoldLine);
      return newFoldLine;
    };
    this.merge = function (foldLineNext) {
      var folds = foldLineNext.folds;
      for (var i = 0; i < folds.length; i++) {
        this.addFold(folds[i]);
      }
      var foldData = this.foldData;
      foldData.splice(foldData.indexOf(foldLineNext), 1);
    };
    this.toString = function () {
      var ret = [this.range.toString() + ': ['];
      this.folds.forEach(function (fold) {
        ret.push('  ' + fold.toString());
      });
      ret.push(']');
      return ret.join('\n');
    };
    this.idxToPosition = function (idx) {
      var lastFoldEndColumn = 0;
      var fold;
      for (var i = 0; i < this.folds.length; i++) {
        var fold = this.folds[i];
        idx -= fold.start.column - lastFoldEndColumn;
        if (idx < 0) {
          return {
            row: fold.start.row,
            column: fold.start.column + idx
          };
        }
        idx -= fold.placeholder.length;
        if (idx < 0) {
          return fold.start;
        }
        lastFoldEndColumn = fold.end.column;
      }
      return {
        row: this.end.row,
        column: this.end.column + idx
      };
    };
  }.call(FoldLine.prototype));
  exports.FoldLine = FoldLine;
});
ace.define('ace/tokenizer', [
  'require',
  'exports',
  'module'
], function (require, exports, module) {
  var MAX_TOKEN_COUNT = 1000;
  var Tokenizer = function (rules) {
    this.states = rules;
    this.regExps = {};
    this.matchMappings = {};
    for (var key in this.states) {
      var state = this.states[key];
      var ruleRegExps = [];
      var matchTotal = 0;
      var mapping = this.matchMappings[key] = { defaultToken: 'text' };
      var flag = 'g';
      var splitterRurles = [];
      for (var i = 0; i < state.length; i++) {
        var rule = state[i];
        if (rule.defaultToken)
          mapping.defaultToken = rule.defaultToken;
        if (rule.caseInsensitive)
          flag = 'gi';
        if (rule.regex == null)
          continue;
        if (rule.regex instanceof RegExp)
          rule.regex = rule.regex.toString().slice(1, -1);
        var adjustedregex = rule.regex;
        var matchcount = new RegExp('(?:(' + adjustedregex + ')|(.))').exec('a').length - 2;
        if (Array.isArray(rule.token)) {
          if (rule.token.length == 1 || matchcount == 1) {
            rule.token = rule.token[0];
          } else if (matchcount - 1 != rule.token.length) {
            throw new Error('number of classes and regexp groups in \'' + rule.token + '\'\n\'' + rule.regex + '\' doesn\'t match\n' + (matchcount - 1) + '!=' + rule.token.length);
          } else {
            rule.tokenArray = rule.token;
            rule.token = null;
            rule.onMatch = this.$arrayTokens;
          }
        } else if (typeof rule.token == 'function' && !rule.onMatch) {
          if (matchcount > 1)
            rule.onMatch = this.$applyToken;
          else
            rule.onMatch = rule.token;
        }
        if (matchcount > 1) {
          if (/\\\d/.test(rule.regex)) {
            adjustedregex = rule.regex.replace(/\\([0-9]+)/g, function (match, digit) {
              return '\\' + (parseInt(digit, 10) + matchTotal + 1);
            });
          } else {
            matchcount = 1;
            adjustedregex = this.removeCapturingGroups(rule.regex);
          }
          if (!rule.splitRegex && typeof rule.token != 'string')
            splitterRurles.push(rule);
        }
        mapping[matchTotal] = i;
        matchTotal += matchcount;
        ruleRegExps.push(adjustedregex);
        if (!rule.onMatch)
          rule.onMatch = null;
        rule.__proto__ = null;
      }
      splitterRurles.forEach(function (rule) {
        rule.splitRegex = this.createSplitterRegexp(rule.regex, flag);
      }, this);
      this.regExps[key] = new RegExp('(' + ruleRegExps.join(')|(') + ')|($)', flag);
    }
  };
  (function () {
    this.$setMaxTokenCount = function (m) {
      MAX_TOKEN_COUNT = m | 0;
    };
    this.$applyToken = function (str) {
      var values = this.splitRegex.exec(str).slice(1);
      var types = this.token.apply(this, values);
      if (typeof types === 'string')
        return [{
            type: types,
            value: str
          }];
      var tokens = [];
      for (var i = 0, l = types.length; i < l; i++) {
        if (values[i])
          tokens[tokens.length] = {
            type: types[i],
            value: values[i]
          };
      }
      return tokens;
    }, this.$arrayTokens = function (str) {
      if (!str)
        return [];
      var values = this.splitRegex.exec(str);
      if (!values)
        return 'text';
      var tokens = [];
      var types = this.tokenArray;
      for (var i = 0, l = types.length; i < l; i++) {
        if (values[i + 1])
          tokens[tokens.length] = {
            type: types[i],
            value: values[i + 1]
          };
      }
      return tokens;
    };
    this.removeCapturingGroups = function (src) {
      var r = src.replace(/\[(?:\\.|[^\]])*?\]|\\.|\(\?[:=!]|(\()/g, function (x, y) {
          return y ? '(?:' : x;
        });
      return r;
    };
    this.createSplitterRegexp = function (src, flag) {
      if (src.indexOf('(?=') != -1) {
        var stack = 0;
        var inChClass = false;
        var lastCapture = {};
        src.replace(/(\\.)|(\((?:\?[=!])?)|(\))|([\[\]])/g, function (m, esc, parenOpen, parenClose, square, index) {
          if (inChClass) {
            inChClass = square != ']';
          } else if (square) {
            inChClass = true;
          } else if (parenClose) {
            if (stack == lastCapture.stack) {
              lastCapture.end = index + 1;
              lastCapture.stack = -1;
            }
            stack--;
          } else if (parenOpen) {
            stack++;
            if (parenOpen.length != 1) {
              lastCapture.stack = stack;
              lastCapture.start = index;
            }
          }
          return m;
        });
        if (lastCapture.end != null && /^\)*$/.test(src.substr(lastCapture.end)))
          src = src.substring(0, lastCapture.start) + src.substr(lastCapture.end);
      }
      return new RegExp(src, (flag || '').replace('g', ''));
    };
    this.getLineTokens = function (line, startState) {
      if (startState && typeof startState != 'string') {
        var stack = startState.slice(0);
        startState = stack[0];
      } else
        var stack = [];
      var currentState = startState || 'start';
      var state = this.states[currentState];
      if (!state) {
        currentState = 'start';
        state = this.states[currentState];
      }
      var mapping = this.matchMappings[currentState];
      var re = this.regExps[currentState];
      re.lastIndex = 0;
      var match, tokens = [];
      var lastIndex = 0;
      var token = {
          type: null,
          value: ''
        };
      while (match = re.exec(line)) {
        var type = mapping.defaultToken;
        var rule = null;
        var value = match[0];
        var index = re.lastIndex;
        if (index - value.length > lastIndex) {
          var skipped = line.substring(lastIndex, index - value.length);
          if (token.type == type) {
            token.value += skipped;
          } else {
            if (token.type)
              tokens.push(token);
            token = {
              type: type,
              value: skipped
            };
          }
        }
        for (var i = 0; i < match.length - 2; i++) {
          if (match[i + 1] === undefined)
            continue;
          rule = state[mapping[i]];
          if (rule.onMatch)
            type = rule.onMatch(value, currentState, stack);
          else
            type = rule.token;
          if (rule.next) {
            if (typeof rule.next == 'string')
              currentState = rule.next;
            else
              currentState = rule.next(currentState, stack);
            state = this.states[currentState];
            if (!state) {
              window.console && console.error && console.error(currentState, 'doesn\'t exist');
              currentState = 'start';
              state = this.states[currentState];
            }
            mapping = this.matchMappings[currentState];
            lastIndex = index;
            re = this.regExps[currentState];
            re.lastIndex = index;
          }
          break;
        }
        if (value) {
          if (typeof type == 'string') {
            if ((!rule || rule.merge !== false) && token.type === type) {
              token.value += value;
            } else {
              if (token.type)
                tokens.push(token);
              token = {
                type: type,
                value: value
              };
            }
          } else if (type) {
            if (token.type)
              tokens.push(token);
            token = {
              type: null,
              value: ''
            };
            for (var i = 0; i < type.length; i++)
              tokens.push(type[i]);
          }
        }
        if (lastIndex == line.length)
          break;
        lastIndex = index;
        if (tokens.length > MAX_TOKEN_COUNT) {
          while (lastIndex < line.length) {
            if (token.type)
              tokens.push(token);
            token = {
              value: line.substring(lastIndex, lastIndex += 2000),
              type: 'overflow'
            };
          }
          currentState = 'start';
          stack = [];
          break;
        }
      }
      if (token.type)
        tokens.push(token);
      if (stack.length > 1) {
        if (stack[0] !== currentState)
          stack.unshift(currentState);
      }
      return {
        tokens: tokens,
        state: stack.length ? stack : currentState
      };
    };
  }.call(Tokenizer.prototype));
  exports.Tokenizer = Tokenizer;
});
ace.define('ace/edit_session/fold', [
  'require',
  'exports',
  'module',
  'ace/range',
  'ace/range_list',
  'ace/lib/oop'
], function (require, exports, module) {
  var Range = require('../range').Range;
  var RangeList = require('../range_list').RangeList;
  var oop = require('../lib/oop');
  var Fold = exports.Fold = function (range, placeholder) {
      this.foldLine = null;
      this.placeholder = placeholder;
      this.range = range;
      this.start = range.start;
      this.end = range.end;
      this.sameRow = range.start.row == range.end.row;
      this.subFolds = this.ranges = [];
    };
  oop.inherits(Fold, RangeList);
  (function () {
    this.toString = function () {
      return '"' + this.placeholder + '" ' + this.range.toString();
    };
    this.setFoldLine = function (foldLine) {
      this.foldLine = foldLine;
      this.subFolds.forEach(function (fold) {
        fold.setFoldLine(foldLine);
      });
    };
    this.clone = function () {
      var range = this.range.clone();
      var fold = new Fold(range, this.placeholder);
      this.subFolds.forEach(function (subFold) {
        fold.subFolds.push(subFold.clone());
      });
      fold.collapseChildren = this.collapseChildren;
      return fold;
    };
    this.addSubFold = function (fold) {
      if (this.range.isEqual(fold))
        return;
      if (!this.range.containsRange(fold))
        throw new Error('A fold can\'t intersect already existing fold' + fold.range + this.range);
      consumeRange(fold, this.start);
      var row = fold.start.row, column = fold.start.column;
      for (var i = 0, cmp = -1; i < this.subFolds.length; i++) {
        cmp = this.subFolds[i].range.compare(row, column);
        if (cmp != 1)
          break;
      }
      var afterStart = this.subFolds[i];
      if (cmp == 0)
        return afterStart.addSubFold(fold);
      var row = fold.range.end.row, column = fold.range.end.column;
      for (var j = i, cmp = -1; j < this.subFolds.length; j++) {
        cmp = this.subFolds[j].range.compare(row, column);
        if (cmp != 1)
          break;
      }
      var afterEnd = this.subFolds[j];
      if (cmp == 0)
        throw new Error('A fold can\'t intersect already existing fold' + fold.range + this.range);
      var consumedFolds = this.subFolds.splice(i, j - i, fold);
      fold.setFoldLine(this.foldLine);
      return fold;
    };
    this.restoreRange = function (range) {
      return restoreRange(range, this.start);
    };
  }.call(Fold.prototype));
  function consumePoint(point, anchor) {
    point.row -= anchor.row;
    if (point.row == 0)
      point.column -= anchor.column;
  }
  function consumeRange(range, anchor) {
    consumePoint(range.start, anchor);
    consumePoint(range.end, anchor);
  }
  function restorePoint(point, anchor) {
    if (point.row == 0)
      point.column += anchor.column;
    point.row += anchor.row;
  }
  function restoreRange(range, anchor) {
    restorePoint(range.start, anchor);
    restorePoint(range.end, anchor);
  }
});
ace.define('ace/mode/text', [
  'require',
  'exports',
  'module',
  'ace/tokenizer',
  'ace/mode/text_highlight_rules',
  'ace/mode/behaviour',
  'ace/unicode',
  'ace/lib/lang',
  'ace/token_iterator',
  'ace/range'
], function (require, exports, module) {
  var Tokenizer = require('../tokenizer').Tokenizer;
  var TextHighlightRules = require('./text_highlight_rules').TextHighlightRules;
  var Behaviour = require('./behaviour').Behaviour;
  var unicode = require('../unicode');
  var lang = require('../lib/lang');
  var TokenIterator = require('../token_iterator').TokenIterator;
  var Range = require('../range').Range;
  var Mode = function () {
    this.HighlightRules = TextHighlightRules;
    this.$behaviour = new Behaviour();
  };
  (function () {
    this.tokenRe = new RegExp('^[' + unicode.packages.L + unicode.packages.Mn + unicode.packages.Mc + unicode.packages.Nd + unicode.packages.Pc + '\\$_]+', 'g');
    this.nonTokenRe = new RegExp('^(?:[^' + unicode.packages.L + unicode.packages.Mn + unicode.packages.Mc + unicode.packages.Nd + unicode.packages.Pc + '\\$_]|\\s])+', 'g');
    this.getTokenizer = function () {
      if (!this.$tokenizer) {
        this.$highlightRules = new this.HighlightRules();
        this.$tokenizer = new Tokenizer(this.$highlightRules.getRules());
      }
      return this.$tokenizer;
    };
    this.lineCommentStart = '';
    this.blockComment = '';
    this.toggleCommentLines = function (state, session, startRow, endRow) {
      var doc = session.doc;
      var ignoreBlankLines = true;
      var shouldRemove = true;
      var minIndent = Infinity;
      var tabSize = session.getTabSize();
      var insertAtTabStop = false;
      if (!this.lineCommentStart) {
        if (!this.blockComment)
          return false;
        var lineCommentStart = this.blockComment.start;
        var lineCommentEnd = this.blockComment.end;
        var regexpStart = new RegExp('^(\\s*)(?:' + lang.escapeRegExp(lineCommentStart) + ')');
        var regexpEnd = new RegExp('(?:' + lang.escapeRegExp(lineCommentEnd) + ')\\s*$');
        var comment = function (line, i) {
          if (testRemove(line, i))
            return;
          if (!ignoreBlankLines || /\S/.test(line)) {
            doc.insertInLine({
              row: i,
              column: line.length
            }, lineCommentEnd);
            doc.insertInLine({
              row: i,
              column: minIndent
            }, lineCommentStart);
          }
        };
        var uncomment = function (line, i) {
          var m;
          if (m = line.match(regexpEnd))
            doc.removeInLine(i, line.length - m[0].length, line.length);
          if (m = line.match(regexpStart))
            doc.removeInLine(i, m[1].length, m[0].length);
        };
        var testRemove = function (line, row) {
          if (regexpStart.test(line))
            return true;
          var tokens = session.getTokens(row);
          for (var i = 0; i < tokens.length; i++) {
            if (tokens[i].type === 'comment')
              return true;
          }
        };
      } else {
        if (Array.isArray(this.lineCommentStart)) {
          var regexpStart = this.lineCommentStart.map(lang.escapeRegExp).join('|');
          var lineCommentStart = this.lineCommentStart[0];
        } else {
          var regexpStart = lang.escapeRegExp(this.lineCommentStart);
          var lineCommentStart = this.lineCommentStart;
        }
        regexpStart = new RegExp('^(\\s*)(?:' + regexpStart + ') ?');
        insertAtTabStop = session.getUseSoftTabs();
        var uncomment = function (line, i) {
          var m = line.match(regexpStart);
          if (!m)
            return;
          var start = m[1].length, end = m[0].length;
          if (!shouldInsertSpace(line, start, end) && m[0][end - 1] == ' ')
            end--;
          doc.removeInLine(i, start, end);
        };
        var commentWithSpace = lineCommentStart + ' ';
        var comment = function (line, i) {
          if (!ignoreBlankLines || /\S/.test(line)) {
            if (shouldInsertSpace(line, minIndent, minIndent))
              doc.insertInLine({
                row: i,
                column: minIndent
              }, commentWithSpace);
            else
              doc.insertInLine({
                row: i,
                column: minIndent
              }, lineCommentStart);
          }
        };
        var testRemove = function (line, i) {
          return regexpStart.test(line);
        };
        var shouldInsertSpace = function (line, before, after) {
          var spaces = 0;
          while (before-- && line.charAt(before) == ' ')
            spaces++;
          if (spaces % tabSize != 0)
            return false;
          var spaces = 0;
          while (line.charAt(after++) == ' ')
            spaces++;
          if (tabSize > 2)
            return spaces % tabSize != tabSize - 1;
          else
            return spaces % tabSize == 0;
          return true;
        };
      }
      function iter(fun) {
        for (var i = startRow; i <= endRow; i++)
          fun(doc.getLine(i), i);
      }
      var minEmptyLength = Infinity;
      iter(function (line, i) {
        var indent = line.search(/\S/);
        if (indent !== -1) {
          if (indent < minIndent)
            minIndent = indent;
          if (shouldRemove && !testRemove(line, i))
            shouldRemove = false;
        } else if (minEmptyLength > line.length) {
          minEmptyLength = line.length;
        }
      });
      if (minIndent == Infinity) {
        minIndent = minEmptyLength;
        ignoreBlankLines = false;
        shouldRemove = false;
      }
      if (insertAtTabStop && minIndent % tabSize != 0)
        minIndent = Math.floor(minIndent / tabSize) * tabSize;
      iter(shouldRemove ? uncomment : comment);
    };
    this.toggleBlockComment = function (state, session, range, cursor) {
      var comment = this.blockComment;
      if (!comment)
        return;
      if (!comment.start && comment[0])
        comment = comment[0];
      var iterator = new TokenIterator(session, cursor.row, cursor.column);
      var token = iterator.getCurrentToken();
      var sel = session.selection;
      var initialRange = session.selection.toOrientedRange();
      var startRow, colDiff;
      if (token && /comment/.test(token.type)) {
        var startRange, endRange;
        while (token && /comment/.test(token.type)) {
          var i = token.value.indexOf(comment.start);
          if (i != -1) {
            var row = iterator.getCurrentTokenRow();
            var column = iterator.getCurrentTokenColumn() + i;
            startRange = new Range(row, column, row, column + comment.start.length);
            break;
          }
          token = iterator.stepBackward();
        }
        var iterator = new TokenIterator(session, cursor.row, cursor.column);
        var token = iterator.getCurrentToken();
        while (token && /comment/.test(token.type)) {
          var i = token.value.indexOf(comment.end);
          if (i != -1) {
            var row = iterator.getCurrentTokenRow();
            var column = iterator.getCurrentTokenColumn() + i;
            endRange = new Range(row, column, row, column + comment.end.length);
            break;
          }
          token = iterator.stepForward();
        }
        if (endRange)
          session.remove(endRange);
        if (startRange) {
          session.remove(startRange);
          startRow = startRange.start.row;
          colDiff = -comment.start.length;
        }
      } else {
        colDiff = comment.start.length;
        startRow = range.start.row;
        session.insert(range.end, comment.end);
        session.insert(range.start, comment.start);
      }
      if (initialRange.start.row == startRow)
        initialRange.start.column += colDiff;
      if (initialRange.end.row == startRow)
        initialRange.end.column += colDiff;
      session.selection.fromOrientedRange(initialRange);
    };
    this.getNextLineIndent = function (state, line, tab) {
      return this.$getIndent(line);
    };
    this.checkOutdent = function (state, line, input) {
      return false;
    };
    this.autoOutdent = function (state, doc, row) {
    };
    this.$getIndent = function (line) {
      return line.match(/^\s*/)[0];
    };
    this.createWorker = function (session) {
      return null;
    };
    this.createModeDelegates = function (mapping) {
      this.$embeds = [];
      this.$modes = {};
      for (var i in mapping) {
        if (mapping[i]) {
          this.$embeds.push(i);
          this.$modes[i] = new mapping[i]();
        }
      }
      var delegations = [
          'toggleBlockComment',
          'toggleCommentLines',
          'getNextLineIndent',
          'checkOutdent',
          'autoOutdent',
          'transformAction',
          'getCompletions'
        ];
      for (var i = 0; i < delegations.length; i++) {
        (function (scope) {
          var functionName = delegations[i];
          var defaultHandler = scope[functionName];
          scope[delegations[i]] = function () {
            return this.$delegator(functionName, arguments, defaultHandler);
          };
        }(this));
      }
    };
    this.$delegator = function (method, args, defaultHandler) {
      var state = args[0];
      if (typeof state != 'string')
        state = state[0];
      for (var i = 0; i < this.$embeds.length; i++) {
        if (!this.$modes[this.$embeds[i]])
          continue;
        var split = state.split(this.$embeds[i]);
        if (!split[0] && split[1]) {
          args[0] = split[1];
          var mode = this.$modes[this.$embeds[i]];
          return mode[method].apply(mode, args);
        }
      }
      var ret = defaultHandler.apply(this, args);
      return defaultHandler ? ret : undefined;
    };
    this.transformAction = function (state, action, editor, session, param) {
      if (this.$behaviour) {
        var behaviours = this.$behaviour.getBehaviours();
        for (var key in behaviours) {
          if (behaviours[key][action]) {
            var ret = behaviours[key][action].apply(this, arguments);
            if (ret) {
              return ret;
            }
          }
        }
      }
    };
    this.getKeywords = function (append) {
      if (!this.completionKeywords) {
        var rules = this.$tokenizer.rules;
        var completionKeywords = [];
        for (var rule in rules) {
          var ruleItr = rules[rule];
          for (var r = 0, l = ruleItr.length; r < l; r++) {
            if (typeof ruleItr[r].token === 'string') {
              if (/keyword|support|storage/.test(ruleItr[r].token))
                completionKeywords.push(ruleItr[r].regex);
            } else if (typeof ruleItr[r].token === 'object') {
              for (var a = 0, aLength = ruleItr[r].token.length; a < aLength; a++) {
                if (/keyword|support|storage/.test(ruleItr[r].token[a])) {
                  var rule = ruleItr[r].regex.match(/\(.+?\)/g)[a];
                  completionKeywords.push(rule.substr(1, rule.length - 2));
                }
              }
            }
          }
        }
        this.completionKeywords = completionKeywords;
      }
      if (!append)
        return this.$keywordList;
      return completionKeywords.concat(this.$keywordList || []);
    };
    this.$createKeywordList = function () {
      if (!this.$highlightRules)
        this.getTokenizer();
      return this.$keywordList = this.$highlightRules.$keywordList || [];
    };
    this.getCompletions = function (state, session, pos, prefix) {
      var keywords = this.$keywordList || this.$createKeywordList();
      return keywords.map(function (word) {
        return {
          name: word,
          value: word,
          score: 0,
          meta: 'keyword'
        };
      });
    };
    this.$id = 'ace/mode/text';
  }.call(Mode.prototype));
  exports.Mode = Mode;
});
ace.define('ace/range_list', [
  'require',
  'exports',
  'module',
  'ace/range'
], function (require, exports, module) {
  var Range = require('./range').Range;
  var comparePoints = Range.comparePoints;
  var RangeList = function () {
    this.ranges = [];
  };
  (function () {
    this.comparePoints = comparePoints;
    this.pointIndex = function (pos, excludeEdges, startIndex) {
      var list = this.ranges;
      for (var i = startIndex || 0; i < list.length; i++) {
        var range = list[i];
        var cmpEnd = comparePoints(pos, range.end);
        if (cmpEnd > 0)
          continue;
        var cmpStart = comparePoints(pos, range.start);
        if (cmpEnd === 0)
          return excludeEdges && cmpStart !== 0 ? -i - 2 : i;
        if (cmpStart > 0 || cmpStart === 0 && !excludeEdges)
          return i;
        return -i - 1;
      }
      return -i - 1;
    };
    this.add = function (range) {
      var excludeEdges = !range.isEmpty();
      var startIndex = this.pointIndex(range.start, excludeEdges);
      if (startIndex < 0)
        startIndex = -startIndex - 1;
      var endIndex = this.pointIndex(range.end, excludeEdges, startIndex);
      if (endIndex < 0)
        endIndex = -endIndex - 1;
      else
        endIndex++;
      return this.ranges.splice(startIndex, endIndex - startIndex, range);
    };
    this.addList = function (list) {
      var removed = [];
      for (var i = list.length; i--;) {
        removed.push.call(removed, this.add(list[i]));
      }
      return removed;
    };
    this.substractPoint = function (pos) {
      var i = this.pointIndex(pos);
      if (i >= 0)
        return this.ranges.splice(i, 1);
    };
    this.merge = function () {
      var removed = [];
      var list = this.ranges;
      list = list.sort(function (a, b) {
        return comparePoints(a.start, b.start);
      });
      var next = list[0], range;
      for (var i = 1; i < list.length; i++) {
        range = next;
        next = list[i];
        var cmp = comparePoints(range.end, next.start);
        if (cmp < 0)
          continue;
        if (cmp == 0 && !range.isEmpty() && !next.isEmpty())
          continue;
        if (comparePoints(range.end, next.end) < 0) {
          range.end.row = next.end.row;
          range.end.column = next.end.column;
        }
        list.splice(i, 1);
        removed.push(next);
        next = range;
        i--;
      }
      this.ranges = list;
      return removed;
    };
    this.contains = function (row, column) {
      return this.pointIndex({
        row: row,
        column: column
      }) >= 0;
    };
    this.containsPoint = function (pos) {
      return this.pointIndex(pos) >= 0;
    };
    this.rangeAtPoint = function (pos) {
      var i = this.pointIndex(pos);
      if (i >= 0)
        return this.ranges[i];
    };
    this.clipRows = function (startRow, endRow) {
      var list = this.ranges;
      if (list[0].start.row > endRow || list[list.length - 1].start.row < startRow)
        return [];
      var startIndex = this.pointIndex({
          row: startRow,
          column: 0
        });
      if (startIndex < 0)
        startIndex = -startIndex - 1;
      var endIndex = this.pointIndex({
          row: endRow,
          column: 0
        }, startIndex);
      if (endIndex < 0)
        endIndex = -endIndex - 1;
      var clipped = [];
      for (var i = startIndex; i < endIndex; i++) {
        clipped.push(list[i]);
      }
      return clipped;
    };
    this.removeAll = function () {
      return this.ranges.splice(0, this.ranges.length);
    };
    this.attach = function (session) {
      if (this.session)
        this.detach();
      this.session = session;
      this.onChange = this.$onChange.bind(this);
      this.session.on('change', this.onChange);
    };
    this.detach = function () {
      if (!this.session)
        return;
      this.session.removeListener('change', this.onChange);
      this.session = null;
    };
    this.$onChange = function (e) {
      var changeRange = e.data.range;
      if (e.data.action[0] == 'i') {
        var start = changeRange.start;
        var end = changeRange.end;
      } else {
        var end = changeRange.start;
        var start = changeRange.end;
      }
      var startRow = start.row;
      var endRow = end.row;
      var lineDif = endRow - startRow;
      var colDiff = -start.column + end.column;
      var ranges = this.ranges;
      for (var i = 0, n = ranges.length; i < n; i++) {
        var r = ranges[i];
        if (r.end.row < startRow)
          continue;
        if (r.start.row > startRow)
          break;
        if (r.start.row == startRow && r.start.column >= start.column) {
          if (r.start.column == start.column && this.$insertRight) {
          } else {
            r.start.column += colDiff;
            r.start.row += lineDif;
          }
        }
        if (r.end.row == startRow && r.end.column >= start.column) {
          if (r.end.column == start.column && this.$insertRight) {
            continue;
          }
          if (r.end.column == start.column && colDiff > 0 && i < n - 1) {
            if (r.end.column > r.start.column && r.end.column == ranges[i + 1].start.column)
              r.end.column -= colDiff;
          }
          r.end.column += colDiff;
          r.end.row += lineDif;
        }
      }
      if (lineDif != 0 && i < n) {
        for (; i < n; i++) {
          var r = ranges[i];
          r.start.row += lineDif;
          r.end.row += lineDif;
        }
      }
    };
  }.call(RangeList.prototype));
  exports.RangeList = RangeList;
});
ace.define('ace/range', [
  'require',
  'exports',
  'module'
], function (require, exports, module) {
  var comparePoints = function (p1, p2) {
    return p1.row - p2.row || p1.column - p2.column;
  };
  var Range = function (startRow, startColumn, endRow, endColumn) {
    this.start = {
      row: startRow,
      column: startColumn
    };
    this.end = {
      row: endRow,
      column: endColumn
    };
  };
  (function () {
    this.isEqual = function (range) {
      return this.start.row === range.start.row && this.end.row === range.end.row && this.start.column === range.start.column && this.end.column === range.end.column;
    };
    this.toString = function () {
      return 'Range: [' + this.start.row + '/' + this.start.column + '] -> [' + this.end.row + '/' + this.end.column + ']';
    };
    this.contains = function (row, column) {
      return this.compare(row, column) == 0;
    };
    this.compareRange = function (range) {
      var cmp, end = range.end, start = range.start;
      cmp = this.compare(end.row, end.column);
      if (cmp == 1) {
        cmp = this.compare(start.row, start.column);
        if (cmp == 1) {
          return 2;
        } else if (cmp == 0) {
          return 1;
        } else {
          return 0;
        }
      } else if (cmp == -1) {
        return -2;
      } else {
        cmp = this.compare(start.row, start.column);
        if (cmp == -1) {
          return -1;
        } else if (cmp == 1) {
          return 42;
        } else {
          return 0;
        }
      }
    };
    this.comparePoint = function (p) {
      return this.compare(p.row, p.column);
    };
    this.containsRange = function (range) {
      return this.comparePoint(range.start) == 0 && this.comparePoint(range.end) == 0;
    };
    this.intersects = function (range) {
      var cmp = this.compareRange(range);
      return cmp == -1 || cmp == 0 || cmp == 1;
    };
    this.isEnd = function (row, column) {
      return this.end.row == row && this.end.column == column;
    };
    this.isStart = function (row, column) {
      return this.start.row == row && this.start.column == column;
    };
    this.setStart = function (row, column) {
      if (typeof row == 'object') {
        this.start.column = row.column;
        this.start.row = row.row;
      } else {
        this.start.row = row;
        this.start.column = column;
      }
    };
    this.setEnd = function (row, column) {
      if (typeof row == 'object') {
        this.end.column = row.column;
        this.end.row = row.row;
      } else {
        this.end.row = row;
        this.end.column = column;
      }
    };
    this.inside = function (row, column) {
      if (this.compare(row, column) == 0) {
        if (this.isEnd(row, column) || this.isStart(row, column)) {
          return false;
        } else {
          return true;
        }
      }
      return false;
    };
    this.insideStart = function (row, column) {
      if (this.compare(row, column) == 0) {
        if (this.isEnd(row, column)) {
          return false;
        } else {
          return true;
        }
      }
      return false;
    };
    this.insideEnd = function (row, column) {
      if (this.compare(row, column) == 0) {
        if (this.isStart(row, column)) {
          return false;
        } else {
          return true;
        }
      }
      return false;
    };
    this.compare = function (row, column) {
      if (!this.isMultiLine()) {
        if (row === this.start.row) {
          return column < this.start.column ? -1 : column > this.end.column ? 1 : 0;
        }
        ;
      }
      if (row < this.start.row)
        return -1;
      if (row > this.end.row)
        return 1;
      if (this.start.row === row)
        return column >= this.start.column ? 0 : -1;
      if (this.end.row === row)
        return column <= this.end.column ? 0 : 1;
      return 0;
    };
    this.compareStart = function (row, column) {
      if (this.start.row == row && this.start.column == column) {
        return -1;
      } else {
        return this.compare(row, column);
      }
    };
    this.compareEnd = function (row, column) {
      if (this.end.row == row && this.end.column == column) {
        return 1;
      } else {
        return this.compare(row, column);
      }
    };
    this.compareInside = function (row, column) {
      if (this.end.row == row && this.end.column == column) {
        return 1;
      } else if (this.start.row == row && this.start.column == column) {
        return -1;
      } else {
        return this.compare(row, column);
      }
    };
    this.clipRows = function (firstRow, lastRow) {
      if (this.end.row > lastRow)
        var end = {
            row: lastRow + 1,
            column: 0
          };
      else if (this.end.row < firstRow)
        var end = {
            row: firstRow,
            column: 0
          };
      if (this.start.row > lastRow)
        var start = {
            row: lastRow + 1,
            column: 0
          };
      else if (this.start.row < firstRow)
        var start = {
            row: firstRow,
            column: 0
          };
      return Range.fromPoints(start || this.start, end || this.end);
    };
    this.extend = function (row, column) {
      var cmp = this.compare(row, column);
      if (cmp == 0)
        return this;
      else if (cmp == -1)
        var start = {
            row: row,
            column: column
          };
      else
        var end = {
            row: row,
            column: column
          };
      return Range.fromPoints(start || this.start, end || this.end);
    };
    this.isEmpty = function () {
      return this.start.row === this.end.row && this.start.column === this.end.column;
    };
    this.isMultiLine = function () {
      return this.start.row !== this.end.row;
    };
    this.clone = function () {
      return Range.fromPoints(this.start, this.end);
    };
    this.collapseRows = function () {
      if (this.end.column == 0)
        return new Range(this.start.row, 0, Math.max(this.start.row, this.end.row - 1), 0);
      else
        return new Range(this.start.row, 0, this.end.row, 0);
    };
    this.toScreenRange = function (session) {
      var screenPosStart = session.documentToScreenPosition(this.start);
      var screenPosEnd = session.documentToScreenPosition(this.end);
      return new Range(screenPosStart.row, screenPosStart.column, screenPosEnd.row, screenPosEnd.column);
    };
    this.moveBy = function (row, column) {
      this.start.row += row;
      this.start.column += column;
      this.end.row += row;
      this.end.column += column;
    };
  }.call(Range.prototype));
  Range.fromPoints = function (start, end) {
    return new Range(start.row, start.column, end.row, end.column);
  };
  Range.comparePoints = comparePoints;
  Range.comparePoints = function (p1, p2) {
    return p1.row - p2.row || p1.column - p2.column;
  };
  exports.Range = Range;
});
ace.define('ace/edit_session/bracket_match', [
  'require',
  'exports',
  'module',
  'ace/token_iterator',
  'ace/range'
], function (require, exports, module) {
  var TokenIterator = require('../token_iterator').TokenIterator;
  var Range = require('../range').Range;
  function BracketMatch() {
    this.findMatchingBracket = function (position, chr) {
      if (position.column == 0)
        return null;
      var charBeforeCursor = chr || this.getLine(position.row).charAt(position.column - 1);
      if (charBeforeCursor == '')
        return null;
      var match = charBeforeCursor.match(/([\(\[\{])|([\)\]\}])/);
      if (!match)
        return null;
      if (match[1])
        return this.$findClosingBracket(match[1], position);
      else
        return this.$findOpeningBracket(match[2], position);
    };
    this.getBracketRange = function (pos) {
      var line = this.getLine(pos.row);
      var before = true, range;
      var chr = line.charAt(pos.column - 1);
      var match = chr && chr.match(/([\(\[\{])|([\)\]\}])/);
      if (!match) {
        chr = line.charAt(pos.column);
        pos = {
          row: pos.row,
          column: pos.column + 1
        };
        match = chr && chr.match(/([\(\[\{])|([\)\]\}])/);
        before = false;
      }
      if (!match)
        return null;
      if (match[1]) {
        var bracketPos = this.$findClosingBracket(match[1], pos);
        if (!bracketPos)
          return null;
        range = Range.fromPoints(pos, bracketPos);
        if (!before) {
          range.end.column++;
          range.start.column--;
        }
        range.cursor = range.end;
      } else {
        var bracketPos = this.$findOpeningBracket(match[2], pos);
        if (!bracketPos)
          return null;
        range = Range.fromPoints(bracketPos, pos);
        if (!before) {
          range.start.column++;
          range.end.column--;
        }
        range.cursor = range.start;
      }
      return range;
    };
    this.$brackets = {
      ')': '(',
      '(': ')',
      ']': '[',
      '[': ']',
      '{': '}',
      '}': '{'
    };
    this.$findOpeningBracket = function (bracket, position, typeRe) {
      var openBracket = this.$brackets[bracket];
      var depth = 1;
      var iterator = new TokenIterator(this, position.row, position.column);
      var token = iterator.getCurrentToken();
      if (!token)
        token = iterator.stepForward();
      if (!token)
        return;
      if (!typeRe) {
        typeRe = new RegExp('(\\.?' + token.type.replace('.', '\\.').replace('rparen', '.paren') + ')+');
      }
      var valueIndex = position.column - iterator.getCurrentTokenColumn() - 2;
      var value = token.value;
      while (true) {
        while (valueIndex >= 0) {
          var chr = value.charAt(valueIndex);
          if (chr == openBracket) {
            depth -= 1;
            if (depth == 0) {
              return {
                row: iterator.getCurrentTokenRow(),
                column: valueIndex + iterator.getCurrentTokenColumn()
              };
            }
          } else if (chr == bracket) {
            depth += 1;
          }
          valueIndex -= 1;
        }
        do {
          token = iterator.stepBackward();
        } while (token && !typeRe.test(token.type));
        if (token == null)
          break;
        value = token.value;
        valueIndex = value.length - 1;
      }
      return null;
    };
    this.$findClosingBracket = function (bracket, position, typeRe) {
      var closingBracket = this.$brackets[bracket];
      var depth = 1;
      var iterator = new TokenIterator(this, position.row, position.column);
      var token = iterator.getCurrentToken();
      if (!token)
        token = iterator.stepForward();
      if (!token)
        return;
      if (!typeRe) {
        typeRe = new RegExp('(\\.?' + token.type.replace('.', '\\.').replace('lparen', '.paren') + ')+');
      }
      var valueIndex = position.column - iterator.getCurrentTokenColumn();
      while (true) {
        var value = token.value;
        var valueLength = value.length;
        while (valueIndex < valueLength) {
          var chr = value.charAt(valueIndex);
          if (chr == closingBracket) {
            depth -= 1;
            if (depth == 0) {
              return {
                row: iterator.getCurrentTokenRow(),
                column: valueIndex + iterator.getCurrentTokenColumn()
              };
            }
          } else if (chr == bracket) {
            depth += 1;
          }
          valueIndex += 1;
        }
        do {
          token = iterator.stepForward();
        } while (token && !typeRe.test(token.type));
        if (token == null)
          break;
        valueIndex = 0;
      }
      return null;
    };
  }
  exports.BracketMatch = BracketMatch;
});
ace.define('ace/selection', [
  'require',
  'exports',
  'module',
  'ace/lib/oop',
  'ace/lib/lang',
  'ace/lib/event_emitter',
  'ace/range'
], function (require, exports, module) {
  var oop = require('./lib/oop');
  var lang = require('./lib/lang');
  var EventEmitter = require('./lib/event_emitter').EventEmitter;
  var Range = require('./range').Range;
  var Selection = function (session) {
    this.session = session;
    this.doc = session.getDocument();
    this.clearSelection();
    this.lead = this.selectionLead = this.doc.createAnchor(0, 0);
    this.anchor = this.selectionAnchor = this.doc.createAnchor(0, 0);
    var self = this;
    this.lead.on('change', function (e) {
      self._emit('changeCursor');
      if (!self.$isEmpty)
        self._emit('changeSelection');
      if (!self.$keepDesiredColumnOnChange && e.old.column != e.value.column)
        self.$desiredColumn = null;
    });
    this.selectionAnchor.on('change', function () {
      if (!self.$isEmpty)
        self._emit('changeSelection');
    });
  };
  (function () {
    oop.implement(this, EventEmitter);
    this.isEmpty = function () {
      return this.$isEmpty || this.anchor.row == this.lead.row && this.anchor.column == this.lead.column;
    };
    this.isMultiLine = function () {
      if (this.isEmpty()) {
        return false;
      }
      return this.getRange().isMultiLine();
    };
    this.getCursor = function () {
      return this.lead.getPosition();
    };
    this.setSelectionAnchor = function (row, column) {
      this.anchor.setPosition(row, column);
      if (this.$isEmpty) {
        this.$isEmpty = false;
        this._emit('changeSelection');
      }
    };
    this.getSelectionAnchor = function () {
      if (this.$isEmpty)
        return this.getSelectionLead();
      else
        return this.anchor.getPosition();
    };
    this.getSelectionLead = function () {
      return this.lead.getPosition();
    };
    this.shiftSelection = function (columns) {
      if (this.$isEmpty) {
        this.moveCursorTo(this.lead.row, this.lead.column + columns);
        return;
      }
      ;
      var anchor = this.getSelectionAnchor();
      var lead = this.getSelectionLead();
      var isBackwards = this.isBackwards();
      if (!isBackwards || anchor.column !== 0)
        this.setSelectionAnchor(anchor.row, anchor.column + columns);
      if (isBackwards || lead.column !== 0) {
        this.$moveSelection(function () {
          this.moveCursorTo(lead.row, lead.column + columns);
        });
      }
    };
    this.isBackwards = function () {
      var anchor = this.anchor;
      var lead = this.lead;
      return anchor.row > lead.row || anchor.row == lead.row && anchor.column > lead.column;
    };
    this.getRange = function () {
      var anchor = this.anchor;
      var lead = this.lead;
      if (this.isEmpty())
        return Range.fromPoints(lead, lead);
      if (this.isBackwards()) {
        return Range.fromPoints(lead, anchor);
      } else {
        return Range.fromPoints(anchor, lead);
      }
    };
    this.clearSelection = function () {
      if (!this.$isEmpty) {
        this.$isEmpty = true;
        this._emit('changeSelection');
      }
    };
    this.selectAll = function () {
      var lastRow = this.doc.getLength() - 1;
      this.setSelectionAnchor(0, 0);
      this.moveCursorTo(lastRow, this.doc.getLine(lastRow).length);
    };
    this.setRange = this.setSelectionRange = function (range, reverse) {
      if (reverse) {
        this.setSelectionAnchor(range.end.row, range.end.column);
        this.selectTo(range.start.row, range.start.column);
      } else {
        this.setSelectionAnchor(range.start.row, range.start.column);
        this.selectTo(range.end.row, range.end.column);
      }
      if (this.getRange().isEmpty())
        this.$isEmpty = true;
      this.$desiredColumn = null;
    };
    this.$moveSelection = function (mover) {
      var lead = this.lead;
      if (this.$isEmpty)
        this.setSelectionAnchor(lead.row, lead.column);
      mover.call(this);
    };
    this.selectTo = function (row, column) {
      this.$moveSelection(function () {
        this.moveCursorTo(row, column);
      });
    };
    this.selectToPosition = function (pos) {
      this.$moveSelection(function () {
        this.moveCursorToPosition(pos);
      });
    };
    this.moveTo = function (row, column) {
      this.clearSelection();
      this.moveCursorTo(row, column);
    };
    this.moveToPosition = function (pos) {
      this.clearSelection();
      this.moveCursorToPosition(pos);
    };
    this.selectUp = function () {
      this.$moveSelection(this.moveCursorUp);
    };
    this.selectDown = function () {
      this.$moveSelection(this.moveCursorDown);
    };
    this.selectRight = function () {
      this.$moveSelection(this.moveCursorRight);
    };
    this.selectLeft = function () {
      this.$moveSelection(this.moveCursorLeft);
    };
    this.selectLineStart = function () {
      this.$moveSelection(this.moveCursorLineStart);
    };
    this.selectLineEnd = function () {
      this.$moveSelection(this.moveCursorLineEnd);
    };
    this.selectFileEnd = function () {
      this.$moveSelection(this.moveCursorFileEnd);
    };
    this.selectFileStart = function () {
      this.$moveSelection(this.moveCursorFileStart);
    };
    this.selectWordRight = function () {
      this.$moveSelection(this.moveCursorWordRight);
    };
    this.selectWordLeft = function () {
      this.$moveSelection(this.moveCursorWordLeft);
    };
    this.getWordRange = function (row, column) {
      if (typeof column == 'undefined') {
        var cursor = row || this.lead;
        row = cursor.row;
        column = cursor.column;
      }
      return this.session.getWordRange(row, column);
    };
    this.selectWord = function () {
      this.setSelectionRange(this.getWordRange());
    };
    this.selectAWord = function () {
      var cursor = this.getCursor();
      var range = this.session.getAWordRange(cursor.row, cursor.column);
      this.setSelectionRange(range);
    };
    this.getLineRange = function (row, excludeLastChar) {
      var rowStart = typeof row == 'number' ? row : this.lead.row;
      var rowEnd;
      var foldLine = this.session.getFoldLine(rowStart);
      if (foldLine) {
        rowStart = foldLine.start.row;
        rowEnd = foldLine.end.row;
      } else {
        rowEnd = rowStart;
      }
      if (excludeLastChar === true)
        return new Range(rowStart, 0, rowEnd, this.session.getLine(rowEnd).length);
      else
        return new Range(rowStart, 0, rowEnd + 1, 0);
    };
    this.selectLine = function () {
      this.setSelectionRange(this.getLineRange());
    };
    this.moveCursorUp = function () {
      this.moveCursorBy(-1, 0);
    };
    this.moveCursorDown = function () {
      this.moveCursorBy(1, 0);
    };
    this.moveCursorLeft = function () {
      var cursor = this.lead.getPosition(), fold;
      if (fold = this.session.getFoldAt(cursor.row, cursor.column, -1)) {
        this.moveCursorTo(fold.start.row, fold.start.column);
      } else if (cursor.column == 0) {
        if (cursor.row > 0) {
          this.moveCursorTo(cursor.row - 1, this.doc.getLine(cursor.row - 1).length);
        }
      } else {
        var tabSize = this.session.getTabSize();
        if (this.session.isTabStop(cursor) && this.doc.getLine(cursor.row).slice(cursor.column - tabSize, cursor.column).split(' ').length - 1 == tabSize)
          this.moveCursorBy(0, -tabSize);
        else
          this.moveCursorBy(0, -1);
      }
    };
    this.moveCursorRight = function () {
      var cursor = this.lead.getPosition(), fold;
      if (fold = this.session.getFoldAt(cursor.row, cursor.column, 1)) {
        this.moveCursorTo(fold.end.row, fold.end.column);
      } else if (this.lead.column == this.doc.getLine(this.lead.row).length) {
        if (this.lead.row < this.doc.getLength() - 1) {
          this.moveCursorTo(this.lead.row + 1, 0);
        }
      } else {
        var tabSize = this.session.getTabSize();
        var cursor = this.lead;
        if (this.session.isTabStop(cursor) && this.doc.getLine(cursor.row).slice(cursor.column, cursor.column + tabSize).split(' ').length - 1 == tabSize)
          this.moveCursorBy(0, tabSize);
        else
          this.moveCursorBy(0, 1);
      }
    };
    this.moveCursorLineStart = function () {
      var row = this.lead.row;
      var column = this.lead.column;
      var screenRow = this.session.documentToScreenRow(row, column);
      var firstColumnPosition = this.session.screenToDocumentPosition(screenRow, 0);
      var beforeCursor = this.session.getDisplayLine(row, null, firstColumnPosition.row, firstColumnPosition.column);
      var leadingSpace = beforeCursor.match(/^\s*/);
      if (leadingSpace[0].length != column && !this.session.$useEmacsStyleLineStart)
        firstColumnPosition.column += leadingSpace[0].length;
      this.moveCursorToPosition(firstColumnPosition);
    };
    this.moveCursorLineEnd = function () {
      var lead = this.lead;
      var lineEnd = this.session.getDocumentLastRowColumnPosition(lead.row, lead.column);
      if (this.lead.column == lineEnd.column) {
        var line = this.session.getLine(lineEnd.row);
        if (lineEnd.column == line.length) {
          var textEnd = line.search(/\s+$/);
          if (textEnd > 0)
            lineEnd.column = textEnd;
        }
      }
      this.moveCursorTo(lineEnd.row, lineEnd.column);
    };
    this.moveCursorFileEnd = function () {
      var row = this.doc.getLength() - 1;
      var column = this.doc.getLine(row).length;
      this.moveCursorTo(row, column);
    };
    this.moveCursorFileStart = function () {
      this.moveCursorTo(0, 0);
    };
    this.moveCursorLongWordRight = function () {
      var row = this.lead.row;
      var column = this.lead.column;
      var line = this.doc.getLine(row);
      var rightOfCursor = line.substring(column);
      var match;
      this.session.nonTokenRe.lastIndex = 0;
      this.session.tokenRe.lastIndex = 0;
      var fold = this.session.getFoldAt(row, column, 1);
      if (fold) {
        this.moveCursorTo(fold.end.row, fold.end.column);
        return;
      }
      if (match = this.session.nonTokenRe.exec(rightOfCursor)) {
        column += this.session.nonTokenRe.lastIndex;
        this.session.nonTokenRe.lastIndex = 0;
        rightOfCursor = line.substring(column);
      }
      if (column >= line.length) {
        this.moveCursorTo(row, line.length);
        this.moveCursorRight();
        if (row < this.doc.getLength() - 1)
          this.moveCursorWordRight();
        return;
      }
      if (match = this.session.tokenRe.exec(rightOfCursor)) {
        column += this.session.tokenRe.lastIndex;
        this.session.tokenRe.lastIndex = 0;
      }
      this.moveCursorTo(row, column);
    };
    this.moveCursorLongWordLeft = function () {
      var row = this.lead.row;
      var column = this.lead.column;
      var fold;
      if (fold = this.session.getFoldAt(row, column, -1)) {
        this.moveCursorTo(fold.start.row, fold.start.column);
        return;
      }
      var str = this.session.getFoldStringAt(row, column, -1);
      if (str == null) {
        str = this.doc.getLine(row).substring(0, column);
      }
      var leftOfCursor = lang.stringReverse(str);
      var match;
      this.session.nonTokenRe.lastIndex = 0;
      this.session.tokenRe.lastIndex = 0;
      if (match = this.session.nonTokenRe.exec(leftOfCursor)) {
        column -= this.session.nonTokenRe.lastIndex;
        leftOfCursor = leftOfCursor.slice(this.session.nonTokenRe.lastIndex);
        this.session.nonTokenRe.lastIndex = 0;
      }
      if (column <= 0) {
        this.moveCursorTo(row, 0);
        this.moveCursorLeft();
        if (row > 0)
          this.moveCursorWordLeft();
        return;
      }
      if (match = this.session.tokenRe.exec(leftOfCursor)) {
        column -= this.session.tokenRe.lastIndex;
        this.session.tokenRe.lastIndex = 0;
      }
      this.moveCursorTo(row, column);
    };
    this.$shortWordEndIndex = function (rightOfCursor) {
      var match, index = 0, ch;
      var whitespaceRe = /\s/;
      var tokenRe = this.session.tokenRe;
      tokenRe.lastIndex = 0;
      if (match = this.session.tokenRe.exec(rightOfCursor)) {
        index = this.session.tokenRe.lastIndex;
      } else {
        while ((ch = rightOfCursor[index]) && whitespaceRe.test(ch))
          index++;
        if (index < 1) {
          tokenRe.lastIndex = 0;
          while ((ch = rightOfCursor[index]) && !tokenRe.test(ch)) {
            tokenRe.lastIndex = 0;
            index++;
            if (whitespaceRe.test(ch)) {
              if (index > 2) {
                index--;
                break;
              } else {
                while ((ch = rightOfCursor[index]) && whitespaceRe.test(ch))
                  index++;
                if (index > 2)
                  break;
              }
            }
          }
        }
      }
      tokenRe.lastIndex = 0;
      return index;
    };
    this.moveCursorShortWordRight = function () {
      var row = this.lead.row;
      var column = this.lead.column;
      var line = this.doc.getLine(row);
      var rightOfCursor = line.substring(column);
      var fold = this.session.getFoldAt(row, column, 1);
      if (fold)
        return this.moveCursorTo(fold.end.row, fold.end.column);
      if (column == line.length) {
        var l = this.doc.getLength();
        do {
          row++;
          rightOfCursor = this.doc.getLine(row);
        } while (row < l && /^\s*$/.test(rightOfCursor));
        if (!/^\s+/.test(rightOfCursor))
          rightOfCursor = '';
        column = 0;
      }
      var index = this.$shortWordEndIndex(rightOfCursor);
      this.moveCursorTo(row, column + index);
    };
    this.moveCursorShortWordLeft = function () {
      var row = this.lead.row;
      var column = this.lead.column;
      var fold;
      if (fold = this.session.getFoldAt(row, column, -1))
        return this.moveCursorTo(fold.start.row, fold.start.column);
      var line = this.session.getLine(row).substring(0, column);
      if (column == 0) {
        do {
          row--;
          line = this.doc.getLine(row);
        } while (row > 0 && /^\s*$/.test(line));
        column = line.length;
        if (!/\s+$/.test(line))
          line = '';
      }
      var leftOfCursor = lang.stringReverse(line);
      var index = this.$shortWordEndIndex(leftOfCursor);
      return this.moveCursorTo(row, column - index);
    };
    this.moveCursorWordRight = function () {
      if (this.session.$selectLongWords)
        this.moveCursorLongWordRight();
      else
        this.moveCursorShortWordRight();
    };
    this.moveCursorWordLeft = function () {
      if (this.session.$selectLongWords)
        this.moveCursorLongWordLeft();
      else
        this.moveCursorShortWordLeft();
    };
    this.moveCursorBy = function (rows, chars) {
      var screenPos = this.session.documentToScreenPosition(this.lead.row, this.lead.column);
      if (chars === 0) {
        if (this.$desiredColumn)
          screenPos.column = this.$desiredColumn;
        else
          this.$desiredColumn = screenPos.column;
      }
      var docPos = this.session.screenToDocumentPosition(screenPos.row + rows, screenPos.column);
      if (rows !== 0 && chars === 0 && docPos.row === this.lead.row && docPos.column === this.lead.column) {
        if (this.session.lineWidgets && this.session.lineWidgets[docPos.row])
          docPos.row++;
      }
      this.moveCursorTo(docPos.row, docPos.column + chars, chars === 0);
    };
    this.moveCursorToPosition = function (position) {
      this.moveCursorTo(position.row, position.column);
    };
    this.moveCursorTo = function (row, column, keepDesiredColumn) {
      var fold = this.session.getFoldAt(row, column, 1);
      if (fold) {
        row = fold.start.row;
        column = fold.start.column;
      }
      this.$keepDesiredColumnOnChange = true;
      this.lead.setPosition(row, column);
      this.$keepDesiredColumnOnChange = false;
      if (!keepDesiredColumn)
        this.$desiredColumn = null;
    };
    this.moveCursorToScreen = function (row, column, keepDesiredColumn) {
      var pos = this.session.screenToDocumentPosition(row, column);
      this.moveCursorTo(pos.row, pos.column, keepDesiredColumn);
    };
    this.detach = function () {
      this.lead.detach();
      this.anchor.detach();
      this.session = this.doc = null;
    };
    this.fromOrientedRange = function (range) {
      this.setSelectionRange(range, range.cursor == range.start);
      this.$desiredColumn = range.desiredColumn || this.$desiredColumn;
    };
    this.toOrientedRange = function (range) {
      var r = this.getRange();
      if (range) {
        range.start.column = r.start.column;
        range.start.row = r.start.row;
        range.end.column = r.end.column;
        range.end.row = r.end.row;
      } else {
        range = r;
      }
      range.cursor = this.isBackwards() ? range.start : range.end;
      range.desiredColumn = this.$desiredColumn;
      return range;
    };
    this.toJSON = function () {
      if (this.rangeCount) {
        var data = this.ranges.map(function (r) {
            var r1 = r.clone();
            r1.isBackwards = r.cursor == r.start;
            return r1;
          });
      } else {
        var data = this.getRange();
        data.isBackwards = this.isBackwards();
      }
      return data;
    };
    this.fromJSON = function (data) {
      if (data.start == undefined) {
        if (this.rangeList) {
          this.toSingleRange(data[0]);
          for (var i = data.length; i--;) {
            var r = Range.fromPoints(data[i].start, data[i].end);
            if (data.isBackwards)
              r.cursor = r.start;
            this.addRange(r, true);
          }
          return;
        } else
          data = data[0];
      }
      if (this.rangeList)
        this.toSingleRange(data);
      this.setSelectionRange(data, data.isBackwards);
    };
    this.isEqual = function (data) {
      if ((data.length || this.rangeCount) && data.length != this.rangeCount)
        return false;
      if (!data.length || !this.ranges)
        return this.getRange().isEqual(data);
      for (var i = this.ranges.length; i--;) {
        if (!this.ranges[i].isEqual(data[i]))
          return false;
      }
      return true;
    };
  }.call(Selection.prototype));
  exports.Selection = Selection;
});
ace.define('ace/search', [
  'require',
  'exports',
  'module',
  'ace/lib/lang',
  'ace/lib/oop',
  'ace/range'
], function (require, exports, module) {
  var lang = require('./lib/lang');
  var oop = require('./lib/oop');
  var Range = require('./range').Range;
  var Search = function () {
    this.$options = {};
  };
  (function () {
    this.set = function (options) {
      oop.mixin(this.$options, options);
      return this;
    };
    this.getOptions = function () {
      return lang.copyObject(this.$options);
    };
    this.setOptions = function (options) {
      this.$options = options;
    };
    this.find = function (session) {
      var iterator = this.$matchIterator(session, this.$options);
      if (!iterator)
        return false;
      var firstRange = null;
      iterator.forEach(function (range, row, offset) {
        if (!range.start) {
          var column = range.offset + (offset || 0);
          firstRange = new Range(row, column, row, column + range.length);
        } else
          firstRange = range;
        return true;
      });
      return firstRange;
    };
    this.findAll = function (session) {
      var options = this.$options;
      if (!options.needle)
        return [];
      this.$assembleRegExp(options);
      var range = options.range;
      var lines = range ? session.getLines(range.start.row, range.end.row) : session.doc.getAllLines();
      var ranges = [];
      var re = options.re;
      if (options.$isMultiLine) {
        var len = re.length;
        var maxRow = lines.length - len;
        var prevRange;
        outer:
          for (var row = re.offset || 0; row <= maxRow; row++) {
            for (var j = 0; j < len; j++)
              if (lines[row + j].search(re[j]) == -1)
                continue outer;
            var startLine = lines[row];
            var line = lines[row + len - 1];
            var startIndex = startLine.length - startLine.match(re[0])[0].length;
            var endIndex = line.match(re[len - 1])[0].length;
            if (prevRange && prevRange.end.row === row && prevRange.end.column > startIndex) {
              continue;
            }
            ranges.push(prevRange = new Range(row, startIndex, row + len - 1, endIndex));
            if (len > 2)
              row = row + len - 2;
          }
      } else {
        for (var i = 0; i < lines.length; i++) {
          var matches = lang.getMatchOffsets(lines[i], re);
          for (var j = 0; j < matches.length; j++) {
            var match = matches[j];
            ranges.push(new Range(i, match.offset, i, match.offset + match.length));
          }
        }
      }
      if (range) {
        var startColumn = range.start.column;
        var endColumn = range.start.column;
        var i = 0, j = ranges.length - 1;
        while (i < j && ranges[i].start.column < startColumn && ranges[i].start.row == range.start.row)
          i++;
        while (i < j && ranges[j].end.column > endColumn && ranges[j].end.row == range.end.row)
          j--;
        ranges = ranges.slice(i, j + 1);
        for (i = 0, j = ranges.length; i < j; i++) {
          ranges[i].start.row += range.start.row;
          ranges[i].end.row += range.start.row;
        }
      }
      return ranges;
    };
    this.replace = function (input, replacement) {
      var options = this.$options;
      var re = this.$assembleRegExp(options);
      if (options.$isMultiLine)
        return replacement;
      if (!re)
        return;
      var match = re.exec(input);
      if (!match || match[0].length != input.length)
        return null;
      replacement = input.replace(re, replacement);
      if (options.preserveCase) {
        replacement = replacement.split('');
        for (var i = Math.min(input.length, input.length); i--;) {
          var ch = input[i];
          if (ch && ch.toLowerCase() != ch)
            replacement[i] = replacement[i].toUpperCase();
          else
            replacement[i] = replacement[i].toLowerCase();
        }
        replacement = replacement.join('');
      }
      return replacement;
    };
    this.$matchIterator = function (session, options) {
      var re = this.$assembleRegExp(options);
      if (!re)
        return false;
      var self = this, callback, backwards = options.backwards;
      if (options.$isMultiLine) {
        var len = re.length;
        var matchIterator = function (line, row, offset) {
          var startIndex = line.search(re[0]);
          if (startIndex == -1)
            return;
          for (var i = 1; i < len; i++) {
            line = session.getLine(row + i);
            if (line.search(re[i]) == -1)
              return;
          }
          var endIndex = line.match(re[len - 1])[0].length;
          var range = new Range(row, startIndex, row + len - 1, endIndex);
          if (re.offset == 1) {
            range.start.row--;
            range.start.column = Number.MAX_VALUE;
          } else if (offset)
            range.start.column += offset;
          if (callback(range))
            return true;
        };
      } else if (backwards) {
        var matchIterator = function (line, row, startIndex) {
          var matches = lang.getMatchOffsets(line, re);
          for (var i = matches.length - 1; i >= 0; i--)
            if (callback(matches[i], row, startIndex))
              return true;
        };
      } else {
        var matchIterator = function (line, row, startIndex) {
          var matches = lang.getMatchOffsets(line, re);
          for (var i = 0; i < matches.length; i++)
            if (callback(matches[i], row, startIndex))
              return true;
        };
      }
      return {
        forEach: function (_callback) {
          callback = _callback;
          self.$lineIterator(session, options).forEach(matchIterator);
        }
      };
    };
    this.$assembleRegExp = function (options, $disableFakeMultiline) {
      if (options.needle instanceof RegExp)
        return options.re = options.needle;
      var needle = options.needle;
      if (!options.needle)
        return options.re = false;
      if (!options.regExp)
        needle = lang.escapeRegExp(needle);
      if (options.wholeWord)
        needle = '\\b' + needle + '\\b';
      var modifier = options.caseSensitive ? 'g' : 'gi';
      options.$isMultiLine = !$disableFakeMultiline && /[\n\r]/.test(needle);
      if (options.$isMultiLine)
        return options.re = this.$assembleMultilineRegExp(needle, modifier);
      try {
        var re = new RegExp(needle, modifier);
      } catch (e) {
        re = false;
      }
      return options.re = re;
    };
    this.$assembleMultilineRegExp = function (needle, modifier) {
      var parts = needle.replace(/\r\n|\r|\n/g, '$\n^').split('\n');
      var re = [];
      for (var i = 0; i < parts.length; i++)
        try {
          re.push(new RegExp(parts[i], modifier));
        } catch (e) {
          return false;
        }
      if (parts[0] == '') {
        re.shift();
        re.offset = 1;
      } else {
        re.offset = 0;
      }
      return re;
    };
    this.$lineIterator = function (session, options) {
      var backwards = options.backwards == true;
      var skipCurrent = options.skipCurrent != false;
      var range = options.range;
      var start = options.start;
      if (!start)
        start = range ? range[backwards ? 'end' : 'start'] : session.selection.getRange();
      if (start.start)
        start = start[skipCurrent != backwards ? 'end' : 'start'];
      var firstRow = range ? range.start.row : 0;
      var lastRow = range ? range.end.row : session.getLength() - 1;
      var forEach = backwards ? function (callback) {
          var row = start.row;
          var line = session.getLine(row).substring(0, start.column);
          if (callback(line, row))
            return;
          for (row--; row >= firstRow; row--)
            if (callback(session.getLine(row), row))
              return;
          if (options.wrap == false)
            return;
          for (row = lastRow, firstRow = start.row; row >= firstRow; row--)
            if (callback(session.getLine(row), row))
              return;
        } : function (callback) {
          var row = start.row;
          var line = session.getLine(row).substr(start.column);
          if (callback(line, row, start.column))
            return;
          for (row = row + 1; row <= lastRow; row++)
            if (callback(session.getLine(row), row))
              return;
          if (options.wrap == false)
            return;
          for (row = firstRow, lastRow = start.row; row <= lastRow; row++)
            if (callback(session.getLine(row), row))
              return;
        };
      return { forEach: forEach };
    };
  }.call(Search.prototype));
  exports.Search = Search;
});
ace.define('ace/edit_session', [
  'require',
  'exports',
  'module',
  'ace/lib/oop',
  'ace/lib/lang',
  'ace/config',
  'ace/lib/event_emitter',
  'ace/selection',
  'ace/mode/text',
  'ace/range',
  'ace/document',
  'ace/background_tokenizer',
  'ace/search_highlight',
  'ace/edit_session/folding',
  'ace/edit_session/bracket_match'
], function (require, exports, module) {
  var oop = require('./lib/oop');
  var lang = require('./lib/lang');
  var config = require('./config');
  var EventEmitter = require('./lib/event_emitter').EventEmitter;
  var Selection = require('./selection').Selection;
  var TextMode = require('./mode/text').Mode;
  var Range = require('./range').Range;
  var Document = require('./document').Document;
  var BackgroundTokenizer = require('./background_tokenizer').BackgroundTokenizer;
  var SearchHighlight = require('./search_highlight').SearchHighlight;
  var EditSession = function (text, mode) {
    this.$breakpoints = [];
    this.$decorations = [];
    this.$frontMarkers = {};
    this.$backMarkers = {};
    this.$markerId = 1;
    this.$undoSelect = true;
    this.$foldData = [];
    this.$foldData.toString = function () {
      return this.join('\n');
    };
    this.on('changeFold', this.onChangeFold.bind(this));
    this.$onChange = this.onChange.bind(this);
    if (typeof text != 'object' || !text.getLine)
      text = new Document(text);
    this.setDocument(text);
    this.selection = new Selection(this);
    config.resetOptions(this);
    this.setMode(mode);
    config._signal('session', this);
  };
  (function () {
    oop.implement(this, EventEmitter);
    this.setDocument = function (doc) {
      if (this.doc)
        this.doc.removeListener('change', this.$onChange);
      this.doc = doc;
      doc.on('change', this.$onChange);
      if (this.bgTokenizer)
        this.bgTokenizer.setDocument(this.getDocument());
      this.resetCaches();
    };
    this.getDocument = function () {
      return this.doc;
    };
    this.$resetRowCache = function (docRow) {
      if (!docRow) {
        this.$docRowCache = [];
        this.$screenRowCache = [];
        return;
      }
      var l = this.$docRowCache.length;
      var i = this.$getRowCacheIndex(this.$docRowCache, docRow) + 1;
      if (l > i) {
        this.$docRowCache.splice(i, l);
        this.$screenRowCache.splice(i, l);
      }
    };
    this.$getRowCacheIndex = function (cacheArray, val) {
      var low = 0;
      var hi = cacheArray.length - 1;
      while (low <= hi) {
        var mid = low + hi >> 1;
        var c = cacheArray[mid];
        if (val > c)
          low = mid + 1;
        else if (val < c)
          hi = mid - 1;
        else
          return mid;
      }
      return low - 1;
    };
    this.resetCaches = function () {
      this.$modified = true;
      this.$wrapData = [];
      this.$rowLengthCache = [];
      this.$resetRowCache(0);
      if (this.bgTokenizer)
        this.bgTokenizer.start(0);
    };
    this.onChangeFold = function (e) {
      var fold = e.data;
      this.$resetRowCache(fold.start.row);
    };
    this.onChange = function (e) {
      var delta = e.data;
      this.$modified = true;
      this.$resetRowCache(delta.range.start.row);
      var removedFolds = this.$updateInternalDataOnChange(e);
      if (!this.$fromUndo && this.$undoManager && !delta.ignore) {
        this.$deltasDoc.push(delta);
        if (removedFolds && removedFolds.length != 0) {
          this.$deltasFold.push({
            action: 'removeFolds',
            folds: removedFolds
          });
        }
        this.$informUndoManager.schedule();
      }
      this.bgTokenizer.$updateOnChange(delta);
      this._signal('change', e);
    };
    this.setValue = function (text) {
      this.doc.setValue(text);
      this.selection.moveTo(0, 0);
      this.$resetRowCache(0);
      this.$deltas = [];
      this.$deltasDoc = [];
      this.$deltasFold = [];
      this.setUndoManager(this.$undoManager);
      this.getUndoManager().reset();
    };
    this.getValue = this.toString = function () {
      return this.doc.getValue();
    };
    this.getSelection = function () {
      return this.selection;
    };
    this.getState = function (row) {
      return this.bgTokenizer.getState(row);
    };
    this.getTokens = function (row) {
      return this.bgTokenizer.getTokens(row);
    };
    this.getTokenAt = function (row, column) {
      var tokens = this.bgTokenizer.getTokens(row);
      var token, c = 0;
      if (column == null) {
        i = tokens.length - 1;
        c = this.getLine(row).length;
      } else {
        for (var i = 0; i < tokens.length; i++) {
          c += tokens[i].value.length;
          if (c >= column)
            break;
        }
      }
      token = tokens[i];
      if (!token)
        return null;
      token.index = i;
      token.start = c - token.value.length;
      return token;
    };
    this.setUndoManager = function (undoManager) {
      this.$undoManager = undoManager;
      this.$deltas = [];
      this.$deltasDoc = [];
      this.$deltasFold = [];
      if (this.$informUndoManager)
        this.$informUndoManager.cancel();
      if (undoManager) {
        var self = this;
        this.$syncInformUndoManager = function () {
          self.$informUndoManager.cancel();
          if (self.$deltasFold.length) {
            self.$deltas.push({
              group: 'fold',
              deltas: self.$deltasFold
            });
            self.$deltasFold = [];
          }
          if (self.$deltasDoc.length) {
            self.$deltas.push({
              group: 'doc',
              deltas: self.$deltasDoc
            });
            self.$deltasDoc = [];
          }
          if (self.$deltas.length > 0) {
            undoManager.execute({
              action: 'aceupdate',
              args: [
                self.$deltas,
                self
              ],
              merge: self.mergeUndoDeltas
            });
          }
          self.mergeUndoDeltas = false;
          self.$deltas = [];
        };
        this.$informUndoManager = lang.delayedCall(this.$syncInformUndoManager);
      }
    };
    this.markUndoGroup = function () {
      if (this.$syncInformUndoManager)
        this.$syncInformUndoManager();
    };
    this.$defaultUndoManager = {
      undo: function () {
      },
      redo: function () {
      },
      reset: function () {
      }
    };
    this.getUndoManager = function () {
      return this.$undoManager || this.$defaultUndoManager;
    };
    this.getTabString = function () {
      if (this.getUseSoftTabs()) {
        return lang.stringRepeat(' ', this.getTabSize());
      } else {
        return '\t';
      }
    };
    this.setUseSoftTabs = function (val) {
      this.setOption('useSoftTabs', val);
    };
    this.getUseSoftTabs = function () {
      return this.$useSoftTabs && !this.$mode.$indentWithTabs;
    };
    this.setTabSize = function (tabSize) {
      this.setOption('tabSize', tabSize);
    };
    this.getTabSize = function () {
      return this.$tabSize;
    };
    this.isTabStop = function (position) {
      return this.$useSoftTabs && position.column % this.$tabSize === 0;
    };
    this.$overwrite = false;
    this.setOverwrite = function (overwrite) {
      this.setOption('overwrite', overwrite);
    };
    this.getOverwrite = function () {
      return this.$overwrite;
    };
    this.toggleOverwrite = function () {
      this.setOverwrite(!this.$overwrite);
    };
    this.addGutterDecoration = function (row, className) {
      if (!this.$decorations[row])
        this.$decorations[row] = '';
      this.$decorations[row] += ' ' + className;
      this._signal('changeBreakpoint', {});
    };
    this.removeGutterDecoration = function (row, className) {
      this.$decorations[row] = (this.$decorations[row] || '').replace(' ' + className, '');
      this._signal('changeBreakpoint', {});
    };
    this.getBreakpoints = function () {
      return this.$breakpoints;
    };
    this.setBreakpoints = function (rows) {
      this.$breakpoints = [];
      for (var i = 0; i < rows.length; i++) {
        this.$breakpoints[rows[i]] = 'ace_breakpoint';
      }
      this._signal('changeBreakpoint', {});
    };
    this.clearBreakpoints = function () {
      this.$breakpoints = [];
      this._signal('changeBreakpoint', {});
    };
    this.setBreakpoint = function (row, className) {
      if (className === undefined)
        className = 'ace_breakpoint';
      if (className)
        this.$breakpoints[row] = className;
      else
        delete this.$breakpoints[row];
      this._signal('changeBreakpoint', {});
    };
    this.clearBreakpoint = function (row) {
      delete this.$breakpoints[row];
      this._signal('changeBreakpoint', {});
    };
    this.addMarker = function (range, clazz, type, inFront) {
      var id = this.$markerId++;
      var marker = {
          range: range,
          type: type || 'line',
          renderer: typeof type == 'function' ? type : null,
          clazz: clazz,
          inFront: !!inFront,
          id: id
        };
      if (inFront) {
        this.$frontMarkers[id] = marker;
        this._signal('changeFrontMarker');
      } else {
        this.$backMarkers[id] = marker;
        this._signal('changeBackMarker');
      }
      return id;
    };
    this.addDynamicMarker = function (marker, inFront) {
      if (!marker.update)
        return;
      var id = this.$markerId++;
      marker.id = id;
      marker.inFront = !!inFront;
      if (inFront) {
        this.$frontMarkers[id] = marker;
        this._signal('changeFrontMarker');
      } else {
        this.$backMarkers[id] = marker;
        this._signal('changeBackMarker');
      }
      return marker;
    };
    this.removeMarker = function (markerId) {
      var marker = this.$frontMarkers[markerId] || this.$backMarkers[markerId];
      if (!marker)
        return;
      var markers = marker.inFront ? this.$frontMarkers : this.$backMarkers;
      if (marker) {
        delete markers[markerId];
        this._signal(marker.inFront ? 'changeFrontMarker' : 'changeBackMarker');
      }
    };
    this.getMarkers = function (inFront) {
      return inFront ? this.$frontMarkers : this.$backMarkers;
    };
    this.highlight = function (re) {
      if (!this.$searchHighlight) {
        var highlight = new SearchHighlight(null, 'ace_selected-word', 'text');
        this.$searchHighlight = this.addDynamicMarker(highlight);
      }
      this.$searchHighlight.setRegexp(re);
    };
    this.highlightLines = function (startRow, endRow, clazz, inFront) {
      if (typeof endRow != 'number') {
        clazz = endRow;
        endRow = startRow;
      }
      if (!clazz)
        clazz = 'ace_step';
      var range = new Range(startRow, 0, endRow, Infinity);
      range.id = this.addMarker(range, clazz, 'fullLine', inFront);
      return range;
    };
    this.setAnnotations = function (annotations) {
      this.$annotations = annotations;
      this._signal('changeAnnotation', {});
    };
    this.getAnnotations = function () {
      return this.$annotations || [];
    };
    this.clearAnnotations = function () {
      this.setAnnotations([]);
    };
    this.$detectNewLine = function (text) {
      var match = text.match(/^.*?(\r?\n)/m);
      if (match) {
        this.$autoNewLine = match[1];
      } else {
        this.$autoNewLine = '\n';
      }
    };
    this.getWordRange = function (row, column) {
      var line = this.getLine(row);
      var inToken = false;
      if (column > 0)
        inToken = !!line.charAt(column - 1).match(this.tokenRe);
      if (!inToken)
        inToken = !!line.charAt(column).match(this.tokenRe);
      if (inToken)
        var re = this.tokenRe;
      else if (/^\s+$/.test(line.slice(column - 1, column + 1)))
        var re = /\s/;
      else
        var re = this.nonTokenRe;
      var start = column;
      if (start > 0) {
        do {
          start--;
        } while (start >= 0 && line.charAt(start).match(re));
        start++;
      }
      var end = column;
      while (end < line.length && line.charAt(end).match(re)) {
        end++;
      }
      return new Range(row, start, row, end);
    };
    this.getAWordRange = function (row, column) {
      var wordRange = this.getWordRange(row, column);
      var line = this.getLine(wordRange.end.row);
      while (line.charAt(wordRange.end.column).match(/[ \t]/)) {
        wordRange.end.column += 1;
      }
      return wordRange;
    };
    this.setNewLineMode = function (newLineMode) {
      this.doc.setNewLineMode(newLineMode);
    };
    this.getNewLineMode = function () {
      return this.doc.getNewLineMode();
    };
    this.setUseWorker = function (useWorker) {
      this.setOption('useWorker', useWorker);
    };
    this.getUseWorker = function () {
      return this.$useWorker;
    };
    this.onReloadTokenizer = function (e) {
      var rows = e.data;
      this.bgTokenizer.start(rows.first);
      this._signal('tokenizerUpdate', e);
    };
    this.$modes = {};
    this.$mode = null;
    this.$modeId = null;
    this.setMode = function (mode, cb) {
      if (mode && typeof mode === 'object') {
        if (mode.getTokenizer)
          return this.$onChangeMode(mode);
        var options = mode;
        var path = options.path;
      } else {
        path = mode || 'ace/mode/text';
      }
      if (!this.$modes['ace/mode/text'])
        this.$modes['ace/mode/text'] = new TextMode();
      if (this.$modes[path] && !options) {
        this.$onChangeMode(this.$modes[path]);
        cb && cb();
        return;
      }
      this.$modeId = path;
      config.loadModule([
        'mode',
        path
      ], function (m) {
        if (this.$modeId !== path)
          return cb && cb();
        if (this.$modes[path] && !options)
          return this.$onChangeMode(this.$modes[path]);
        if (m && m.Mode) {
          m = new m.Mode(options);
          if (!options) {
            this.$modes[path] = m;
            m.$id = path;
          }
          this.$onChangeMode(m);
          cb && cb();
        }
      }.bind(this));
      if (!this.$mode)
        this.$onChangeMode(this.$modes['ace/mode/text'], true);
    };
    this.$onChangeMode = function (mode, $isPlaceholder) {
      if (!$isPlaceholder)
        this.$modeId = mode.$id;
      if (this.$mode === mode)
        return;
      this.$mode = mode;
      this.$stopWorker();
      if (this.$useWorker)
        this.$startWorker();
      var tokenizer = mode.getTokenizer();
      if (tokenizer.addEventListener !== undefined) {
        var onReloadTokenizer = this.onReloadTokenizer.bind(this);
        tokenizer.addEventListener('update', onReloadTokenizer);
      }
      if (!this.bgTokenizer) {
        this.bgTokenizer = new BackgroundTokenizer(tokenizer);
        var _self = this;
        this.bgTokenizer.addEventListener('update', function (e) {
          _self._signal('tokenizerUpdate', e);
        });
      } else {
        this.bgTokenizer.setTokenizer(tokenizer);
      }
      this.bgTokenizer.setDocument(this.getDocument());
      this.tokenRe = mode.tokenRe;
      this.nonTokenRe = mode.nonTokenRe;
      if (!$isPlaceholder) {
        this.$options.wrapMethod.set.call(this, this.$wrapMethod);
        this.$setFolding(mode.foldingRules);
        this.bgTokenizer.start(0);
        this._emit('changeMode');
      }
    };
    this.$stopWorker = function () {
      if (this.$worker)
        this.$worker.terminate();
      this.$worker = null;
    };
    this.$startWorker = function () {
      if (typeof Worker !== 'undefined' && !require.noWorker) {
        try {
          this.$worker = this.$mode.createWorker(this);
        } catch (e) {
          console.log('Could not load worker');
          console.log(e);
          this.$worker = null;
        }
      } else
        this.$worker = null;
    };
    this.getMode = function () {
      return this.$mode;
    };
    this.$scrollTop = 0;
    this.setScrollTop = function (scrollTop) {
      if (this.$scrollTop === scrollTop || isNaN(scrollTop))
        return;
      this.$scrollTop = scrollTop;
      this._signal('changeScrollTop', scrollTop);
    };
    this.getScrollTop = function () {
      return this.$scrollTop;
    };
    this.$scrollLeft = 0;
    this.setScrollLeft = function (scrollLeft) {
      if (this.$scrollLeft === scrollLeft || isNaN(scrollLeft))
        return;
      this.$scrollLeft = scrollLeft;
      this._signal('changeScrollLeft', scrollLeft);
    };
    this.getScrollLeft = function () {
      return this.$scrollLeft;
    };
    this.getScreenWidth = function () {
      this.$computeWidth();
      if (this.lineWidgets)
        return Math.max(this.getLineWidgetMaxWidth(), this.screenWidth);
      return this.screenWidth;
    };
    this.getLineWidgetMaxWidth = function () {
      if (this.lineWidgetsWidth != null)
        return this.lineWidgetsWidth;
      var width = 0;
      this.lineWidgets.forEach(function (w) {
        if (w && w.screenWidth > width)
          width = w.screenWidth;
      });
      return this.lineWidgetWidth = width;
    };
    this.$computeWidth = function (force) {
      if (this.$modified || force) {
        this.$modified = false;
        if (this.$useWrapMode)
          return this.screenWidth = this.$wrapLimit;
        var lines = this.doc.getAllLines();
        var cache = this.$rowLengthCache;
        var longestScreenLine = 0;
        var foldIndex = 0;
        var foldLine = this.$foldData[foldIndex];
        var foldStart = foldLine ? foldLine.start.row : Infinity;
        var len = lines.length;
        for (var i = 0; i < len; i++) {
          if (i > foldStart) {
            i = foldLine.end.row + 1;
            if (i >= len)
              break;
            foldLine = this.$foldData[foldIndex++];
            foldStart = foldLine ? foldLine.start.row : Infinity;
          }
          if (cache[i] == null)
            cache[i] = this.$getStringScreenWidth(lines[i])[0];
          if (cache[i] > longestScreenLine)
            longestScreenLine = cache[i];
        }
        this.screenWidth = longestScreenLine;
      }
    };
    this.getLine = function (row) {
      return this.doc.getLine(row);
    };
    this.getLines = function (firstRow, lastRow) {
      return this.doc.getLines(firstRow, lastRow);
    };
    this.getLength = function () {
      return this.doc.getLength();
    };
    this.getTextRange = function (range) {
      return this.doc.getTextRange(range || this.selection.getRange());
    };
    this.insert = function (position, text) {
      return this.doc.insert(position, text);
    };
    this.remove = function (range) {
      return this.doc.remove(range);
    };
    this.undoChanges = function (deltas, dontSelect) {
      if (!deltas.length)
        return;
      this.$fromUndo = true;
      var lastUndoRange = null;
      for (var i = deltas.length - 1; i != -1; i--) {
        var delta = deltas[i];
        if (delta.group == 'doc') {
          this.doc.revertDeltas(delta.deltas);
          lastUndoRange = this.$getUndoSelection(delta.deltas, true, lastUndoRange);
        } else {
          delta.deltas.forEach(function (foldDelta) {
            this.addFolds(foldDelta.folds);
          }, this);
        }
      }
      this.$fromUndo = false;
      lastUndoRange && this.$undoSelect && !dontSelect && this.selection.setSelectionRange(lastUndoRange);
      return lastUndoRange;
    };
    this.redoChanges = function (deltas, dontSelect) {
      if (!deltas.length)
        return;
      this.$fromUndo = true;
      var lastUndoRange = null;
      for (var i = 0; i < deltas.length; i++) {
        var delta = deltas[i];
        if (delta.group == 'doc') {
          this.doc.applyDeltas(delta.deltas);
          lastUndoRange = this.$getUndoSelection(delta.deltas, false, lastUndoRange);
        }
      }
      this.$fromUndo = false;
      lastUndoRange && this.$undoSelect && !dontSelect && this.selection.setSelectionRange(lastUndoRange);
      return lastUndoRange;
    };
    this.setUndoSelect = function (enable) {
      this.$undoSelect = enable;
    };
    this.$getUndoSelection = function (deltas, isUndo, lastUndoRange) {
      function isInsert(delta) {
        var insert = delta.action === 'insertText' || delta.action === 'insertLines';
        return isUndo ? !insert : insert;
      }
      var delta = deltas[0];
      var range, point;
      var lastDeltaIsInsert = false;
      if (isInsert(delta)) {
        range = Range.fromPoints(delta.range.start, delta.range.end);
        lastDeltaIsInsert = true;
      } else {
        range = Range.fromPoints(delta.range.start, delta.range.start);
        lastDeltaIsInsert = false;
      }
      for (var i = 1; i < deltas.length; i++) {
        delta = deltas[i];
        if (isInsert(delta)) {
          point = delta.range.start;
          if (range.compare(point.row, point.column) == -1) {
            range.setStart(delta.range.start);
          }
          point = delta.range.end;
          if (range.compare(point.row, point.column) == 1) {
            range.setEnd(delta.range.end);
          }
          lastDeltaIsInsert = true;
        } else {
          point = delta.range.start;
          if (range.compare(point.row, point.column) == -1) {
            range = Range.fromPoints(delta.range.start, delta.range.start);
          }
          lastDeltaIsInsert = false;
        }
      }
      if (lastUndoRange != null) {
        if (Range.comparePoints(lastUndoRange.start, range.start) === 0) {
          lastUndoRange.start.column += range.end.column - range.start.column;
          lastUndoRange.end.column += range.end.column - range.start.column;
        }
        var cmp = lastUndoRange.compareRange(range);
        if (cmp == 1) {
          range.setStart(lastUndoRange.start);
        } else if (cmp == -1) {
          range.setEnd(lastUndoRange.end);
        }
      }
      return range;
    };
    this.replace = function (range, text) {
      return this.doc.replace(range, text);
    };
    this.moveText = function (fromRange, toPosition, copy) {
      var text = this.getTextRange(fromRange);
      var folds = this.getFoldsInRange(fromRange);
      var toRange = Range.fromPoints(toPosition, toPosition);
      if (!copy) {
        this.remove(fromRange);
        var rowDiff = fromRange.start.row - fromRange.end.row;
        var collDiff = rowDiff ? -fromRange.end.column : fromRange.start.column - fromRange.end.column;
        if (collDiff) {
          if (toRange.start.row == fromRange.end.row && toRange.start.column > fromRange.end.column)
            toRange.start.column += collDiff;
          if (toRange.end.row == fromRange.end.row && toRange.end.column > fromRange.end.column)
            toRange.end.column += collDiff;
        }
        if (rowDiff && toRange.start.row >= fromRange.end.row) {
          toRange.start.row += rowDiff;
          toRange.end.row += rowDiff;
        }
      }
      toRange.end = this.insert(toRange.start, text);
      if (folds.length) {
        var oldStart = fromRange.start;
        var newStart = toRange.start;
        var rowDiff = newStart.row - oldStart.row;
        var collDiff = newStart.column - oldStart.column;
        this.addFolds(folds.map(function (x) {
          x = x.clone();
          if (x.start.row == oldStart.row)
            x.start.column += collDiff;
          if (x.end.row == oldStart.row)
            x.end.column += collDiff;
          x.start.row += rowDiff;
          x.end.row += rowDiff;
          return x;
        }));
      }
      return toRange;
    };
    this.indentRows = function (startRow, endRow, indentString) {
      indentString = indentString.replace(/\t/g, this.getTabString());
      for (var row = startRow; row <= endRow; row++)
        this.insert({
          row: row,
          column: 0
        }, indentString);
    };
    this.outdentRows = function (range) {
      var rowRange = range.collapseRows();
      var deleteRange = new Range(0, 0, 0, 0);
      var size = this.getTabSize();
      for (var i = rowRange.start.row; i <= rowRange.end.row; ++i) {
        var line = this.getLine(i);
        deleteRange.start.row = i;
        deleteRange.end.row = i;
        for (var j = 0; j < size; ++j)
          if (line.charAt(j) != ' ')
            break;
        if (j < size && line.charAt(j) == '\t') {
          deleteRange.start.column = j;
          deleteRange.end.column = j + 1;
        } else {
          deleteRange.start.column = 0;
          deleteRange.end.column = j;
        }
        this.remove(deleteRange);
      }
    };
    this.$moveLines = function (firstRow, lastRow, dir) {
      firstRow = this.getRowFoldStart(firstRow);
      lastRow = this.getRowFoldEnd(lastRow);
      if (dir < 0) {
        var row = this.getRowFoldStart(firstRow + dir);
        if (row < 0)
          return 0;
        var diff = row - firstRow;
      } else if (dir > 0) {
        var row = this.getRowFoldEnd(lastRow + dir);
        if (row > this.doc.getLength() - 1)
          return 0;
        var diff = row - lastRow;
      } else {
        firstRow = this.$clipRowToDocument(firstRow);
        lastRow = this.$clipRowToDocument(lastRow);
        var diff = lastRow - firstRow + 1;
      }
      var range = new Range(firstRow, 0, lastRow, Number.MAX_VALUE);
      var folds = this.getFoldsInRange(range).map(function (x) {
          x = x.clone();
          x.start.row += diff;
          x.end.row += diff;
          return x;
        });
      var lines = dir == 0 ? this.doc.getLines(firstRow, lastRow) : this.doc.removeLines(firstRow, lastRow);
      this.doc.insertLines(firstRow + diff, lines);
      folds.length && this.addFolds(folds);
      return diff;
    };
    this.moveLinesUp = function (firstRow, lastRow) {
      return this.$moveLines(firstRow, lastRow, -1);
    };
    this.moveLinesDown = function (firstRow, lastRow) {
      return this.$moveLines(firstRow, lastRow, 1);
    };
    this.duplicateLines = function (firstRow, lastRow) {
      return this.$moveLines(firstRow, lastRow, 0);
    };
    this.$clipRowToDocument = function (row) {
      return Math.max(0, Math.min(row, this.doc.getLength() - 1));
    };
    this.$clipColumnToRow = function (row, column) {
      if (column < 0)
        return 0;
      return Math.min(this.doc.getLine(row).length, column);
    };
    this.$clipPositionToDocument = function (row, column) {
      column = Math.max(0, column);
      if (row < 0) {
        row = 0;
        column = 0;
      } else {
        var len = this.doc.getLength();
        if (row >= len) {
          row = len - 1;
          column = this.doc.getLine(len - 1).length;
        } else {
          column = Math.min(this.doc.getLine(row).length, column);
        }
      }
      return {
        row: row,
        column: column
      };
    };
    this.$clipRangeToDocument = function (range) {
      if (range.start.row < 0) {
        range.start.row = 0;
        range.start.column = 0;
      } else {
        range.start.column = this.$clipColumnToRow(range.start.row, range.start.column);
      }
      var len = this.doc.getLength() - 1;
      if (range.end.row > len) {
        range.end.row = len;
        range.end.column = this.doc.getLine(len).length;
      } else {
        range.end.column = this.$clipColumnToRow(range.end.row, range.end.column);
      }
      return range;
    };
    this.$wrapLimit = 80;
    this.$useWrapMode = false;
    this.$wrapLimitRange = {
      min: null,
      max: null
    };
    this.setUseWrapMode = function (useWrapMode) {
      if (useWrapMode != this.$useWrapMode) {
        this.$useWrapMode = useWrapMode;
        this.$modified = true;
        this.$resetRowCache(0);
        if (useWrapMode) {
          var len = this.getLength();
          this.$wrapData = Array(len);
          this.$updateWrapData(0, len - 1);
        }
        this._signal('changeWrapMode');
      }
    };
    this.getUseWrapMode = function () {
      return this.$useWrapMode;
    };
    this.setWrapLimitRange = function (min, max) {
      if (this.$wrapLimitRange.min !== min || this.$wrapLimitRange.max !== max) {
        this.$wrapLimitRange = {
          min: min,
          max: max
        };
        this.$modified = true;
        this._signal('changeWrapMode');
      }
    };
    this.adjustWrapLimit = function (desiredLimit, $printMargin) {
      var limits = this.$wrapLimitRange;
      if (limits.max < 0)
        limits = {
          min: $printMargin,
          max: $printMargin
        };
      var wrapLimit = this.$constrainWrapLimit(desiredLimit, limits.min, limits.max);
      if (wrapLimit != this.$wrapLimit && wrapLimit > 1) {
        this.$wrapLimit = wrapLimit;
        this.$modified = true;
        if (this.$useWrapMode) {
          this.$updateWrapData(0, this.getLength() - 1);
          this.$resetRowCache(0);
          this._signal('changeWrapLimit');
        }
        return true;
      }
      return false;
    };
    this.$constrainWrapLimit = function (wrapLimit, min, max) {
      if (min)
        wrapLimit = Math.max(min, wrapLimit);
      if (max)
        wrapLimit = Math.min(max, wrapLimit);
      return wrapLimit;
    };
    this.getWrapLimit = function () {
      return this.$wrapLimit;
    };
    this.setWrapLimit = function (limit) {
      this.setWrapLimitRange(limit, limit);
    };
    this.getWrapLimitRange = function () {
      return {
        min: this.$wrapLimitRange.min,
        max: this.$wrapLimitRange.max
      };
    };
    this.$updateInternalDataOnChange = function (e) {
      var useWrapMode = this.$useWrapMode;
      var len;
      var action = e.data.action;
      var firstRow = e.data.range.start.row;
      var lastRow = e.data.range.end.row;
      var start = e.data.range.start;
      var end = e.data.range.end;
      var removedFolds = null;
      if (action.indexOf('Lines') != -1) {
        if (action == 'insertLines') {
          lastRow = firstRow + e.data.lines.length;
        } else {
          lastRow = firstRow;
        }
        len = e.data.lines ? e.data.lines.length : lastRow - firstRow;
      } else {
        len = lastRow - firstRow;
      }
      this.$updating = true;
      if (len != 0) {
        if (action.indexOf('remove') != -1) {
          this[useWrapMode ? '$wrapData' : '$rowLengthCache'].splice(firstRow, len);
          var foldLines = this.$foldData;
          removedFolds = this.getFoldsInRange(e.data.range);
          this.removeFolds(removedFolds);
          var foldLine = this.getFoldLine(end.row);
          var idx = 0;
          if (foldLine) {
            foldLine.addRemoveChars(end.row, end.column, start.column - end.column);
            foldLine.shiftRow(-len);
            var foldLineBefore = this.getFoldLine(firstRow);
            if (foldLineBefore && foldLineBefore !== foldLine) {
              foldLineBefore.merge(foldLine);
              foldLine = foldLineBefore;
            }
            idx = foldLines.indexOf(foldLine) + 1;
          }
          for (idx; idx < foldLines.length; idx++) {
            var foldLine = foldLines[idx];
            if (foldLine.start.row >= end.row) {
              foldLine.shiftRow(-len);
            }
          }
          lastRow = firstRow;
        } else {
          var args = Array(len);
          args.unshift(firstRow, 0);
          var arr = useWrapMode ? this.$wrapData : this.$rowLengthCache;
          arr.splice.apply(arr, args);
          var foldLines = this.$foldData;
          var foldLine = this.getFoldLine(firstRow);
          var idx = 0;
          if (foldLine) {
            var cmp = foldLine.range.compareInside(start.row, start.column);
            if (cmp == 0) {
              foldLine = foldLine.split(start.row, start.column);
              foldLine.shiftRow(len);
              foldLine.addRemoveChars(lastRow, 0, end.column - start.column);
            } else if (cmp == -1) {
              foldLine.addRemoveChars(firstRow, 0, end.column - start.column);
              foldLine.shiftRow(len);
            }
            idx = foldLines.indexOf(foldLine) + 1;
          }
          for (idx; idx < foldLines.length; idx++) {
            var foldLine = foldLines[idx];
            if (foldLine.start.row >= firstRow) {
              foldLine.shiftRow(len);
            }
          }
        }
      } else {
        len = Math.abs(e.data.range.start.column - e.data.range.end.column);
        if (action.indexOf('remove') != -1) {
          removedFolds = this.getFoldsInRange(e.data.range);
          this.removeFolds(removedFolds);
          len = -len;
        }
        var foldLine = this.getFoldLine(firstRow);
        if (foldLine) {
          foldLine.addRemoveChars(firstRow, start.column, len);
        }
      }
      if (useWrapMode && this.$wrapData.length != this.doc.getLength()) {
        console.error('doc.getLength() and $wrapData.length have to be the same!');
      }
      this.$updating = false;
      if (useWrapMode)
        this.$updateWrapData(firstRow, lastRow);
      else
        this.$updateRowLengthCache(firstRow, lastRow);
      return removedFolds;
    };
    this.$updateRowLengthCache = function (firstRow, lastRow, b) {
      this.$rowLengthCache[firstRow] = null;
      this.$rowLengthCache[lastRow] = null;
    };
    this.$updateWrapData = function (firstRow, lastRow) {
      var lines = this.doc.getAllLines();
      var tabSize = this.getTabSize();
      var wrapData = this.$wrapData;
      var wrapLimit = this.$wrapLimit;
      var tokens;
      var foldLine;
      var row = firstRow;
      lastRow = Math.min(lastRow, lines.length - 1);
      while (row <= lastRow) {
        foldLine = this.getFoldLine(row, foldLine);
        if (!foldLine) {
          tokens = this.$getDisplayTokens(lines[row]);
          wrapData[row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);
          row++;
        } else {
          tokens = [];
          foldLine.walk(function (placeholder, row, column, lastColumn) {
            var walkTokens;
            if (placeholder != null) {
              walkTokens = this.$getDisplayTokens(placeholder, tokens.length);
              walkTokens[0] = PLACEHOLDER_START;
              for (var i = 1; i < walkTokens.length; i++) {
                walkTokens[i] = PLACEHOLDER_BODY;
              }
            } else {
              walkTokens = this.$getDisplayTokens(lines[row].substring(lastColumn, column), tokens.length);
            }
            tokens = tokens.concat(walkTokens);
          }.bind(this), foldLine.end.row, lines[foldLine.end.row].length + 1);
          wrapData[foldLine.start.row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);
          row = foldLine.end.row + 1;
        }
      }
    };
    var CHAR = 1, CHAR_EXT = 2, PLACEHOLDER_START = 3, PLACEHOLDER_BODY = 4, PUNCTUATION = 9, SPACE = 10, TAB = 11, TAB_SPACE = 12;
    this.$computeWrapSplits = function (tokens, wrapLimit) {
      if (tokens.length == 0) {
        return [];
      }
      var splits = [];
      var displayLength = tokens.length;
      var lastSplit = 0, lastDocSplit = 0;
      var isCode = this.$wrapAsCode;
      function addSplit(screenPos) {
        var displayed = tokens.slice(lastSplit, screenPos);
        var len = displayed.length;
        displayed.join('').replace(/12/g, function () {
          len -= 1;
        }).replace(/2/g, function () {
          len -= 1;
        });
        lastDocSplit += len;
        splits.push(lastDocSplit);
        lastSplit = screenPos;
      }
      while (displayLength - lastSplit > wrapLimit) {
        var split = lastSplit + wrapLimit;
        if (tokens[split - 1] >= SPACE && tokens[split] >= SPACE) {
          addSplit(split);
          continue;
        }
        if (tokens[split] == PLACEHOLDER_START || tokens[split] == PLACEHOLDER_BODY) {
          for (split; split != lastSplit - 1; split--) {
            if (tokens[split] == PLACEHOLDER_START) {
              break;
            }
          }
          if (split > lastSplit) {
            addSplit(split);
            continue;
          }
          split = lastSplit + wrapLimit;
          for (split; split < tokens.length; split++) {
            if (tokens[split] != PLACEHOLDER_BODY) {
              break;
            }
          }
          if (split == tokens.length) {
            break;
          }
          addSplit(split);
          continue;
        }
        var minSplit = Math.max(split - (isCode ? 10 : wrapLimit - (wrapLimit >> 2)), lastSplit - 1);
        while (split > minSplit && tokens[split] < PLACEHOLDER_START) {
          split--;
        }
        if (isCode) {
          while (split > minSplit && tokens[split] < PLACEHOLDER_START) {
            split--;
          }
          while (split > minSplit && tokens[split] == PUNCTUATION) {
            split--;
          }
        } else {
          while (split > minSplit && tokens[split] < SPACE) {
            split--;
          }
        }
        if (split > minSplit) {
          addSplit(++split);
          continue;
        }
        split = lastSplit + wrapLimit;
        addSplit(split);
      }
      return splits;
    };
    this.$getDisplayTokens = function (str, offset) {
      var arr = [];
      var tabSize;
      offset = offset || 0;
      for (var i = 0; i < str.length; i++) {
        var c = str.charCodeAt(i);
        if (c == 9) {
          tabSize = this.getScreenTabSize(arr.length + offset);
          arr.push(TAB);
          for (var n = 1; n < tabSize; n++) {
            arr.push(TAB_SPACE);
          }
        } else if (c == 32) {
          arr.push(SPACE);
        } else if (c > 39 && c < 48 || c > 57 && c < 64) {
          arr.push(PUNCTUATION);
        } else if (c >= 4352 && isFullWidth(c)) {
          arr.push(CHAR, CHAR_EXT);
        } else {
          arr.push(CHAR);
        }
      }
      return arr;
    };
    this.$getStringScreenWidth = function (str, maxScreenColumn, screenColumn) {
      if (maxScreenColumn == 0)
        return [
          0,
          0
        ];
      if (maxScreenColumn == null)
        maxScreenColumn = Infinity;
      screenColumn = screenColumn || 0;
      var c, column;
      for (column = 0; column < str.length; column++) {
        c = str.charCodeAt(column);
        if (c == 9) {
          screenColumn += this.getScreenTabSize(screenColumn);
        } else if (c >= 4352 && isFullWidth(c)) {
          screenColumn += 2;
        } else {
          screenColumn += 1;
        }
        if (screenColumn > maxScreenColumn) {
          break;
        }
      }
      return [
        screenColumn,
        column
      ];
    };
    this.lineWidgets = null;
    this.getRowLength = function (row) {
      if (this.lineWidgets)
        var h = this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;
      else
        h = 0;
      if (!this.$useWrapMode || !this.$wrapData[row]) {
        return 1 + h;
      } else {
        return this.$wrapData[row].length + 1 + h;
      }
    };
    this.getRowLineCount = function (row) {
      if (!this.$useWrapMode || !this.$wrapData[row]) {
        return 1;
      } else {
        return this.$wrapData[row].length + 1;
      }
    };
    this.getScreenLastRowColumn = function (screenRow) {
      var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);
      return this.documentToScreenColumn(pos.row, pos.column);
    };
    this.getDocumentLastRowColumn = function (docRow, docColumn) {
      var screenRow = this.documentToScreenRow(docRow, docColumn);
      return this.getScreenLastRowColumn(screenRow);
    };
    this.getDocumentLastRowColumnPosition = function (docRow, docColumn) {
      var screenRow = this.documentToScreenRow(docRow, docColumn);
      return this.screenToDocumentPosition(screenRow, Number.MAX_VALUE / 10);
    };
    this.getRowSplitData = function (row) {
      if (!this.$useWrapMode) {
        return undefined;
      } else {
        return this.$wrapData[row];
      }
    };
    this.getScreenTabSize = function (screenColumn) {
      return this.$tabSize - screenColumn % this.$tabSize;
    };
    this.screenToDocumentRow = function (screenRow, screenColumn) {
      return this.screenToDocumentPosition(screenRow, screenColumn).row;
    };
    this.screenToDocumentColumn = function (screenRow, screenColumn) {
      return this.screenToDocumentPosition(screenRow, screenColumn).column;
    };
    this.screenToDocumentPosition = function (screenRow, screenColumn) {
      if (screenRow < 0)
        return {
          row: 0,
          column: 0
        };
      var line;
      var docRow = 0;
      var docColumn = 0;
      var column;
      var row = 0;
      var rowLength = 0;
      var rowCache = this.$screenRowCache;
      var i = this.$getRowCacheIndex(rowCache, screenRow);
      var l = rowCache.length;
      if (l && i >= 0) {
        var row = rowCache[i];
        var docRow = this.$docRowCache[i];
        var doCache = screenRow > rowCache[l - 1];
      } else {
        var doCache = !l;
      }
      var maxRow = this.getLength() - 1;
      var foldLine = this.getNextFoldLine(docRow);
      var foldStart = foldLine ? foldLine.start.row : Infinity;
      while (row <= screenRow) {
        rowLength = this.getRowLength(docRow);
        if (row + rowLength > screenRow || docRow >= maxRow) {
          break;
        } else {
          row += rowLength;
          docRow++;
          if (docRow > foldStart) {
            docRow = foldLine.end.row + 1;
            foldLine = this.getNextFoldLine(docRow, foldLine);
            foldStart = foldLine ? foldLine.start.row : Infinity;
          }
        }
        if (doCache) {
          this.$docRowCache.push(docRow);
          this.$screenRowCache.push(row);
        }
      }
      if (foldLine && foldLine.start.row <= docRow) {
        line = this.getFoldDisplayLine(foldLine);
        docRow = foldLine.start.row;
      } else if (row + rowLength <= screenRow || docRow > maxRow) {
        return {
          row: maxRow,
          column: this.getLine(maxRow).length
        };
      } else {
        line = this.getLine(docRow);
        foldLine = null;
      }
      if (this.$useWrapMode) {
        var splits = this.$wrapData[docRow];
        if (splits) {
          var splitIndex = Math.floor(screenRow - row);
          column = splits[splitIndex];
          if (splitIndex > 0 && splits.length) {
            docColumn = splits[splitIndex - 1] || splits[splits.length - 1];
            line = line.substring(docColumn);
          }
        }
      }
      docColumn += this.$getStringScreenWidth(line, screenColumn)[1];
      if (this.$useWrapMode && docColumn >= column)
        docColumn = column - 1;
      if (foldLine)
        return foldLine.idxToPosition(docColumn);
      return {
        row: docRow,
        column: docColumn
      };
    };
    this.documentToScreenPosition = function (docRow, docColumn) {
      if (typeof docColumn === 'undefined')
        var pos = this.$clipPositionToDocument(docRow.row, docRow.column);
      else
        pos = this.$clipPositionToDocument(docRow, docColumn);
      docRow = pos.row;
      docColumn = pos.column;
      var screenRow = 0;
      var foldStartRow = null;
      var fold = null;
      fold = this.getFoldAt(docRow, docColumn, 1);
      if (fold) {
        docRow = fold.start.row;
        docColumn = fold.start.column;
      }
      var rowEnd, row = 0;
      var rowCache = this.$docRowCache;
      var i = this.$getRowCacheIndex(rowCache, docRow);
      var l = rowCache.length;
      if (l && i >= 0) {
        var row = rowCache[i];
        var screenRow = this.$screenRowCache[i];
        var doCache = docRow > rowCache[l - 1];
      } else {
        var doCache = !l;
      }
      var foldLine = this.getNextFoldLine(row);
      var foldStart = foldLine ? foldLine.start.row : Infinity;
      while (row < docRow) {
        if (row >= foldStart) {
          rowEnd = foldLine.end.row + 1;
          if (rowEnd > docRow)
            break;
          foldLine = this.getNextFoldLine(rowEnd, foldLine);
          foldStart = foldLine ? foldLine.start.row : Infinity;
        } else {
          rowEnd = row + 1;
        }
        screenRow += this.getRowLength(row);
        row = rowEnd;
        if (doCache) {
          this.$docRowCache.push(row);
          this.$screenRowCache.push(screenRow);
        }
      }
      var textLine = '';
      if (foldLine && row >= foldStart) {
        textLine = this.getFoldDisplayLine(foldLine, docRow, docColumn);
        foldStartRow = foldLine.start.row;
      } else {
        textLine = this.getLine(docRow).substring(0, docColumn);
        foldStartRow = docRow;
      }
      if (this.$useWrapMode) {
        var wrapRow = this.$wrapData[foldStartRow];
        if (wrapRow) {
          var screenRowOffset = 0;
          while (textLine.length >= wrapRow[screenRowOffset]) {
            screenRow++;
            screenRowOffset++;
          }
          textLine = textLine.substring(wrapRow[screenRowOffset - 1] || 0, textLine.length);
        }
      }
      return {
        row: screenRow,
        column: this.$getStringScreenWidth(textLine)[0]
      };
    };
    this.documentToScreenColumn = function (row, docColumn) {
      return this.documentToScreenPosition(row, docColumn).column;
    };
    this.documentToScreenRow = function (docRow, docColumn) {
      return this.documentToScreenPosition(docRow, docColumn).row;
    };
    this.getScreenLength = function () {
      var screenRows = 0;
      var fold = null;
      if (!this.$useWrapMode) {
        screenRows = this.getLength();
        var foldData = this.$foldData;
        for (var i = 0; i < foldData.length; i++) {
          fold = foldData[i];
          screenRows -= fold.end.row - fold.start.row;
        }
      } else {
        var lastRow = this.$wrapData.length;
        var row = 0, i = 0;
        var fold = this.$foldData[i++];
        var foldStart = fold ? fold.start.row : Infinity;
        while (row < lastRow) {
          var splits = this.$wrapData[row];
          screenRows += splits ? splits.length + 1 : 1;
          row++;
          if (row > foldStart) {
            row = fold.end.row + 1;
            fold = this.$foldData[i++];
            foldStart = fold ? fold.start.row : Infinity;
          }
        }
      }
      if (this.lineWidgets)
        screenRows += this.$getWidgetScreenLength();
      return screenRows;
    };
    this.$setFontMetrics = function (fm) {
    };
    function isFullWidth(c) {
      if (c < 4352)
        return false;
      return c >= 4352 && c <= 4447 || c >= 4515 && c <= 4519 || c >= 4602 && c <= 4607 || c >= 9001 && c <= 9002 || c >= 11904 && c <= 11929 || c >= 11931 && c <= 12019 || c >= 12032 && c <= 12245 || c >= 12272 && c <= 12283 || c >= 12288 && c <= 12350 || c >= 12353 && c <= 12438 || c >= 12441 && c <= 12543 || c >= 12549 && c <= 12589 || c >= 12593 && c <= 12686 || c >= 12688 && c <= 12730 || c >= 12736 && c <= 12771 || c >= 12784 && c <= 12830 || c >= 12832 && c <= 12871 || c >= 12880 && c <= 13054 || c >= 13056 && c <= 19903 || c >= 19968 && c <= 42124 || c >= 42128 && c <= 42182 || c >= 43360 && c <= 43388 || c >= 44032 && c <= 55203 || c >= 55216 && c <= 55238 || c >= 55243 && c <= 55291 || c >= 63744 && c <= 64255 || c >= 65040 && c <= 65049 || c >= 65072 && c <= 65106 || c >= 65108 && c <= 65126 || c >= 65128 && c <= 65131 || c >= 65281 && c <= 65376 || c >= 65504 && c <= 65510;
    }
    ;
  }.call(EditSession.prototype));
  require('./edit_session/folding').Folding.call(EditSession.prototype);
  require('./edit_session/bracket_match').BracketMatch.call(EditSession.prototype);
  config.defineOptions(EditSession.prototype, 'session', {
    wrap: {
      set: function (value) {
        if (!value || value == 'off')
          value = false;
        else if (value == 'free')
          value = true;
        else if (value == 'printMargin')
          value = -1;
        else if (typeof value == 'string')
          value = parseInt(value, 10) || false;
        if (this.$wrap == value)
          return;
        if (!value) {
          this.setUseWrapMode(false);
        } else {
          var col = typeof value == 'number' ? value : null;
          this.setWrapLimitRange(col, col);
          this.setUseWrapMode(true);
        }
        this.$wrap = value;
      },
      get: function () {
        if (this.getUseWrapMode()) {
          if (this.$wrap == -1)
            return 'printMargin';
          if (!this.getWrapLimitRange().min)
            return 'free';
          return this.$wrap;
        }
        return 'off';
      },
      handlesSet: true
    },
    wrapMethod: {
      set: function (val) {
        val = val == 'auto' ? this.$mode.type != 'text' : val != 'text';
        if (val != this.$wrapAsCode) {
          this.$wrapAsCode = val;
          if (this.$useWrapMode) {
            this.$modified = true;
            this.$resetRowCache(0);
            this.$updateWrapData(0, this.getLength() - 1);
          }
        }
      },
      initialValue: 'auto'
    },
    firstLineNumber: {
      set: function () {
        this._signal('changeBreakpoint');
      },
      initialValue: 1
    },
    useWorker: {
      set: function (useWorker) {
        this.$useWorker = useWorker;
        this.$stopWorker();
        if (useWorker)
          this.$startWorker();
      },
      initialValue: true
    },
    useSoftTabs: { initialValue: true },
    tabSize: {
      set: function (tabSize) {
        if (isNaN(tabSize) || this.$tabSize === tabSize)
          return;
        this.$modified = true;
        this.$rowLengthCache = [];
        this.$tabSize = tabSize;
        this._signal('changeTabSize');
      },
      initialValue: 4,
      handlesSet: true
    },
    overwrite: {
      set: function (val) {
        this._signal('changeOverwrite');
      },
      initialValue: false
    },
    newLineMode: {
      set: function (val) {
        this.doc.setNewLineMode(val);
      },
      get: function () {
        return this.doc.getNewLineMode();
      },
      handlesSet: true
    },
    mode: {
      set: function (val) {
        this.setMode(val);
      },
      get: function () {
        return this.$modeId;
      }
    }
  });
  exports.EditSession = EditSession;
});
ace.define('ace/commands/command_manager', [
  'require',
  'exports',
  'module',
  'ace/lib/oop',
  'ace/keyboard/hash_handler',
  'ace/lib/event_emitter'
], function (require, exports, module) {
  var oop = require('../lib/oop');
  var HashHandler = require('../keyboard/hash_handler').HashHandler;
  var EventEmitter = require('../lib/event_emitter').EventEmitter;
  var CommandManager = function (platform, commands) {
    HashHandler.call(this, commands, platform);
    this.byName = this.commands;
    this.setDefaultHandler('exec', function (e) {
      return e.command.exec(e.editor, e.args || {});
    });
  };
  oop.inherits(CommandManager, HashHandler);
  (function () {
    oop.implement(this, EventEmitter);
    this.exec = function (command, editor, args) {
      if (typeof command === 'string')
        command = this.commands[command];
      if (!command)
        return false;
      if (editor && editor.$readOnly && !command.readOnly)
        return false;
      var e = {
          editor: editor,
          command: command,
          args: args
        };
      var retvalue = this._emit('exec', e);
      this._signal('afterExec', e);
      return retvalue === false ? false : true;
    };
    this.toggleRecording = function (editor) {
      if (this.$inReplay)
        return;
      editor && editor._emit('changeStatus');
      if (this.recording) {
        this.macro.pop();
        this.removeEventListener('exec', this.$addCommandToMacro);
        if (!this.macro.length)
          this.macro = this.oldMacro;
        return this.recording = false;
      }
      if (!this.$addCommandToMacro) {
        this.$addCommandToMacro = function (e) {
          this.macro.push([
            e.command,
            e.args
          ]);
        }.bind(this);
      }
      this.oldMacro = this.macro;
      this.macro = [];
      this.on('exec', this.$addCommandToMacro);
      return this.recording = true;
    };
    this.replay = function (editor) {
      if (this.$inReplay || !this.macro)
        return;
      if (this.recording)
        return this.toggleRecording(editor);
      try {
        this.$inReplay = true;
        this.macro.forEach(function (x) {
          if (typeof x == 'string')
            this.exec(x, editor);
          else
            this.exec(x[0], editor, x[1]);
        }, this);
      } finally {
        this.$inReplay = false;
      }
    };
    this.trimMacro = function (m) {
      return m.map(function (x) {
        if (typeof x[0] != 'string')
          x[0] = x[0].name;
        if (!x[1])
          x = x[0];
        return x;
      });
    };
  }.call(CommandManager.prototype));
  exports.CommandManager = CommandManager;
});
ace.define('ace/keyboard/keybinding', [
  'require',
  'exports',
  'module',
  'ace/lib/keys',
  'ace/lib/event'
], function (require, exports, module) {
  var keyUtil = require('../lib/keys');
  var event = require('../lib/event');
  var KeyBinding = function (editor) {
    this.$editor = editor;
    this.$data = {};
    this.$handlers = [];
    this.setDefaultHandler(editor.commands);
  };
  (function () {
    this.setDefaultHandler = function (kb) {
      this.removeKeyboardHandler(this.$defaultHandler);
      this.$defaultHandler = kb;
      this.addKeyboardHandler(kb, 0);
      this.$data = { editor: this.$editor };
    };
    this.setKeyboardHandler = function (kb) {
      var h = this.$handlers;
      if (h[h.length - 1] == kb)
        return;
      while (h[h.length - 1] && h[h.length - 1] != this.$defaultHandler)
        this.removeKeyboardHandler(h[h.length - 1]);
      this.addKeyboardHandler(kb, 1);
    };
    this.addKeyboardHandler = function (kb, pos) {
      if (!kb)
        return;
      if (typeof kb == 'function' && !kb.handleKeyboard)
        kb.handleKeyboard = kb;
      var i = this.$handlers.indexOf(kb);
      if (i != -1)
        this.$handlers.splice(i, 1);
      if (pos == undefined)
        this.$handlers.push(kb);
      else
        this.$handlers.splice(pos, 0, kb);
      if (i == -1 && kb.attach)
        kb.attach(this.$editor);
    };
    this.removeKeyboardHandler = function (kb) {
      var i = this.$handlers.indexOf(kb);
      if (i == -1)
        return false;
      this.$handlers.splice(i, 1);
      kb.detach && kb.detach(this.$editor);
      return true;
    };
    this.getKeyboardHandler = function () {
      return this.$handlers[this.$handlers.length - 1];
    };
    this.$callKeyboardHandlers = function (hashId, keyString, keyCode, e) {
      var toExecute;
      var success = false;
      var commands = this.$editor.commands;
      for (var i = this.$handlers.length; i--;) {
        toExecute = this.$handlers[i].handleKeyboard(this.$data, hashId, keyString, keyCode, e);
        if (!toExecute || !toExecute.command)
          continue;
        if (toExecute.command == 'null') {
          success = true;
        } else {
          success = commands.exec(toExecute.command, this.$editor, toExecute.args, e);
        }
        if (success && e && hashId != -1 && toExecute.passEvent != true && toExecute.command.passEvent != true) {
          event.stopEvent(e);
        }
        if (success)
          break;
      }
      return success;
    };
    this.onCommandKey = function (e, hashId, keyCode) {
      var keyString = keyUtil.keyCodeToString(keyCode);
      this.$callKeyboardHandlers(hashId, keyString, keyCode, e);
    };
    this.onTextInput = function (text) {
      var success = this.$callKeyboardHandlers(-1, text);
      if (!success)
        this.$editor.commands.exec('insertstring', this.$editor, text);
    };
  }.call(KeyBinding.prototype));
  exports.KeyBinding = KeyBinding;
});
ace.define('ace/keyboard/hash_handler', [
  'require',
  'exports',
  'module',
  'ace/lib/keys',
  'ace/lib/useragent'
], function (require, exports, module) {
  var keyUtil = require('../lib/keys');
  var useragent = require('../lib/useragent');
  function HashHandler(config, platform) {
    this.platform = platform || (useragent.isMac ? 'mac' : 'win');
    this.commands = {};
    this.commandKeyBinding = {};
    if (this.__defineGetter__ && this.__defineSetter__ && typeof console != 'undefined' && console.error) {
      var warned = false;
      var warn = function () {
        if (!warned) {
          warned = true;
          console.error('commmandKeyBinding has too many m\'s. use commandKeyBinding');
        }
      };
      this.__defineGetter__('commmandKeyBinding', function () {
        warn();
        return this.commandKeyBinding;
      });
      this.__defineSetter__('commmandKeyBinding', function (val) {
        warn();
        return this.commandKeyBinding = val;
      });
    } else {
      this.commmandKeyBinding = this.commandKeyBinding;
    }
    this.addCommands(config);
  }
  ;
  (function () {
    this.addCommand = function (command) {
      if (this.commands[command.name])
        this.removeCommand(command);
      this.commands[command.name] = command;
      if (command.bindKey)
        this._buildKeyHash(command);
    };
    this.removeCommand = function (command) {
      var name = typeof command === 'string' ? command : command.name;
      command = this.commands[name];
      delete this.commands[name];
      var ckb = this.commandKeyBinding;
      for (var hashId in ckb) {
        for (var key in ckb[hashId]) {
          if (ckb[hashId][key] == command)
            delete ckb[hashId][key];
        }
      }
    };
    this.bindKey = function (key, command) {
      if (!key)
        return;
      if (typeof command == 'function') {
        this.addCommand({
          exec: command,
          bindKey: key,
          name: command.name || key
        });
        return;
      }
      var ckb = this.commandKeyBinding;
      key.split('|').forEach(function (keyPart) {
        var binding = this.parseKeys(keyPart, command);
        var hashId = binding.hashId;
        (ckb[hashId] || (ckb[hashId] = {}))[binding.key] = command;
      }, this);
    };
    this.addCommands = function (commands) {
      commands && Object.keys(commands).forEach(function (name) {
        var command = commands[name];
        if (!command)
          return;
        if (typeof command === 'string')
          return this.bindKey(command, name);
        if (typeof command === 'function')
          command = { exec: command };
        if (typeof command !== 'object')
          return;
        if (!command.name)
          command.name = name;
        this.addCommand(command);
      }, this);
    };
    this.removeCommands = function (commands) {
      Object.keys(commands).forEach(function (name) {
        this.removeCommand(commands[name]);
      }, this);
    };
    this.bindKeys = function (keyList) {
      Object.keys(keyList).forEach(function (key) {
        this.bindKey(key, keyList[key]);
      }, this);
    };
    this._buildKeyHash = function (command) {
      var binding = command.bindKey;
      if (!binding)
        return;
      var key = typeof binding == 'string' ? binding : binding[this.platform];
      this.bindKey(key, command);
    };
    this.parseKeys = function (keys) {
      if (keys.indexOf(' ') != -1)
        keys = keys.split(/\s+/).pop();
      var parts = keys.toLowerCase().split(/[\-\+]([\-\+])?/).filter(function (x) {
          return x;
        });
      var key = parts.pop();
      var keyCode = keyUtil[key];
      if (keyUtil.FUNCTION_KEYS[keyCode])
        key = keyUtil.FUNCTION_KEYS[keyCode].toLowerCase();
      else if (!parts.length)
        return {
          key: key,
          hashId: -1
        };
      else if (parts.length == 1 && parts[0] == 'shift')
        return {
          key: key.toUpperCase(),
          hashId: -1
        };
      var hashId = 0;
      for (var i = parts.length; i--;) {
        var modifier = keyUtil.KEY_MODS[parts[i]];
        if (modifier == null) {
          if (typeof console != 'undefined')
            console.error('invalid modifier ' + parts[i] + ' in ' + keys);
          return false;
        }
        hashId |= modifier;
      }
      return {
        key: key,
        hashId: hashId
      };
    };
    this.findKeyCommand = function findKeyCommand(hashId, keyString) {
      var ckbr = this.commandKeyBinding;
      return ckbr[hashId] && ckbr[hashId][keyString];
    };
    this.handleKeyboard = function (data, hashId, keyString, keyCode) {
      return { command: this.findKeyCommand(hashId, keyString) };
    };
  }.call(HashHandler.prototype));
  exports.HashHandler = HashHandler;
});
ace.define('ace/mouse/fold_handler', [
  'require',
  'exports',
  'module'
], function (require, exports, module) {
  function FoldHandler(editor) {
    editor.on('click', function (e) {
      var position = e.getDocumentPosition();
      var session = editor.session;
      var fold = session.getFoldAt(position.row, position.column, 1);
      if (fold) {
        if (e.getAccelKey())
          session.removeFold(fold);
        else
          session.expandFold(fold);
        e.stop();
      }
    });
    editor.on('gutterclick', function (e) {
      var gutterRegion = editor.renderer.$gutterLayer.getRegion(e);
      if (gutterRegion == 'foldWidgets') {
        var row = e.getDocumentPosition().row;
        var session = editor.session;
        if (session.foldWidgets && session.foldWidgets[row])
          editor.session.onFoldWidgetClick(row, e);
        if (!editor.isFocused())
          editor.focus();
        e.stop();
      }
    });
    editor.on('gutterdblclick', function (e) {
      var gutterRegion = editor.renderer.$gutterLayer.getRegion(e);
      if (gutterRegion == 'foldWidgets') {
        var row = e.getDocumentPosition().row;
        var session = editor.session;
        var data = session.getParentFoldRangeData(row, true);
        var range = data.range || data.firstRange;
        if (range) {
          row = range.start.row;
          var fold = session.getFoldAt(row, session.getLine(row).length, 1);
          if (fold) {
            session.removeFold(fold);
          } else {
            session.addFold('...', range);
            editor.renderer.scrollCursorIntoView({
              row: range.start.row,
              column: 0
            });
          }
        }
        e.stop();
      }
    });
  }
  exports.FoldHandler = FoldHandler;
});
ace.define('ace/commands/default_commands', [
  'require',
  'exports',
  'module',
  'ace/lib/lang',
  'ace/config'
], function (require, exports, module) {
  var lang = require('../lib/lang');
  var config = require('../config');
  function bindKey(win, mac) {
    return {
      win: win,
      mac: mac
    };
  }
  exports.commands = [
    {
      name: 'showSettingsMenu',
      bindKey: bindKey('Ctrl-,', 'Command-,'),
      exec: function (editor) {
        config.loadModule('ace/ext/settings_menu', function (module) {
          module.init(editor);
          editor.showSettingsMenu();
        });
      },
      readOnly: true
    },
    {
      name: 'goToNextError',
      bindKey: bindKey('Alt-E', 'Ctrl-E'),
      exec: function (editor) {
        config.loadModule('ace/ext/error_marker', function (module) {
          module.showErrorMarker(editor, 1);
        });
      },
      scrollIntoView: 'animate',
      readOnly: true
    },
    {
      name: 'goToPreviousError',
      bindKey: bindKey('Alt-Shift-E', 'Ctrl-Shift-E'),
      exec: function (editor) {
        config.loadModule('ace/ext/error_marker', function (module) {
          module.showErrorMarker(editor, -1);
        });
      },
      scrollIntoView: 'animate',
      readOnly: true
    },
    {
      name: 'selectall',
      bindKey: bindKey('Ctrl-A', 'Command-A'),
      exec: function (editor) {
        editor.selectAll();
      },
      readOnly: true
    },
    {
      name: 'centerselection',
      bindKey: bindKey(null, 'Ctrl-L'),
      exec: function (editor) {
        editor.centerSelection();
      },
      readOnly: true
    },
    {
      name: 'gotoline',
      bindKey: bindKey('Ctrl-L', 'Command-L'),
      exec: function (editor) {
        var line = parseInt(prompt('Enter line number:'), 10);
        if (!isNaN(line)) {
          editor.gotoLine(line);
        }
      },
      readOnly: true
    },
    {
      name: 'fold',
      bindKey: bindKey('Alt-L|Ctrl-F1', 'Command-Alt-L|Command-F1'),
      exec: function (editor) {
        editor.session.toggleFold(false);
      },
      scrollIntoView: 'center',
      readOnly: true
    },
    {
      name: 'unfold',
      bindKey: bindKey('Alt-Shift-L|Ctrl-Shift-F1', 'Command-Alt-Shift-L|Command-Shift-F1'),
      exec: function (editor) {
        editor.session.toggleFold(true);
      },
      scrollIntoView: 'center',
      readOnly: true
    },
    {
      name: 'toggleFoldWidget',
      bindKey: bindKey('F2', 'F2'),
      exec: function (editor) {
        editor.session.toggleFoldWidget();
      },
      scrollIntoView: 'center',
      readOnly: true
    },
    {
      name: 'toggleParentFoldWidget',
      bindKey: bindKey('Alt-F2', 'Alt-F2'),
      exec: function (editor) {
        editor.session.toggleFoldWidget(true);
      },
      scrollIntoView: 'center',
      readOnly: true
    },
    {
      name: 'foldall',
      bindKey: bindKey('Ctrl-Alt-0', 'Ctrl-Command-Option-0'),
      exec: function (editor) {
        editor.session.foldAll();
      },
      scrollIntoView: 'center',
      readOnly: true
    },
    {
      name: 'foldOther',
      bindKey: bindKey('Alt-0', 'Command-Option-0'),
      exec: function (editor) {
        editor.session.foldAll();
        editor.session.unfold(editor.selection.getAllRanges());
      },
      scrollIntoView: 'center',
      readOnly: true
    },
    {
      name: 'unfoldall',
      bindKey: bindKey('Alt-Shift-0', 'Command-Option-Shift-0'),
      exec: function (editor) {
        editor.session.unfold();
      },
      scrollIntoView: 'center',
      readOnly: true
    },
    {
      name: 'findnext',
      bindKey: bindKey('Ctrl-K', 'Command-G'),
      exec: function (editor) {
        editor.findNext();
      },
      readOnly: true
    },
    {
      name: 'findprevious',
      bindKey: bindKey('Ctrl-Shift-K', 'Command-Shift-G'),
      exec: function (editor) {
        editor.findPrevious();
      },
      readOnly: true
    },
    {
      name: 'selectOrFindNext',
      bindKey: bindKey('ALt-K', 'Ctrl-G'),
      exec: function (editor) {
        if (editor.selection.isEmpty())
          editor.selection.selectWord();
        else
          editor.findNext();
      },
      readOnly: true
    },
    {
      name: 'selectOrFindPrevious',
      bindKey: bindKey('Alt-Shift-K', 'Ctrl-Shift-G'),
      exec: function (editor) {
        if (editor.selection.isEmpty())
          editor.selection.selectWord();
        else
          editor.findPrevious();
      },
      readOnly: true
    },
    {
      name: 'find',
      bindKey: bindKey('Ctrl-F', 'Command-F'),
      exec: function (editor) {
        config.loadModule('ace/ext/searchbox', function (e) {
          e.Search(editor);
        });
      },
      readOnly: true
    },
    {
      name: 'overwrite',
      bindKey: 'Insert',
      exec: function (editor) {
        editor.toggleOverwrite();
      },
      readOnly: true
    },
    {
      name: 'selecttostart',
      bindKey: bindKey('Ctrl-Shift-Home', 'Command-Shift-Up'),
      exec: function (editor) {
        editor.getSelection().selectFileStart();
      },
      multiSelectAction: 'forEach',
      readOnly: true,
      scrollIntoView: 'animate',
      aceCommandGroup: 'fileJump'
    },
    {
      name: 'gotostart',
      bindKey: bindKey('Ctrl-Home', 'Command-Home|Command-Up'),
      exec: function (editor) {
        editor.navigateFileStart();
      },
      multiSelectAction: 'forEach',
      readOnly: true,
      scrollIntoView: 'animate',
      aceCommandGroup: 'fileJump'
    },
    {
      name: 'selectup',
      bindKey: bindKey('Shift-Up', 'Shift-Up'),
      exec: function (editor) {
        editor.getSelection().selectUp();
      },
      multiSelectAction: 'forEach',
      readOnly: true
    },
    {
      name: 'golineup',
      bindKey: bindKey('Up', 'Up|Ctrl-P'),
      exec: function (editor, args) {
        editor.navigateUp(args.times);
      },
      multiSelectAction: 'forEach',
      readOnly: true
    },
    {
      name: 'selecttoend',
      bindKey: bindKey('Ctrl-Shift-End', 'Command-Shift-Down'),
      exec: function (editor) {
        editor.getSelection().selectFileEnd();
      },
      multiSelectAction: 'forEach',
      readOnly: true,
      scrollIntoView: 'animate',
      aceCommandGroup: 'fileJump'
    },
    {
      name: 'gotoend',
      bindKey: bindKey('Ctrl-End', 'Command-End|Command-Down'),
      exec: function (editor) {
        editor.navigateFileEnd();
      },
      multiSelectAction: 'forEach',
      readOnly: true,
      scrollIntoView: 'animate',
      aceCommandGroup: 'fileJump'
    },
    {
      name: 'selectdown',
      bindKey: bindKey('Shift-Down', 'Shift-Down'),
      exec: function (editor) {
        editor.getSelection().selectDown();
      },
      multiSelectAction: 'forEach',
      scrollIntoView: 'cursor',
      readOnly: true
    },
    {
      name: 'golinedown',
      bindKey: bindKey('Down', 'Down|Ctrl-N'),
      exec: function (editor, args) {
        editor.navigateDown(args.times);
      },
      multiSelectAction: 'forEach',
      scrollIntoView: 'cursor',
      readOnly: true
    },
    {
      name: 'selectwordleft',
      bindKey: bindKey('Ctrl-Shift-Left', 'Option-Shift-Left'),
      exec: function (editor) {
        editor.getSelection().selectWordLeft();
      },
      multiSelectAction: 'forEach',
      scrollIntoView: 'cursor',
      readOnly: true
    },
    {
      name: 'gotowordleft',
      bindKey: bindKey('Ctrl-Left', 'Option-Left'),
      exec: function (editor) {
        editor.navigateWordLeft();
      },
      multiSelectAction: 'forEach',
      scrollIntoView: 'cursor',
      readOnly: true
    },
    {
      name: 'selecttolinestart',
      bindKey: bindKey('Alt-Shift-Left', 'Command-Shift-Left'),
      exec: function (editor) {
        editor.getSelection().selectLineStart();
      },
      multiSelectAction: 'forEach',
      scrollIntoView: 'cursor',
      readOnly: true
    },
    {
      name: 'gotolinestart',
      bindKey: bindKey('Alt-Left|Home', 'Command-Left|Home|Ctrl-A'),
      exec: function (editor) {
        editor.navigateLineStart();
      },
      multiSelectAction: 'forEach',
      scrollIntoView: 'cursor',
      readOnly: true
    },
    {
      name: 'selectleft',
      bindKey: bindKey('Shift-Left', 'Shift-Left'),
      exec: function (editor) {
        editor.getSelection().selectLeft();
      },
      multiSelectAction: 'forEach',
      scrollIntoView: 'cursor',
      readOnly: true
    },
    {
      name: 'gotoleft',
      bindKey: bindKey('Left', 'Left|Ctrl-B'),
      exec: function (editor, args) {
        editor.navigateLeft(args.times);
      },
      multiSelectAction: 'forEach',
      scrollIntoView: 'cursor',
      readOnly: true
    },
    {
      name: 'selectwordright',
      bindKey: bindKey('Ctrl-Shift-Right', 'Option-Shift-Right'),
      exec: function (editor) {
        editor.getSelection().selectWordRight();
      },
      multiSelectAction: 'forEach',
      scrollIntoView: 'cursor',
      readOnly: true
    },
    {
      name: 'gotowordright',
      bindKey: bindKey('Ctrl-Right', 'Option-Right'),
      exec: function (editor) {
        editor.navigateWordRight();
      },
      multiSelectAction: 'forEach',
      scrollIntoView: 'cursor',
      readOnly: true
    },
    {
      name: 'selecttolineend',
      bindKey: bindKey('Alt-Shift-Right', 'Command-Shift-Right'),
      exec: function (editor) {
        editor.getSelection().selectLineEnd();
      },
      multiSelectAction: 'forEach',
      scrollIntoView: 'cursor',
      readOnly: true
    },
    {
      name: 'gotolineend',
      bindKey: bindKey('Alt-Right|End', 'Command-Right|End|Ctrl-E'),
      exec: function (editor) {
        editor.navigateLineEnd();
      },
      multiSelectAction: 'forEach',
      scrollIntoView: 'cursor',
      readOnly: true
    },
    {
      name: 'selectright',
      bindKey: bindKey('Shift-Right', 'Shift-Right'),
      exec: function (editor) {
        editor.getSelection().selectRight();
      },
      multiSelectAction: 'forEach',
      scrollIntoView: 'cursor',
      readOnly: true
    },
    {
      name: 'gotoright',
      bindKey: bindKey('Right', 'Right|Ctrl-F'),
      exec: function (editor, args) {
        editor.navigateRight(args.times);
      },
      multiSelectAction: 'forEach',
      scrollIntoView: 'cursor',
      readOnly: true
    },
    {
      name: 'selectpagedown',
      bindKey: 'Shift-PageDown',
      exec: function (editor) {
        editor.selectPageDown();
      },
      readOnly: true
    },
    {
      name: 'pagedown',
      bindKey: bindKey(null, 'Option-PageDown'),
      exec: function (editor) {
        editor.scrollPageDown();
      },
      readOnly: true
    },
    {
      name: 'gotopagedown',
      bindKey: bindKey('PageDown', 'PageDown|Ctrl-V'),
      exec: function (editor) {
        editor.gotoPageDown();
      },
      readOnly: true
    },
    {
      name: 'selectpageup',
      bindKey: 'Shift-PageUp',
      exec: function (editor) {
        editor.selectPageUp();
      },
      readOnly: true
    },
    {
      name: 'pageup',
      bindKey: bindKey(null, 'Option-PageUp'),
      exec: function (editor) {
        editor.scrollPageUp();
      },
      readOnly: true
    },
    {
      name: 'gotopageup',
      bindKey: 'PageUp',
      exec: function (editor) {
        editor.gotoPageUp();
      },
      readOnly: true
    },
    {
      name: 'scrollup',
      bindKey: bindKey('Ctrl-Up', null),
      exec: function (e) {
        e.renderer.scrollBy(0, -2 * e.renderer.layerConfig.lineHeight);
      },
      readOnly: true
    },
    {
      name: 'scrolldown',
      bindKey: bindKey('Ctrl-Down', null),
      exec: function (e) {
        e.renderer.scrollBy(0, 2 * e.renderer.layerConfig.lineHeight);
      },
      readOnly: true
    },
    {
      name: 'selectlinestart',
      bindKey: 'Shift-Home',
      exec: function (editor) {
        editor.getSelection().selectLineStart();
      },
      multiSelectAction: 'forEach',
      scrollIntoView: 'cursor',
      readOnly: true
    },
    {
      name: 'selectlineend',
      bindKey: 'Shift-End',
      exec: function (editor) {
        editor.getSelection().selectLineEnd();
      },
      multiSelectAction: 'forEach',
      scrollIntoView: 'cursor',
      readOnly: true
    },
    {
      name: 'togglerecording',
      bindKey: bindKey('Ctrl-Alt-E', 'Command-Option-E'),
      exec: function (editor) {
        editor.commands.toggleRecording(editor);
      },
      readOnly: true
    },
    {
      name: 'replaymacro',
      bindKey: bindKey('Ctrl-Shift-E', 'Command-Shift-E'),
      exec: function (editor) {
        editor.commands.replay(editor);
      },
      readOnly: true
    },
    {
      name: 'jumptomatching',
      bindKey: bindKey('Ctrl-P', 'Ctrl-Shift-P'),
      exec: function (editor) {
        editor.jumpToMatching();
      },
      multiSelectAction: 'forEach',
      readOnly: true
    },
    {
      name: 'selecttomatching',
      bindKey: bindKey('Ctrl-Shift-P', null),
      exec: function (editor) {
        editor.jumpToMatching(true);
      },
      multiSelectAction: 'forEach',
      readOnly: true
    },
    {
      name: 'cut',
      exec: function (editor) {
        var range = editor.getSelectionRange();
        editor._emit('cut', range);
        if (!editor.selection.isEmpty()) {
          editor.session.remove(range);
          editor.clearSelection();
        }
      },
      scrollIntoView: 'cursor',
      multiSelectAction: 'forEach'
    },
    {
      name: 'removeline',
      bindKey: bindKey('Ctrl-D', 'Command-D'),
      exec: function (editor) {
        editor.removeLines();
      },
      scrollIntoView: 'cursor',
      multiSelectAction: 'forEachLine'
    },
    {
      name: 'duplicateSelection',
      bindKey: bindKey('Ctrl-Shift-D', 'Command-Shift-D'),
      exec: function (editor) {
        editor.duplicateSelection();
      },
      scrollIntoView: 'cursor',
      multiSelectAction: 'forEach'
    },
    {
      name: 'sortlines',
      bindKey: bindKey('Ctrl-Alt-S', 'Command-Alt-S'),
      exec: function (editor) {
        editor.sortLines();
      },
      scrollIntoView: 'selection',
      multiSelectAction: 'forEachLine'
    },
    {
      name: 'togglecomment',
      bindKey: bindKey('Ctrl-/', 'Command-/'),
      exec: function (editor) {
        editor.toggleCommentLines();
      },
      multiSelectAction: 'forEachLine',
      scrollIntoView: 'selectionPart'
    },
    {
      name: 'toggleBlockComment',
      bindKey: bindKey('Ctrl-Shift-/', 'Command-Shift-/'),
      exec: function (editor) {
        editor.toggleBlockComment();
      },
      multiSelectAction: 'forEach',
      scrollIntoView: 'selectionPart'
    },
    {
      name: 'modifyNumberUp',
      bindKey: bindKey('Ctrl-Shift-Up', 'Alt-Shift-Up'),
      exec: function (editor) {
        editor.modifyNumber(1);
      },
      multiSelectAction: 'forEach'
    },
    {
      name: 'modifyNumberDown',
      bindKey: bindKey('Ctrl-Shift-Down', 'Alt-Shift-Down'),
      exec: function (editor) {
        editor.modifyNumber(-1);
      },
      multiSelectAction: 'forEach'
    },
    {
      name: 'replace',
      bindKey: bindKey('Ctrl-H', 'Command-Option-F'),
      exec: function (editor) {
        config.loadModule('ace/ext/searchbox', function (e) {
          e.Search(editor, true);
        });
      }
    },
    {
      name: 'undo',
      bindKey: bindKey('Ctrl-Z', 'Command-Z'),
      exec: function (editor) {
        editor.undo();
      }
    },
    {
      name: 'redo',
      bindKey: bindKey('Ctrl-Shift-Z|Ctrl-Y', 'Command-Shift-Z|Command-Y'),
      exec: function (editor) {
        editor.redo();
      }
    },
    {
      name: 'copylinesup',
      bindKey: bindKey('Alt-Shift-Up', 'Command-Option-Up'),
      exec: function (editor) {
        editor.copyLinesUp();
      },
      scrollIntoView: 'cursor'
    },
    {
      name: 'movelinesup',
      bindKey: bindKey('Alt-Up', 'Option-Up'),
      exec: function (editor) {
        editor.moveLinesUp();
      },
      scrollIntoView: 'cursor'
    },
    {
      name: 'copylinesdown',
      bindKey: bindKey('Alt-Shift-Down', 'Command-Option-Down'),
      exec: function (editor) {
        editor.copyLinesDown();
      },
      scrollIntoView: 'cursor'
    },
    {
      name: 'movelinesdown',
      bindKey: bindKey('Alt-Down', 'Option-Down'),
      exec: function (editor) {
        editor.moveLinesDown();
      },
      scrollIntoView: 'cursor'
    },
    {
      name: 'del',
      bindKey: bindKey('Delete', 'Delete|Ctrl-D|Shift-Delete'),
      exec: function (editor) {
        editor.remove('right');
      },
      multiSelectAction: 'forEach',
      scrollIntoView: 'cursor'
    },
    {
      name: 'backspace',
      bindKey: bindKey('Shift-Backspace|Backspace', 'Ctrl-Backspace|Shift-Backspace|Backspace|Ctrl-H'),
      exec: function (editor) {
        editor.remove('left');
      },
      multiSelectAction: 'forEach',
      scrollIntoView: 'cursor'
    },
    {
      name: 'cut_or_delete',
      bindKey: bindKey('Shift-Delete', null),
      exec: function (editor) {
        if (editor.selection.isEmpty()) {
          editor.remove('left');
        } else {
          return false;
        }
      },
      multiSelectAction: 'forEach',
      scrollIntoView: 'cursor'
    },
    {
      name: 'removetolinestart',
      bindKey: bindKey('Alt-Backspace', 'Command-Backspace'),
      exec: function (editor) {
        editor.removeToLineStart();
      },
      multiSelectAction: 'forEach',
      scrollIntoView: 'cursor'
    },
    {
      name: 'removetolineend',
      bindKey: bindKey('Alt-Delete', 'Ctrl-K'),
      exec: function (editor) {
        editor.removeToLineEnd();
      },
      multiSelectAction: 'forEach',
      scrollIntoView: 'cursor'
    },
    {
      name: 'removewordleft',
      bindKey: bindKey('Ctrl-Backspace', 'Alt-Backspace|Ctrl-Alt-Backspace'),
      exec: function (editor) {
        editor.removeWordLeft();
      },
      multiSelectAction: 'forEach',
      scrollIntoView: 'cursor'
    },
    {
      name: 'removewordright',
      bindKey: bindKey('Ctrl-Delete', 'Alt-Delete'),
      exec: function (editor) {
        editor.removeWordRight();
      },
      multiSelectAction: 'forEach',
      scrollIntoView: 'cursor'
    },
    {
      name: 'outdent',
      bindKey: bindKey('Shift-Tab', 'Shift-Tab'),
      exec: function (editor) {
        editor.blockOutdent();
      },
      multiSelectAction: 'forEach',
      scrollIntoView: 'selectionPart'
    },
    {
      name: 'indent',
      bindKey: bindKey('Tab', 'Tab'),
      exec: function (editor) {
        editor.indent();
      },
      multiSelectAction: 'forEach',
      scrollIntoView: 'selectionPart'
    },
    {
      name: 'blockoutdent',
      bindKey: bindKey('Ctrl-[', 'Ctrl-['),
      exec: function (editor) {
        editor.blockOutdent();
      },
      multiSelectAction: 'forEachLine',
      scrollIntoView: 'selectionPart'
    },
    {
      name: 'blockindent',
      bindKey: bindKey('Ctrl-]', 'Ctrl-]'),
      exec: function (editor) {
        editor.blockIndent();
      },
      multiSelectAction: 'forEachLine',
      scrollIntoView: 'selectionPart'
    },
    {
      name: 'insertstring',
      exec: function (editor, str) {
        editor.insert(str);
      },
      multiSelectAction: 'forEach',
      scrollIntoView: 'cursor'
    },
    {
      name: 'inserttext',
      exec: function (editor, args) {
        editor.insert(lang.stringRepeat(args.text || '', args.times || 1));
      },
      multiSelectAction: 'forEach',
      scrollIntoView: 'cursor'
    },
    {
      name: 'splitline',
      bindKey: bindKey(null, 'Ctrl-O'),
      exec: function (editor) {
        editor.splitLine();
      },
      multiSelectAction: 'forEach',
      scrollIntoView: 'cursor'
    },
    {
      name: 'transposeletters',
      bindKey: bindKey('Ctrl-T', 'Ctrl-T'),
      exec: function (editor) {
        editor.transposeLetters();
      },
      multiSelectAction: function (editor) {
        editor.transposeSelections(1);
      },
      scrollIntoView: 'cursor'
    },
    {
      name: 'touppercase',
      bindKey: bindKey('Ctrl-U', 'Ctrl-U'),
      exec: function (editor) {
        editor.toUpperCase();
      },
      multiSelectAction: 'forEach',
      scrollIntoView: 'cursor'
    },
    {
      name: 'tolowercase',
      bindKey: bindKey('Ctrl-Shift-U', 'Ctrl-Shift-U'),
      exec: function (editor) {
        editor.toLowerCase();
      },
      multiSelectAction: 'forEach',
      scrollIntoView: 'cursor'
    }
  ];
});
ace.define('ace/lib/event_emitter', [
  'require',
  'exports',
  'module'
], function (require, exports, module) {
  var EventEmitter = {};
  var stopPropagation = function () {
    this.propagationStopped = true;
  };
  var preventDefault = function () {
    this.defaultPrevented = true;
  };
  EventEmitter._emit = EventEmitter._dispatchEvent = function (eventName, e) {
    this._eventRegistry || (this._eventRegistry = {});
    this._defaultHandlers || (this._defaultHandlers = {});
    var listeners = this._eventRegistry[eventName] || [];
    var defaultHandler = this._defaultHandlers[eventName];
    if (!listeners.length && !defaultHandler)
      return;
    if (typeof e != 'object' || !e)
      e = {};
    if (!e.type)
      e.type = eventName;
    if (!e.stopPropagation)
      e.stopPropagation = stopPropagation;
    if (!e.preventDefault)
      e.preventDefault = preventDefault;
    listeners = listeners.slice();
    for (var i = 0; i < listeners.length; i++) {
      listeners[i](e, this);
      if (e.propagationStopped)
        break;
    }
    if (defaultHandler && !e.defaultPrevented)
      return defaultHandler(e, this);
  };
  EventEmitter._signal = function (eventName, e) {
    var listeners = (this._eventRegistry || {})[eventName];
    if (!listeners)
      return;
    listeners = listeners.slice();
    for (var i = 0; i < listeners.length; i++)
      listeners[i](e, this);
  };
  EventEmitter.once = function (eventName, callback) {
    var _self = this;
    callback && this.addEventListener(eventName, function newCallback() {
      _self.removeEventListener(eventName, newCallback);
      callback.apply(null, arguments);
    });
  };
  EventEmitter.setDefaultHandler = function (eventName, callback) {
    var handlers = this._defaultHandlers;
    if (!handlers)
      handlers = this._defaultHandlers = { _disabled_: {} };
    if (handlers[eventName]) {
      var old = handlers[eventName];
      var disabled = handlers._disabled_[eventName];
      if (!disabled)
        handlers._disabled_[eventName] = disabled = [];
      disabled.push(old);
      var i = disabled.indexOf(callback);
      if (i != -1)
        disabled.splice(i, 1);
    }
    handlers[eventName] = callback;
  };
  EventEmitter.removeDefaultHandler = function (eventName, callback) {
    var handlers = this._defaultHandlers;
    if (!handlers)
      return;
    var disabled = handlers._disabled_[eventName];
    if (handlers[eventName] == callback) {
      var old = handlers[eventName];
      if (disabled)
        this.setDefaultHandler(eventName, disabled.pop());
    } else if (disabled) {
      var i = disabled.indexOf(callback);
      if (i != -1)
        disabled.splice(i, 1);
    }
  };
  EventEmitter.on = EventEmitter.addEventListener = function (eventName, callback, capturing) {
    this._eventRegistry = this._eventRegistry || {};
    var listeners = this._eventRegistry[eventName];
    if (!listeners)
      listeners = this._eventRegistry[eventName] = [];
    if (listeners.indexOf(callback) == -1)
      listeners[capturing ? 'unshift' : 'push'](callback);
    return callback;
  };
  EventEmitter.off = EventEmitter.removeListener = EventEmitter.removeEventListener = function (eventName, callback) {
    this._eventRegistry = this._eventRegistry || {};
    var listeners = this._eventRegistry[eventName];
    if (!listeners)
      return;
    var index = listeners.indexOf(callback);
    if (index !== -1)
      listeners.splice(index, 1);
  };
  EventEmitter.removeAllListeners = function (eventName) {
    if (this._eventRegistry)
      this._eventRegistry[eventName] = [];
  };
  exports.EventEmitter = EventEmitter;
});
ace.define('ace/undomanager', [
  'require',
  'exports',
  'module'
], function (require, exports, module) {
  var UndoManager = function () {
    this.reset();
  };
  (function () {
    this.execute = function (options) {
      var deltas = options.args[0];
      this.$doc = options.args[1];
      if (options.merge && this.hasUndo()) {
        this.dirtyCounter--;
        deltas = this.$undoStack.pop().concat(deltas);
      }
      this.$undoStack.push(deltas);
      this.$redoStack = [];
      if (this.dirtyCounter < 0) {
        this.dirtyCounter = NaN;
      }
      this.dirtyCounter++;
    };
    this.undo = function (dontSelect) {
      var deltas = this.$undoStack.pop();
      var undoSelectionRange = null;
      if (deltas) {
        undoSelectionRange = this.$doc.undoChanges(deltas, dontSelect);
        this.$redoStack.push(deltas);
        this.dirtyCounter--;
      }
      return undoSelectionRange;
    };
    this.redo = function (dontSelect) {
      var deltas = this.$redoStack.pop();
      var redoSelectionRange = null;
      if (deltas) {
        redoSelectionRange = this.$doc.redoChanges(deltas, dontSelect);
        this.$undoStack.push(deltas);
        this.dirtyCounter++;
      }
      return redoSelectionRange;
    };
    this.reset = function () {
      this.$undoStack = [];
      this.$redoStack = [];
      this.dirtyCounter = 0;
    };
    this.hasUndo = function () {
      return this.$undoStack.length > 0;
    };
    this.hasRedo = function () {
      return this.$redoStack.length > 0;
    };
    this.markClean = function () {
      this.dirtyCounter = 0;
    };
    this.isClean = function () {
      return this.dirtyCounter === 0;
    };
  }.call(UndoManager.prototype));
  exports.UndoManager = UndoManager;
});
ace.define('ace/lib/net', [
  'require',
  'exports',
  'module',
  'ace/lib/dom'
], function (require, exports, module) {
  var dom = require('./dom');
  exports.get = function (url, callback) {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', url, true);
    xhr.onreadystatechange = function () {
      if (xhr.readyState === 4) {
        callback(xhr.responseText);
      }
    };
    xhr.send(null);
  };
  exports.loadScript = function (path, callback) {
    var head = dom.getDocumentHead();
    var s = document.createElement('script');
    s.src = path;
    head.appendChild(s);
    s.onload = s.onreadystatechange = function (_, isAbort) {
      if (isAbort || !s.readyState || s.readyState == 'loaded' || s.readyState == 'complete') {
        s = s.onload = s.onreadystatechange = null;
        if (!isAbort)
          callback();
      }
    };
  };
});
ace.define('ace/virtual_renderer', [
  'require',
  'exports',
  'module',
  'ace/lib/oop',
  'ace/lib/dom',
  'ace/config',
  'ace/layer/gutter',
  'ace/layer/marker',
  'ace/layer/text',
  'ace/layer/cursor',
  'ace/scrollbar',
  'ace/renderloop',
  'ace/layer/font_metrics',
  'ace/lib/event_emitter'
], function (require, exports, module) {
  var oop = require('./lib/oop');
  var dom = require('./lib/dom');
  var config = require('./config');
  var GutterLayer = require('./layer/gutter').Gutter;
  var MarkerLayer = require('./layer/marker').Marker;
  var TextLayer = require('./layer/text').Text;
  var CursorLayer = require('./layer/cursor').Cursor;
  var HScrollBar = require('./scrollbar').HScrollBar;
  var VScrollBar = require('./scrollbar').VScrollBar;
  var RenderLoop = require('./renderloop').RenderLoop;
  var FontMetrics = require('./layer/font_metrics').FontMetrics;
  var EventEmitter = require('./lib/event_emitter').EventEmitter;
  var editorCss = '.ace_editor {position: relative;overflow: hidden;font-family: \'Monaco\', \'Menlo\', \'Ubuntu Mono\', \'Consolas\', \'source-code-pro\', monospace;font-size: 12px;line-height: normal;direction: ltr;}.ace_scroller {position: absolute;overflow: hidden;top: 0;bottom: 0;background-color: inherit;-ms-user-select: none;-moz-user-select: none;-webkit-user-select: none;user-select: none;}.ace_content {position: absolute;-moz-box-sizing: border-box;-webkit-box-sizing: border-box;box-sizing: border-box;cursor: text;min-width: 100%;}.ace_dragging, .ace_dragging * {cursor: move !important;}.ace_dragging .ace_scroller:before{position: absolute;top: 0;left: 0;right: 0;bottom: 0;content: \'\';background: rgba(250, 250, 250, 0.01);z-index: 1000;}.ace_dragging.ace_dark .ace_scroller:before{background: rgba(0, 0, 0, 0.01);}.ace_selecting, .ace_selecting * {cursor: text !important;}.ace_gutter {position: absolute;overflow : hidden;width: auto;top: 0;bottom: 0;left: 0;cursor: default;z-index: 4;-ms-user-select: none;-moz-user-select: none;-webkit-user-select: none;user-select: none;}.ace_gutter-active-line {position: absolute;left: 0;right: 0;}.ace_scroller.ace_scroll-left {box-shadow: 17px 0 16px -16px rgba(0, 0, 0, 0.4) inset;}.ace_gutter-cell {padding-left: 19px;padding-right: 6px;background-repeat: no-repeat;}.ace_gutter-cell.ace_error {background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAABOFBMVEX/////////QRswFAb/Ui4wFAYwFAYwFAaWGAfDRymzOSH/PxswFAb/SiUwFAYwFAbUPRvjQiDllog5HhHdRybsTi3/Tyv9Tir+Syj/UC3////XurebMBIwFAb/RSHbPx/gUzfdwL3kzMivKBAwFAbbvbnhPx66NhowFAYwFAaZJg8wFAaxKBDZurf/RB6mMxb/SCMwFAYwFAbxQB3+RB4wFAb/Qhy4Oh+4QifbNRcwFAYwFAYwFAb/QRzdNhgwFAYwFAbav7v/Uy7oaE68MBK5LxLewr/r2NXewLswFAaxJw4wFAbkPRy2PyYwFAaxKhLm1tMwFAazPiQwFAaUGAb/QBrfOx3bvrv/VC/maE4wFAbRPBq6MRO8Qynew8Dp2tjfwb0wFAbx6eju5+by6uns4uH9/f36+vr/GkHjAAAAYnRSTlMAGt+64rnWu/bo8eAA4InH3+DwoN7j4eLi4xP99Nfg4+b+/u9B/eDs1MD1mO7+4PHg2MXa347g7vDizMLN4eG+Pv7i5evs/v79yu7S3/DV7/498Yv24eH+4ufQ3Ozu/v7+y13sRqwAAADLSURBVHjaZc/XDsFgGIBhtDrshlitmk2IrbHFqL2pvXf/+78DPokj7+Fz9qpU/9UXJIlhmPaTaQ6QPaz0mm+5gwkgovcV6GZzd5JtCQwgsxoHOvJO15kleRLAnMgHFIESUEPmawB9ngmelTtipwwfASilxOLyiV5UVUyVAfbG0cCPHig+GBkzAENHS0AstVF6bacZIOzgLmxsHbt2OecNgJC83JERmePUYq8ARGkJx6XtFsdddBQgZE2nPR6CICZhawjA4Fb/chv+399kfR+MMMDGOQAAAABJRU5ErkJggg==");background-repeat: no-repeat;background-position: 2px center;}.ace_gutter-cell.ace_warning {background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAmVBMVEX///8AAAD///8AAAAAAABPSzb/5sAAAAB/blH/73z/ulkAAAAAAAD85pkAAAAAAAACAgP/vGz/rkDerGbGrV7/pkQICAf////e0IsAAAD/oED/qTvhrnUAAAD/yHD/njcAAADuv2r/nz//oTj/p064oGf/zHAAAAA9Nir/tFIAAAD/tlTiuWf/tkIAAACynXEAAAAAAAAtIRW7zBpBAAAAM3RSTlMAABR1m7RXO8Ln31Z36zT+neXe5OzooRDfn+TZ4p3h2hTf4t3k3ucyrN1K5+Xaks52Sfs9CXgrAAAAjklEQVR42o3PbQ+CIBQFYEwboPhSYgoYunIqqLn6/z8uYdH8Vmdnu9vz4WwXgN/xTPRD2+sgOcZjsge/whXZgUaYYvT8QnuJaUrjrHUQreGczuEafQCO/SJTufTbroWsPgsllVhq3wJEk2jUSzX3CUEDJC84707djRc5MTAQxoLgupWRwW6UB5fS++NV8AbOZgnsC7BpEAAAAABJRU5ErkJggg==");background-position: 2px center;}.ace_gutter-cell.ace_info {background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAAAAAA6mKC9AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAAJ0Uk5TAAB2k804AAAAPklEQVQY02NgIB68QuO3tiLznjAwpKTgNyDbMegwisCHZUETUZV0ZqOquBpXj2rtnpSJT1AEnnRmL2OgGgAAIKkRQap2htgAAAAASUVORK5CYII=");background-position: 2px center;}.ace_dark .ace_gutter-cell.ace_info {background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAMAAADt3eJSAAAAJFBMVEUAAAChoaGAgIAqKiq+vr6tra1ZWVmUlJSbm5s8PDxubm56enrdgzg3AAAAAXRSTlMAQObYZgAAAClJREFUeNpjYMAPdsMYHegyJZFQBlsUlMFVCWUYKkAZMxZAGdxlDMQBAG+TBP4B6RyJAAAAAElFTkSuQmCC");}.ace_scrollbar {position: absolute;right: 0;bottom: 0;z-index: 6;}.ace_scrollbar-inner {position: absolute;cursor: text;left: 0;top: 0;}.ace_scrollbar-v{overflow-x: hidden;overflow-y: scroll;top: 0;}.ace_scrollbar-h {overflow-x: scroll;overflow-y: hidden;left: 0;}.ace_print-margin {position: absolute;height: 100%;}.ace_text-input {position: absolute;z-index: 0;width: 0.5em;height: 1em;opacity: 0;background: transparent;-moz-appearance: none;appearance: none;border: none;resize: none;outline: none;overflow: hidden;font: inherit;padding: 0 1px;margin: 0 -1px;text-indent: -1em;-ms-user-select: text;-moz-user-select: text;-webkit-user-select: text;user-select: text;}.ace_text-input.ace_composition {background: #f8f8f8;color: #111;z-index: 1000;opacity: 1;text-indent: 0;}.ace_layer {z-index: 1;position: absolute;overflow: hidden;white-space: pre;height: 100%;width: 100%;-moz-box-sizing: border-box;-webkit-box-sizing: border-box;box-sizing: border-box;/* setting pointer-events: auto; on node under the mouse, which changesduring scroll, will break mouse wheel scrolling in Safari */pointer-events: none;}.ace_gutter-layer {position: relative;width: auto;text-align: right;pointer-events: auto;}.ace_text-layer {font: inherit !important;}.ace_cjk {display: inline-block;text-align: center;}.ace_cursor-layer {z-index: 4;}.ace_cursor {z-index: 4;position: absolute;-moz-box-sizing: border-box;-webkit-box-sizing: border-box;box-sizing: border-box;border-left: 2px solid}.ace_slim-cursors .ace_cursor {border-left-width: 1px;}.ace_overwrite-cursors .ace_cursor {border-left-width: 0px;border-bottom: 1px solid;}.ace_hidden-cursors .ace_cursor {opacity: 0.2;}.ace_smooth-blinking .ace_cursor {-moz-transition: opacity 0.18s;-webkit-transition: opacity 0.18s;-o-transition: opacity 0.18s;-ms-transition: opacity 0.18s;transition: opacity 0.18s;}.ace_editor.ace_multiselect .ace_cursor {border-left-width: 1px;}.ace_marker-layer .ace_step, .ace_marker-layer .ace_stack {position: absolute;z-index: 3;}.ace_marker-layer .ace_selection {position: absolute;z-index: 5;}.ace_marker-layer .ace_bracket {position: absolute;z-index: 6;}.ace_marker-layer .ace_active-line {position: absolute;z-index: 2;}.ace_marker-layer .ace_selected-word {position: absolute;z-index: 4;-moz-box-sizing: border-box;-webkit-box-sizing: border-box;box-sizing: border-box;}.ace_line .ace_fold {-moz-box-sizing: border-box;-webkit-box-sizing: border-box;box-sizing: border-box;display: inline-block;height: 11px;margin-top: -2px;vertical-align: middle;background-image:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII="),url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACJJREFUeNpi+P//fxgTAwPDBxDxD078RSX+YeEyDFMCIMAAI3INmXiwf2YAAAAASUVORK5CYII=");background-repeat: no-repeat, repeat-x;background-position: center center, top left;color: transparent;border: 1px solid black;-moz-border-radius: 2px;-webkit-border-radius: 2px;border-radius: 2px;cursor: pointer;pointer-events: auto;}.ace_dark .ace_fold {}.ace_fold:hover{background-image:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII="),url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACBJREFUeNpi+P//fz4TAwPDZxDxD5X4i5fLMEwJgAADAEPVDbjNw87ZAAAAAElFTkSuQmCC");}.ace_tooltip {background-color: #FFF;background-image: -webkit-linear-gradient(top, transparent, rgba(0, 0, 0, 0.1));background-image: linear-gradient(to bottom, transparent, rgba(0, 0, 0, 0.1));border: 1px solid gray;border-radius: 1px;box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);color: black;display: block;max-width: 100%;padding: 3px 4px;position: fixed;z-index: 999999;-moz-box-sizing: border-box;-webkit-box-sizing: border-box;box-sizing: border-box;cursor: default;white-space: pre;word-wrap: break-word;line-height: normal;font-style: normal;font-weight: normal;letter-spacing: normal;pointer-events: none;}.ace_folding-enabled > .ace_gutter-cell {padding-right: 13px;}.ace_fold-widget {-moz-box-sizing: border-box;-webkit-box-sizing: border-box;box-sizing: border-box;margin: 0 -12px 0 1px;display: none;width: 11px;vertical-align: top;background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42mWKsQ0AMAzC8ixLlrzQjzmBiEjp0A6WwBCSPgKAXoLkqSot7nN3yMwR7pZ32NzpKkVoDBUxKAAAAABJRU5ErkJggg==");background-repeat: no-repeat;background-position: center;border-radius: 3px;border: 1px solid transparent;cursor: pointer;}.ace_folding-enabled .ace_fold-widget {display: inline-block;   }.ace_fold-widget.ace_end {background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42m3HwQkAMAhD0YzsRchFKI7sAikeWkrxwScEB0nh5e7KTPWimZki4tYfVbX+MNl4pyZXejUO1QAAAABJRU5ErkJggg==");}.ace_fold-widget.ace_closed {background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAGCAYAAAAG5SQMAAAAOUlEQVR42jXKwQkAMAgDwKwqKD4EwQ26sSOkVWjgIIHAzPiCgaqiqnJHZnKICBERHN194O5b9vbLuAVRL+l0YWnZAAAAAElFTkSuQmCCXA==");}.ace_fold-widget:hover {border: 1px solid rgba(0, 0, 0, 0.3);background-color: rgba(255, 255, 255, 0.2);-moz-box-shadow: 0 1px 1px rgba(255, 255, 255, 0.7);-webkit-box-shadow: 0 1px 1px rgba(255, 255, 255, 0.7);box-shadow: 0 1px 1px rgba(255, 255, 255, 0.7);}.ace_fold-widget:active {border: 1px solid rgba(0, 0, 0, 0.4);background-color: rgba(0, 0, 0, 0.05);-moz-box-shadow: 0 1px 1px rgba(255, 255, 255, 0.8);-webkit-box-shadow: 0 1px 1px rgba(255, 255, 255, 0.8);box-shadow: 0 1px 1px rgba(255, 255, 255, 0.8);}/*** Dark version for fold widgets*/.ace_dark .ace_fold-widget {background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHklEQVQIW2P4//8/AzoGEQ7oGCaLLAhWiSwB146BAQCSTPYocqT0AAAAAElFTkSuQmCC");}.ace_dark .ace_fold-widget.ace_end {background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAH0lEQVQIW2P4//8/AxQ7wNjIAjDMgC4AxjCVKBirIAAF0kz2rlhxpAAAAABJRU5ErkJggg==");}.ace_dark .ace_fold-widget.ace_closed {background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAFCAYAAACAcVaiAAAAHElEQVQIW2P4//+/AxAzgDADlOOAznHAKgPWAwARji8UIDTfQQAAAABJRU5ErkJggg==");}.ace_dark .ace_fold-widget:hover {box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);background-color: rgba(255, 255, 255, 0.1);}.ace_dark .ace_fold-widget:active {-moz-box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);-webkit-box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);}.ace_fold-widget.ace_invalid {background-color: #FFB4B4;border-color: #DE5555;}.ace_fade-fold-widgets .ace_fold-widget {-moz-transition: opacity 0.4s ease 0.05s;-webkit-transition: opacity 0.4s ease 0.05s;-o-transition: opacity 0.4s ease 0.05s;-ms-transition: opacity 0.4s ease 0.05s;transition: opacity 0.4s ease 0.05s;opacity: 0;}.ace_fade-fold-widgets:hover .ace_fold-widget {-moz-transition: opacity 0.05s ease 0.05s;-webkit-transition: opacity 0.05s ease 0.05s;-o-transition: opacity 0.05s ease 0.05s;-ms-transition: opacity 0.05s ease 0.05s;transition: opacity 0.05s ease 0.05s;opacity:1;}.ace_underline {text-decoration: underline;}.ace_bold {font-weight: bold;}.ace_nobold .ace_bold {font-weight: normal;}.ace_italic {font-style: italic;}.ace_error-marker {background-color: rgba(255, 0, 0,0.2);position: absolute;z-index: 9;}.ace_highlight-marker {background-color: rgba(255, 255, 0,0.2);position: absolute;z-index: 8;}';
  dom.importCssString(editorCss, 'ace_editor');
  var VirtualRenderer = function (container, theme) {
    var _self = this;
    this.container = container || dom.createElement('div');
    this.$keepTextAreaAtCursor = true;
    dom.addCssClass(this.container, 'ace_editor');
    this.setTheme(theme);
    this.$gutter = dom.createElement('div');
    this.$gutter.className = 'ace_gutter';
    this.container.appendChild(this.$gutter);
    this.scroller = dom.createElement('div');
    this.scroller.className = 'ace_scroller';
    this.container.appendChild(this.scroller);
    this.content = dom.createElement('div');
    this.content.className = 'ace_content';
    this.scroller.appendChild(this.content);
    this.$gutterLayer = new GutterLayer(this.$gutter);
    this.$gutterLayer.on('changeGutterWidth', this.onGutterResize.bind(this));
    this.$markerBack = new MarkerLayer(this.content);
    var textLayer = this.$textLayer = new TextLayer(this.content);
    this.canvas = textLayer.element;
    this.$markerFront = new MarkerLayer(this.content);
    this.$cursorLayer = new CursorLayer(this.content);
    this.$horizScroll = false;
    this.$vScroll = false;
    this.scrollBar = this.scrollBarV = new VScrollBar(this.container, this);
    this.scrollBarH = new HScrollBar(this.container, this);
    this.scrollBarV.addEventListener('scroll', function (e) {
      if (!_self.$scrollAnimation)
        _self.session.setScrollTop(e.data - _self.scrollMargin.top);
    });
    this.scrollBarH.addEventListener('scroll', function (e) {
      if (!_self.$scrollAnimation)
        _self.session.setScrollLeft(e.data - _self.scrollMargin.left);
    });
    this.scrollTop = 0;
    this.scrollLeft = 0;
    this.cursorPos = {
      row: 0,
      column: 0
    };
    this.$fontMetrics = new FontMetrics(this.container, 500);
    this.$textLayer.$setFontMetrics(this.$fontMetrics);
    this.$textLayer.addEventListener('changeCharacterSize', function (e) {
      _self.updateCharacterSize();
      _self.onResize(true, _self.gutterWidth, _self.$size.width, _self.$size.height);
      _self._signal('changeCharacterSize', e);
    });
    this.$size = {
      width: 0,
      height: 0,
      scrollerHeight: 0,
      scrollerWidth: 0,
      $dirty: true
    };
    this.layerConfig = {
      width: 1,
      padding: 0,
      firstRow: 0,
      firstRowScreen: 0,
      lastRow: 0,
      lineHeight: 0,
      characterWidth: 0,
      minHeight: 1,
      maxHeight: 1,
      offset: 0,
      height: 1,
      gutterOffset: 1
    };
    this.scrollMargin = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0,
      v: 0,
      h: 0
    };
    this.$loop = new RenderLoop(this.$renderChanges.bind(this), this.container.ownerDocument.defaultView);
    this.$loop.schedule(this.CHANGE_FULL);
    this.updateCharacterSize();
    this.setPadding(4);
    config.resetOptions(this);
    config._emit('renderer', this);
  };
  (function () {
    this.CHANGE_CURSOR = 1;
    this.CHANGE_MARKER = 2;
    this.CHANGE_GUTTER = 4;
    this.CHANGE_SCROLL = 8;
    this.CHANGE_LINES = 16;
    this.CHANGE_TEXT = 32;
    this.CHANGE_SIZE = 64;
    this.CHANGE_MARKER_BACK = 128;
    this.CHANGE_MARKER_FRONT = 256;
    this.CHANGE_FULL = 512;
    this.CHANGE_H_SCROLL = 1024;
    oop.implement(this, EventEmitter);
    this.updateCharacterSize = function () {
      if (this.$textLayer.allowBoldFonts != this.$allowBoldFonts) {
        this.$allowBoldFonts = this.$textLayer.allowBoldFonts;
        this.setStyle('ace_nobold', !this.$allowBoldFonts);
      }
      this.layerConfig.characterWidth = this.characterWidth = this.$textLayer.getCharacterWidth();
      this.layerConfig.lineHeight = this.lineHeight = this.$textLayer.getLineHeight();
      this.$updatePrintMargin();
    };
    this.setSession = function (session) {
      if (this.session)
        this.session.doc.off('changeNewLineMode', this.onChangeNewLineMode);
      this.session = session;
      if (!session)
        return;
      if (this.scrollMargin.top && session.getScrollTop() <= 0)
        session.setScrollTop(-this.scrollMargin.top);
      this.$cursorLayer.setSession(session);
      this.$markerBack.setSession(session);
      this.$markerFront.setSession(session);
      this.$gutterLayer.setSession(session);
      this.$textLayer.setSession(session);
      this.$loop.schedule(this.CHANGE_FULL);
      this.session.$setFontMetrics(this.$fontMetrics);
      this.onChangeNewLineMode = this.onChangeNewLineMode.bind(this);
      this.onChangeNewLineMode();
      this.session.doc.on('changeNewLineMode', this.onChangeNewLineMode);
    };
    this.updateLines = function (firstRow, lastRow) {
      if (lastRow === undefined)
        lastRow = Infinity;
      if (!this.$changedLines) {
        this.$changedLines = {
          firstRow: firstRow,
          lastRow: lastRow
        };
      } else {
        if (this.$changedLines.firstRow > firstRow)
          this.$changedLines.firstRow = firstRow;
        if (this.$changedLines.lastRow < lastRow)
          this.$changedLines.lastRow = lastRow;
      }
      if (this.$changedLines.firstRow > this.layerConfig.lastRow || this.$changedLines.lastRow < this.layerConfig.firstRow)
        return;
      this.$loop.schedule(this.CHANGE_LINES);
    };
    this.onChangeNewLineMode = function () {
      this.$loop.schedule(this.CHANGE_TEXT);
      this.$textLayer.$updateEolChar();
    };
    this.onChangeTabSize = function () {
      this.$loop.schedule(this.CHANGE_TEXT | this.CHANGE_MARKER);
      this.$textLayer.onChangeTabSize();
    };
    this.updateText = function () {
      this.$loop.schedule(this.CHANGE_TEXT);
    };
    this.updateFull = function (force) {
      if (force)
        this.$renderChanges(this.CHANGE_FULL, true);
      else
        this.$loop.schedule(this.CHANGE_FULL);
    };
    this.updateFontSize = function () {
      this.$textLayer.checkForSizeChanges();
    };
    this.$changes = 0;
    this.$updateSizeAsync = function () {
      if (this.$loop.pending)
        this.$size.$dirty = true;
      else
        this.onResize();
    };
    this.onResize = function (force, gutterWidth, width, height) {
      if (this.resizing > 2)
        return;
      else if (this.resizing > 0)
        this.resizing++;
      else
        this.resizing = force ? 1 : 0;
      var el = this.container;
      if (!height)
        height = el.clientHeight || el.scrollHeight;
      if (!width)
        width = el.clientWidth || el.scrollWidth;
      var changes = this.$updateCachedSize(force, gutterWidth, width, height);
      if (!this.$size.scrollerHeight || !width && !height)
        return this.resizing = 0;
      if (force)
        this.$gutterLayer.$padding = null;
      if (force)
        this.$renderChanges(changes | this.$changes, true);
      else
        this.$loop.schedule(changes | this.$changes);
      if (this.resizing)
        this.resizing = 0;
    };
    this.$updateCachedSize = function (force, gutterWidth, width, height) {
      height -= this.$extraHeight || 0;
      var changes = 0;
      var size = this.$size;
      var oldSize = {
          width: size.width,
          height: size.height,
          scrollerHeight: size.scrollerHeight,
          scrollerWidth: size.scrollerWidth
        };
      if (height && (force || size.height != height)) {
        size.height = height;
        changes |= this.CHANGE_SIZE;
        size.scrollerHeight = size.height;
        if (this.$horizScroll)
          size.scrollerHeight -= this.scrollBarH.getHeight();
        this.scrollBarV.element.style.bottom = this.scrollBarH.getHeight() + 'px';
        changes = changes | this.CHANGE_SCROLL;
      }
      if (width && (force || size.width != width)) {
        changes |= this.CHANGE_SIZE;
        size.width = width;
        if (gutterWidth == null)
          gutterWidth = this.$showGutter ? this.$gutter.offsetWidth : 0;
        this.gutterWidth = gutterWidth;
        this.scrollBarH.element.style.left = this.scroller.style.left = gutterWidth + 'px';
        size.scrollerWidth = Math.max(0, width - gutterWidth - this.scrollBarV.getWidth());
        this.scrollBarH.element.style.right = this.scroller.style.right = this.scrollBarV.getWidth() + 'px';
        this.scroller.style.bottom = this.scrollBarH.getHeight() + 'px';
        if (this.session && this.session.getUseWrapMode() && this.adjustWrapLimit() || force)
          changes |= this.CHANGE_FULL;
      }
      size.$dirty = !width || !height;
      if (changes)
        this._signal('resize', oldSize);
      return changes;
    };
    this.onGutterResize = function () {
      var gutterWidth = this.$showGutter ? this.$gutter.offsetWidth : 0;
      if (gutterWidth != this.gutterWidth)
        this.$changes |= this.$updateCachedSize(true, gutterWidth, this.$size.width, this.$size.height);
      if (this.session.getUseWrapMode() && this.adjustWrapLimit()) {
        this.$loop.schedule(this.CHANGE_FULL);
      } else if (this.$size.$dirty) {
        this.$loop.schedule(this.CHANGE_FULL);
      } else {
        this.$computeLayerConfig();
        this.$loop.schedule(this.CHANGE_MARKER);
      }
    };
    this.adjustWrapLimit = function () {
      var availableWidth = this.$size.scrollerWidth - this.$padding * 2;
      var limit = Math.floor(availableWidth / this.characterWidth);
      return this.session.adjustWrapLimit(limit, this.$showPrintMargin && this.$printMarginColumn);
    };
    this.setAnimatedScroll = function (shouldAnimate) {
      this.setOption('animatedScroll', shouldAnimate);
    };
    this.getAnimatedScroll = function () {
      return this.$animatedScroll;
    };
    this.setShowInvisibles = function (showInvisibles) {
      this.setOption('showInvisibles', showInvisibles);
    };
    this.getShowInvisibles = function () {
      return this.getOption('showInvisibles');
    };
    this.getDisplayIndentGuides = function () {
      return this.getOption('displayIndentGuides');
    };
    this.setDisplayIndentGuides = function (display) {
      this.setOption('displayIndentGuides', display);
    };
    this.setShowPrintMargin = function (showPrintMargin) {
      this.setOption('showPrintMargin', showPrintMargin);
    };
    this.getShowPrintMargin = function () {
      return this.getOption('showPrintMargin');
    };
    this.setPrintMarginColumn = function (showPrintMargin) {
      this.setOption('printMarginColumn', showPrintMargin);
    };
    this.getPrintMarginColumn = function () {
      return this.getOption('printMarginColumn');
    };
    this.getShowGutter = function () {
      return this.getOption('showGutter');
    };
    this.setShowGutter = function (show) {
      return this.setOption('showGutter', show);
    };
    this.getFadeFoldWidgets = function () {
      return this.getOption('fadeFoldWidgets');
    };
    this.setFadeFoldWidgets = function (show) {
      this.setOption('fadeFoldWidgets', show);
    };
    this.setHighlightGutterLine = function (shouldHighlight) {
      this.setOption('highlightGutterLine', shouldHighlight);
    };
    this.getHighlightGutterLine = function () {
      return this.getOption('highlightGutterLine');
    };
    this.$updateGutterLineHighlight = function () {
      var pos = this.$cursorLayer.$pixelPos;
      var height = this.layerConfig.lineHeight;
      if (this.session.getUseWrapMode()) {
        var cursor = this.session.selection.getCursor();
        cursor.column = 0;
        pos = this.$cursorLayer.getPixelPosition(cursor, true);
        height *= this.session.getRowLength(cursor.row);
      }
      this.$gutterLineHighlight.style.top = pos.top - this.layerConfig.offset + 'px';
      this.$gutterLineHighlight.style.height = height + 'px';
    };
    this.$updatePrintMargin = function () {
      if (!this.$showPrintMargin && !this.$printMarginEl)
        return;
      if (!this.$printMarginEl) {
        var containerEl = dom.createElement('div');
        containerEl.className = 'ace_layer ace_print-margin-layer';
        this.$printMarginEl = dom.createElement('div');
        this.$printMarginEl.className = 'ace_print-margin';
        containerEl.appendChild(this.$printMarginEl);
        this.content.insertBefore(containerEl, this.content.firstChild);
      }
      var style = this.$printMarginEl.style;
      style.left = this.characterWidth * this.$printMarginColumn + this.$padding + 'px';
      style.visibility = this.$showPrintMargin ? 'visible' : 'hidden';
      if (this.session && this.session.$wrap == -1)
        this.adjustWrapLimit();
    };
    this.getContainerElement = function () {
      return this.container;
    };
    this.getMouseEventTarget = function () {
      return this.content;
    };
    this.getTextAreaContainer = function () {
      return this.container;
    };
    this.$moveTextAreaToCursor = function () {
      if (!this.$keepTextAreaAtCursor)
        return;
      var config = this.layerConfig;
      var posTop = this.$cursorLayer.$pixelPos.top;
      var posLeft = this.$cursorLayer.$pixelPos.left;
      posTop -= config.offset;
      var h = this.lineHeight;
      if (posTop < 0 || posTop > config.height - h)
        return;
      var w = this.characterWidth;
      if (this.$composition) {
        var val = this.textarea.value.replace(/^\x01+/, '');
        w *= this.session.$getStringScreenWidth(val)[0] + 2;
        h += 2;
        posTop -= 1;
      }
      posLeft -= this.scrollLeft;
      if (posLeft > this.$size.scrollerWidth - w)
        posLeft = this.$size.scrollerWidth - w;
      posLeft -= this.scrollBar.width;
      this.textarea.style.height = h + 'px';
      this.textarea.style.width = w + 'px';
      this.textarea.style.right = Math.max(0, this.$size.scrollerWidth - posLeft - w) + 'px';
      this.textarea.style.bottom = Math.max(0, this.$size.height - posTop - h) + 'px';
    };
    this.getFirstVisibleRow = function () {
      return this.layerConfig.firstRow;
    };
    this.getFirstFullyVisibleRow = function () {
      return this.layerConfig.firstRow + (this.layerConfig.offset === 0 ? 0 : 1);
    };
    this.getLastFullyVisibleRow = function () {
      var flint = Math.floor((this.layerConfig.height + this.layerConfig.offset) / this.layerConfig.lineHeight);
      return this.layerConfig.firstRow - 1 + flint;
    };
    this.getLastVisibleRow = function () {
      return this.layerConfig.lastRow;
    };
    this.$padding = null;
    this.setPadding = function (padding) {
      this.$padding = padding;
      this.$textLayer.setPadding(padding);
      this.$cursorLayer.setPadding(padding);
      this.$markerFront.setPadding(padding);
      this.$markerBack.setPadding(padding);
      this.$loop.schedule(this.CHANGE_FULL);
      this.$updatePrintMargin();
    };
    this.setScrollMargin = function (top, bottom, left, right) {
      var sm = this.scrollMargin;
      sm.top = top | 0;
      sm.bottom = bottom | 0;
      sm.right = right | 0;
      sm.left = left | 0;
      sm.v = sm.top + sm.bottom;
      sm.h = sm.left + sm.right;
      if (sm.top && this.scrollTop <= 0 && this.session)
        this.session.setScrollTop(-sm.top);
      this.updateFull();
    };
    this.getHScrollBarAlwaysVisible = function () {
      return this.$hScrollBarAlwaysVisible;
    };
    this.setHScrollBarAlwaysVisible = function (alwaysVisible) {
      this.setOption('hScrollBarAlwaysVisible', alwaysVisible);
    };
    this.getVScrollBarAlwaysVisible = function () {
      return this.$hScrollBarAlwaysVisible;
    };
    this.setVScrollBarAlwaysVisible = function (alwaysVisible) {
      this.setOption('vScrollBarAlwaysVisible', alwaysVisible);
    };
    this.$updateScrollBarV = function () {
      this.scrollBarV.setScrollHeight(this.layerConfig.maxHeight + this.scrollMargin.v);
      this.scrollBarV.setScrollTop(this.scrollTop + this.scrollMargin.top);
    };
    this.$updateScrollBarH = function () {
      this.scrollBarH.setScrollWidth(this.layerConfig.width + 2 * this.$padding + this.scrollMargin.h);
      this.scrollBarH.setScrollLeft(this.scrollLeft + this.scrollMargin.left);
    };
    this.$frozen = false;
    this.freeze = function () {
      this.$frozen = true;
    };
    this.unfreeze = function () {
      this.$frozen = false;
    };
    this.$renderChanges = function (changes, force) {
      if (this.$changes) {
        changes |= this.$changes;
        this.$changes = 0;
      }
      if (!this.session || !this.container.offsetWidth || this.$frozen || !changes && !force) {
        this.$changes |= changes;
        return;
      }
      if (this.$size.$dirty) {
        this.$changes |= changes;
        return this.onResize(true);
      }
      if (!this.lineHeight) {
        this.$textLayer.checkForSizeChanges();
      }
      this._signal('beforeRender');
      var config = this.layerConfig;
      if (changes & this.CHANGE_FULL || changes & this.CHANGE_SIZE || changes & this.CHANGE_TEXT || changes & this.CHANGE_LINES || changes & this.CHANGE_SCROLL || changes & this.CHANGE_H_SCROLL) {
        changes |= this.$computeLayerConfig();
        config = this.layerConfig;
        this.$updateScrollBarV();
        if (changes & this.CHANGE_H_SCROLL)
          this.$updateScrollBarH();
        this.$gutterLayer.element.style.marginTop = -config.offset + 'px';
        this.content.style.marginTop = -config.offset + 'px';
        this.content.style.width = config.width + 2 * this.$padding + 'px';
        this.content.style.height = config.minHeight + 'px';
      }
      if (changes & this.CHANGE_H_SCROLL) {
        this.content.style.marginLeft = -this.scrollLeft + 'px';
        this.scroller.className = this.scrollLeft <= 0 ? 'ace_scroller' : 'ace_scroller ace_scroll-left';
      }
      if (changes & this.CHANGE_FULL) {
        this.$textLayer.update(config);
        if (this.$showGutter)
          this.$gutterLayer.update(config);
        this.$markerBack.update(config);
        this.$markerFront.update(config);
        this.$cursorLayer.update(config);
        this.$moveTextAreaToCursor();
        this.$highlightGutterLine && this.$updateGutterLineHighlight();
        this._signal('afterRender');
        return;
      }
      if (changes & this.CHANGE_SCROLL) {
        if (changes & this.CHANGE_TEXT || changes & this.CHANGE_LINES)
          this.$textLayer.update(config);
        else
          this.$textLayer.scrollLines(config);
        if (this.$showGutter)
          this.$gutterLayer.update(config);
        this.$markerBack.update(config);
        this.$markerFront.update(config);
        this.$cursorLayer.update(config);
        this.$highlightGutterLine && this.$updateGutterLineHighlight();
        this.$moveTextAreaToCursor();
        this._signal('afterRender');
        return;
      }
      if (changes & this.CHANGE_TEXT) {
        this.$textLayer.update(config);
        if (this.$showGutter)
          this.$gutterLayer.update(config);
      } else if (changes & this.CHANGE_LINES) {
        if (this.$updateLines() || changes & this.CHANGE_GUTTER && this.$showGutter)
          this.$gutterLayer.update(config);
      } else if (changes & this.CHANGE_TEXT || changes & this.CHANGE_GUTTER) {
        if (this.$showGutter)
          this.$gutterLayer.update(config);
      }
      if (changes & this.CHANGE_CURSOR) {
        this.$cursorLayer.update(config);
        this.$moveTextAreaToCursor();
        this.$highlightGutterLine && this.$updateGutterLineHighlight();
      }
      if (changes & (this.CHANGE_MARKER | this.CHANGE_MARKER_FRONT)) {
        this.$markerFront.update(config);
      }
      if (changes & (this.CHANGE_MARKER | this.CHANGE_MARKER_BACK)) {
        this.$markerBack.update(config);
      }
      this._signal('afterRender');
    };
    this.$autosize = function () {
      var height = this.session.getScreenLength() * this.lineHeight;
      var maxHeight = this.$maxLines * this.lineHeight;
      var desiredHeight = Math.max((this.$minLines || 1) * this.lineHeight, Math.min(maxHeight, height)) + this.scrollMargin.v + (this.$extraHeight || 0);
      var vScroll = height > maxHeight;
      if (desiredHeight != this.desiredHeight || this.$size.height != this.desiredHeight || vScroll != this.$vScroll) {
        if (vScroll != this.$vScroll) {
          this.$vScroll = vScroll;
          this.scrollBarV.setVisible(vScroll);
        }
        var w = this.container.clientWidth;
        this.container.style.height = desiredHeight + 'px';
        this.$updateCachedSize(true, this.$gutterWidth, w, desiredHeight);
        this.desiredHeight = desiredHeight;
      }
    };
    this.$computeLayerConfig = function () {
      if (this.$maxLines && this.lineHeight > 1)
        this.$autosize();
      var session = this.session;
      var size = this.$size;
      var hideScrollbars = size.height <= 2 * this.lineHeight;
      var screenLines = this.session.getScreenLength();
      var maxHeight = screenLines * this.lineHeight;
      var offset = this.scrollTop % this.lineHeight;
      var minHeight = size.scrollerHeight + this.lineHeight;
      var longestLine = this.$getLongestLine();
      var horizScroll = !hideScrollbars && (this.$hScrollBarAlwaysVisible || size.scrollerWidth - longestLine - 2 * this.$padding < 0);
      var hScrollChanged = this.$horizScroll !== horizScroll;
      if (hScrollChanged) {
        this.$horizScroll = horizScroll;
        this.scrollBarH.setVisible(horizScroll);
      }
      if (!this.$maxLines && this.$scrollPastEnd) {
        if (this.scrollTop > maxHeight - size.scrollerHeight)
          maxHeight += Math.min((size.scrollerHeight - this.lineHeight) * this.$scrollPastEnd, this.scrollTop - maxHeight + size.scrollerHeight);
      }
      var vScroll = !hideScrollbars && (this.$vScrollBarAlwaysVisible || size.scrollerHeight - maxHeight < 0);
      var vScrollChanged = this.$vScroll !== vScroll;
      if (vScrollChanged) {
        this.$vScroll = vScroll;
        this.scrollBarV.setVisible(vScroll);
      }
      this.session.setScrollTop(Math.max(-this.scrollMargin.top, Math.min(this.scrollTop, maxHeight - size.scrollerHeight + this.scrollMargin.bottom)));
      this.session.setScrollLeft(Math.max(-this.scrollMargin.left, Math.min(this.scrollLeft, longestLine + 2 * this.$padding - size.scrollerWidth + this.scrollMargin.right)));
      var lineCount = Math.ceil(minHeight / this.lineHeight) - 1;
      var firstRow = Math.max(0, Math.round((this.scrollTop - offset) / this.lineHeight));
      var lastRow = firstRow + lineCount;
      var firstRowScreen, firstRowHeight;
      var lineHeight = this.lineHeight;
      firstRow = session.screenToDocumentRow(firstRow, 0);
      var foldLine = session.getFoldLine(firstRow);
      if (foldLine) {
        firstRow = foldLine.start.row;
      }
      firstRowScreen = session.documentToScreenRow(firstRow, 0);
      firstRowHeight = session.getRowLength(firstRow) * lineHeight;
      lastRow = Math.min(session.screenToDocumentRow(lastRow, 0), session.getLength() - 1);
      minHeight = size.scrollerHeight + session.getRowLength(lastRow) * lineHeight + firstRowHeight;
      offset = this.scrollTop - firstRowScreen * lineHeight;
      var changes = 0;
      if (this.layerConfig.width != longestLine)
        changes = this.CHANGE_H_SCROLL;
      if (hScrollChanged || vScrollChanged) {
        changes = this.$updateCachedSize(true, this.gutterWidth, size.width, size.height);
        this._signal('scrollbarVisibilityChanged');
        if (vScrollChanged)
          longestLine = this.$getLongestLine();
      }
      this.layerConfig = {
        width: longestLine,
        padding: this.$padding,
        firstRow: firstRow,
        firstRowScreen: firstRowScreen,
        lastRow: lastRow,
        lineHeight: lineHeight,
        characterWidth: this.characterWidth,
        minHeight: minHeight,
        maxHeight: maxHeight,
        offset: offset,
        gutterOffset: Math.max(0, Math.ceil((offset + size.height - size.scrollerHeight) / lineHeight)),
        height: this.$size.scrollerHeight
      };
      return changes;
    };
    this.$updateLines = function () {
      var firstRow = this.$changedLines.firstRow;
      var lastRow = this.$changedLines.lastRow;
      this.$changedLines = null;
      var layerConfig = this.layerConfig;
      if (firstRow > layerConfig.lastRow + 1) {
        return;
      }
      if (lastRow < layerConfig.firstRow) {
        return;
      }
      if (lastRow === Infinity) {
        if (this.$showGutter)
          this.$gutterLayer.update(layerConfig);
        this.$textLayer.update(layerConfig);
        return;
      }
      this.$textLayer.updateLines(layerConfig, firstRow, lastRow);
      return true;
    };
    this.$getLongestLine = function () {
      var charCount = this.session.getScreenWidth();
      if (this.showInvisibles && !this.session.$useWrapMode)
        charCount += 1;
      return Math.max(this.$size.scrollerWidth - 2 * this.$padding, Math.round(charCount * this.characterWidth));
    };
    this.updateFrontMarkers = function () {
      this.$markerFront.setMarkers(this.session.getMarkers(true));
      this.$loop.schedule(this.CHANGE_MARKER_FRONT);
    };
    this.updateBackMarkers = function () {
      this.$markerBack.setMarkers(this.session.getMarkers());
      this.$loop.schedule(this.CHANGE_MARKER_BACK);
    };
    this.addGutterDecoration = function (row, className) {
      this.$gutterLayer.addGutterDecoration(row, className);
    };
    this.removeGutterDecoration = function (row, className) {
      this.$gutterLayer.removeGutterDecoration(row, className);
    };
    this.updateBreakpoints = function (rows) {
      this.$loop.schedule(this.CHANGE_GUTTER);
    };
    this.setAnnotations = function (annotations) {
      this.$gutterLayer.setAnnotations(annotations);
      this.$loop.schedule(this.CHANGE_GUTTER);
    };
    this.updateCursor = function () {
      this.$loop.schedule(this.CHANGE_CURSOR);
    };
    this.hideCursor = function () {
      this.$cursorLayer.hideCursor();
    };
    this.showCursor = function () {
      this.$cursorLayer.showCursor();
    };
    this.scrollSelectionIntoView = function (anchor, lead, offset) {
      this.scrollCursorIntoView(anchor, offset);
      this.scrollCursorIntoView(lead, offset);
    };
    this.scrollCursorIntoView = function (cursor, offset, $viewMargin) {
      if (this.$size.scrollerHeight === 0)
        return;
      var pos = this.$cursorLayer.getPixelPosition(cursor);
      var left = pos.left;
      var top = pos.top;
      var topMargin = $viewMargin && $viewMargin.top || 0;
      var bottomMargin = $viewMargin && $viewMargin.bottom || 0;
      var scrollTop = this.$scrollAnimation ? this.session.getScrollTop() : this.scrollTop;
      if (scrollTop + topMargin > top) {
        if (offset)
          top -= offset * this.$size.scrollerHeight;
        if (top === 0)
          top = -this.scrollMargin.top;
        this.session.setScrollTop(top);
      } else if (scrollTop + this.$size.scrollerHeight - bottomMargin < top + this.lineHeight) {
        if (offset)
          top += offset * this.$size.scrollerHeight;
        this.session.setScrollTop(top + this.lineHeight - this.$size.scrollerHeight);
      }
      var scrollLeft = this.scrollLeft;
      if (scrollLeft > left) {
        if (left < this.$padding + 2 * this.layerConfig.characterWidth)
          left = -this.scrollMargin.left;
        this.session.setScrollLeft(left);
      } else if (scrollLeft + this.$size.scrollerWidth < left + this.characterWidth) {
        this.session.setScrollLeft(Math.round(left + this.characterWidth - this.$size.scrollerWidth));
      } else if (scrollLeft <= this.$padding && left - scrollLeft < this.characterWidth) {
        this.session.setScrollLeft(0);
      }
    };
    this.getScrollTop = function () {
      return this.session.getScrollTop();
    };
    this.getScrollLeft = function () {
      return this.session.getScrollLeft();
    };
    this.getScrollTopRow = function () {
      return this.scrollTop / this.lineHeight;
    };
    this.getScrollBottomRow = function () {
      return Math.max(0, Math.floor((this.scrollTop + this.$size.scrollerHeight) / this.lineHeight) - 1);
    };
    this.scrollToRow = function (row) {
      this.session.setScrollTop(row * this.lineHeight);
    };
    this.alignCursor = function (cursor, alignment) {
      if (typeof cursor == 'number')
        cursor = {
          row: cursor,
          column: 0
        };
      var pos = this.$cursorLayer.getPixelPosition(cursor);
      var h = this.$size.scrollerHeight - this.lineHeight;
      var offset = pos.top - h * (alignment || 0);
      this.session.setScrollTop(offset);
      return offset;
    };
    this.STEPS = 8;
    this.$calcSteps = function (fromValue, toValue) {
      var i = 0;
      var l = this.STEPS;
      var steps = [];
      var func = function (t, x_min, dx) {
        return dx * (Math.pow(t - 1, 3) + 1) + x_min;
      };
      for (i = 0; i < l; ++i)
        steps.push(func(i / this.STEPS, fromValue, toValue - fromValue));
      return steps;
    };
    this.scrollToLine = function (line, center, animate, callback) {
      var pos = this.$cursorLayer.getPixelPosition({
          row: line,
          column: 0
        });
      var offset = pos.top;
      if (center)
        offset -= this.$size.scrollerHeight / 2;
      var initialScroll = this.scrollTop;
      this.session.setScrollTop(offset);
      if (animate !== false)
        this.animateScrolling(initialScroll, callback);
    };
    this.animateScrolling = function (fromValue, callback) {
      var toValue = this.scrollTop;
      if (!this.$animatedScroll)
        return;
      var _self = this;
      if (fromValue == toValue)
        return;
      if (this.$scrollAnimation) {
        var oldSteps = this.$scrollAnimation.steps;
        if (oldSteps.length) {
          fromValue = oldSteps[0];
          if (fromValue == toValue)
            return;
        }
      }
      var steps = _self.$calcSteps(fromValue, toValue);
      this.$scrollAnimation = {
        from: fromValue,
        to: toValue,
        steps: steps
      };
      clearInterval(this.$timer);
      _self.session.setScrollTop(steps.shift());
      _self.session.$scrollTop = toValue;
      this.$timer = setInterval(function () {
        if (steps.length) {
          _self.session.setScrollTop(steps.shift());
          _self.session.$scrollTop = toValue;
        } else if (toValue != null) {
          _self.session.$scrollTop = -1;
          _self.session.setScrollTop(toValue);
          toValue = null;
        } else {
          _self.$timer = clearInterval(_self.$timer);
          _self.$scrollAnimation = null;
          callback && callback();
        }
      }, 10);
    };
    this.scrollToY = function (scrollTop) {
      if (this.scrollTop !== scrollTop) {
        this.$loop.schedule(this.CHANGE_SCROLL);
        this.scrollTop = scrollTop;
      }
    };
    this.scrollToX = function (scrollLeft) {
      if (this.scrollLeft !== scrollLeft)
        this.scrollLeft = scrollLeft;
      this.$loop.schedule(this.CHANGE_H_SCROLL);
    };
    this.scrollTo = function (x, y) {
      this.session.setScrollTop(y);
      this.session.setScrollLeft(y);
    };
    this.scrollBy = function (deltaX, deltaY) {
      deltaY && this.session.setScrollTop(this.session.getScrollTop() + deltaY);
      deltaX && this.session.setScrollLeft(this.session.getScrollLeft() + deltaX);
    };
    this.isScrollableBy = function (deltaX, deltaY) {
      if (deltaY < 0 && this.session.getScrollTop() >= 1 - this.scrollMargin.top)
        return true;
      if (deltaY > 0 && this.session.getScrollTop() + this.$size.scrollerHeight - this.layerConfig.maxHeight - (this.$size.scrollerHeight - this.lineHeight) * this.$scrollPastEnd < -1 + this.scrollMargin.bottom)
        return true;
      if (deltaX < 0 && this.session.getScrollLeft() >= 1 - this.scrollMargin.left)
        return true;
      if (deltaX > 0 && this.session.getScrollLeft() + this.$size.scrollerWidth - this.layerConfig.width < -1 + this.scrollMargin.right)
        return true;
    };
    this.pixelToScreenCoordinates = function (x, y) {
      var canvasPos = this.scroller.getBoundingClientRect();
      var offset = (x + this.scrollLeft - canvasPos.left - this.$padding) / this.characterWidth;
      var row = Math.floor((y + this.scrollTop - canvasPos.top) / this.lineHeight);
      var col = Math.round(offset);
      return {
        row: row,
        column: col,
        side: offset - col > 0 ? 1 : -1
      };
    };
    this.screenToTextCoordinates = function (x, y) {
      var canvasPos = this.scroller.getBoundingClientRect();
      var col = Math.round((x + this.scrollLeft - canvasPos.left - this.$padding) / this.characterWidth);
      var row = (y + this.scrollTop - canvasPos.top) / this.lineHeight;
      return this.session.screenToDocumentPosition(row, Math.max(col, 0));
    };
    this.textToScreenCoordinates = function (row, column) {
      var canvasPos = this.scroller.getBoundingClientRect();
      var pos = this.session.documentToScreenPosition(row, column);
      var x = this.$padding + Math.round(pos.column * this.characterWidth);
      var y = pos.row * this.lineHeight;
      return {
        pageX: canvasPos.left + x - this.scrollLeft,
        pageY: canvasPos.top + y - this.scrollTop
      };
    };
    this.visualizeFocus = function () {
      dom.addCssClass(this.container, 'ace_focus');
    };
    this.visualizeBlur = function () {
      dom.removeCssClass(this.container, 'ace_focus');
    };
    this.showComposition = function (position) {
      if (!this.$composition)
        this.$composition = {
          keepTextAreaAtCursor: this.$keepTextAreaAtCursor,
          cssText: this.textarea.style.cssText
        };
      this.$keepTextAreaAtCursor = true;
      dom.addCssClass(this.textarea, 'ace_composition');
      this.textarea.style.cssText = '';
      this.$moveTextAreaToCursor();
    };
    this.setCompositionText = function (text) {
      this.$moveTextAreaToCursor();
    };
    this.hideComposition = function () {
      if (!this.$composition)
        return;
      dom.removeCssClass(this.textarea, 'ace_composition');
      this.$keepTextAreaAtCursor = this.$composition.keepTextAreaAtCursor;
      this.textarea.style.cssText = this.$composition.cssText;
      this.$composition = null;
    };
    this.setTheme = function (theme, cb) {
      var _self = this;
      this.$themeId = theme;
      _self._dispatchEvent('themeChange', { theme: theme });
      if (!theme || typeof theme == 'string') {
        var moduleName = theme || this.$options.theme.initialValue;
        config.loadModule([
          'theme',
          moduleName
        ], afterLoad);
      } else {
        afterLoad(theme);
      }
      function afterLoad(module) {
        if (_self.$themeId != theme)
          return cb && cb();
        if (!module.cssClass)
          return;
        dom.importCssString(module.cssText, module.cssClass, _self.container.ownerDocument);
        if (_self.theme)
          dom.removeCssClass(_self.container, _self.theme.cssClass);
        var padding = 'padding' in module ? module.padding : 'padding' in (_self.theme || {}) ? 4 : _self.$padding;
        if (_self.$padding && padding != _self.$padding)
          _self.setPadding(padding);
        _self.$theme = module.cssClass;
        _self.theme = module;
        dom.addCssClass(_self.container, module.cssClass);
        dom.setCssClass(_self.container, 'ace_dark', module.isDark);
        if (_self.$size) {
          _self.$size.width = 0;
          _self.$updateSizeAsync();
        }
        _self._dispatchEvent('themeLoaded', { theme: module });
        cb && cb();
      }
    };
    this.getTheme = function () {
      return this.$themeId;
    };
    this.setStyle = function (style, include) {
      dom.setCssClass(this.container, style, include !== false);
    };
    this.unsetStyle = function (style) {
      dom.removeCssClass(this.container, style);
    };
    this.setCursorStyle = function (style) {
      if (this.content.style.cursor != style)
        this.content.style.cursor = style;
    };
    this.setMouseCursor = function (cursorStyle) {
      this.content.style.cursor = cursorStyle;
    };
    this.destroy = function () {
      this.$textLayer.destroy();
      this.$cursorLayer.destroy();
    };
  }.call(VirtualRenderer.prototype));
  config.defineOptions(VirtualRenderer.prototype, 'renderer', {
    animatedScroll: { initialValue: false },
    showInvisibles: {
      set: function (value) {
        if (this.$textLayer.setShowInvisibles(value))
          this.$loop.schedule(this.CHANGE_TEXT);
      },
      initialValue: false
    },
    showPrintMargin: {
      set: function () {
        this.$updatePrintMargin();
      },
      initialValue: true
    },
    printMarginColumn: {
      set: function () {
        this.$updatePrintMargin();
      },
      initialValue: 80
    },
    printMargin: {
      set: function (val) {
        if (typeof val == 'number')
          this.$printMarginColumn = val;
        this.$showPrintMargin = !!val;
        this.$updatePrintMargin();
      },
      get: function () {
        return this.$showPrintMargin && this.$printMarginColumn;
      }
    },
    showGutter: {
      set: function (show) {
        this.$gutter.style.display = show ? 'block' : 'none';
        this.$loop.schedule(this.CHANGE_FULL);
        this.onGutterResize();
      },
      initialValue: true
    },
    fadeFoldWidgets: {
      set: function (show) {
        dom.setCssClass(this.$gutter, 'ace_fade-fold-widgets', show);
      },
      initialValue: false
    },
    showFoldWidgets: {
      set: function (show) {
        this.$gutterLayer.setShowFoldWidgets(show);
      },
      initialValue: true
    },
    showLineNumbers: {
      set: function (show) {
        this.$gutterLayer.setShowLineNumbers(show);
        this.$loop.schedule(this.CHANGE_GUTTER);
      },
      initialValue: true
    },
    displayIndentGuides: {
      set: function (show) {
        if (this.$textLayer.setDisplayIndentGuides(show))
          this.$loop.schedule(this.CHANGE_TEXT);
      },
      initialValue: true
    },
    highlightGutterLine: {
      set: function (shouldHighlight) {
        if (!this.$gutterLineHighlight) {
          this.$gutterLineHighlight = dom.createElement('div');
          this.$gutterLineHighlight.className = 'ace_gutter-active-line';
          this.$gutter.appendChild(this.$gutterLineHighlight);
          return;
        }
        this.$gutterLineHighlight.style.display = shouldHighlight ? '' : 'none';
        if (this.$cursorLayer.$pixelPos)
          this.$updateGutterLineHighlight();
      },
      initialValue: false,
      value: true
    },
    hScrollBarAlwaysVisible: {
      set: function (val) {
        if (!this.$hScrollBarAlwaysVisible || !this.$horizScroll)
          this.$loop.schedule(this.CHANGE_SCROLL);
      },
      initialValue: false
    },
    vScrollBarAlwaysVisible: {
      set: function (val) {
        if (!this.$vScrollBarAlwaysVisible || !this.$vScroll)
          this.$loop.schedule(this.CHANGE_SCROLL);
      },
      initialValue: false
    },
    fontSize: {
      set: function (size) {
        if (typeof size == 'number')
          size = size + 'px';
        this.container.style.fontSize = size;
        this.updateFontSize();
      },
      initialValue: 12
    },
    fontFamily: {
      set: function (name) {
        this.container.style.fontFamily = name;
        this.updateFontSize();
      }
    },
    maxLines: {
      set: function (val) {
        this.updateFull();
      }
    },
    minLines: {
      set: function (val) {
        this.updateFull();
      }
    },
    scrollPastEnd: {
      set: function (val) {
        val = +val || 0;
        if (this.$scrollPastEnd == val)
          return;
        this.$scrollPastEnd = val;
        this.$loop.schedule(this.CHANGE_SCROLL);
      },
      initialValue: 0,
      handlesSet: true
    },
    fixedWidthGutter: {
      set: function (val) {
        this.$gutterLayer.$fixedWidth = !!val;
        this.$loop.schedule(this.CHANGE_GUTTER);
      }
    },
    theme: {
      set: function (val) {
        this.setTheme(val);
      },
      get: function () {
        return this.$themeId || this.theme;
      },
      initialValue: './theme/textmate',
      handlesSet: true
    }
  });
  exports.VirtualRenderer = VirtualRenderer;
});
ace.define('ace/config', [
  'require',
  'exports',
  'module',
  'ace/lib/lang',
  'ace/lib/oop',
  'ace/lib/net',
  'ace/lib/event_emitter'
], function (require, exports, module) {
  'no use strict';
  var lang = require('./lib/lang');
  var oop = require('./lib/oop');
  var net = require('./lib/net');
  var EventEmitter = require('./lib/event_emitter').EventEmitter;
  var global = function () {
      return this;
    }();
  var options = {
      packaged: false,
      workerPath: null,
      modePath: null,
      themePath: null,
      basePath: '',
      suffix: '.js',
      $moduleUrls: {}
    };
  exports.get = function (key) {
    if (!options.hasOwnProperty(key))
      throw new Error('Unknown config key: ' + key);
    return options[key];
  };
  exports.set = function (key, value) {
    if (!options.hasOwnProperty(key))
      throw new Error('Unknown config key: ' + key);
    options[key] = value;
  };
  exports.all = function () {
    return lang.copyObject(options);
  };
  oop.implement(exports, EventEmitter);
  exports.moduleUrl = function (name, component) {
    if (options.$moduleUrls[name])
      return options.$moduleUrls[name];
    var parts = name.split('/');
    component = component || parts[parts.length - 2] || '';
    var sep = component == 'snippets' ? '/' : '-';
    var base = parts[parts.length - 1];
    if (sep == '-') {
      var re = new RegExp('^' + component + '[\\-_]|[\\-_]' + component + '$', 'g');
      base = base.replace(re, '');
    }
    if ((!base || base == component) && parts.length > 1)
      base = parts[parts.length - 2];
    var path = options[component + 'Path'];
    if (path == null) {
      path = options.basePath;
    } else if (sep == '/') {
      component = sep = '';
    }
    if (path && path.slice(-1) != '/')
      path += '/';
    return path + component + sep + base + this.get('suffix');
  };
  exports.setModuleUrl = function (name, subst) {
    return options.$moduleUrls[name] = subst;
  };
  exports.$loading = {};
  exports.loadModule = function (moduleName, onLoad) {
    var module, moduleType;
    if (Array.isArray(moduleName)) {
      moduleType = moduleName[0];
      moduleName = moduleName[1];
    }
    try {
      module = require(moduleName);
    } catch (e) {
    }
    if (module && !exports.$loading[moduleName])
      return onLoad && onLoad(module);
    if (!exports.$loading[moduleName])
      exports.$loading[moduleName] = [];
    exports.$loading[moduleName].push(onLoad);
    if (exports.$loading[moduleName].length > 1)
      return;
    var afterLoad = function () {
      require([moduleName], function (module) {
        exports._emit('load.module', {
          name: moduleName,
          module: module
        });
        var listeners = exports.$loading[moduleName];
        exports.$loading[moduleName] = null;
        listeners.forEach(function (onLoad) {
          onLoad && onLoad(module);
        });
      });
    };
    if (!exports.get('packaged'))
      return afterLoad();
    net.loadScript(exports.moduleUrl(moduleName, moduleType), afterLoad);
  };
  init(true);
  function init(packaged) {
    options.packaged = packaged || require.packaged || module.packaged || global.define && define.packaged;
    if (!global.document)
      return '';
    var scriptOptions = {};
    var scriptUrl = '';
    var scripts = document.getElementsByTagName('script');
    for (var i = 0; i < scripts.length; i++) {
      var script = scripts[i];
      var src = script.src || script.getAttribute('src');
      if (!src)
        continue;
      var attributes = script.attributes;
      for (var j = 0, l = attributes.length; j < l; j++) {
        var attr = attributes[j];
        if (attr.name.indexOf('data-ace-') === 0) {
          scriptOptions[deHyphenate(attr.name.replace(/^data-ace-/, ''))] = attr.value;
        }
      }
      var m = src.match(/^(.*)\/ace(\-\w+)?\.js(\?|$)/);
      if (m)
        scriptUrl = m[1];
    }
    if (scriptUrl) {
      scriptOptions.base = scriptOptions.base || scriptUrl;
      scriptOptions.packaged = true;
    }
    scriptOptions.basePath = scriptOptions.base;
    scriptOptions.workerPath = scriptOptions.workerPath || scriptOptions.base;
    scriptOptions.modePath = scriptOptions.modePath || scriptOptions.base;
    scriptOptions.themePath = scriptOptions.themePath || scriptOptions.base;
    delete scriptOptions.base;
    for (var key in scriptOptions)
      if (typeof scriptOptions[key] !== 'undefined')
        exports.set(key, scriptOptions[key]);
  }
  ;
  exports.init = init;
  function deHyphenate(str) {
    return str.replace(/-(.)/g, function (m, m1) {
      return m1.toUpperCase();
    });
  }
  var optionsProvider = {
      setOptions: function (optList) {
        Object.keys(optList).forEach(function (key) {
          this.setOption(key, optList[key]);
        }, this);
      },
      getOptions: function (optionNames) {
        var result = {};
        if (!optionNames) {
          optionNames = Object.keys(this.$options);
        } else if (!Array.isArray(optionNames)) {
          result = optionNames;
          optionNames = Object.keys(result);
        }
        optionNames.forEach(function (key) {
          result[key] = this.getOption(key);
        }, this);
        return result;
      },
      setOption: function (name, value) {
        if (this['$' + name] === value)
          return;
        var opt = this.$options[name];
        if (!opt) {
          if (typeof console != 'undefined' && console.warn)
            console.warn('misspelled option "' + name + '"');
          return undefined;
        }
        if (opt.forwardTo)
          return this[opt.forwardTo] && this[opt.forwardTo].setOption(name, value);
        if (!opt.handlesSet)
          this['$' + name] = value;
        if (opt && opt.set)
          opt.set.call(this, value);
      },
      getOption: function (name) {
        var opt = this.$options[name];
        if (!opt) {
          if (typeof console != 'undefined' && console.warn)
            console.warn('misspelled option "' + name + '"');
          return undefined;
        }
        if (opt.forwardTo)
          return this[opt.forwardTo] && this[opt.forwardTo].getOption(name);
        return opt && opt.get ? opt.get.call(this) : this['$' + name];
      }
    };
  var defaultOptions = {};
  exports.defineOptions = function (obj, path, options) {
    if (!obj.$options)
      defaultOptions[path] = obj.$options = {};
    Object.keys(options).forEach(function (key) {
      var opt = options[key];
      if (typeof opt == 'string')
        opt = { forwardTo: opt };
      opt.name || (opt.name = key);
      obj.$options[opt.name] = opt;
      if ('initialValue' in opt)
        obj['$' + opt.name] = opt.initialValue;
    });
    oop.implement(obj, optionsProvider);
    return this;
  };
  exports.resetOptions = function (obj) {
    Object.keys(obj.$options).forEach(function (key) {
      var opt = obj.$options[key];
      if ('value' in opt)
        obj.setOption(key, opt.value);
    });
  };
  exports.setDefaultValue = function (path, name, value) {
    var opts = defaultOptions[path] || (defaultOptions[path] = {});
    if (opts[name]) {
      if (opts.forwardTo)
        exports.setDefaultValue(opts.forwardTo, name, value);
      else
        opts[name].value = value;
    }
  };
  exports.setDefaultValues = function (path, optionHash) {
    Object.keys(optionHash).forEach(function (key) {
      exports.setDefaultValue(path, key, optionHash[key]);
    });
  };
});
ace.define('ace/layer/gutter', [
  'require',
  'exports',
  'module',
  'ace/lib/dom',
  'ace/lib/oop',
  'ace/lib/lang',
  'ace/lib/event_emitter'
], function (require, exports, module) {
  var dom = require('../lib/dom');
  var oop = require('../lib/oop');
  var lang = require('../lib/lang');
  var EventEmitter = require('../lib/event_emitter').EventEmitter;
  var Gutter = function (parentEl) {
    this.element = dom.createElement('div');
    this.element.className = 'ace_layer ace_gutter-layer';
    parentEl.appendChild(this.element);
    this.setShowFoldWidgets(this.$showFoldWidgets);
    this.gutterWidth = 0;
    this.$annotations = [];
    this.$updateAnnotations = this.$updateAnnotations.bind(this);
    this.$cells = [];
  };
  (function () {
    oop.implement(this, EventEmitter);
    this.setSession = function (session) {
      if (this.session)
        this.session.removeEventListener('change', this.$updateAnnotations);
      this.session = session;
      session.on('change', this.$updateAnnotations);
    };
    this.addGutterDecoration = function (row, className) {
      if (window.console)
        console.warn && console.warn('deprecated use session.addGutterDecoration');
      this.session.addGutterDecoration(row, className);
    };
    this.removeGutterDecoration = function (row, className) {
      if (window.console)
        console.warn && console.warn('deprecated use session.removeGutterDecoration');
      this.session.removeGutterDecoration(row, className);
    };
    this.setAnnotations = function (annotations) {
      this.$annotations = [];
      for (var i = 0; i < annotations.length; i++) {
        var annotation = annotations[i];
        var row = annotation.row;
        var rowInfo = this.$annotations[row];
        if (!rowInfo)
          rowInfo = this.$annotations[row] = { text: [] };
        var annoText = annotation.text;
        annoText = annoText ? lang.escapeHTML(annoText) : annotation.html || '';
        if (rowInfo.text.indexOf(annoText) === -1)
          rowInfo.text.push(annoText);
        var type = annotation.type;
        if (type == 'error')
          rowInfo.className = ' ace_error';
        else if (type == 'warning' && rowInfo.className != ' ace_error')
          rowInfo.className = ' ace_warning';
        else if (type == 'info' && !rowInfo.className)
          rowInfo.className = ' ace_info';
      }
    };
    this.$updateAnnotations = function (e) {
      if (!this.$annotations.length)
        return;
      var delta = e.data;
      var range = delta.range;
      var firstRow = range.start.row;
      var len = range.end.row - firstRow;
      if (len === 0) {
      } else if (delta.action == 'removeText' || delta.action == 'removeLines') {
        this.$annotations.splice(firstRow, len + 1, null);
      } else {
        var args = new Array(len + 1);
        args.unshift(firstRow, 1);
        this.$annotations.splice.apply(this.$annotations, args);
      }
    };
    this.update = function (config) {
      var session = this.session;
      var firstRow = config.firstRow;
      var lastRow = Math.min(config.lastRow + config.gutterOffset, session.getLength() - 1);
      var fold = session.getNextFoldLine(firstRow);
      var foldStart = fold ? fold.start.row : Infinity;
      var foldWidgets = this.$showFoldWidgets && session.foldWidgets;
      var breakpoints = session.$breakpoints;
      var decorations = session.$decorations;
      var firstLineNumber = session.$firstLineNumber;
      var lastLineNumber = 0;
      var gutterRenderer = session.gutterRenderer || this.$renderer;
      var cell = null;
      var index = -1;
      var row = firstRow;
      while (true) {
        if (row > foldStart) {
          row = fold.end.row + 1;
          fold = session.getNextFoldLine(row, fold);
          foldStart = fold ? fold.start.row : Infinity;
        }
        if (row > lastRow) {
          while (this.$cells.length > index + 1) {
            cell = this.$cells.pop();
            this.element.removeChild(cell.element);
          }
          break;
        }
        cell = this.$cells[++index];
        if (!cell) {
          cell = {
            element: null,
            textNode: null,
            foldWidget: null
          };
          cell.element = dom.createElement('div');
          cell.textNode = document.createTextNode('');
          cell.element.appendChild(cell.textNode);
          this.element.appendChild(cell.element);
          this.$cells[index] = cell;
        }
        var className = 'ace_gutter-cell ';
        if (breakpoints[row])
          className += breakpoints[row];
        if (decorations[row])
          className += decorations[row];
        if (this.$annotations[row])
          className += this.$annotations[row].className;
        if (cell.element.className != className)
          cell.element.className = className;
        var height = session.getRowLength(row) * config.lineHeight + 'px';
        if (height != cell.element.style.height)
          cell.element.style.height = height;
        if (foldWidgets) {
          var c = foldWidgets[row];
          if (c == null)
            c = foldWidgets[row] = session.getFoldWidget(row);
        }
        if (c) {
          if (!cell.foldWidget) {
            cell.foldWidget = dom.createElement('span');
            cell.element.appendChild(cell.foldWidget);
          }
          var className = 'ace_fold-widget ace_' + c;
          if (c == 'start' && row == foldStart && row < fold.end.row)
            className += ' ace_closed';
          else
            className += ' ace_open';
          if (cell.foldWidget.className != className)
            cell.foldWidget.className = className;
          var height = config.lineHeight + 'px';
          if (cell.foldWidget.style.height != height)
            cell.foldWidget.style.height = height;
        } else {
          if (cell.foldWidget) {
            cell.element.removeChild(cell.foldWidget);
            cell.foldWidget = null;
          }
        }
        var text = lastLineNumber = gutterRenderer ? gutterRenderer.getText(session, row) : row + firstLineNumber;
        if (text != cell.textNode.data)
          cell.textNode.data = text;
        row++;
      }
      this.element.style.height = config.minHeight + 'px';
      if (this.$fixedWidth || session.$useWrapMode)
        lastLineNumber = session.getLength() + firstLineNumber;
      var gutterWidth = gutterRenderer ? gutterRenderer.getWidth(session, lastLineNumber, config) : lastLineNumber.toString().length * config.characterWidth;
      var padding = this.$padding || this.$computePadding();
      gutterWidth += padding.left + padding.right;
      if (gutterWidth !== this.gutterWidth && !isNaN(gutterWidth)) {
        this.gutterWidth = gutterWidth;
        this.element.style.width = Math.ceil(this.gutterWidth) + 'px';
        this._emit('changeGutterWidth', gutterWidth);
      }
    };
    this.$fixedWidth = false;
    this.$showLineNumbers = true;
    this.$renderer = '';
    this.setShowLineNumbers = function (show) {
      this.$renderer = !show && {
        getWidth: function () {
          return '';
        },
        getText: function () {
          return '';
        }
      };
    };
    this.getShowLineNumbers = function () {
      return this.$showLineNumbers;
    };
    this.$showFoldWidgets = true;
    this.setShowFoldWidgets = function (show) {
      if (show)
        dom.addCssClass(this.element, 'ace_folding-enabled');
      else
        dom.removeCssClass(this.element, 'ace_folding-enabled');
      this.$showFoldWidgets = show;
      this.$padding = null;
    };
    this.getShowFoldWidgets = function () {
      return this.$showFoldWidgets;
    };
    this.$computePadding = function () {
      if (!this.element.firstChild)
        return {
          left: 0,
          right: 0
        };
      var style = dom.computedStyle(this.element.firstChild);
      this.$padding = {};
      this.$padding.left = parseInt(style.paddingLeft) + 1 || 0;
      this.$padding.right = parseInt(style.paddingRight) || 0;
      return this.$padding;
    };
    this.getRegion = function (point) {
      var padding = this.$padding || this.$computePadding();
      var rect = this.element.getBoundingClientRect();
      if (point.x < padding.left + rect.left)
        return 'markers';
      if (this.$showFoldWidgets && point.x > rect.right - padding.right)
        return 'foldWidgets';
    };
  }.call(Gutter.prototype));
  exports.Gutter = Gutter;
});
ace.define('ace/mouse/dragdrop_handler', [
  'require',
  'exports',
  'module',
  'ace/lib/dom',
  'ace/lib/event',
  'ace/lib/useragent'
], function (require, exports, module) {
  var dom = require('../lib/dom');
  var event = require('../lib/event');
  var useragent = require('../lib/useragent');
  var AUTOSCROLL_DELAY = 200;
  var SCROLL_CURSOR_DELAY = 200;
  var SCROLL_CURSOR_HYSTERESIS = 5;
  function DragdropHandler(mouseHandler) {
    var editor = mouseHandler.editor;
    var blankImage = dom.createElement('img');
    blankImage.src = 'data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==';
    if (useragent.isOpera)
      blankImage.style.cssText = 'width:1px;height:1px;position:fixed;top:0;left:0;z-index:2147483647;opacity:0;';
    var exports = [
        'dragWait',
        'dragWaitEnd',
        'startDrag',
        'dragReadyEnd',
        'onMouseDrag'
      ];
    exports.forEach(function (x) {
      mouseHandler[x] = this[x];
    }, this);
    editor.addEventListener('mousedown', this.onMouseDown.bind(mouseHandler));
    var mouseTarget = editor.container;
    var dragSelectionMarker, x, y;
    var timerId, range;
    var dragCursor, counter = 0;
    var dragOperation;
    var isInternal;
    var autoScrollStartTime;
    var cursorMovedTime;
    var cursorPointOnCaretMoved;
    this.onDragStart = function (e) {
      if (this.cancelDrag || !mouseTarget.draggable) {
        var self = this;
        setTimeout(function () {
          self.startSelect();
          self.captureMouse(e);
        }, 0);
        return e.preventDefault();
      }
      range = editor.getSelectionRange();
      var dataTransfer = e.dataTransfer;
      dataTransfer.effectAllowed = editor.getReadOnly() ? 'copy' : 'copyMove';
      if (useragent.isOpera) {
        editor.container.appendChild(blankImage);
        blankImage._top = blankImage.offsetTop;
      }
      dataTransfer.setDragImage && dataTransfer.setDragImage(blankImage, 0, 0);
      if (useragent.isOpera) {
        editor.container.removeChild(blankImage);
      }
      dataTransfer.clearData();
      dataTransfer.setData('Text', editor.session.getTextRange());
      isInternal = true;
      this.setState('drag');
    };
    this.onDragEnd = function (e) {
      mouseTarget.draggable = false;
      isInternal = false;
      this.setState(null);
      if (!editor.getReadOnly()) {
        var dropEffect = e.dataTransfer.dropEffect;
        if (!dragOperation && dropEffect == 'move')
          editor.session.remove(editor.getSelectionRange());
        editor.renderer.$cursorLayer.setBlinking(true);
      }
      this.editor.unsetStyle('ace_dragging');
    };
    this.onDragEnter = function (e) {
      if (editor.getReadOnly() || !canAccept(e.dataTransfer))
        return;
      if (!dragSelectionMarker)
        addDragMarker();
      counter++;
      e.dataTransfer.dropEffect = dragOperation = getDropEffect(e);
      return event.preventDefault(e);
    };
    this.onDragOver = function (e) {
      if (editor.getReadOnly() || !canAccept(e.dataTransfer))
        return;
      if (!dragSelectionMarker) {
        addDragMarker();
        counter++;
      }
      if (onMouseMoveTimer !== null)
        onMouseMoveTimer = null;
      x = e.clientX;
      y = e.clientY;
      e.dataTransfer.dropEffect = dragOperation = getDropEffect(e);
      return event.preventDefault(e);
    };
    this.onDragLeave = function (e) {
      counter--;
      if (counter <= 0 && dragSelectionMarker) {
        clearDragMarker();
        dragOperation = null;
        return event.preventDefault(e);
      }
    };
    this.onDrop = function (e) {
      if (!dragSelectionMarker)
        return;
      var dataTransfer = e.dataTransfer;
      if (isInternal) {
        switch (dragOperation) {
        case 'move':
          if (range.contains(dragCursor.row, dragCursor.column)) {
            range = {
              start: dragCursor,
              end: dragCursor
            };
          } else {
            range = editor.moveText(range, dragCursor);
          }
          break;
        case 'copy':
          range = editor.moveText(range, dragCursor, true);
          break;
        }
      } else {
        var dropData = dataTransfer.getData('Text');
        range = {
          start: dragCursor,
          end: editor.session.insert(dragCursor, dropData)
        };
        editor.focus();
        dragOperation = null;
      }
      clearDragMarker();
      return event.preventDefault(e);
    };
    event.addListener(mouseTarget, 'dragstart', this.onDragStart.bind(mouseHandler));
    event.addListener(mouseTarget, 'dragend', this.onDragEnd.bind(mouseHandler));
    event.addListener(mouseTarget, 'dragenter', this.onDragEnter.bind(mouseHandler));
    event.addListener(mouseTarget, 'dragover', this.onDragOver.bind(mouseHandler));
    event.addListener(mouseTarget, 'dragleave', this.onDragLeave.bind(mouseHandler));
    event.addListener(mouseTarget, 'drop', this.onDrop.bind(mouseHandler));
    function scrollCursorIntoView(cursor, prevCursor) {
      var now = Date.now();
      var vMovement = !prevCursor || cursor.row != prevCursor.row;
      var hMovement = !prevCursor || cursor.column != prevCursor.column;
      if (!cursorMovedTime || vMovement || hMovement) {
        editor.$blockScrolling += 1;
        editor.moveCursorToPosition(cursor);
        editor.$blockScrolling -= 1;
        cursorMovedTime = now;
        cursorPointOnCaretMoved = {
          x: x,
          y: y
        };
      } else {
        var distance = calcDistance(cursorPointOnCaretMoved.x, cursorPointOnCaretMoved.y, x, y);
        if (distance > SCROLL_CURSOR_HYSTERESIS) {
          cursorMovedTime = null;
        } else if (now - cursorMovedTime >= SCROLL_CURSOR_DELAY) {
          editor.renderer.scrollCursorIntoView();
          cursorMovedTime = null;
        }
      }
    }
    function autoScroll(cursor, prevCursor) {
      var now = Date.now();
      var lineHeight = editor.renderer.layerConfig.lineHeight;
      var characterWidth = editor.renderer.layerConfig.characterWidth;
      var editorRect = editor.renderer.scroller.getBoundingClientRect();
      var offsets = {
          x: {
            left: x - editorRect.left,
            right: editorRect.right - x
          },
          y: {
            top: y - editorRect.top,
            bottom: editorRect.bottom - y
          }
        };
      var nearestXOffset = Math.min(offsets.x.left, offsets.x.right);
      var nearestYOffset = Math.min(offsets.y.top, offsets.y.bottom);
      var scrollCursor = {
          row: cursor.row,
          column: cursor.column
        };
      if (nearestXOffset / characterWidth <= 2) {
        scrollCursor.column += offsets.x.left < offsets.x.right ? -3 : +2;
      }
      if (nearestYOffset / lineHeight <= 1) {
        scrollCursor.row += offsets.y.top < offsets.y.bottom ? -1 : +1;
      }
      var vScroll = cursor.row != scrollCursor.row;
      var hScroll = cursor.column != scrollCursor.column;
      var vMovement = !prevCursor || cursor.row != prevCursor.row;
      if (vScroll || hScroll && !vMovement) {
        if (!autoScrollStartTime)
          autoScrollStartTime = now;
        else if (now - autoScrollStartTime >= AUTOSCROLL_DELAY)
          editor.renderer.scrollCursorIntoView(scrollCursor);
      } else {
        autoScrollStartTime = null;
      }
    }
    function onDragInterval() {
      var prevCursor = dragCursor;
      dragCursor = editor.renderer.screenToTextCoordinates(x, y);
      scrollCursorIntoView(dragCursor, prevCursor);
      autoScroll(dragCursor, prevCursor);
    }
    function addDragMarker() {
      range = editor.selection.toOrientedRange();
      dragSelectionMarker = editor.session.addMarker(range, 'ace_selection', editor.getSelectionStyle());
      editor.clearSelection();
      if (editor.isFocused())
        editor.renderer.$cursorLayer.setBlinking(false);
      clearInterval(timerId);
      timerId = setInterval(onDragInterval, 20);
      counter = 0;
      event.addListener(document, 'mousemove', onMouseMove);
    }
    function clearDragMarker() {
      clearInterval(timerId);
      editor.session.removeMarker(dragSelectionMarker);
      dragSelectionMarker = null;
      editor.$blockScrolling += 1;
      editor.selection.fromOrientedRange(range);
      editor.$blockScrolling -= 1;
      if (editor.isFocused() && !isInternal)
        editor.renderer.$cursorLayer.setBlinking(!editor.getReadOnly());
      range = null;
      counter = 0;
      autoScrollStartTime = null;
      cursorMovedTime = null;
      event.removeListener(document, 'mousemove', onMouseMove);
    }
    var onMouseMoveTimer = null;
    function onMouseMove() {
      if (onMouseMoveTimer == null) {
        onMouseMoveTimer = setTimeout(function () {
          if (onMouseMoveTimer != null && dragSelectionMarker)
            clearDragMarker();
        }, 20);
      }
    }
    function canAccept(dataTransfer) {
      var types = dataTransfer.types;
      return !types || Array.prototype.some.call(types, function (type) {
        return type == 'text/plain' || type == 'Text';
      });
    }
    function getDropEffect(e) {
      var copyAllowed = [
          'copy',
          'copymove',
          'all',
          'uninitialized'
        ];
      var moveAllowed = [
          'move',
          'copymove',
          'linkmove',
          'all',
          'uninitialized'
        ];
      var copyModifierState = useragent.isMac ? e.altKey : e.ctrlKey;
      var effectAllowed = 'uninitialized';
      try {
        effectAllowed = e.dataTransfer.effectAllowed.toLowerCase();
      } catch (e) {
      }
      var dropEffect = 'none';
      if (copyModifierState && copyAllowed.indexOf(effectAllowed) >= 0)
        dropEffect = 'copy';
      else if (moveAllowed.indexOf(effectAllowed) >= 0)
        dropEffect = 'move';
      else if (copyAllowed.indexOf(effectAllowed) >= 0)
        dropEffect = 'copy';
      return dropEffect;
    }
  }
  (function () {
    this.dragWait = function () {
      var interval = Date.now() - this.mousedownEvent.time;
      if (interval > this.editor.getDragDelay())
        this.startDrag();
    };
    this.dragWaitEnd = function () {
      var target = this.editor.container;
      target.draggable = false;
      this.startSelect(this.mousedownEvent.getDocumentPosition());
      this.selectEnd();
    };
    this.dragReadyEnd = function (e) {
      this.editor.renderer.$cursorLayer.setBlinking(!this.editor.getReadOnly());
      this.editor.unsetStyle('ace_dragging');
      this.dragWaitEnd();
    };
    this.startDrag = function () {
      this.cancelDrag = false;
      var target = this.editor.container;
      target.draggable = true;
      this.editor.renderer.$cursorLayer.setBlinking(false);
      this.editor.setStyle('ace_dragging');
      this.setState('dragReady');
    };
    this.onMouseDrag = function (e) {
      var target = this.editor.container;
      if (useragent.isIE && this.state == 'dragReady') {
        var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
        if (distance > 3)
          target.dragDrop();
      }
      if (this.state === 'dragWait') {
        var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
        if (distance > 0) {
          target.draggable = false;
          this.startSelect(this.mousedownEvent.getDocumentPosition());
        }
      }
    };
    this.onMouseDown = function (e) {
      if (!this.$dragEnabled)
        return;
      this.mousedownEvent = e;
      var editor = this.editor;
      var inSelection = e.inSelection();
      var button = e.getButton();
      var clickCount = e.domEvent.detail || 1;
      if (clickCount === 1 && button === 0 && inSelection) {
        if (e.editor.inMultiSelectMode && (e.getAccelKey() || e.getShiftKey()))
          return;
        this.mousedownEvent.time = Date.now();
        var eventTarget = e.domEvent.target || e.domEvent.srcElement;
        if ('unselectable' in eventTarget)
          eventTarget.unselectable = 'on';
        if (editor.getDragDelay()) {
          if (useragent.isWebKit) {
            this.cancelDrag = true;
            var mouseTarget = editor.container;
            mouseTarget.draggable = true;
          }
          this.setState('dragWait');
        } else {
          this.startDrag();
        }
        this.captureMouse(e, this.onMouseDrag.bind(this));
        e.defaultPrevented = true;
      }
    };
  }.call(DragdropHandler.prototype));
  function calcDistance(ax, ay, bx, by) {
    return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));
  }
  exports.DragdropHandler = DragdropHandler;
});
ace.define('ace/layer/marker', [
  'require',
  'exports',
  'module',
  'ace/range',
  'ace/lib/dom'
], function (require, exports, module) {
  var Range = require('../range').Range;
  var dom = require('../lib/dom');
  var Marker = function (parentEl) {
    this.element = dom.createElement('div');
    this.element.className = 'ace_layer ace_marker-layer';
    parentEl.appendChild(this.element);
  };
  (function () {
    this.$padding = 0;
    this.setPadding = function (padding) {
      this.$padding = padding;
    };
    this.setSession = function (session) {
      this.session = session;
    };
    this.setMarkers = function (markers) {
      this.markers = markers;
    };
    this.update = function (config) {
      var config = config || this.config;
      if (!config)
        return;
      this.config = config;
      var html = [];
      for (var key in this.markers) {
        var marker = this.markers[key];
        if (!marker.range) {
          marker.update(html, this, this.session, config);
          continue;
        }
        var range = marker.range.clipRows(config.firstRow, config.lastRow);
        if (range.isEmpty())
          continue;
        range = range.toScreenRange(this.session);
        if (marker.renderer) {
          var top = this.$getTop(range.start.row, config);
          var left = this.$padding + range.start.column * config.characterWidth;
          marker.renderer(html, range, left, top, config);
        } else if (marker.type == 'fullLine') {
          this.drawFullLineMarker(html, range, marker.clazz, config);
        } else if (marker.type == 'screenLine') {
          this.drawScreenLineMarker(html, range, marker.clazz, config);
        } else if (range.isMultiLine()) {
          if (marker.type == 'text')
            this.drawTextMarker(html, range, marker.clazz, config);
          else
            this.drawMultiLineMarker(html, range, marker.clazz, config);
        } else {
          this.drawSingleLineMarker(html, range, marker.clazz + ' ace_start', config);
        }
      }
      this.element = dom.setInnerHtml(this.element, html.join(''));
    };
    this.$getTop = function (row, layerConfig) {
      return (row - layerConfig.firstRowScreen) * layerConfig.lineHeight;
    };
    this.drawTextMarker = function (stringBuilder, range, clazz, layerConfig, extraStyle) {
      var row = range.start.row;
      var lineRange = new Range(row, range.start.column, row, this.session.getScreenLastRowColumn(row));
      this.drawSingleLineMarker(stringBuilder, lineRange, clazz + ' ace_start', layerConfig, 1, extraStyle);
      row = range.end.row;
      lineRange = new Range(row, 0, row, range.end.column);
      this.drawSingleLineMarker(stringBuilder, lineRange, clazz, layerConfig, 0, extraStyle);
      for (row = range.start.row + 1; row < range.end.row; row++) {
        lineRange.start.row = row;
        lineRange.end.row = row;
        lineRange.end.column = this.session.getScreenLastRowColumn(row);
        this.drawSingleLineMarker(stringBuilder, lineRange, clazz, layerConfig, 1, extraStyle);
      }
    };
    this.drawMultiLineMarker = function (stringBuilder, range, clazz, config, extraStyle) {
      var padding = this.$padding;
      var height = config.lineHeight;
      var top = this.$getTop(range.start.row, config);
      var left = padding + range.start.column * config.characterWidth;
      extraStyle = extraStyle || '';
      stringBuilder.push('<div class=\'', clazz, ' ace_start\' style=\'', 'height:', height, 'px;', 'right:0;', 'top:', top, 'px;', 'left:', left, 'px;', extraStyle, '\'></div>');
      top = this.$getTop(range.end.row, config);
      var width = range.end.column * config.characterWidth;
      stringBuilder.push('<div class=\'', clazz, '\' style=\'', 'height:', height, 'px;', 'width:', width, 'px;', 'top:', top, 'px;', 'left:', padding, 'px;', extraStyle, '\'></div>');
      height = (range.end.row - range.start.row - 1) * config.lineHeight;
      if (height < 0)
        return;
      top = this.$getTop(range.start.row + 1, config);
      stringBuilder.push('<div class=\'', clazz, '\' style=\'', 'height:', height, 'px;', 'right:0;', 'top:', top, 'px;', 'left:', padding, 'px;', extraStyle, '\'></div>');
    };
    this.drawSingleLineMarker = function (stringBuilder, range, clazz, config, extraLength, extraStyle) {
      var height = config.lineHeight;
      var width = (range.end.column + (extraLength || 0) - range.start.column) * config.characterWidth;
      var top = this.$getTop(range.start.row, config);
      var left = this.$padding + range.start.column * config.characterWidth;
      stringBuilder.push('<div class=\'', clazz, '\' style=\'', 'height:', height, 'px;', 'width:', width, 'px;', 'top:', top, 'px;', 'left:', left, 'px;', extraStyle || '', '\'></div>');
    };
    this.drawFullLineMarker = function (stringBuilder, range, clazz, config, extraStyle) {
      var top = this.$getTop(range.start.row, config);
      var height = config.lineHeight;
      if (range.start.row != range.end.row)
        height += this.$getTop(range.end.row, config) - top;
      stringBuilder.push('<div class=\'', clazz, '\' style=\'', 'height:', height, 'px;', 'top:', top, 'px;', 'left:0;right:0;', extraStyle || '', '\'></div>');
    };
    this.drawScreenLineMarker = function (stringBuilder, range, clazz, config, extraStyle) {
      var top = this.$getTop(range.start.row, config);
      var height = config.lineHeight;
      stringBuilder.push('<div class=\'', clazz, '\' style=\'', 'height:', height, 'px;', 'top:', top, 'px;', 'left:0;right:0;', extraStyle || '', '\'></div>');
    };
  }.call(Marker.prototype));
  exports.Marker = Marker;
});
ace.define('ace/mouse/mouse_event', [
  'require',
  'exports',
  'module',
  'ace/lib/event',
  'ace/lib/useragent'
], function (require, exports, module) {
  var event = require('../lib/event');
  var useragent = require('../lib/useragent');
  var MouseEvent = exports.MouseEvent = function (domEvent, editor) {
      this.domEvent = domEvent;
      this.editor = editor;
      this.x = this.clientX = domEvent.clientX;
      this.y = this.clientY = domEvent.clientY;
      this.$pos = null;
      this.$inSelection = null;
      this.propagationStopped = false;
      this.defaultPrevented = false;
    };
  (function () {
    this.stopPropagation = function () {
      event.stopPropagation(this.domEvent);
      this.propagationStopped = true;
    };
    this.preventDefault = function () {
      event.preventDefault(this.domEvent);
      this.defaultPrevented = true;
    };
    this.stop = function () {
      this.stopPropagation();
      this.preventDefault();
    };
    this.getDocumentPosition = function () {
      if (this.$pos)
        return this.$pos;
      this.$pos = this.editor.renderer.screenToTextCoordinates(this.clientX, this.clientY);
      return this.$pos;
    };
    this.inSelection = function () {
      if (this.$inSelection !== null)
        return this.$inSelection;
      var editor = this.editor;
      var selectionRange = editor.getSelectionRange();
      if (selectionRange.isEmpty())
        this.$inSelection = false;
      else {
        var pos = this.getDocumentPosition();
        this.$inSelection = selectionRange.contains(pos.row, pos.column);
      }
      return this.$inSelection;
    };
    this.getButton = function () {
      return event.getButton(this.domEvent);
    };
    this.getShiftKey = function () {
      return this.domEvent.shiftKey;
    };
    this.getAccelKey = useragent.isMac ? function () {
      return this.domEvent.metaKey;
    } : function () {
      return this.domEvent.ctrlKey;
    };
  }.call(MouseEvent.prototype));
});
ace.define('ace/layer/text', [
  'require',
  'exports',
  'module',
  'ace/lib/oop',
  'ace/lib/dom',
  'ace/lib/lang',
  'ace/lib/useragent',
  'ace/lib/event_emitter'
], function (require, exports, module) {
  var oop = require('../lib/oop');
  var dom = require('../lib/dom');
  var lang = require('../lib/lang');
  var useragent = require('../lib/useragent');
  var EventEmitter = require('../lib/event_emitter').EventEmitter;
  var Text = function (parentEl) {
    this.element = dom.createElement('div');
    this.element.className = 'ace_layer ace_text-layer';
    parentEl.appendChild(this.element);
    this.$updateEolChar = this.$updateEolChar.bind(this);
  };
  (function () {
    oop.implement(this, EventEmitter);
    this.EOF_CHAR = '\xb6';
    this.EOL_CHAR_LF = '\xac';
    this.EOL_CHAR_CRLF = '\xa4';
    this.EOL_CHAR = this.EOL_CHAR_LF;
    this.TAB_CHAR = '\u2192';
    this.SPACE_CHAR = '\xb7';
    this.$padding = 0;
    this.$updateEolChar = function () {
      var EOL_CHAR = this.session.doc.getNewLineCharacter() == '\n' ? this.EOL_CHAR_LF : this.EOL_CHAR_CRLF;
      if (this.EOL_CHAR != EOL_CHAR) {
        this.EOL_CHAR = EOL_CHAR;
        return true;
      }
    };
    this.setPadding = function (padding) {
      this.$padding = padding;
      this.element.style.padding = '0 ' + padding + 'px';
    };
    this.getLineHeight = function () {
      return this.$fontMetrics.$characterSize.height || 0;
    };
    this.getCharacterWidth = function () {
      return this.$fontMetrics.$characterSize.width || 0;
    };
    this.$setFontMetrics = function (measure) {
      this.$fontMetrics = measure;
      this.$fontMetrics.on('changeCharacterSize', function (e) {
        this._signal('changeCharacterSize', e);
      }.bind(this));
      this.$pollSizeChanges();
    };
    this.checkForSizeChanges = function () {
      this.$fontMetrics.checkForSizeChanges();
    };
    this.$pollSizeChanges = function () {
      return this.$pollSizeChangesTimer = this.$fontMetrics.$pollSizeChanges();
    };
    this.setSession = function (session) {
      this.session = session;
      this.$computeTabString();
    };
    this.showInvisibles = false;
    this.setShowInvisibles = function (showInvisibles) {
      if (this.showInvisibles == showInvisibles)
        return false;
      this.showInvisibles = showInvisibles;
      this.$computeTabString();
      return true;
    };
    this.displayIndentGuides = true;
    this.setDisplayIndentGuides = function (display) {
      if (this.displayIndentGuides == display)
        return false;
      this.displayIndentGuides = display;
      this.$computeTabString();
      return true;
    };
    this.$tabStrings = [];
    this.onChangeTabSize = this.$computeTabString = function () {
      var tabSize = this.session.getTabSize();
      this.tabSize = tabSize;
      var tabStr = this.$tabStrings = [0];
      for (var i = 1; i < tabSize + 1; i++) {
        if (this.showInvisibles) {
          tabStr.push('<span class=\'ace_invisible\'>' + this.TAB_CHAR + lang.stringRepeat('\xa0', i - 1) + '</span>');
        } else {
          tabStr.push(lang.stringRepeat('\xa0', i));
        }
      }
      if (this.displayIndentGuides) {
        this.$indentGuideRe = /\s\S| \t|\t |\s$/;
        var className = 'ace_indent-guide';
        if (this.showInvisibles) {
          className += ' ace_invisible';
          var spaceContent = lang.stringRepeat(this.SPACE_CHAR, this.tabSize);
          var tabContent = this.TAB_CHAR + lang.stringRepeat('\xa0', this.tabSize - 1);
        } else {
          var spaceContent = lang.stringRepeat('\xa0', this.tabSize);
          var tabContent = spaceContent;
        }
        this.$tabStrings[' '] = '<span class=\'' + className + '\'>' + spaceContent + '</span>';
        this.$tabStrings['\t'] = '<span class=\'' + className + '\'>' + tabContent + '</span>';
      }
    };
    this.updateLines = function (config, firstRow, lastRow) {
      if (this.config.lastRow != config.lastRow || this.config.firstRow != config.firstRow) {
        this.scrollLines(config);
      }
      this.config = config;
      var first = Math.max(firstRow, config.firstRow);
      var last = Math.min(lastRow, config.lastRow);
      var lineElements = this.element.childNodes;
      var lineElementsIdx = 0;
      for (var row = config.firstRow; row < first; row++) {
        var foldLine = this.session.getFoldLine(row);
        if (foldLine) {
          if (foldLine.containsRow(first)) {
            first = foldLine.start.row;
            break;
          } else {
            row = foldLine.end.row;
          }
        }
        lineElementsIdx++;
      }
      var row = first;
      var foldLine = this.session.getNextFoldLine(row);
      var foldStart = foldLine ? foldLine.start.row : Infinity;
      while (true) {
        if (row > foldStart) {
          row = foldLine.end.row + 1;
          foldLine = this.session.getNextFoldLine(row, foldLine);
          foldStart = foldLine ? foldLine.start.row : Infinity;
        }
        if (row > last)
          break;
        var lineElement = lineElements[lineElementsIdx++];
        if (lineElement) {
          var html = [];
          this.$renderLine(html, row, !this.$useLineGroups(), row == foldStart ? foldLine : false);
          lineElement.style.height = config.lineHeight * this.session.getRowLength(row) + 'px';
          dom.setInnerHtml(lineElement, html.join(''));
        }
        row++;
      }
    };
    this.scrollLines = function (config) {
      var oldConfig = this.config;
      this.config = config;
      if (!oldConfig || oldConfig.lastRow < config.firstRow)
        return this.update(config);
      if (config.lastRow < oldConfig.firstRow)
        return this.update(config);
      var el = this.element;
      if (oldConfig.firstRow < config.firstRow)
        for (var row = this.session.getFoldedRowCount(oldConfig.firstRow, config.firstRow - 1); row > 0; row--)
          el.removeChild(el.firstChild);
      if (oldConfig.lastRow > config.lastRow)
        for (var row = this.session.getFoldedRowCount(config.lastRow + 1, oldConfig.lastRow); row > 0; row--)
          el.removeChild(el.lastChild);
      if (config.firstRow < oldConfig.firstRow) {
        var fragment = this.$renderLinesFragment(config, config.firstRow, oldConfig.firstRow - 1);
        if (el.firstChild)
          el.insertBefore(fragment, el.firstChild);
        else
          el.appendChild(fragment);
      }
      if (config.lastRow > oldConfig.lastRow) {
        var fragment = this.$renderLinesFragment(config, oldConfig.lastRow + 1, config.lastRow);
        el.appendChild(fragment);
      }
    };
    this.$renderLinesFragment = function (config, firstRow, lastRow) {
      var fragment = this.element.ownerDocument.createDocumentFragment();
      var row = firstRow;
      var foldLine = this.session.getNextFoldLine(row);
      var foldStart = foldLine ? foldLine.start.row : Infinity;
      while (true) {
        if (row > foldStart) {
          row = foldLine.end.row + 1;
          foldLine = this.session.getNextFoldLine(row, foldLine);
          foldStart = foldLine ? foldLine.start.row : Infinity;
        }
        if (row > lastRow)
          break;
        var container = dom.createElement('div');
        var html = [];
        this.$renderLine(html, row, false, row == foldStart ? foldLine : false);
        container.innerHTML = html.join('');
        if (this.$useLineGroups()) {
          container.className = 'ace_line_group';
          fragment.appendChild(container);
          container.style.height = config.lineHeight * this.session.getRowLength(row) + 'px';
        } else {
          while (container.firstChild)
            fragment.appendChild(container.firstChild);
        }
        row++;
      }
      return fragment;
    };
    this.update = function (config) {
      this.config = config;
      var html = [];
      var firstRow = config.firstRow, lastRow = config.lastRow;
      var row = firstRow;
      var foldLine = this.session.getNextFoldLine(row);
      var foldStart = foldLine ? foldLine.start.row : Infinity;
      while (true) {
        if (row > foldStart) {
          row = foldLine.end.row + 1;
          foldLine = this.session.getNextFoldLine(row, foldLine);
          foldStart = foldLine ? foldLine.start.row : Infinity;
        }
        if (row > lastRow)
          break;
        if (this.$useLineGroups())
          html.push('<div class=\'ace_line_group\' style=\'height:', config.lineHeight * this.session.getRowLength(row), 'px\'>');
        this.$renderLine(html, row, false, row == foldStart ? foldLine : false);
        if (this.$useLineGroups())
          html.push('</div>');
        row++;
      }
      this.element = dom.setInnerHtml(this.element, html.join(''));
    };
    this.$textToken = {
      'text': true,
      'rparen': true,
      'lparen': true
    };
    this.$renderToken = function (stringBuilder, screenColumn, token, value) {
      var self = this;
      var replaceReg = /\t|&|<|( +)|([\x00-\x1f\x80-\xa0\u1680\u180E\u2000-\u200f\u2028\u2029\u202F\u205F\u3000\uFEFF])|[\u1100-\u115F\u11A3-\u11A7\u11FA-\u11FF\u2329-\u232A\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFB\u3000-\u303E\u3041-\u3096\u3099-\u30FF\u3105-\u312D\u3131-\u318E\u3190-\u31BA\u31C0-\u31E3\u31F0-\u321E\u3220-\u3247\u3250-\u32FE\u3300-\u4DBF\u4E00-\uA48C\uA490-\uA4C6\uA960-\uA97C\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFAFF\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE66\uFE68-\uFE6B\uFF01-\uFF60\uFFE0-\uFFE6]/g;
      var replaceFunc = function (c, a, b, tabIdx, idx4) {
        if (a) {
          return self.showInvisibles ? '<span class=\'ace_invisible\'>' + lang.stringRepeat(self.SPACE_CHAR, c.length) + '</span>' : lang.stringRepeat('\xa0', c.length);
        } else if (c == '&') {
          return '&#38;';
        } else if (c == '<') {
          return '&#60;';
        } else if (c == '\t') {
          var tabSize = self.session.getScreenTabSize(screenColumn + tabIdx);
          screenColumn += tabSize - 1;
          return self.$tabStrings[tabSize];
        } else if (c == '\u3000') {
          var classToUse = self.showInvisibles ? 'ace_cjk ace_invisible' : 'ace_cjk';
          var space = self.showInvisibles ? self.SPACE_CHAR : '';
          screenColumn += 1;
          return '<span class=\'' + classToUse + '\' style=\'width:' + self.config.characterWidth * 2 + 'px\'>' + space + '</span>';
        } else if (b) {
          return '<span class=\'ace_invisible ace_invalid\'>' + self.SPACE_CHAR + '</span>';
        } else {
          screenColumn += 1;
          return '<span class=\'ace_cjk\' style=\'width:' + self.config.characterWidth * 2 + 'px\'>' + c + '</span>';
        }
      };
      var output = value.replace(replaceReg, replaceFunc);
      if (!this.$textToken[token.type]) {
        var classes = 'ace_' + token.type.replace(/\./g, ' ace_');
        var style = '';
        if (token.type == 'fold')
          style = ' style=\'width:' + token.value.length * this.config.characterWidth + 'px;\' ';
        stringBuilder.push('<span class=\'', classes, '\'', style, '>', output, '</span>');
      } else {
        stringBuilder.push(output);
      }
      return screenColumn + value.length;
    };
    this.renderIndentGuide = function (stringBuilder, value, max) {
      var cols = value.search(this.$indentGuideRe);
      if (cols <= 0 || cols >= max)
        return value;
      if (value[0] == ' ') {
        cols -= cols % this.tabSize;
        stringBuilder.push(lang.stringRepeat(this.$tabStrings[' '], cols / this.tabSize));
        return value.substr(cols);
      } else if (value[0] == '\t') {
        stringBuilder.push(lang.stringRepeat(this.$tabStrings['\t'], cols));
        return value.substr(cols);
      }
      return value;
    };
    this.$renderWrappedLine = function (stringBuilder, tokens, splits, onlyContents) {
      var chars = 0;
      var split = 0;
      var splitChars = splits[0];
      var screenColumn = 0;
      for (var i = 0; i < tokens.length; i++) {
        var token = tokens[i];
        var value = token.value;
        if (i == 0 && this.displayIndentGuides) {
          chars = value.length;
          value = this.renderIndentGuide(stringBuilder, value, splitChars);
          if (!value)
            continue;
          chars -= value.length;
        }
        if (chars + value.length < splitChars) {
          screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value);
          chars += value.length;
        } else {
          while (chars + value.length >= splitChars) {
            screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value.substring(0, splitChars - chars));
            value = value.substring(splitChars - chars);
            chars = splitChars;
            if (!onlyContents) {
              stringBuilder.push('</div>', '<div class=\'ace_line\' style=\'height:', this.config.lineHeight, 'px\'>');
            }
            split++;
            screenColumn = 0;
            splitChars = splits[split] || Number.MAX_VALUE;
          }
          if (value.length != 0) {
            chars += value.length;
            screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value);
          }
        }
      }
    };
    this.$renderSimpleLine = function (stringBuilder, tokens) {
      var screenColumn = 0;
      var token = tokens[0];
      var value = token.value;
      if (this.displayIndentGuides)
        value = this.renderIndentGuide(stringBuilder, value);
      if (value)
        screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value);
      for (var i = 1; i < tokens.length; i++) {
        token = tokens[i];
        value = token.value;
        screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value);
      }
    };
    this.$renderLine = function (stringBuilder, row, onlyContents, foldLine) {
      if (!foldLine && foldLine != false)
        foldLine = this.session.getFoldLine(row);
      if (foldLine)
        var tokens = this.$getFoldLineTokens(row, foldLine);
      else
        var tokens = this.session.getTokens(row);
      if (!onlyContents) {
        stringBuilder.push('<div class=\'ace_line\' style=\'height:', this.config.lineHeight * (this.$useLineGroups() ? 1 : this.session.getRowLength(row)), 'px\'>');
      }
      if (tokens.length) {
        var splits = this.session.getRowSplitData(row);
        if (splits && splits.length)
          this.$renderWrappedLine(stringBuilder, tokens, splits, onlyContents);
        else
          this.$renderSimpleLine(stringBuilder, tokens);
      }
      if (this.showInvisibles) {
        if (foldLine)
          row = foldLine.end.row;
        stringBuilder.push('<span class=\'ace_invisible\'>', row == this.session.getLength() - 1 ? this.EOF_CHAR : this.EOL_CHAR, '</span>');
      }
      if (!onlyContents)
        stringBuilder.push('</div>');
    };
    this.$getFoldLineTokens = function (row, foldLine) {
      var session = this.session;
      var renderTokens = [];
      function addTokens(tokens, from, to) {
        var idx = 0, col = 0;
        while (col + tokens[idx].value.length < from) {
          col += tokens[idx].value.length;
          idx++;
          if (idx == tokens.length)
            return;
        }
        if (col != from) {
          var value = tokens[idx].value.substring(from - col);
          if (value.length > to - from)
            value = value.substring(0, to - from);
          renderTokens.push({
            type: tokens[idx].type,
            value: value
          });
          col = from + value.length;
          idx += 1;
        }
        while (col < to && idx < tokens.length) {
          var value = tokens[idx].value;
          if (value.length + col > to) {
            renderTokens.push({
              type: tokens[idx].type,
              value: value.substring(0, to - col)
            });
          } else
            renderTokens.push(tokens[idx]);
          col += value.length;
          idx += 1;
        }
      }
      var tokens = session.getTokens(row);
      foldLine.walk(function (placeholder, row, column, lastColumn, isNewRow) {
        if (placeholder != null) {
          renderTokens.push({
            type: 'fold',
            value: placeholder
          });
        } else {
          if (isNewRow)
            tokens = session.getTokens(row);
          if (tokens.length)
            addTokens(tokens, lastColumn, column);
        }
      }, foldLine.end.row, this.session.getLine(foldLine.end.row).length);
      return renderTokens;
    };
    this.$useLineGroups = function () {
      return this.session.getUseWrapMode();
    };
    this.destroy = function () {
      clearInterval(this.$pollSizeChangesTimer);
      if (this.$measureNode)
        this.$measureNode.parentNode.removeChild(this.$measureNode);
      delete this.$measureNode;
    };
  }.call(Text.prototype));
  exports.Text = Text;
});
ace.define('ace/tooltip', [
  'require',
  'exports',
  'module',
  'ace/lib/oop',
  'ace/lib/dom'
], function (require, exports, module) {
  var oop = require('./lib/oop');
  var dom = require('./lib/dom');
  function Tooltip(parentNode) {
    this.isOpen = false;
    this.$element = null;
    this.$parentNode = parentNode;
  }
  (function () {
    this.$init = function () {
      this.$element = dom.createElement('div');
      this.$element.className = 'ace_tooltip';
      this.$element.style.display = 'none';
      this.$parentNode.appendChild(this.$element);
      return this.$element;
    };
    this.getElement = function () {
      return this.$element || this.$init();
    };
    this.setText = function (text) {
      dom.setInnerText(this.getElement(), text);
    };
    this.setHtml = function (html) {
      this.getElement().innerHTML = html;
    };
    this.setPosition = function (x, y) {
      this.getElement().style.left = x + 'px';
      this.getElement().style.top = y + 'px';
    };
    this.setClassName = function (className) {
      dom.addCssClass(this.getElement(), className);
    };
    this.show = function (text, x, y) {
      if (text != null)
        this.setText(text);
      if (x != null && y != null)
        this.setPosition(x, y);
      if (!this.isOpen) {
        this.getElement().style.display = 'block';
        this.isOpen = true;
      }
    };
    this.hide = function () {
      if (this.isOpen) {
        this.getElement().style.display = 'none';
        this.isOpen = false;
      }
    };
    this.getHeight = function () {
      return this.getElement().offsetHeight;
    };
    this.getWidth = function () {
      return this.getElement().offsetWidth;
    };
  }.call(Tooltip.prototype));
  exports.Tooltip = Tooltip;
});
ace.define('ace/layer/cursor', [
  'require',
  'exports',
  'module',
  'ace/lib/dom'
], function (require, exports, module) {
  var dom = require('../lib/dom');
  var IE8;
  var Cursor = function (parentEl) {
    this.element = dom.createElement('div');
    this.element.className = 'ace_layer ace_cursor-layer';
    parentEl.appendChild(this.element);
    if (IE8 === undefined)
      IE8 = 'opacity' in this.element;
    this.isVisible = false;
    this.isBlinking = true;
    this.blinkInterval = 1000;
    this.smoothBlinking = false;
    this.cursors = [];
    this.cursor = this.addCursor();
    dom.addCssClass(this.element, 'ace_hidden-cursors');
    this.$updateCursors = this.$updateVisibility.bind(this);
  };
  (function () {
    this.$updateVisibility = function (val) {
      var cursors = this.cursors;
      for (var i = cursors.length; i--;)
        cursors[i].style.visibility = val ? '' : 'hidden';
    };
    this.$updateOpacity = function (val) {
      var cursors = this.cursors;
      for (var i = cursors.length; i--;)
        cursors[i].style.opacity = val ? '' : '0';
    };
    this.$padding = 0;
    this.setPadding = function (padding) {
      this.$padding = padding;
    };
    this.setSession = function (session) {
      this.session = session;
    };
    this.setBlinking = function (blinking) {
      if (blinking != this.isBlinking) {
        this.isBlinking = blinking;
        this.restartTimer();
      }
    };
    this.setBlinkInterval = function (blinkInterval) {
      if (blinkInterval != this.blinkInterval) {
        this.blinkInterval = blinkInterval;
        this.restartTimer();
      }
    };
    this.setSmoothBlinking = function (smoothBlinking) {
      if (smoothBlinking != this.smoothBlinking && !IE8) {
        this.smoothBlinking = smoothBlinking;
        dom.setCssClass(this.element, 'ace_smooth-blinking', smoothBlinking);
        this.$updateCursors(true);
        this.$updateCursors = (smoothBlinking ? this.$updateOpacity : this.$updateVisibility).bind(this);
        this.restartTimer();
      }
    };
    this.addCursor = function () {
      var el = dom.createElement('div');
      el.className = 'ace_cursor';
      this.element.appendChild(el);
      this.cursors.push(el);
      return el;
    };
    this.removeCursor = function () {
      if (this.cursors.length > 1) {
        var el = this.cursors.pop();
        el.parentNode.removeChild(el);
        return el;
      }
    };
    this.hideCursor = function () {
      this.isVisible = false;
      dom.addCssClass(this.element, 'ace_hidden-cursors');
      this.restartTimer();
    };
    this.showCursor = function () {
      this.isVisible = true;
      dom.removeCssClass(this.element, 'ace_hidden-cursors');
      this.restartTimer();
    };
    this.restartTimer = function () {
      var update = this.$updateCursors;
      clearInterval(this.intervalId);
      clearTimeout(this.timeoutId);
      if (this.smoothBlinking) {
        dom.removeCssClass(this.element, 'ace_smooth-blinking');
      }
      update(true);
      if (!this.isBlinking || !this.blinkInterval || !this.isVisible)
        return;
      if (this.smoothBlinking) {
        setTimeout(function () {
          dom.addCssClass(this.element, 'ace_smooth-blinking');
        }.bind(this));
      }
      var blink = function () {
          this.timeoutId = setTimeout(function () {
            update(false);
          }, 0.6 * this.blinkInterval);
        }.bind(this);
      this.intervalId = setInterval(function () {
        update(true);
        blink();
      }, this.blinkInterval);
      blink();
    };
    this.getPixelPosition = function (position, onScreen) {
      if (!this.config || !this.session)
        return {
          left: 0,
          top: 0
        };
      if (!position)
        position = this.session.selection.getCursor();
      var pos = this.session.documentToScreenPosition(position);
      var cursorLeft = this.$padding + pos.column * this.config.characterWidth;
      var cursorTop = (pos.row - (onScreen ? this.config.firstRowScreen : 0)) * this.config.lineHeight;
      return {
        left: cursorLeft,
        top: cursorTop
      };
    };
    this.update = function (config) {
      this.config = config;
      var selections = this.session.$selectionMarkers;
      var i = 0, cursorIndex = 0;
      if (selections === undefined || selections.length === 0) {
        selections = [{ cursor: null }];
      }
      for (var i = 0, n = selections.length; i < n; i++) {
        var pixelPos = this.getPixelPosition(selections[i].cursor, true);
        if ((pixelPos.top > config.height + config.offset || pixelPos.top < 0) && i > 1) {
          continue;
        }
        var style = (this.cursors[cursorIndex++] || this.addCursor()).style;
        style.left = pixelPos.left + 'px';
        style.top = pixelPos.top + 'px';
        style.width = config.characterWidth + 'px';
        style.height = config.lineHeight + 'px';
      }
      while (this.cursors.length > cursorIndex)
        this.removeCursor();
      var overwrite = this.session.getOverwrite();
      this.$setOverwrite(overwrite);
      this.$pixelPos = pixelPos;
      this.restartTimer();
    };
    this.$setOverwrite = function (overwrite) {
      if (overwrite != this.overwrite) {
        this.overwrite = overwrite;
        if (overwrite)
          dom.addCssClass(this.element, 'ace_overwrite-cursors');
        else
          dom.removeCssClass(this.element, 'ace_overwrite-cursors');
      }
    };
    this.destroy = function () {
      clearInterval(this.intervalId);
      clearTimeout(this.timeoutId);
    };
  }.call(Cursor.prototype));
  exports.Cursor = Cursor;
});
ace.define('ace/mouse/default_gutter_handler', [
  'require',
  'exports',
  'module',
  'ace/lib/dom',
  'ace/lib/oop',
  'ace/lib/event',
  'ace/tooltip'
], function (require, exports, module) {
  var dom = require('../lib/dom');
  var oop = require('../lib/oop');
  var event = require('../lib/event');
  var Tooltip = require('../tooltip').Tooltip;
  function GutterHandler(mouseHandler) {
    var editor = mouseHandler.editor;
    var gutter = editor.renderer.$gutterLayer;
    var tooltip = new GutterTooltip(editor.container);
    mouseHandler.editor.setDefaultHandler('guttermousedown', function (e) {
      if (!editor.isFocused() || e.getButton() != 0)
        return;
      var gutterRegion = gutter.getRegion(e);
      if (gutterRegion == 'foldWidgets')
        return;
      var row = e.getDocumentPosition().row;
      var selection = editor.session.selection;
      if (e.getShiftKey())
        selection.selectTo(row, 0);
      else {
        if (e.domEvent.detail == 2) {
          editor.selectAll();
          return e.preventDefault();
        }
        mouseHandler.$clickSelection = editor.selection.getLineRange(row);
      }
      mouseHandler.setState('selectByLines');
      mouseHandler.captureMouse(e);
      return e.preventDefault();
    });
    var tooltipTimeout, mouseEvent, tooltipAnnotation;
    function showTooltip() {
      var row = mouseEvent.getDocumentPosition().row;
      var annotation = gutter.$annotations[row];
      if (!annotation)
        return hideTooltip();
      var maxRow = editor.session.getLength();
      if (row == maxRow) {
        var screenRow = editor.renderer.pixelToScreenCoordinates(0, mouseEvent.y).row;
        var pos = mouseEvent.$pos;
        if (screenRow > editor.session.documentToScreenRow(pos.row, pos.column))
          return hideTooltip();
      }
      if (tooltipAnnotation == annotation)
        return;
      tooltipAnnotation = annotation.text.join('<br/>');
      tooltip.setHtml(tooltipAnnotation);
      tooltip.show();
      editor.on('mousewheel', hideTooltip);
      if (mouseHandler.$tooltipFollowsMouse) {
        moveTooltip(mouseEvent);
      } else {
        var gutterElement = gutter.$cells[row].element;
        var rect = gutterElement.getBoundingClientRect();
        var style = tooltip.getElement().style;
        style.left = rect.right + 'px';
        style.top = rect.bottom + 'px';
      }
    }
    function hideTooltip() {
      if (tooltipTimeout)
        tooltipTimeout = clearTimeout(tooltipTimeout);
      if (tooltipAnnotation) {
        tooltip.hide();
        tooltipAnnotation = null;
        editor.removeEventListener('mousewheel', hideTooltip);
      }
    }
    function moveTooltip(e) {
      tooltip.setPosition(e.x, e.y);
    }
    mouseHandler.editor.setDefaultHandler('guttermousemove', function (e) {
      var target = e.domEvent.target || e.domEvent.srcElement;
      if (dom.hasCssClass(target, 'ace_fold-widget'))
        return hideTooltip();
      if (tooltipAnnotation && mouseHandler.$tooltipFollowsMouse)
        moveTooltip(e);
      mouseEvent = e;
      if (tooltipTimeout)
        return;
      tooltipTimeout = setTimeout(function () {
        tooltipTimeout = null;
        if (mouseEvent && !mouseHandler.isMousePressed)
          showTooltip();
        else
          hideTooltip();
      }, 50);
    });
    event.addListener(editor.renderer.$gutter, 'mouseout', function (e) {
      mouseEvent = null;
      if (!tooltipAnnotation || tooltipTimeout)
        return;
      tooltipTimeout = setTimeout(function () {
        tooltipTimeout = null;
        hideTooltip();
      }, 50);
    });
    editor.on('changeSession', hideTooltip);
  }
  function GutterTooltip(parentNode) {
    Tooltip.call(this, parentNode);
  }
  oop.inherits(GutterTooltip, Tooltip);
  (function () {
    this.setPosition = function (x, y) {
      var windowWidth = window.innerWidth || document.documentElement.clientWidth;
      var windowHeight = window.innerHeight || document.documentElement.clientHeight;
      var width = this.getWidth();
      var height = this.getHeight();
      x += 15;
      y += 15;
      if (x + width > windowWidth) {
        x -= x + width - windowWidth;
      }
      if (y + height > windowHeight) {
        y -= 20 + height;
      }
      Tooltip.prototype.setPosition.call(this, x, y);
    };
  }.call(GutterTooltip.prototype));
  exports.GutterHandler = GutterHandler;
});
ace.define('ace/scrollbar', [
  'require',
  'exports',
  'module',
  'ace/lib/oop',
  'ace/lib/dom',
  'ace/lib/event',
  'ace/lib/event_emitter'
], function (require, exports, module) {
  var oop = require('./lib/oop');
  var dom = require('./lib/dom');
  var event = require('./lib/event');
  var EventEmitter = require('./lib/event_emitter').EventEmitter;
  var ScrollBar = function (parent) {
    this.element = dom.createElement('div');
    this.element.className = 'ace_scrollbar ace_scrollbar' + this.classSuffix;
    this.inner = dom.createElement('div');
    this.inner.className = 'ace_scrollbar-inner';
    this.element.appendChild(this.inner);
    parent.appendChild(this.element);
    this.setVisible(false);
    this.skipEvent = false;
    event.addListener(this.element, 'scroll', this.onScroll.bind(this));
    event.addListener(this.element, 'mousedown', event.preventDefault);
  };
  (function () {
    oop.implement(this, EventEmitter);
    this.setVisible = function (isVisible) {
      this.element.style.display = isVisible ? '' : 'none';
      this.isVisible = isVisible;
    };
  }.call(ScrollBar.prototype));
  var VScrollBar = function (parent, renderer) {
    ScrollBar.call(this, parent);
    this.scrollTop = 0;
    renderer.$scrollbarWidth = this.width = dom.scrollbarWidth(parent.ownerDocument);
    this.inner.style.width = this.element.style.width = (this.width || 15) + 5 + 'px';
  };
  oop.inherits(VScrollBar, ScrollBar);
  (function () {
    this.classSuffix = '-v';
    this.onScroll = function () {
      if (!this.skipEvent) {
        this.scrollTop = this.element.scrollTop;
        this._emit('scroll', { data: this.scrollTop });
      }
      this.skipEvent = false;
    };
    this.getWidth = function () {
      return this.isVisible ? this.width : 0;
    };
    this.setHeight = function (height) {
      this.element.style.height = height + 'px';
    };
    this.setInnerHeight = function (height) {
      this.inner.style.height = height + 'px';
    };
    this.setScrollHeight = function (height) {
      this.inner.style.height = height + 'px';
    };
    this.setScrollTop = function (scrollTop) {
      if (this.scrollTop != scrollTop) {
        this.skipEvent = true;
        this.scrollTop = this.element.scrollTop = scrollTop;
      }
    };
  }.call(VScrollBar.prototype));
  var HScrollBar = function (parent, renderer) {
    ScrollBar.call(this, parent);
    this.scrollLeft = 0;
    this.height = renderer.$scrollbarWidth;
    this.inner.style.height = this.element.style.height = (this.height || 15) + 5 + 'px';
  };
  oop.inherits(HScrollBar, ScrollBar);
  (function () {
    this.classSuffix = '-h';
    this.onScroll = function () {
      if (!this.skipEvent) {
        this.scrollLeft = this.element.scrollLeft;
        this._emit('scroll', { data: this.scrollLeft });
      }
      this.skipEvent = false;
    };
    this.getHeight = function () {
      return this.isVisible ? this.height : 0;
    };
    this.setWidth = function (width) {
      this.element.style.width = width + 'px';
    };
    this.setInnerWidth = function (width) {
      this.inner.style.width = width + 'px';
    };
    this.setScrollWidth = function (width) {
      this.inner.style.width = width + 'px';
    };
    this.setScrollLeft = function (scrollLeft) {
      if (this.scrollLeft != scrollLeft) {
        this.skipEvent = true;
        this.scrollLeft = this.element.scrollLeft = scrollLeft;
      }
    };
  }.call(HScrollBar.prototype));
  exports.ScrollBar = VScrollBar;
  exports.ScrollBarV = VScrollBar;
  exports.ScrollBarH = HScrollBar;
  exports.VScrollBar = VScrollBar;
  exports.HScrollBar = HScrollBar;
});
ace.define('ace/mouse/default_handlers', [
  'require',
  'exports',
  'module',
  'ace/lib/dom',
  'ace/lib/event',
  'ace/lib/useragent'
], function (require, exports, module) {
  var dom = require('../lib/dom');
  var event = require('../lib/event');
  var useragent = require('../lib/useragent');
  var DRAG_OFFSET = 0;
  function DefaultHandlers(mouseHandler) {
    mouseHandler.$clickSelection = null;
    var editor = mouseHandler.editor;
    editor.setDefaultHandler('mousedown', this.onMouseDown.bind(mouseHandler));
    editor.setDefaultHandler('dblclick', this.onDoubleClick.bind(mouseHandler));
    editor.setDefaultHandler('tripleclick', this.onTripleClick.bind(mouseHandler));
    editor.setDefaultHandler('quadclick', this.onQuadClick.bind(mouseHandler));
    editor.setDefaultHandler('mousewheel', this.onMouseWheel.bind(mouseHandler));
    var exports = [
        'select',
        'startSelect',
        'selectEnd',
        'selectAllEnd',
        'selectByWordsEnd',
        'selectByLinesEnd',
        'dragWait',
        'dragWaitEnd',
        'focusWait'
      ];
    exports.forEach(function (x) {
      mouseHandler[x] = this[x];
    }, this);
    mouseHandler.selectByLines = this.extendSelectionBy.bind(mouseHandler, 'getLineRange');
    mouseHandler.selectByWords = this.extendSelectionBy.bind(mouseHandler, 'getWordRange');
  }
  (function () {
    this.onMouseDown = function (ev) {
      var inSelection = ev.inSelection();
      var pos = ev.getDocumentPosition();
      this.mousedownEvent = ev;
      var editor = this.editor;
      var button = ev.getButton();
      if (button !== 0) {
        var selectionRange = editor.getSelectionRange();
        var selectionEmpty = selectionRange.isEmpty();
        if (selectionEmpty) {
          editor.selection.moveToPosition(pos);
        }
        editor.textInput.onContextMenu(ev.domEvent);
        return;
      }
      if (inSelection && !editor.isFocused()) {
        editor.focus();
        if (this.$focusTimout && !this.$clickSelection && !editor.inMultiSelectMode) {
          this.mousedownEvent.time = Date.now();
          this.setState('focusWait');
          this.captureMouse(ev);
          return;
        }
      }
      this.captureMouse(ev);
      if (!inSelection || this.$clickSelection || ev.getShiftKey() || editor.inMultiSelectMode) {
        this.startSelect(pos);
      } else if (inSelection) {
        this.mousedownEvent.time = Date.now();
        this.startSelect(pos);
      }
      return ev.preventDefault();
    };
    this.startSelect = function (pos) {
      pos = pos || this.editor.renderer.screenToTextCoordinates(this.x, this.y);
      var editor = this.editor;
      var shiftPressed = this.mousedownEvent.getShiftKey();
      if (shiftPressed) {
        editor.selection.selectToPosition(pos);
      } else if (!this.$clickSelection) {
        editor.selection.moveToPosition(pos);
      }
      if (editor.renderer.scroller.setCapture) {
        editor.renderer.scroller.setCapture();
      }
      editor.setStyle('ace_selecting');
      this.setState('select');
    };
    this.select = function () {
      var anchor, editor = this.editor;
      var cursor = editor.renderer.screenToTextCoordinates(this.x, this.y);
      if (this.$clickSelection) {
        var cmp = this.$clickSelection.comparePoint(cursor);
        if (cmp == -1) {
          anchor = this.$clickSelection.end;
        } else if (cmp == 1) {
          anchor = this.$clickSelection.start;
        } else {
          var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);
          cursor = orientedRange.cursor;
          anchor = orientedRange.anchor;
        }
        editor.selection.setSelectionAnchor(anchor.row, anchor.column);
      }
      editor.selection.selectToPosition(cursor);
      editor.renderer.scrollCursorIntoView();
    };
    this.extendSelectionBy = function (unitName) {
      var anchor, editor = this.editor;
      var cursor = editor.renderer.screenToTextCoordinates(this.x, this.y);
      var range = editor.selection[unitName](cursor.row, cursor.column);
      if (this.$clickSelection) {
        var cmpStart = this.$clickSelection.comparePoint(range.start);
        var cmpEnd = this.$clickSelection.comparePoint(range.end);
        if (cmpStart == -1 && cmpEnd <= 0) {
          anchor = this.$clickSelection.end;
          if (range.end.row != cursor.row || range.end.column != cursor.column)
            cursor = range.start;
        } else if (cmpEnd == 1 && cmpStart >= 0) {
          anchor = this.$clickSelection.start;
          if (range.start.row != cursor.row || range.start.column != cursor.column)
            cursor = range.end;
        } else if (cmpStart == -1 && cmpEnd == 1) {
          cursor = range.end;
          anchor = range.start;
        } else {
          var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);
          cursor = orientedRange.cursor;
          anchor = orientedRange.anchor;
        }
        editor.selection.setSelectionAnchor(anchor.row, anchor.column);
      }
      editor.selection.selectToPosition(cursor);
      editor.renderer.scrollCursorIntoView();
    };
    this.selectEnd = this.selectAllEnd = this.selectByWordsEnd = this.selectByLinesEnd = function () {
      this.editor.unsetStyle('ace_selecting');
      if (this.editor.renderer.scroller.releaseCapture) {
        this.editor.renderer.scroller.releaseCapture();
      }
    };
    this.focusWait = function () {
      var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
      var time = Date.now();
      if (distance > DRAG_OFFSET || time - this.mousedownEvent.time > this.$focusTimout)
        this.startSelect(this.mousedownEvent.getDocumentPosition());
    };
    this.onDoubleClick = function (ev) {
      var pos = ev.getDocumentPosition();
      var editor = this.editor;
      var session = editor.session;
      var range = session.getBracketRange(pos);
      if (range) {
        if (range.isEmpty()) {
          range.start.column--;
          range.end.column++;
        }
        this.setState('select');
      } else {
        range = editor.selection.getWordRange(pos.row, pos.column);
        this.setState('selectByWords');
      }
      this.$clickSelection = range;
      this[this.state] && this[this.state](ev);
    };
    this.onTripleClick = function (ev) {
      var pos = ev.getDocumentPosition();
      var editor = this.editor;
      this.setState('selectByLines');
      this.$clickSelection = editor.selection.getLineRange(pos.row);
      this[this.state] && this[this.state](ev);
    };
    this.onQuadClick = function (ev) {
      var editor = this.editor;
      editor.selectAll();
      this.$clickSelection = editor.getSelectionRange();
      this.setState('selectAll');
    };
    this.onMouseWheel = function (ev) {
      if (ev.getAccelKey())
        return;
      if (ev.getShiftKey() && ev.wheelY && !ev.wheelX) {
        ev.wheelX = ev.wheelY;
        ev.wheelY = 0;
      }
      var t = ev.domEvent.timeStamp;
      var dt = t - (this.$lastScrollTime || 0);
      var editor = this.editor;
      var isScrolable = editor.renderer.isScrollableBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
      if (isScrolable || dt < 200) {
        this.$lastScrollTime = t;
        editor.renderer.scrollBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
        return ev.stop();
      }
    };
  }.call(DefaultHandlers.prototype));
  exports.DefaultHandlers = DefaultHandlers;
  function calcDistance(ax, ay, bx, by) {
    return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));
  }
  function calcRangeOrientation(range, cursor) {
    if (range.start.row == range.end.row)
      var cmp = 2 * cursor.column - range.start.column - range.end.column;
    else if (range.start.row == range.end.row - 1 && !range.start.column && !range.end.column)
      var cmp = cursor.column - 4;
    else
      var cmp = 2 * cursor.row - range.start.row - range.end.row;
    if (cmp < 0)
      return {
        cursor: range.start,
        anchor: range.end
      };
    else
      return {
        cursor: range.end,
        anchor: range.start
      };
  }
});
ace.define('ace/renderloop', [
  'require',
  'exports',
  'module',
  'ace/lib/event'
], function (require, exports, module) {
  var event = require('./lib/event');
  var RenderLoop = function (onRender, win) {
    this.onRender = onRender;
    this.pending = false;
    this.changes = 0;
    this.window = win || window;
  };
  (function () {
    this.schedule = function (change) {
      this.changes = this.changes | change;
      if (!this.pending && this.changes) {
        this.pending = true;
        var _self = this;
        event.nextFrame(function () {
          _self.pending = false;
          var changes;
          while (changes = _self.changes) {
            _self.changes = 0;
            _self.onRender(changes);
          }
        }, this.window);
      }
    };
  }.call(RenderLoop.prototype));
  exports.RenderLoop = RenderLoop;
});
ace.define('ace/mouse/mouse_handler', [
  'require',
  'exports',
  'module',
  'ace/lib/event',
  'ace/lib/useragent',
  'ace/mouse/default_handlers',
  'ace/mouse/default_gutter_handler',
  'ace/mouse/mouse_event',
  'ace/mouse/dragdrop_handler',
  'ace/config'
], function (require, exports, module) {
  var event = require('../lib/event');
  var useragent = require('../lib/useragent');
  var DefaultHandlers = require('./default_handlers').DefaultHandlers;
  var DefaultGutterHandler = require('./default_gutter_handler').GutterHandler;
  var MouseEvent = require('./mouse_event').MouseEvent;
  var DragdropHandler = require('./dragdrop_handler').DragdropHandler;
  var config = require('../config');
  var MouseHandler = function (editor) {
    this.editor = editor;
    new DefaultHandlers(this);
    new DefaultGutterHandler(this);
    new DragdropHandler(this);
    var mouseTarget = editor.renderer.getMouseEventTarget();
    event.addListener(mouseTarget, 'click', this.onMouseEvent.bind(this, 'click'));
    event.addListener(mouseTarget, 'mousemove', this.onMouseMove.bind(this, 'mousemove'));
    event.addMultiMouseDownListener(mouseTarget, [
      300,
      300,
      250
    ], this, 'onMouseEvent');
    if (editor.renderer.scrollBarV) {
      event.addMultiMouseDownListener(editor.renderer.scrollBarV.inner, [
        300,
        300,
        250
      ], this, 'onMouseEvent');
      event.addMultiMouseDownListener(editor.renderer.scrollBarH.inner, [
        300,
        300,
        250
      ], this, 'onMouseEvent');
    }
    event.addMouseWheelListener(editor.container, this.onMouseWheel.bind(this, 'mousewheel'));
    var gutterEl = editor.renderer.$gutter;
    event.addListener(gutterEl, 'mousedown', this.onMouseEvent.bind(this, 'guttermousedown'));
    event.addListener(gutterEl, 'click', this.onMouseEvent.bind(this, 'gutterclick'));
    event.addListener(gutterEl, 'dblclick', this.onMouseEvent.bind(this, 'gutterdblclick'));
    event.addListener(gutterEl, 'mousemove', this.onMouseEvent.bind(this, 'guttermousemove'));
    event.addListener(mouseTarget, 'mousedown', function (e) {
      editor.focus();
    });
    event.addListener(gutterEl, 'mousedown', function (e) {
      editor.focus();
      return event.preventDefault(e);
    });
  };
  (function () {
    this.onMouseEvent = function (name, e) {
      this.editor._emit(name, new MouseEvent(e, this.editor));
    };
    this.onMouseMove = function (name, e) {
      var listeners = this.editor._eventRegistry && this.editor._eventRegistry.mousemove;
      if (!listeners || !listeners.length)
        return;
      this.editor._emit(name, new MouseEvent(e, this.editor));
    };
    this.onMouseWheel = function (name, e) {
      var mouseEvent = new MouseEvent(e, this.editor);
      mouseEvent.speed = this.$scrollSpeed * 2;
      mouseEvent.wheelX = e.wheelX;
      mouseEvent.wheelY = e.wheelY;
      this.editor._emit(name, mouseEvent);
    };
    this.setState = function (state) {
      this.state = state;
    };
    this.captureMouse = function (ev, mouseMoveHandler) {
      this.x = ev.x;
      this.y = ev.y;
      this.isMousePressed = true;
      var renderer = this.editor.renderer;
      if (renderer.$keepTextAreaAtCursor)
        renderer.$keepTextAreaAtCursor = null;
      var self = this;
      var onMouseMove = function (e) {
        self.x = e.clientX;
        self.y = e.clientY;
        mouseMoveHandler && mouseMoveHandler(e);
        self.mouseEvent = new MouseEvent(e, self.editor);
        self.$mouseMoved = true;
      };
      var onCaptureEnd = function (e) {
        clearInterval(timerId);
        onCaptureInterval();
        self[self.state + 'End'] && self[self.state + 'End'](e);
        self.$clickSelection = null;
        if (renderer.$keepTextAreaAtCursor == null) {
          renderer.$keepTextAreaAtCursor = true;
          renderer.$moveTextAreaToCursor();
        }
        self.isMousePressed = false;
        self.$onCaptureMouseMove = self.releaseMouse = null;
        self.onMouseEvent('mouseup', e);
      };
      var onCaptureInterval = function () {
        self[self.state] && self[self.state]();
        self.$mouseMoved = false;
      };
      if (useragent.isOldIE && ev.domEvent.type == 'dblclick') {
        return setTimeout(function () {
          onCaptureEnd(ev);
        });
      }
      self.$onCaptureMouseMove = onMouseMove;
      self.releaseMouse = event.capture(this.editor.container, onMouseMove, onCaptureEnd);
      var timerId = setInterval(onCaptureInterval, 20);
    };
    this.releaseMouse = null;
  }.call(MouseHandler.prototype));
  config.defineOptions(MouseHandler.prototype, 'mouseHandler', {
    scrollSpeed: { initialValue: 2 },
    dragDelay: { initialValue: 150 },
    dragEnabled: { initialValue: true },
    focusTimout: { initialValue: 0 },
    tooltipFollowsMouse: { initialValue: true }
  });
  exports.MouseHandler = MouseHandler;
});
ace.define('ace/layer/font_metrics', [
  'require',
  'exports',
  'module',
  'ace/lib/oop',
  'ace/lib/dom',
  'ace/lib/lang',
  'ace/lib/event_emitter'
], function (require, exports, module) {
  var oop = require('../lib/oop');
  var dom = require('../lib/dom');
  var lang = require('../lib/lang');
  var EventEmitter = require('../lib/event_emitter').EventEmitter;
  var CHAR_COUNT = 0;
  var FontMetrics = exports.FontMetrics = function (parentEl, interval) {
      this.el = dom.createElement('div');
      this.$setMeasureNodeStyles(this.el.style, true);
      this.$main = dom.createElement('div');
      this.$setMeasureNodeStyles(this.$main.style);
      this.$measureNode = dom.createElement('div');
      this.$setMeasureNodeStyles(this.$measureNode.style);
      this.el.appendChild(this.$main);
      this.el.appendChild(this.$measureNode);
      parentEl.appendChild(this.el);
      if (!CHAR_COUNT)
        this.$testFractionalRect();
      this.$measureNode.textContent = lang.stringRepeat('X', CHAR_COUNT);
      this.$characterSize = {
        width: 0,
        height: 0
      };
      this.checkForSizeChanges();
    };
  (function () {
    oop.implement(this, EventEmitter);
    this.$characterSize = {
      width: 0,
      height: 0
    };
    this.$testFractionalRect = function () {
      var el = dom.createElement('div');
      this.$setMeasureNodeStyles(el.style);
      el.style.width = '0.2px';
      document.documentElement.appendChild(el);
      var w = el.getBoundingClientRect().width;
      if (w > 0 && w < 1)
        CHAR_COUNT = 1;
      else
        CHAR_COUNT = 100;
      el.parentNode.removeChild(el);
    };
    this.$setMeasureNodeStyles = function (style, isRoot) {
      style.width = style.height = 'auto';
      style.left = style.top = '-100px';
      style.visibility = 'hidden';
      style.position = 'fixed';
      style.whiteSpace = 'pre';
      style.font = 'inherit';
      style.overflow = isRoot ? 'hidden' : 'visible';
    };
    this.checkForSizeChanges = function () {
      var size = this.$measureSizes();
      if (size && (this.$characterSize.width !== size.width || this.$characterSize.height !== size.height)) {
        this.$measureNode.style.fontWeight = 'bold';
        var boldSize = this.$measureSizes();
        this.$measureNode.style.fontWeight = '';
        this.$characterSize = size;
        this.charSizes = Object.create(null);
        this.allowBoldFonts = boldSize && boldSize.width === size.width && boldSize.height === size.height;
        this._emit('changeCharacterSize', { data: size });
      }
    };
    this.$pollSizeChanges = function () {
      if (this.$pollSizeChangesTimer)
        return this.$pollSizeChangesTimer;
      var self = this;
      return this.$pollSizeChangesTimer = setInterval(function () {
        self.checkForSizeChanges();
      }, 500);
    };
    this.setPolling = function (val) {
      if (val) {
        this.$pollSizeChanges();
      } else {
        if (this.$pollSizeChangesTimer)
          this.$pollSizeChangesTimer;
      }
    };
    this.$measureSizes = function () {
      var rect = this.$measureNode.getBoundingClientRect();
      var size = {
          height: rect.height,
          width: rect.width / CHAR_COUNT
        };
      if (size.width === 0 || size.height === 0)
        return null;
      return size;
    };
    this.$measureCharWidth = function (ch) {
      this.$main.textContent = lang.stringRepeat(ch, CHAR_COUNT);
      var rect = this.$main.getBoundingClientRect();
      return rect.width / CHAR_COUNT;
    };
    this.getCharacterWidth = function (ch) {
      var w = this.charSizes[ch];
      if (w === undefined) {
        this.charSizes[ch] = this.$measureCharWidth(ch) / this.$characterSize.width;
      }
      return w;
    };
    this.destroy = function () {
      clearInterval(this.$pollSizeChangesTimer);
      if (this.el && this.el.parentNode)
        this.el.parentNode.removeChild(this.el);
    };
  }.call(FontMetrics.prototype));
});
ace.define('ace/keyboard/textinput', [
  'require',
  'exports',
  'module',
  'ace/lib/event',
  'ace/lib/useragent',
  'ace/lib/dom',
  'ace/lib/lang'
], function (require, exports, module) {
  var event = require('../lib/event');
  var useragent = require('../lib/useragent');
  var dom = require('../lib/dom');
  var lang = require('../lib/lang');
  var BROKEN_SETDATA = useragent.isChrome < 18;
  var TextInput = function (parentNode, host) {
    var text = dom.createElement('textarea');
    text.className = 'ace_text-input';
    if (useragent.isTouchPad)
      text.setAttribute('x-palm-disable-auto-cap', true);
    text.wrap = 'off';
    text.autocorrect = 'off';
    text.autocapitalize = 'off';
    text.spellcheck = false;
    text.style.opacity = '0';
    parentNode.insertBefore(text, parentNode.firstChild);
    var PLACEHOLDER = '\x01\x01';
    var cut = false;
    var copied = false;
    var pasted = false;
    var inComposition = false;
    var tempStyle = '';
    var isSelectionEmpty = true;
    try {
      var isFocused = document.activeElement === text;
    } catch (e) {
    }
    event.addListener(text, 'blur', function () {
      host.onBlur();
      isFocused = false;
    });
    event.addListener(text, 'focus', function () {
      isFocused = true;
      host.onFocus();
      resetSelection();
    });
    this.focus = function () {
      text.focus();
    };
    this.blur = function () {
      text.blur();
    };
    this.isFocused = function () {
      return isFocused;
    };
    var syncSelection = lang.delayedCall(function () {
        isFocused && resetSelection(isSelectionEmpty);
      });
    var syncValue = lang.delayedCall(function () {
        if (!inComposition) {
          text.value = PLACEHOLDER;
          isFocused && resetSelection();
        }
      });
    function resetSelection(isEmpty) {
      if (inComposition)
        return;
      if (inputHandler) {
        selectionStart = 0;
        selectionEnd = isEmpty ? 0 : text.value.length - 1;
      } else {
        var selectionStart = isEmpty ? 2 : 1;
        var selectionEnd = 2;
      }
      try {
        text.setSelectionRange(selectionStart, selectionEnd);
      } catch (e) {
      }
    }
    function resetValue() {
      if (inComposition)
        return;
      text.value = PLACEHOLDER;
      if (useragent.isWebKit)
        syncValue.schedule();
    }
    useragent.isWebKit || host.addEventListener('changeSelection', function () {
      if (host.selection.isEmpty() != isSelectionEmpty) {
        isSelectionEmpty = !isSelectionEmpty;
        syncSelection.schedule();
      }
    });
    resetValue();
    if (isFocused)
      host.onFocus();
    var isAllSelected = function (text) {
      return text.selectionStart === 0 && text.selectionEnd === text.value.length;
    };
    if (!text.setSelectionRange && text.createTextRange) {
      text.setSelectionRange = function (selectionStart, selectionEnd) {
        var range = this.createTextRange();
        range.collapse(true);
        range.moveStart('character', selectionStart);
        range.moveEnd('character', selectionEnd);
        range.select();
      };
      isAllSelected = function (text) {
        try {
          var range = text.ownerDocument.selection.createRange();
        } catch (e) {
        }
        if (!range || range.parentElement() != text)
          return false;
        return range.text == text.value;
      };
    }
    if (useragent.isOldIE) {
      var inPropertyChange = false;
      var onPropertyChange = function (e) {
        if (inPropertyChange)
          return;
        var data = text.value;
        if (inComposition || !data || data == PLACEHOLDER)
          return;
        if (e && data == PLACEHOLDER[0])
          return syncProperty.schedule();
        sendText(data);
        inPropertyChange = true;
        resetValue();
        inPropertyChange = false;
      };
      var syncProperty = lang.delayedCall(onPropertyChange);
      event.addListener(text, 'propertychange', onPropertyChange);
      var keytable = {
          13: 1,
          27: 1
        };
      event.addListener(text, 'keyup', function (e) {
        if (inComposition && (!text.value || keytable[e.keyCode]))
          setTimeout(onCompositionEnd, 0);
        if ((text.value.charCodeAt(0) || 0) < 129) {
          return syncProperty.call();
        }
        inComposition ? onCompositionUpdate() : onCompositionStart();
      });
      event.addListener(text, 'keydown', function (e) {
        syncProperty.schedule(50);
      });
    }
    var onSelect = function (e) {
      if (cut) {
        cut = false;
      } else if (copied) {
        copied = false;
      } else if (isAllSelected(text)) {
        host.selectAll();
        resetSelection();
      } else if (inputHandler) {
        resetSelection(host.selection.isEmpty());
      }
    };
    var inputHandler = null;
    this.setInputHandler = function (cb) {
      inputHandler = cb;
    };
    this.getInputHandler = function () {
      return inputHandler;
    };
    var afterContextMenu = false;
    var sendText = function (data) {
      if (inputHandler) {
        data = inputHandler(data);
        inputHandler = null;
      }
      if (pasted) {
        resetSelection();
        if (data)
          host.onPaste(data);
        pasted = false;
      } else if (data == PLACEHOLDER.charAt(0)) {
        if (afterContextMenu)
          host.execCommand('del', { source: 'ace' });
        else
          host.execCommand('backspace', { source: 'ace' });
      } else {
        if (data.substring(0, 2) == PLACEHOLDER)
          data = data.substr(2);
        else if (data.charAt(0) == PLACEHOLDER.charAt(0))
          data = data.substr(1);
        else if (data.charAt(data.length - 1) == PLACEHOLDER.charAt(0))
          data = data.slice(0, -1);
        if (data.charAt(data.length - 1) == PLACEHOLDER.charAt(0))
          data = data.slice(0, -1);
        if (data)
          host.onTextInput(data);
      }
      if (afterContextMenu)
        afterContextMenu = false;
    };
    var onInput = function (e) {
      if (inComposition)
        return;
      var data = text.value;
      sendText(data);
      resetValue();
    };
    var onCut = function (e) {
      var data = host.getCopyText();
      if (!data) {
        event.preventDefault(e);
        return;
      }
      var clipboardData = e.clipboardData || window.clipboardData;
      if (clipboardData && !BROKEN_SETDATA) {
        var supported = clipboardData.setData('Text', data);
        if (supported) {
          host.onCut();
          event.preventDefault(e);
        }
      }
      if (!supported) {
        cut = true;
        text.value = data;
        text.select();
        setTimeout(function () {
          cut = false;
          resetValue();
          resetSelection();
          host.onCut();
        });
      }
    };
    var onCopy = function (e) {
      var data = host.getCopyText();
      if (!data) {
        event.preventDefault(e);
        return;
      }
      var clipboardData = e.clipboardData || window.clipboardData;
      if (clipboardData && !BROKEN_SETDATA) {
        var supported = clipboardData.setData('Text', data);
        if (supported) {
          host.onCopy();
          event.preventDefault(e);
        }
      }
      if (!supported) {
        copied = true;
        text.value = data;
        text.select();
        setTimeout(function () {
          copied = false;
          resetValue();
          resetSelection();
          host.onCopy();
        });
      }
    };
    var onPaste = function (e) {
      var clipboardData = e.clipboardData || window.clipboardData;
      if (clipboardData) {
        var data = clipboardData.getData('Text');
        if (data)
          host.onPaste(data);
        if (useragent.isIE)
          setTimeout(resetSelection);
        event.preventDefault(e);
      } else {
        text.value = '';
        pasted = true;
      }
    };
    event.addCommandKeyListener(text, host.onCommandKey.bind(host));
    event.addListener(text, 'select', onSelect);
    event.addListener(text, 'input', onInput);
    event.addListener(text, 'cut', onCut);
    event.addListener(text, 'copy', onCopy);
    event.addListener(text, 'paste', onPaste);
    if (!('oncut' in text) || !('oncopy' in text) || !('onpaste' in text)) {
      event.addListener(parentNode, 'keydown', function (e) {
        if (useragent.isMac && !e.metaKey || !e.ctrlKey)
          return;
        switch (e.keyCode) {
        case 67:
          onCopy(e);
          break;
        case 86:
          onPaste(e);
          break;
        case 88:
          onCut(e);
          break;
        }
      });
    }
    var onCompositionStart = function (e) {
      if (inComposition || !host.onCompositionStart)
        return;
      inComposition = {};
      host.onCompositionStart();
      setTimeout(onCompositionUpdate, 0);
      host.on('mousedown', onCompositionEnd);
      if (!host.selection.isEmpty()) {
        host.insert('');
        host.session.markUndoGroup();
        host.selection.clearSelection();
      }
      host.session.markUndoGroup();
    };
    var onCompositionUpdate = function () {
      if (!inComposition || !host.onCompositionUpdate)
        return;
      var val = text.value.replace(/\x01/g, '');
      if (inComposition.lastValue === val)
        return;
      host.onCompositionUpdate(val);
      if (inComposition.lastValue)
        host.undo();
      inComposition.lastValue = val;
      if (inComposition.lastValue) {
        var r = host.selection.getRange();
        host.insert(inComposition.lastValue);
        host.session.markUndoGroup();
        inComposition.range = host.selection.getRange();
        host.selection.setRange(r);
        host.selection.clearSelection();
      }
    };
    var onCompositionEnd = function (e) {
      if (!host.onCompositionEnd)
        return;
      var c = inComposition;
      inComposition = false;
      var timer = setTimeout(function () {
          timer = null;
          var str = text.value.replace(/\x01/g, '');
          if (inComposition)
            return;
          else if (str == c.lastValue)
            resetValue();
          else if (!c.lastValue && str) {
            resetValue();
            sendText(str);
          }
        });
      inputHandler = function compositionInputHandler(str) {
        if (timer)
          clearTimeout(timer);
        str = str.replace(/\x01/g, '');
        if (str == c.lastValue)
          return '';
        if (c.lastValue && timer)
          host.undo();
        return str;
      };
      host.onCompositionEnd();
      host.removeListener('mousedown', onCompositionEnd);
      if (e.type == 'compositionend' && c.range) {
        host.selection.setRange(c.range);
      }
    };
    var syncComposition = lang.delayedCall(onCompositionUpdate, 50);
    event.addListener(text, 'compositionstart', onCompositionStart);
    if (useragent.isGecko) {
      event.addListener(text, 'text', function () {
        syncComposition.schedule();
      });
    } else {
      event.addListener(text, 'keyup', function () {
        syncComposition.schedule();
      });
      event.addListener(text, 'keydown', function () {
        syncComposition.schedule();
      });
    }
    event.addListener(text, 'compositionend', onCompositionEnd);
    this.getElement = function () {
      return text;
    };
    this.setReadOnly = function (readOnly) {
      text.readOnly = readOnly;
    };
    this.onContextMenu = function (e) {
      afterContextMenu = true;
      if (!tempStyle)
        tempStyle = text.style.cssText;
      text.style.cssText = 'z-index:100000;' + (useragent.isIE ? 'opacity:0.1;' : '');
      resetSelection(host.selection.isEmpty());
      host._emit('nativecontextmenu', {
        target: host,
        domEvent: e
      });
      var rect = host.container.getBoundingClientRect();
      var style = dom.computedStyle(host.container);
      var top = rect.top + (parseInt(style.borderTopWidth) || 0);
      var left = rect.left + (parseInt(rect.borderLeftWidth) || 0);
      var maxTop = rect.bottom - top - text.clientHeight;
      var move = function (e) {
        text.style.left = e.clientX - left - 2 + 'px';
        text.style.top = Math.min(e.clientY - top - 2, maxTop) + 'px';
      };
      move(e);
      if (e.type != 'mousedown')
        return;
      if (host.renderer.$keepTextAreaAtCursor)
        host.renderer.$keepTextAreaAtCursor = null;
      if (useragent.isWin)
        event.capture(host.container, move, onContextMenuClose);
    };
    this.onContextMenuClose = onContextMenuClose;
    function onContextMenuClose() {
      setTimeout(function () {
        if (tempStyle) {
          text.style.cssText = tempStyle;
          tempStyle = '';
        }
        if (host.renderer.$keepTextAreaAtCursor == null) {
          host.renderer.$keepTextAreaAtCursor = true;
          host.renderer.$moveTextAreaToCursor();
        }
      }, 0);
    }
    if (!useragent.isGecko || useragent.isMac) {
      var onContextMenu = function (e) {
        host.textInput.onContextMenu(e);
        onContextMenuClose();
      };
      event.addListener(host.renderer.scroller, 'contextmenu', onContextMenu);
      event.addListener(text, 'contextmenu', onContextMenu);
    }
  };
  exports.TextInput = TextInput;
});
ace.define('ace/lib/lang', [
  'require',
  'exports',
  'module'
], function (require, exports, module) {
  exports.last = function (a) {
    return a[a.length - 1];
  };
  exports.stringReverse = function (string) {
    return string.split('').reverse().join('');
  };
  exports.stringRepeat = function (string, count) {
    var result = '';
    while (count > 0) {
      if (count & 1)
        result += string;
      if (count >>= 1)
        string += string;
    }
    return result;
  };
  var trimBeginRegexp = /^\s\s*/;
  var trimEndRegexp = /\s\s*$/;
  exports.stringTrimLeft = function (string) {
    return string.replace(trimBeginRegexp, '');
  };
  exports.stringTrimRight = function (string) {
    return string.replace(trimEndRegexp, '');
  };
  exports.copyObject = function (obj) {
    var copy = {};
    for (var key in obj) {
      copy[key] = obj[key];
    }
    return copy;
  };
  exports.copyArray = function (array) {
    var copy = [];
    for (var i = 0, l = array.length; i < l; i++) {
      if (array[i] && typeof array[i] == 'object')
        copy[i] = this.copyObject(array[i]);
      else
        copy[i] = array[i];
    }
    return copy;
  };
  exports.deepCopy = function (obj) {
    if (typeof obj !== 'object' || !obj)
      return obj;
    var cons = obj.constructor;
    if (cons === RegExp)
      return obj;
    var copy = cons();
    for (var key in obj) {
      if (typeof obj[key] === 'object') {
        copy[key] = exports.deepCopy(obj[key]);
      } else {
        copy[key] = obj[key];
      }
    }
    return copy;
  };
  exports.arrayToMap = function (arr) {
    var map = {};
    for (var i = 0; i < arr.length; i++) {
      map[arr[i]] = 1;
    }
    return map;
  };
  exports.createMap = function (props) {
    var map = Object.create(null);
    for (var i in props) {
      map[i] = props[i];
    }
    return map;
  };
  exports.arrayRemove = function (array, value) {
    for (var i = 0; i <= array.length; i++) {
      if (value === array[i]) {
        array.splice(i, 1);
      }
    }
  };
  exports.escapeRegExp = function (str) {
    return str.replace(/([.*+?^${}()|[\]\/\\])/g, '\\$1');
  };
  exports.escapeHTML = function (str) {
    return str.replace(/&/g, '&#38;').replace(/"/g, '&#34;').replace(/'/g, '&#39;').replace(/</g, '&#60;');
  };
  exports.getMatchOffsets = function (string, regExp) {
    var matches = [];
    string.replace(regExp, function (str) {
      matches.push({
        offset: arguments[arguments.length - 2],
        length: str.length
      });
    });
    return matches;
  };
  exports.deferredCall = function (fcn) {
    var timer = null;
    var callback = function () {
      timer = null;
      fcn();
    };
    var deferred = function (timeout) {
      deferred.cancel();
      timer = setTimeout(callback, timeout || 0);
      return deferred;
    };
    deferred.schedule = deferred;
    deferred.call = function () {
      this.cancel();
      fcn();
      return deferred;
    };
    deferred.cancel = function () {
      clearTimeout(timer);
      timer = null;
      return deferred;
    };
    deferred.isPending = function () {
      return timer;
    };
    return deferred;
  };
  exports.delayedCall = function (fcn, defaultTimeout) {
    var timer = null;
    var callback = function () {
      timer = null;
      fcn();
    };
    var _self = function (timeout) {
      if (timer == null)
        timer = setTimeout(callback, timeout || defaultTimeout);
    };
    _self.delay = function (timeout) {
      timer && clearTimeout(timer);
      timer = setTimeout(callback, timeout || defaultTimeout);
    };
    _self.schedule = _self;
    _self.call = function () {
      this.cancel();
      fcn();
    };
    _self.cancel = function () {
      timer && clearTimeout(timer);
      timer = null;
    };
    _self.isPending = function () {
      return timer;
    };
    return _self;
  };
});
ace.define('ace/multi_select', [
  'require',
  'exports',
  'module',
  'ace/range_list',
  'ace/range',
  'ace/selection',
  'ace/mouse/multi_select_handler',
  'ace/lib/event',
  'ace/lib/lang',
  'ace/commands/multi_select_commands',
  'ace/search',
  'ace/edit_session',
  'ace/editor',
  'ace/config'
], function (require, exports, module) {
  var RangeList = require('./range_list').RangeList;
  var Range = require('./range').Range;
  var Selection = require('./selection').Selection;
  var onMouseDown = require('./mouse/multi_select_handler').onMouseDown;
  var event = require('./lib/event');
  var lang = require('./lib/lang');
  var commands = require('./commands/multi_select_commands');
  exports.commands = commands.defaultCommands.concat(commands.multiSelectCommands);
  var Search = require('./search').Search;
  var search = new Search();
  function find(session, needle, dir) {
    search.$options.wrap = true;
    search.$options.needle = needle;
    search.$options.backwards = dir == -1;
    return search.find(session);
  }
  var EditSession = require('./edit_session').EditSession;
  (function () {
    this.getSelectionMarkers = function () {
      return this.$selectionMarkers;
    };
  }.call(EditSession.prototype));
  (function () {
    this.ranges = null;
    this.rangeList = null;
    this.addRange = function (range, $blockChangeEvents) {
      if (!range)
        return;
      if (!this.inMultiSelectMode && this.rangeCount == 0) {
        var oldRange = this.toOrientedRange();
        this.rangeList.add(oldRange);
        this.rangeList.add(range);
        if (this.rangeList.ranges.length != 2) {
          this.rangeList.removeAll();
          return $blockChangeEvents || this.fromOrientedRange(range);
        }
        this.rangeList.removeAll();
        this.rangeList.add(oldRange);
        this.$onAddRange(oldRange);
      }
      if (!range.cursor)
        range.cursor = range.end;
      var removed = this.rangeList.add(range);
      this.$onAddRange(range);
      if (removed.length)
        this.$onRemoveRange(removed);
      if (this.rangeCount > 1 && !this.inMultiSelectMode) {
        this._signal('multiSelect');
        this.inMultiSelectMode = true;
        this.session.$undoSelect = false;
        this.rangeList.attach(this.session);
      }
      return $blockChangeEvents || this.fromOrientedRange(range);
    };
    this.toSingleRange = function (range) {
      range = range || this.ranges[0];
      var removed = this.rangeList.removeAll();
      if (removed.length)
        this.$onRemoveRange(removed);
      range && this.fromOrientedRange(range);
    };
    this.substractPoint = function (pos) {
      var removed = this.rangeList.substractPoint(pos);
      if (removed) {
        this.$onRemoveRange(removed);
        return removed[0];
      }
    };
    this.mergeOverlappingRanges = function () {
      var removed = this.rangeList.merge();
      if (removed.length)
        this.$onRemoveRange(removed);
      else if (this.ranges[0])
        this.fromOrientedRange(this.ranges[0]);
    };
    this.$onAddRange = function (range) {
      this.rangeCount = this.rangeList.ranges.length;
      this.ranges.unshift(range);
      this._signal('addRange', { range: range });
    };
    this.$onRemoveRange = function (removed) {
      this.rangeCount = this.rangeList.ranges.length;
      if (this.rangeCount == 1 && this.inMultiSelectMode) {
        var lastRange = this.rangeList.ranges.pop();
        removed.push(lastRange);
        this.rangeCount = 0;
      }
      for (var i = removed.length; i--;) {
        var index = this.ranges.indexOf(removed[i]);
        this.ranges.splice(index, 1);
      }
      this._signal('removeRange', { ranges: removed });
      if (this.rangeCount == 0 && this.inMultiSelectMode) {
        this.inMultiSelectMode = false;
        this._signal('singleSelect');
        this.session.$undoSelect = true;
        this.rangeList.detach(this.session);
      }
      lastRange = lastRange || this.ranges[0];
      if (lastRange && !lastRange.isEqual(this.getRange()))
        this.fromOrientedRange(lastRange);
    };
    this.$initRangeList = function () {
      if (this.rangeList)
        return;
      this.rangeList = new RangeList();
      this.ranges = [];
      this.rangeCount = 0;
    };
    this.getAllRanges = function () {
      return this.rangeCount ? this.rangeList.ranges.concat() : [this.getRange()];
    };
    this.splitIntoLines = function () {
      if (this.rangeCount > 1) {
        var ranges = this.rangeList.ranges;
        var lastRange = ranges[ranges.length - 1];
        var range = Range.fromPoints(ranges[0].start, lastRange.end);
        this.toSingleRange();
        this.setSelectionRange(range, lastRange.cursor == lastRange.start);
      } else {
        var range = this.getRange();
        var isBackwards = this.isBackwards();
        var startRow = range.start.row;
        var endRow = range.end.row;
        if (startRow == endRow) {
          if (isBackwards)
            var start = range.end, end = range.start;
          else
            var start = range.start, end = range.end;
          this.addRange(Range.fromPoints(end, end));
          this.addRange(Range.fromPoints(start, start));
          return;
        }
        var rectSel = [];
        var r = this.getLineRange(startRow, true);
        r.start.column = range.start.column;
        rectSel.push(r);
        for (var i = startRow + 1; i < endRow; i++)
          rectSel.push(this.getLineRange(i, true));
        r = this.getLineRange(endRow, true);
        r.end.column = range.end.column;
        rectSel.push(r);
        rectSel.forEach(this.addRange, this);
      }
    };
    this.toggleBlockSelection = function () {
      if (this.rangeCount > 1) {
        var ranges = this.rangeList.ranges;
        var lastRange = ranges[ranges.length - 1];
        var range = Range.fromPoints(ranges[0].start, lastRange.end);
        this.toSingleRange();
        this.setSelectionRange(range, lastRange.cursor == lastRange.start);
      } else {
        var cursor = this.session.documentToScreenPosition(this.selectionLead);
        var anchor = this.session.documentToScreenPosition(this.selectionAnchor);
        var rectSel = this.rectangularRangeBlock(cursor, anchor);
        rectSel.forEach(this.addRange, this);
      }
    };
    this.rectangularRangeBlock = function (screenCursor, screenAnchor, includeEmptyLines) {
      var rectSel = [];
      var xBackwards = screenCursor.column < screenAnchor.column;
      if (xBackwards) {
        var startColumn = screenCursor.column;
        var endColumn = screenAnchor.column;
      } else {
        var startColumn = screenAnchor.column;
        var endColumn = screenCursor.column;
      }
      var yBackwards = screenCursor.row < screenAnchor.row;
      if (yBackwards) {
        var startRow = screenCursor.row;
        var endRow = screenAnchor.row;
      } else {
        var startRow = screenAnchor.row;
        var endRow = screenCursor.row;
      }
      if (startColumn < 0)
        startColumn = 0;
      if (startRow < 0)
        startRow = 0;
      if (startRow == endRow)
        includeEmptyLines = true;
      for (var row = startRow; row <= endRow; row++) {
        var range = Range.fromPoints(this.session.screenToDocumentPosition(row, startColumn), this.session.screenToDocumentPosition(row, endColumn));
        if (range.isEmpty()) {
          if (docEnd && isSamePoint(range.end, docEnd))
            break;
          var docEnd = range.end;
        }
        range.cursor = xBackwards ? range.start : range.end;
        rectSel.push(range);
      }
      if (yBackwards)
        rectSel.reverse();
      if (!includeEmptyLines) {
        var end = rectSel.length - 1;
        while (rectSel[end].isEmpty() && end > 0)
          end--;
        if (end > 0) {
          var start = 0;
          while (rectSel[start].isEmpty())
            start++;
        }
        for (var i = end; i >= start; i--) {
          if (rectSel[i].isEmpty())
            rectSel.splice(i, 1);
        }
      }
      return rectSel;
    };
  }.call(Selection.prototype));
  var Editor = require('./editor').Editor;
  (function () {
    this.updateSelectionMarkers = function () {
      this.renderer.updateCursor();
      this.renderer.updateBackMarkers();
    };
    this.addSelectionMarker = function (orientedRange) {
      if (!orientedRange.cursor)
        orientedRange.cursor = orientedRange.end;
      var style = this.getSelectionStyle();
      orientedRange.marker = this.session.addMarker(orientedRange, 'ace_selection', style);
      this.session.$selectionMarkers.push(orientedRange);
      this.session.selectionMarkerCount = this.session.$selectionMarkers.length;
      return orientedRange;
    };
    this.removeSelectionMarker = function (range) {
      if (!range.marker)
        return;
      this.session.removeMarker(range.marker);
      var index = this.session.$selectionMarkers.indexOf(range);
      if (index != -1)
        this.session.$selectionMarkers.splice(index, 1);
      this.session.selectionMarkerCount = this.session.$selectionMarkers.length;
    };
    this.removeSelectionMarkers = function (ranges) {
      var markerList = this.session.$selectionMarkers;
      for (var i = ranges.length; i--;) {
        var range = ranges[i];
        if (!range.marker)
          continue;
        this.session.removeMarker(range.marker);
        var index = markerList.indexOf(range);
        if (index != -1)
          markerList.splice(index, 1);
      }
      this.session.selectionMarkerCount = markerList.length;
    };
    this.$onAddRange = function (e) {
      this.addSelectionMarker(e.range);
      this.renderer.updateCursor();
      this.renderer.updateBackMarkers();
    };
    this.$onRemoveRange = function (e) {
      this.removeSelectionMarkers(e.ranges);
      this.renderer.updateCursor();
      this.renderer.updateBackMarkers();
    };
    this.$onMultiSelect = function (e) {
      if (this.inMultiSelectMode)
        return;
      this.inMultiSelectMode = true;
      this.setStyle('ace_multiselect');
      this.keyBinding.addKeyboardHandler(commands.keyboardHandler);
      this.commands.setDefaultHandler('exec', this.$onMultiSelectExec);
      this.renderer.updateCursor();
      this.renderer.updateBackMarkers();
    };
    this.$onSingleSelect = function (e) {
      if (this.session.multiSelect.inVirtualMode)
        return;
      this.inMultiSelectMode = false;
      this.unsetStyle('ace_multiselect');
      this.keyBinding.removeKeyboardHandler(commands.keyboardHandler);
      this.commands.removeDefaultHandler('exec', this.$onMultiSelectExec);
      this.renderer.updateCursor();
      this.renderer.updateBackMarkers();
      this._emit('changeSelection');
    };
    this.$onMultiSelectExec = function (e) {
      var command = e.command;
      var editor = e.editor;
      if (!editor.multiSelect)
        return;
      if (!command.multiSelectAction) {
        var result = command.exec(editor, e.args || {});
        editor.multiSelect.addRange(editor.multiSelect.toOrientedRange());
        editor.multiSelect.mergeOverlappingRanges();
      } else if (command.multiSelectAction == 'forEach') {
        result = editor.forEachSelection(command, e.args);
      } else if (command.multiSelectAction == 'forEachLine') {
        result = editor.forEachSelection(command, e.args, true);
      } else if (command.multiSelectAction == 'single') {
        editor.exitMultiSelectMode();
        result = command.exec(editor, e.args || {});
      } else {
        result = command.multiSelectAction(editor, e.args || {});
      }
      return result;
    };
    this.forEachSelection = function (cmd, args, $byLines) {
      if (this.inVirtualSelectionMode)
        return;
      var session = this.session;
      var selection = this.selection;
      var rangeList = selection.rangeList;
      var result;
      var reg = selection._eventRegistry;
      selection._eventRegistry = {};
      var tmpSel = new Selection(session);
      this.inVirtualSelectionMode = true;
      for (var i = rangeList.ranges.length; i--;) {
        if ($byLines) {
          while (i > 0 && rangeList.ranges[i].start.row == rangeList.ranges[i - 1].end.row)
            i--;
        }
        tmpSel.fromOrientedRange(rangeList.ranges[i]);
        tmpSel.id = rangeList.ranges[i].marker;
        this.selection = session.selection = tmpSel;
        var cmdResult = cmd.exec(this, args || {});
        if (result !== undefined)
          result = cmdResult;
        tmpSel.toOrientedRange(rangeList.ranges[i]);
      }
      tmpSel.detach();
      this.selection = session.selection = selection;
      this.inVirtualSelectionMode = false;
      selection._eventRegistry = reg;
      selection.mergeOverlappingRanges();
      var anim = this.renderer.$scrollAnimation;
      this.onCursorChange();
      this.onSelectionChange();
      if (anim && anim.from == anim.to)
        this.renderer.animateScrolling(anim.from);
      return result;
    };
    this.exitMultiSelectMode = function () {
      if (!this.inMultiSelectMode || this.inVirtualSelectionMode)
        return;
      this.multiSelect.toSingleRange();
    };
    this.getSelectedText = function () {
      var text = '';
      if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {
        var ranges = this.multiSelect.rangeList.ranges;
        var buf = [];
        for (var i = 0; i < ranges.length; i++) {
          buf.push(this.session.getTextRange(ranges[i]));
        }
        var nl = this.session.getDocument().getNewLineCharacter();
        text = buf.join(nl);
        if (text.length == (buf.length - 1) * nl.length)
          text = '';
      } else if (!this.selection.isEmpty()) {
        text = this.session.getTextRange(this.getSelectionRange());
      }
      return text;
    };
    this.onPaste = function (text) {
      if (this.$readOnly)
        return;
      var e = { text: text };
      this._signal('paste', e);
      text = e.text;
      if (!this.inMultiSelectMode || this.inVirtualSelectionMode)
        return this.insert(text);
      var lines = text.split(/\r\n|\r|\n/);
      var ranges = this.selection.rangeList.ranges;
      if (lines.length > ranges.length || lines.length < 2 || !lines[1])
        return this.commands.exec('insertstring', this, text);
      for (var i = ranges.length; i--;) {
        var range = ranges[i];
        if (!range.isEmpty())
          this.session.remove(range);
        this.session.insert(range.start, lines[i]);
      }
    };
    this.findAll = function (needle, options, additive) {
      options = options || {};
      options.needle = needle || options.needle;
      this.$search.set(options);
      var ranges = this.$search.findAll(this.session);
      if (!ranges.length)
        return 0;
      this.$blockScrolling += 1;
      var selection = this.multiSelect;
      if (!additive)
        selection.toSingleRange(ranges[0]);
      for (var i = ranges.length; i--;)
        selection.addRange(ranges[i], true);
      this.$blockScrolling -= 1;
      return ranges.length;
    };
    this.selectMoreLines = function (dir, skip) {
      var range = this.selection.toOrientedRange();
      var isBackwards = range.cursor == range.end;
      var screenLead = this.session.documentToScreenPosition(range.cursor);
      if (this.selection.$desiredColumn)
        screenLead.column = this.selection.$desiredColumn;
      var lead = this.session.screenToDocumentPosition(screenLead.row + dir, screenLead.column);
      if (!range.isEmpty()) {
        var screenAnchor = this.session.documentToScreenPosition(isBackwards ? range.end : range.start);
        var anchor = this.session.screenToDocumentPosition(screenAnchor.row + dir, screenAnchor.column);
      } else {
        var anchor = lead;
      }
      if (isBackwards) {
        var newRange = Range.fromPoints(lead, anchor);
        newRange.cursor = newRange.start;
      } else {
        var newRange = Range.fromPoints(anchor, lead);
        newRange.cursor = newRange.end;
      }
      newRange.desiredColumn = screenLead.column;
      if (!this.selection.inMultiSelectMode) {
        this.selection.addRange(range);
      } else {
        if (skip)
          var toRemove = range.cursor;
      }
      this.selection.addRange(newRange);
      if (toRemove)
        this.selection.substractPoint(toRemove);
    };
    this.transposeSelections = function (dir) {
      var session = this.session;
      var sel = session.multiSelect;
      var all = sel.ranges;
      for (var i = all.length; i--;) {
        var range = all[i];
        if (range.isEmpty()) {
          var tmp = session.getWordRange(range.start.row, range.start.column);
          range.start.row = tmp.start.row;
          range.start.column = tmp.start.column;
          range.end.row = tmp.end.row;
          range.end.column = tmp.end.column;
        }
      }
      sel.mergeOverlappingRanges();
      var words = [];
      for (var i = all.length; i--;) {
        var range = all[i];
        words.unshift(session.getTextRange(range));
      }
      if (dir < 0)
        words.unshift(words.pop());
      else
        words.push(words.shift());
      for (var i = all.length; i--;) {
        var range = all[i];
        var tmp = range.clone();
        session.replace(range, words[i]);
        range.start.row = tmp.start.row;
        range.start.column = tmp.start.column;
      }
    };
    this.selectMore = function (dir, skip) {
      var session = this.session;
      var sel = session.multiSelect;
      var range = sel.toOrientedRange();
      if (range.isEmpty()) {
        range = session.getWordRange(range.start.row, range.start.column);
        range.cursor = dir == -1 ? range.start : range.end;
        this.multiSelect.addRange(range);
      }
      var needle = session.getTextRange(range);
      var newRange = find(session, needle, dir);
      if (newRange) {
        newRange.cursor = dir == -1 ? newRange.start : newRange.end;
        this.$blockScrolling += 1;
        this.session.unfold(newRange);
        this.multiSelect.addRange(newRange);
        this.$blockScrolling -= 1;
        this.renderer.scrollCursorIntoView(null, 0.5);
      }
      if (skip)
        this.multiSelect.substractPoint(range.cursor);
    };
    this.alignCursors = function () {
      var session = this.session;
      var sel = session.multiSelect;
      var ranges = sel.ranges;
      if (!ranges.length) {
        var range = this.selection.getRange();
        var fr = range.start.row, lr = range.end.row;
        var guessRange = fr == lr;
        if (guessRange) {
          var max = this.session.getLength();
          var line;
          do {
            line = this.session.getLine(lr);
          } while (/[=:]/.test(line) && ++lr < max);
          do {
            line = this.session.getLine(fr);
          } while (/[=:]/.test(line) && --fr > 0);
          if (fr < 0)
            fr = 0;
          if (lr >= max)
            lr = max - 1;
        }
        var lines = this.session.doc.removeLines(fr, lr);
        lines = this.$reAlignText(lines, guessRange);
        this.session.doc.insert({
          row: fr,
          column: 0
        }, lines.join('\n') + '\n');
        if (!guessRange) {
          range.start.column = 0;
          range.end.column = lines[lines.length - 1].length;
        }
        this.selection.setRange(range);
      } else {
        var row = -1;
        var sameRowRanges = ranges.filter(function (r) {
            if (r.cursor.row == row)
              return true;
            row = r.cursor.row;
          });
        sel.$onRemoveRange(sameRowRanges);
        var maxCol = 0;
        var minSpace = Infinity;
        var spaceOffsets = ranges.map(function (r) {
            var p = r.cursor;
            var line = session.getLine(p.row);
            var spaceOffset = line.substr(p.column).search(/\S/g);
            if (spaceOffset == -1)
              spaceOffset = 0;
            if (p.column > maxCol)
              maxCol = p.column;
            if (spaceOffset < minSpace)
              minSpace = spaceOffset;
            return spaceOffset;
          });
        ranges.forEach(function (r, i) {
          var p = r.cursor;
          var l = maxCol - p.column;
          var d = spaceOffsets[i] - minSpace;
          if (l > d)
            session.insert(p, lang.stringRepeat(' ', l - d));
          else
            session.remove(new Range(p.row, p.column, p.row, p.column - l + d));
          r.start.column = r.end.column = maxCol;
          r.start.row = r.end.row = p.row;
          r.cursor = r.end;
        });
        sel.fromOrientedRange(ranges[0]);
        this.renderer.updateCursor();
        this.renderer.updateBackMarkers();
      }
    };
    this.$reAlignText = function (lines, forceLeft) {
      var isLeftAligned = true, isRightAligned = true;
      var startW, textW, endW;
      return lines.map(function (line) {
        var m = line.match(/(\s*)(.*?)(\s*)([=:].*)/);
        if (!m)
          return [line];
        if (startW == null) {
          startW = m[1].length;
          textW = m[2].length;
          endW = m[3].length;
          return m;
        }
        if (startW + textW + endW != m[1].length + m[2].length + m[3].length)
          isRightAligned = false;
        if (startW != m[1].length)
          isLeftAligned = false;
        if (startW > m[1].length)
          startW = m[1].length;
        if (textW < m[2].length)
          textW = m[2].length;
        if (endW > m[3].length)
          endW = m[3].length;
        return m;
      }).map(forceLeft ? alignLeft : isLeftAligned ? isRightAligned ? alignRight : alignLeft : unAlign);
      function spaces(n) {
        return lang.stringRepeat(' ', n);
      }
      function alignLeft(m) {
        return !m[2] ? m[0] : spaces(startW) + m[2] + spaces(textW - m[2].length + endW) + m[4].replace(/^([=:])\s+/, '$1 ');
      }
      function alignRight(m) {
        return !m[2] ? m[0] : spaces(startW + textW - m[2].length) + m[2] + spaces(endW, ' ') + m[4].replace(/^([=:])\s+/, '$1 ');
      }
      function unAlign(m) {
        return !m[2] ? m[0] : spaces(startW) + m[2] + spaces(endW) + m[4].replace(/^([=:])\s+/, '$1 ');
      }
    };
  }.call(Editor.prototype));
  function isSamePoint(p1, p2) {
    return p1.row == p2.row && p1.column == p2.column;
  }
  exports.onSessionChange = function (e) {
    var session = e.session;
    if (!session.multiSelect) {
      session.$selectionMarkers = [];
      session.selection.$initRangeList();
      session.multiSelect = session.selection;
    }
    this.multiSelect = session.multiSelect;
    var oldSession = e.oldSession;
    if (oldSession) {
      oldSession.multiSelect.removeEventListener('addRange', this.$onAddRange);
      oldSession.multiSelect.removeEventListener('removeRange', this.$onRemoveRange);
      oldSession.multiSelect.removeEventListener('multiSelect', this.$onMultiSelect);
      oldSession.multiSelect.removeEventListener('singleSelect', this.$onSingleSelect);
    }
    session.multiSelect.on('addRange', this.$onAddRange);
    session.multiSelect.on('removeRange', this.$onRemoveRange);
    session.multiSelect.on('multiSelect', this.$onMultiSelect);
    session.multiSelect.on('singleSelect', this.$onSingleSelect);
    if (this.inMultiSelectMode != session.selection.inMultiSelectMode) {
      if (session.selection.inMultiSelectMode)
        this.$onMultiSelect();
      else
        this.$onSingleSelect();
    }
  };
  function MultiSelect(editor) {
    if (editor.$multiselectOnSessionChange)
      return;
    editor.$onAddRange = editor.$onAddRange.bind(editor);
    editor.$onRemoveRange = editor.$onRemoveRange.bind(editor);
    editor.$onMultiSelect = editor.$onMultiSelect.bind(editor);
    editor.$onSingleSelect = editor.$onSingleSelect.bind(editor);
    editor.$multiselectOnSessionChange = exports.onSessionChange.bind(editor);
    editor.$multiselectOnSessionChange(editor);
    editor.on('changeSession', editor.$multiselectOnSessionChange);
    editor.on('mousedown', onMouseDown);
    editor.commands.addCommands(commands.defaultCommands);
    addAltCursorListeners(editor);
  }
  function addAltCursorListeners(editor) {
    var el = editor.textInput.getElement();
    var altCursor = false;
    event.addListener(el, 'keydown', function (e) {
      if (e.keyCode == 18 && !(e.ctrlKey || e.shiftKey || e.metaKey)) {
        if (!altCursor) {
          editor.renderer.setMouseCursor('crosshair');
          altCursor = true;
        }
      } else if (altCursor) {
        reset();
      }
    });
    event.addListener(el, 'keyup', reset);
    event.addListener(el, 'blur', reset);
    function reset(e) {
      if (altCursor) {
        editor.renderer.setMouseCursor('');
        altCursor = false;
      }
    }
  }
  exports.MultiSelect = MultiSelect;
  require('./config').defineOptions(Editor.prototype, 'editor', {
    enableMultiselect: {
      set: function (val) {
        MultiSelect(this);
        if (val) {
          this.on('changeSession', this.$multiselectOnSessionChange);
          this.on('mousedown', onMouseDown);
        } else {
          this.off('changeSession', this.$multiselectOnSessionChange);
          this.off('mousedown', onMouseDown);
        }
      },
      value: true
    }
  });
});
ace.define('ace/editor', [
  'require',
  'exports',
  'module',
  'ace/lib/fixoldbrowsers',
  'ace/lib/oop',
  'ace/lib/dom',
  'ace/lib/lang',
  'ace/lib/useragent',
  'ace/keyboard/textinput',
  'ace/mouse/mouse_handler',
  'ace/mouse/fold_handler',
  'ace/keyboard/keybinding',
  'ace/edit_session',
  'ace/search',
  'ace/range',
  'ace/lib/event_emitter',
  'ace/commands/command_manager',
  'ace/commands/default_commands',
  'ace/config'
], function (require, exports, module) {
  require('./lib/fixoldbrowsers');
  var oop = require('./lib/oop');
  var dom = require('./lib/dom');
  var lang = require('./lib/lang');
  var useragent = require('./lib/useragent');
  var TextInput = require('./keyboard/textinput').TextInput;
  var MouseHandler = require('./mouse/mouse_handler').MouseHandler;
  var FoldHandler = require('./mouse/fold_handler').FoldHandler;
  var KeyBinding = require('./keyboard/keybinding').KeyBinding;
  var EditSession = require('./edit_session').EditSession;
  var Search = require('./search').Search;
  var Range = require('./range').Range;
  var EventEmitter = require('./lib/event_emitter').EventEmitter;
  var CommandManager = require('./commands/command_manager').CommandManager;
  var defaultCommands = require('./commands/default_commands').commands;
  var config = require('./config');
  var Editor = function (renderer, session) {
    var container = renderer.getContainerElement();
    this.container = container;
    this.renderer = renderer;
    this.commands = new CommandManager(useragent.isMac ? 'mac' : 'win', defaultCommands);
    this.textInput = new TextInput(renderer.getTextAreaContainer(), this);
    this.renderer.textarea = this.textInput.getElement();
    this.keyBinding = new KeyBinding(this);
    this.$mouseHandler = new MouseHandler(this);
    new FoldHandler(this);
    this.$blockScrolling = 0;
    this.$search = new Search().set({ wrap: true });
    this.$historyTracker = this.$historyTracker.bind(this);
    this.commands.on('exec', this.$historyTracker);
    this.$initOperationListeners();
    this._$emitInputEvent = lang.delayedCall(function () {
      this._signal('input', {});
      this.session.bgTokenizer && this.session.bgTokenizer.scheduleStart();
    }.bind(this));
    this.on('change', function (_, _self) {
      _self._$emitInputEvent.schedule(31);
    });
    this.setSession(session || new EditSession(''));
    config.resetOptions(this);
    config._signal('editor', this);
  };
  (function () {
    oop.implement(this, EventEmitter);
    this.$initOperationListeners = function () {
      function last(a) {
        return a[a.length - 1];
      }
      this.selections = [];
      this.commands.on('exec', function (e) {
        this.startOperation(e);
        var command = e.command;
        if (command.aceCommandGroup == 'fileJump') {
          var prev = this.prevOp;
          if (!prev || prev.command.aceCommandGroup != 'fileJump') {
            this.lastFileJumpPos = last(this.selections);
          }
        } else {
          this.lastFileJumpPos = null;
        }
      }.bind(this), true);
      this.commands.on('afterExec', function (e) {
        var command = e.command;
        if (command.aceCommandGroup == 'fileJump') {
          if (this.lastFileJumpPos && !this.curOp.selectionChanged) {
            this.selection.fromJSON(this.lastFileJumpPos);
          }
        }
        this.endOperation(e);
      }.bind(this), true);
      this.$opResetTimer = lang.delayedCall(this.endOperation.bind(this));
      this.on('change', function () {
        this.curOp || this.startOperation();
        this.curOp.docChanged = true;
      }.bind(this), true);
      this.on('changeSelection', function () {
        this.curOp || this.startOperation();
        this.curOp.selectionChanged = true;
      }.bind(this), true);
    };
    this.curOp = null;
    this.prevOp = {};
    this.startOperation = function (commadEvent) {
      if (this.curOp) {
        if (!commadEvent || this.curOp.command)
          return;
        this.prevOp = this.curOp;
      }
      if (!commadEvent) {
        this.previousCommand = null;
        commadEvent = {};
      }
      this.$opResetTimer.schedule();
      this.curOp = {
        command: commadEvent.command || {},
        args: commadEvent.args,
        scrollTop: this.renderer.scrollTop
      };
      var command = this.curOp.command;
      if (command && command.scrollIntoView)
        this.$blockScrolling++;
      this.selections.push(this.selection.toJSON());
    };
    this.endOperation = function () {
      if (this.curOp) {
        var command = this.curOp.command;
        if (command && command.scrollIntoView) {
          this.$blockScrolling--;
          switch (command.scrollIntoView) {
          case 'center':
            this.renderer.scrollCursorIntoView(null, 0.5);
            break;
          case 'animate':
          case 'cursor':
            this.renderer.scrollCursorIntoView();
            break;
          case 'selectionPart':
            var range = this.selection.getRange();
            var config = this.renderer.layerConfig;
            if (range.start.row >= config.lastRow || range.end.row <= config.firstRow) {
              this.renderer.scrollSelectionIntoView(this.selection.anchor, this.selection.lead);
            }
            break;
          default:
            break;
          }
          if (command.scrollIntoView == 'animate')
            this.renderer.animateScrolling(this.curOp.scrollTop);
        }
        this.prevOp = this.curOp;
        this.curOp = null;
      }
    };
    this.$historyTracker = function (e) {
      if (!this.$mergeUndoDeltas)
        return;
      var prev = this.prevOp;
      var mergeableCommands = [
          'backspace',
          'del',
          'insertstring'
        ];
      var shouldMerge = prev.command && e.command.name == prev.command.name;
      if (e.command.name == 'insertstring') {
        var text = e.args;
        if (this.mergeNextCommand === undefined)
          this.mergeNextCommand = true;
        shouldMerge = shouldMerge && this.mergeNextCommand && (!/\s/.test(text) || /\s/.test(prev.args));
        this.mergeNextCommand = true;
      } else {
        shouldMerge = shouldMerge && mergeableCommands.indexOf(e.command.name) !== -1;
      }
      if (this.$mergeUndoDeltas != 'always' && Date.now() - this.sequenceStartTime > 2000) {
        shouldMerge = false;
      }
      if (shouldMerge)
        this.session.mergeUndoDeltas = true;
      else if (mergeableCommands.indexOf(e.command.name) !== -1)
        this.sequenceStartTime = Date.now();
    };
    this.setKeyboardHandler = function (keyboardHandler) {
      if (!keyboardHandler) {
        this.keyBinding.setKeyboardHandler(null);
      } else if (typeof keyboardHandler === 'string') {
        this.$keybindingId = keyboardHandler;
        var _self = this;
        config.loadModule([
          'keybinding',
          keyboardHandler
        ], function (module) {
          if (_self.$keybindingId == keyboardHandler)
            _self.keyBinding.setKeyboardHandler(module && module.handler);
        });
      } else {
        this.$keybindingId = null;
        this.keyBinding.setKeyboardHandler(keyboardHandler);
      }
    };
    this.getKeyboardHandler = function () {
      return this.keyBinding.getKeyboardHandler();
    };
    this.setSession = function (session) {
      if (this.session == session)
        return;
      var oldSession = this.session;
      if (oldSession) {
        this.session.removeEventListener('change', this.$onDocumentChange);
        this.session.removeEventListener('changeMode', this.$onChangeMode);
        this.session.removeEventListener('tokenizerUpdate', this.$onTokenizerUpdate);
        this.session.removeEventListener('changeTabSize', this.$onChangeTabSize);
        this.session.removeEventListener('changeWrapLimit', this.$onChangeWrapLimit);
        this.session.removeEventListener('changeWrapMode', this.$onChangeWrapMode);
        this.session.removeEventListener('onChangeFold', this.$onChangeFold);
        this.session.removeEventListener('changeFrontMarker', this.$onChangeFrontMarker);
        this.session.removeEventListener('changeBackMarker', this.$onChangeBackMarker);
        this.session.removeEventListener('changeBreakpoint', this.$onChangeBreakpoint);
        this.session.removeEventListener('changeAnnotation', this.$onChangeAnnotation);
        this.session.removeEventListener('changeOverwrite', this.$onCursorChange);
        this.session.removeEventListener('changeScrollTop', this.$onScrollTopChange);
        this.session.removeEventListener('changeScrollLeft', this.$onScrollLeftChange);
        var selection = this.session.getSelection();
        selection.removeEventListener('changeCursor', this.$onCursorChange);
        selection.removeEventListener('changeSelection', this.$onSelectionChange);
      }
      this.session = session;
      if (session) {
        this.$onDocumentChange = this.onDocumentChange.bind(this);
        session.addEventListener('change', this.$onDocumentChange);
        this.renderer.setSession(session);
        this.$onChangeMode = this.onChangeMode.bind(this);
        session.addEventListener('changeMode', this.$onChangeMode);
        this.$onTokenizerUpdate = this.onTokenizerUpdate.bind(this);
        session.addEventListener('tokenizerUpdate', this.$onTokenizerUpdate);
        this.$onChangeTabSize = this.renderer.onChangeTabSize.bind(this.renderer);
        session.addEventListener('changeTabSize', this.$onChangeTabSize);
        this.$onChangeWrapLimit = this.onChangeWrapLimit.bind(this);
        session.addEventListener('changeWrapLimit', this.$onChangeWrapLimit);
        this.$onChangeWrapMode = this.onChangeWrapMode.bind(this);
        session.addEventListener('changeWrapMode', this.$onChangeWrapMode);
        this.$onChangeFold = this.onChangeFold.bind(this);
        session.addEventListener('changeFold', this.$onChangeFold);
        this.$onChangeFrontMarker = this.onChangeFrontMarker.bind(this);
        this.session.addEventListener('changeFrontMarker', this.$onChangeFrontMarker);
        this.$onChangeBackMarker = this.onChangeBackMarker.bind(this);
        this.session.addEventListener('changeBackMarker', this.$onChangeBackMarker);
        this.$onChangeBreakpoint = this.onChangeBreakpoint.bind(this);
        this.session.addEventListener('changeBreakpoint', this.$onChangeBreakpoint);
        this.$onChangeAnnotation = this.onChangeAnnotation.bind(this);
        this.session.addEventListener('changeAnnotation', this.$onChangeAnnotation);
        this.$onCursorChange = this.onCursorChange.bind(this);
        this.session.addEventListener('changeOverwrite', this.$onCursorChange);
        this.$onScrollTopChange = this.onScrollTopChange.bind(this);
        this.session.addEventListener('changeScrollTop', this.$onScrollTopChange);
        this.$onScrollLeftChange = this.onScrollLeftChange.bind(this);
        this.session.addEventListener('changeScrollLeft', this.$onScrollLeftChange);
        this.selection = session.getSelection();
        this.selection.addEventListener('changeCursor', this.$onCursorChange);
        this.$onSelectionChange = this.onSelectionChange.bind(this);
        this.selection.addEventListener('changeSelection', this.$onSelectionChange);
        this.onChangeMode();
        this.$blockScrolling += 1;
        this.onCursorChange();
        this.$blockScrolling -= 1;
        this.onScrollTopChange();
        this.onScrollLeftChange();
        this.onSelectionChange();
        this.onChangeFrontMarker();
        this.onChangeBackMarker();
        this.onChangeBreakpoint();
        this.onChangeAnnotation();
        this.session.getUseWrapMode() && this.renderer.adjustWrapLimit();
        this.renderer.updateFull();
      }
      this._signal('changeSession', {
        session: session,
        oldSession: oldSession
      });
      oldSession && oldSession._signal('changeEditor', { oldEditor: this });
      session && session._signal('changeEditor', { editor: this });
    };
    this.getSession = function () {
      return this.session;
    };
    this.setValue = function (val, cursorPos) {
      this.session.doc.setValue(val);
      if (!cursorPos)
        this.selectAll();
      else if (cursorPos == 1)
        this.navigateFileEnd();
      else if (cursorPos == -1)
        this.navigateFileStart();
      return val;
    };
    this.getValue = function () {
      return this.session.getValue();
    };
    this.getSelection = function () {
      return this.selection;
    };
    this.resize = function (force) {
      this.renderer.onResize(force);
    };
    this.setTheme = function (theme, cb) {
      this.renderer.setTheme(theme, cb);
    };
    this.getTheme = function () {
      return this.renderer.getTheme();
    };
    this.setStyle = function (style) {
      this.renderer.setStyle(style);
    };
    this.unsetStyle = function (style) {
      this.renderer.unsetStyle(style);
    };
    this.getFontSize = function () {
      return this.getOption('fontSize') || dom.computedStyle(this.container, 'fontSize');
    };
    this.setFontSize = function (size) {
      this.setOption('fontSize', size);
    };
    this.$highlightBrackets = function () {
      if (this.session.$bracketHighlight) {
        this.session.removeMarker(this.session.$bracketHighlight);
        this.session.$bracketHighlight = null;
      }
      if (this.$highlightPending) {
        return;
      }
      var self = this;
      this.$highlightPending = true;
      setTimeout(function () {
        self.$highlightPending = false;
        var pos = self.session.findMatchingBracket(self.getCursorPosition());
        if (pos) {
          var range = new Range(pos.row, pos.column, pos.row, pos.column + 1);
        } else if (self.session.$mode.getMatching) {
          var range = self.session.$mode.getMatching(self.session);
        }
        if (range)
          self.session.$bracketHighlight = self.session.addMarker(range, 'ace_bracket', 'text');
      }, 50);
    };
    this.focus = function () {
      var _self = this;
      setTimeout(function () {
        _self.textInput.focus();
      });
      this.textInput.focus();
    };
    this.isFocused = function () {
      return this.textInput.isFocused();
    };
    this.blur = function () {
      this.textInput.blur();
    };
    this.onFocus = function () {
      if (this.$isFocused)
        return;
      this.$isFocused = true;
      this.renderer.showCursor();
      this.renderer.visualizeFocus();
      this._emit('focus');
    };
    this.onBlur = function () {
      if (!this.$isFocused)
        return;
      this.$isFocused = false;
      this.renderer.hideCursor();
      this.renderer.visualizeBlur();
      this._emit('blur');
    };
    this.$cursorChange = function () {
      this.renderer.updateCursor();
    };
    this.onDocumentChange = function (e) {
      var delta = e.data;
      var range = delta.range;
      var lastRow;
      if (range.start.row == range.end.row && delta.action != 'insertLines' && delta.action != 'removeLines')
        lastRow = range.end.row;
      else
        lastRow = Infinity;
      this.renderer.updateLines(range.start.row, lastRow);
      this._signal('change', e);
      this.$cursorChange();
    };
    this.onTokenizerUpdate = function (e) {
      var rows = e.data;
      this.renderer.updateLines(rows.first, rows.last);
    };
    this.onScrollTopChange = function () {
      this.renderer.scrollToY(this.session.getScrollTop());
    };
    this.onScrollLeftChange = function () {
      this.renderer.scrollToX(this.session.getScrollLeft());
    };
    this.onCursorChange = function () {
      this.$cursorChange();
      if (!this.$blockScrolling) {
        this.renderer.scrollCursorIntoView();
      }
      this.$highlightBrackets();
      this.$updateHighlightActiveLine();
      this._signal('changeSelection');
    };
    this.$updateHighlightActiveLine = function () {
      var session = this.getSession();
      var highlight;
      if (this.$highlightActiveLine) {
        if (this.$selectionStyle != 'line' || !this.selection.isMultiLine())
          highlight = this.getCursorPosition();
        if (this.renderer.$maxLines && this.session.getLength() === 1 && !(this.renderer.$minLines > 1))
          highlight = false;
      }
      if (session.$highlightLineMarker && !highlight) {
        session.removeMarker(session.$highlightLineMarker.id);
        session.$highlightLineMarker = null;
      } else if (!session.$highlightLineMarker && highlight) {
        var range = new Range(highlight.row, highlight.column, highlight.row, Infinity);
        range.id = session.addMarker(range, 'ace_active-line', 'screenLine');
        session.$highlightLineMarker = range;
      } else if (highlight) {
        session.$highlightLineMarker.start.row = highlight.row;
        session.$highlightLineMarker.end.row = highlight.row;
        session.$highlightLineMarker.start.column = highlight.column;
        session._signal('changeBackMarker');
      }
    };
    this.onSelectionChange = function (e) {
      var session = this.session;
      if (session.$selectionMarker) {
        session.removeMarker(session.$selectionMarker);
      }
      session.$selectionMarker = null;
      if (!this.selection.isEmpty()) {
        var range = this.selection.getRange();
        var style = this.getSelectionStyle();
        session.$selectionMarker = session.addMarker(range, 'ace_selection', style);
      } else {
        this.$updateHighlightActiveLine();
      }
      var re = this.$highlightSelectedWord && this.$getSelectionHighLightRegexp();
      this.session.highlight(re);
      this._signal('changeSelection');
    };
    this.$getSelectionHighLightRegexp = function () {
      var session = this.session;
      var selection = this.getSelectionRange();
      if (selection.isEmpty() || selection.isMultiLine())
        return;
      var startOuter = selection.start.column - 1;
      var endOuter = selection.end.column + 1;
      var line = session.getLine(selection.start.row);
      var lineCols = line.length;
      var needle = line.substring(Math.max(startOuter, 0), Math.min(endOuter, lineCols));
      if (startOuter >= 0 && /^[\w\d]/.test(needle) || endOuter <= lineCols && /[\w\d]$/.test(needle))
        return;
      needle = line.substring(selection.start.column, selection.end.column);
      if (!/^[\w\d]+$/.test(needle))
        return;
      var re = this.$search.$assembleRegExp({
          wholeWord: true,
          caseSensitive: true,
          needle: needle
        });
      return re;
    };
    this.onChangeFrontMarker = function () {
      this.renderer.updateFrontMarkers();
    };
    this.onChangeBackMarker = function () {
      this.renderer.updateBackMarkers();
    };
    this.onChangeBreakpoint = function () {
      this.renderer.updateBreakpoints();
    };
    this.onChangeAnnotation = function () {
      this.renderer.setAnnotations(this.session.getAnnotations());
    };
    this.onChangeMode = function (e) {
      this.renderer.updateText();
      this._emit('changeMode', e);
    };
    this.onChangeWrapLimit = function () {
      this.renderer.updateFull();
    };
    this.onChangeWrapMode = function () {
      this.renderer.onResize(true);
    };
    this.onChangeFold = function () {
      this.$updateHighlightActiveLine();
      this.renderer.updateFull();
    };
    this.getSelectedText = function () {
      return this.session.getTextRange(this.getSelectionRange());
    };
    this.getCopyText = function () {
      var text = this.getSelectedText();
      this._signal('copy', text);
      return text;
    };
    this.onCopy = function () {
      this.commands.exec('copy', this);
    };
    this.onCut = function () {
      this.commands.exec('cut', this);
    };
    this.onPaste = function (text) {
      if (this.$readOnly)
        return;
      var e = { text: text };
      this._signal('paste', e);
      this.insert(e.text, true);
    };
    this.execCommand = function (command, args) {
      this.commands.exec(command, this, args);
    };
    this.insert = function (text, pasted) {
      var session = this.session;
      var mode = session.getMode();
      var cursor = this.getCursorPosition();
      if (this.getBehavioursEnabled() && !pasted) {
        var transform = mode.transformAction(session.getState(cursor.row), 'insertion', this, session, text);
        if (transform) {
          if (text !== transform.text) {
            this.session.mergeUndoDeltas = false;
            this.$mergeNextCommand = false;
          }
          text = transform.text;
        }
      }
      if (text == '\t')
        text = this.session.getTabString();
      if (!this.selection.isEmpty()) {
        var range = this.getSelectionRange();
        cursor = this.session.remove(range);
        this.clearSelection();
      } else if (this.session.getOverwrite()) {
        var range = new Range.fromPoints(cursor, cursor);
        range.end.column += text.length;
        this.session.remove(range);
      }
      if (text == '\n' || text == '\r\n') {
        var line = session.getLine(cursor.row);
        if (cursor.column > line.search(/\S|$/)) {
          var d = line.substr(cursor.column).search(/\S|$/);
          session.doc.removeInLine(cursor.row, cursor.column, cursor.column + d);
        }
      }
      this.clearSelection();
      var start = cursor.column;
      var lineState = session.getState(cursor.row);
      var line = session.getLine(cursor.row);
      var shouldOutdent = mode.checkOutdent(lineState, line, text);
      var end = session.insert(cursor, text);
      if (transform && transform.selection) {
        if (transform.selection.length == 2) {
          this.selection.setSelectionRange(new Range(cursor.row, start + transform.selection[0], cursor.row, start + transform.selection[1]));
        } else {
          this.selection.setSelectionRange(new Range(cursor.row + transform.selection[0], transform.selection[1], cursor.row + transform.selection[2], transform.selection[3]));
        }
      }
      if (session.getDocument().isNewLine(text)) {
        var lineIndent = mode.getNextLineIndent(lineState, line.slice(0, cursor.column), session.getTabString());
        session.insert({
          row: cursor.row + 1,
          column: 0
        }, lineIndent);
      }
      if (shouldOutdent)
        mode.autoOutdent(lineState, session, cursor.row);
    };
    this.onTextInput = function (text) {
      this.keyBinding.onTextInput(text);
    };
    this.onCommandKey = function (e, hashId, keyCode) {
      this.keyBinding.onCommandKey(e, hashId, keyCode);
    };
    this.setOverwrite = function (overwrite) {
      this.session.setOverwrite(overwrite);
    };
    this.getOverwrite = function () {
      return this.session.getOverwrite();
    };
    this.toggleOverwrite = function () {
      this.session.toggleOverwrite();
    };
    this.setScrollSpeed = function (speed) {
      this.setOption('scrollSpeed', speed);
    };
    this.getScrollSpeed = function () {
      return this.getOption('scrollSpeed');
    };
    this.setDragDelay = function (dragDelay) {
      this.setOption('dragDelay', dragDelay);
    };
    this.getDragDelay = function () {
      return this.getOption('dragDelay');
    };
    this.setSelectionStyle = function (val) {
      this.setOption('selectionStyle', val);
    };
    this.getSelectionStyle = function () {
      return this.getOption('selectionStyle');
    };
    this.setHighlightActiveLine = function (shouldHighlight) {
      this.setOption('highlightActiveLine', shouldHighlight);
    };
    this.getHighlightActiveLine = function () {
      return this.getOption('highlightActiveLine');
    };
    this.setHighlightGutterLine = function (shouldHighlight) {
      this.setOption('highlightGutterLine', shouldHighlight);
    };
    this.getHighlightGutterLine = function () {
      return this.getOption('highlightGutterLine');
    };
    this.setHighlightSelectedWord = function (shouldHighlight) {
      this.setOption('highlightSelectedWord', shouldHighlight);
    };
    this.getHighlightSelectedWord = function () {
      return this.$highlightSelectedWord;
    };
    this.setAnimatedScroll = function (shouldAnimate) {
      this.renderer.setAnimatedScroll(shouldAnimate);
    };
    this.getAnimatedScroll = function () {
      return this.renderer.getAnimatedScroll();
    };
    this.setShowInvisibles = function (showInvisibles) {
      this.renderer.setShowInvisibles(showInvisibles);
    };
    this.getShowInvisibles = function () {
      return this.renderer.getShowInvisibles();
    };
    this.setDisplayIndentGuides = function (display) {
      this.renderer.setDisplayIndentGuides(display);
    };
    this.getDisplayIndentGuides = function () {
      return this.renderer.getDisplayIndentGuides();
    };
    this.setShowPrintMargin = function (showPrintMargin) {
      this.renderer.setShowPrintMargin(showPrintMargin);
    };
    this.getShowPrintMargin = function () {
      return this.renderer.getShowPrintMargin();
    };
    this.setPrintMarginColumn = function (showPrintMargin) {
      this.renderer.setPrintMarginColumn(showPrintMargin);
    };
    this.getPrintMarginColumn = function () {
      return this.renderer.getPrintMarginColumn();
    };
    this.setReadOnly = function (readOnly) {
      this.setOption('readOnly', readOnly);
    };
    this.getReadOnly = function () {
      return this.getOption('readOnly');
    };
    this.setBehavioursEnabled = function (enabled) {
      this.setOption('behavioursEnabled', enabled);
    };
    this.getBehavioursEnabled = function () {
      return this.getOption('behavioursEnabled');
    };
    this.setWrapBehavioursEnabled = function (enabled) {
      this.setOption('wrapBehavioursEnabled', enabled);
    };
    this.getWrapBehavioursEnabled = function () {
      return this.getOption('wrapBehavioursEnabled');
    };
    this.setShowFoldWidgets = function (show) {
      this.setOption('showFoldWidgets', show);
    };
    this.getShowFoldWidgets = function () {
      return this.getOption('showFoldWidgets');
    };
    this.setFadeFoldWidgets = function (fade) {
      this.setOption('fadeFoldWidgets', fade);
    };
    this.getFadeFoldWidgets = function () {
      return this.getOption('fadeFoldWidgets');
    };
    this.remove = function (dir) {
      if (this.selection.isEmpty()) {
        if (dir == 'left')
          this.selection.selectLeft();
        else
          this.selection.selectRight();
      }
      var range = this.getSelectionRange();
      if (this.getBehavioursEnabled()) {
        var session = this.session;
        var state = session.getState(range.start.row);
        var new_range = session.getMode().transformAction(state, 'deletion', this, session, range);
        if (range.end.column === 0) {
          var text = session.getTextRange(range);
          if (text[text.length - 1] == '\n') {
            var line = session.getLine(range.end.row);
            if (/^\s+$/.test(line)) {
              range.end.column = line.length;
            }
          }
        }
        if (new_range)
          range = new_range;
      }
      this.session.remove(range);
      this.clearSelection();
    };
    this.removeWordRight = function () {
      if (this.selection.isEmpty())
        this.selection.selectWordRight();
      this.session.remove(this.getSelectionRange());
      this.clearSelection();
    };
    this.removeWordLeft = function () {
      if (this.selection.isEmpty())
        this.selection.selectWordLeft();
      this.session.remove(this.getSelectionRange());
      this.clearSelection();
    };
    this.removeToLineStart = function () {
      if (this.selection.isEmpty())
        this.selection.selectLineStart();
      this.session.remove(this.getSelectionRange());
      this.clearSelection();
    };
    this.removeToLineEnd = function () {
      if (this.selection.isEmpty())
        this.selection.selectLineEnd();
      var range = this.getSelectionRange();
      if (range.start.column == range.end.column && range.start.row == range.end.row) {
        range.end.column = 0;
        range.end.row++;
      }
      this.session.remove(range);
      this.clearSelection();
    };
    this.splitLine = function () {
      if (!this.selection.isEmpty()) {
        this.session.remove(this.getSelectionRange());
        this.clearSelection();
      }
      var cursor = this.getCursorPosition();
      this.insert('\n');
      this.moveCursorToPosition(cursor);
    };
    this.transposeLetters = function () {
      if (!this.selection.isEmpty()) {
        return;
      }
      var cursor = this.getCursorPosition();
      var column = cursor.column;
      if (column === 0)
        return;
      var line = this.session.getLine(cursor.row);
      var swap, range;
      if (column < line.length) {
        swap = line.charAt(column) + line.charAt(column - 1);
        range = new Range(cursor.row, column - 1, cursor.row, column + 1);
      } else {
        swap = line.charAt(column - 1) + line.charAt(column - 2);
        range = new Range(cursor.row, column - 2, cursor.row, column);
      }
      this.session.replace(range, swap);
    };
    this.toLowerCase = function () {
      var originalRange = this.getSelectionRange();
      if (this.selection.isEmpty()) {
        this.selection.selectWord();
      }
      var range = this.getSelectionRange();
      var text = this.session.getTextRange(range);
      this.session.replace(range, text.toLowerCase());
      this.selection.setSelectionRange(originalRange);
    };
    this.toUpperCase = function () {
      var originalRange = this.getSelectionRange();
      if (this.selection.isEmpty()) {
        this.selection.selectWord();
      }
      var range = this.getSelectionRange();
      var text = this.session.getTextRange(range);
      this.session.replace(range, text.toUpperCase());
      this.selection.setSelectionRange(originalRange);
    };
    this.indent = function () {
      var session = this.session;
      var range = this.getSelectionRange();
      if (range.start.row < range.end.row) {
        var rows = this.$getSelectedRows();
        session.indentRows(rows.first, rows.last, '\t');
        return;
      } else if (range.start.column < range.end.column) {
        var text = session.getTextRange(range);
        if (!/^\s+$/.test(text)) {
          var rows = this.$getSelectedRows();
          session.indentRows(rows.first, rows.last, '\t');
          return;
        }
      }
      var line = session.getLine(range.start.row);
      var position = range.start;
      var size = session.getTabSize();
      var column = session.documentToScreenColumn(position.row, position.column);
      if (this.session.getUseSoftTabs()) {
        var count = size - column % size;
        var indentString = lang.stringRepeat(' ', count);
      } else {
        var count = column % size;
        while (line[range.start.column] == ' ' && count) {
          range.start.column--;
          count--;
        }
        this.selection.setSelectionRange(range);
        indentString = '\t';
      }
      return this.insert(indentString);
    };
    this.blockIndent = function () {
      var rows = this.$getSelectedRows();
      this.session.indentRows(rows.first, rows.last, '\t');
    };
    this.blockOutdent = function () {
      var selection = this.session.getSelection();
      this.session.outdentRows(selection.getRange());
    };
    this.sortLines = function () {
      var rows = this.$getSelectedRows();
      var session = this.session;
      var lines = [];
      for (i = rows.first; i <= rows.last; i++)
        lines.push(session.getLine(i));
      lines.sort(function (a, b) {
        if (a.toLowerCase() < b.toLowerCase())
          return -1;
        if (a.toLowerCase() > b.toLowerCase())
          return 1;
        return 0;
      });
      var deleteRange = new Range(0, 0, 0, 0);
      for (var i = rows.first; i <= rows.last; i++) {
        var line = session.getLine(i);
        deleteRange.start.row = i;
        deleteRange.end.row = i;
        deleteRange.end.column = line.length;
        session.replace(deleteRange, lines[i - rows.first]);
      }
    };
    this.toggleCommentLines = function () {
      var state = this.session.getState(this.getCursorPosition().row);
      var rows = this.$getSelectedRows();
      this.session.getMode().toggleCommentLines(state, this.session, rows.first, rows.last);
    };
    this.toggleBlockComment = function () {
      var cursor = this.getCursorPosition();
      var state = this.session.getState(cursor.row);
      var range = this.getSelectionRange();
      this.session.getMode().toggleBlockComment(state, this.session, range, cursor);
    };
    this.getNumberAt = function (row, column) {
      var _numberRx = /[\-]?[0-9]+(?:\.[0-9]+)?/g;
      _numberRx.lastIndex = 0;
      var s = this.session.getLine(row);
      while (_numberRx.lastIndex < column) {
        var m = _numberRx.exec(s);
        if (m.index <= column && m.index + m[0].length >= column) {
          var number = {
              value: m[0],
              start: m.index,
              end: m.index + m[0].length
            };
          return number;
        }
      }
      return null;
    };
    this.modifyNumber = function (amount) {
      var row = this.selection.getCursor().row;
      var column = this.selection.getCursor().column;
      var charRange = new Range(row, column - 1, row, column);
      var c = this.session.getTextRange(charRange);
      if (!isNaN(parseFloat(c)) && isFinite(c)) {
        var nr = this.getNumberAt(row, column);
        if (nr) {
          var fp = nr.value.indexOf('.') >= 0 ? nr.start + nr.value.indexOf('.') + 1 : nr.end;
          var decimals = nr.start + nr.value.length - fp;
          var t = parseFloat(nr.value);
          t *= Math.pow(10, decimals);
          if (fp !== nr.end && column < fp) {
            amount *= Math.pow(10, nr.end - column - 1);
          } else {
            amount *= Math.pow(10, nr.end - column);
          }
          t += amount;
          t /= Math.pow(10, decimals);
          var nnr = t.toFixed(decimals);
          var replaceRange = new Range(row, nr.start, row, nr.end);
          this.session.replace(replaceRange, nnr);
          this.moveCursorTo(row, Math.max(nr.start + 1, column + nnr.length - nr.value.length));
        }
      }
    };
    this.removeLines = function () {
      var rows = this.$getSelectedRows();
      var range;
      if (rows.first === 0 || rows.last + 1 < this.session.getLength())
        range = new Range(rows.first, 0, rows.last + 1, 0);
      else
        range = new Range(rows.first - 1, this.session.getLine(rows.first - 1).length, rows.last, this.session.getLine(rows.last).length);
      this.session.remove(range);
      this.clearSelection();
    };
    this.duplicateSelection = function () {
      var sel = this.selection;
      var doc = this.session;
      var range = sel.getRange();
      var reverse = sel.isBackwards();
      if (range.isEmpty()) {
        var row = range.start.row;
        doc.duplicateLines(row, row);
      } else {
        var point = reverse ? range.start : range.end;
        var endPoint = doc.insert(point, doc.getTextRange(range), false);
        range.start = point;
        range.end = endPoint;
        sel.setSelectionRange(range, reverse);
      }
    };
    this.moveLinesDown = function () {
      this.$moveLines(function (firstRow, lastRow) {
        return this.session.moveLinesDown(firstRow, lastRow);
      });
    };
    this.moveLinesUp = function () {
      this.$moveLines(function (firstRow, lastRow) {
        return this.session.moveLinesUp(firstRow, lastRow);
      });
    };
    this.moveText = function (range, toPosition, copy) {
      return this.session.moveText(range, toPosition, copy);
    };
    this.copyLinesUp = function () {
      this.$moveLines(function (firstRow, lastRow) {
        this.session.duplicateLines(firstRow, lastRow);
        return 0;
      });
    };
    this.copyLinesDown = function () {
      this.$moveLines(function (firstRow, lastRow) {
        return this.session.duplicateLines(firstRow, lastRow);
      });
    };
    this.$moveLines = function (mover) {
      var selection = this.selection;
      if (!selection.inMultiSelectMode || this.inVirtualSelectionMode) {
        var range = selection.toOrientedRange();
        var rows = this.$getSelectedRows(range);
        var linesMoved = mover.call(this, rows.first, rows.last);
        range.moveBy(linesMoved, 0);
        selection.fromOrientedRange(range);
      } else {
        var ranges = selection.rangeList.ranges;
        selection.rangeList.detach(this.session);
        for (var i = ranges.length; i--;) {
          var rangeIndex = i;
          var rows = ranges[i].collapseRows();
          var last = rows.end.row;
          var first = rows.start.row;
          while (i--) {
            rows = ranges[i].collapseRows();
            if (first - rows.end.row <= 1)
              first = rows.end.row;
            else
              break;
          }
          i++;
          var linesMoved = mover.call(this, first, last);
          while (rangeIndex >= i) {
            ranges[rangeIndex].moveBy(linesMoved, 0);
            rangeIndex--;
          }
        }
        selection.fromOrientedRange(selection.ranges[0]);
        selection.rangeList.attach(this.session);
      }
    };
    this.$getSelectedRows = function () {
      var range = this.getSelectionRange().collapseRows();
      return {
        first: this.session.getRowFoldStart(range.start.row),
        last: this.session.getRowFoldEnd(range.end.row)
      };
    };
    this.onCompositionStart = function (text) {
      this.renderer.showComposition(this.getCursorPosition());
    };
    this.onCompositionUpdate = function (text) {
      this.renderer.setCompositionText(text);
    };
    this.onCompositionEnd = function () {
      this.renderer.hideComposition();
    };
    this.getFirstVisibleRow = function () {
      return this.renderer.getFirstVisibleRow();
    };
    this.getLastVisibleRow = function () {
      return this.renderer.getLastVisibleRow();
    };
    this.isRowVisible = function (row) {
      return row >= this.getFirstVisibleRow() && row <= this.getLastVisibleRow();
    };
    this.isRowFullyVisible = function (row) {
      return row >= this.renderer.getFirstFullyVisibleRow() && row <= this.renderer.getLastFullyVisibleRow();
    };
    this.$getVisibleRowCount = function () {
      return this.renderer.getScrollBottomRow() - this.renderer.getScrollTopRow() + 1;
    };
    this.$moveByPage = function (dir, select) {
      var renderer = this.renderer;
      var config = this.renderer.layerConfig;
      var rows = dir * Math.floor(config.height / config.lineHeight);
      this.$blockScrolling++;
      if (select === true) {
        this.selection.$moveSelection(function () {
          this.moveCursorBy(rows, 0);
        });
      } else if (select === false) {
        this.selection.moveCursorBy(rows, 0);
        this.selection.clearSelection();
      }
      this.$blockScrolling--;
      var scrollTop = renderer.scrollTop;
      renderer.scrollBy(0, rows * config.lineHeight);
      if (select != null)
        renderer.scrollCursorIntoView(null, 0.5);
      renderer.animateScrolling(scrollTop);
    };
    this.selectPageDown = function () {
      this.$moveByPage(1, true);
    };
    this.selectPageUp = function () {
      this.$moveByPage(-1, true);
    };
    this.gotoPageDown = function () {
      this.$moveByPage(1, false);
    };
    this.gotoPageUp = function () {
      this.$moveByPage(-1, false);
    };
    this.scrollPageDown = function () {
      this.$moveByPage(1);
    };
    this.scrollPageUp = function () {
      this.$moveByPage(-1);
    };
    this.scrollToRow = function (row) {
      this.renderer.scrollToRow(row);
    };
    this.scrollToLine = function (line, center, animate, callback) {
      this.renderer.scrollToLine(line, center, animate, callback);
    };
    this.centerSelection = function () {
      var range = this.getSelectionRange();
      var pos = {
          row: Math.floor(range.start.row + (range.end.row - range.start.row) / 2),
          column: Math.floor(range.start.column + (range.end.column - range.start.column) / 2)
        };
      this.renderer.alignCursor(pos, 0.5);
    };
    this.getCursorPosition = function () {
      return this.selection.getCursor();
    };
    this.getCursorPositionScreen = function () {
      return this.session.documentToScreenPosition(this.getCursorPosition());
    };
    this.getSelectionRange = function () {
      return this.selection.getRange();
    };
    this.selectAll = function () {
      this.$blockScrolling += 1;
      this.selection.selectAll();
      this.$blockScrolling -= 1;
    };
    this.clearSelection = function () {
      this.selection.clearSelection();
    };
    this.moveCursorTo = function (row, column) {
      this.selection.moveCursorTo(row, column);
    };
    this.moveCursorToPosition = function (pos) {
      this.selection.moveCursorToPosition(pos);
    };
    this.jumpToMatching = function (select) {
      var cursor = this.getCursorPosition();
      var range = this.session.getBracketRange(cursor);
      if (!range) {
        range = this.find({
          needle: /[{}()\[\]]/g,
          preventScroll: true,
          start: {
            row: cursor.row,
            column: cursor.column - 1
          }
        });
        if (!range)
          return;
        var pos = range.start;
        if (pos.row == cursor.row && Math.abs(pos.column - cursor.column) < 2)
          range = this.session.getBracketRange(pos);
      }
      pos = range && range.cursor || pos;
      if (pos) {
        if (select) {
          if (range && range.isEqual(this.getSelectionRange()))
            this.clearSelection();
          else
            this.selection.selectTo(pos.row, pos.column);
        } else {
          this.selection.moveTo(pos.row, pos.column);
        }
      }
    };
    this.gotoLine = function (lineNumber, column, animate) {
      this.selection.clearSelection();
      this.session.unfold({
        row: lineNumber - 1,
        column: column || 0
      });
      this.$blockScrolling += 1;
      this.exitMultiSelectMode && this.exitMultiSelectMode();
      this.moveCursorTo(lineNumber - 1, column || 0);
      this.$blockScrolling -= 1;
      if (!this.isRowFullyVisible(lineNumber - 1))
        this.scrollToLine(lineNumber - 1, true, animate);
    };
    this.navigateTo = function (row, column) {
      this.selection.moveTo(row, column);
    };
    this.navigateUp = function (times) {
      if (this.selection.isMultiLine() && !this.selection.isBackwards()) {
        var selectionStart = this.selection.anchor.getPosition();
        return this.moveCursorToPosition(selectionStart);
      }
      this.selection.clearSelection();
      this.selection.moveCursorBy(-times || -1, 0);
    };
    this.navigateDown = function (times) {
      if (this.selection.isMultiLine() && this.selection.isBackwards()) {
        var selectionEnd = this.selection.anchor.getPosition();
        return this.moveCursorToPosition(selectionEnd);
      }
      this.selection.clearSelection();
      this.selection.moveCursorBy(times || 1, 0);
    };
    this.navigateLeft = function (times) {
      if (!this.selection.isEmpty()) {
        var selectionStart = this.getSelectionRange().start;
        this.moveCursorToPosition(selectionStart);
      } else {
        times = times || 1;
        while (times--) {
          this.selection.moveCursorLeft();
        }
      }
      this.clearSelection();
    };
    this.navigateRight = function (times) {
      if (!this.selection.isEmpty()) {
        var selectionEnd = this.getSelectionRange().end;
        this.moveCursorToPosition(selectionEnd);
      } else {
        times = times || 1;
        while (times--) {
          this.selection.moveCursorRight();
        }
      }
      this.clearSelection();
    };
    this.navigateLineStart = function () {
      this.selection.moveCursorLineStart();
      this.clearSelection();
    };
    this.navigateLineEnd = function () {
      this.selection.moveCursorLineEnd();
      this.clearSelection();
    };
    this.navigateFileEnd = function () {
      this.selection.moveCursorFileEnd();
      this.clearSelection();
    };
    this.navigateFileStart = function () {
      this.selection.moveCursorFileStart();
      this.clearSelection();
    };
    this.navigateWordRight = function () {
      this.selection.moveCursorWordRight();
      this.clearSelection();
    };
    this.navigateWordLeft = function () {
      this.selection.moveCursorWordLeft();
      this.clearSelection();
    };
    this.replace = function (replacement, options) {
      if (options)
        this.$search.set(options);
      var range = this.$search.find(this.session);
      var replaced = 0;
      if (!range)
        return replaced;
      if (this.$tryReplace(range, replacement)) {
        replaced = 1;
      }
      if (range !== null) {
        this.selection.setSelectionRange(range);
        this.renderer.scrollSelectionIntoView(range.start, range.end);
      }
      return replaced;
    };
    this.replaceAll = function (replacement, options) {
      if (options) {
        this.$search.set(options);
      }
      var ranges = this.$search.findAll(this.session);
      var replaced = 0;
      if (!ranges.length)
        return replaced;
      this.$blockScrolling += 1;
      var selection = this.getSelectionRange();
      this.selection.moveTo(0, 0);
      for (var i = ranges.length - 1; i >= 0; --i) {
        if (this.$tryReplace(ranges[i], replacement)) {
          replaced++;
        }
      }
      this.selection.setSelectionRange(selection);
      this.$blockScrolling -= 1;
      return replaced;
    };
    this.$tryReplace = function (range, replacement) {
      var input = this.session.getTextRange(range);
      replacement = this.$search.replace(input, replacement);
      if (replacement !== null) {
        range.end = this.session.replace(range, replacement);
        return range;
      } else {
        return null;
      }
    };
    this.getLastSearchOptions = function () {
      return this.$search.getOptions();
    };
    this.find = function (needle, options, animate) {
      if (!options)
        options = {};
      if (typeof needle == 'string' || needle instanceof RegExp)
        options.needle = needle;
      else if (typeof needle == 'object')
        oop.mixin(options, needle);
      var range = this.selection.getRange();
      if (options.needle == null) {
        needle = this.session.getTextRange(range) || this.$search.$options.needle;
        if (!needle) {
          range = this.session.getWordRange(range.start.row, range.start.column);
          needle = this.session.getTextRange(range);
        }
        this.$search.set({ needle: needle });
      }
      this.$search.set(options);
      if (!options.start)
        this.$search.set({ start: range });
      var newRange = this.$search.find(this.session);
      if (options.preventScroll)
        return newRange;
      if (newRange) {
        this.revealRange(newRange, animate);
        return newRange;
      }
      if (options.backwards)
        range.start = range.end;
      else
        range.end = range.start;
      this.selection.setRange(range);
    };
    this.findNext = function (options, animate) {
      this.find({
        skipCurrent: true,
        backwards: false
      }, options, animate);
    };
    this.findPrevious = function (options, animate) {
      this.find(options, {
        skipCurrent: true,
        backwards: true
      }, animate);
    };
    this.revealRange = function (range, animate) {
      this.$blockScrolling += 1;
      this.session.unfold(range);
      this.selection.setSelectionRange(range);
      this.$blockScrolling -= 1;
      var scrollTop = this.renderer.scrollTop;
      this.renderer.scrollSelectionIntoView(range.start, range.end, 0.5);
      if (animate !== false)
        this.renderer.animateScrolling(scrollTop);
    };
    this.undo = function () {
      this.$blockScrolling++;
      this.session.getUndoManager().undo();
      this.$blockScrolling--;
      this.renderer.scrollCursorIntoView(null, 0.5);
    };
    this.redo = function () {
      this.$blockScrolling++;
      this.session.getUndoManager().redo();
      this.$blockScrolling--;
      this.renderer.scrollCursorIntoView(null, 0.5);
    };
    this.destroy = function () {
      this.renderer.destroy();
      this._signal('destroy', this);
    };
    this.setAutoScrollEditorIntoView = function (enable) {
      if (!enable)
        return;
      var rect;
      var self = this;
      var shouldScroll = false;
      if (!this.$scrollAnchor)
        this.$scrollAnchor = document.createElement('div');
      var scrollAnchor = this.$scrollAnchor;
      scrollAnchor.style.cssText = 'position:absolute';
      this.container.insertBefore(scrollAnchor, this.container.firstChild);
      var onChangeSelection = this.on('changeSelection', function () {
          shouldScroll = true;
        });
      var onBeforeRender = this.renderer.on('beforeRender', function () {
          if (shouldScroll)
            rect = self.renderer.container.getBoundingClientRect();
        });
      var onAfterRender = this.renderer.on('afterRender', function () {
          if (shouldScroll && rect && self.isFocused()) {
            var renderer = self.renderer;
            var pos = renderer.$cursorLayer.$pixelPos;
            var config = renderer.layerConfig;
            var top = pos.top - config.offset;
            if (pos.top >= 0 && top + rect.top < 0) {
              shouldScroll = true;
            } else if (pos.top < config.height && pos.top + rect.top + config.lineHeight > window.innerHeight) {
              shouldScroll = false;
            } else {
              shouldScroll = null;
            }
            if (shouldScroll != null) {
              scrollAnchor.style.top = top + 'px';
              scrollAnchor.style.left = pos.left + 'px';
              scrollAnchor.style.height = config.lineHeight + 'px';
              scrollAnchor.scrollIntoView(shouldScroll);
            }
            shouldScroll = rect = null;
          }
        });
      this.setAutoScrollEditorIntoView = function (enable) {
        if (enable)
          return;
        delete this.setAutoScrollEditorIntoView;
        this.removeEventListener('changeSelection', onChangeSelection);
        this.renderer.removeEventListener('afterRender', onAfterRender);
        this.renderer.removeEventListener('beforeRender', onBeforeRender);
      };
    };
    this.$resetCursorStyle = function () {
      var style = this.$cursorStyle || 'ace';
      var cursorLayer = this.renderer.$cursorLayer;
      if (!cursorLayer)
        return;
      cursorLayer.setSmoothBlinking(style == 'smooth');
      cursorLayer.isBlinking = !this.$readOnly && style != 'wide';
    };
  }.call(Editor.prototype));
  config.defineOptions(Editor.prototype, 'editor', {
    selectionStyle: {
      set: function (style) {
        this.onSelectionChange();
        this._signal('changeSelectionStyle', { data: style });
      },
      initialValue: 'line'
    },
    highlightActiveLine: {
      set: function () {
        this.$updateHighlightActiveLine();
      },
      initialValue: true
    },
    highlightSelectedWord: {
      set: function (shouldHighlight) {
        this.$onSelectionChange();
      },
      initialValue: true
    },
    readOnly: {
      set: function (readOnly) {
        this.textInput.setReadOnly(readOnly);
        this.$resetCursorStyle();
      },
      initialValue: false
    },
    cursorStyle: {
      set: function (val) {
        this.$resetCursorStyle();
      },
      values: [
        'ace',
        'slim',
        'smooth',
        'wide'
      ],
      initialValue: 'ace'
    },
    mergeUndoDeltas: {
      values: [
        false,
        true,
        'always'
      ],
      initialValue: true
    },
    behavioursEnabled: { initialValue: true },
    wrapBehavioursEnabled: { initialValue: true },
    autoScrollEditorIntoView: {
      set: function (val) {
        this.setAutoScrollEditorIntoView(val);
      }
    },
    hScrollBarAlwaysVisible: 'renderer',
    vScrollBarAlwaysVisible: 'renderer',
    highlightGutterLine: 'renderer',
    animatedScroll: 'renderer',
    showInvisibles: 'renderer',
    showPrintMargin: 'renderer',
    printMarginColumn: 'renderer',
    printMargin: 'renderer',
    fadeFoldWidgets: 'renderer',
    showFoldWidgets: 'renderer',
    showLineNumbers: 'renderer',
    showGutter: 'renderer',
    displayIndentGuides: 'renderer',
    fontSize: 'renderer',
    fontFamily: 'renderer',
    maxLines: 'renderer',
    minLines: 'renderer',
    scrollPastEnd: 'renderer',
    fixedWidthGutter: 'renderer',
    theme: 'renderer',
    scrollSpeed: '$mouseHandler',
    dragDelay: '$mouseHandler',
    dragEnabled: '$mouseHandler',
    focusTimout: '$mouseHandler',
    tooltipFollowsMouse: '$mouseHandler',
    firstLineNumber: 'session',
    overwrite: 'session',
    newLineMode: 'session',
    useWorker: 'session',
    useSoftTabs: 'session',
    tabSize: 'session',
    wrap: 'session',
    foldStyle: 'session',
    mode: 'session'
  });
  exports.Editor = Editor;
});
ace.define('ace/mouse/multi_select_handler', [
  'require',
  'exports',
  'module',
  'ace/lib/event'
], function (require, exports, module) {
  var event = require('../lib/event');
  function isSamePoint(p1, p2) {
    return p1.row == p2.row && p1.column == p2.column;
  }
  function onMouseDown(e) {
    var ev = e.domEvent;
    var alt = ev.altKey;
    var shift = ev.shiftKey;
    var ctrl = e.getAccelKey();
    var button = e.getButton();
    if (e.editor.inMultiSelectMode && button == 2) {
      e.editor.textInput.onContextMenu(e.domEvent);
      return;
    }
    if (!ctrl && !alt) {
      if (button === 0 && e.editor.inMultiSelectMode)
        e.editor.exitMultiSelectMode();
      return;
    }
    var editor = e.editor;
    var selection = editor.selection;
    var isMultiSelect = editor.inMultiSelectMode;
    var pos = e.getDocumentPosition();
    var cursor = selection.getCursor();
    var inSelection = e.inSelection() || selection.isEmpty() && isSamePoint(pos, cursor);
    var mouseX = e.x, mouseY = e.y;
    var onMouseSelection = function (e) {
      mouseX = e.clientX;
      mouseY = e.clientY;
    };
    var blockSelect = function () {
      var newCursor = editor.renderer.pixelToScreenCoordinates(mouseX, mouseY);
      var cursor = session.screenToDocumentPosition(newCursor.row, newCursor.column);
      if (isSamePoint(screenCursor, newCursor) && isSamePoint(cursor, selection.selectionLead))
        return;
      screenCursor = newCursor;
      editor.selection.moveToPosition(cursor);
      editor.renderer.scrollCursorIntoView();
      editor.removeSelectionMarkers(rectSel);
      rectSel = selection.rectangularRangeBlock(screenCursor, screenAnchor);
      rectSel.forEach(editor.addSelectionMarker, editor);
      editor.updateSelectionMarkers();
    };
    var session = editor.session;
    var screenAnchor = editor.renderer.pixelToScreenCoordinates(mouseX, mouseY);
    var screenCursor = screenAnchor;
    if (ctrl && !alt && !shift && button === 0) {
      if (!isMultiSelect && inSelection)
        return;
      if (!isMultiSelect) {
        var range = selection.toOrientedRange();
        editor.addSelectionMarker(range);
      }
      var oldRange = selection.rangeList.rangeAtPoint(pos);
      editor.$blockScrolling++;
      editor.once('mouseup', function () {
        var tmpSel = selection.toOrientedRange();
        if (oldRange && tmpSel.isEmpty() && isSamePoint(oldRange.cursor, tmpSel.cursor))
          selection.substractPoint(tmpSel.cursor);
        else {
          if (range) {
            editor.removeSelectionMarker(range);
            selection.addRange(range);
          }
          selection.addRange(tmpSel);
        }
        editor.$blockScrolling--;
      });
    } else if (alt && button === 0) {
      e.stop();
      if (isMultiSelect && !ctrl)
        selection.toSingleRange();
      else if (!isMultiSelect && ctrl)
        selection.addRange();
      var rectSel = [];
      if (shift) {
        screenAnchor = session.documentToScreenPosition(selection.lead);
        blockSelect();
      } else {
        selection.moveToPosition(pos);
      }
      var onMouseSelectionEnd = function (e) {
        clearInterval(timerId);
        editor.removeSelectionMarkers(rectSel);
        for (var i = 0; i < rectSel.length; i++)
          selection.addRange(rectSel[i]);
      };
      var onSelectionInterval = blockSelect;
      event.capture(editor.container, onMouseSelection, onMouseSelectionEnd);
      var timerId = setInterval(function () {
          onSelectionInterval();
        }, 20);
      return e.preventDefault();
    }
  }
  exports.onMouseDown = onMouseDown;
});
ace.define('ace/lib/useragent', [
  'require',
  'exports',
  'module'
], function (require, exports, module) {
  exports.OS = {
    LINUX: 'LINUX',
    MAC: 'MAC',
    WINDOWS: 'WINDOWS'
  };
  exports.getOS = function () {
    if (exports.isMac) {
      return exports.OS.MAC;
    } else if (exports.isLinux) {
      return exports.OS.LINUX;
    } else {
      return exports.OS.WINDOWS;
    }
  };
  if (typeof navigator != 'object')
    return;
  var os = (navigator.platform.match(/mac|win|linux/i) || ['other'])[0].toLowerCase();
  var ua = navigator.userAgent;
  exports.isWin = os == 'win';
  exports.isMac = os == 'mac';
  exports.isLinux = os == 'linux';
  exports.isIE = (navigator.appName == 'Microsoft Internet Explorer' || navigator.appName.indexOf('MSAppHost') >= 0) && parseFloat(navigator.userAgent.match(/(?:Trident\/[0-9]+[\.0-9]+;.*rv:|MSIE )([0-9]+[\.0-9]+)/)[1]);
  exports.isOldIE = exports.isIE && exports.isIE < 9;
  exports.isGecko = exports.isMozilla = window.controllers && window.navigator.product === 'Gecko';
  exports.isOldGecko = exports.isGecko && parseInt((navigator.userAgent.match(/rv\:(\d+)/) || [])[1], 10) < 4;
  exports.isOpera = window.opera && Object.prototype.toString.call(window.opera) == '[object Opera]';
  exports.isWebKit = parseFloat(ua.split('WebKit/')[1]) || undefined;
  exports.isChrome = parseFloat(ua.split(' Chrome/')[1]) || undefined;
  exports.isAIR = ua.indexOf('AdobeAIR') >= 0;
  exports.isIPad = ua.indexOf('iPad') >= 0;
  exports.isTouchPad = ua.indexOf('TouchPad') >= 0;
});
ace.define('ace/commands/multi_select_commands', [
  'require',
  'exports',
  'module',
  'ace/keyboard/hash_handler'
], function (require, exports, module) {
  exports.defaultCommands = [
    {
      name: 'addCursorAbove',
      exec: function (editor) {
        editor.selectMoreLines(-1);
      },
      bindKey: {
        win: 'Ctrl-Alt-Up',
        mac: 'Ctrl-Alt-Up'
      },
      readonly: true
    },
    {
      name: 'addCursorBelow',
      exec: function (editor) {
        editor.selectMoreLines(1);
      },
      bindKey: {
        win: 'Ctrl-Alt-Down',
        mac: 'Ctrl-Alt-Down'
      },
      readonly: true
    },
    {
      name: 'addCursorAboveSkipCurrent',
      exec: function (editor) {
        editor.selectMoreLines(-1, true);
      },
      bindKey: {
        win: 'Ctrl-Alt-Shift-Up',
        mac: 'Ctrl-Alt-Shift-Up'
      },
      readonly: true
    },
    {
      name: 'addCursorBelowSkipCurrent',
      exec: function (editor) {
        editor.selectMoreLines(1, true);
      },
      bindKey: {
        win: 'Ctrl-Alt-Shift-Down',
        mac: 'Ctrl-Alt-Shift-Down'
      },
      readonly: true
    },
    {
      name: 'selectMoreBefore',
      exec: function (editor) {
        editor.selectMore(-1);
      },
      bindKey: {
        win: 'Ctrl-Alt-Left',
        mac: 'Ctrl-Alt-Left'
      },
      readonly: true
    },
    {
      name: 'selectMoreAfter',
      exec: function (editor) {
        editor.selectMore(1);
      },
      bindKey: {
        win: 'Ctrl-Alt-Right',
        mac: 'Ctrl-Alt-Right'
      },
      readonly: true
    },
    {
      name: 'selectNextBefore',
      exec: function (editor) {
        editor.selectMore(-1, true);
      },
      bindKey: {
        win: 'Ctrl-Alt-Shift-Left',
        mac: 'Ctrl-Alt-Shift-Left'
      },
      readonly: true
    },
    {
      name: 'selectNextAfter',
      exec: function (editor) {
        editor.selectMore(1, true);
      },
      bindKey: {
        win: 'Ctrl-Alt-Shift-Right',
        mac: 'Ctrl-Alt-Shift-Right'
      },
      readonly: true
    },
    {
      name: 'splitIntoLines',
      exec: function (editor) {
        editor.multiSelect.splitIntoLines();
      },
      bindKey: {
        win: 'Ctrl-Alt-L',
        mac: 'Ctrl-Alt-L'
      },
      readonly: true
    },
    {
      name: 'alignCursors',
      exec: function (editor) {
        editor.alignCursors();
      },
      bindKey: {
        win: 'Ctrl-Alt-A',
        mac: 'Ctrl-Alt-A'
      }
    }
  ];
  exports.multiSelectCommands = [{
      name: 'singleSelection',
      bindKey: 'esc',
      exec: function (editor) {
        editor.exitMultiSelectMode();
      },
      readonly: true,
      isAvailable: function (editor) {
        return editor && editor.inMultiSelectMode;
      }
    }];
  var HashHandler = require('../keyboard/hash_handler').HashHandler;
  exports.keyboardHandler = new HashHandler(exports.multiSelectCommands);
});
ace.define('ace/lib/oop', [
  'require',
  'exports',
  'module'
], function (require, exports, module) {
  exports.inherits = function (ctor, superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
  exports.mixin = function (obj, mixin) {
    for (var key in mixin) {
      obj[key] = mixin[key];
    }
    return obj;
  };
  exports.implement = function (proto, mixin) {
    exports.mixin(proto, mixin);
  };
});
ace.define('ace/worker/worker_client', [
  'require',
  'exports',
  'module',
  'ace/lib/oop',
  'ace/lib/event_emitter',
  'ace/config'
], function (require, exports, module) {
  var oop = require('../lib/oop');
  var EventEmitter = require('../lib/event_emitter').EventEmitter;
  var config = require('../config');
  var WorkerClient = function (topLevelNamespaces, mod, classname, workerUrl) {
    this.$sendDeltaQueue = this.$sendDeltaQueue.bind(this);
    this.changeListener = this.changeListener.bind(this);
    this.onMessage = this.onMessage.bind(this);
    if (require.nameToUrl && !require.toUrl)
      require.toUrl = require.nameToUrl;
    if (config.get('packaged') || !require.toUrl) {
      workerUrl = workerUrl || config.moduleUrl(mod, 'worker');
    } else {
      var normalizePath = this.$normalizePath;
      workerUrl = workerUrl || normalizePath(require.toUrl('ace/worker/worker.js', null, '_'));
      var tlns = {};
      topLevelNamespaces.forEach(function (ns) {
        tlns[ns] = normalizePath(require.toUrl(ns, null, '_').replace(/(\.js)?(\?.*)?$/, ''));
      });
    }
    try {
      this.$worker = new Worker(workerUrl);
    } catch (e) {
      if (e instanceof window.DOMException) {
        var blob = this.$workerBlob(workerUrl);
        var URL = window.URL || window.webkitURL;
        var blobURL = URL.createObjectURL(blob);
        this.$worker = new Worker(blobURL);
        URL.revokeObjectURL(blobURL);
      } else {
        throw e;
      }
    }
    this.$worker.postMessage({
      init: true,
      tlns: tlns,
      module: mod,
      classname: classname
    });
    this.callbackId = 1;
    this.callbacks = {};
    this.$worker.onmessage = this.onMessage;
  };
  (function () {
    oop.implement(this, EventEmitter);
    this.onMessage = function (e) {
      var msg = e.data;
      switch (msg.type) {
      case 'log':
        window.console && console.log && console.log.apply(console, msg.data);
        break;
      case 'event':
        this._signal(msg.name, { data: msg.data });
        break;
      case 'call':
        var callback = this.callbacks[msg.id];
        if (callback) {
          callback(msg.data);
          delete this.callbacks[msg.id];
        }
        break;
      }
    };
    this.$normalizePath = function (path) {
      if (!location.host)
        return path;
      path = path.replace(/^[a-z]+:\/\/[^\/]+/, '');
      path = location.protocol + '//' + location.host + (path.charAt(0) == '/' ? '' : location.pathname.replace(/\/[^\/]*$/, '')) + '/' + path.replace(/^[\/]+/, '');
      return path;
    };
    this.terminate = function () {
      this._signal('terminate', {});
      this.deltaQueue = null;
      this.$worker.terminate();
      this.$worker = null;
      this.$doc.removeEventListener('change', this.changeListener);
      this.$doc = null;
    };
    this.send = function (cmd, args) {
      this.$worker.postMessage({
        command: cmd,
        args: args
      });
    };
    this.call = function (cmd, args, callback) {
      if (callback) {
        var id = this.callbackId++;
        this.callbacks[id] = callback;
        args.push(id);
      }
      this.send(cmd, args);
    };
    this.emit = function (event, data) {
      try {
        this.$worker.postMessage({
          event: event,
          data: { data: data.data }
        });
      } catch (ex) {
      }
    };
    this.attachToDocument = function (doc) {
      if (this.$doc)
        this.terminate();
      this.$doc = doc;
      this.call('setValue', [doc.getValue()]);
      doc.on('change', this.changeListener);
    };
    this.changeListener = function (e) {
      if (!this.deltaQueue) {
        this.deltaQueue = [e.data];
        setTimeout(this.$sendDeltaQueue, 0);
      } else
        this.deltaQueue.push(e.data);
    };
    this.$sendDeltaQueue = function () {
      var q = this.deltaQueue;
      if (!q)
        return;
      this.deltaQueue = null;
      if (q.length > 20 && q.length > this.$doc.getLength() >> 1) {
        this.call('setValue', [this.$doc.getValue()]);
      } else
        this.emit('change', { data: q });
    };
    this.$workerBlob = function (workerUrl) {
      var script = 'importScripts(\'' + workerUrl + '\');';
      try {
        return new Blob([script], { 'type': 'application/javascript' });
      } catch (e) {
        var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder;
        var blobBuilder = new BlobBuilder();
        blobBuilder.append(script);
        return blobBuilder.getBlob('application/javascript');
      }
    };
  }.call(WorkerClient.prototype));
  var UIWorkerClient = function (topLevelNamespaces, mod, classname) {
    this.$sendDeltaQueue = this.$sendDeltaQueue.bind(this);
    this.changeListener = this.changeListener.bind(this);
    this.callbackId = 1;
    this.callbacks = {};
    this.messageBuffer = [];
    var main = null;
    var emitSync = false;
    var sender = Object.create(EventEmitter);
    var _self = this;
    this.$worker = {};
    this.$worker.terminate = function () {
    };
    this.$worker.postMessage = function (e) {
      _self.messageBuffer.push(e);
      if (main) {
        if (emitSync)
          setTimeout(processNext);
        else
          processNext();
      }
    };
    this.setEmitSync = function (val) {
      emitSync = val;
    };
    var processNext = function () {
      var msg = _self.messageBuffer.shift();
      if (msg.command)
        main[msg.command].apply(main, msg.args);
      else if (msg.event)
        sender._signal(msg.event, msg.data);
    };
    sender.postMessage = function (msg) {
      _self.onMessage({ data: msg });
    };
    sender.callback = function (data, callbackId) {
      this.postMessage({
        type: 'call',
        id: callbackId,
        data: data
      });
    };
    sender.emit = function (name, data) {
      this.postMessage({
        type: 'event',
        name: name,
        data: data
      });
    };
    config.loadModule([
      'worker',
      mod
    ], function (Main) {
      main = new Main[classname](sender);
      while (_self.messageBuffer.length)
        processNext();
    });
  };
  UIWorkerClient.prototype = WorkerClient.prototype;
  exports.UIWorkerClient = UIWorkerClient;
  exports.WorkerClient = WorkerClient;
});
ace.define('ace/lib/keys', [
  'require',
  'exports',
  'module',
  'ace/lib/oop'
], function (require, exports, module) {
  var oop = require('./oop');
  var Keys = function () {
      var ret = {
          MODIFIER_KEYS: {
            16: 'Shift',
            17: 'Ctrl',
            18: 'Alt',
            224: 'Meta'
          },
          KEY_MODS: {
            'ctrl': 1,
            'alt': 2,
            'option': 2,
            'shift': 4,
            'super': 8,
            'meta': 8,
            'command': 8,
            'cmd': 8
          },
          FUNCTION_KEYS: {
            8: 'Backspace',
            9: 'Tab',
            13: 'Return',
            19: 'Pause',
            27: 'Esc',
            32: 'Space',
            33: 'PageUp',
            34: 'PageDown',
            35: 'End',
            36: 'Home',
            37: 'Left',
            38: 'Up',
            39: 'Right',
            40: 'Down',
            44: 'Print',
            45: 'Insert',
            46: 'Delete',
            96: 'Numpad0',
            97: 'Numpad1',
            98: 'Numpad2',
            99: 'Numpad3',
            100: 'Numpad4',
            101: 'Numpad5',
            102: 'Numpad6',
            103: 'Numpad7',
            104: 'Numpad8',
            105: 'Numpad9',
            '-13': 'NumpadEnter',
            112: 'F1',
            113: 'F2',
            114: 'F3',
            115: 'F4',
            116: 'F5',
            117: 'F6',
            118: 'F7',
            119: 'F8',
            120: 'F9',
            121: 'F10',
            122: 'F11',
            123: 'F12',
            144: 'Numlock',
            145: 'Scrolllock'
          },
          PRINTABLE_KEYS: {
            32: ' ',
            48: '0',
            49: '1',
            50: '2',
            51: '3',
            52: '4',
            53: '5',
            54: '6',
            55: '7',
            56: '8',
            57: '9',
            59: ';',
            61: '=',
            65: 'a',
            66: 'b',
            67: 'c',
            68: 'd',
            69: 'e',
            70: 'f',
            71: 'g',
            72: 'h',
            73: 'i',
            74: 'j',
            75: 'k',
            76: 'l',
            77: 'm',
            78: 'n',
            79: 'o',
            80: 'p',
            81: 'q',
            82: 'r',
            83: 's',
            84: 't',
            85: 'u',
            86: 'v',
            87: 'w',
            88: 'x',
            89: 'y',
            90: 'z',
            107: '+',
            109: '-',
            110: '.',
            188: ',',
            190: '.',
            191: '/',
            192: '`',
            219: '[',
            220: '\\',
            221: ']',
            222: '\''
          }
        };
      var name, i;
      for (i in ret.FUNCTION_KEYS) {
        name = ret.FUNCTION_KEYS[i].toLowerCase();
        ret[name] = parseInt(i, 10);
      }
      for (i in ret.PRINTABLE_KEYS) {
        name = ret.PRINTABLE_KEYS[i].toLowerCase();
        ret[name] = parseInt(i, 10);
      }
      oop.mixin(ret, ret.MODIFIER_KEYS);
      oop.mixin(ret, ret.PRINTABLE_KEYS);
      oop.mixin(ret, ret.FUNCTION_KEYS);
      ret.enter = ret['return'];
      ret.escape = ret.esc;
      ret.del = ret['delete'];
      ret[173] = '-';
      (function () {
        var mods = [
            'cmd',
            'ctrl',
            'alt',
            'shift'
          ];
        for (var i = Math.pow(2, mods.length); i--;) {
          ret.KEY_MODS[i] = mods.filter(function (x) {
            return i & ret.KEY_MODS[x];
          }).join('-') + '-';
        }
      }());
      return ret;
    }();
  oop.mixin(exports, Keys);
  exports.keyCodeToString = function (keyCode) {
    return (Keys[keyCode] || String.fromCharCode(keyCode)).toLowerCase();
  };
});
ace.define('ace/placeholder', [
  'require',
  'exports',
  'module',
  'ace/range',
  'ace/lib/event_emitter',
  'ace/lib/oop'
], function (require, exports, module) {
  var Range = require('./range').Range;
  var EventEmitter = require('./lib/event_emitter').EventEmitter;
  var oop = require('./lib/oop');
  var PlaceHolder = function (session, length, pos, others, mainClass, othersClass) {
    var _self = this;
    this.length = length;
    this.session = session;
    this.doc = session.getDocument();
    this.mainClass = mainClass;
    this.othersClass = othersClass;
    this.$onUpdate = this.onUpdate.bind(this);
    this.doc.on('change', this.$onUpdate);
    this.$others = others;
    this.$onCursorChange = function () {
      setTimeout(function () {
        _self.onCursorChange();
      });
    };
    this.$pos = pos;
    var undoStack = session.getUndoManager().$undoStack || session.getUndoManager().$undostack || { length: -1 };
    this.$undoStackDepth = undoStack.length;
    this.setup();
    session.selection.on('changeCursor', this.$onCursorChange);
  };
  (function () {
    oop.implement(this, EventEmitter);
    this.setup = function () {
      var _self = this;
      var doc = this.doc;
      var session = this.session;
      var pos = this.$pos;
      this.pos = doc.createAnchor(pos.row, pos.column);
      this.markerId = session.addMarker(new Range(pos.row, pos.column, pos.row, pos.column + this.length), this.mainClass, null, false);
      this.pos.on('change', function (event) {
        session.removeMarker(_self.markerId);
        _self.markerId = session.addMarker(new Range(event.value.row, event.value.column, event.value.row, event.value.column + _self.length), _self.mainClass, null, false);
      });
      this.others = [];
      this.$others.forEach(function (other) {
        var anchor = doc.createAnchor(other.row, other.column);
        _self.others.push(anchor);
      });
      session.setUndoSelect(false);
    };
    this.showOtherMarkers = function () {
      if (this.othersActive)
        return;
      var session = this.session;
      var _self = this;
      this.othersActive = true;
      this.others.forEach(function (anchor) {
        anchor.markerId = session.addMarker(new Range(anchor.row, anchor.column, anchor.row, anchor.column + _self.length), _self.othersClass, null, false);
        anchor.on('change', function (event) {
          session.removeMarker(anchor.markerId);
          anchor.markerId = session.addMarker(new Range(event.value.row, event.value.column, event.value.row, event.value.column + _self.length), _self.othersClass, null, false);
        });
      });
    };
    this.hideOtherMarkers = function () {
      if (!this.othersActive)
        return;
      this.othersActive = false;
      for (var i = 0; i < this.others.length; i++) {
        this.session.removeMarker(this.others[i].markerId);
      }
    };
    this.onUpdate = function (event) {
      var delta = event.data;
      var range = delta.range;
      if (range.start.row !== range.end.row)
        return;
      if (range.start.row !== this.pos.row)
        return;
      if (this.$updating)
        return;
      this.$updating = true;
      var lengthDiff = delta.action === 'insertText' ? range.end.column - range.start.column : range.start.column - range.end.column;
      if (range.start.column >= this.pos.column && range.start.column <= this.pos.column + this.length + 1) {
        var distanceFromStart = range.start.column - this.pos.column;
        this.length += lengthDiff;
        if (!this.session.$fromUndo) {
          if (delta.action === 'insertText') {
            for (var i = this.others.length - 1; i >= 0; i--) {
              var otherPos = this.others[i];
              var newPos = {
                  row: otherPos.row,
                  column: otherPos.column + distanceFromStart
                };
              if (otherPos.row === range.start.row && range.start.column < otherPos.column)
                newPos.column += lengthDiff;
              this.doc.insert(newPos, delta.text);
            }
          } else if (delta.action === 'removeText') {
            for (var i = this.others.length - 1; i >= 0; i--) {
              var otherPos = this.others[i];
              var newPos = {
                  row: otherPos.row,
                  column: otherPos.column + distanceFromStart
                };
              if (otherPos.row === range.start.row && range.start.column < otherPos.column)
                newPos.column += lengthDiff;
              this.doc.remove(new Range(newPos.row, newPos.column, newPos.row, newPos.column - lengthDiff));
            }
          }
          if (range.start.column === this.pos.column && delta.action === 'insertText') {
            setTimeout(function () {
              this.pos.setPosition(this.pos.row, this.pos.column - lengthDiff);
              for (var i = 0; i < this.others.length; i++) {
                var other = this.others[i];
                var newPos = {
                    row: other.row,
                    column: other.column - lengthDiff
                  };
                if (other.row === range.start.row && range.start.column < other.column)
                  newPos.column += lengthDiff;
                other.setPosition(newPos.row, newPos.column);
              }
            }.bind(this), 0);
          } else if (range.start.column === this.pos.column && delta.action === 'removeText') {
            setTimeout(function () {
              for (var i = 0; i < this.others.length; i++) {
                var other = this.others[i];
                if (other.row === range.start.row && range.start.column < other.column) {
                  other.setPosition(other.row, other.column - lengthDiff);
                }
              }
            }.bind(this), 0);
          }
        }
        this.pos._emit('change', { value: this.pos });
        for (var i = 0; i < this.others.length; i++) {
          this.others[i]._emit('change', { value: this.others[i] });
        }
      }
      this.$updating = false;
    };
    this.onCursorChange = function (event) {
      if (this.$updating)
        return;
      var pos = this.session.selection.getCursor();
      if (pos.row === this.pos.row && pos.column >= this.pos.column && pos.column <= this.pos.column + this.length) {
        this.showOtherMarkers();
        this._emit('cursorEnter', event);
      } else {
        this.hideOtherMarkers();
        this._emit('cursorLeave', event);
      }
    };
    this.detach = function () {
      this.session.removeMarker(this.markerId);
      this.hideOtherMarkers();
      this.doc.removeEventListener('change', this.$onUpdate);
      this.session.selection.removeEventListener('changeCursor', this.$onCursorChange);
      this.pos.detach();
      for (var i = 0; i < this.others.length; i++) {
        this.others[i].detach();
      }
      this.session.setUndoSelect(true);
    };
    this.cancel = function () {
      if (this.$undoStackDepth === -1)
        throw Error('Canceling placeholders only supported with undo manager attached to session.');
      var undoManager = this.session.getUndoManager();
      var undosRequired = (undoManager.$undoStack || undoManager.$undostack).length - this.$undoStackDepth;
      for (var i = 0; i < undosRequired; i++) {
        undoManager.undo(true);
      }
    };
  }.call(PlaceHolder.prototype));
  exports.PlaceHolder = PlaceHolder;
});
ace.define('ace/lib/event', [
  'require',
  'exports',
  'module',
  'ace/lib/keys',
  'ace/lib/useragent'
], function (require, exports, module) {
  var keys = require('./keys');
  var useragent = require('./useragent');
  exports.addListener = function (elem, type, callback) {
    if (elem.addEventListener) {
      return elem.addEventListener(type, callback, false);
    }
    if (elem.attachEvent) {
      var wrapper = function () {
        callback.call(elem, window.event);
      };
      callback._wrapper = wrapper;
      elem.attachEvent('on' + type, wrapper);
    }
  };
  exports.removeListener = function (elem, type, callback) {
    if (elem.removeEventListener) {
      return elem.removeEventListener(type, callback, false);
    }
    if (elem.detachEvent) {
      elem.detachEvent('on' + type, callback._wrapper || callback);
    }
  };
  exports.stopEvent = function (e) {
    exports.stopPropagation(e);
    exports.preventDefault(e);
    return false;
  };
  exports.stopPropagation = function (e) {
    if (e.stopPropagation)
      e.stopPropagation();
    else
      e.cancelBubble = true;
  };
  exports.preventDefault = function (e) {
    if (e.preventDefault)
      e.preventDefault();
    else
      e.returnValue = false;
  };
  exports.getButton = function (e) {
    if (e.type == 'dblclick')
      return 0;
    if (e.type == 'contextmenu' || e.ctrlKey && useragent.isMac)
      return 2;
    if (e.preventDefault) {
      return e.button;
    } else {
      return {
        1: 0,
        2: 2,
        4: 1
      }[e.button];
    }
  };
  exports.capture = function (el, eventHandler, releaseCaptureHandler) {
    function onMouseUp(e) {
      eventHandler && eventHandler(e);
      releaseCaptureHandler && releaseCaptureHandler(e);
      exports.removeListener(document, 'mousemove', eventHandler, true);
      exports.removeListener(document, 'mouseup', onMouseUp, true);
      exports.removeListener(document, 'dragstart', onMouseUp, true);
    }
    exports.addListener(document, 'mousemove', eventHandler, true);
    exports.addListener(document, 'mouseup', onMouseUp, true);
    exports.addListener(document, 'dragstart', onMouseUp, true);
    return onMouseUp;
  };
  exports.addMouseWheelListener = function (el, callback) {
    if ('onmousewheel' in el) {
      exports.addListener(el, 'mousewheel', function (e) {
        var factor = 8;
        if (e.wheelDeltaX !== undefined) {
          e.wheelX = -e.wheelDeltaX / factor;
          e.wheelY = -e.wheelDeltaY / factor;
        } else {
          e.wheelX = 0;
          e.wheelY = -e.wheelDelta / factor;
        }
        callback(e);
      });
    } else if ('onwheel' in el) {
      exports.addListener(el, 'wheel', function (e) {
        var factor = 0.35;
        switch (e.deltaMode) {
        case e.DOM_DELTA_PIXEL:
          e.wheelX = e.deltaX * factor || 0;
          e.wheelY = e.deltaY * factor || 0;
          break;
        case e.DOM_DELTA_LINE:
        case e.DOM_DELTA_PAGE:
          e.wheelX = (e.deltaX || 0) * 5;
          e.wheelY = (e.deltaY || 0) * 5;
          break;
        }
        callback(e);
      });
    } else {
      exports.addListener(el, 'DOMMouseScroll', function (e) {
        if (e.axis && e.axis == e.HORIZONTAL_AXIS) {
          e.wheelX = (e.detail || 0) * 5;
          e.wheelY = 0;
        } else {
          e.wheelX = 0;
          e.wheelY = (e.detail || 0) * 5;
        }
        callback(e);
      });
    }
  };
  exports.addMultiMouseDownListener = function (el, timeouts, eventHandler, callbackName) {
    var clicks = 0;
    var startX, startY, timer;
    var eventNames = {
        2: 'dblclick',
        3: 'tripleclick',
        4: 'quadclick'
      };
    exports.addListener(el, 'mousedown', function (e) {
      if (exports.getButton(e) !== 0) {
        clicks = 0;
      } else if (e.detail > 1) {
        clicks++;
        if (clicks > 4)
          clicks = 1;
      } else {
        clicks = 1;
      }
      if (useragent.isIE) {
        var isNewClick = Math.abs(e.clientX - startX) > 5 || Math.abs(e.clientY - startY) > 5;
        if (isNewClick) {
          clicks = 1;
        }
        if (clicks == 1) {
          startX = e.clientX;
          startY = e.clientY;
        }
      }
      eventHandler[callbackName]('mousedown', e);
      if (clicks > 4)
        clicks = 0;
      else if (clicks > 1)
        return eventHandler[callbackName](eventNames[clicks], e);
    });
    if (useragent.isOldIE) {
      exports.addListener(el, 'dblclick', function (e) {
        clicks = 2;
        if (timer)
          clearTimeout(timer);
        timer = setTimeout(function () {
          timer = null;
        }, timeouts[clicks - 1] || 600);
        eventHandler[callbackName]('mousedown', e);
        eventHandler[callbackName](eventNames[clicks], e);
      });
    }
  };
  var getModifierHash = useragent.isMac && useragent.isOpera && !('KeyboardEvent' in window) ? function (e) {
      return 0 | (e.metaKey ? 1 : 0) | (e.altKey ? 2 : 0) | (e.shiftKey ? 4 : 0) | (e.ctrlKey ? 8 : 0);
    } : function (e) {
      return 0 | (e.ctrlKey ? 1 : 0) | (e.altKey ? 2 : 0) | (e.shiftKey ? 4 : 0) | (e.metaKey ? 8 : 0);
    };
  exports.getModifierString = function (e) {
    return keys.KEY_MODS[getModifierHash(e)];
  };
  function normalizeCommandKeys(callback, e, keyCode) {
    var hashId = getModifierHash(e);
    if (!useragent.isMac && pressedKeys) {
      if (pressedKeys[91] || pressedKeys[92])
        hashId |= 8;
      if (pressedKeys.altGr) {
        if ((3 & hashId) != 3)
          pressedKeys.altGr = 0;
        else
          return;
      }
      if (keyCode === 18 || keyCode === 17) {
        var location = e.location || e.keyLocation;
        if (keyCode === 17 && location === 1) {
          ts = e.timeStamp;
        } else if (keyCode === 18 && hashId === 3 && location === 2) {
          var dt = -ts;
          ts = e.timeStamp;
          dt += ts;
          if (dt < 3)
            pressedKeys.altGr = true;
        }
      }
    }
    if (keyCode in keys.MODIFIER_KEYS) {
      switch (keys.MODIFIER_KEYS[keyCode]) {
      case 'Alt':
        hashId = 2;
        break;
      case 'Shift':
        hashId = 4;
        break;
      case 'Ctrl':
        hashId = 1;
        break;
      default:
        hashId = 8;
        break;
      }
      keyCode = -1;
    }
    if (hashId & 8 && (keyCode === 91 || keyCode === 93)) {
      keyCode = -1;
    }
    if (!hashId && keyCode === 13) {
      if (e.location || e.keyLocation === 3) {
        callback(e, hashId, -keyCode);
        if (e.defaultPrevented)
          return;
      }
    }
    if (!hashId && !(keyCode in keys.FUNCTION_KEYS) && !(keyCode in keys.PRINTABLE_KEYS)) {
      return false;
    }
    return callback(e, hashId, keyCode);
  }
  var pressedKeys = null;
  var ts = 0;
  exports.addCommandKeyListener = function (el, callback) {
    var addListener = exports.addListener;
    if (useragent.isOldGecko || useragent.isOpera && !('KeyboardEvent' in window)) {
      var lastKeyDownKeyCode = null;
      addListener(el, 'keydown', function (e) {
        lastKeyDownKeyCode = e.keyCode;
      });
      addListener(el, 'keypress', function (e) {
        return normalizeCommandKeys(callback, e, lastKeyDownKeyCode);
      });
    } else {
      var lastDefaultPrevented = null;
      addListener(el, 'keydown', function (e) {
        pressedKeys[e.keyCode] = true;
        var result = normalizeCommandKeys(callback, e, e.keyCode);
        lastDefaultPrevented = e.defaultPrevented;
        return result;
      });
      addListener(el, 'keypress', function (e) {
        if (lastDefaultPrevented && (e.ctrlKey || e.altKey || e.shiftKey || e.metaKey)) {
          exports.stopEvent(e);
          lastDefaultPrevented = null;
        }
      });
      addListener(el, 'keyup', function (e) {
        pressedKeys[e.keyCode] = null;
      });
      if (!pressedKeys) {
        pressedKeys = Object.create(null);
        addListener(window, 'focus', function (e) {
          pressedKeys = Object.create(null);
        });
      }
    }
  };
  if (window.postMessage && !useragent.isOldIE) {
    var postMessageId = 1;
    exports.nextTick = function (callback, win) {
      win = win || window;
      var messageName = 'zero-timeout-message-' + postMessageId;
      exports.addListener(win, 'message', function listener(e) {
        if (e.data == messageName) {
          exports.stopPropagation(e);
          exports.removeListener(win, 'message', listener);
          callback();
        }
      });
      win.postMessage(messageName, '*');
    };
  }
  exports.nextFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || window.oRequestAnimationFrame;
  if (exports.nextFrame)
    exports.nextFrame = exports.nextFrame.bind(window);
  else
    exports.nextFrame = function (callback) {
      setTimeout(callback, 17);
    };
});
ace.define('ace/mode/folding/fold_mode', [
  'require',
  'exports',
  'module',
  'ace/range'
], function (require, exports, module) {
  var Range = require('../../range').Range;
  var FoldMode = exports.FoldMode = function () {
    };
  (function () {
    this.foldingStartMarker = null;
    this.foldingStopMarker = null;
    this.getFoldWidget = function (session, foldStyle, row) {
      var line = session.getLine(row);
      if (this.foldingStartMarker.test(line))
        return 'start';
      if (foldStyle == 'markbeginend' && this.foldingStopMarker && this.foldingStopMarker.test(line))
        return 'end';
      return '';
    };
    this.getFoldWidgetRange = function (session, foldStyle, row) {
      return null;
    };
    this.indentationBlock = function (session, row, column) {
      var re = /\S/;
      var line = session.getLine(row);
      var startLevel = line.search(re);
      if (startLevel == -1)
        return;
      var startColumn = column || line.length;
      var maxRow = session.getLength();
      var startRow = row;
      var endRow = row;
      while (++row < maxRow) {
        var level = session.getLine(row).search(re);
        if (level == -1)
          continue;
        if (level <= startLevel)
          break;
        endRow = row;
      }
      if (endRow > startRow) {
        var endColumn = session.getLine(endRow).length;
        return new Range(startRow, startColumn, endRow, endColumn);
      }
    };
    this.openingBracketBlock = function (session, bracket, row, column, typeRe) {
      var start = {
          row: row,
          column: column + 1
        };
      var end = session.$findClosingBracket(bracket, start, typeRe);
      if (!end)
        return;
      var fw = session.foldWidgets[end.row];
      if (fw == null)
        fw = session.getFoldWidget(end.row);
      if (fw == 'start' && end.row > start.row) {
        end.row--;
        end.column = session.getLine(end.row).length;
      }
      return Range.fromPoints(start, end);
    };
    this.closingBracketBlock = function (session, bracket, row, column, typeRe) {
      var end = {
          row: row,
          column: column
        };
      var start = session.$findOpeningBracket(bracket, end);
      if (!start)
        return;
      start.column++;
      end.column--;
      return Range.fromPoints(start, end);
    };
  }.call(FoldMode.prototype));
});
ace.define('ace/lib/dom', [
  'require',
  'exports',
  'module'
], function (require, exports, module) {
  if (typeof document == 'undefined')
    return;
  var XHTML_NS = 'http://www.w3.org/1999/xhtml';
  exports.getDocumentHead = function (doc) {
    if (!doc)
      doc = document;
    return doc.head || doc.getElementsByTagName('head')[0] || doc.documentElement;
  };
  exports.createElement = function (tag, ns) {
    return document.createElementNS ? document.createElementNS(ns || XHTML_NS, tag) : document.createElement(tag);
  };
  exports.hasCssClass = function (el, name) {
    var classes = el.className.split(/\s+/g);
    return classes.indexOf(name) !== -1;
  };
  exports.addCssClass = function (el, name) {
    if (!exports.hasCssClass(el, name)) {
      el.className += ' ' + name;
    }
  };
  exports.removeCssClass = function (el, name) {
    var classes = el.className.split(/\s+/g);
    while (true) {
      var index = classes.indexOf(name);
      if (index == -1) {
        break;
      }
      classes.splice(index, 1);
    }
    el.className = classes.join(' ');
  };
  exports.toggleCssClass = function (el, name) {
    var classes = el.className.split(/\s+/g), add = true;
    while (true) {
      var index = classes.indexOf(name);
      if (index == -1) {
        break;
      }
      add = false;
      classes.splice(index, 1);
    }
    if (add)
      classes.push(name);
    el.className = classes.join(' ');
    return add;
  };
  exports.setCssClass = function (node, className, include) {
    if (include) {
      exports.addCssClass(node, className);
    } else {
      exports.removeCssClass(node, className);
    }
  };
  exports.hasCssString = function (id, doc) {
    var index = 0, sheets;
    doc = doc || document;
    if (doc.createStyleSheet && (sheets = doc.styleSheets)) {
      while (index < sheets.length)
        if (sheets[index++].owningElement.id === id)
          return true;
    } else if (sheets = doc.getElementsByTagName('style')) {
      while (index < sheets.length)
        if (sheets[index++].id === id)
          return true;
    }
    return false;
  };
  exports.importCssString = function importCssString(cssText, id, doc) {
    doc = doc || document;
    if (id && exports.hasCssString(id, doc))
      return null;
    var style;
    if (doc.createStyleSheet) {
      style = doc.createStyleSheet();
      style.cssText = cssText;
      if (id)
        style.owningElement.id = id;
    } else {
      style = doc.createElementNS ? doc.createElementNS(XHTML_NS, 'style') : doc.createElement('style');
      style.appendChild(doc.createTextNode(cssText));
      if (id)
        style.id = id;
      exports.getDocumentHead(doc).appendChild(style);
    }
  };
  exports.importCssStylsheet = function (uri, doc) {
    if (doc.createStyleSheet) {
      doc.createStyleSheet(uri);
    } else {
      var link = exports.createElement('link');
      link.rel = 'stylesheet';
      link.href = uri;
      exports.getDocumentHead(doc).appendChild(link);
    }
  };
  exports.getInnerWidth = function (element) {
    return parseInt(exports.computedStyle(element, 'paddingLeft'), 10) + parseInt(exports.computedStyle(element, 'paddingRight'), 10) + element.clientWidth;
  };
  exports.getInnerHeight = function (element) {
    return parseInt(exports.computedStyle(element, 'paddingTop'), 10) + parseInt(exports.computedStyle(element, 'paddingBottom'), 10) + element.clientHeight;
  };
  if (window.pageYOffset !== undefined) {
    exports.getPageScrollTop = function () {
      return window.pageYOffset;
    };
    exports.getPageScrollLeft = function () {
      return window.pageXOffset;
    };
  } else {
    exports.getPageScrollTop = function () {
      return document.body.scrollTop;
    };
    exports.getPageScrollLeft = function () {
      return document.body.scrollLeft;
    };
  }
  if (window.getComputedStyle)
    exports.computedStyle = function (element, style) {
      if (style)
        return (window.getComputedStyle(element, '') || {})[style] || '';
      return window.getComputedStyle(element, '') || {};
    };
  else
    exports.computedStyle = function (element, style) {
      if (style)
        return element.currentStyle[style];
      return element.currentStyle;
    };
  exports.scrollbarWidth = function (document) {
    var inner = exports.createElement('ace_inner');
    inner.style.width = '100%';
    inner.style.minWidth = '0px';
    inner.style.height = '200px';
    inner.style.display = 'block';
    var outer = exports.createElement('ace_outer');
    var style = outer.style;
    style.position = 'absolute';
    style.left = '-10000px';
    style.overflow = 'hidden';
    style.width = '200px';
    style.minWidth = '0px';
    style.height = '150px';
    style.display = 'block';
    outer.appendChild(inner);
    var body = document.documentElement;
    body.appendChild(outer);
    var noScrollbar = inner.offsetWidth;
    style.overflow = 'scroll';
    var withScrollbar = inner.offsetWidth;
    if (noScrollbar == withScrollbar) {
      withScrollbar = outer.clientWidth;
    }
    body.removeChild(outer);
    return noScrollbar - withScrollbar;
  };
  exports.setInnerHtml = function (el, innerHtml) {
    var element = el.cloneNode(false);
    element.innerHTML = innerHtml;
    el.parentNode.replaceChild(element, el);
    return element;
  };
  if ('textContent' in document.documentElement) {
    exports.setInnerText = function (el, innerText) {
      el.textContent = innerText;
    };
    exports.getInnerText = function (el) {
      return el.textContent;
    };
  } else {
    exports.setInnerText = function (el, innerText) {
      el.innerText = innerText;
    };
    exports.getInnerText = function (el) {
      return el.innerText;
    };
  }
  exports.getParentWindow = function (document) {
    return document.defaultView || document.parentWindow;
  };
});
ace.define('ace/theme/textmate', [
  'require',
  'exports',
  'module',
  'ace/lib/dom'
], function (require, exports, module) {
  exports.isDark = false;
  exports.cssClass = 'ace-tm';
  exports.cssText = '.ace-tm .ace_gutter {background: #f0f0f0;color: #333;}.ace-tm .ace_print-margin {width: 1px;background: #e8e8e8;}.ace-tm .ace_fold {background-color: #6B72E6;}.ace-tm {background-color: #FFFFFF;color: black;}.ace-tm .ace_cursor {color: black;}.ace-tm .ace_invisible {color: rgb(191, 191, 191);}.ace-tm .ace_storage,.ace-tm .ace_keyword {color: blue;}.ace-tm .ace_constant {color: rgb(197, 6, 11);}.ace-tm .ace_constant.ace_buildin {color: rgb(88, 72, 246);}.ace-tm .ace_constant.ace_language {color: rgb(88, 92, 246);}.ace-tm .ace_constant.ace_library {color: rgb(6, 150, 14);}.ace-tm .ace_invalid {background-color: rgba(255, 0, 0, 0.1);color: red;}.ace-tm .ace_support.ace_function {color: rgb(60, 76, 114);}.ace-tm .ace_support.ace_constant {color: rgb(6, 150, 14);}.ace-tm .ace_support.ace_type,.ace-tm .ace_support.ace_class {color: rgb(109, 121, 222);}.ace-tm .ace_keyword.ace_operator {color: rgb(104, 118, 135);}.ace-tm .ace_string {color: rgb(3, 106, 7);}.ace-tm .ace_comment {color: rgb(76, 136, 107);}.ace-tm .ace_comment.ace_doc {color: rgb(0, 102, 255);}.ace-tm .ace_comment.ace_doc.ace_tag {color: rgb(128, 159, 191);}.ace-tm .ace_constant.ace_numeric {color: rgb(0, 0, 205);}.ace-tm .ace_variable {color: rgb(49, 132, 149);}.ace-tm .ace_xml-pe {color: rgb(104, 104, 91);}.ace-tm .ace_entity.ace_name.ace_function {color: #0000A2;}.ace-tm .ace_heading {color: rgb(12, 7, 255);}.ace-tm .ace_list {color:rgb(185, 6, 144);}.ace-tm .ace_meta.ace_tag {color:rgb(0, 22, 142);}.ace-tm .ace_string.ace_regex {color: rgb(255, 0, 0)}.ace-tm .ace_marker-layer .ace_selection {background: rgb(181, 213, 255);}.ace-tm.ace_multiselect .ace_selection.ace_start {box-shadow: 0 0 3px 0px white;border-radius: 2px;}.ace-tm .ace_marker-layer .ace_step {background: rgb(252, 255, 0);}.ace-tm .ace_marker-layer .ace_stack {background: rgb(164, 229, 101);}.ace-tm .ace_marker-layer .ace_bracket {margin: -1px 0 0 -1px;border: 1px solid rgb(192, 192, 192);}.ace-tm .ace_marker-layer .ace_active-line {background: rgba(0, 0, 0, 0.07);}.ace-tm .ace_gutter-active-line {background-color : #dcdcdc;}.ace-tm .ace_marker-layer .ace_selected-word {background: rgb(250, 250, 255);border: 1px solid rgb(200, 200, 250);}.ace-tm .ace_indent-guide {background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bLly//BwAmVgd1/w11/gAAAABJRU5ErkJggg==") right repeat-y;}';
  var dom = require('../lib/dom');
  dom.importCssString(exports.cssText, exports.cssClass);
});
ace.define('ace/lib/es5-shim', [
  'require',
  'exports',
  'module'
], function (require, exports, module) {
  function Empty() {
  }
  if (!Function.prototype.bind) {
    Function.prototype.bind = function bind(that) {
      var target = this;
      if (typeof target != 'function') {
        throw new TypeError('Function.prototype.bind called on incompatible ' + target);
      }
      var args = slice.call(arguments, 1);
      var bound = function () {
        if (this instanceof bound) {
          var result = target.apply(this, args.concat(slice.call(arguments)));
          if (Object(result) === result) {
            return result;
          }
          return this;
        } else {
          return target.apply(that, args.concat(slice.call(arguments)));
        }
      };
      if (target.prototype) {
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
  var call = Function.prototype.call;
  var prototypeOfArray = Array.prototype;
  var prototypeOfObject = Object.prototype;
  var slice = prototypeOfArray.slice;
  var _toString = call.bind(prototypeOfObject.toString);
  var owns = call.bind(prototypeOfObject.hasOwnProperty);
  var defineGetter;
  var defineSetter;
  var lookupGetter;
  var lookupSetter;
  var supportsAccessors;
  if (supportsAccessors = owns(prototypeOfObject, '__defineGetter__')) {
    defineGetter = call.bind(prototypeOfObject.__defineGetter__);
    defineSetter = call.bind(prototypeOfObject.__defineSetter__);
    lookupGetter = call.bind(prototypeOfObject.__lookupGetter__);
    lookupSetter = call.bind(prototypeOfObject.__lookupSetter__);
  }
  if ([
      1,
      2
    ].splice(0).length != 2) {
    if (function () {
        function makeArray(l) {
          var a = new Array(l + 2);
          a[0] = a[1] = 0;
          return a;
        }
        var array = [], lengthBefore;
        array.splice.apply(array, makeArray(20));
        array.splice.apply(array, makeArray(26));
        lengthBefore = array.length;
        array.splice(5, 0, 'XXX');
        lengthBefore + 1 == array.length;
        if (lengthBefore + 1 == array.length) {
          return true;
        }
      }()) {
      var array_splice = Array.prototype.splice;
      Array.prototype.splice = function (start, deleteCount) {
        if (!arguments.length) {
          return [];
        } else {
          return array_splice.apply(this, [
            start === void 0 ? 0 : start,
            deleteCount === void 0 ? this.length - start : deleteCount
          ].concat(slice.call(arguments, 2)));
        }
      };
    } else {
      Array.prototype.splice = function (pos, removeCount) {
        var length = this.length;
        if (pos > 0) {
          if (pos > length)
            pos = length;
        } else if (pos == void 0) {
          pos = 0;
        } else if (pos < 0) {
          pos = Math.max(length + pos, 0);
        }
        if (!(pos + removeCount < length))
          removeCount = length - pos;
        var removed = this.slice(pos, pos + removeCount);
        var insert = slice.call(arguments, 2);
        var add = insert.length;
        if (pos === length) {
          if (add) {
            this.push.apply(this, insert);
          }
        } else {
          var remove = Math.min(removeCount, length - pos);
          var tailOldPos = pos + remove;
          var tailNewPos = tailOldPos + add - remove;
          var tailCount = length - tailOldPos;
          var lengthAfterRemove = length - remove;
          if (tailNewPos < tailOldPos) {
            for (var i = 0; i < tailCount; ++i) {
              this[tailNewPos + i] = this[tailOldPos + i];
            }
          } else if (tailNewPos > tailOldPos) {
            for (i = tailCount; i--;) {
              this[tailNewPos + i] = this[tailOldPos + i];
            }
          }
          if (add && pos === lengthAfterRemove) {
            this.length = lengthAfterRemove;
            this.push.apply(this, insert);
          } else {
            this.length = lengthAfterRemove + add;
            for (i = 0; i < add; ++i) {
              this[pos + i] = insert[i];
            }
          }
        }
        return removed;
      };
    }
  }
  if (!Array.isArray) {
    Array.isArray = function isArray(obj) {
      return _toString(obj) == '[object Array]';
    };
  }
  var boxedString = Object('a'), splitString = boxedString[0] != 'a' || !(0 in boxedString);
  if (!Array.prototype.forEach) {
    Array.prototype.forEach = function forEach(fun) {
      var object = toObject(this), self = splitString && _toString(this) == '[object String]' ? this.split('') : object, thisp = arguments[1], i = -1, length = self.length >>> 0;
      if (_toString(fun) != '[object Function]') {
        throw new TypeError();
      }
      while (++i < length) {
        if (i in self) {
          fun.call(thisp, self[i], i, object);
        }
      }
    };
  }
  if (!Array.prototype.map) {
    Array.prototype.map = function map(fun) {
      var object = toObject(this), self = splitString && _toString(this) == '[object String]' ? this.split('') : object, length = self.length >>> 0, result = Array(length), thisp = arguments[1];
      if (_toString(fun) != '[object Function]') {
        throw new TypeError(fun + ' is not a function');
      }
      for (var i = 0; i < length; i++) {
        if (i in self)
          result[i] = fun.call(thisp, self[i], i, object);
      }
      return result;
    };
  }
  if (!Array.prototype.filter) {
    Array.prototype.filter = function filter(fun) {
      var object = toObject(this), self = splitString && _toString(this) == '[object String]' ? this.split('') : object, length = self.length >>> 0, result = [], value, thisp = arguments[1];
      if (_toString(fun) != '[object Function]') {
        throw new TypeError(fun + ' is not a function');
      }
      for (var i = 0; i < length; i++) {
        if (i in self) {
          value = self[i];
          if (fun.call(thisp, value, i, object)) {
            result.push(value);
          }
        }
      }
      return result;
    };
  }
  if (!Array.prototype.every) {
    Array.prototype.every = function every(fun) {
      var object = toObject(this), self = splitString && _toString(this) == '[object String]' ? this.split('') : object, length = self.length >>> 0, thisp = arguments[1];
      if (_toString(fun) != '[object Function]') {
        throw new TypeError(fun + ' is not a function');
      }
      for (var i = 0; i < length; i++) {
        if (i in self && !fun.call(thisp, self[i], i, object)) {
          return false;
        }
      }
      return true;
    };
  }
  if (!Array.prototype.some) {
    Array.prototype.some = function some(fun) {
      var object = toObject(this), self = splitString && _toString(this) == '[object String]' ? this.split('') : object, length = self.length >>> 0, thisp = arguments[1];
      if (_toString(fun) != '[object Function]') {
        throw new TypeError(fun + ' is not a function');
      }
      for (var i = 0; i < length; i++) {
        if (i in self && fun.call(thisp, self[i], i, object)) {
          return true;
        }
      }
      return false;
    };
  }
  if (!Array.prototype.reduce) {
    Array.prototype.reduce = function reduce(fun) {
      var object = toObject(this), self = splitString && _toString(this) == '[object String]' ? this.split('') : object, length = self.length >>> 0;
      if (_toString(fun) != '[object Function]') {
        throw new TypeError(fun + ' is not a function');
      }
      if (!length && arguments.length == 1) {
        throw new TypeError('reduce of empty array with no initial value');
      }
      var i = 0;
      var result;
      if (arguments.length >= 2) {
        result = arguments[1];
      } else {
        do {
          if (i in self) {
            result = self[i++];
            break;
          }
          if (++i >= length) {
            throw new TypeError('reduce of empty array with no initial value');
          }
        } while (true);
      }
      for (; i < length; i++) {
        if (i in self) {
          result = fun.call(void 0, result, self[i], i, object);
        }
      }
      return result;
    };
  }
  if (!Array.prototype.reduceRight) {
    Array.prototype.reduceRight = function reduceRight(fun) {
      var object = toObject(this), self = splitString && _toString(this) == '[object String]' ? this.split('') : object, length = self.length >>> 0;
      if (_toString(fun) != '[object Function]') {
        throw new TypeError(fun + ' is not a function');
      }
      if (!length && arguments.length == 1) {
        throw new TypeError('reduceRight of empty array with no initial value');
      }
      var result, i = length - 1;
      if (arguments.length >= 2) {
        result = arguments[1];
      } else {
        do {
          if (i in self) {
            result = self[i--];
            break;
          }
          if (--i < 0) {
            throw new TypeError('reduceRight of empty array with no initial value');
          }
        } while (true);
      }
      do {
        if (i in this) {
          result = fun.call(void 0, result, self[i], i, object);
        }
      } while (i--);
      return result;
    };
  }
  if (!Array.prototype.indexOf || [
      0,
      1
    ].indexOf(1, 2) != -1) {
    Array.prototype.indexOf = function indexOf(sought) {
      var self = splitString && _toString(this) == '[object String]' ? this.split('') : toObject(this), length = self.length >>> 0;
      if (!length) {
        return -1;
      }
      var i = 0;
      if (arguments.length > 1) {
        i = toInteger(arguments[1]);
      }
      i = i >= 0 ? i : Math.max(0, length + i);
      for (; i < length; i++) {
        if (i in self && self[i] === sought) {
          return i;
        }
      }
      return -1;
    };
  }
  if (!Array.prototype.lastIndexOf || [
      0,
      1
    ].lastIndexOf(0, -3) != -1) {
    Array.prototype.lastIndexOf = function lastIndexOf(sought) {
      var self = splitString && _toString(this) == '[object String]' ? this.split('') : toObject(this), length = self.length >>> 0;
      if (!length) {
        return -1;
      }
      var i = length - 1;
      if (arguments.length > 1) {
        i = Math.min(i, toInteger(arguments[1]));
      }
      i = i >= 0 ? i : length - Math.abs(i);
      for (; i >= 0; i--) {
        if (i in self && sought === self[i]) {
          return i;
        }
      }
      return -1;
    };
  }
  if (!Object.getPrototypeOf) {
    Object.getPrototypeOf = function getPrototypeOf(object) {
      return object.__proto__ || (object.constructor ? object.constructor.prototype : prototypeOfObject);
    };
  }
  if (!Object.getOwnPropertyDescriptor) {
    var ERR_NON_OBJECT = 'Object.getOwnPropertyDescriptor called on a ' + 'non-object: ';
    Object.getOwnPropertyDescriptor = function getOwnPropertyDescriptor(object, property) {
      if (typeof object != 'object' && typeof object != 'function' || object === null)
        throw new TypeError(ERR_NON_OBJECT + object);
      if (!owns(object, property))
        return;
      var descriptor, getter, setter;
      descriptor = {
        enumerable: true,
        configurable: true
      };
      if (supportsAccessors) {
        var prototype = object.__proto__;
        object.__proto__ = prototypeOfObject;
        var getter = lookupGetter(object, property);
        var setter = lookupSetter(object, property);
        object.__proto__ = prototype;
        if (getter || setter) {
          if (getter)
            descriptor.get = getter;
          if (setter)
            descriptor.set = setter;
          return descriptor;
        }
      }
      descriptor.value = object[property];
      return descriptor;
    };
  }
  if (!Object.getOwnPropertyNames) {
    Object.getOwnPropertyNames = function getOwnPropertyNames(object) {
      return Object.keys(object);
    };
  }
  if (!Object.create) {
    var createEmpty;
    if (Object.prototype.__proto__ === null) {
      createEmpty = function () {
        return { '__proto__': null };
      };
    } else {
      createEmpty = function () {
        var empty = {};
        for (var i in empty)
          empty[i] = null;
        empty.constructor = empty.hasOwnProperty = empty.propertyIsEnumerable = empty.isPrototypeOf = empty.toLocaleString = empty.toString = empty.valueOf = empty.__proto__ = null;
        return empty;
      };
    }
    Object.create = function create(prototype, properties) {
      var object;
      if (prototype === null) {
        object = createEmpty();
      } else {
        if (typeof prototype != 'object')
          throw new TypeError('typeof prototype[' + typeof prototype + '] != \'object\'');
        var Type = function () {
        };
        Type.prototype = prototype;
        object = new Type();
        object.__proto__ = prototype;
      }
      if (properties !== void 0)
        Object.defineProperties(object, properties);
      return object;
    };
  }
  function doesDefinePropertyWork(object) {
    try {
      Object.defineProperty(object, 'sentinel', {});
      return 'sentinel' in object;
    } catch (exception) {
    }
  }
  if (Object.defineProperty) {
    var definePropertyWorksOnObject = doesDefinePropertyWork({});
    var definePropertyWorksOnDom = typeof document == 'undefined' || doesDefinePropertyWork(document.createElement('div'));
    if (!definePropertyWorksOnObject || !definePropertyWorksOnDom) {
      var definePropertyFallback = Object.defineProperty;
    }
  }
  if (!Object.defineProperty || definePropertyFallback) {
    var ERR_NON_OBJECT_DESCRIPTOR = 'Property description must be an object: ';
    var ERR_NON_OBJECT_TARGET = 'Object.defineProperty called on non-object: ';
    var ERR_ACCESSORS_NOT_SUPPORTED = 'getters & setters can not be defined ' + 'on this javascript engine';
    Object.defineProperty = function defineProperty(object, property, descriptor) {
      if (typeof object != 'object' && typeof object != 'function' || object === null)
        throw new TypeError(ERR_NON_OBJECT_TARGET + object);
      if (typeof descriptor != 'object' && typeof descriptor != 'function' || descriptor === null)
        throw new TypeError(ERR_NON_OBJECT_DESCRIPTOR + descriptor);
      if (definePropertyFallback) {
        try {
          return definePropertyFallback.call(Object, object, property, descriptor);
        } catch (exception) {
        }
      }
      if (owns(descriptor, 'value')) {
        if (supportsAccessors && (lookupGetter(object, property) || lookupSetter(object, property))) {
          var prototype = object.__proto__;
          object.__proto__ = prototypeOfObject;
          delete object[property];
          object[property] = descriptor.value;
          object.__proto__ = prototype;
        } else {
          object[property] = descriptor.value;
        }
      } else {
        if (!supportsAccessors)
          throw new TypeError(ERR_ACCESSORS_NOT_SUPPORTED);
        if (owns(descriptor, 'get'))
          defineGetter(object, property, descriptor.get);
        if (owns(descriptor, 'set'))
          defineSetter(object, property, descriptor.set);
      }
      return object;
    };
  }
  if (!Object.defineProperties) {
    Object.defineProperties = function defineProperties(object, properties) {
      for (var property in properties) {
        if (owns(properties, property))
          Object.defineProperty(object, property, properties[property]);
      }
      return object;
    };
  }
  if (!Object.seal) {
    Object.seal = function seal(object) {
      return object;
    };
  }
  if (!Object.freeze) {
    Object.freeze = function freeze(object) {
      return object;
    };
  }
  try {
    Object.freeze(function () {
    });
  } catch (exception) {
    Object.freeze = function freeze(freezeObject) {
      return function freeze(object) {
        if (typeof object == 'function') {
          return object;
        } else {
          return freezeObject(object);
        }
      };
    }(Object.freeze);
  }
  if (!Object.preventExtensions) {
    Object.preventExtensions = function preventExtensions(object) {
      return object;
    };
  }
  if (!Object.isSealed) {
    Object.isSealed = function isSealed(object) {
      return false;
    };
  }
  if (!Object.isFrozen) {
    Object.isFrozen = function isFrozen(object) {
      return false;
    };
  }
  if (!Object.isExtensible) {
    Object.isExtensible = function isExtensible(object) {
      if (Object(object) === object) {
        throw new TypeError();
      }
      var name = '';
      while (owns(object, name)) {
        name += '?';
      }
      object[name] = true;
      var returnValue = owns(object, name);
      delete object[name];
      return returnValue;
    };
  }
  if (!Object.keys) {
    var hasDontEnumBug = true, dontEnums = [
        'toString',
        'toLocaleString',
        'valueOf',
        'hasOwnProperty',
        'isPrototypeOf',
        'propertyIsEnumerable',
        'constructor'
      ], dontEnumsLength = dontEnums.length;
    for (var key in { 'toString': null }) {
      hasDontEnumBug = false;
    }
    Object.keys = function keys(object) {
      if (typeof object != 'object' && typeof object != 'function' || object === null) {
        throw new TypeError('Object.keys called on a non-object');
      }
      var keys = [];
      for (var name in object) {
        if (owns(object, name)) {
          keys.push(name);
        }
      }
      if (hasDontEnumBug) {
        for (var i = 0, ii = dontEnumsLength; i < ii; i++) {
          var dontEnum = dontEnums[i];
          if (owns(object, dontEnum)) {
            keys.push(dontEnum);
          }
        }
      }
      return keys;
    };
  }
  if (!Date.now) {
    Date.now = function now() {
      return new Date().getTime();
    };
  }
  var ws = '\t\n\x0B\f\r \xa0\u1680\u180e\u2000\u2001\u2002\u2003' + '\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028' + '\u2029\ufeff';
  if (!String.prototype.trim || ws.trim()) {
    ws = '[' + ws + ']';
    var trimBeginRegexp = new RegExp('^' + ws + ws + '*'), trimEndRegexp = new RegExp(ws + ws + '*$');
    String.prototype.trim = function trim() {
      return String(this).replace(trimBeginRegexp, '').replace(trimEndRegexp, '');
    };
  }
  function toInteger(n) {
    n = +n;
    if (n !== n) {
      n = 0;
    } else if (n !== 0 && n !== 1 / 0 && n !== -(1 / 0)) {
      n = (n > 0 || -1) * Math.floor(Math.abs(n));
    }
    return n;
  }
  function isPrimitive(input) {
    var type = typeof input;
    return input === null || type === 'undefined' || type === 'boolean' || type === 'number' || type === 'string';
  }
  function toPrimitive(input) {
    var val, valueOf, toString;
    if (isPrimitive(input)) {
      return input;
    }
    valueOf = input.valueOf;
    if (typeof valueOf === 'function') {
      val = valueOf.call(input);
      if (isPrimitive(val)) {
        return val;
      }
    }
    toString = input.toString;
    if (typeof toString === 'function') {
      val = toString.call(input);
      if (isPrimitive(val)) {
        return val;
      }
    }
    throw new TypeError();
  }
  var toObject = function (o) {
    if (o == null) {
      throw new TypeError('can\'t convert ' + o + ' to object');
    }
    return Object(o);
  };
});
ace.define('ace/lib/regexp', [
  'require',
  'exports',
  'module'
], function (require, exports, module) {
  var real = {
      exec: RegExp.prototype.exec,
      test: RegExp.prototype.test,
      match: String.prototype.match,
      replace: String.prototype.replace,
      split: String.prototype.split
    }, compliantExecNpcg = real.exec.call(/()??/, '')[1] === undefined, compliantLastIndexIncrement = function () {
      var x = /^/g;
      real.test.call(x, '');
      return !x.lastIndex;
    }();
  if (compliantLastIndexIncrement && compliantExecNpcg)
    return;
  RegExp.prototype.exec = function (str) {
    var match = real.exec.apply(this, arguments), name, r2;
    if (typeof str == 'string' && match) {
      if (!compliantExecNpcg && match.length > 1 && indexOf(match, '') > -1) {
        r2 = RegExp(this.source, real.replace.call(getNativeFlags(this), 'g', ''));
        real.replace.call(str.slice(match.index), r2, function () {
          for (var i = 1; i < arguments.length - 2; i++) {
            if (arguments[i] === undefined)
              match[i] = undefined;
          }
        });
      }
      if (this._xregexp && this._xregexp.captureNames) {
        for (var i = 1; i < match.length; i++) {
          name = this._xregexp.captureNames[i - 1];
          if (name)
            match[name] = match[i];
        }
      }
      if (!compliantLastIndexIncrement && this.global && !match[0].length && this.lastIndex > match.index)
        this.lastIndex--;
    }
    return match;
  };
  if (!compliantLastIndexIncrement) {
    RegExp.prototype.test = function (str) {
      var match = real.exec.call(this, str);
      if (match && this.global && !match[0].length && this.lastIndex > match.index)
        this.lastIndex--;
      return !!match;
    };
  }
  function getNativeFlags(regex) {
    return (regex.global ? 'g' : '') + (regex.ignoreCase ? 'i' : '') + (regex.multiline ? 'm' : '') + (regex.extended ? 'x' : '') + (regex.sticky ? 'y' : '');
  }
  function indexOf(array, item, from) {
    if (Array.prototype.indexOf)
      return array.indexOf(item, from);
    for (var i = from || 0; i < array.length; i++) {
      if (array[i] === item)
        return i;
    }
    return -1;
  }
});
ace.define('ace/ext/error_marker', [
  'require',
  'exports',
  'module',
  'ace/line_widgets',
  'ace/lib/dom',
  'ace/range'
], function (require, exports, module) {
  var LineWidgets = require('ace/line_widgets').LineWidgets;
  var dom = require('ace/lib/dom');
  var Range = require('ace/range').Range;
  function binarySearch(array, needle, comparator) {
    var first = 0;
    var last = array.length - 1;
    while (first <= last) {
      var mid = first + last >> 1;
      var c = comparator(needle, array[mid]);
      if (c > 0)
        first = mid + 1;
      else if (c < 0)
        last = mid - 1;
      else
        return mid;
    }
    return -(first + 1);
  }
  function findAnnotations(session, row, dir) {
    var annotations = session.getAnnotations().sort(Range.comparePoints);
    if (!annotations.length)
      return;
    var i = binarySearch(annotations, {
        row: row,
        column: -1
      }, Range.comparePoints);
    if (i < 0)
      i = -i - 1;
    if (i >= annotations.length - 1)
      i = dir > 0 ? 0 : annotations.length - 1;
    else if (i === 0 && dir < 0)
      i = annotations.length - 1;
    var annotation = annotations[i];
    if (!annotation || !dir)
      return;
    if (annotation.row === row) {
      do {
        annotation = annotations[i += dir];
      } while (annotation && annotation.row === row);
      if (!annotation)
        return annotations.slice();
    }
    var matched = [];
    row = annotation.row;
    do {
      matched[dir < 0 ? 'unshift' : 'push'](annotation);
      annotation = annotations[i += dir];
    } while (annotation && annotation.row == row);
    return matched.length && matched;
  }
  exports.showErrorMarker = function (editor, dir) {
    var session = editor.session;
    if (!session.widgetManager) {
      session.widgetManager = new LineWidgets(session);
      session.widgetManager.attach(editor);
    }
    var pos = editor.getCursorPosition();
    var row = pos.row;
    var oldWidget = session.lineWidgets && session.lineWidgets[row];
    if (oldWidget) {
      oldWidget.destroy();
    } else {
      row -= dir;
    }
    var annotations = findAnnotations(session, row, dir);
    var gutterAnno;
    if (annotations) {
      var annotation = annotations[0];
      pos.column = (annotation.pos && typeof annotation.column != 'number' ? annotation.pos.sc : annotation.column) || 0;
      pos.row = annotation.row;
      gutterAnno = editor.renderer.$gutterLayer.$annotations[pos.row];
    } else if (oldWidget) {
      return;
    } else {
      gutterAnno = {
        text: ['Looks good!'],
        className: 'ace_ok'
      };
    }
    editor.session.unfold(pos.row);
    editor.selection.moveToPosition(pos);
    var w = {
        row: pos.row,
        fixedWidth: true,
        coverGutter: true,
        el: dom.createElement('div')
      };
    var el = w.el.appendChild(dom.createElement('div'));
    var arrow = w.el.appendChild(dom.createElement('div'));
    arrow.className = 'error_widget_arrow ' + gutterAnno.className;
    var left = editor.renderer.$cursorLayer.getPixelPosition(pos).left;
    arrow.style.left = left + editor.renderer.gutterWidth - 5 + 'px';
    w.el.className = 'error_widget_wrapper';
    el.className = 'error_widget ' + gutterAnno.className;
    el.innerHTML = gutterAnno.text.join('<br>');
    el.appendChild(dom.createElement('div'));
    var kb = function (_, hashId, keyString) {
      if (hashId === 0 && (keyString === 'esc' || keyString === 'return')) {
        w.destroy();
        return { command: 'null' };
      }
    };
    w.destroy = function () {
      if (editor.$mouseHandler.isMousePressed)
        return;
      editor.keyBinding.removeKeyboardHandler(kb);
      session.widgetManager.removeLineWidget(w);
      editor.off('changeSelection', w.destroy);
      editor.off('changeSession', w.destroy);
      editor.off('mouseup', w.destroy);
      editor.off('change', w.destroy);
    };
    editor.keyBinding.addKeyboardHandler(kb);
    editor.on('changeSelection', w.destroy);
    editor.on('changeSession', w.destroy);
    editor.on('mouseup', w.destroy);
    editor.on('change', w.destroy);
    editor.session.widgetManager.addLineWidget(w);
    w.el.onmousedown = editor.focus.bind(editor);
    editor.renderer.scrollCursorIntoView(null, 0.5, { bottom: w.el.offsetHeight });
  };
  dom.importCssString('    .error_widget_wrapper {        background: inherit;        color: inherit;        border:none    }    .error_widget {        border-top: solid 2px;        border-bottom: solid 2px;        margin: 5px 0;        padding: 10px 40px;        white-space: pre-wrap;    }    .error_widget.ace_error, .error_widget_arrow.ace_error{        border-color: #ff5a5a    }    .error_widget.ace_warning, .error_widget_arrow.ace_warning{        border-color: #F1D817    }    .error_widget.ace_info, .error_widget_arrow.ace_info{        border-color: #5a5a5a    }    .error_widget.ace_ok, .error_widget_arrow.ace_ok{        border-color: #5aaa5a    }    .error_widget_arrow {        position: absolute;        border: solid 5px;        border-top-color: transparent!important;        border-right-color: transparent!important;        border-left-color: transparent!important;        top: -5px;    }', '');
});
ace.define('ace/lib/fixoldbrowsers', [
  'require',
  'exports',
  'module',
  'ace/lib/regexp',
  'ace/lib/es5-shim'
], function (require, exports, module) {
  require('./regexp');
  require('./es5-shim');
});
ace.define('ace/line_widgets', [
  'require',
  'exports',
  'module',
  'ace/lib/oop',
  'ace/lib/dom',
  'ace/range'
], function (require, exports, module) {
  var oop = require('./lib/oop');
  var dom = require('./lib/dom');
  var Range = require('./range').Range;
  function LineWidgets(session) {
    this.session = session;
    this.session.widgetManager = this;
    this.session.getRowLength = this.getRowLength;
    this.session.$getWidgetScreenLength = this.$getWidgetScreenLength;
    this.updateOnChange = this.updateOnChange.bind(this);
    this.renderWidgets = this.renderWidgets.bind(this);
    this.measureWidgets = this.measureWidgets.bind(this);
    this.session._changedWidgets = [];
    this.detach = this.detach.bind(this);
    this.session.on('change', this.updateOnChange);
  }
  (function () {
    this.getRowLength = function (row) {
      var h;
      if (this.lineWidgets)
        h = this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;
      else
        h = 0;
      if (!this.$useWrapMode || !this.$wrapData[row]) {
        return 1 + h;
      } else {
        return this.$wrapData[row].length + 1 + h;
      }
    };
    this.$getWidgetScreenLength = function () {
      var screenRows = 0;
      this.lineWidgets.forEach(function (w) {
        if (w && w.rowCount)
          screenRows += w.rowCount;
      });
      return screenRows;
    };
    this.attach = function (editor) {
      if (editor.widgetManager && editor.widgetManager != this)
        editor.widgetManager.detach();
      if (this.editor == editor)
        return;
      this.detach();
      this.editor = editor;
      this.editor.on('changeSession', this.detach);
      editor.widgetManager = this;
      editor.setOption('enableLineWidgets', true);
      editor.renderer.on('beforeRender', this.measureWidgets);
      editor.renderer.on('afterRender', this.renderWidgets);
    };
    this.detach = function (e) {
      if (e && e.session == this.session)
        return;
      var editor = this.editor;
      if (!editor)
        return;
      editor.off('changeSession', this.detach);
      this.editor = null;
      editor.widgetManager = null;
      editor.renderer.off('beforeRender', this.measureWidgets);
      editor.renderer.off('afterRender', this.renderWidgets);
      var lineWidgets = this.session.lineWidgets;
      lineWidgets && lineWidgets.forEach(function (w) {
        if (w && w.el && w.el.parentNode) {
          w._inDocument = false;
          w.el.parentNode.removeChild(w.el);
        }
      });
    };
    this.updateOnChange = function (e) {
      var lineWidgets = this.session.lineWidgets;
      if (!lineWidgets)
        return;
      var delta = e.data;
      var range = delta.range;
      var startRow = range.start.row;
      var len = range.end.row - startRow;
      if (len === 0) {
      } else if (delta.action == 'removeText' || delta.action == 'removeLines') {
        var removed = lineWidgets.splice(startRow + 1, len);
        removed.forEach(function (w) {
          w && this.removeLineWidget(w);
        }, this);
        this.$updateRows();
      } else {
        var args = new Array(len);
        args.unshift(startRow, 0);
        lineWidgets.splice.apply(lineWidgets, args);
        this.$updateRows();
      }
    };
    this.$updateRows = function () {
      var lineWidgets = this.session.lineWidgets;
      if (!lineWidgets)
        return;
      var noWidgets = true;
      lineWidgets.forEach(function (w, i) {
        if (w) {
          noWidgets = false;
          w.row = i;
        }
      });
      if (noWidgets)
        this.session.lineWidgets = null;
    };
    this.addLineWidget = function (w) {
      if (!this.session.lineWidgets)
        this.session.lineWidgets = new Array(this.session.getLength());
      this.session.lineWidgets[w.row] = w;
      var renderer = this.editor.renderer;
      if (w.html && !w.el) {
        w.el = dom.createElement('div');
        w.el.innerHTML = w.html;
      }
      if (w.el) {
        dom.addCssClass(w.el, 'ace_lineWidgetContainer');
        w.el.style.position = 'absolute';
        w.el.style.zIndex = 5;
        renderer.container.appendChild(w.el);
        w._inDocument = true;
      }
      if (!w.coverGutter) {
        w.el.style.zIndex = 3;
      }
      if (!w.pixelHeight) {
        w.pixelHeight = w.el.offsetHeight;
      }
      if (w.rowCount == null)
        w.rowCount = w.pixelHeight / renderer.layerConfig.lineHeight;
      this.session._emit('changeFold', { data: { start: { row: w.row } } });
      this.$updateRows();
      this.renderWidgets(null, renderer);
      return w;
    };
    this.removeLineWidget = function (w) {
      w._inDocument = false;
      if (w.el && w.el.parentNode)
        w.el.parentNode.removeChild(w.el);
      if (w.editor && w.editor.destroy)
        try {
          w.editor.destroy();
        } catch (e) {
        }
      if (this.session.lineWidgets)
        this.session.lineWidgets[w.row] = undefined;
      this.session._emit('changeFold', { data: { start: { row: w.row } } });
      this.$updateRows();
    };
    this.onWidgetChanged = function (w) {
      this.session._changedWidgets.push(w);
      this.editor && this.editor.renderer.updateFull();
    };
    this.measureWidgets = function (e, renderer) {
      var changedWidgets = this.session._changedWidgets;
      var config = renderer.layerConfig;
      if (!changedWidgets || !changedWidgets.length)
        return;
      var min = Infinity;
      for (var i = 0; i < changedWidgets.length; i++) {
        var w = changedWidgets[i];
        if (!w._inDocument) {
          w._inDocument = true;
          renderer.container.appendChild(w.el);
        }
        w.h = w.el.offsetHeight;
        if (!w.fixedWidth) {
          w.w = w.el.offsetWidth;
          w.screenWidth = Math.ceil(w.w / config.characterWidth);
        }
        var rowCount = w.h / config.lineHeight;
        if (w.coverLine) {
          rowCount -= this.session.getRowLineCount(w.row);
          if (rowCount < 0)
            rowCount = 0;
        }
        if (w.rowCount != rowCount) {
          w.rowCount = rowCount;
          if (w.row < min)
            min = w.row;
        }
      }
      if (min != Infinity) {
        this.session._emit('changeFold', { data: { start: { row: min } } });
        this.session.lineWidgetWidth = null;
      }
      this.session._changedWidgets = [];
    };
    this.renderWidgets = function (e, renderer) {
      var config = renderer.layerConfig;
      var lineWidgets = this.session.lineWidgets;
      if (!lineWidgets)
        return;
      var first = Math.min(this.firstRow, config.firstRow);
      var last = Math.max(this.lastRow, config.lastRow, lineWidgets.length);
      while (first > 0 && !lineWidgets[first])
        first--;
      this.firstRow = config.firstRow;
      this.lastRow = config.lastRow;
      renderer.$cursorLayer.config = config;
      for (var i = first; i <= last; i++) {
        var w = lineWidgets[i];
        if (!w || !w.el)
          continue;
        if (!w._inDocument) {
          w._inDocument = true;
          renderer.container.appendChild(w.el);
        }
        var top = renderer.$cursorLayer.getPixelPosition({
            row: i,
            column: 0
          }, true).top;
        if (!w.coverLine)
          top += config.lineHeight * this.session.getRowLineCount(w.row);
        w.el.style.top = top - config.offset + 'px';
        var left = w.coverGutter ? 0 : renderer.gutterWidth;
        if (!w.fixedWidth)
          left -= renderer.scrollLeft;
        w.el.style.left = left + 'px';
        if (w.fixedWidth) {
          w.el.style.right = renderer.scrollBar.getWidth() + 'px';
        } else {
          w.el.style.right = '';
        }
      }
    };
  }.call(LineWidgets.prototype));
  exports.LineWidgets = LineWidgets;
});
ace.define('ace/document', [
  'require',
  'exports',
  'module',
  'ace/lib/oop',
  'ace/lib/event_emitter',
  'ace/range',
  'ace/anchor'
], function (require, exports, module) {
  var oop = require('./lib/oop');
  var EventEmitter = require('./lib/event_emitter').EventEmitter;
  var Range = require('./range').Range;
  var Anchor = require('./anchor').Anchor;
  var Document = function (text) {
    this.$lines = [];
    if (text.length === 0) {
      this.$lines = [''];
    } else if (Array.isArray(text)) {
      this._insertLines(0, text);
    } else {
      this.insert({
        row: 0,
        column: 0
      }, text);
    }
  };
  (function () {
    oop.implement(this, EventEmitter);
    this.setValue = function (text) {
      var len = this.getLength();
      this.remove(new Range(0, 0, len, this.getLine(len - 1).length));
      this.insert({
        row: 0,
        column: 0
      }, text);
    };
    this.getValue = function () {
      return this.getAllLines().join(this.getNewLineCharacter());
    };
    this.createAnchor = function (row, column) {
      return new Anchor(this, row, column);
    };
    if ('aaa'.split(/a/).length === 0)
      this.$split = function (text) {
        return text.replace(/\r\n|\r/g, '\n').split('\n');
      };
    else
      this.$split = function (text) {
        return text.split(/\r\n|\r|\n/);
      };
    this.$detectNewLine = function (text) {
      var match = text.match(/^.*?(\r\n|\r|\n)/m);
      this.$autoNewLine = match ? match[1] : '\n';
      this._signal('changeNewLineMode');
    };
    this.getNewLineCharacter = function () {
      switch (this.$newLineMode) {
      case 'windows':
        return '\r\n';
      case 'unix':
        return '\n';
      default:
        return this.$autoNewLine || '\n';
      }
    };
    this.$autoNewLine = '';
    this.$newLineMode = 'auto';
    this.setNewLineMode = function (newLineMode) {
      if (this.$newLineMode === newLineMode)
        return;
      this.$newLineMode = newLineMode;
      this._signal('changeNewLineMode');
    };
    this.getNewLineMode = function () {
      return this.$newLineMode;
    };
    this.isNewLine = function (text) {
      return text == '\r\n' || text == '\r' || text == '\n';
    };
    this.getLine = function (row) {
      return this.$lines[row] || '';
    };
    this.getLines = function (firstRow, lastRow) {
      return this.$lines.slice(firstRow, lastRow + 1);
    };
    this.getAllLines = function () {
      return this.getLines(0, this.getLength());
    };
    this.getLength = function () {
      return this.$lines.length;
    };
    this.getTextRange = function (range) {
      if (range.start.row == range.end.row) {
        return this.getLine(range.start.row).substring(range.start.column, range.end.column);
      }
      var lines = this.getLines(range.start.row, range.end.row);
      lines[0] = (lines[0] || '').substring(range.start.column);
      var l = lines.length - 1;
      if (range.end.row - range.start.row == l)
        lines[l] = lines[l].substring(0, range.end.column);
      return lines.join(this.getNewLineCharacter());
    };
    this.$clipPosition = function (position) {
      var length = this.getLength();
      if (position.row >= length) {
        position.row = Math.max(0, length - 1);
        position.column = this.getLine(length - 1).length;
      } else if (position.row < 0)
        position.row = 0;
      return position;
    };
    this.insert = function (position, text) {
      if (!text || text.length === 0)
        return position;
      position = this.$clipPosition(position);
      if (this.getLength() <= 1)
        this.$detectNewLine(text);
      var lines = this.$split(text);
      var firstLine = lines.splice(0, 1)[0];
      var lastLine = lines.length == 0 ? null : lines.splice(lines.length - 1, 1)[0];
      position = this.insertInLine(position, firstLine);
      if (lastLine !== null) {
        position = this.insertNewLine(position);
        position = this._insertLines(position.row, lines);
        position = this.insertInLine(position, lastLine || '');
      }
      return position;
    };
    this.insertLines = function (row, lines) {
      if (row >= this.getLength())
        return this.insert({
          row: row,
          column: 0
        }, '\n' + lines.join('\n'));
      return this._insertLines(Math.max(row, 0), lines);
    };
    this._insertLines = function (row, lines) {
      if (lines.length == 0)
        return {
          row: row,
          column: 0
        };
      while (lines.length > 61440) {
        var end = this._insertLines(row, lines.slice(0, 61440));
        lines = lines.slice(61440);
        row = end.row;
      }
      var args = [
          row,
          0
        ];
      args.push.apply(args, lines);
      this.$lines.splice.apply(this.$lines, args);
      var range = new Range(row, 0, row + lines.length, 0);
      var delta = {
          action: 'insertLines',
          range: range,
          lines: lines
        };
      this._signal('change', { data: delta });
      return range.end;
    };
    this.insertNewLine = function (position) {
      position = this.$clipPosition(position);
      var line = this.$lines[position.row] || '';
      this.$lines[position.row] = line.substring(0, position.column);
      this.$lines.splice(position.row + 1, 0, line.substring(position.column, line.length));
      var end = {
          row: position.row + 1,
          column: 0
        };
      var delta = {
          action: 'insertText',
          range: Range.fromPoints(position, end),
          text: this.getNewLineCharacter()
        };
      this._signal('change', { data: delta });
      return end;
    };
    this.insertInLine = function (position, text) {
      if (text.length == 0)
        return position;
      var line = this.$lines[position.row] || '';
      this.$lines[position.row] = line.substring(0, position.column) + text + line.substring(position.column);
      var end = {
          row: position.row,
          column: position.column + text.length
        };
      var delta = {
          action: 'insertText',
          range: Range.fromPoints(position, end),
          text: text
        };
      this._signal('change', { data: delta });
      return end;
    };
    this.remove = function (range) {
      if (!(range instanceof Range))
        range = Range.fromPoints(range.start, range.end);
      range.start = this.$clipPosition(range.start);
      range.end = this.$clipPosition(range.end);
      if (range.isEmpty())
        return range.start;
      var firstRow = range.start.row;
      var lastRow = range.end.row;
      if (range.isMultiLine()) {
        var firstFullRow = range.start.column == 0 ? firstRow : firstRow + 1;
        var lastFullRow = lastRow - 1;
        if (range.end.column > 0)
          this.removeInLine(lastRow, 0, range.end.column);
        if (lastFullRow >= firstFullRow)
          this._removeLines(firstFullRow, lastFullRow);
        if (firstFullRow != firstRow) {
          this.removeInLine(firstRow, range.start.column, this.getLine(firstRow).length);
          this.removeNewLine(range.start.row);
        }
      } else {
        this.removeInLine(firstRow, range.start.column, range.end.column);
      }
      return range.start;
    };
    this.removeInLine = function (row, startColumn, endColumn) {
      if (startColumn == endColumn)
        return;
      var range = new Range(row, startColumn, row, endColumn);
      var line = this.getLine(row);
      var removed = line.substring(startColumn, endColumn);
      var newLine = line.substring(0, startColumn) + line.substring(endColumn, line.length);
      this.$lines.splice(row, 1, newLine);
      var delta = {
          action: 'removeText',
          range: range,
          text: removed
        };
      this._signal('change', { data: delta });
      return range.start;
    };
    this.removeLines = function (firstRow, lastRow) {
      if (firstRow < 0 || lastRow >= this.getLength())
        return this.remove(new Range(firstRow, 0, lastRow + 1, 0));
      return this._removeLines(firstRow, lastRow);
    };
    this._removeLines = function (firstRow, lastRow) {
      var range = new Range(firstRow, 0, lastRow + 1, 0);
      var removed = this.$lines.splice(firstRow, lastRow - firstRow + 1);
      var delta = {
          action: 'removeLines',
          range: range,
          nl: this.getNewLineCharacter(),
          lines: removed
        };
      this._signal('change', { data: delta });
      return removed;
    };
    this.removeNewLine = function (row) {
      var firstLine = this.getLine(row);
      var secondLine = this.getLine(row + 1);
      var range = new Range(row, firstLine.length, row + 1, 0);
      var line = firstLine + secondLine;
      this.$lines.splice(row, 2, line);
      var delta = {
          action: 'removeText',
          range: range,
          text: this.getNewLineCharacter()
        };
      this._signal('change', { data: delta });
    };
    this.replace = function (range, text) {
      if (!(range instanceof Range))
        range = Range.fromPoints(range.start, range.end);
      if (text.length == 0 && range.isEmpty())
        return range.start;
      if (text == this.getTextRange(range))
        return range.end;
      this.remove(range);
      if (text) {
        var end = this.insert(range.start, text);
      } else {
        end = range.start;
      }
      return end;
    };
    this.applyDeltas = function (deltas) {
      for (var i = 0; i < deltas.length; i++) {
        var delta = deltas[i];
        var range = Range.fromPoints(delta.range.start, delta.range.end);
        if (delta.action == 'insertLines')
          this.insertLines(range.start.row, delta.lines);
        else if (delta.action == 'insertText')
          this.insert(range.start, delta.text);
        else if (delta.action == 'removeLines')
          this._removeLines(range.start.row, range.end.row - 1);
        else if (delta.action == 'removeText')
          this.remove(range);
      }
    };
    this.revertDeltas = function (deltas) {
      for (var i = deltas.length - 1; i >= 0; i--) {
        var delta = deltas[i];
        var range = Range.fromPoints(delta.range.start, delta.range.end);
        if (delta.action == 'insertLines')
          this._removeLines(range.start.row, range.end.row - 1);
        else if (delta.action == 'insertText')
          this.remove(range);
        else if (delta.action == 'removeLines')
          this._insertLines(range.start.row, delta.lines);
        else if (delta.action == 'removeText')
          this.insert(range.start, delta.text);
      }
    };
    this.indexToPosition = function (index, startRow) {
      var lines = this.$lines || this.getAllLines();
      var newlineLength = this.getNewLineCharacter().length;
      for (var i = startRow || 0, l = lines.length; i < l; i++) {
        index -= lines[i].length + newlineLength;
        if (index < 0)
          return {
            row: i,
            column: index + lines[i].length + newlineLength
          };
      }
      return {
        row: l - 1,
        column: lines[l - 1].length
      };
    };
    this.positionToIndex = function (pos, startRow) {
      var lines = this.$lines || this.getAllLines();
      var newlineLength = this.getNewLineCharacter().length;
      var index = 0;
      var row = Math.min(pos.row, lines.length);
      for (var i = startRow || 0; i < row; ++i)
        index += lines[i].length + newlineLength;
      return index + pos.column;
    };
  }.call(Document.prototype));
  exports.Document = Document;
});
;
(function () {
  ace.require(['ace/ace'], function (a) {
    a && a.config.init(true);
    if (!window.ace)
      window.ace = a;
    for (var key in a)
      if (a.hasOwnProperty(key))
        ace[key] = a[key];
  });
}());
ace.define('ace/mode/python', [
  'require',
  'exports',
  'module',
  'ace/lib/oop',
  'ace/mode/text',
  'ace/tokenizer',
  'ace/mode/python_highlight_rules',
  'ace/mode/folding/pythonic',
  'ace/range'
], function (require, exports, module) {
  var oop = require('../lib/oop');
  var TextMode = require('./text').Mode;
  var Tokenizer = require('../tokenizer').Tokenizer;
  var PythonHighlightRules = require('./python_highlight_rules').PythonHighlightRules;
  var PythonFoldMode = require('./folding/pythonic').FoldMode;
  var Range = require('../range').Range;
  var Mode = function () {
    this.HighlightRules = PythonHighlightRules;
    this.foldingRules = new PythonFoldMode('\\:');
  };
  oop.inherits(Mode, TextMode);
  (function () {
    this.lineCommentStart = '#';
    this.getNextLineIndent = function (state, line, tab) {
      var indent = this.$getIndent(line);
      var tokenizedLine = this.getTokenizer().getLineTokens(line, state);
      var tokens = tokenizedLine.tokens;
      if (tokens.length && tokens[tokens.length - 1].type == 'comment') {
        return indent;
      }
      if (state == 'start') {
        var match = line.match(/^.*[\{\(\[\:]\s*$/);
        if (match) {
          indent += tab;
        }
      }
      return indent;
    };
    var outdents = {
        'pass': 1,
        'return': 1,
        'raise': 1,
        'break': 1,
        'continue': 1
      };
    this.checkOutdent = function (state, line, input) {
      if (input !== '\r\n' && input !== '\r' && input !== '\n')
        return false;
      var tokens = this.getTokenizer().getLineTokens(line.trim(), state).tokens;
      if (!tokens)
        return false;
      do {
        var last = tokens.pop();
      } while (last && (last.type == 'comment' || last.type == 'text' && last.value.match(/^\s+$/)));
      if (!last)
        return false;
      return last.type == 'keyword' && outdents[last.value];
    };
    this.autoOutdent = function (state, doc, row) {
      row += 1;
      var indent = this.$getIndent(doc.getLine(row));
      var tab = doc.getTabString();
      if (indent.slice(-tab.length) == tab)
        doc.remove(new Range(row, indent.length - tab.length, row, indent.length));
    };
    this.$id = 'ace/mode/python';
  }.call(Mode.prototype));
  exports.Mode = Mode;
});
ace.define('ace/mode/python_highlight_rules', [
  'require',
  'exports',
  'module',
  'ace/lib/oop',
  'ace/mode/text_highlight_rules'
], function (require, exports, module) {
  var oop = require('../lib/oop');
  var TextHighlightRules = require('./text_highlight_rules').TextHighlightRules;
  var PythonHighlightRules = function () {
    var keywords = 'and|as|assert|break|class|continue|def|del|elif|else|except|exec|' + 'finally|for|from|global|if|import|in|is|lambda|not|or|pass|print|' + 'raise|return|try|while|with|yield';
    var builtinConstants = 'True|False|None|NotImplemented|Ellipsis|__debug__';
    var builtinFunctions = 'abs|divmod|input|open|staticmethod|all|enumerate|int|ord|str|any|' + 'eval|isinstance|pow|sum|basestring|execfile|issubclass|print|super|' + 'binfile|iter|property|tuple|bool|filter|len|range|type|bytearray|' + 'float|list|raw_input|unichr|callable|format|locals|reduce|unicode|' + 'chr|frozenset|long|reload|vars|classmethod|getattr|map|repr|xrange|' + 'cmp|globals|max|reversed|zip|compile|hasattr|memoryview|round|' + '__import__|complex|hash|min|set|apply|delattr|help|next|setattr|' + 'buffer|dict|hex|object|slice|coerce|dir|id|oct|sorted|intern';
    var keywordMapper = this.createKeywordMapper({
        'invalid.deprecated': 'debugger',
        'support.function': builtinFunctions,
        'constant.language': builtinConstants,
        'keyword': keywords
      }, 'identifier');
    var strPre = '(?:r|u|ur|R|U|UR|Ur|uR)?';
    var decimalInteger = '(?:(?:[1-9]\\d*)|(?:0))';
    var octInteger = '(?:0[oO]?[0-7]+)';
    var hexInteger = '(?:0[xX][\\dA-Fa-f]+)';
    var binInteger = '(?:0[bB][01]+)';
    var integer = '(?:' + decimalInteger + '|' + octInteger + '|' + hexInteger + '|' + binInteger + ')';
    var exponent = '(?:[eE][+-]?\\d+)';
    var fraction = '(?:\\.\\d+)';
    var intPart = '(?:\\d+)';
    var pointFloat = '(?:(?:' + intPart + '?' + fraction + ')|(?:' + intPart + '\\.))';
    var exponentFloat = '(?:(?:' + pointFloat + '|' + intPart + ')' + exponent + ')';
    var floatNumber = '(?:' + exponentFloat + '|' + pointFloat + ')';
    var stringEscape = '\\\\(x[0-9A-Fa-f]{2}|[0-7]{3}|[\\\\abfnrtv\'"]|U[0-9A-Fa-f]{8}|u[0-9A-Fa-f]{4})';
    this.$rules = {
      'start': [
        {
          token: 'comment',
          regex: '#.*$'
        },
        {
          token: 'string',
          regex: strPre + '"{3}',
          next: 'qqstring3'
        },
        {
          token: 'string',
          regex: strPre + '"(?=.)',
          next: 'qqstring'
        },
        {
          token: 'string',
          regex: strPre + '\'{3}',
          next: 'qstring3'
        },
        {
          token: 'string',
          regex: strPre + '\'(?=.)',
          next: 'qstring'
        },
        {
          token: 'constant.numeric',
          regex: '(?:' + floatNumber + '|\\d+)[jJ]\\b'
        },
        {
          token: 'constant.numeric',
          regex: floatNumber
        },
        {
          token: 'constant.numeric',
          regex: integer + '[lL]\\b'
        },
        {
          token: 'constant.numeric',
          regex: integer + '\\b'
        },
        {
          token: keywordMapper,
          regex: '[a-zA-Z_$][a-zA-Z0-9_$]*\\b'
        },
        {
          token: 'keyword.operator',
          regex: '\\+|\\-|\\*|\\*\\*|\\/|\\/\\/|%|<<|>>|&|\\||\\^|~|<|>|<=|=>|==|!=|<>|='
        },
        {
          token: 'paren.lparen',
          regex: '[\\[\\(\\{]'
        },
        {
          token: 'paren.rparen',
          regex: '[\\]\\)\\}]'
        },
        {
          token: 'text',
          regex: '\\s+'
        }
      ],
      'qqstring3': [
        {
          token: 'constant.language.escape',
          regex: stringEscape
        },
        {
          token: 'string',
          regex: '"{3}',
          next: 'start'
        },
        { defaultToken: 'string' }
      ],
      'qstring3': [
        {
          token: 'constant.language.escape',
          regex: stringEscape
        },
        {
          token: 'string',
          regex: '\'{3}',
          next: 'start'
        },
        { defaultToken: 'string' }
      ],
      'qqstring': [
        {
          token: 'constant.language.escape',
          regex: stringEscape
        },
        {
          token: 'string',
          regex: '\\\\$',
          next: 'qqstring'
        },
        {
          token: 'string',
          regex: '"|$',
          next: 'start'
        },
        { defaultToken: 'string' }
      ],
      'qstring': [
        {
          token: 'constant.language.escape',
          regex: stringEscape
        },
        {
          token: 'string',
          regex: '\\\\$',
          next: 'qstring'
        },
        {
          token: 'string',
          regex: '\'|$',
          next: 'start'
        },
        { defaultToken: 'string' }
      ]
    };
  };
  oop.inherits(PythonHighlightRules, TextHighlightRules);
  exports.PythonHighlightRules = PythonHighlightRules;
});
ace.define('ace/mode/folding/pythonic', [
  'require',
  'exports',
  'module',
  'ace/lib/oop',
  'ace/mode/folding/fold_mode'
], function (require, exports, module) {
  var oop = require('../../lib/oop');
  var BaseFoldMode = require('./fold_mode').FoldMode;
  var FoldMode = exports.FoldMode = function (markers) {
      this.foldingStartMarker = new RegExp('([\\[{])(?:\\s*)$|(' + markers + ')(?:\\s*)(?:#.*)?$');
    };
  oop.inherits(FoldMode, BaseFoldMode);
  (function () {
    this.getFoldWidgetRange = function (session, foldStyle, row) {
      var line = session.getLine(row);
      var match = line.match(this.foldingStartMarker);
      if (match) {
        if (match[1])
          return this.openingBracketBlock(session, match[1], row, match.index);
        if (match[2])
          return this.indentationBlock(session, row, match.index + match[2].length);
        return this.indentationBlock(session, row);
      }
    };
  }.call(FoldMode.prototype));
});
ace.define('ace/theme/monokai', [
  'require',
  'exports',
  'module',
  'ace/lib/dom'
], function (require, exports, module) {
  exports.isDark = true;
  exports.cssClass = 'ace-monokai';
  exports.cssText = '.ace-monokai .ace_gutter {background: #2F3129;color: #8F908A}.ace-monokai .ace_print-margin {width: 1px;background: #555651}.ace-monokai {background-color: #272822;color: #F8F8F2}.ace-monokai .ace_cursor {color: #F8F8F0}.ace-monokai .ace_marker-layer .ace_selection {background: #49483E}.ace-monokai.ace_multiselect .ace_selection.ace_start {box-shadow: 0 0 3px 0px #272822;border-radius: 2px}.ace-monokai .ace_marker-layer .ace_step {background: rgb(102, 82, 0)}.ace-monokai .ace_marker-layer .ace_bracket {margin: -1px 0 0 -1px;border: 1px solid #49483E}.ace-monokai .ace_marker-layer .ace_active-line {background: #202020}.ace-monokai .ace_gutter-active-line {background-color: #272727}.ace-monokai .ace_marker-layer .ace_selected-word {border: 1px solid #49483E}.ace-monokai .ace_invisible {color: #52524d}.ace-monokai .ace_entity.ace_name.ace_tag,.ace-monokai .ace_keyword,.ace-monokai .ace_meta.ace_tag,.ace-monokai .ace_storage {color: #F92672}.ace-monokai .ace_punctuation,.ace-monokai .ace_punctuation.ace_tag {color: #fff}.ace-monokai .ace_constant.ace_character,.ace-monokai .ace_constant.ace_language,.ace-monokai .ace_constant.ace_numeric,.ace-monokai .ace_constant.ace_other {color: #AE81FF}.ace-monokai .ace_invalid {color: #F8F8F0;background-color: #F92672}.ace-monokai .ace_invalid.ace_deprecated {color: #F8F8F0;background-color: #AE81FF}.ace-monokai .ace_support.ace_constant,.ace-monokai .ace_support.ace_function {color: #66D9EF}.ace-monokai .ace_fold {background-color: #A6E22E;border-color: #F8F8F2}.ace-monokai .ace_storage.ace_type,.ace-monokai .ace_support.ace_class,.ace-monokai .ace_support.ace_type {font-style: italic;color: #66D9EF}.ace-monokai .ace_entity.ace_name.ace_function,.ace-monokai .ace_entity.ace_other,.ace-monokai .ace_entity.ace_other.ace_attribute-name,.ace-monokai .ace_variable {color: #A6E22E}.ace-monokai .ace_variable.ace_parameter {font-style: italic;color: #FD971F}.ace-monokai .ace_string {color: #E6DB74}.ace-monokai .ace_comment {color: #75715E}.ace-monokai .ace_indent-guide {background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAEklEQVQImWPQ0FD0ZXBzd/wPAAjVAoxeSgNeAAAAAElFTkSuQmCC) right repeat-y}';
  var dom = require('../lib/dom');
  dom.importCssString(exports.cssText, exports.cssClass);
});
ace.define('ace/theme/twilight', [
  'require',
  'exports',
  'module',
  'ace/lib/dom'
], function (require, exports, module) {
  exports.isDark = true;
  exports.cssClass = 'ace-twilight';
  exports.cssText = '.ace-twilight .ace_gutter {background: #232323;color: #E2E2E2}.ace-twilight .ace_print-margin {width: 1px;background: #232323}.ace-twilight {background-color: #141414;color: #F8F8F8}.ace-twilight .ace_cursor {color: #A7A7A7}.ace-twilight .ace_marker-layer .ace_selection {background: rgba(221, 240, 255, 0.20)}.ace-twilight.ace_multiselect .ace_selection.ace_start {box-shadow: 0 0 3px 0px #141414;border-radius: 2px}.ace-twilight .ace_marker-layer .ace_step {background: rgb(102, 82, 0)}.ace-twilight .ace_marker-layer .ace_bracket {margin: -1px 0 0 -1px;border: 1px solid rgba(255, 255, 255, 0.25)}.ace-twilight .ace_marker-layer .ace_active-line {background: rgba(255, 255, 255, 0.031)}.ace-twilight .ace_gutter-active-line {background-color: rgba(255, 255, 255, 0.031)}.ace-twilight .ace_marker-layer .ace_selected-word {border: 1px solid rgba(221, 240, 255, 0.20)}.ace-twilight .ace_invisible {color: rgba(255, 255, 255, 0.25)}.ace-twilight .ace_keyword,.ace-twilight .ace_meta {color: #CDA869}.ace-twilight .ace_constant,.ace-twilight .ace_constant.ace_character,.ace-twilight .ace_constant.ace_character.ace_escape,.ace-twilight .ace_constant.ace_other,.ace-twilight .ace_heading,.ace-twilight .ace_markup.ace_heading,.ace-twilight .ace_support.ace_constant {color: #CF6A4C}.ace-twilight .ace_invalid.ace_illegal {color: #F8F8F8;background-color: rgba(86, 45, 86, 0.75)}.ace-twilight .ace_invalid.ace_deprecated {text-decoration: underline;font-style: italic;color: #D2A8A1}.ace-twilight .ace_support {color: #9B859D}.ace-twilight .ace_fold {background-color: #AC885B;border-color: #F8F8F8}.ace-twilight .ace_support.ace_function {color: #DAD085}.ace-twilight .ace_list,.ace-twilight .ace_markup.ace_list,.ace-twilight .ace_storage {color: #F9EE98}.ace-twilight .ace_entity.ace_name.ace_function,.ace-twilight .ace_meta.ace_tag,.ace-twilight .ace_variable {color: #AC885B}.ace-twilight .ace_string {color: #8F9D6A}.ace-twilight .ace_string.ace_regexp {color: #E9C062}.ace-twilight .ace_comment {font-style: italic;color: #5F5A60}.ace-twilight .ace_variable {color: #7587A6}.ace-twilight .ace_xml-pe {color: #494949}.ace-twilight .ace_indent-guide {background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAEklEQVQImWMQERFpYLC1tf0PAAgOAnPnhxyiAAAAAElFTkSuQmCC) right repeat-y}';
  var dom = require('../lib/dom');
  dom.importCssString(exports.cssText, exports.cssClass);
});
!function () {
  function n(n, t) {
    return t > n ? -1 : n > t ? 1 : n >= t ? 0 : 0 / 0;
  }
  function t(n) {
    return null != n && !isNaN(n);
  }
  function r(n) {
    return {
      left: function (t, r, e, u) {
        for (arguments.length < 3 && (e = 0), arguments.length < 4 && (u = t.length); u > e;) {
          var i = e + u >>> 1;
          n(t[i], r) < 0 ? e = i + 1 : u = i;
        }
        return e;
      },
      right: function (t, r, e, u) {
        for (arguments.length < 3 && (e = 0), arguments.length < 4 && (u = t.length); u > e;) {
          var i = e + u >>> 1;
          n(t[i], r) > 0 ? u = i : e = i + 1;
        }
        return e;
      }
    };
  }
  function e(n) {
    return n.length;
  }
  function u(n) {
    for (var t = 1; n * t % 1;)
      t *= 10;
    return t;
  }
  function i(n, t) {
    try {
      for (var r in t)
        Object.defineProperty(n.prototype, r, {
          value: t[r],
          enumerable: !1
        });
    } catch (e) {
      n.prototype = t;
    }
  }
  function o() {
  }
  function a(n) {
    return sa + n in this;
  }
  function c(n) {
    return n = sa + n, n in this && delete this[n];
  }
  function s() {
    var n = [];
    return this.forEach(function (t) {
      n.push(t);
    }), n;
  }
  function l() {
    var n = 0;
    for (var t in this)
      t.charCodeAt(0) === la && ++n;
    return n;
  }
  function f() {
    for (var n in this)
      if (n.charCodeAt(0) === la)
        return !1;
    return !0;
  }
  function h() {
  }
  function g(n, t, r) {
    return function () {
      var e = r.apply(t, arguments);
      return e === t ? n : e;
    };
  }
  function p(n, t) {
    if (t in n)
      return t;
    t = t.charAt(0).toUpperCase() + t.substring(1);
    for (var r = 0, e = fa.length; e > r; ++r) {
      var u = fa[r] + t;
      if (u in n)
        return u;
    }
  }
  function v() {
  }
  function d() {
  }
  function m(n) {
    function t() {
      for (var t, e = r, u = -1, i = e.length; ++u < i;)
        (t = e[u].on) && t.apply(this, arguments);
      return n;
    }
    var r = [], e = new o();
    return t.on = function (t, u) {
      var i, o = e.get(t);
      return arguments.length < 2 ? o && o.on : (o && (o.on = null, r = r.slice(0, i = r.indexOf(o)).concat(r.slice(i + 1)), e.remove(t)), u && r.push(e.set(t, { on: u })), n);
    }, t;
  }
  function y() {
    Bo.event.preventDefault();
  }
  function x() {
    for (var n, t = Bo.event; n = t.sourceEvent;)
      t = n;
    return t;
  }
  function M(n) {
    for (var t = new d(), r = 0, e = arguments.length; ++r < e;)
      t[arguments[r]] = m(t);
    return t.of = function (r, e) {
      return function (u) {
        try {
          var i = u.sourceEvent = Bo.event;
          u.target = n, Bo.event = u, t[u.type].apply(r, e);
        } finally {
          Bo.event = i;
        }
      };
    }, t;
  }
  function _(n) {
    return ga(n, ya), n;
  }
  function b(n) {
    return 'function' == typeof n ? n : function () {
      return pa(n, this);
    };
  }
  function w(n) {
    return 'function' == typeof n ? n : function () {
      return va(n, this);
    };
  }
  function S(n, t) {
    function r() {
      this.removeAttribute(n);
    }
    function e() {
      this.removeAttributeNS(n.space, n.local);
    }
    function u() {
      this.setAttribute(n, t);
    }
    function i() {
      this.setAttributeNS(n.space, n.local, t);
    }
    function o() {
      var r = t.apply(this, arguments);
      null == r ? this.removeAttribute(n) : this.setAttribute(n, r);
    }
    function a() {
      var r = t.apply(this, arguments);
      null == r ? this.removeAttributeNS(n.space, n.local) : this.setAttributeNS(n.space, n.local, r);
    }
    return n = Bo.ns.qualify(n), null == t ? n.local ? e : r : 'function' == typeof t ? n.local ? a : o : n.local ? i : u;
  }
  function k(n) {
    return n.trim().replace(/\s+/g, ' ');
  }
  function E(n) {
    return new RegExp('(?:^|\\s+)' + Bo.requote(n) + '(?:\\s+|$)', 'g');
  }
  function A(n) {
    return n.trim().split(/^|\s+/);
  }
  function C(n, t) {
    function r() {
      for (var r = -1; ++r < u;)
        n[r](this, t);
    }
    function e() {
      for (var r = -1, e = t.apply(this, arguments); ++r < u;)
        n[r](this, e);
    }
    n = A(n).map(N);
    var u = n.length;
    return 'function' == typeof t ? e : r;
  }
  function N(n) {
    var t = E(n);
    return function (r, e) {
      if (u = r.classList)
        return e ? u.add(n) : u.remove(n);
      var u = r.getAttribute('class') || '';
      e ? (t.lastIndex = 0, t.test(u) || r.setAttribute('class', k(u + ' ' + n))) : r.setAttribute('class', k(u.replace(t, ' ')));
    };
  }
  function z(n, t, r) {
    function e() {
      this.style.removeProperty(n);
    }
    function u() {
      this.style.setProperty(n, t, r);
    }
    function i() {
      var e = t.apply(this, arguments);
      null == e ? this.style.removeProperty(n) : this.style.setProperty(n, e, r);
    }
    return null == t ? e : 'function' == typeof t ? i : u;
  }
  function L(n, t) {
    function r() {
      delete this[n];
    }
    function e() {
      this[n] = t;
    }
    function u() {
      var r = t.apply(this, arguments);
      null == r ? delete this[n] : this[n] = r;
    }
    return null == t ? r : 'function' == typeof t ? u : e;
  }
  function T(n) {
    return 'function' == typeof n ? n : (n = Bo.ns.qualify(n)).local ? function () {
      return this.ownerDocument.createElementNS(n.space, n.local);
    } : function () {
      return this.ownerDocument.createElementNS(this.namespaceURI, n);
    };
  }
  function q(n) {
    return { __data__: n };
  }
  function R(n) {
    return function () {
      return ma(this, n);
    };
  }
  function D(t) {
    return arguments.length || (t = n), function (n, r) {
      return n && r ? t(n.__data__, r.__data__) : !n - !r;
    };
  }
  function P(n, t) {
    for (var r = 0, e = n.length; e > r; r++)
      for (var u, i = n[r], o = 0, a = i.length; a > o; o++)
        (u = i[o]) && t(u, o, r);
    return n;
  }
  function U(n) {
    return ga(n, Ma), n;
  }
  function j(n) {
    var t, r;
    return function (e, u, i) {
      var o, a = n[i].update, c = a.length;
      for (i != r && (r = i, t = 0), u >= t && (t = u + 1); !(o = a[t]) && ++t < c;);
      return o;
    };
  }
  function H() {
    var n = this.__transition__;
    n && ++n.active;
  }
  function F(n, t, r) {
    function e() {
      var t = this[o];
      t && (this.removeEventListener(n, t, t.$), delete this[o]);
    }
    function u() {
      var u = c(t, Wo(arguments));
      e.call(this), this.addEventListener(n, this[o] = u, u.$ = r), u._ = t;
    }
    function i() {
      var t, r = new RegExp('^__on([^.]+)' + Bo.requote(n) + '$');
      for (var e in this)
        if (t = e.match(r)) {
          var u = this[e];
          this.removeEventListener(t[1], u, u.$), delete this[e];
        }
    }
    var o = '__on' + n, a = n.indexOf('.'), c = O;
    a > 0 && (n = n.substring(0, a));
    var s = ba.get(n);
    return s && (n = s, c = I), a ? t ? u : e : t ? v : i;
  }
  function O(n, t) {
    return function (r) {
      var e = Bo.event;
      Bo.event = r, t[0] = this.__data__;
      try {
        n.apply(this, t);
      } finally {
        Bo.event = e;
      }
    };
  }
  function I(n, t) {
    var r = O(n, t);
    return function (n) {
      var t = this, e = n.relatedTarget;
      e && (e === t || 8 & e.compareDocumentPosition(t)) || r.call(t, n);
    };
  }
  function Y() {
    var n = '.dragsuppress-' + ++Sa, t = 'click' + n, r = Bo.select(Qo).on('touchmove' + n, y).on('dragstart' + n, y).on('selectstart' + n, y);
    if (wa) {
      var e = Ko.style, u = e[wa];
      e[wa] = 'none';
    }
    return function (i) {
      function o() {
        r.on(t, null);
      }
      r.on(n, null), wa && (e[wa] = u), i && (r.on(t, function () {
        y(), o();
      }, !0), setTimeout(o, 0));
    };
  }
  function Z(n, t) {
    t.changedTouches && (t = t.changedTouches[0]);
    var r = n.ownerSVGElement || n;
    if (r.createSVGPoint) {
      var e = r.createSVGPoint();
      return e.x = t.clientX, e.y = t.clientY, e = e.matrixTransform(n.getScreenCTM().inverse()), [
        e.x,
        e.y
      ];
    }
    var u = n.getBoundingClientRect();
    return [
      t.clientX - u.left - n.clientLeft,
      t.clientY - u.top - n.clientTop
    ];
  }
  function V() {
    return Bo.event.changedTouches[0].identifier;
  }
  function $() {
    return Bo.event.target;
  }
  function X() {
    return Qo;
  }
  function B(n) {
    return n > 0 ? 1 : 0 > n ? -1 : 0;
  }
  function J(n, t, r) {
    return (t[0] - n[0]) * (r[1] - n[1]) - (t[1] - n[1]) * (r[0] - n[0]);
  }
  function W(n) {
    return n > 1 ? 0 : -1 > n ? ka : Math.acos(n);
  }
  function G(n) {
    return n > 1 ? Aa : -1 > n ? -Aa : Math.asin(n);
  }
  function K(n) {
    return ((n = Math.exp(n)) - 1 / n) / 2;
  }
  function Q(n) {
    return ((n = Math.exp(n)) + 1 / n) / 2;
  }
  function nt(n) {
    return ((n = Math.exp(2 * n)) - 1) / (n + 1);
  }
  function tt(n) {
    return (n = Math.sin(n / 2)) * n;
  }
  function rt() {
  }
  function et(n, t, r) {
    return new ut(n, t, r);
  }
  function ut(n, t, r) {
    this.h = n, this.s = t, this.l = r;
  }
  function it(n, t, r) {
    function e(n) {
      return n > 360 ? n -= 360 : 0 > n && (n += 360), 60 > n ? i + (o - i) * n / 60 : 180 > n ? o : 240 > n ? i + (o - i) * (240 - n) / 60 : i;
    }
    function u(n) {
      return Math.round(255 * e(n));
    }
    var i, o;
    return n = isNaN(n) ? 0 : (n %= 360) < 0 ? n + 360 : n, t = isNaN(t) ? 0 : 0 > t ? 0 : t > 1 ? 1 : t, r = 0 > r ? 0 : r > 1 ? 1 : r, o = 0.5 >= r ? r * (1 + t) : r + t - r * t, i = 2 * r - o, yt(u(n + 120), u(n), u(n - 120));
  }
  function ot(n, t, r) {
    return new at(n, t, r);
  }
  function at(n, t, r) {
    this.h = n, this.c = t, this.l = r;
  }
  function ct(n, t, r) {
    return isNaN(n) && (n = 0), isNaN(t) && (t = 0), st(r, Math.cos(n *= za) * t, Math.sin(n) * t);
  }
  function st(n, t, r) {
    return new lt(n, t, r);
  }
  function lt(n, t, r) {
    this.l = n, this.a = t, this.b = r;
  }
  function ft(n, t, r) {
    var e = (n + 16) / 116, u = e + t / 500, i = e - r / 200;
    return u = gt(u) * Oa, e = gt(e) * Ia, i = gt(i) * Ya, yt(vt(3.2404542 * u - 1.5371385 * e - 0.4985314 * i), vt(-0.969266 * u + 1.8760108 * e + 0.041556 * i), vt(0.0556434 * u - 0.2040259 * e + 1.0572252 * i));
  }
  function ht(n, t, r) {
    return n > 0 ? ot(Math.atan2(r, t) * La, Math.sqrt(t * t + r * r), n) : ot(0 / 0, 0 / 0, n);
  }
  function gt(n) {
    return n > 0.206893034 ? n * n * n : (n - 4 / 29) / 7.787037;
  }
  function pt(n) {
    return n > 0.008856 ? Math.pow(n, 1 / 3) : 7.787037 * n + 4 / 29;
  }
  function vt(n) {
    return Math.round(255 * (0.00304 >= n ? 12.92 * n : 1.055 * Math.pow(n, 1 / 2.4) - 0.055));
  }
  function dt(n) {
    return yt(n >> 16, 255 & n >> 8, 255 & n);
  }
  function mt(n) {
    return dt(n) + '';
  }
  function yt(n, t, r) {
    return new xt(n, t, r);
  }
  function xt(n, t, r) {
    this.r = n, this.g = t, this.b = r;
  }
  function Mt(n) {
    return 16 > n ? '0' + Math.max(0, n).toString(16) : Math.min(255, n).toString(16);
  }
  function _t(n, t, r) {
    var e, u, i, o = 0, a = 0, c = 0;
    if (e = /([a-z]+)\((.*)\)/i.exec(n))
      switch (u = e[2].split(','), e[1]) {
      case 'hsl':
        return r(parseFloat(u[0]), parseFloat(u[1]) / 100, parseFloat(u[2]) / 100);
      case 'rgb':
        return t(kt(u[0]), kt(u[1]), kt(u[2]));
      }
    return (i = $a.get(n)) ? t(i.r, i.g, i.b) : (null == n || '#' !== n.charAt(0) || isNaN(i = parseInt(n.substring(1), 16)) || (4 === n.length ? (o = (3840 & i) >> 4, o = o >> 4 | o, a = 240 & i, a = a >> 4 | a, c = 15 & i, c = c << 4 | c) : 7 === n.length && (o = (16711680 & i) >> 16, a = (65280 & i) >> 8, c = 255 & i)), t(o, a, c));
  }
  function bt(n, t, r) {
    var e, u, i = Math.min(n /= 255, t /= 255, r /= 255), o = Math.max(n, t, r), a = o - i, c = (o + i) / 2;
    return a ? (u = 0.5 > c ? a / (o + i) : a / (2 - o - i), e = n == o ? (t - r) / a + (r > t ? 6 : 0) : t == o ? (r - n) / a + 2 : (n - t) / a + 4, e *= 60) : (e = 0 / 0, u = c > 0 && 1 > c ? 0 : e), et(e, u, c);
  }
  function wt(n, t, r) {
    n = St(n), t = St(t), r = St(r);
    var e = pt((0.4124564 * n + 0.3575761 * t + 0.1804375 * r) / Oa), u = pt((0.2126729 * n + 0.7151522 * t + 0.072175 * r) / Ia), i = pt((0.0193339 * n + 0.119192 * t + 0.9503041 * r) / Ya);
    return st(116 * u - 16, 500 * (e - u), 200 * (u - i));
  }
  function St(n) {
    return (n /= 255) <= 0.04045 ? n / 12.92 : Math.pow((n + 0.055) / 1.055, 2.4);
  }
  function kt(n) {
    var t = parseFloat(n);
    return '%' === n.charAt(n.length - 1) ? Math.round(2.55 * t) : t;
  }
  function Et(n) {
    return 'function' == typeof n ? n : function () {
      return n;
    };
  }
  function At(n) {
    return n;
  }
  function Ct(n) {
    return function (t, r, e) {
      return 2 === arguments.length && 'function' == typeof r && (e = r, r = null), Nt(t, r, n, e);
    };
  }
  function Nt(n, t, r, e) {
    function u() {
      var n, t = c.status;
      if (!t && c.responseText || t >= 200 && 300 > t || 304 === t) {
        try {
          n = r.call(i, c);
        } catch (e) {
          return o.error.call(i, e), void 0;
        }
        o.load.call(i, n);
      } else
        o.error.call(i, c);
    }
    var i = {}, o = Bo.dispatch('beforesend', 'progress', 'load', 'error'), a = {}, c = new XMLHttpRequest(), s = null;
    return !Qo.XDomainRequest || 'withCredentials' in c || !/^(http(s)?:)?\/\//.test(n) || (c = new XDomainRequest()), 'onload' in c ? c.onload = c.onerror = u : c.onreadystatechange = function () {
      c.readyState > 3 && u();
    }, c.onprogress = function (n) {
      var t = Bo.event;
      Bo.event = n;
      try {
        o.progress.call(i, c);
      } finally {
        Bo.event = t;
      }
    }, i.header = function (n, t) {
      return n = (n + '').toLowerCase(), arguments.length < 2 ? a[n] : (null == t ? delete a[n] : a[n] = t + '', i);
    }, i.mimeType = function (n) {
      return arguments.length ? (t = null == n ? null : n + '', i) : t;
    }, i.responseType = function (n) {
      return arguments.length ? (s = n, i) : s;
    }, i.response = function (n) {
      return r = n, i;
    }, [
      'get',
      'post'
    ].forEach(function (n) {
      i[n] = function () {
        return i.send.apply(i, [n].concat(Wo(arguments)));
      };
    }), i.send = function (r, e, u) {
      if (2 === arguments.length && 'function' == typeof e && (u = e, e = null), c.open(r, n, !0), null == t || 'accept' in a || (a.accept = t + ',*/*'), c.setRequestHeader)
        for (var l in a)
          c.setRequestHeader(l, a[l]);
      return null != t && c.overrideMimeType && c.overrideMimeType(t), null != s && (c.responseType = s), null != u && i.on('error', u).on('load', function (n) {
        u(null, n);
      }), o.beforesend.call(i, c), c.send(null == e ? null : e), i;
    }, i.abort = function () {
      return c.abort(), i;
    }, Bo.rebind(i, o, 'on'), null == e ? i : i.get(zt(e));
  }
  function zt(n) {
    return 1 === n.length ? function (t, r) {
      n(null == t ? r : null);
    } : n;
  }
  function Lt() {
    var n = Tt(), t = qt() - n;
    t > 24 ? (isFinite(t) && (clearTimeout(Wa), Wa = setTimeout(Lt, t)), Ja = 0) : (Ja = 1, Ka(Lt));
  }
  function Tt() {
    var n = Date.now();
    for (Ga = Xa; Ga;)
      n >= Ga.t && (Ga.f = Ga.c(n - Ga.t)), Ga = Ga.n;
    return n;
  }
  function qt() {
    for (var n, t = Xa, r = 1 / 0; t;)
      t.f ? t = n ? n.n = t.n : Xa = t.n : (t.t < r && (r = t.t), t = (n = t).n);
    return Ba = n, r;
  }
  function Rt(n, t) {
    return t - (n ? Math.ceil(Math.log(n) / Math.LN10) : 1);
  }
  function Dt(n, t) {
    var r = Math.pow(10, 3 * ca(8 - t));
    return {
      scale: t > 8 ? function (n) {
        return n / r;
      } : function (n) {
        return n * r;
      },
      symbol: n
    };
  }
  function Pt(n) {
    var t = n.decimal, r = n.thousands, e = n.grouping, u = n.currency, i = e ? function (n) {
        for (var t = n.length, u = [], i = 0, o = e[0]; t > 0 && o > 0;)
          u.push(n.substring(t -= o, t + o)), o = e[i = (i + 1) % e.length];
        return u.reverse().join(r);
      } : At;
    return function (n) {
      var r = nc.exec(n), e = r[1] || ' ', o = r[2] || '>', a = r[3] || '', c = r[4] || '', s = r[5], l = +r[6], f = r[7], h = r[8], g = r[9], p = 1, v = '', d = '', m = !1;
      switch (h && (h = +h.substring(1)), (s || '0' === e && '=' === o) && (s = e = '0', o = '=', f && (l -= Math.floor((l - 1) / 4))), g) {
      case 'n':
        f = !0, g = 'g';
        break;
      case '%':
        p = 100, d = '%', g = 'f';
        break;
      case 'p':
        p = 100, d = '%', g = 'r';
        break;
      case 'b':
      case 'o':
      case 'x':
      case 'X':
        '#' === c && (v = '0' + g.toLowerCase());
      case 'c':
      case 'd':
        m = !0, h = 0;
        break;
      case 's':
        p = -1, g = 'r';
      }
      '$' === c && (v = u[0], d = u[1]), 'r' != g || h || (g = 'g'), null != h && ('g' == g ? h = Math.max(1, Math.min(21, h)) : ('e' == g || 'f' == g) && (h = Math.max(0, Math.min(20, h)))), g = tc.get(g) || Ut;
      var y = s && f;
      return function (n) {
        var r = d;
        if (m && n % 1)
          return '';
        var u = 0 > n || 0 === n && 0 > 1 / n ? (n = -n, '-') : a;
        if (0 > p) {
          var c = Bo.formatPrefix(n, h);
          n = c.scale(n), r = c.symbol + d;
        } else
          n *= p;
        n = g(n, h);
        var x = n.lastIndexOf('.'), M = 0 > x ? n : n.substring(0, x), _ = 0 > x ? '' : t + n.substring(x + 1);
        !s && f && (M = i(M));
        var b = v.length + M.length + _.length + (y ? 0 : u.length), w = l > b ? new Array(b = l - b + 1).join(e) : '';
        return y && (M = i(w + M)), u += v, n = M + _, ('<' === o ? u + n + w : '>' === o ? w + u + n : '^' === o ? w.substring(0, b >>= 1) + u + n + w.substring(b) : u + (y ? n : w + n)) + r;
      };
    };
  }
  function Ut(n) {
    return n + '';
  }
  function jt() {
    this._ = new Date(arguments.length > 1 ? Date.UTC.apply(this, arguments) : arguments[0]);
  }
  function Ht(n, t, r) {
    function e(t) {
      var r = n(t), e = i(r, 1);
      return e - t > t - r ? r : e;
    }
    function u(r) {
      return t(r = n(new ec(r - 1)), 1), r;
    }
    function i(n, r) {
      return t(n = new ec(+n), r), n;
    }
    function o(n, e, i) {
      var o = u(n), a = [];
      if (i > 1)
        for (; e > o;)
          r(o) % i || a.push(new Date(+o)), t(o, 1);
      else
        for (; e > o;)
          a.push(new Date(+o)), t(o, 1);
      return a;
    }
    function a(n, t, r) {
      try {
        ec = jt;
        var e = new jt();
        return e._ = n, o(e, t, r);
      } finally {
        ec = Date;
      }
    }
    n.floor = n, n.round = e, n.ceil = u, n.offset = i, n.range = o;
    var c = n.utc = Ft(n);
    return c.floor = c, c.round = Ft(e), c.ceil = Ft(u), c.offset = Ft(i), c.range = a, n;
  }
  function Ft(n) {
    return function (t, r) {
      try {
        ec = jt;
        var e = new jt();
        return e._ = t, n(e, r)._;
      } finally {
        ec = Date;
      }
    };
  }
  function Ot(n) {
    function t(n) {
      function t(t) {
        for (var r, u, i, o = [], a = -1, c = 0; ++a < e;)
          37 === n.charCodeAt(a) && (o.push(n.substring(c, a)), null != (u = ic[r = n.charAt(++a)]) && (r = n.charAt(++a)), (i = C[r]) && (r = i(t, null == u ? 'e' === r ? ' ' : '0' : u)), o.push(r), c = a + 1);
        return o.push(n.substring(c, a)), o.join('');
      }
      var e = n.length;
      return t.parse = function (t) {
        var e = {
            y: 1900,
            m: 0,
            d: 1,
            H: 0,
            M: 0,
            S: 0,
            L: 0,
            Z: null
          }, u = r(e, n, t, 0);
        if (u != t.length)
          return null;
        'p' in e && (e.H = e.H % 12 + 12 * e.p);
        var i = null != e.Z && ec !== jt, o = new (i ? jt : ec)();
        return 'j' in e ? o.setFullYear(e.y, 0, e.j) : 'w' in e && ('W' in e || 'U' in e) ? (o.setFullYear(e.y, 0, 1), o.setFullYear(e.y, 0, 'W' in e ? (e.w + 6) % 7 + 7 * e.W - (o.getDay() + 5) % 7 : e.w + 7 * e.U - (o.getDay() + 6) % 7)) : o.setFullYear(e.y, e.m, e.d), o.setHours(e.H + Math.floor(e.Z / 100), e.M + e.Z % 100, e.S, e.L), i ? o._ : o;
      }, t.toString = function () {
        return n;
      }, t;
    }
    function r(n, t, r, e) {
      for (var u, i, o, a = 0, c = t.length, s = r.length; c > a;) {
        if (e >= s)
          return -1;
        if (u = t.charCodeAt(a++), 37 === u) {
          if (o = t.charAt(a++), i = N[o in ic ? t.charAt(a++) : o], !i || (e = i(n, r, e)) < 0)
            return -1;
        } else if (u != r.charCodeAt(e++))
          return -1;
      }
      return e;
    }
    function e(n, t, r) {
      b.lastIndex = 0;
      var e = b.exec(t.substring(r));
      return e ? (n.w = w.get(e[0].toLowerCase()), r + e[0].length) : -1;
    }
    function u(n, t, r) {
      M.lastIndex = 0;
      var e = M.exec(t.substring(r));
      return e ? (n.w = _.get(e[0].toLowerCase()), r + e[0].length) : -1;
    }
    function i(n, t, r) {
      E.lastIndex = 0;
      var e = E.exec(t.substring(r));
      return e ? (n.m = A.get(e[0].toLowerCase()), r + e[0].length) : -1;
    }
    function o(n, t, r) {
      S.lastIndex = 0;
      var e = S.exec(t.substring(r));
      return e ? (n.m = k.get(e[0].toLowerCase()), r + e[0].length) : -1;
    }
    function a(n, t, e) {
      return r(n, C.c.toString(), t, e);
    }
    function c(n, t, e) {
      return r(n, C.x.toString(), t, e);
    }
    function s(n, t, e) {
      return r(n, C.X.toString(), t, e);
    }
    function l(n, t, r) {
      var e = x.get(t.substring(r, r += 2).toLowerCase());
      return null == e ? -1 : (n.p = e, r);
    }
    var f = n.dateTime, h = n.date, g = n.time, p = n.periods, v = n.days, d = n.shortDays, m = n.months, y = n.shortMonths;
    t.utc = function (n) {
      function r(n) {
        try {
          ec = jt;
          var t = new ec();
          return t._ = n, e(t);
        } finally {
          ec = Date;
        }
      }
      var e = t(n);
      return r.parse = function (n) {
        try {
          ec = jt;
          var t = e.parse(n);
          return t && t._;
        } finally {
          ec = Date;
        }
      }, r.toString = e.toString, r;
    }, t.multi = t.utc.multi = ar;
    var x = Bo.map(), M = Yt(v), _ = Zt(v), b = Yt(d), w = Zt(d), S = Yt(m), k = Zt(m), E = Yt(y), A = Zt(y);
    p.forEach(function (n, t) {
      x.set(n.toLowerCase(), t);
    });
    var C = {
        a: function (n) {
          return d[n.getDay()];
        },
        A: function (n) {
          return v[n.getDay()];
        },
        b: function (n) {
          return y[n.getMonth()];
        },
        B: function (n) {
          return m[n.getMonth()];
        },
        c: t(f),
        d: function (n, t) {
          return It(n.getDate(), t, 2);
        },
        e: function (n, t) {
          return It(n.getDate(), t, 2);
        },
        H: function (n, t) {
          return It(n.getHours(), t, 2);
        },
        I: function (n, t) {
          return It(n.getHours() % 12 || 12, t, 2);
        },
        j: function (n, t) {
          return It(1 + rc.dayOfYear(n), t, 3);
        },
        L: function (n, t) {
          return It(n.getMilliseconds(), t, 3);
        },
        m: function (n, t) {
          return It(n.getMonth() + 1, t, 2);
        },
        M: function (n, t) {
          return It(n.getMinutes(), t, 2);
        },
        p: function (n) {
          return p[+(n.getHours() >= 12)];
        },
        S: function (n, t) {
          return It(n.getSeconds(), t, 2);
        },
        U: function (n, t) {
          return It(rc.sundayOfYear(n), t, 2);
        },
        w: function (n) {
          return n.getDay();
        },
        W: function (n, t) {
          return It(rc.mondayOfYear(n), t, 2);
        },
        x: t(h),
        X: t(g),
        y: function (n, t) {
          return It(n.getFullYear() % 100, t, 2);
        },
        Y: function (n, t) {
          return It(n.getFullYear() % 10000, t, 4);
        },
        Z: ir,
        '%': function () {
          return '%';
        }
      }, N = {
        a: e,
        A: u,
        b: i,
        B: o,
        c: a,
        d: Qt,
        e: Qt,
        H: tr,
        I: tr,
        j: nr,
        L: ur,
        m: Kt,
        M: rr,
        p: l,
        S: er,
        U: $t,
        w: Vt,
        W: Xt,
        x: c,
        X: s,
        y: Jt,
        Y: Bt,
        Z: Wt,
        '%': or
      };
    return t;
  }
  function It(n, t, r) {
    var e = 0 > n ? '-' : '', u = (e ? -n : n) + '', i = u.length;
    return e + (r > i ? new Array(r - i + 1).join(t) + u : u);
  }
  function Yt(n) {
    return new RegExp('^(?:' + n.map(Bo.requote).join('|') + ')', 'i');
  }
  function Zt(n) {
    for (var t = new o(), r = -1, e = n.length; ++r < e;)
      t.set(n[r].toLowerCase(), r);
    return t;
  }
  function Vt(n, t, r) {
    oc.lastIndex = 0;
    var e = oc.exec(t.substring(r, r + 1));
    return e ? (n.w = +e[0], r + e[0].length) : -1;
  }
  function $t(n, t, r) {
    oc.lastIndex = 0;
    var e = oc.exec(t.substring(r));
    return e ? (n.U = +e[0], r + e[0].length) : -1;
  }
  function Xt(n, t, r) {
    oc.lastIndex = 0;
    var e = oc.exec(t.substring(r));
    return e ? (n.W = +e[0], r + e[0].length) : -1;
  }
  function Bt(n, t, r) {
    oc.lastIndex = 0;
    var e = oc.exec(t.substring(r, r + 4));
    return e ? (n.y = +e[0], r + e[0].length) : -1;
  }
  function Jt(n, t, r) {
    oc.lastIndex = 0;
    var e = oc.exec(t.substring(r, r + 2));
    return e ? (n.y = Gt(+e[0]), r + e[0].length) : -1;
  }
  function Wt(n, t, r) {
    return /^[+-]\d{4}$/.test(t = t.substring(r, r + 5)) ? (n.Z = -t, r + 5) : -1;
  }
  function Gt(n) {
    return n + (n > 68 ? 1900 : 2000);
  }
  function Kt(n, t, r) {
    oc.lastIndex = 0;
    var e = oc.exec(t.substring(r, r + 2));
    return e ? (n.m = e[0] - 1, r + e[0].length) : -1;
  }
  function Qt(n, t, r) {
    oc.lastIndex = 0;
    var e = oc.exec(t.substring(r, r + 2));
    return e ? (n.d = +e[0], r + e[0].length) : -1;
  }
  function nr(n, t, r) {
    oc.lastIndex = 0;
    var e = oc.exec(t.substring(r, r + 3));
    return e ? (n.j = +e[0], r + e[0].length) : -1;
  }
  function tr(n, t, r) {
    oc.lastIndex = 0;
    var e = oc.exec(t.substring(r, r + 2));
    return e ? (n.H = +e[0], r + e[0].length) : -1;
  }
  function rr(n, t, r) {
    oc.lastIndex = 0;
    var e = oc.exec(t.substring(r, r + 2));
    return e ? (n.M = +e[0], r + e[0].length) : -1;
  }
  function er(n, t, r) {
    oc.lastIndex = 0;
    var e = oc.exec(t.substring(r, r + 2));
    return e ? (n.S = +e[0], r + e[0].length) : -1;
  }
  function ur(n, t, r) {
    oc.lastIndex = 0;
    var e = oc.exec(t.substring(r, r + 3));
    return e ? (n.L = +e[0], r + e[0].length) : -1;
  }
  function ir(n) {
    var t = n.getTimezoneOffset(), r = t > 0 ? '-' : '+', e = ~~(ca(t) / 60), u = ca(t) % 60;
    return r + It(e, '0', 2) + It(u, '0', 2);
  }
  function or(n, t, r) {
    ac.lastIndex = 0;
    var e = ac.exec(t.substring(r, r + 1));
    return e ? r + e[0].length : -1;
  }
  function ar(n) {
    for (var t = n.length, r = -1; ++r < t;)
      n[r][0] = this(n[r][0]);
    return function (t) {
      for (var r = 0, e = n[r]; !e[1](t);)
        e = n[++r];
      return e[0](t);
    };
  }
  function cr() {
  }
  function sr(n, t, r) {
    var e = r.s = n + t, u = e - n, i = e - u;
    r.t = n - i + (t - u);
  }
  function lr(n, t) {
    n && fc.hasOwnProperty(n.type) && fc[n.type](n, t);
  }
  function fr(n, t, r) {
    var e, u = -1, i = n.length - r;
    for (t.lineStart(); ++u < i;)
      e = n[u], t.point(e[0], e[1], e[2]);
    t.lineEnd();
  }
  function hr(n, t) {
    var r = -1, e = n.length;
    for (t.polygonStart(); ++r < e;)
      fr(n[r], t, 1);
    t.polygonEnd();
  }
  function gr() {
    function n(n, t) {
      n *= za, t = t * za / 2 + ka / 4;
      var r = n - e, o = r >= 0 ? 1 : -1, a = o * r, c = Math.cos(t), s = Math.sin(t), l = i * s, f = u * c + l * Math.cos(a), h = l * o * Math.sin(a);
      gc.add(Math.atan2(h, f)), e = n, u = c, i = s;
    }
    var t, r, e, u, i;
    pc.point = function (o, a) {
      pc.point = n, e = (t = o) * za, u = Math.cos(a = (r = a) * za / 2 + ka / 4), i = Math.sin(a);
    }, pc.lineEnd = function () {
      n(t, r);
    };
  }
  function pr(n) {
    var t = n[0], r = n[1], e = Math.cos(r);
    return [
      e * Math.cos(t),
      e * Math.sin(t),
      Math.sin(r)
    ];
  }
  function vr(n, t) {
    return n[0] * t[0] + n[1] * t[1] + n[2] * t[2];
  }
  function dr(n, t) {
    return [
      n[1] * t[2] - n[2] * t[1],
      n[2] * t[0] - n[0] * t[2],
      n[0] * t[1] - n[1] * t[0]
    ];
  }
  function mr(n, t) {
    n[0] += t[0], n[1] += t[1], n[2] += t[2];
  }
  function yr(n, t) {
    return [
      n[0] * t,
      n[1] * t,
      n[2] * t
    ];
  }
  function xr(n) {
    var t = Math.sqrt(n[0] * n[0] + n[1] * n[1] + n[2] * n[2]);
    n[0] /= t, n[1] /= t, n[2] /= t;
  }
  function Mr(n) {
    return [
      Math.atan2(n[1], n[0]),
      G(n[2])
    ];
  }
  function _r(n, t) {
    return ca(n[0] - t[0]) < Ca && ca(n[1] - t[1]) < Ca;
  }
  function br(n, t) {
    n *= za;
    var r = Math.cos(t *= za);
    wr(r * Math.cos(n), r * Math.sin(n), Math.sin(t));
  }
  function wr(n, t, r) {
    ++vc, mc += (n - mc) / vc, yc += (t - yc) / vc, xc += (r - xc) / vc;
  }
  function Sr() {
    function n(n, u) {
      n *= za;
      var i = Math.cos(u *= za), o = i * Math.cos(n), a = i * Math.sin(n), c = Math.sin(u), s = Math.atan2(Math.sqrt((s = r * c - e * a) * s + (s = e * o - t * c) * s + (s = t * a - r * o) * s), t * o + r * a + e * c);
      dc += s, Mc += s * (t + (t = o)), _c += s * (r + (r = a)), bc += s * (e + (e = c)), wr(t, r, e);
    }
    var t, r, e;
    Ec.point = function (u, i) {
      u *= za;
      var o = Math.cos(i *= za);
      t = o * Math.cos(u), r = o * Math.sin(u), e = Math.sin(i), Ec.point = n, wr(t, r, e);
    };
  }
  function kr() {
    Ec.point = br;
  }
  function Er() {
    function n(n, t) {
      n *= za;
      var r = Math.cos(t *= za), o = r * Math.cos(n), a = r * Math.sin(n), c = Math.sin(t), s = u * c - i * a, l = i * o - e * c, f = e * a - u * o, h = Math.sqrt(s * s + l * l + f * f), g = e * o + u * a + i * c, p = h && -W(g) / h, v = Math.atan2(h, g);
      wc += p * s, Sc += p * l, kc += p * f, dc += v, Mc += v * (e + (e = o)), _c += v * (u + (u = a)), bc += v * (i + (i = c)), wr(e, u, i);
    }
    var t, r, e, u, i;
    Ec.point = function (o, a) {
      t = o, r = a, Ec.point = n, o *= za;
      var c = Math.cos(a *= za);
      e = c * Math.cos(o), u = c * Math.sin(o), i = Math.sin(a), wr(e, u, i);
    }, Ec.lineEnd = function () {
      n(t, r), Ec.lineEnd = kr, Ec.point = br;
    };
  }
  function Ar() {
    return !0;
  }
  function Cr(n, t, r, e, u) {
    var i = [], o = [];
    if (n.forEach(function (n) {
        if (!((t = n.length - 1) <= 0)) {
          var t, r = n[0], e = n[t];
          if (_r(r, e)) {
            u.lineStart();
            for (var a = 0; t > a; ++a)
              u.point((r = n[a])[0], r[1]);
            return u.lineEnd(), void 0;
          }
          var c = new zr(r, n, null, !0), s = new zr(r, null, c, !1);
          c.o = s, i.push(c), o.push(s), c = new zr(e, n, null, !1), s = new zr(e, null, c, !0), c.o = s, i.push(c), o.push(s);
        }
      }), o.sort(t), Nr(i), Nr(o), i.length) {
      for (var a = 0, c = r, s = o.length; s > a; ++a)
        o[a].e = c = !c;
      for (var l, f, h = i[0];;) {
        for (var g = h, p = !0; g.v;)
          if ((g = g.n) === h)
            return;
        l = g.z, u.lineStart();
        do {
          if (g.v = g.o.v = !0, g.e) {
            if (p)
              for (var a = 0, s = l.length; s > a; ++a)
                u.point((f = l[a])[0], f[1]);
            else
              e(g.x, g.n.x, 1, u);
            g = g.n;
          } else {
            if (p) {
              l = g.p.z;
              for (var a = l.length - 1; a >= 0; --a)
                u.point((f = l[a])[0], f[1]);
            } else
              e(g.x, g.p.x, -1, u);
            g = g.p;
          }
          g = g.o, l = g.z, p = !p;
        } while (!g.v);
        u.lineEnd();
      }
    }
  }
  function Nr(n) {
    if (t = n.length) {
      for (var t, r, e = 0, u = n[0]; ++e < t;)
        u.n = r = n[e], r.p = u, u = r;
      u.n = r = n[0], r.p = u;
    }
  }
  function zr(n, t, r, e) {
    this.x = n, this.z = t, this.o = r, this.e = e, this.v = !1, this.n = this.p = null;
  }
  function Lr(n, t, r, e) {
    return function (u, i) {
      function o(t, r) {
        var e = u(t, r);
        n(t = e[0], r = e[1]) && i.point(t, r);
      }
      function a(n, t) {
        var r = u(n, t);
        d.point(r[0], r[1]);
      }
      function c() {
        y.point = a, d.lineStart();
      }
      function s() {
        y.point = o, d.lineEnd();
      }
      function l(n, t) {
        v.push([
          n,
          t
        ]);
        var r = u(n, t);
        M.point(r[0], r[1]);
      }
      function f() {
        M.lineStart(), v = [];
      }
      function h() {
        l(v[0][0], v[0][1]), M.lineEnd();
        var n, t = M.clean(), r = x.buffer(), e = r.length;
        if (v.pop(), p.push(v), v = null, e)
          if (1 & t) {
            n = r[0];
            var u, e = n.length - 1, o = -1;
            if (e > 0) {
              for (_ || (i.polygonStart(), _ = !0), i.lineStart(); ++o < e;)
                i.point((u = n[o])[0], u[1]);
              i.lineEnd();
            }
          } else
            e > 1 && 2 & t && r.push(r.pop().concat(r.shift())), g.push(r.filter(Tr));
      }
      var g, p, v, d = t(i), m = u.invert(e[0], e[1]), y = {
          point: o,
          lineStart: c,
          lineEnd: s,
          polygonStart: function () {
            y.point = l, y.lineStart = f, y.lineEnd = h, g = [], p = [];
          },
          polygonEnd: function () {
            y.point = o, y.lineStart = c, y.lineEnd = s, g = Bo.merge(g);
            var n = Dr(m, p);
            g.length ? (_ || (i.polygonStart(), _ = !0), Cr(g, Rr, n, r, i)) : n && (_ || (i.polygonStart(), _ = !0), i.lineStart(), r(null, null, 1, i), i.lineEnd()), _ && (i.polygonEnd(), _ = !1), g = p = null;
          },
          sphere: function () {
            i.polygonStart(), i.lineStart(), r(null, null, 1, i), i.lineEnd(), i.polygonEnd();
          }
        }, x = qr(), M = t(x), _ = !1;
      return y;
    };
  }
  function Tr(n) {
    return n.length > 1;
  }
  function qr() {
    var n, t = [];
    return {
      lineStart: function () {
        t.push(n = []);
      },
      point: function (t, r) {
        n.push([
          t,
          r
        ]);
      },
      lineEnd: v,
      buffer: function () {
        var r = t;
        return t = [], n = null, r;
      },
      rejoin: function () {
        t.length > 1 && t.push(t.pop().concat(t.shift()));
      }
    };
  }
  function Rr(n, t) {
    return ((n = n.x)[0] < 0 ? n[1] - Aa - Ca : Aa - n[1]) - ((t = t.x)[0] < 0 ? t[1] - Aa - Ca : Aa - t[1]);
  }
  function Dr(n, t) {
    var r = n[0], e = n[1], u = [
        Math.sin(r),
        -Math.cos(r),
        0
      ], i = 0, o = 0;
    gc.reset();
    for (var a = 0, c = t.length; c > a; ++a) {
      var s = t[a], l = s.length;
      if (l)
        for (var f = s[0], h = f[0], g = f[1] / 2 + ka / 4, p = Math.sin(g), v = Math.cos(g), d = 1;;) {
          d === l && (d = 0), n = s[d];
          var m = n[0], y = n[1] / 2 + ka / 4, x = Math.sin(y), M = Math.cos(y), _ = m - h, b = _ >= 0 ? 1 : -1, w = b * _, S = w > ka, k = p * x;
          if (gc.add(Math.atan2(k * b * Math.sin(w), v * M + k * Math.cos(w))), i += S ? _ + b * Ea : _, S ^ h >= r ^ m >= r) {
            var E = dr(pr(f), pr(n));
            xr(E);
            var A = dr(u, E);
            xr(A);
            var C = (S ^ _ >= 0 ? -1 : 1) * G(A[2]);
            (e > C || e === C && (E[0] || E[1])) && (o += S ^ _ >= 0 ? 1 : -1);
          }
          if (!d++)
            break;
          h = m, p = x, v = M, f = n;
        }
    }
    return (-Ca > i || Ca > i && 0 > gc) ^ 1 & o;
  }
  function Pr(n) {
    var t, r = 0 / 0, e = 0 / 0, u = 0 / 0;
    return {
      lineStart: function () {
        n.lineStart(), t = 1;
      },
      point: function (i, o) {
        var a = i > 0 ? ka : -ka, c = ca(i - r);
        ca(c - ka) < Ca ? (n.point(r, e = (e + o) / 2 > 0 ? Aa : -Aa), n.point(u, e), n.lineEnd(), n.lineStart(), n.point(a, e), n.point(i, e), t = 0) : u !== a && c >= ka && (ca(r - u) < Ca && (r -= u * Ca), ca(i - a) < Ca && (i -= a * Ca), e = Ur(r, e, i, o), n.point(u, e), n.lineEnd(), n.lineStart(), n.point(a, e), t = 0), n.point(r = i, e = o), u = a;
      },
      lineEnd: function () {
        n.lineEnd(), r = e = 0 / 0;
      },
      clean: function () {
        return 2 - t;
      }
    };
  }
  function Ur(n, t, r, e) {
    var u, i, o = Math.sin(n - r);
    return ca(o) > Ca ? Math.atan((Math.sin(t) * (i = Math.cos(e)) * Math.sin(r) - Math.sin(e) * (u = Math.cos(t)) * Math.sin(n)) / (u * i * o)) : (t + e) / 2;
  }
  function jr(n, t, r, e) {
    var u;
    if (null == n)
      u = r * Aa, e.point(-ka, u), e.point(0, u), e.point(ka, u), e.point(ka, 0), e.point(ka, -u), e.point(0, -u), e.point(-ka, -u), e.point(-ka, 0), e.point(-ka, u);
    else if (ca(n[0] - t[0]) > Ca) {
      var i = n[0] < t[0] ? ka : -ka;
      u = r * i / 2, e.point(-i, u), e.point(0, u), e.point(i, u);
    } else
      e.point(t[0], t[1]);
  }
  function Hr(n) {
    function t(n, t) {
      return Math.cos(n) * Math.cos(t) > i;
    }
    function r(n) {
      var r, i, c, s, l;
      return {
        lineStart: function () {
          s = c = !1, l = 1;
        },
        point: function (f, h) {
          var g, p = [
              f,
              h
            ], v = t(f, h), d = o ? v ? 0 : u(f, h) : v ? u(f + (0 > f ? ka : -ka), h) : 0;
          if (!r && (s = c = v) && n.lineStart(), v !== c && (g = e(r, p), (_r(r, g) || _r(p, g)) && (p[0] += Ca, p[1] += Ca, v = t(p[0], p[1]))), v !== c)
            l = 0, v ? (n.lineStart(), g = e(p, r), n.point(g[0], g[1])) : (g = e(r, p), n.point(g[0], g[1]), n.lineEnd()), r = g;
          else if (a && r && o ^ v) {
            var m;
            d & i || !(m = e(p, r, !0)) || (l = 0, o ? (n.lineStart(), n.point(m[0][0], m[0][1]), n.point(m[1][0], m[1][1]), n.lineEnd()) : (n.point(m[1][0], m[1][1]), n.lineEnd(), n.lineStart(), n.point(m[0][0], m[0][1])));
          }
          !v || r && _r(r, p) || n.point(p[0], p[1]), r = p, c = v, i = d;
        },
        lineEnd: function () {
          c && n.lineEnd(), r = null;
        },
        clean: function () {
          return l | (s && c) << 1;
        }
      };
    }
    function e(n, t, r) {
      var e = pr(n), u = pr(t), o = [
          1,
          0,
          0
        ], a = dr(e, u), c = vr(a, a), s = a[0], l = c - s * s;
      if (!l)
        return !r && n;
      var f = i * c / l, h = -i * s / l, g = dr(o, a), p = yr(o, f), v = yr(a, h);
      mr(p, v);
      var d = g, m = vr(p, d), y = vr(d, d), x = m * m - y * (vr(p, p) - 1);
      if (!(0 > x)) {
        var M = Math.sqrt(x), _ = yr(d, (-m - M) / y);
        if (mr(_, p), _ = Mr(_), !r)
          return _;
        var b, w = n[0], S = t[0], k = n[1], E = t[1];
        w > S && (b = w, w = S, S = b);
        var A = S - w, C = ca(A - ka) < Ca, N = C || Ca > A;
        if (!C && k > E && (b = k, k = E, E = b), N ? C ? k + E > 0 ^ _[1] < (ca(_[0] - w) < Ca ? k : E) : k <= _[1] && _[1] <= E : A > ka ^ (w <= _[0] && _[0] <= S)) {
          var z = yr(d, (-m + M) / y);
          return mr(z, p), [
            _,
            Mr(z)
          ];
        }
      }
    }
    function u(t, r) {
      var e = o ? n : ka - n, u = 0;
      return -e > t ? u |= 1 : t > e && (u |= 2), -e > r ? u |= 4 : r > e && (u |= 8), u;
    }
    var i = Math.cos(n), o = i > 0, a = ca(i) > Ca, c = ge(n, 6 * za);
    return Lr(t, r, c, o ? [
      0,
      -n
    ] : [
      -ka,
      n - ka
    ]);
  }
  function Fr(n, t, r, e) {
    return function (u) {
      var i, o = u.a, a = u.b, c = o.x, s = o.y, l = a.x, f = a.y, h = 0, g = 1, p = l - c, v = f - s;
      if (i = n - c, p || !(i > 0)) {
        if (i /= p, 0 > p) {
          if (h > i)
            return;
          g > i && (g = i);
        } else if (p > 0) {
          if (i > g)
            return;
          i > h && (h = i);
        }
        if (i = r - c, p || !(0 > i)) {
          if (i /= p, 0 > p) {
            if (i > g)
              return;
            i > h && (h = i);
          } else if (p > 0) {
            if (h > i)
              return;
            g > i && (g = i);
          }
          if (i = t - s, v || !(i > 0)) {
            if (i /= v, 0 > v) {
              if (h > i)
                return;
              g > i && (g = i);
            } else if (v > 0) {
              if (i > g)
                return;
              i > h && (h = i);
            }
            if (i = e - s, v || !(0 > i)) {
              if (i /= v, 0 > v) {
                if (i > g)
                  return;
                i > h && (h = i);
              } else if (v > 0) {
                if (h > i)
                  return;
                g > i && (g = i);
              }
              return h > 0 && (u.a = {
                x: c + h * p,
                y: s + h * v
              }), 1 > g && (u.b = {
                x: c + g * p,
                y: s + g * v
              }), u;
            }
          }
        }
      }
    };
  }
  function Or(n, t, r, e) {
    function u(e, u) {
      return ca(e[0] - n) < Ca ? u > 0 ? 0 : 3 : ca(e[0] - r) < Ca ? u > 0 ? 2 : 1 : ca(e[1] - t) < Ca ? u > 0 ? 1 : 0 : u > 0 ? 3 : 2;
    }
    function i(n, t) {
      return o(n.x, t.x);
    }
    function o(n, t) {
      var r = u(n, 1), e = u(t, 1);
      return r !== e ? r - e : 0 === r ? t[1] - n[1] : 1 === r ? n[0] - t[0] : 2 === r ? n[1] - t[1] : t[0] - n[0];
    }
    return function (a) {
      function c(n) {
        for (var t = 0, r = d.length, e = n[1], u = 0; r > u; ++u)
          for (var i, o = 1, a = d[u], c = a.length, s = a[0]; c > o; ++o)
            i = a[o], s[1] <= e ? i[1] > e && J(s, i, n) > 0 && ++t : i[1] <= e && J(s, i, n) < 0 && --t, s = i;
        return 0 !== t;
      }
      function s(i, a, c, s) {
        var l = 0, f = 0;
        if (null == i || (l = u(i, c)) !== (f = u(a, c)) || o(i, a) < 0 ^ c > 0) {
          do
            s.point(0 === l || 3 === l ? n : r, l > 1 ? e : t);
          while ((l = (l + c + 4) % 4) !== f);
        } else
          s.point(a[0], a[1]);
      }
      function l(u, i) {
        return u >= n && r >= u && i >= t && e >= i;
      }
      function f(n, t) {
        l(n, t) && a.point(n, t);
      }
      function h() {
        N.point = p, d && d.push(m = []), S = !0, w = !1, _ = b = 0 / 0;
      }
      function g() {
        v && (p(y, x), M && w && A.rejoin(), v.push(A.buffer())), N.point = f, w && a.lineEnd();
      }
      function p(n, t) {
        n = Math.max(-Cc, Math.min(Cc, n)), t = Math.max(-Cc, Math.min(Cc, t));
        var r = l(n, t);
        if (d && m.push([
            n,
            t
          ]), S)
          y = n, x = t, M = r, S = !1, r && (a.lineStart(), a.point(n, t));
        else if (r && w)
          a.point(n, t);
        else {
          var e = {
              a: {
                x: _,
                y: b
              },
              b: {
                x: n,
                y: t
              }
            };
          C(e) ? (w || (a.lineStart(), a.point(e.a.x, e.a.y)), a.point(e.b.x, e.b.y), r || a.lineEnd(), k = !1) : r && (a.lineStart(), a.point(n, t), k = !1);
        }
        _ = n, b = t, w = r;
      }
      var v, d, m, y, x, M, _, b, w, S, k, E = a, A = qr(), C = Fr(n, t, r, e), N = {
          point: f,
          lineStart: h,
          lineEnd: g,
          polygonStart: function () {
            a = A, v = [], d = [], k = !0;
          },
          polygonEnd: function () {
            a = E, v = Bo.merge(v);
            var t = c([
                n,
                e
              ]), r = k && t, u = v.length;
            (r || u) && (a.polygonStart(), r && (a.lineStart(), s(null, null, 1, a), a.lineEnd()), u && Cr(v, i, t, s, a), a.polygonEnd()), v = d = m = null;
          }
        };
      return N;
    };
  }
  function Ir(n, t) {
    function r(r, e) {
      return r = n(r, e), t(r[0], r[1]);
    }
    return n.invert && t.invert && (r.invert = function (r, e) {
      return r = t.invert(r, e), r && n.invert(r[0], r[1]);
    }), r;
  }
  function Yr(n) {
    var t = 0, r = ka / 3, e = ie(n), u = e(t, r);
    return u.parallels = function (n) {
      return arguments.length ? e(t = n[0] * ka / 180, r = n[1] * ka / 180) : [
        180 * (t / ka),
        180 * (r / ka)
      ];
    }, u;
  }
  function Zr(n, t) {
    function r(n, t) {
      var r = Math.sqrt(i - 2 * u * Math.sin(t)) / u;
      return [
        r * Math.sin(n *= u),
        o - r * Math.cos(n)
      ];
    }
    var e = Math.sin(n), u = (e + Math.sin(t)) / 2, i = 1 + e * (2 * u - e), o = Math.sqrt(i) / u;
    return r.invert = function (n, t) {
      var r = o - t;
      return [
        Math.atan2(n, r) / u,
        G((i - (n * n + r * r) * u * u) / (2 * u))
      ];
    }, r;
  }
  function Vr() {
    function n(n, t) {
      zc += u * n - e * t, e = n, u = t;
    }
    var t, r, e, u;
    Dc.point = function (i, o) {
      Dc.point = n, t = e = i, r = u = o;
    }, Dc.lineEnd = function () {
      n(t, r);
    };
  }
  function $r(n, t) {
    Lc > n && (Lc = n), n > qc && (qc = n), Tc > t && (Tc = t), t > Rc && (Rc = t);
  }
  function Xr() {
    function n(n, t) {
      o.push('M', n, ',', t, i);
    }
    function t(n, t) {
      o.push('M', n, ',', t), a.point = r;
    }
    function r(n, t) {
      o.push('L', n, ',', t);
    }
    function e() {
      a.point = n;
    }
    function u() {
      o.push('Z');
    }
    var i = Br(4.5), o = [], a = {
        point: n,
        lineStart: function () {
          a.point = t;
        },
        lineEnd: e,
        polygonStart: function () {
          a.lineEnd = u;
        },
        polygonEnd: function () {
          a.lineEnd = e, a.point = n;
        },
        pointRadius: function (n) {
          return i = Br(n), a;
        },
        result: function () {
          if (o.length) {
            var n = o.join('');
            return o = [], n;
          }
        }
      };
    return a;
  }
  function Br(n) {
    return 'm0,' + n + 'a' + n + ',' + n + ' 0 1,1 0,' + -2 * n + 'a' + n + ',' + n + ' 0 1,1 0,' + 2 * n + 'z';
  }
  function Jr(n, t) {
    mc += n, yc += t, ++xc;
  }
  function Wr() {
    function n(n, e) {
      var u = n - t, i = e - r, o = Math.sqrt(u * u + i * i);
      Mc += o * (t + n) / 2, _c += o * (r + e) / 2, bc += o, Jr(t = n, r = e);
    }
    var t, r;
    Uc.point = function (e, u) {
      Uc.point = n, Jr(t = e, r = u);
    };
  }
  function Gr() {
    Uc.point = Jr;
  }
  function Kr() {
    function n(n, t) {
      var r = n - e, i = t - u, o = Math.sqrt(r * r + i * i);
      Mc += o * (e + n) / 2, _c += o * (u + t) / 2, bc += o, o = u * n - e * t, wc += o * (e + n), Sc += o * (u + t), kc += 3 * o, Jr(e = n, u = t);
    }
    var t, r, e, u;
    Uc.point = function (i, o) {
      Uc.point = n, Jr(t = e = i, r = u = o);
    }, Uc.lineEnd = function () {
      n(t, r);
    };
  }
  function Qr(n) {
    function t(t, r) {
      n.moveTo(t, r), n.arc(t, r, o, 0, Ea);
    }
    function r(t, r) {
      n.moveTo(t, r), a.point = e;
    }
    function e(t, r) {
      n.lineTo(t, r);
    }
    function u() {
      a.point = t;
    }
    function i() {
      n.closePath();
    }
    var o = 4.5, a = {
        point: t,
        lineStart: function () {
          a.point = r;
        },
        lineEnd: u,
        polygonStart: function () {
          a.lineEnd = i;
        },
        polygonEnd: function () {
          a.lineEnd = u, a.point = t;
        },
        pointRadius: function (n) {
          return o = n, a;
        },
        result: v
      };
    return a;
  }
  function ne(n) {
    function t(n) {
      return (a ? e : r)(n);
    }
    function r(t) {
      return ee(t, function (r, e) {
        r = n(r, e), t.point(r[0], r[1]);
      });
    }
    function e(t) {
      function r(r, e) {
        r = n(r, e), t.point(r[0], r[1]);
      }
      function e() {
        x = 0 / 0, S.point = i, t.lineStart();
      }
      function i(r, e) {
        var i = pr([
            r,
            e
          ]), o = n(r, e);
        u(x, M, y, _, b, w, x = o[0], M = o[1], y = r, _ = i[0], b = i[1], w = i[2], a, t), t.point(x, M);
      }
      function o() {
        S.point = r, t.lineEnd();
      }
      function c() {
        e(), S.point = s, S.lineEnd = l;
      }
      function s(n, t) {
        i(f = n, h = t), g = x, p = M, v = _, d = b, m = w, S.point = i;
      }
      function l() {
        u(x, M, y, _, b, w, g, p, f, v, d, m, a, t), S.lineEnd = o, o();
      }
      var f, h, g, p, v, d, m, y, x, M, _, b, w, S = {
          point: r,
          lineStart: e,
          lineEnd: o,
          polygonStart: function () {
            t.polygonStart(), S.lineStart = c;
          },
          polygonEnd: function () {
            t.polygonEnd(), S.lineStart = e;
          }
        };
      return S;
    }
    function u(t, r, e, a, c, s, l, f, h, g, p, v, d, m) {
      var y = l - t, x = f - r, M = y * y + x * x;
      if (M > 4 * i && d--) {
        var _ = a + g, b = c + p, w = s + v, S = Math.sqrt(_ * _ + b * b + w * w), k = Math.asin(w /= S), E = ca(ca(w) - 1) < Ca || ca(e - h) < Ca ? (e + h) / 2 : Math.atan2(b, _), A = n(E, k), C = A[0], N = A[1], z = C - t, L = N - r, T = x * z - y * L;
        (T * T / M > i || ca((y * z + x * L) / M - 0.5) > 0.3 || o > a * g + c * p + s * v) && (u(t, r, e, a, c, s, C, N, E, _ /= S, b /= S, w, d, m), m.point(C, N), u(C, N, E, _, b, w, l, f, h, g, p, v, d, m));
      }
    }
    var i = 0.5, o = Math.cos(30 * za), a = 16;
    return t.precision = function (n) {
      return arguments.length ? (a = (i = n * n) > 0 && 16, t) : Math.sqrt(i);
    }, t;
  }
  function te(n) {
    var t = ne(function (t, r) {
        return n([
          t * La,
          r * La
        ]);
      });
    return function (n) {
      return oe(t(n));
    };
  }
  function re(n) {
    this.stream = n;
  }
  function ee(n, t) {
    return {
      point: t,
      sphere: function () {
        n.sphere();
      },
      lineStart: function () {
        n.lineStart();
      },
      lineEnd: function () {
        n.lineEnd();
      },
      polygonStart: function () {
        n.polygonStart();
      },
      polygonEnd: function () {
        n.polygonEnd();
      }
    };
  }
  function ue(n) {
    return ie(function () {
      return n;
    })();
  }
  function ie(n) {
    function t(n) {
      return n = a(n[0] * za, n[1] * za), [
        n[0] * h + c,
        s - n[1] * h
      ];
    }
    function r(n) {
      return n = a.invert((n[0] - c) / h, (s - n[1]) / h), n && [
        n[0] * La,
        n[1] * La
      ];
    }
    function e() {
      a = Ir(o = se(m, y, x), i);
      var n = i(v, d);
      return c = g - n[0] * h, s = p + n[1] * h, u();
    }
    function u() {
      return l && (l.valid = !1, l = null), t;
    }
    var i, o, a, c, s, l, f = ne(function (n, t) {
        return n = i(n, t), [
          n[0] * h + c,
          s - n[1] * h
        ];
      }), h = 150, g = 480, p = 250, v = 0, d = 0, m = 0, y = 0, x = 0, M = Ac, _ = At, b = null, w = null;
    return t.stream = function (n) {
      return l && (l.valid = !1), l = oe(M(o, f(_(n)))), l.valid = !0, l;
    }, t.clipAngle = function (n) {
      return arguments.length ? (M = null == n ? (b = n, Ac) : Hr((b = +n) * za), u()) : b;
    }, t.clipExtent = function (n) {
      return arguments.length ? (w = n, _ = n ? Or(n[0][0], n[0][1], n[1][0], n[1][1]) : At, u()) : w;
    }, t.scale = function (n) {
      return arguments.length ? (h = +n, e()) : h;
    }, t.translate = function (n) {
      return arguments.length ? (g = +n[0], p = +n[1], e()) : [
        g,
        p
      ];
    }, t.center = function (n) {
      return arguments.length ? (v = n[0] % 360 * za, d = n[1] % 360 * za, e()) : [
        v * La,
        d * La
      ];
    }, t.rotate = function (n) {
      return arguments.length ? (m = n[0] % 360 * za, y = n[1] % 360 * za, x = n.length > 2 ? n[2] % 360 * za : 0, e()) : [
        m * La,
        y * La,
        x * La
      ];
    }, Bo.rebind(t, f, 'precision'), function () {
      return i = n.apply(this, arguments), t.invert = i.invert && r, e();
    };
  }
  function oe(n) {
    return ee(n, function (t, r) {
      n.point(t * za, r * za);
    });
  }
  function ae(n, t) {
    return [
      n,
      t
    ];
  }
  function ce(n, t) {
    return [
      n > ka ? n - Ea : -ka > n ? n + Ea : n,
      t
    ];
  }
  function se(n, t, r) {
    return n ? t || r ? Ir(fe(n), he(t, r)) : fe(n) : t || r ? he(t, r) : ce;
  }
  function le(n) {
    return function (t, r) {
      return t += n, [
        t > ka ? t - Ea : -ka > t ? t + Ea : t,
        r
      ];
    };
  }
  function fe(n) {
    var t = le(n);
    return t.invert = le(-n), t;
  }
  function he(n, t) {
    function r(n, t) {
      var r = Math.cos(t), a = Math.cos(n) * r, c = Math.sin(n) * r, s = Math.sin(t), l = s * e + a * u;
      return [
        Math.atan2(c * i - l * o, a * e - s * u),
        G(l * i + c * o)
      ];
    }
    var e = Math.cos(n), u = Math.sin(n), i = Math.cos(t), o = Math.sin(t);
    return r.invert = function (n, t) {
      var r = Math.cos(t), a = Math.cos(n) * r, c = Math.sin(n) * r, s = Math.sin(t), l = s * i - c * o;
      return [
        Math.atan2(c * i + s * o, a * e + l * u),
        G(l * e - a * u)
      ];
    }, r;
  }
  function ge(n, t) {
    var r = Math.cos(n), e = Math.sin(n);
    return function (u, i, o, a) {
      var c = o * t;
      null != u ? (u = pe(r, u), i = pe(r, i), (o > 0 ? i > u : u > i) && (u += o * Ea)) : (u = n + o * Ea, i = n - 0.5 * c);
      for (var s, l = u; o > 0 ? l > i : i > l; l -= c)
        a.point((s = Mr([
          r,
          -e * Math.cos(l),
          -e * Math.sin(l)
        ]))[0], s[1]);
    };
  }
  function pe(n, t) {
    var r = pr(t);
    r[0] -= n, xr(r);
    var e = W(-r[1]);
    return ((-r[2] < 0 ? -e : e) + 2 * Math.PI - Ca) % (2 * Math.PI);
  }
  function ve(n, t, r) {
    var e = Bo.range(n, t - Ca, r).concat(t);
    return function (n) {
      return e.map(function (t) {
        return [
          n,
          t
        ];
      });
    };
  }
  function de(n, t, r) {
    var e = Bo.range(n, t - Ca, r).concat(t);
    return function (n) {
      return e.map(function (t) {
        return [
          t,
          n
        ];
      });
    };
  }
  function me(n) {
    return n.source;
  }
  function ye(n) {
    return n.target;
  }
  function xe(n, t, r, e) {
    var u = Math.cos(t), i = Math.sin(t), o = Math.cos(e), a = Math.sin(e), c = u * Math.cos(n), s = u * Math.sin(n), l = o * Math.cos(r), f = o * Math.sin(r), h = 2 * Math.asin(Math.sqrt(tt(e - t) + u * o * tt(r - n))), g = 1 / Math.sin(h), p = h ? function (n) {
        var t = Math.sin(n *= h) * g, r = Math.sin(h - n) * g, e = r * c + t * l, u = r * s + t * f, o = r * i + t * a;
        return [
          Math.atan2(u, e) * La,
          Math.atan2(o, Math.sqrt(e * e + u * u)) * La
        ];
      } : function () {
        return [
          n * La,
          t * La
        ];
      };
    return p.distance = h, p;
  }
  function Me() {
    function n(n, u) {
      var i = Math.sin(u *= za), o = Math.cos(u), a = ca((n *= za) - t), c = Math.cos(a);
      jc += Math.atan2(Math.sqrt((a = o * Math.sin(a)) * a + (a = e * i - r * o * c) * a), r * i + e * o * c), t = n, r = i, e = o;
    }
    var t, r, e;
    Hc.point = function (u, i) {
      t = u * za, r = Math.sin(i *= za), e = Math.cos(i), Hc.point = n;
    }, Hc.lineEnd = function () {
      Hc.point = Hc.lineEnd = v;
    };
  }
  function _e(n, t) {
    function r(t, r) {
      var e = Math.cos(t), u = Math.cos(r), i = n(e * u);
      return [
        i * u * Math.sin(t),
        i * Math.sin(r)
      ];
    }
    return r.invert = function (n, r) {
      var e = Math.sqrt(n * n + r * r), u = t(e), i = Math.sin(u), o = Math.cos(u);
      return [
        Math.atan2(n * i, e * o),
        Math.asin(e && r * i / e)
      ];
    }, r;
  }
  function be(n, t) {
    function r(n, t) {
      o > 0 ? -Aa + Ca > t && (t = -Aa + Ca) : t > Aa - Ca && (t = Aa - Ca);
      var r = o / Math.pow(u(t), i);
      return [
        r * Math.sin(i * n),
        o - r * Math.cos(i * n)
      ];
    }
    var e = Math.cos(n), u = function (n) {
        return Math.tan(ka / 4 + n / 2);
      }, i = n === t ? Math.sin(n) : Math.log(e / Math.cos(t)) / Math.log(u(t) / u(n)), o = e * Math.pow(u(n), i) / i;
    return i ? (r.invert = function (n, t) {
      var r = o - t, e = B(i) * Math.sqrt(n * n + r * r);
      return [
        Math.atan2(n, r) / i,
        2 * Math.atan(Math.pow(o / e, 1 / i)) - Aa
      ];
    }, r) : Se;
  }
  function we(n, t) {
    function r(n, t) {
      var r = i - t;
      return [
        r * Math.sin(u * n),
        i - r * Math.cos(u * n)
      ];
    }
    var e = Math.cos(n), u = n === t ? Math.sin(n) : (e - Math.cos(t)) / (t - n), i = e / u + n;
    return ca(u) < Ca ? ae : (r.invert = function (n, t) {
      var r = i - t;
      return [
        Math.atan2(n, r) / u,
        i - B(u) * Math.sqrt(n * n + r * r)
      ];
    }, r);
  }
  function Se(n, t) {
    return [
      n,
      Math.log(Math.tan(ka / 4 + t / 2))
    ];
  }
  function ke(n) {
    var t, r = ue(n), e = r.scale, u = r.translate, i = r.clipExtent;
    return r.scale = function () {
      var n = e.apply(r, arguments);
      return n === r ? t ? r.clipExtent(null) : r : n;
    }, r.translate = function () {
      var n = u.apply(r, arguments);
      return n === r ? t ? r.clipExtent(null) : r : n;
    }, r.clipExtent = function (n) {
      var o = i.apply(r, arguments);
      if (o === r) {
        if (t = null == n) {
          var a = ka * e(), c = u();
          i([
            [
              c[0] - a,
              c[1] - a
            ],
            [
              c[0] + a,
              c[1] + a
            ]
          ]);
        }
      } else
        t && (o = null);
      return o;
    }, r.clipExtent(null);
  }
  function Ee(n, t) {
    return [
      Math.log(Math.tan(ka / 4 + t / 2)),
      -n
    ];
  }
  function Ae(n) {
    return n[0];
  }
  function Ce(n) {
    return n[1];
  }
  function Ne(n) {
    for (var t = n.length, r = [
          0,
          1
        ], e = 2, u = 2; t > u; u++) {
      for (; e > 1 && J(n[r[e - 2]], n[r[e - 1]], n[u]) <= 0;)
        --e;
      r[e++] = u;
    }
    return r.slice(0, e);
  }
  function ze(n, t) {
    return n[0] - t[0] || n[1] - t[1];
  }
  function Le(n, t, r) {
    return (r[0] - t[0]) * (n[1] - t[1]) < (r[1] - t[1]) * (n[0] - t[0]);
  }
  function Te(n, t, r, e) {
    var u = n[0], i = r[0], o = t[0] - u, a = e[0] - i, c = n[1], s = r[1], l = t[1] - c, f = e[1] - s, h = (a * (c - s) - f * (u - i)) / (f * o - a * l);
    return [
      u + h * o,
      c + h * l
    ];
  }
  function qe(n) {
    var t = n[0], r = n[n.length - 1];
    return !(t[0] - r[0] || t[1] - r[1]);
  }
  function Re() {
    tu(this), this.edge = this.site = this.circle = null;
  }
  function De(n) {
    var t = Gc.pop() || new Re();
    return t.site = n, t;
  }
  function Pe(n) {
    $e(n), Bc.remove(n), Gc.push(n), tu(n);
  }
  function Ue(n) {
    var t = n.circle, r = t.x, e = t.cy, u = {
        x: r,
        y: e
      }, i = n.P, o = n.N, a = [n];
    Pe(n);
    for (var c = i; c.circle && ca(r - c.circle.x) < Ca && ca(e - c.circle.cy) < Ca;)
      i = c.P, a.unshift(c), Pe(c), c = i;
    a.unshift(c), $e(c);
    for (var s = o; s.circle && ca(r - s.circle.x) < Ca && ca(e - s.circle.cy) < Ca;)
      o = s.N, a.push(s), Pe(s), s = o;
    a.push(s), $e(s);
    var l, f = a.length;
    for (l = 1; f > l; ++l)
      s = a[l], c = a[l - 1], Ke(s.edge, c.site, s.site, u);
    c = a[0], s = a[f - 1], s.edge = We(c.site, s.site, null, u), Ve(c), Ve(s);
  }
  function je(n) {
    for (var t, r, e, u, i = n.x, o = n.y, a = Bc._; a;)
      if (e = He(a, o) - i, e > Ca)
        a = a.L;
      else {
        if (u = i - Fe(a, o), !(u > Ca)) {
          e > -Ca ? (t = a.P, r = a) : u > -Ca ? (t = a, r = a.N) : t = r = a;
          break;
        }
        if (!a.R) {
          t = a;
          break;
        }
        a = a.R;
      }
    var c = De(n);
    if (Bc.insert(t, c), t || r) {
      if (t === r)
        return $e(t), r = De(t.site), Bc.insert(c, r), c.edge = r.edge = We(t.site, c.site), Ve(t), Ve(r), void 0;
      if (!r)
        return c.edge = We(t.site, c.site), void 0;
      $e(t), $e(r);
      var s = t.site, l = s.x, f = s.y, h = n.x - l, g = n.y - f, p = r.site, v = p.x - l, d = p.y - f, m = 2 * (h * d - g * v), y = h * h + g * g, x = v * v + d * d, M = {
          x: (d * y - g * x) / m + l,
          y: (h * x - v * y) / m + f
        };
      Ke(r.edge, s, p, M), c.edge = We(s, n, null, M), r.edge = We(n, p, null, M), Ve(t), Ve(r);
    }
  }
  function He(n, t) {
    var r = n.site, e = r.x, u = r.y, i = u - t;
    if (!i)
      return e;
    var o = n.P;
    if (!o)
      return -1 / 0;
    r = o.site;
    var a = r.x, c = r.y, s = c - t;
    if (!s)
      return a;
    var l = a - e, f = 1 / i - 1 / s, h = l / s;
    return f ? (-h + Math.sqrt(h * h - 2 * f * (l * l / (-2 * s) - c + s / 2 + u - i / 2))) / f + e : (e + a) / 2;
  }
  function Fe(n, t) {
    var r = n.N;
    if (r)
      return He(r, t);
    var e = n.site;
    return e.y === t ? e.x : 1 / 0;
  }
  function Oe(n) {
    this.site = n, this.edges = [];
  }
  function Ie(n) {
    for (var t, r, e, u, i, o, a, c, s, l, f = n[0][0], h = n[1][0], g = n[0][1], p = n[1][1], v = Xc, d = v.length; d--;)
      if (i = v[d], i && i.prepare())
        for (a = i.edges, c = a.length, o = 0; c > o;)
          l = a[o].end(), e = l.x, u = l.y, s = a[++o % c].start(), t = s.x, r = s.y, (ca(e - t) > Ca || ca(u - r) > Ca) && (a.splice(o, 0, new Qe(Ge(i.site, l, ca(e - f) < Ca && p - u > Ca ? {
            x: f,
            y: ca(t - f) < Ca ? r : p
          } : ca(u - p) < Ca && h - e > Ca ? {
            x: ca(r - p) < Ca ? t : h,
            y: p
          } : ca(e - h) < Ca && u - g > Ca ? {
            x: h,
            y: ca(t - h) < Ca ? r : g
          } : ca(u - g) < Ca && e - f > Ca ? {
            x: ca(r - g) < Ca ? t : f,
            y: g
          } : null), i.site, null)), ++c);
  }
  function Ye(n, t) {
    return t.angle - n.angle;
  }
  function Ze() {
    tu(this), this.x = this.y = this.arc = this.site = this.cy = null;
  }
  function Ve(n) {
    var t = n.P, r = n.N;
    if (t && r) {
      var e = t.site, u = n.site, i = r.site;
      if (e !== i) {
        var o = u.x, a = u.y, c = e.x - o, s = e.y - a, l = i.x - o, f = i.y - a, h = 2 * (c * f - s * l);
        if (!(h >= -Na)) {
          var g = c * c + s * s, p = l * l + f * f, v = (f * g - s * p) / h, d = (c * p - l * g) / h, f = d + a, m = Kc.pop() || new Ze();
          m.arc = n, m.site = u, m.x = v + o, m.y = f + Math.sqrt(v * v + d * d), m.cy = f, n.circle = m;
          for (var y = null, x = Wc._; x;)
            if (m.y < x.y || m.y === x.y && m.x <= x.x) {
              if (!x.L) {
                y = x.P;
                break;
              }
              x = x.L;
            } else {
              if (!x.R) {
                y = x;
                break;
              }
              x = x.R;
            }
          Wc.insert(y, m), y || (Jc = m);
        }
      }
    }
  }
  function $e(n) {
    var t = n.circle;
    t && (t.P || (Jc = t.N), Wc.remove(t), Kc.push(t), tu(t), n.circle = null);
  }
  function Xe(n) {
    for (var t, r = $c, e = Fr(n[0][0], n[0][1], n[1][0], n[1][1]), u = r.length; u--;)
      t = r[u], (!Be(t, n) || !e(t) || ca(t.a.x - t.b.x) < Ca && ca(t.a.y - t.b.y) < Ca) && (t.a = t.b = null, r.splice(u, 1));
  }
  function Be(n, t) {
    var r = n.b;
    if (r)
      return !0;
    var e, u, i = n.a, o = t[0][0], a = t[1][0], c = t[0][1], s = t[1][1], l = n.l, f = n.r, h = l.x, g = l.y, p = f.x, v = f.y, d = (h + p) / 2, m = (g + v) / 2;
    if (v === g) {
      if (o > d || d >= a)
        return;
      if (h > p) {
        if (i) {
          if (i.y >= s)
            return;
        } else
          i = {
            x: d,
            y: c
          };
        r = {
          x: d,
          y: s
        };
      } else {
        if (i) {
          if (i.y < c)
            return;
        } else
          i = {
            x: d,
            y: s
          };
        r = {
          x: d,
          y: c
        };
      }
    } else if (e = (h - p) / (v - g), u = m - e * d, -1 > e || e > 1)
      if (h > p) {
        if (i) {
          if (i.y >= s)
            return;
        } else
          i = {
            x: (c - u) / e,
            y: c
          };
        r = {
          x: (s - u) / e,
          y: s
        };
      } else {
        if (i) {
          if (i.y < c)
            return;
        } else
          i = {
            x: (s - u) / e,
            y: s
          };
        r = {
          x: (c - u) / e,
          y: c
        };
      }
    else if (v > g) {
      if (i) {
        if (i.x >= a)
          return;
      } else
        i = {
          x: o,
          y: e * o + u
        };
      r = {
        x: a,
        y: e * a + u
      };
    } else {
      if (i) {
        if (i.x < o)
          return;
      } else
        i = {
          x: a,
          y: e * a + u
        };
      r = {
        x: o,
        y: e * o + u
      };
    }
    return n.a = i, n.b = r, !0;
  }
  function Je(n, t) {
    this.l = n, this.r = t, this.a = this.b = null;
  }
  function We(n, t, r, e) {
    var u = new Je(n, t);
    return $c.push(u), r && Ke(u, n, t, r), e && Ke(u, t, n, e), Xc[n.i].edges.push(new Qe(u, n, t)), Xc[t.i].edges.push(new Qe(u, t, n)), u;
  }
  function Ge(n, t, r) {
    var e = new Je(n, null);
    return e.a = t, e.b = r, $c.push(e), e;
  }
  function Ke(n, t, r, e) {
    n.a || n.b ? n.l === r ? n.b = e : n.a = e : (n.a = e, n.l = t, n.r = r);
  }
  function Qe(n, t, r) {
    var e = n.a, u = n.b;
    this.edge = n, this.site = t, this.angle = r ? Math.atan2(r.y - t.y, r.x - t.x) : n.l === t ? Math.atan2(u.x - e.x, e.y - u.y) : Math.atan2(e.x - u.x, u.y - e.y);
  }
  function nu() {
    this._ = null;
  }
  function tu(n) {
    n.U = n.C = n.L = n.R = n.P = n.N = null;
  }
  function ru(n, t) {
    var r = t, e = t.R, u = r.U;
    u ? u.L === r ? u.L = e : u.R = e : n._ = e, e.U = u, r.U = e, r.R = e.L, r.R && (r.R.U = r), e.L = r;
  }
  function eu(n, t) {
    var r = t, e = t.L, u = r.U;
    u ? u.L === r ? u.L = e : u.R = e : n._ = e, e.U = u, r.U = e, r.L = e.R, r.L && (r.L.U = r), e.R = r;
  }
  function uu(n) {
    for (; n.L;)
      n = n.L;
    return n;
  }
  function iu(n, t) {
    var r, e, u, i = n.sort(ou).pop();
    for ($c = [], Xc = new Array(n.length), Bc = new nu(), Wc = new nu();;)
      if (u = Jc, i && (!u || i.y < u.y || i.y === u.y && i.x < u.x))
        (i.x !== r || i.y !== e) && (Xc[i.i] = new Oe(i), je(i), r = i.x, e = i.y), i = n.pop();
      else {
        if (!u)
          break;
        Ue(u.arc);
      }
    t && (Xe(t), Ie(t));
    var o = {
        cells: Xc,
        edges: $c
      };
    return Bc = Wc = $c = Xc = null, o;
  }
  function ou(n, t) {
    return t.y - n.y || t.x - n.x;
  }
  function au(n, t, r) {
    return (n.x - r.x) * (t.y - n.y) - (n.x - t.x) * (r.y - n.y);
  }
  function cu(n) {
    return n.x;
  }
  function su(n) {
    return n.y;
  }
  function lu() {
    return {
      leaf: !0,
      nodes: [],
      point: null,
      x: null,
      y: null
    };
  }
  function fu(n, t, r, e, u, i) {
    if (!n(t, r, e, u, i)) {
      var o = 0.5 * (r + u), a = 0.5 * (e + i), c = t.nodes;
      c[0] && fu(n, c[0], r, e, o, a), c[1] && fu(n, c[1], o, e, u, a), c[2] && fu(n, c[2], r, a, o, i), c[3] && fu(n, c[3], o, a, u, i);
    }
  }
  function hu(n, t) {
    n = Bo.rgb(n), t = Bo.rgb(t);
    var r = n.r, e = n.g, u = n.b, i = t.r - r, o = t.g - e, a = t.b - u;
    return function (n) {
      return '#' + Mt(Math.round(r + i * n)) + Mt(Math.round(e + o * n)) + Mt(Math.round(u + a * n));
    };
  }
  function gu(n, t) {
    var r, e = {}, u = {};
    for (r in n)
      r in t ? e[r] = du(n[r], t[r]) : u[r] = n[r];
    for (r in t)
      r in n || (u[r] = t[r]);
    return function (n) {
      for (r in e)
        u[r] = e[r](n);
      return u;
    };
  }
  function pu(n, t) {
    return t -= n = +n, function (r) {
      return n + t * r;
    };
  }
  function vu(n, t) {
    var r, e, u, i = ns.lastIndex = ts.lastIndex = 0, o = -1, a = [], c = [];
    for (n += '', t += ''; (r = ns.exec(n)) && (e = ts.exec(t));)
      (u = e.index) > i && (u = t.substring(i, u), a[o] ? a[o] += u : a[++o] = u), (r = r[0]) === (e = e[0]) ? a[o] ? a[o] += e : a[++o] = e : (a[++o] = null, c.push({
        i: o,
        x: pu(r, e)
      })), i = ts.lastIndex;
    return i < t.length && (u = t.substring(i), a[o] ? a[o] += u : a[++o] = u), a.length < 2 ? c[0] ? (t = c[0].x, function (n) {
      return t(n) + '';
    }) : function () {
      return t;
    } : (t = c.length, function (n) {
      for (var r, e = 0; t > e; ++e)
        a[(r = c[e]).i] = r.x(n);
      return a.join('');
    });
  }
  function du(n, t) {
    for (var r, e = Bo.interpolators.length; --e >= 0 && !(r = Bo.interpolators[e](n, t)););
    return r;
  }
  function mu(n, t) {
    var r, e = [], u = [], i = n.length, o = t.length, a = Math.min(n.length, t.length);
    for (r = 0; a > r; ++r)
      e.push(du(n[r], t[r]));
    for (; i > r; ++r)
      u[r] = n[r];
    for (; o > r; ++r)
      u[r] = t[r];
    return function (n) {
      for (r = 0; a > r; ++r)
        u[r] = e[r](n);
      return u;
    };
  }
  function yu(n) {
    return function (t) {
      return 0 >= t ? 0 : t >= 1 ? 1 : n(t);
    };
  }
  function xu(n) {
    return function (t) {
      return 1 - n(1 - t);
    };
  }
  function Mu(n) {
    return function (t) {
      return 0.5 * (0.5 > t ? n(2 * t) : 2 - n(2 - 2 * t));
    };
  }
  function _u(n) {
    return n * n;
  }
  function bu(n) {
    return n * n * n;
  }
  function wu(n) {
    if (0 >= n)
      return 0;
    if (n >= 1)
      return 1;
    var t = n * n, r = t * n;
    return 4 * (0.5 > n ? r : 3 * (n - t) + r - 0.75);
  }
  function Su(n) {
    return function (t) {
      return Math.pow(t, n);
    };
  }
  function ku(n) {
    return 1 - Math.cos(n * Aa);
  }
  function Eu(n) {
    return Math.pow(2, 10 * (n - 1));
  }
  function Au(n) {
    return 1 - Math.sqrt(1 - n * n);
  }
  function Cu(n, t) {
    var r;
    return arguments.length < 2 && (t = 0.45), arguments.length ? r = t / Ea * Math.asin(1 / n) : (n = 1, r = t / 4), function (e) {
      return 1 + n * Math.pow(2, -10 * e) * Math.sin((e - r) * Ea / t);
    };
  }
  function Nu(n) {
    return n || (n = 1.70158), function (t) {
      return t * t * ((n + 1) * t - n);
    };
  }
  function zu(n) {
    return 1 / 2.75 > n ? 7.5625 * n * n : 2 / 2.75 > n ? 7.5625 * (n -= 1.5 / 2.75) * n + 0.75 : 2.5 / 2.75 > n ? 7.5625 * (n -= 2.25 / 2.75) * n + 0.9375 : 7.5625 * (n -= 2.625 / 2.75) * n + 0.984375;
  }
  function Lu(n, t) {
    n = Bo.hcl(n), t = Bo.hcl(t);
    var r = n.h, e = n.c, u = n.l, i = t.h - r, o = t.c - e, a = t.l - u;
    return isNaN(o) && (o = 0, e = isNaN(e) ? t.c : e), isNaN(i) ? (i = 0, r = isNaN(r) ? t.h : r) : i > 180 ? i -= 360 : -180 > i && (i += 360), function (n) {
      return ct(r + i * n, e + o * n, u + a * n) + '';
    };
  }
  function Tu(n, t) {
    n = Bo.hsl(n), t = Bo.hsl(t);
    var r = n.h, e = n.s, u = n.l, i = t.h - r, o = t.s - e, a = t.l - u;
    return isNaN(o) && (o = 0, e = isNaN(e) ? t.s : e), isNaN(i) ? (i = 0, r = isNaN(r) ? t.h : r) : i > 180 ? i -= 360 : -180 > i && (i += 360), function (n) {
      return it(r + i * n, e + o * n, u + a * n) + '';
    };
  }
  function qu(n, t) {
    n = Bo.lab(n), t = Bo.lab(t);
    var r = n.l, e = n.a, u = n.b, i = t.l - r, o = t.a - e, a = t.b - u;
    return function (n) {
      return ft(r + i * n, e + o * n, u + a * n) + '';
    };
  }
  function Ru(n, t) {
    return t -= n, function (r) {
      return Math.round(n + t * r);
    };
  }
  function Du(n) {
    var t = [
        n.a,
        n.b
      ], r = [
        n.c,
        n.d
      ], e = Uu(t), u = Pu(t, r), i = Uu(ju(r, t, -u)) || 0;
    t[0] * r[1] < r[0] * t[1] && (t[0] *= -1, t[1] *= -1, e *= -1, u *= -1), this.rotate = (e ? Math.atan2(t[1], t[0]) : Math.atan2(-r[0], r[1])) * La, this.translate = [
      n.e,
      n.f
    ], this.scale = [
      e,
      i
    ], this.skew = i ? Math.atan2(u, i) * La : 0;
  }
  function Pu(n, t) {
    return n[0] * t[0] + n[1] * t[1];
  }
  function Uu(n) {
    var t = Math.sqrt(Pu(n, n));
    return t && (n[0] /= t, n[1] /= t), t;
  }
  function ju(n, t, r) {
    return n[0] += r * t[0], n[1] += r * t[1], n;
  }
  function Hu(n, t) {
    var r, e = [], u = [], i = Bo.transform(n), o = Bo.transform(t), a = i.translate, c = o.translate, s = i.rotate, l = o.rotate, f = i.skew, h = o.skew, g = i.scale, p = o.scale;
    return a[0] != c[0] || a[1] != c[1] ? (e.push('translate(', null, ',', null, ')'), u.push({
      i: 1,
      x: pu(a[0], c[0])
    }, {
      i: 3,
      x: pu(a[1], c[1])
    })) : c[0] || c[1] ? e.push('translate(' + c + ')') : e.push(''), s != l ? (s - l > 180 ? l += 360 : l - s > 180 && (s += 360), u.push({
      i: e.push(e.pop() + 'rotate(', null, ')') - 2,
      x: pu(s, l)
    })) : l && e.push(e.pop() + 'rotate(' + l + ')'), f != h ? u.push({
      i: e.push(e.pop() + 'skewX(', null, ')') - 2,
      x: pu(f, h)
    }) : h && e.push(e.pop() + 'skewX(' + h + ')'), g[0] != p[0] || g[1] != p[1] ? (r = e.push(e.pop() + 'scale(', null, ',', null, ')'), u.push({
      i: r - 4,
      x: pu(g[0], p[0])
    }, {
      i: r - 2,
      x: pu(g[1], p[1])
    })) : (1 != p[0] || 1 != p[1]) && e.push(e.pop() + 'scale(' + p + ')'), r = u.length, function (n) {
      for (var t, i = -1; ++i < r;)
        e[(t = u[i]).i] = t.x(n);
      return e.join('');
    };
  }
  function Fu(n, t) {
    return t = t - (n = +n) ? 1 / (t - n) : 0, function (r) {
      return (r - n) * t;
    };
  }
  function Ou(n, t) {
    return t = t - (n = +n) ? 1 / (t - n) : 0, function (r) {
      return Math.max(0, Math.min(1, (r - n) * t));
    };
  }
  function Iu(n) {
    for (var t = n.source, r = n.target, e = Zu(t, r), u = [t]; t !== e;)
      t = t.parent, u.push(t);
    for (var i = u.length; r !== e;)
      u.splice(i, 0, r), r = r.parent;
    return u;
  }
  function Yu(n) {
    for (var t = [], r = n.parent; null != r;)
      t.push(n), n = r, r = r.parent;
    return t.push(n), t;
  }
  function Zu(n, t) {
    if (n === t)
      return n;
    for (var r = Yu(n), e = Yu(t), u = r.pop(), i = e.pop(), o = null; u === i;)
      o = u, u = r.pop(), i = e.pop();
    return o;
  }
  function Vu(n) {
    n.fixed |= 2;
  }
  function $u(n) {
    n.fixed &= -7;
  }
  function Xu(n) {
    n.fixed |= 4, n.px = n.x, n.py = n.y;
  }
  function Bu(n) {
    n.fixed &= -5;
  }
  function Ju(n, t, r) {
    var e = 0, u = 0;
    if (n.charge = 0, !n.leaf)
      for (var i, o = n.nodes, a = o.length, c = -1; ++c < a;)
        i = o[c], null != i && (Ju(i, t, r), n.charge += i.charge, e += i.charge * i.cx, u += i.charge * i.cy);
    if (n.point) {
      n.leaf || (n.point.x += Math.random() - 0.5, n.point.y += Math.random() - 0.5);
      var s = t * r[n.point.index];
      n.charge += n.pointCharge = s, e += s * n.point.x, u += s * n.point.y;
    }
    n.cx = e / n.charge, n.cy = u / n.charge;
  }
  function Wu(n, t) {
    return Bo.rebind(n, t, 'sort', 'children', 'value'), n.nodes = n, n.links = ri, n;
  }
  function Gu(n, t) {
    for (var r = [n]; null != (n = r.pop());)
      if (t(n), (u = n.children) && (e = u.length))
        for (var e, u; --e >= 0;)
          r.push(u[e]);
  }
  function Ku(n, t) {
    for (var r = [n], e = []; null != (n = r.pop());)
      if (e.push(n), (i = n.children) && (u = i.length))
        for (var u, i, o = -1; ++o < u;)
          r.push(i[o]);
    for (; null != (n = e.pop());)
      t(n);
  }
  function Qu(n) {
    return n.children;
  }
  function ni(n) {
    return n.value;
  }
  function ti(n, t) {
    return t.value - n.value;
  }
  function ri(n) {
    return Bo.merge(n.map(function (n) {
      return (n.children || []).map(function (t) {
        return {
          source: n,
          target: t
        };
      });
    }));
  }
  function ei(n) {
    return n.x;
  }
  function ui(n) {
    return n.y;
  }
  function ii(n, t, r) {
    n.y0 = t, n.y = r;
  }
  function oi(n) {
    return Bo.range(n.length);
  }
  function ai(n) {
    for (var t = -1, r = n[0].length, e = []; ++t < r;)
      e[t] = 0;
    return e;
  }
  function ci(n) {
    for (var t, r = 1, e = 0, u = n[0][1], i = n.length; i > r; ++r)
      (t = n[r][1]) > u && (e = r, u = t);
    return e;
  }
  function si(n) {
    return n.reduce(li, 0);
  }
  function li(n, t) {
    return n + t[1];
  }
  function fi(n, t) {
    return hi(n, Math.ceil(Math.log(t.length) / Math.LN2 + 1));
  }
  function hi(n, t) {
    for (var r = -1, e = +n[0], u = (n[1] - e) / t, i = []; ++r <= t;)
      i[r] = u * r + e;
    return i;
  }
  function gi(n) {
    return [
      Bo.min(n),
      Bo.max(n)
    ];
  }
  function pi(n, t) {
    return n.value - t.value;
  }
  function vi(n, t) {
    var r = n._pack_next;
    n._pack_next = t, t._pack_prev = n, t._pack_next = r, r._pack_prev = t;
  }
  function di(n, t) {
    n._pack_next = t, t._pack_prev = n;
  }
  function mi(n, t) {
    var r = t.x - n.x, e = t.y - n.y, u = n.r + t.r;
    return 0.999 * u * u > r * r + e * e;
  }
  function yi(n) {
    function t(n) {
      l = Math.min(n.x - n.r, l), f = Math.max(n.x + n.r, f), h = Math.min(n.y - n.r, h), g = Math.max(n.y + n.r, g);
    }
    if ((r = n.children) && (s = r.length)) {
      var r, e, u, i, o, a, c, s, l = 1 / 0, f = -1 / 0, h = 1 / 0, g = -1 / 0;
      if (r.forEach(xi), e = r[0], e.x = -e.r, e.y = 0, t(e), s > 1 && (u = r[1], u.x = u.r, u.y = 0, t(u), s > 2))
        for (i = r[2], bi(e, u, i), t(i), vi(e, i), e._pack_prev = i, vi(i, u), u = e._pack_next, o = 3; s > o; o++) {
          bi(e, u, i = r[o]);
          var p = 0, v = 1, d = 1;
          for (a = u._pack_next; a !== u; a = a._pack_next, v++)
            if (mi(a, i)) {
              p = 1;
              break;
            }
          if (1 == p)
            for (c = e._pack_prev; c !== a._pack_prev && !mi(c, i); c = c._pack_prev, d++);
          p ? (d > v || v == d && u.r < e.r ? di(e, u = a) : di(e = c, u), o--) : (vi(e, i), u = i, t(i));
        }
      var m = (l + f) / 2, y = (h + g) / 2, x = 0;
      for (o = 0; s > o; o++)
        i = r[o], i.x -= m, i.y -= y, x = Math.max(x, i.r + Math.sqrt(i.x * i.x + i.y * i.y));
      n.r = x, r.forEach(Mi);
    }
  }
  function xi(n) {
    n._pack_next = n._pack_prev = n;
  }
  function Mi(n) {
    delete n._pack_next, delete n._pack_prev;
  }
  function _i(n, t, r, e) {
    var u = n.children;
    if (n.x = t += e * n.x, n.y = r += e * n.y, n.r *= e, u)
      for (var i = -1, o = u.length; ++i < o;)
        _i(u[i], t, r, e);
  }
  function bi(n, t, r) {
    var e = n.r + r.r, u = t.x - n.x, i = t.y - n.y;
    if (e && (u || i)) {
      var o = t.r + r.r, a = u * u + i * i;
      o *= o, e *= e;
      var c = 0.5 + (e - o) / (2 * a), s = Math.sqrt(Math.max(0, 2 * o * (e + a) - (e -= a) * e - o * o)) / (2 * a);
      r.x = n.x + c * u + s * i, r.y = n.y + c * i - s * u;
    } else
      r.x = n.x + e, r.y = n.y;
  }
  function wi(n, t) {
    return n.parent == t.parent ? 1 : 2;
  }
  function Si(n) {
    var t = n.children;
    return t.length ? t[0] : n.t;
  }
  function ki(n) {
    var t, r = n.children;
    return (t = r.length) ? r[t - 1] : n.t;
  }
  function Ei(n, t, r) {
    var e = r / (t.i - n.i);
    t.c -= e, t.s += r, n.c += e, t.z += r, t.m += r;
  }
  function Ai(n) {
    for (var t, r = 0, e = 0, u = n.children, i = u.length; --i >= 0;)
      t = u[i], t.z += r, t.m += r, r += t.s + (e += t.c);
  }
  function Ci(n, t, r) {
    return n.a.parent === t.parent ? n.a : r;
  }
  function Ni(n) {
    return 1 + Bo.max(n, function (n) {
      return n.y;
    });
  }
  function zi(n) {
    return n.reduce(function (n, t) {
      return n + t.x;
    }, 0) / n.length;
  }
  function Li(n) {
    var t = n.children;
    return t && t.length ? Li(t[0]) : n;
  }
  function Ti(n) {
    var t, r = n.children;
    return r && (t = r.length) ? Ti(r[t - 1]) : n;
  }
  function qi(n) {
    return {
      x: n.x,
      y: n.y,
      dx: n.dx,
      dy: n.dy
    };
  }
  function Ri(n, t) {
    var r = n.x + t[3], e = n.y + t[0], u = n.dx - t[1] - t[3], i = n.dy - t[0] - t[2];
    return 0 > u && (r += u / 2, u = 0), 0 > i && (e += i / 2, i = 0), {
      x: r,
      y: e,
      dx: u,
      dy: i
    };
  }
  function Di(n) {
    var t = n[0], r = n[n.length - 1];
    return r > t ? [
      t,
      r
    ] : [
      r,
      t
    ];
  }
  function Pi(n) {
    return n.rangeExtent ? n.rangeExtent() : Di(n.range());
  }
  function Ui(n, t, r, e) {
    var u = r(n[0], n[1]), i = e(t[0], t[1]);
    return function (n) {
      return i(u(n));
    };
  }
  function ji(n, t) {
    var r, e = 0, u = n.length - 1, i = n[e], o = n[u];
    return i > o && (r = e, e = u, u = r, r = i, i = o, o = r), n[e] = t.floor(i), n[u] = t.ceil(o), n;
  }
  function Hi(n) {
    return n ? {
      floor: function (t) {
        return Math.floor(t / n) * n;
      },
      ceil: function (t) {
        return Math.ceil(t / n) * n;
      }
    } : hs;
  }
  function Fi(n, t, r, e) {
    var u = [], i = [], o = 0, a = Math.min(n.length, t.length) - 1;
    for (n[a] < n[0] && (n = n.slice().reverse(), t = t.slice().reverse()); ++o <= a;)
      u.push(r(n[o - 1], n[o])), i.push(e(t[o - 1], t[o]));
    return function (t) {
      var r = Bo.bisect(n, t, 1, a) - 1;
      return i[r](u[r](t));
    };
  }
  function Oi(n, t, r, e) {
    function u() {
      var u = Math.min(n.length, t.length) > 2 ? Fi : Ui, c = e ? Ou : Fu;
      return o = u(n, t, c, r), a = u(t, n, c, du), i;
    }
    function i(n) {
      return o(n);
    }
    var o, a;
    return i.invert = function (n) {
      return a(n);
    }, i.domain = function (t) {
      return arguments.length ? (n = t.map(Number), u()) : n;
    }, i.range = function (n) {
      return arguments.length ? (t = n, u()) : t;
    }, i.rangeRound = function (n) {
      return i.range(n).interpolate(Ru);
    }, i.clamp = function (n) {
      return arguments.length ? (e = n, u()) : e;
    }, i.interpolate = function (n) {
      return arguments.length ? (r = n, u()) : r;
    }, i.ticks = function (t) {
      return Vi(n, t);
    }, i.tickFormat = function (t, r) {
      return $i(n, t, r);
    }, i.nice = function (t) {
      return Yi(n, t), u();
    }, i.copy = function () {
      return Oi(n, t, r, e);
    }, u();
  }
  function Ii(n, t) {
    return Bo.rebind(n, t, 'range', 'rangeRound', 'interpolate', 'clamp');
  }
  function Yi(n, t) {
    return ji(n, Hi(Zi(n, t)[2]));
  }
  function Zi(n, t) {
    null == t && (t = 10);
    var r = Di(n), e = r[1] - r[0], u = Math.pow(10, Math.floor(Math.log(e / t) / Math.LN10)), i = t / e * u;
    return 0.15 >= i ? u *= 10 : 0.35 >= i ? u *= 5 : 0.75 >= i && (u *= 2), r[0] = Math.ceil(r[0] / u) * u, r[1] = Math.floor(r[1] / u) * u + 0.5 * u, r[2] = u, r;
  }
  function Vi(n, t) {
    return Bo.range.apply(Bo, Zi(n, t));
  }
  function $i(n, t, r) {
    var e = Zi(n, t);
    if (r) {
      var u = nc.exec(r);
      if (u.shift(), 's' === u[8]) {
        var i = Bo.formatPrefix(Math.max(ca(e[0]), ca(e[1])));
        return u[7] || (u[7] = '.' + Xi(i.scale(e[2]))), u[8] = 'f', r = Bo.format(u.join('')), function (n) {
          return r(i.scale(n)) + i.symbol;
        };
      }
      u[7] || (u[7] = '.' + Bi(u[8], e)), r = u.join('');
    } else
      r = ',.' + Xi(e[2]) + 'f';
    return Bo.format(r);
  }
  function Xi(n) {
    return -Math.floor(Math.log(n) / Math.LN10 + 0.01);
  }
  function Bi(n, t) {
    var r = Xi(t[2]);
    return n in gs ? Math.abs(r - Xi(Math.max(ca(t[0]), ca(t[1])))) + +('e' !== n) : r - 2 * ('%' === n);
  }
  function Ji(n, t, r, e) {
    function u(n) {
      return (r ? Math.log(0 > n ? 0 : n) : -Math.log(n > 0 ? 0 : -n)) / Math.log(t);
    }
    function i(n) {
      return r ? Math.pow(t, n) : -Math.pow(t, -n);
    }
    function o(t) {
      return n(u(t));
    }
    return o.invert = function (t) {
      return i(n.invert(t));
    }, o.domain = function (t) {
      return arguments.length ? (r = t[0] >= 0, n.domain((e = t.map(Number)).map(u)), o) : e;
    }, o.base = function (r) {
      return arguments.length ? (t = +r, n.domain(e.map(u)), o) : t;
    }, o.nice = function () {
      var t = ji(e.map(u), r ? Math : vs);
      return n.domain(t), e = t.map(i), o;
    }, o.ticks = function () {
      var n = Di(e), o = [], a = n[0], c = n[1], s = Math.floor(u(a)), l = Math.ceil(u(c)), f = t % 1 ? 2 : t;
      if (isFinite(l - s)) {
        if (r) {
          for (; l > s; s++)
            for (var h = 1; f > h; h++)
              o.push(i(s) * h);
          o.push(i(s));
        } else
          for (o.push(i(s)); s++ < l;)
            for (var h = f - 1; h > 0; h--)
              o.push(i(s) * h);
        for (s = 0; o[s] < a; s++);
        for (l = o.length; o[l - 1] > c; l--);
        o = o.slice(s, l);
      }
      return o;
    }, o.tickFormat = function (n, t) {
      if (!arguments.length)
        return ps;
      arguments.length < 2 ? t = ps : 'function' != typeof t && (t = Bo.format(t));
      var e, a = Math.max(0.1, n / o.ticks().length), c = r ? (e = 1e-12, Math.ceil) : (e = -1e-12, Math.floor);
      return function (n) {
        return n / i(c(u(n) + e)) <= a ? t(n) : '';
      };
    }, o.copy = function () {
      return Ji(n.copy(), t, r, e);
    }, Ii(o, n);
  }
  function Wi(n, t, r) {
    function e(t) {
      return n(u(t));
    }
    var u = Gi(t), i = Gi(1 / t);
    return e.invert = function (t) {
      return i(n.invert(t));
    }, e.domain = function (t) {
      return arguments.length ? (n.domain((r = t.map(Number)).map(u)), e) : r;
    }, e.ticks = function (n) {
      return Vi(r, n);
    }, e.tickFormat = function (n, t) {
      return $i(r, n, t);
    }, e.nice = function (n) {
      return e.domain(Yi(r, n));
    }, e.exponent = function (o) {
      return arguments.length ? (u = Gi(t = o), i = Gi(1 / t), n.domain(r.map(u)), e) : t;
    }, e.copy = function () {
      return Wi(n.copy(), t, r);
    }, Ii(e, n);
  }
  function Gi(n) {
    return function (t) {
      return 0 > t ? -Math.pow(-t, n) : Math.pow(t, n);
    };
  }
  function Ki(n, t) {
    function r(r) {
      return i[((u.get(r) || ('range' === t.t ? u.set(r, n.push(r)) : 0 / 0)) - 1) % i.length];
    }
    function e(t, r) {
      return Bo.range(n.length).map(function (n) {
        return t + r * n;
      });
    }
    var u, i, a;
    return r.domain = function (e) {
      if (!arguments.length)
        return n;
      n = [], u = new o();
      for (var i, a = -1, c = e.length; ++a < c;)
        u.has(i = e[a]) || u.set(i, n.push(i));
      return r[t.t].apply(r, t.a);
    }, r.range = function (n) {
      return arguments.length ? (i = n, a = 0, t = {
        t: 'range',
        a: arguments
      }, r) : i;
    }, r.rangePoints = function (u, o) {
      arguments.length < 2 && (o = 0);
      var c = u[0], s = u[1], l = (s - c) / (Math.max(1, n.length - 1) + o);
      return i = e(n.length < 2 ? (c + s) / 2 : c + l * o / 2, l), a = 0, t = {
        t: 'rangePoints',
        a: arguments
      }, r;
    }, r.rangeBands = function (u, o, c) {
      arguments.length < 2 && (o = 0), arguments.length < 3 && (c = o);
      var s = u[1] < u[0], l = u[s - 0], f = u[1 - s], h = (f - l) / (n.length - o + 2 * c);
      return i = e(l + h * c, h), s && i.reverse(), a = h * (1 - o), t = {
        t: 'rangeBands',
        a: arguments
      }, r;
    }, r.rangeRoundBands = function (u, o, c) {
      arguments.length < 2 && (o = 0), arguments.length < 3 && (c = o);
      var s = u[1] < u[0], l = u[s - 0], f = u[1 - s], h = Math.floor((f - l) / (n.length - o + 2 * c)), g = f - l - (n.length - o) * h;
      return i = e(l + Math.round(g / 2), h), s && i.reverse(), a = Math.round(h * (1 - o)), t = {
        t: 'rangeRoundBands',
        a: arguments
      }, r;
    }, r.rangeBand = function () {
      return a;
    }, r.rangeExtent = function () {
      return Di(t.a[0]);
    }, r.copy = function () {
      return Ki(n, t);
    }, r.domain(n);
  }
  function Qi(r, e) {
    function u() {
      var n = 0, t = e.length;
      for (o = []; ++n < t;)
        o[n - 1] = Bo.quantile(r, n / t);
      return i;
    }
    function i(n) {
      return isNaN(n = +n) ? void 0 : e[Bo.bisect(o, n)];
    }
    var o;
    return i.domain = function (e) {
      return arguments.length ? (r = e.filter(t).sort(n), u()) : r;
    }, i.range = function (n) {
      return arguments.length ? (e = n, u()) : e;
    }, i.quantiles = function () {
      return o;
    }, i.invertExtent = function (n) {
      return n = e.indexOf(n), 0 > n ? [
        0 / 0,
        0 / 0
      ] : [
        n > 0 ? o[n - 1] : r[0],
        n < o.length ? o[n] : r[r.length - 1]
      ];
    }, i.copy = function () {
      return Qi(r, e);
    }, u();
  }
  function no(n, t, r) {
    function e(t) {
      return r[Math.max(0, Math.min(o, Math.floor(i * (t - n))))];
    }
    function u() {
      return i = r.length / (t - n), o = r.length - 1, e;
    }
    var i, o;
    return e.domain = function (r) {
      return arguments.length ? (n = +r[0], t = +r[r.length - 1], u()) : [
        n,
        t
      ];
    }, e.range = function (n) {
      return arguments.length ? (r = n, u()) : r;
    }, e.invertExtent = function (t) {
      return t = r.indexOf(t), t = 0 > t ? 0 / 0 : t / i + n, [
        t,
        t + 1 / i
      ];
    }, e.copy = function () {
      return no(n, t, r);
    }, u();
  }
  function to(n, t) {
    function r(r) {
      return r >= r ? t[Bo.bisect(n, r)] : void 0;
    }
    return r.domain = function (t) {
      return arguments.length ? (n = t, r) : n;
    }, r.range = function (n) {
      return arguments.length ? (t = n, r) : t;
    }, r.invertExtent = function (r) {
      return r = t.indexOf(r), [
        n[r - 1],
        n[r]
      ];
    }, r.copy = function () {
      return to(n, t);
    }, r;
  }
  function ro(n) {
    function t(n) {
      return +n;
    }
    return t.invert = t, t.domain = t.range = function (r) {
      return arguments.length ? (n = r.map(t), t) : n;
    }, t.ticks = function (t) {
      return Vi(n, t);
    }, t.tickFormat = function (t, r) {
      return $i(n, t, r);
    }, t.copy = function () {
      return ro(n);
    }, t;
  }
  function eo(n) {
    return n.innerRadius;
  }
  function uo(n) {
    return n.outerRadius;
  }
  function io(n) {
    return n.startAngle;
  }
  function oo(n) {
    return n.endAngle;
  }
  function ao(n) {
    function t(t) {
      function o() {
        s.push('M', i(n(l), a));
      }
      for (var c, s = [], l = [], f = -1, h = t.length, g = Et(r), p = Et(e); ++f < h;)
        u.call(this, c = t[f], f) ? l.push([
          +g.call(this, c, f),
          +p.call(this, c, f)
        ]) : l.length && (o(), l = []);
      return l.length && o(), s.length ? s.join('') : null;
    }
    var r = Ae, e = Ce, u = Ar, i = co, o = i.key, a = 0.7;
    return t.x = function (n) {
      return arguments.length ? (r = n, t) : r;
    }, t.y = function (n) {
      return arguments.length ? (e = n, t) : e;
    }, t.defined = function (n) {
      return arguments.length ? (u = n, t) : u;
    }, t.interpolate = function (n) {
      return arguments.length ? (o = 'function' == typeof n ? i = n : (i = bs.get(n) || co).key, t) : o;
    }, t.tension = function (n) {
      return arguments.length ? (a = n, t) : a;
    }, t;
  }
  function co(n) {
    return n.join('L');
  }
  function so(n) {
    return co(n) + 'Z';
  }
  function lo(n) {
    for (var t = 0, r = n.length, e = n[0], u = [
          e[0],
          ',',
          e[1]
        ]; ++t < r;)
      u.push('H', (e[0] + (e = n[t])[0]) / 2, 'V', e[1]);
    return r > 1 && u.push('H', e[0]), u.join('');
  }
  function fo(n) {
    for (var t = 0, r = n.length, e = n[0], u = [
          e[0],
          ',',
          e[1]
        ]; ++t < r;)
      u.push('V', (e = n[t])[1], 'H', e[0]);
    return u.join('');
  }
  function ho(n) {
    for (var t = 0, r = n.length, e = n[0], u = [
          e[0],
          ',',
          e[1]
        ]; ++t < r;)
      u.push('H', (e = n[t])[0], 'V', e[1]);
    return u.join('');
  }
  function go(n, t) {
    return n.length < 4 ? co(n) : n[1] + mo(n.slice(1, n.length - 1), yo(n, t));
  }
  function po(n, t) {
    return n.length < 3 ? co(n) : n[0] + mo((n.push(n[0]), n), yo([n[n.length - 2]].concat(n, [n[1]]), t));
  }
  function vo(n, t) {
    return n.length < 3 ? co(n) : n[0] + mo(n, yo(n, t));
  }
  function mo(n, t) {
    if (t.length < 1 || n.length != t.length && n.length != t.length + 2)
      return co(n);
    var r = n.length != t.length, e = '', u = n[0], i = n[1], o = t[0], a = o, c = 1;
    if (r && (e += 'Q' + (i[0] - 2 * o[0] / 3) + ',' + (i[1] - 2 * o[1] / 3) + ',' + i[0] + ',' + i[1], u = n[1], c = 2), t.length > 1) {
      a = t[1], i = n[c], c++, e += 'C' + (u[0] + o[0]) + ',' + (u[1] + o[1]) + ',' + (i[0] - a[0]) + ',' + (i[1] - a[1]) + ',' + i[0] + ',' + i[1];
      for (var s = 2; s < t.length; s++, c++)
        i = n[c], a = t[s], e += 'S' + (i[0] - a[0]) + ',' + (i[1] - a[1]) + ',' + i[0] + ',' + i[1];
    }
    if (r) {
      var l = n[c];
      e += 'Q' + (i[0] + 2 * a[0] / 3) + ',' + (i[1] + 2 * a[1] / 3) + ',' + l[0] + ',' + l[1];
    }
    return e;
  }
  function yo(n, t) {
    for (var r, e = [], u = (1 - t) / 2, i = n[0], o = n[1], a = 1, c = n.length; ++a < c;)
      r = i, i = o, o = n[a], e.push([
        u * (o[0] - r[0]),
        u * (o[1] - r[1])
      ]);
    return e;
  }
  function xo(n) {
    if (n.length < 3)
      return co(n);
    var t = 1, r = n.length, e = n[0], u = e[0], i = e[1], o = [
        u,
        u,
        u,
        (e = n[1])[0]
      ], a = [
        i,
        i,
        i,
        e[1]
      ], c = [
        u,
        ',',
        i,
        'L',
        wo(ks, o),
        ',',
        wo(ks, a)
      ];
    for (n.push(n[r - 1]); ++t <= r;)
      e = n[t], o.shift(), o.push(e[0]), a.shift(), a.push(e[1]), So(c, o, a);
    return n.pop(), c.push('L', e), c.join('');
  }
  function Mo(n) {
    if (n.length < 4)
      return co(n);
    for (var t, r = [], e = -1, u = n.length, i = [0], o = [0]; ++e < 3;)
      t = n[e], i.push(t[0]), o.push(t[1]);
    for (r.push(wo(ks, i) + ',' + wo(ks, o)), --e; ++e < u;)
      t = n[e], i.shift(), i.push(t[0]), o.shift(), o.push(t[1]), So(r, i, o);
    return r.join('');
  }
  function _o(n) {
    for (var t, r, e = -1, u = n.length, i = u + 4, o = [], a = []; ++e < 4;)
      r = n[e % u], o.push(r[0]), a.push(r[1]);
    for (t = [
        wo(ks, o),
        ',',
        wo(ks, a)
      ], --e; ++e < i;)
      r = n[e % u], o.shift(), o.push(r[0]), a.shift(), a.push(r[1]), So(t, o, a);
    return t.join('');
  }
  function bo(n, t) {
    var r = n.length - 1;
    if (r)
      for (var e, u, i = n[0][0], o = n[0][1], a = n[r][0] - i, c = n[r][1] - o, s = -1; ++s <= r;)
        e = n[s], u = s / r, e[0] = t * e[0] + (1 - t) * (i + u * a), e[1] = t * e[1] + (1 - t) * (o + u * c);
    return xo(n);
  }
  function wo(n, t) {
    return n[0] * t[0] + n[1] * t[1] + n[2] * t[2] + n[3] * t[3];
  }
  function So(n, t, r) {
    n.push('C', wo(ws, t), ',', wo(ws, r), ',', wo(Ss, t), ',', wo(Ss, r), ',', wo(ks, t), ',', wo(ks, r));
  }
  function ko(n, t) {
    return (t[1] - n[1]) / (t[0] - n[0]);
  }
  function Eo(n) {
    for (var t = 0, r = n.length - 1, e = [], u = n[0], i = n[1], o = e[0] = ko(u, i); ++t < r;)
      e[t] = (o + (o = ko(u = i, i = n[t + 1]))) / 2;
    return e[t] = o, e;
  }
  function Ao(n) {
    for (var t, r, e, u, i = [], o = Eo(n), a = -1, c = n.length - 1; ++a < c;)
      t = ko(n[a], n[a + 1]), ca(t) < Ca ? o[a] = o[a + 1] = 0 : (r = o[a] / t, e = o[a + 1] / t, u = r * r + e * e, u > 9 && (u = 3 * t / Math.sqrt(u), o[a] = u * r, o[a + 1] = u * e));
    for (a = -1; ++a <= c;)
      u = (n[Math.min(c, a + 1)][0] - n[Math.max(0, a - 1)][0]) / (6 * (1 + o[a] * o[a])), i.push([
        u || 0,
        o[a] * u || 0
      ]);
    return i;
  }
  function Co(n) {
    return n.length < 3 ? co(n) : n[0] + mo(n, Ao(n));
  }
  function No(n) {
    for (var t, r, e, u = -1, i = n.length; ++u < i;)
      t = n[u], r = t[0], e = t[1] + Ms, t[0] = r * Math.cos(e), t[1] = r * Math.sin(e);
    return n;
  }
  function zo(n) {
    function t(t) {
      function c() {
        v.push('M', a(n(m), f), l, s(n(d.reverse()), f), 'Z');
      }
      for (var h, g, p, v = [], d = [], m = [], y = -1, x = t.length, M = Et(r), _ = Et(u), b = r === e ? function () {
            return g;
          } : Et(e), w = u === i ? function () {
            return p;
          } : Et(i); ++y < x;)
        o.call(this, h = t[y], y) ? (d.push([
          g = +M.call(this, h, y),
          p = +_.call(this, h, y)
        ]), m.push([
          +b.call(this, h, y),
          +w.call(this, h, y)
        ])) : d.length && (c(), d = [], m = []);
      return d.length && c(), v.length ? v.join('') : null;
    }
    var r = Ae, e = Ae, u = 0, i = Ce, o = Ar, a = co, c = a.key, s = a, l = 'L', f = 0.7;
    return t.x = function (n) {
      return arguments.length ? (r = e = n, t) : e;
    }, t.x0 = function (n) {
      return arguments.length ? (r = n, t) : r;
    }, t.x1 = function (n) {
      return arguments.length ? (e = n, t) : e;
    }, t.y = function (n) {
      return arguments.length ? (u = i = n, t) : i;
    }, t.y0 = function (n) {
      return arguments.length ? (u = n, t) : u;
    }, t.y1 = function (n) {
      return arguments.length ? (i = n, t) : i;
    }, t.defined = function (n) {
      return arguments.length ? (o = n, t) : o;
    }, t.interpolate = function (n) {
      return arguments.length ? (c = 'function' == typeof n ? a = n : (a = bs.get(n) || co).key, s = a.reverse || a, l = a.closed ? 'M' : 'L', t) : c;
    }, t.tension = function (n) {
      return arguments.length ? (f = n, t) : f;
    }, t;
  }
  function Lo(n) {
    return n.radius;
  }
  function To(n) {
    return [
      n.x,
      n.y
    ];
  }
  function qo(n) {
    return function () {
      var t = n.apply(this, arguments), r = t[0], e = t[1] + Ms;
      return [
        r * Math.cos(e),
        r * Math.sin(e)
      ];
    };
  }
  function Ro() {
    return 64;
  }
  function Do() {
    return 'circle';
  }
  function Po(n) {
    var t = Math.sqrt(n / ka);
    return 'M0,' + t + 'A' + t + ',' + t + ' 0 1,1 0,' + -t + 'A' + t + ',' + t + ' 0 1,1 0,' + t + 'Z';
  }
  function Uo(n, t) {
    return ga(n, Ls), n.id = t, n;
  }
  function jo(n, t, r, e) {
    var u = n.id;
    return P(n, 'function' == typeof r ? function (n, i, o) {
      n.__transition__[u].tween.set(t, e(r.call(n, n.__data__, i, o)));
    } : (r = e(r), function (n) {
      n.__transition__[u].tween.set(t, r);
    }));
  }
  function Ho(n) {
    return null == n && (n = ''), function () {
      this.textContent = n;
    };
  }
  function Fo(n, t, r, e) {
    var u = n.__transition__ || (n.__transition__ = {
        active: 0,
        count: 0
      }), i = u[r];
    if (!i) {
      var a = e.time;
      i = u[r] = {
        tween: new o(),
        time: a,
        ease: e.ease,
        delay: e.delay,
        duration: e.duration
      }, ++u.count, Bo.timer(function (e) {
        function o(e) {
          return u.active > r ? s() : (u.active = r, i.event && i.event.start.call(n, l, t), i.tween.forEach(function (r, e) {
            (e = e.call(n, l, t)) && v.push(e);
          }), Bo.timer(function () {
            return p.c = c(e || 1) ? Ar : c, 1;
          }, 0, a), void 0);
        }
        function c(e) {
          if (u.active !== r)
            return s();
          for (var o = e / g, a = f(o), c = v.length; c > 0;)
            v[--c].call(n, a);
          return o >= 1 ? (i.event && i.event.end.call(n, l, t), s()) : void 0;
        }
        function s() {
          return --u.count ? delete u[r] : delete n.__transition__, 1;
        }
        var l = n.__data__, f = i.ease, h = i.delay, g = i.duration, p = Ga, v = [];
        return p.t = h + a, e >= h ? o(e - h) : (p.c = o, void 0);
      }, 0, a);
    }
  }
  function Oo(n, t) {
    n.attr('transform', function (n) {
      return 'translate(' + t(n) + ',0)';
    });
  }
  function Io(n, t) {
    n.attr('transform', function (n) {
      return 'translate(0,' + t(n) + ')';
    });
  }
  function Yo(n) {
    return n.toISOString();
  }
  function Zo(n, t, r) {
    function e(t) {
      return n(t);
    }
    function u(n, r) {
      var e = n[1] - n[0], u = e / r, i = Bo.bisect(Fs, u);
      return i == Fs.length ? [
        t.year,
        Zi(n.map(function (n) {
          return n / 31536000000;
        }), r)[2]
      ] : i ? t[u / Fs[i - 1] < Fs[i] / u ? i - 1 : i] : [
        Ys,
        Zi(n, r)[2]
      ];
    }
    return e.invert = function (t) {
      return Vo(n.invert(t));
    }, e.domain = function (t) {
      return arguments.length ? (n.domain(t), e) : n.domain().map(Vo);
    }, e.nice = function (n, t) {
      function r(r) {
        return !isNaN(r) && !n.range(r, Vo(+r + 1), t).length;
      }
      var i = e.domain(), o = Di(i), a = null == n ? u(o, 10) : 'number' == typeof n && u(o, n);
      return a && (n = a[0], t = a[1]), e.domain(ji(i, t > 1 ? {
        floor: function (t) {
          for (; r(t = n.floor(t));)
            t = Vo(t - 1);
          return t;
        },
        ceil: function (t) {
          for (; r(t = n.ceil(t));)
            t = Vo(+t + 1);
          return t;
        }
      } : n));
    }, e.ticks = function (n, t) {
      var r = Di(e.domain()), i = null == n ? u(r, 10) : 'number' == typeof n ? u(r, n) : !n.range && [
          { range: n },
          t
        ];
      return i && (n = i[0], t = i[1]), n.range(r[0], Vo(+r[1] + 1), 1 > t ? 1 : t);
    }, e.tickFormat = function () {
      return r;
    }, e.copy = function () {
      return Zo(n.copy(), t, r);
    }, Ii(e, n);
  }
  function Vo(n) {
    return new Date(n);
  }
  function $o(n) {
    return JSON.parse(n.responseText);
  }
  function Xo(n) {
    var t = Go.createRange();
    return t.selectNode(Go.body), t.createContextualFragment(n.responseText);
  }
  var Bo = { version: '3.4.8' };
  Date.now || (Date.now = function () {
    return +new Date();
  });
  var Jo = [].slice, Wo = function (n) {
      return Jo.call(n);
    }, Go = document, Ko = Go.documentElement, Qo = window;
  try {
    Wo(Ko.childNodes)[0].nodeType;
  } catch (na) {
    Wo = function (n) {
      for (var t = n.length, r = new Array(t); t--;)
        r[t] = n[t];
      return r;
    };
  }
  try {
    Go.createElement('div').style.setProperty('opacity', 0, '');
  } catch (ta) {
    var ra = Qo.Element.prototype, ea = ra.setAttribute, ua = ra.setAttributeNS, ia = Qo.CSSStyleDeclaration.prototype, oa = ia.setProperty;
    ra.setAttribute = function (n, t) {
      ea.call(this, n, t + '');
    }, ra.setAttributeNS = function (n, t, r) {
      ua.call(this, n, t, r + '');
    }, ia.setProperty = function (n, t, r) {
      oa.call(this, n, t + '', r);
    };
  }
  Bo.ascending = n, Bo.descending = function (n, t) {
    return n > t ? -1 : t > n ? 1 : t >= n ? 0 : 0 / 0;
  }, Bo.min = function (n, t) {
    var r, e, u = -1, i = n.length;
    if (1 === arguments.length) {
      for (; ++u < i && !(null != (r = n[u]) && r >= r);)
        r = void 0;
      for (; ++u < i;)
        null != (e = n[u]) && r > e && (r = e);
    } else {
      for (; ++u < i && !(null != (r = t.call(n, n[u], u)) && r >= r);)
        r = void 0;
      for (; ++u < i;)
        null != (e = t.call(n, n[u], u)) && r > e && (r = e);
    }
    return r;
  }, Bo.max = function (n, t) {
    var r, e, u = -1, i = n.length;
    if (1 === arguments.length) {
      for (; ++u < i && !(null != (r = n[u]) && r >= r);)
        r = void 0;
      for (; ++u < i;)
        null != (e = n[u]) && e > r && (r = e);
    } else {
      for (; ++u < i && !(null != (r = t.call(n, n[u], u)) && r >= r);)
        r = void 0;
      for (; ++u < i;)
        null != (e = t.call(n, n[u], u)) && e > r && (r = e);
    }
    return r;
  }, Bo.extent = function (n, t) {
    var r, e, u, i = -1, o = n.length;
    if (1 === arguments.length) {
      for (; ++i < o && !(null != (r = u = n[i]) && r >= r);)
        r = u = void 0;
      for (; ++i < o;)
        null != (e = n[i]) && (r > e && (r = e), e > u && (u = e));
    } else {
      for (; ++i < o && !(null != (r = u = t.call(n, n[i], i)) && r >= r);)
        r = void 0;
      for (; ++i < o;)
        null != (e = t.call(n, n[i], i)) && (r > e && (r = e), e > u && (u = e));
    }
    return [
      r,
      u
    ];
  }, Bo.sum = function (n, t) {
    var r, e = 0, u = n.length, i = -1;
    if (1 === arguments.length)
      for (; ++i < u;)
        isNaN(r = +n[i]) || (e += r);
    else
      for (; ++i < u;)
        isNaN(r = +t.call(n, n[i], i)) || (e += r);
    return e;
  }, Bo.mean = function (n, r) {
    var e, u = 0, i = n.length, o = -1, a = i;
    if (1 === arguments.length)
      for (; ++o < i;)
        t(e = n[o]) ? u += e : --a;
    else
      for (; ++o < i;)
        t(e = r.call(n, n[o], o)) ? u += e : --a;
    return a ? u / a : void 0;
  }, Bo.quantile = function (n, t) {
    var r = (n.length - 1) * t + 1, e = Math.floor(r), u = +n[e - 1], i = r - e;
    return i ? u + i * (n[e] - u) : u;
  }, Bo.median = function (r, e) {
    return arguments.length > 1 && (r = r.map(e)), r = r.filter(t), r.length ? Bo.quantile(r.sort(n), 0.5) : void 0;
  };
  var aa = r(n);
  Bo.bisectLeft = aa.left, Bo.bisect = Bo.bisectRight = aa.right, Bo.bisector = function (t) {
    return r(1 === t.length ? function (r, e) {
      return n(t(r), e);
    } : t);
  }, Bo.shuffle = function (n) {
    for (var t, r, e = n.length; e;)
      r = 0 | Math.random() * e--, t = n[e], n[e] = n[r], n[r] = t;
    return n;
  }, Bo.permute = function (n, t) {
    for (var r = t.length, e = new Array(r); r--;)
      e[r] = n[t[r]];
    return e;
  }, Bo.pairs = function (n) {
    for (var t, r = 0, e = n.length - 1, u = n[0], i = new Array(0 > e ? 0 : e); e > r;)
      i[r] = [
        t = u,
        u = n[++r]
      ];
    return i;
  }, Bo.zip = function () {
    if (!(u = arguments.length))
      return [];
    for (var n = -1, t = Bo.min(arguments, e), r = new Array(t); ++n < t;)
      for (var u, i = -1, o = r[n] = new Array(u); ++i < u;)
        o[i] = arguments[i][n];
    return r;
  }, Bo.transpose = function (n) {
    return Bo.zip.apply(Bo, n);
  }, Bo.keys = function (n) {
    var t = [];
    for (var r in n)
      t.push(r);
    return t;
  }, Bo.values = function (n) {
    var t = [];
    for (var r in n)
      t.push(n[r]);
    return t;
  }, Bo.entries = function (n) {
    var t = [];
    for (var r in n)
      t.push({
        key: r,
        value: n[r]
      });
    return t;
  }, Bo.merge = function (n) {
    for (var t, r, e, u = n.length, i = -1, o = 0; ++i < u;)
      o += n[i].length;
    for (r = new Array(o); --u >= 0;)
      for (e = n[u], t = e.length; --t >= 0;)
        r[--o] = e[t];
    return r;
  };
  var ca = Math.abs;
  Bo.range = function (n, t, r) {
    if (arguments.length < 3 && (r = 1, arguments.length < 2 && (t = n, n = 0)), 1 / 0 === (t - n) / r)
      throw new Error('infinite range');
    var e, i = [], o = u(ca(r)), a = -1;
    if (n *= o, t *= o, r *= o, 0 > r)
      for (; (e = n + r * ++a) > t;)
        i.push(e / o);
    else
      for (; (e = n + r * ++a) < t;)
        i.push(e / o);
    return i;
  }, Bo.map = function (n) {
    var t = new o();
    if (n instanceof o)
      n.forEach(function (n, r) {
        t.set(n, r);
      });
    else
      for (var r in n)
        t.set(r, n[r]);
    return t;
  }, i(o, {
    has: a,
    get: function (n) {
      return this[sa + n];
    },
    set: function (n, t) {
      return this[sa + n] = t;
    },
    remove: c,
    keys: s,
    values: function () {
      var n = [];
      return this.forEach(function (t, r) {
        n.push(r);
      }), n;
    },
    entries: function () {
      var n = [];
      return this.forEach(function (t, r) {
        n.push({
          key: t,
          value: r
        });
      }), n;
    },
    size: l,
    empty: f,
    forEach: function (n) {
      for (var t in this)
        t.charCodeAt(0) === la && n.call(this, t.substring(1), this[t]);
    }
  });
  var sa = '\0', la = sa.charCodeAt(0);
  Bo.nest = function () {
    function n(t, a, c) {
      if (c >= i.length)
        return e ? e.call(u, a) : r ? a.sort(r) : a;
      for (var s, l, f, h, g = -1, p = a.length, v = i[c++], d = new o(); ++g < p;)
        (h = d.get(s = v(l = a[g]))) ? h.push(l) : d.set(s, [l]);
      return t ? (l = t(), f = function (r, e) {
        l.set(r, n(t, e, c));
      }) : (l = {}, f = function (r, e) {
        l[r] = n(t, e, c);
      }), d.forEach(f), l;
    }
    function t(n, r) {
      if (r >= i.length)
        return n;
      var e = [], u = a[r++];
      return n.forEach(function (n, u) {
        e.push({
          key: n,
          values: t(u, r)
        });
      }), u ? e.sort(function (n, t) {
        return u(n.key, t.key);
      }) : e;
    }
    var r, e, u = {}, i = [], a = [];
    return u.map = function (t, r) {
      return n(r, t, 0);
    }, u.entries = function (r) {
      return t(n(Bo.map, r, 0), 0);
    }, u.key = function (n) {
      return i.push(n), u;
    }, u.sortKeys = function (n) {
      return a[i.length - 1] = n, u;
    }, u.sortValues = function (n) {
      return r = n, u;
    }, u.rollup = function (n) {
      return e = n, u;
    }, u;
  }, Bo.set = function (n) {
    var t = new h();
    if (n)
      for (var r = 0, e = n.length; e > r; ++r)
        t.add(n[r]);
    return t;
  }, i(h, {
    has: a,
    add: function (n) {
      return this[sa + n] = !0, n;
    },
    remove: function (n) {
      return n = sa + n, n in this && delete this[n];
    },
    values: s,
    size: l,
    empty: f,
    forEach: function (n) {
      for (var t in this)
        t.charCodeAt(0) === la && n.call(this, t.substring(1));
    }
  }), Bo.behavior = {}, Bo.rebind = function (n, t) {
    for (var r, e = 1, u = arguments.length; ++e < u;)
      n[r = arguments[e]] = g(n, t, t[r]);
    return n;
  };
  var fa = [
      'webkit',
      'ms',
      'moz',
      'Moz',
      'o',
      'O'
    ];
  Bo.dispatch = function () {
    for (var n = new d(), t = -1, r = arguments.length; ++t < r;)
      n[arguments[t]] = m(n);
    return n;
  }, d.prototype.on = function (n, t) {
    var r = n.indexOf('.'), e = '';
    if (r >= 0 && (e = n.substring(r + 1), n = n.substring(0, r)), n)
      return arguments.length < 2 ? this[n].on(e) : this[n].on(e, t);
    if (2 === arguments.length) {
      if (null == t)
        for (n in this)
          this.hasOwnProperty(n) && this[n].on(e, null);
      return this;
    }
  }, Bo.event = null, Bo.requote = function (n) {
    return n.replace(ha, '\\$&');
  };
  var ha = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g, ga = {}.__proto__ ? function (n, t) {
      n.__proto__ = t;
    } : function (n, t) {
      for (var r in t)
        n[r] = t[r];
    }, pa = function (n, t) {
      return t.querySelector(n);
    }, va = function (n, t) {
      return t.querySelectorAll(n);
    }, da = Ko[p(Ko, 'matchesSelector')], ma = function (n, t) {
      return da.call(n, t);
    };
  'function' == typeof Sizzle && (pa = function (n, t) {
    return Sizzle(n, t)[0] || null;
  }, va = Sizzle, ma = Sizzle.matchesSelector), Bo.selection = function () {
    return _a;
  };
  var ya = Bo.selection.prototype = [];
  ya.select = function (n) {
    var t, r, e, u, i = [];
    n = b(n);
    for (var o = -1, a = this.length; ++o < a;) {
      i.push(t = []), t.parentNode = (e = this[o]).parentNode;
      for (var c = -1, s = e.length; ++c < s;)
        (u = e[c]) ? (t.push(r = n.call(u, u.__data__, c, o)), r && '__data__' in u && (r.__data__ = u.__data__)) : t.push(null);
    }
    return _(i);
  }, ya.selectAll = function (n) {
    var t, r, e = [];
    n = w(n);
    for (var u = -1, i = this.length; ++u < i;)
      for (var o = this[u], a = -1, c = o.length; ++a < c;)
        (r = o[a]) && (e.push(t = Wo(n.call(r, r.__data__, a, u))), t.parentNode = r);
    return _(e);
  };
  var xa = {
      svg: 'http://www.w3.org/2000/svg',
      xhtml: 'http://www.w3.org/1999/xhtml',
      xlink: 'http://www.w3.org/1999/xlink',
      xml: 'http://www.w3.org/XML/1998/namespace',
      xmlns: 'http://www.w3.org/2000/xmlns/'
    };
  Bo.ns = {
    prefix: xa,
    qualify: function (n) {
      var t = n.indexOf(':'), r = n;
      return t >= 0 && (r = n.substring(0, t), n = n.substring(t + 1)), xa.hasOwnProperty(r) ? {
        space: xa[r],
        local: n
      } : n;
    }
  }, ya.attr = function (n, t) {
    if (arguments.length < 2) {
      if ('string' == typeof n) {
        var r = this.node();
        return n = Bo.ns.qualify(n), n.local ? r.getAttributeNS(n.space, n.local) : r.getAttribute(n);
      }
      for (t in n)
        this.each(S(t, n[t]));
      return this;
    }
    return this.each(S(n, t));
  }, ya.classed = function (n, t) {
    if (arguments.length < 2) {
      if ('string' == typeof n) {
        var r = this.node(), e = (n = A(n)).length, u = -1;
        if (t = r.classList) {
          for (; ++u < e;)
            if (!t.contains(n[u]))
              return !1;
        } else
          for (t = r.getAttribute('class'); ++u < e;)
            if (!E(n[u]).test(t))
              return !1;
        return !0;
      }
      for (t in n)
        this.each(C(t, n[t]));
      return this;
    }
    return this.each(C(n, t));
  }, ya.style = function (n, t, r) {
    var e = arguments.length;
    if (3 > e) {
      if ('string' != typeof n) {
        2 > e && (t = '');
        for (r in n)
          this.each(z(r, n[r], t));
        return this;
      }
      if (2 > e)
        return Qo.getComputedStyle(this.node(), null).getPropertyValue(n);
      r = '';
    }
    return this.each(z(n, t, r));
  }, ya.property = function (n, t) {
    if (arguments.length < 2) {
      if ('string' == typeof n)
        return this.node()[n];
      for (t in n)
        this.each(L(t, n[t]));
      return this;
    }
    return this.each(L(n, t));
  }, ya.text = function (n) {
    return arguments.length ? this.each('function' == typeof n ? function () {
      var t = n.apply(this, arguments);
      this.textContent = null == t ? '' : t;
    } : null == n ? function () {
      this.textContent = '';
    } : function () {
      this.textContent = n;
    }) : this.node().textContent;
  }, ya.html = function (n) {
    return arguments.length ? this.each('function' == typeof n ? function () {
      var t = n.apply(this, arguments);
      this.innerHTML = null == t ? '' : t;
    } : null == n ? function () {
      this.innerHTML = '';
    } : function () {
      this.innerHTML = n;
    }) : this.node().innerHTML;
  }, ya.append = function (n) {
    return n = T(n), this.select(function () {
      return this.appendChild(n.apply(this, arguments));
    });
  }, ya.insert = function (n, t) {
    return n = T(n), t = b(t), this.select(function () {
      return this.insertBefore(n.apply(this, arguments), t.apply(this, arguments) || null);
    });
  }, ya.remove = function () {
    return this.each(function () {
      var n = this.parentNode;
      n && n.removeChild(this);
    });
  }, ya.data = function (n, t) {
    function r(n, r) {
      var e, u, i, a = n.length, f = r.length, h = Math.min(a, f), g = new Array(f), p = new Array(f), v = new Array(a);
      if (t) {
        var d, m = new o(), y = new o(), x = [];
        for (e = -1; ++e < a;)
          d = t.call(u = n[e], u.__data__, e), m.has(d) ? v[e] = u : m.set(d, u), x.push(d);
        for (e = -1; ++e < f;)
          d = t.call(r, i = r[e], e), (u = m.get(d)) ? (g[e] = u, u.__data__ = i) : y.has(d) || (p[e] = q(i)), y.set(d, i), m.remove(d);
        for (e = -1; ++e < a;)
          m.has(x[e]) && (v[e] = n[e]);
      } else {
        for (e = -1; ++e < h;)
          u = n[e], i = r[e], u ? (u.__data__ = i, g[e] = u) : p[e] = q(i);
        for (; f > e; ++e)
          p[e] = q(r[e]);
        for (; a > e; ++e)
          v[e] = n[e];
      }
      p.update = g, p.parentNode = g.parentNode = v.parentNode = n.parentNode, c.push(p), s.push(g), l.push(v);
    }
    var e, u, i = -1, a = this.length;
    if (!arguments.length) {
      for (n = new Array(a = (e = this[0]).length); ++i < a;)
        (u = e[i]) && (n[i] = u.__data__);
      return n;
    }
    var c = U([]), s = _([]), l = _([]);
    if ('function' == typeof n)
      for (; ++i < a;)
        r(e = this[i], n.call(e, e.parentNode.__data__, i));
    else
      for (; ++i < a;)
        r(e = this[i], n);
    return s.enter = function () {
      return c;
    }, s.exit = function () {
      return l;
    }, s;
  }, ya.datum = function (n) {
    return arguments.length ? this.property('__data__', n) : this.property('__data__');
  }, ya.filter = function (n) {
    var t, r, e, u = [];
    'function' != typeof n && (n = R(n));
    for (var i = 0, o = this.length; o > i; i++) {
      u.push(t = []), t.parentNode = (r = this[i]).parentNode;
      for (var a = 0, c = r.length; c > a; a++)
        (e = r[a]) && n.call(e, e.__data__, a, i) && t.push(e);
    }
    return _(u);
  }, ya.order = function () {
    for (var n = -1, t = this.length; ++n < t;)
      for (var r, e = this[n], u = e.length - 1, i = e[u]; --u >= 0;)
        (r = e[u]) && (i && i !== r.nextSibling && i.parentNode.insertBefore(r, i), i = r);
    return this;
  }, ya.sort = function (n) {
    n = D.apply(this, arguments);
    for (var t = -1, r = this.length; ++t < r;)
      this[t].sort(n);
    return this.order();
  }, ya.each = function (n) {
    return P(this, function (t, r, e) {
      n.call(t, t.__data__, r, e);
    });
  }, ya.call = function (n) {
    var t = Wo(arguments);
    return n.apply(t[0] = this, t), this;
  }, ya.empty = function () {
    return !this.node();
  }, ya.node = function () {
    for (var n = 0, t = this.length; t > n; n++)
      for (var r = this[n], e = 0, u = r.length; u > e; e++) {
        var i = r[e];
        if (i)
          return i;
      }
    return null;
  }, ya.size = function () {
    var n = 0;
    return this.each(function () {
      ++n;
    }), n;
  };
  var Ma = [];
  Bo.selection.enter = U, Bo.selection.enter.prototype = Ma, Ma.append = ya.append, Ma.empty = ya.empty, Ma.node = ya.node, Ma.call = ya.call, Ma.size = ya.size, Ma.select = function (n) {
    for (var t, r, e, u, i, o = [], a = -1, c = this.length; ++a < c;) {
      e = (u = this[a]).update, o.push(t = []), t.parentNode = u.parentNode;
      for (var s = -1, l = u.length; ++s < l;)
        (i = u[s]) ? (t.push(e[s] = r = n.call(u.parentNode, i.__data__, s, a)), r.__data__ = i.__data__) : t.push(null);
    }
    return _(o);
  }, Ma.insert = function (n, t) {
    return arguments.length < 2 && (t = j(this)), ya.insert.call(this, n, t);
  }, ya.transition = function () {
    for (var n, t, r = As || ++Ts, e = [], u = Cs || {
          time: Date.now(),
          ease: wu,
          delay: 0,
          duration: 250
        }, i = -1, o = this.length; ++i < o;) {
      e.push(n = []);
      for (var a = this[i], c = -1, s = a.length; ++c < s;)
        (t = a[c]) && Fo(t, c, r, u), n.push(t);
    }
    return Uo(e, r);
  }, ya.interrupt = function () {
    return this.each(H);
  }, Bo.select = function (n) {
    var t = ['string' == typeof n ? pa(n, Go) : n];
    return t.parentNode = Ko, _([t]);
  }, Bo.selectAll = function (n) {
    var t = Wo('string' == typeof n ? va(n, Go) : n);
    return t.parentNode = Ko, _([t]);
  };
  var _a = Bo.select(Ko);
  ya.on = function (n, t, r) {
    var e = arguments.length;
    if (3 > e) {
      if ('string' != typeof n) {
        2 > e && (t = !1);
        for (r in n)
          this.each(F(r, n[r], t));
        return this;
      }
      if (2 > e)
        return (e = this.node()['__on' + n]) && e._;
      r = !1;
    }
    return this.each(F(n, t, r));
  };
  var ba = Bo.map({
      mouseenter: 'mouseover',
      mouseleave: 'mouseout'
    });
  ba.forEach(function (n) {
    'on' + n in Go && ba.remove(n);
  });
  var wa = 'onselectstart' in Go ? null : p(Ko.style, 'userSelect'), Sa = 0;
  Bo.mouse = function (n) {
    return Z(n, x());
  }, Bo.touches = function (n, t) {
    return arguments.length < 2 && (t = x().touches), t ? Wo(t).map(function (t) {
      var r = Z(n, t);
      return r.identifier = t.identifier, r;
    }) : [];
  }, Bo.behavior.drag = function () {
    function n() {
      this.on('mousedown.drag', u).on('touchstart.drag', i);
    }
    function t(n, t, u, i, o) {
      return function () {
        function a() {
          var n, r, e = t(h, v);
          e && (n = e[0] - x[0], r = e[1] - x[1], p |= n | r, x = e, g({
            type: 'drag',
            x: e[0] + s[0],
            y: e[1] + s[1],
            dx: n,
            dy: r
          }));
        }
        function c() {
          t(h, v) && (m.on(i + d, null).on(o + d, null), y(p && Bo.event.target === f), g({ type: 'dragend' }));
        }
        var s, l = this, f = Bo.event.target, h = l.parentNode, g = r.of(l, arguments), p = 0, v = n(), d = '.drag' + (null == v ? '' : '-' + v), m = Bo.select(u()).on(i + d, a).on(o + d, c), y = Y(), x = t(h, v);
        e ? (s = e.apply(l, arguments), s = [
          s.x - x[0],
          s.y - x[1]
        ]) : s = [
          0,
          0
        ], g({ type: 'dragstart' });
      };
    }
    var r = M(n, 'drag', 'dragstart', 'dragend'), e = null, u = t(v, Bo.mouse, X, 'mousemove', 'mouseup'), i = t(V, Bo.touch, $, 'touchmove', 'touchend');
    return n.origin = function (t) {
      return arguments.length ? (e = t, n) : e;
    }, Bo.rebind(n, r, 'on');
  };
  var ka = Math.PI, Ea = 2 * ka, Aa = ka / 2, Ca = 0.000001, Na = Ca * Ca, za = ka / 180, La = 180 / ka, Ta = Math.SQRT2, qa = 2, Ra = 4;
  Bo.interpolateZoom = function (n, t) {
    function r(n) {
      var t = n * y;
      if (m) {
        var r = Q(v), o = i / (qa * h) * (r * nt(Ta * t + v) - K(v));
        return [
          e + o * s,
          u + o * l,
          i * r / Q(Ta * t + v)
        ];
      }
      return [
        e + n * s,
        u + n * l,
        i * Math.exp(Ta * t)
      ];
    }
    var e = n[0], u = n[1], i = n[2], o = t[0], a = t[1], c = t[2], s = o - e, l = a - u, f = s * s + l * l, h = Math.sqrt(f), g = (c * c - i * i + Ra * f) / (2 * i * qa * h), p = (c * c - i * i - Ra * f) / (2 * c * qa * h), v = Math.log(Math.sqrt(g * g + 1) - g), d = Math.log(Math.sqrt(p * p + 1) - p), m = d - v, y = (m || Math.log(c / i)) / Ta;
    return r.duration = 1000 * y, r;
  }, Bo.behavior.zoom = function () {
    function n(n) {
      n.on(A, s).on(Ua + '.zoom', f).on(C, h).on('dblclick.zoom', g).on(z, l);
    }
    function t(n) {
      return [
        (n[0] - S.x) / S.k,
        (n[1] - S.y) / S.k
      ];
    }
    function r(n) {
      return [
        n[0] * S.k + S.x,
        n[1] * S.k + S.y
      ];
    }
    function e(n) {
      S.k = Math.max(E[0], Math.min(E[1], n));
    }
    function u(n, t) {
      t = r(t), S.x += n[0] - t[0], S.y += n[1] - t[1];
    }
    function i() {
      _ && _.domain(x.range().map(function (n) {
        return (n - S.x) / S.k;
      }).map(x.invert)), w && w.domain(b.range().map(function (n) {
        return (n - S.y) / S.k;
      }).map(b.invert));
    }
    function o(n) {
      n({ type: 'zoomstart' });
    }
    function a(n) {
      i(), n({
        type: 'zoom',
        scale: S.k,
        translate: [
          S.x,
          S.y
        ]
      });
    }
    function c(n) {
      n({ type: 'zoomend' });
    }
    function s() {
      function n() {
        l = 1, u(Bo.mouse(e), g), a(s);
      }
      function r() {
        f.on(C, Qo === e ? h : null).on(N, null), p(l && Bo.event.target === i), c(s);
      }
      var e = this, i = Bo.event.target, s = L.of(e, arguments), l = 0, f = Bo.select(Qo).on(C, n).on(N, r), g = t(Bo.mouse(e)), p = Y();
      H.call(e), o(s);
    }
    function l() {
      function n() {
        var n = Bo.touches(g);
        return h = S.k, n.forEach(function (n) {
          n.identifier in v && (v[n.identifier] = t(n));
        }), n;
      }
      function r() {
        var t = Bo.event.target;
        Bo.select(t).on(M, i).on(_, f), b.push(t);
        for (var r = Bo.event.changedTouches, o = 0, c = r.length; c > o; ++o)
          v[r[o].identifier] = null;
        var s = n(), l = Date.now();
        if (1 === s.length) {
          if (500 > l - m) {
            var h = s[0], g = v[h.identifier];
            e(2 * S.k), u(h, g), y(), a(p);
          }
          m = l;
        } else if (s.length > 1) {
          var h = s[0], x = s[1], w = h[0] - x[0], k = h[1] - x[1];
          d = w * w + k * k;
        }
      }
      function i() {
        for (var n, t, r, i, o = Bo.touches(g), c = 0, s = o.length; s > c; ++c, i = null)
          if (r = o[c], i = v[r.identifier]) {
            if (t)
              break;
            n = r, t = i;
          }
        if (i) {
          var l = (l = r[0] - n[0]) * l + (l = r[1] - n[1]) * l, f = d && Math.sqrt(l / d);
          n = [
            (n[0] + r[0]) / 2,
            (n[1] + r[1]) / 2
          ], t = [
            (t[0] + i[0]) / 2,
            (t[1] + i[1]) / 2
          ], e(f * h);
        }
        m = null, u(n, t), a(p);
      }
      function f() {
        if (Bo.event.touches.length) {
          for (var t = Bo.event.changedTouches, r = 0, e = t.length; e > r; ++r)
            delete v[t[r].identifier];
          for (var u in v)
            return void n();
        }
        Bo.selectAll(b).on(x, null), w.on(A, s).on(z, l), k(), c(p);
      }
      var h, g = this, p = L.of(g, arguments), v = {}, d = 0, x = '.zoom-' + Bo.event.changedTouches[0].identifier, M = 'touchmove' + x, _ = 'touchend' + x, b = [], w = Bo.select(g).on(A, null).on(z, r), k = Y();
      H.call(g), r(), o(p);
    }
    function f() {
      var n = L.of(this, arguments);
      d ? clearTimeout(d) : (H.call(this), o(n)), d = setTimeout(function () {
        d = null, c(n);
      }, 50), y();
      var r = v || Bo.mouse(this);
      p || (p = t(r)), e(Math.pow(2, 0.002 * Da()) * S.k), u(r, p), a(n);
    }
    function h() {
      p = null;
    }
    function g() {
      var n = L.of(this, arguments), r = Bo.mouse(this), i = t(r), s = Math.log(S.k) / Math.LN2;
      o(n), e(Math.pow(2, Bo.event.shiftKey ? Math.ceil(s) - 1 : Math.floor(s) + 1)), u(r, i), a(n), c(n);
    }
    var p, v, d, m, x, _, b, w, S = {
        x: 0,
        y: 0,
        k: 1
      }, k = [
        960,
        500
      ], E = Pa, A = 'mousedown.zoom', C = 'mousemove.zoom', N = 'mouseup.zoom', z = 'touchstart.zoom', L = M(n, 'zoomstart', 'zoom', 'zoomend');
    return n.event = function (n) {
      n.each(function () {
        var n = L.of(this, arguments), t = S;
        As ? Bo.select(this).transition().each('start.zoom', function () {
          S = this.__chart__ || {
            x: 0,
            y: 0,
            k: 1
          }, o(n);
        }).tween('zoom:zoom', function () {
          var r = k[0], e = k[1], u = r / 2, i = e / 2, o = Bo.interpolateZoom([
              (u - S.x) / S.k,
              (i - S.y) / S.k,
              r / S.k
            ], [
              (u - t.x) / t.k,
              (i - t.y) / t.k,
              r / t.k
            ]);
          return function (t) {
            var e = o(t), c = r / e[2];
            this.__chart__ = S = {
              x: u - e[0] * c,
              y: i - e[1] * c,
              k: c
            }, a(n);
          };
        }).each('end.zoom', function () {
          c(n);
        }) : (this.__chart__ = S, o(n), a(n), c(n));
      });
    }, n.translate = function (t) {
      return arguments.length ? (S = {
        x: +t[0],
        y: +t[1],
        k: S.k
      }, i(), n) : [
        S.x,
        S.y
      ];
    }, n.scale = function (t) {
      return arguments.length ? (S = {
        x: S.x,
        y: S.y,
        k: +t
      }, i(), n) : S.k;
    }, n.scaleExtent = function (t) {
      return arguments.length ? (E = null == t ? Pa : [
        +t[0],
        +t[1]
      ], n) : E;
    }, n.center = function (t) {
      return arguments.length ? (v = t && [
        +t[0],
        +t[1]
      ], n) : v;
    }, n.size = function (t) {
      return arguments.length ? (k = t && [
        +t[0],
        +t[1]
      ], n) : k;
    }, n.x = function (t) {
      return arguments.length ? (_ = t, x = t.copy(), S = {
        x: 0,
        y: 0,
        k: 1
      }, n) : _;
    }, n.y = function (t) {
      return arguments.length ? (w = t, b = t.copy(), S = {
        x: 0,
        y: 0,
        k: 1
      }, n) : w;
    }, Bo.rebind(n, L, 'on');
  };
  var Da, Pa = [
      0,
      1 / 0
    ], Ua = 'onwheel' in Go ? (Da = function () {
      return -Bo.event.deltaY * (Bo.event.deltaMode ? 120 : 1);
    }, 'wheel') : 'onmousewheel' in Go ? (Da = function () {
      return Bo.event.wheelDelta;
    }, 'mousewheel') : (Da = function () {
      return -Bo.event.detail;
    }, 'MozMousePixelScroll');
  rt.prototype.toString = function () {
    return this.rgb() + '';
  }, Bo.hsl = function (n, t, r) {
    return 1 === arguments.length ? n instanceof ut ? et(n.h, n.s, n.l) : _t('' + n, bt, et) : et(+n, +t, +r);
  };
  var ja = ut.prototype = new rt();
  ja.brighter = function (n) {
    return n = Math.pow(0.7, arguments.length ? n : 1), et(this.h, this.s, this.l / n);
  }, ja.darker = function (n) {
    return n = Math.pow(0.7, arguments.length ? n : 1), et(this.h, this.s, n * this.l);
  }, ja.rgb = function () {
    return it(this.h, this.s, this.l);
  }, Bo.hcl = function (n, t, r) {
    return 1 === arguments.length ? n instanceof at ? ot(n.h, n.c, n.l) : n instanceof lt ? ht(n.l, n.a, n.b) : ht((n = wt((n = Bo.rgb(n)).r, n.g, n.b)).l, n.a, n.b) : ot(+n, +t, +r);
  };
  var Ha = at.prototype = new rt();
  Ha.brighter = function (n) {
    return ot(this.h, this.c, Math.min(100, this.l + Fa * (arguments.length ? n : 1)));
  }, Ha.darker = function (n) {
    return ot(this.h, this.c, Math.max(0, this.l - Fa * (arguments.length ? n : 1)));
  }, Ha.rgb = function () {
    return ct(this.h, this.c, this.l).rgb();
  }, Bo.lab = function (n, t, r) {
    return 1 === arguments.length ? n instanceof lt ? st(n.l, n.a, n.b) : n instanceof at ? ct(n.l, n.c, n.h) : wt((n = Bo.rgb(n)).r, n.g, n.b) : st(+n, +t, +r);
  };
  var Fa = 18, Oa = 0.95047, Ia = 1, Ya = 1.08883, Za = lt.prototype = new rt();
  Za.brighter = function (n) {
    return st(Math.min(100, this.l + Fa * (arguments.length ? n : 1)), this.a, this.b);
  }, Za.darker = function (n) {
    return st(Math.max(0, this.l - Fa * (arguments.length ? n : 1)), this.a, this.b);
  }, Za.rgb = function () {
    return ft(this.l, this.a, this.b);
  }, Bo.rgb = function (n, t, r) {
    return 1 === arguments.length ? n instanceof xt ? yt(n.r, n.g, n.b) : _t('' + n, yt, it) : yt(~~n, ~~t, ~~r);
  };
  var Va = xt.prototype = new rt();
  Va.brighter = function (n) {
    n = Math.pow(0.7, arguments.length ? n : 1);
    var t = this.r, r = this.g, e = this.b, u = 30;
    return t || r || e ? (t && u > t && (t = u), r && u > r && (r = u), e && u > e && (e = u), yt(Math.min(255, ~~(t / n)), Math.min(255, ~~(r / n)), Math.min(255, ~~(e / n)))) : yt(u, u, u);
  }, Va.darker = function (n) {
    return n = Math.pow(0.7, arguments.length ? n : 1), yt(~~(n * this.r), ~~(n * this.g), ~~(n * this.b));
  }, Va.hsl = function () {
    return bt(this.r, this.g, this.b);
  }, Va.toString = function () {
    return '#' + Mt(this.r) + Mt(this.g) + Mt(this.b);
  };
  var $a = Bo.map({
      aliceblue: 15792383,
      antiquewhite: 16444375,
      aqua: 65535,
      aquamarine: 8388564,
      azure: 15794175,
      beige: 16119260,
      bisque: 16770244,
      black: 0,
      blanchedalmond: 16772045,
      blue: 255,
      blueviolet: 9055202,
      brown: 10824234,
      burlywood: 14596231,
      cadetblue: 6266528,
      chartreuse: 8388352,
      chocolate: 13789470,
      coral: 16744272,
      cornflowerblue: 6591981,
      cornsilk: 16775388,
      crimson: 14423100,
      cyan: 65535,
      darkblue: 139,
      darkcyan: 35723,
      darkgoldenrod: 12092939,
      darkgray: 11119017,
      darkgreen: 25600,
      darkgrey: 11119017,
      darkkhaki: 12433259,
      darkmagenta: 9109643,
      darkolivegreen: 5597999,
      darkorange: 16747520,
      darkorchid: 10040012,
      darkred: 9109504,
      darksalmon: 15308410,
      darkseagreen: 9419919,
      darkslateblue: 4734347,
      darkslategray: 3100495,
      darkslategrey: 3100495,
      darkturquoise: 52945,
      darkviolet: 9699539,
      deeppink: 16716947,
      deepskyblue: 49151,
      dimgray: 6908265,
      dimgrey: 6908265,
      dodgerblue: 2003199,
      firebrick: 11674146,
      floralwhite: 16775920,
      forestgreen: 2263842,
      fuchsia: 16711935,
      gainsboro: 14474460,
      ghostwhite: 16316671,
      gold: 16766720,
      goldenrod: 14329120,
      gray: 8421504,
      green: 32768,
      greenyellow: 11403055,
      grey: 8421504,
      honeydew: 15794160,
      hotpink: 16738740,
      indianred: 13458524,
      indigo: 4915330,
      ivory: 16777200,
      khaki: 15787660,
      lavender: 15132410,
      lavenderblush: 16773365,
      lawngreen: 8190976,
      lemonchiffon: 16775885,
      lightblue: 11393254,
      lightcoral: 15761536,
      lightcyan: 14745599,
      lightgoldenrodyellow: 16448210,
      lightgray: 13882323,
      lightgreen: 9498256,
      lightgrey: 13882323,
      lightpink: 16758465,
      lightsalmon: 16752762,
      lightseagreen: 2142890,
      lightskyblue: 8900346,
      lightslategray: 7833753,
      lightslategrey: 7833753,
      lightsteelblue: 11584734,
      lightyellow: 16777184,
      lime: 65280,
      limegreen: 3329330,
      linen: 16445670,
      magenta: 16711935,
      maroon: 8388608,
      mediumaquamarine: 6737322,
      mediumblue: 205,
      mediumorchid: 12211667,
      mediumpurple: 9662683,
      mediumseagreen: 3978097,
      mediumslateblue: 8087790,
      mediumspringgreen: 64154,
      mediumturquoise: 4772300,
      mediumvioletred: 13047173,
      midnightblue: 1644912,
      mintcream: 16121850,
      mistyrose: 16770273,
      moccasin: 16770229,
      navajowhite: 16768685,
      navy: 128,
      oldlace: 16643558,
      olive: 8421376,
      olivedrab: 7048739,
      orange: 16753920,
      orangered: 16729344,
      orchid: 14315734,
      palegoldenrod: 15657130,
      palegreen: 10025880,
      paleturquoise: 11529966,
      palevioletred: 14381203,
      papayawhip: 16773077,
      peachpuff: 16767673,
      peru: 13468991,
      pink: 16761035,
      plum: 14524637,
      powderblue: 11591910,
      purple: 8388736,
      red: 16711680,
      rosybrown: 12357519,
      royalblue: 4286945,
      saddlebrown: 9127187,
      salmon: 16416882,
      sandybrown: 16032864,
      seagreen: 3050327,
      seashell: 16774638,
      sienna: 10506797,
      silver: 12632256,
      skyblue: 8900331,
      slateblue: 6970061,
      slategray: 7372944,
      slategrey: 7372944,
      snow: 16775930,
      springgreen: 65407,
      steelblue: 4620980,
      tan: 13808780,
      teal: 32896,
      thistle: 14204888,
      tomato: 16737095,
      turquoise: 4251856,
      violet: 15631086,
      wheat: 16113331,
      white: 16777215,
      whitesmoke: 16119285,
      yellow: 16776960,
      yellowgreen: 10145074
    });
  $a.forEach(function (n, t) {
    $a.set(n, dt(t));
  }), Bo.functor = Et, Bo.xhr = Ct(At), Bo.dsv = function (n, t) {
    function r(n, r, i) {
      arguments.length < 3 && (i = r, r = null);
      var o = Nt(n, t, null == r ? e : u(r), i);
      return o.row = function (n) {
        return arguments.length ? o.response(null == (r = n) ? e : u(n)) : r;
      }, o;
    }
    function e(n) {
      return r.parse(n.responseText);
    }
    function u(n) {
      return function (t) {
        return r.parse(t.responseText, n);
      };
    }
    function i(t) {
      return t.map(o).join(n);
    }
    function o(n) {
      return a.test(n) ? '"' + n.replace(/\"/g, '""') + '"' : n;
    }
    var a = new RegExp('["' + n + '\n]'), c = n.charCodeAt(0);
    return r.parse = function (n, t) {
      var e;
      return r.parseRows(n, function (n, r) {
        if (e)
          return e(n, r - 1);
        var u = new Function('d', 'return {' + n.map(function (n, t) {
            return JSON.stringify(n) + ': d[' + t + ']';
          }).join(',') + '}');
        e = t ? function (n, r) {
          return t(u(n), r);
        } : u;
      });
    }, r.parseRows = function (n, t) {
      function r() {
        if (l >= s)
          return o;
        if (u)
          return u = !1, i;
        var t = l;
        if (34 === n.charCodeAt(t)) {
          for (var r = t; r++ < s;)
            if (34 === n.charCodeAt(r)) {
              if (34 !== n.charCodeAt(r + 1))
                break;
              ++r;
            }
          l = r + 2;
          var e = n.charCodeAt(r + 1);
          return 13 === e ? (u = !0, 10 === n.charCodeAt(r + 2) && ++l) : 10 === e && (u = !0), n.substring(t + 1, r).replace(/""/g, '"');
        }
        for (; s > l;) {
          var e = n.charCodeAt(l++), a = 1;
          if (10 === e)
            u = !0;
          else if (13 === e)
            u = !0, 10 === n.charCodeAt(l) && (++l, ++a);
          else if (e !== c)
            continue;
          return n.substring(t, l - a);
        }
        return n.substring(t);
      }
      for (var e, u, i = {}, o = {}, a = [], s = n.length, l = 0, f = 0; (e = r()) !== o;) {
        for (var h = []; e !== i && e !== o;)
          h.push(e), e = r();
        (!t || (h = t(h, f++))) && a.push(h);
      }
      return a;
    }, r.format = function (t) {
      if (Array.isArray(t[0]))
        return r.formatRows(t);
      var e = new h(), u = [];
      return t.forEach(function (n) {
        for (var t in n)
          e.has(t) || u.push(e.add(t));
      }), [u.map(o).join(n)].concat(t.map(function (t) {
        return u.map(function (n) {
          return o(t[n]);
        }).join(n);
      })).join('\n');
    }, r.formatRows = function (n) {
      return n.map(i).join('\n');
    }, r;
  }, Bo.csv = Bo.dsv(',', 'text/csv'), Bo.tsv = Bo.dsv('\t', 'text/tab-separated-values'), Bo.touch = function (n, t, r) {
    if (arguments.length < 3 && (r = t, t = x().changedTouches), t)
      for (var e, u = 0, i = t.length; i > u; ++u)
        if ((e = t[u]).identifier === r)
          return Z(n, e);
  };
  var Xa, Ba, Ja, Wa, Ga, Ka = Qo[p(Qo, 'requestAnimationFrame')] || function (n) {
      setTimeout(n, 17);
    };
  Bo.timer = function (n, t, r) {
    var e = arguments.length;
    2 > e && (t = 0), 3 > e && (r = Date.now());
    var u = r + t, i = {
        c: n,
        t: u,
        f: !1,
        n: null
      };
    Ba ? Ba.n = i : Xa = i, Ba = i, Ja || (Wa = clearTimeout(Wa), Ja = 1, Ka(Lt));
  }, Bo.timer.flush = function () {
    Tt(), qt();
  }, Bo.round = function (n, t) {
    return t ? Math.round(n * (t = Math.pow(10, t))) / t : Math.round(n);
  };
  var Qa = [
      'y',
      'z',
      'a',
      'f',
      'p',
      'n',
      '\xb5',
      'm',
      '',
      'k',
      'M',
      'G',
      'T',
      'P',
      'E',
      'Z',
      'Y'
    ].map(Dt);
  Bo.formatPrefix = function (n, t) {
    var r = 0;
    return n && (0 > n && (n *= -1), t && (n = Bo.round(n, Rt(n, t))), r = 1 + Math.floor(1e-12 + Math.log(n) / Math.LN10), r = Math.max(-24, Math.min(24, 3 * Math.floor((r - 1) / 3)))), Qa[8 + r / 3];
  };
  var nc = /(?:([^{])?([<>=^]))?([+\- ])?([$#])?(0)?(\d+)?(,)?(\.-?\d+)?([a-z%])?/i, tc = Bo.map({
      b: function (n) {
        return n.toString(2);
      },
      c: function (n) {
        return String.fromCharCode(n);
      },
      o: function (n) {
        return n.toString(8);
      },
      x: function (n) {
        return n.toString(16);
      },
      X: function (n) {
        return n.toString(16).toUpperCase();
      },
      g: function (n, t) {
        return n.toPrecision(t);
      },
      e: function (n, t) {
        return n.toExponential(t);
      },
      f: function (n, t) {
        return n.toFixed(t);
      },
      r: function (n, t) {
        return (n = Bo.round(n, Rt(n, t))).toFixed(Math.max(0, Math.min(20, Rt(n * (1 + 1e-15), t))));
      }
    }), rc = Bo.time = {}, ec = Date;
  jt.prototype = {
    getDate: function () {
      return this._.getUTCDate();
    },
    getDay: function () {
      return this._.getUTCDay();
    },
    getFullYear: function () {
      return this._.getUTCFullYear();
    },
    getHours: function () {
      return this._.getUTCHours();
    },
    getMilliseconds: function () {
      return this._.getUTCMilliseconds();
    },
    getMinutes: function () {
      return this._.getUTCMinutes();
    },
    getMonth: function () {
      return this._.getUTCMonth();
    },
    getSeconds: function () {
      return this._.getUTCSeconds();
    },
    getTime: function () {
      return this._.getTime();
    },
    getTimezoneOffset: function () {
      return 0;
    },
    valueOf: function () {
      return this._.valueOf();
    },
    setDate: function () {
      uc.setUTCDate.apply(this._, arguments);
    },
    setDay: function () {
      uc.setUTCDay.apply(this._, arguments);
    },
    setFullYear: function () {
      uc.setUTCFullYear.apply(this._, arguments);
    },
    setHours: function () {
      uc.setUTCHours.apply(this._, arguments);
    },
    setMilliseconds: function () {
      uc.setUTCMilliseconds.apply(this._, arguments);
    },
    setMinutes: function () {
      uc.setUTCMinutes.apply(this._, arguments);
    },
    setMonth: function () {
      uc.setUTCMonth.apply(this._, arguments);
    },
    setSeconds: function () {
      uc.setUTCSeconds.apply(this._, arguments);
    },
    setTime: function () {
      uc.setTime.apply(this._, arguments);
    }
  };
  var uc = Date.prototype;
  rc.year = Ht(function (n) {
    return n = rc.day(n), n.setMonth(0, 1), n;
  }, function (n, t) {
    n.setFullYear(n.getFullYear() + t);
  }, function (n) {
    return n.getFullYear();
  }), rc.years = rc.year.range, rc.years.utc = rc.year.utc.range, rc.day = Ht(function (n) {
    var t = new ec(2000, 0);
    return t.setFullYear(n.getFullYear(), n.getMonth(), n.getDate()), t;
  }, function (n, t) {
    n.setDate(n.getDate() + t);
  }, function (n) {
    return n.getDate() - 1;
  }), rc.days = rc.day.range, rc.days.utc = rc.day.utc.range, rc.dayOfYear = function (n) {
    var t = rc.year(n);
    return Math.floor((n - t - 60000 * (n.getTimezoneOffset() - t.getTimezoneOffset())) / 86400000);
  }, [
    'sunday',
    'monday',
    'tuesday',
    'wednesday',
    'thursday',
    'friday',
    'saturday'
  ].forEach(function (n, t) {
    t = 7 - t;
    var r = rc[n] = Ht(function (n) {
        return (n = rc.day(n)).setDate(n.getDate() - (n.getDay() + t) % 7), n;
      }, function (n, t) {
        n.setDate(n.getDate() + 7 * Math.floor(t));
      }, function (n) {
        var r = rc.year(n).getDay();
        return Math.floor((rc.dayOfYear(n) + (r + t) % 7) / 7) - (r !== t);
      });
    rc[n + 's'] = r.range, rc[n + 's'].utc = r.utc.range, rc[n + 'OfYear'] = function (n) {
      var r = rc.year(n).getDay();
      return Math.floor((rc.dayOfYear(n) + (r + t) % 7) / 7);
    };
  }), rc.week = rc.sunday, rc.weeks = rc.sunday.range, rc.weeks.utc = rc.sunday.utc.range, rc.weekOfYear = rc.sundayOfYear;
  var ic = {
      '-': '',
      _: ' ',
      0: '0'
    }, oc = /^\s*\d+/, ac = /^%/;
  Bo.locale = function (n) {
    return {
      numberFormat: Pt(n),
      timeFormat: Ot(n)
    };
  };
  var cc = Bo.locale({
      decimal: '.',
      thousands: ',',
      grouping: [3],
      currency: [
        '$',
        ''
      ],
      dateTime: '%a %b %e %X %Y',
      date: '%m/%d/%Y',
      time: '%H:%M:%S',
      periods: [
        'AM',
        'PM'
      ],
      days: [
        'Sunday',
        'Monday',
        'Tuesday',
        'Wednesday',
        'Thursday',
        'Friday',
        'Saturday'
      ],
      shortDays: [
        'Sun',
        'Mon',
        'Tue',
        'Wed',
        'Thu',
        'Fri',
        'Sat'
      ],
      months: [
        'January',
        'February',
        'March',
        'April',
        'May',
        'June',
        'July',
        'August',
        'September',
        'October',
        'November',
        'December'
      ],
      shortMonths: [
        'Jan',
        'Feb',
        'Mar',
        'Apr',
        'May',
        'Jun',
        'Jul',
        'Aug',
        'Sep',
        'Oct',
        'Nov',
        'Dec'
      ]
    });
  Bo.format = cc.numberFormat, Bo.geo = {}, cr.prototype = {
    s: 0,
    t: 0,
    add: function (n) {
      sr(n, this.t, sc), sr(sc.s, this.s, this), this.s ? this.t += sc.t : this.s = sc.t;
    },
    reset: function () {
      this.s = this.t = 0;
    },
    valueOf: function () {
      return this.s;
    }
  };
  var sc = new cr();
  Bo.geo.stream = function (n, t) {
    n && lc.hasOwnProperty(n.type) ? lc[n.type](n, t) : lr(n, t);
  };
  var lc = {
      Feature: function (n, t) {
        lr(n.geometry, t);
      },
      FeatureCollection: function (n, t) {
        for (var r = n.features, e = -1, u = r.length; ++e < u;)
          lr(r[e].geometry, t);
      }
    }, fc = {
      Sphere: function (n, t) {
        t.sphere();
      },
      Point: function (n, t) {
        n = n.coordinates, t.point(n[0], n[1], n[2]);
      },
      MultiPoint: function (n, t) {
        for (var r = n.coordinates, e = -1, u = r.length; ++e < u;)
          n = r[e], t.point(n[0], n[1], n[2]);
      },
      LineString: function (n, t) {
        fr(n.coordinates, t, 0);
      },
      MultiLineString: function (n, t) {
        for (var r = n.coordinates, e = -1, u = r.length; ++e < u;)
          fr(r[e], t, 0);
      },
      Polygon: function (n, t) {
        hr(n.coordinates, t);
      },
      MultiPolygon: function (n, t) {
        for (var r = n.coordinates, e = -1, u = r.length; ++e < u;)
          hr(r[e], t);
      },
      GeometryCollection: function (n, t) {
        for (var r = n.geometries, e = -1, u = r.length; ++e < u;)
          lr(r[e], t);
      }
    };
  Bo.geo.area = function (n) {
    return hc = 0, Bo.geo.stream(n, pc), hc;
  };
  var hc, gc = new cr(), pc = {
      sphere: function () {
        hc += 4 * ka;
      },
      point: v,
      lineStart: v,
      lineEnd: v,
      polygonStart: function () {
        gc.reset(), pc.lineStart = gr;
      },
      polygonEnd: function () {
        var n = 2 * gc;
        hc += 0 > n ? 4 * ka + n : n, pc.lineStart = pc.lineEnd = pc.point = v;
      }
    };
  Bo.geo.bounds = function () {
    function n(n, t) {
      x.push(M = [
        l = n,
        h = n
      ]), f > t && (f = t), t > g && (g = t);
    }
    function t(t, r) {
      var e = pr([
          t * za,
          r * za
        ]);
      if (m) {
        var u = dr(m, e), i = [
            u[1],
            -u[0],
            0
          ], o = dr(i, u);
        xr(o), o = Mr(o);
        var c = t - p, s = c > 0 ? 1 : -1, v = o[0] * La * s, d = ca(c) > 180;
        if (d ^ (v > s * p && s * t > v)) {
          var y = o[1] * La;
          y > g && (g = y);
        } else if (v = (v + 360) % 360 - 180, d ^ (v > s * p && s * t > v)) {
          var y = -o[1] * La;
          f > y && (f = y);
        } else
          f > r && (f = r), r > g && (g = r);
        d ? p > t ? a(l, t) > a(l, h) && (h = t) : a(t, h) > a(l, h) && (l = t) : h >= l ? (l > t && (l = t), t > h && (h = t)) : t > p ? a(l, t) > a(l, h) && (h = t) : a(t, h) > a(l, h) && (l = t);
      } else
        n(t, r);
      m = e, p = t;
    }
    function r() {
      _.point = t;
    }
    function e() {
      M[0] = l, M[1] = h, _.point = n, m = null;
    }
    function u(n, r) {
      if (m) {
        var e = n - p;
        y += ca(e) > 180 ? e + (e > 0 ? 360 : -360) : e;
      } else
        v = n, d = r;
      pc.point(n, r), t(n, r);
    }
    function i() {
      pc.lineStart();
    }
    function o() {
      u(v, d), pc.lineEnd(), ca(y) > Ca && (l = -(h = 180)), M[0] = l, M[1] = h, m = null;
    }
    function a(n, t) {
      return (t -= n) < 0 ? t + 360 : t;
    }
    function c(n, t) {
      return n[0] - t[0];
    }
    function s(n, t) {
      return t[0] <= t[1] ? t[0] <= n && n <= t[1] : n < t[0] || t[1] < n;
    }
    var l, f, h, g, p, v, d, m, y, x, M, _ = {
        point: n,
        lineStart: r,
        lineEnd: e,
        polygonStart: function () {
          _.point = u, _.lineStart = i, _.lineEnd = o, y = 0, pc.polygonStart();
        },
        polygonEnd: function () {
          pc.polygonEnd(), _.point = n, _.lineStart = r, _.lineEnd = e, 0 > gc ? (l = -(h = 180), f = -(g = 90)) : y > Ca ? g = 90 : -Ca > y && (f = -90), M[0] = l, M[1] = h;
        }
      };
    return function (n) {
      g = h = -(l = f = 1 / 0), x = [], Bo.geo.stream(n, _);
      var t = x.length;
      if (t) {
        x.sort(c);
        for (var r, e = 1, u = x[0], i = [u]; t > e; ++e)
          r = x[e], s(r[0], u) || s(r[1], u) ? (a(u[0], r[1]) > a(u[0], u[1]) && (u[1] = r[1]), a(r[0], u[1]) > a(u[0], u[1]) && (u[0] = r[0])) : i.push(u = r);
        for (var o, r, p = -1 / 0, t = i.length - 1, e = 0, u = i[t]; t >= e; u = r, ++e)
          r = i[e], (o = a(u[1], r[0])) > p && (p = o, l = r[0], h = u[1]);
      }
      return x = M = null, 1 / 0 === l || 1 / 0 === f ? [
        [
          0 / 0,
          0 / 0
        ],
        [
          0 / 0,
          0 / 0
        ]
      ] : [
        [
          l,
          f
        ],
        [
          h,
          g
        ]
      ];
    };
  }(), Bo.geo.centroid = function (n) {
    vc = dc = mc = yc = xc = Mc = _c = bc = wc = Sc = kc = 0, Bo.geo.stream(n, Ec);
    var t = wc, r = Sc, e = kc, u = t * t + r * r + e * e;
    return Na > u && (t = Mc, r = _c, e = bc, Ca > dc && (t = mc, r = yc, e = xc), u = t * t + r * r + e * e, Na > u) ? [
      0 / 0,
      0 / 0
    ] : [
      Math.atan2(r, t) * La,
      G(e / Math.sqrt(u)) * La
    ];
  };
  var vc, dc, mc, yc, xc, Mc, _c, bc, wc, Sc, kc, Ec = {
      sphere: v,
      point: br,
      lineStart: Sr,
      lineEnd: kr,
      polygonStart: function () {
        Ec.lineStart = Er;
      },
      polygonEnd: function () {
        Ec.lineStart = Sr;
      }
    }, Ac = Lr(Ar, Pr, jr, [
      -ka,
      -ka / 2
    ]), Cc = 1000000000;
  Bo.geo.clipExtent = function () {
    var n, t, r, e, u, i, o = {
        stream: function (n) {
          return u && (u.valid = !1), u = i(n), u.valid = !0, u;
        },
        extent: function (a) {
          return arguments.length ? (i = Or(n = +a[0][0], t = +a[0][1], r = +a[1][0], e = +a[1][1]), u && (u.valid = !1, u = null), o) : [
            [
              n,
              t
            ],
            [
              r,
              e
            ]
          ];
        }
      };
    return o.extent([
      [
        0,
        0
      ],
      [
        960,
        500
      ]
    ]);
  }, (Bo.geo.conicEqualArea = function () {
    return Yr(Zr);
  }).raw = Zr, Bo.geo.albers = function () {
    return Bo.geo.conicEqualArea().rotate([
      96,
      0
    ]).center([
      -0.6,
      38.7
    ]).parallels([
      29.5,
      45.5
    ]).scale(1070);
  }, Bo.geo.albersUsa = function () {
    function n(n) {
      var i = n[0], o = n[1];
      return t = null, r(i, o), t || (e(i, o), t) || u(i, o), t;
    }
    var t, r, e, u, i = Bo.geo.albers(), o = Bo.geo.conicEqualArea().rotate([
        154,
        0
      ]).center([
        -2,
        58.5
      ]).parallels([
        55,
        65
      ]), a = Bo.geo.conicEqualArea().rotate([
        157,
        0
      ]).center([
        -3,
        19.9
      ]).parallels([
        8,
        18
      ]), c = {
        point: function (n, r) {
          t = [
            n,
            r
          ];
        }
      };
    return n.invert = function (n) {
      var t = i.scale(), r = i.translate(), e = (n[0] - r[0]) / t, u = (n[1] - r[1]) / t;
      return (u >= 0.12 && 0.234 > u && e >= -0.425 && -0.214 > e ? o : u >= 0.166 && 0.234 > u && e >= -0.214 && -0.115 > e ? a : i).invert(n);
    }, n.stream = function (n) {
      var t = i.stream(n), r = o.stream(n), e = a.stream(n);
      return {
        point: function (n, u) {
          t.point(n, u), r.point(n, u), e.point(n, u);
        },
        sphere: function () {
          t.sphere(), r.sphere(), e.sphere();
        },
        lineStart: function () {
          t.lineStart(), r.lineStart(), e.lineStart();
        },
        lineEnd: function () {
          t.lineEnd(), r.lineEnd(), e.lineEnd();
        },
        polygonStart: function () {
          t.polygonStart(), r.polygonStart(), e.polygonStart();
        },
        polygonEnd: function () {
          t.polygonEnd(), r.polygonEnd(), e.polygonEnd();
        }
      };
    }, n.precision = function (t) {
      return arguments.length ? (i.precision(t), o.precision(t), a.precision(t), n) : i.precision();
    }, n.scale = function (t) {
      return arguments.length ? (i.scale(t), o.scale(0.35 * t), a.scale(t), n.translate(i.translate())) : i.scale();
    }, n.translate = function (t) {
      if (!arguments.length)
        return i.translate();
      var s = i.scale(), l = +t[0], f = +t[1];
      return r = i.translate(t).clipExtent([
        [
          l - 0.455 * s,
          f - 0.238 * s
        ],
        [
          l + 0.455 * s,
          f + 0.238 * s
        ]
      ]).stream(c).point, e = o.translate([
        l - 0.307 * s,
        f + 0.201 * s
      ]).clipExtent([
        [
          l - 0.425 * s + Ca,
          f + 0.12 * s + Ca
        ],
        [
          l - 0.214 * s - Ca,
          f + 0.234 * s - Ca
        ]
      ]).stream(c).point, u = a.translate([
        l - 0.205 * s,
        f + 0.212 * s
      ]).clipExtent([
        [
          l - 0.214 * s + Ca,
          f + 0.166 * s + Ca
        ],
        [
          l - 0.115 * s - Ca,
          f + 0.234 * s - Ca
        ]
      ]).stream(c).point, n;
    }, n.scale(1070);
  };
  var Nc, zc, Lc, Tc, qc, Rc, Dc = {
      point: v,
      lineStart: v,
      lineEnd: v,
      polygonStart: function () {
        zc = 0, Dc.lineStart = Vr;
      },
      polygonEnd: function () {
        Dc.lineStart = Dc.lineEnd = Dc.point = v, Nc += ca(zc / 2);
      }
    }, Pc = {
      point: $r,
      lineStart: v,
      lineEnd: v,
      polygonStart: v,
      polygonEnd: v
    }, Uc = {
      point: Jr,
      lineStart: Wr,
      lineEnd: Gr,
      polygonStart: function () {
        Uc.lineStart = Kr;
      },
      polygonEnd: function () {
        Uc.point = Jr, Uc.lineStart = Wr, Uc.lineEnd = Gr;
      }
    };
  Bo.geo.path = function () {
    function n(n) {
      return n && ('function' == typeof a && i.pointRadius(+a.apply(this, arguments)), o && o.valid || (o = u(i)), Bo.geo.stream(n, o)), i.result();
    }
    function t() {
      return o = null, n;
    }
    var r, e, u, i, o, a = 4.5;
    return n.area = function (n) {
      return Nc = 0, Bo.geo.stream(n, u(Dc)), Nc;
    }, n.centroid = function (n) {
      return mc = yc = xc = Mc = _c = bc = wc = Sc = kc = 0, Bo.geo.stream(n, u(Uc)), kc ? [
        wc / kc,
        Sc / kc
      ] : bc ? [
        Mc / bc,
        _c / bc
      ] : xc ? [
        mc / xc,
        yc / xc
      ] : [
        0 / 0,
        0 / 0
      ];
    }, n.bounds = function (n) {
      return qc = Rc = -(Lc = Tc = 1 / 0), Bo.geo.stream(n, u(Pc)), [
        [
          Lc,
          Tc
        ],
        [
          qc,
          Rc
        ]
      ];
    }, n.projection = function (n) {
      return arguments.length ? (u = (r = n) ? n.stream || te(n) : At, t()) : r;
    }, n.context = function (n) {
      return arguments.length ? (i = null == (e = n) ? new Xr() : new Qr(n), 'function' != typeof a && i.pointRadius(a), t()) : e;
    }, n.pointRadius = function (t) {
      return arguments.length ? (a = 'function' == typeof t ? t : (i.pointRadius(+t), +t), n) : a;
    }, n.projection(Bo.geo.albersUsa()).context(null);
  }, Bo.geo.transform = function (n) {
    return {
      stream: function (t) {
        var r = new re(t);
        for (var e in n)
          r[e] = n[e];
        return r;
      }
    };
  }, re.prototype = {
    point: function (n, t) {
      this.stream.point(n, t);
    },
    sphere: function () {
      this.stream.sphere();
    },
    lineStart: function () {
      this.stream.lineStart();
    },
    lineEnd: function () {
      this.stream.lineEnd();
    },
    polygonStart: function () {
      this.stream.polygonStart();
    },
    polygonEnd: function () {
      this.stream.polygonEnd();
    }
  }, Bo.geo.projection = ue, Bo.geo.projectionMutator = ie, (Bo.geo.equirectangular = function () {
    return ue(ae);
  }).raw = ae.invert = ae, Bo.geo.rotation = function (n) {
    function t(t) {
      return t = n(t[0] * za, t[1] * za), t[0] *= La, t[1] *= La, t;
    }
    return n = se(n[0] % 360 * za, n[1] * za, n.length > 2 ? n[2] * za : 0), t.invert = function (t) {
      return t = n.invert(t[0] * za, t[1] * za), t[0] *= La, t[1] *= La, t;
    }, t;
  }, ce.invert = ae, Bo.geo.circle = function () {
    function n() {
      var n = 'function' == typeof e ? e.apply(this, arguments) : e, t = se(-n[0] * za, -n[1] * za, 0).invert, u = [];
      return r(null, null, 1, {
        point: function (n, r) {
          u.push(n = t(n, r)), n[0] *= La, n[1] *= La;
        }
      }), {
        type: 'Polygon',
        coordinates: [u]
      };
    }
    var t, r, e = [
        0,
        0
      ], u = 6;
    return n.origin = function (t) {
      return arguments.length ? (e = t, n) : e;
    }, n.angle = function (e) {
      return arguments.length ? (r = ge((t = +e) * za, u * za), n) : t;
    }, n.precision = function (e) {
      return arguments.length ? (r = ge(t * za, (u = +e) * za), n) : u;
    }, n.angle(90);
  }, Bo.geo.distance = function (n, t) {
    var r, e = (t[0] - n[0]) * za, u = n[1] * za, i = t[1] * za, o = Math.sin(e), a = Math.cos(e), c = Math.sin(u), s = Math.cos(u), l = Math.sin(i), f = Math.cos(i);
    return Math.atan2(Math.sqrt((r = f * o) * r + (r = s * l - c * f * a) * r), c * l + s * f * a);
  }, Bo.geo.graticule = function () {
    function n() {
      return {
        type: 'MultiLineString',
        coordinates: t()
      };
    }
    function t() {
      return Bo.range(Math.ceil(i / d) * d, u, d).map(h).concat(Bo.range(Math.ceil(s / m) * m, c, m).map(g)).concat(Bo.range(Math.ceil(e / p) * p, r, p).filter(function (n) {
        return ca(n % d) > Ca;
      }).map(l)).concat(Bo.range(Math.ceil(a / v) * v, o, v).filter(function (n) {
        return ca(n % m) > Ca;
      }).map(f));
    }
    var r, e, u, i, o, a, c, s, l, f, h, g, p = 10, v = p, d = 90, m = 360, y = 2.5;
    return n.lines = function () {
      return t().map(function (n) {
        return {
          type: 'LineString',
          coordinates: n
        };
      });
    }, n.outline = function () {
      return {
        type: 'Polygon',
        coordinates: [h(i).concat(g(c).slice(1), h(u).reverse().slice(1), g(s).reverse().slice(1))]
      };
    }, n.extent = function (t) {
      return arguments.length ? n.majorExtent(t).minorExtent(t) : n.minorExtent();
    }, n.majorExtent = function (t) {
      return arguments.length ? (i = +t[0][0], u = +t[1][0], s = +t[0][1], c = +t[1][1], i > u && (t = i, i = u, u = t), s > c && (t = s, s = c, c = t), n.precision(y)) : [
        [
          i,
          s
        ],
        [
          u,
          c
        ]
      ];
    }, n.minorExtent = function (t) {
      return arguments.length ? (e = +t[0][0], r = +t[1][0], a = +t[0][1], o = +t[1][1], e > r && (t = e, e = r, r = t), a > o && (t = a, a = o, o = t), n.precision(y)) : [
        [
          e,
          a
        ],
        [
          r,
          o
        ]
      ];
    }, n.step = function (t) {
      return arguments.length ? n.majorStep(t).minorStep(t) : n.minorStep();
    }, n.majorStep = function (t) {
      return arguments.length ? (d = +t[0], m = +t[1], n) : [
        d,
        m
      ];
    }, n.minorStep = function (t) {
      return arguments.length ? (p = +t[0], v = +t[1], n) : [
        p,
        v
      ];
    }, n.precision = function (t) {
      return arguments.length ? (y = +t, l = ve(a, o, 90), f = de(e, r, y), h = ve(s, c, 90), g = de(i, u, y), n) : y;
    }, n.majorExtent([
      [
        -180,
        -90 + Ca
      ],
      [
        180,
        90 - Ca
      ]
    ]).minorExtent([
      [
        -180,
        -80 - Ca
      ],
      [
        180,
        80 + Ca
      ]
    ]);
  }, Bo.geo.greatArc = function () {
    function n() {
      return {
        type: 'LineString',
        coordinates: [
          t || e.apply(this, arguments),
          r || u.apply(this, arguments)
        ]
      };
    }
    var t, r, e = me, u = ye;
    return n.distance = function () {
      return Bo.geo.distance(t || e.apply(this, arguments), r || u.apply(this, arguments));
    }, n.source = function (r) {
      return arguments.length ? (e = r, t = 'function' == typeof r ? null : r, n) : e;
    }, n.target = function (t) {
      return arguments.length ? (u = t, r = 'function' == typeof t ? null : t, n) : u;
    }, n.precision = function () {
      return arguments.length ? n : 0;
    }, n;
  }, Bo.geo.interpolate = function (n, t) {
    return xe(n[0] * za, n[1] * za, t[0] * za, t[1] * za);
  }, Bo.geo.length = function (n) {
    return jc = 0, Bo.geo.stream(n, Hc), jc;
  };
  var jc, Hc = {
      sphere: v,
      point: v,
      lineStart: Me,
      lineEnd: v,
      polygonStart: v,
      polygonEnd: v
    }, Fc = _e(function (n) {
      return Math.sqrt(2 / (1 + n));
    }, function (n) {
      return 2 * Math.asin(n / 2);
    });
  (Bo.geo.azimuthalEqualArea = function () {
    return ue(Fc);
  }).raw = Fc;
  var Oc = _e(function (n) {
      var t = Math.acos(n);
      return t && t / Math.sin(t);
    }, At);
  (Bo.geo.azimuthalEquidistant = function () {
    return ue(Oc);
  }).raw = Oc, (Bo.geo.conicConformal = function () {
    return Yr(be);
  }).raw = be, (Bo.geo.conicEquidistant = function () {
    return Yr(we);
  }).raw = we;
  var Ic = _e(function (n) {
      return 1 / n;
    }, Math.atan);
  (Bo.geo.gnomonic = function () {
    return ue(Ic);
  }).raw = Ic, Se.invert = function (n, t) {
    return [
      n,
      2 * Math.atan(Math.exp(t)) - Aa
    ];
  }, (Bo.geo.mercator = function () {
    return ke(Se);
  }).raw = Se;
  var Yc = _e(function () {
      return 1;
    }, Math.asin);
  (Bo.geo.orthographic = function () {
    return ue(Yc);
  }).raw = Yc;
  var Zc = _e(function (n) {
      return 1 / (1 + n);
    }, function (n) {
      return 2 * Math.atan(n);
    });
  (Bo.geo.stereographic = function () {
    return ue(Zc);
  }).raw = Zc, Ee.invert = function (n, t) {
    return [
      -t,
      2 * Math.atan(Math.exp(n)) - Aa
    ];
  }, (Bo.geo.transverseMercator = function () {
    var n = ke(Ee), t = n.center, r = n.rotate;
    return n.center = function (n) {
      return n ? t([
        -n[1],
        n[0]
      ]) : (n = t(), [
        -n[1],
        n[0]
      ]);
    }, n.rotate = function (n) {
      return n ? r([
        n[0],
        n[1],
        n.length > 2 ? n[2] + 90 : 90
      ]) : (n = r(), [
        n[0],
        n[1],
        n[2] - 90
      ]);
    }, n.rotate([
      0,
      0
    ]);
  }).raw = Ee, Bo.geom = {}, Bo.geom.hull = function (n) {
    function t(n) {
      if (n.length < 3)
        return [];
      var t, u = Et(r), i = Et(e), o = n.length, a = [], c = [];
      for (t = 0; o > t; t++)
        a.push([
          +u.call(this, n[t], t),
          +i.call(this, n[t], t),
          t
        ]);
      for (a.sort(ze), t = 0; o > t; t++)
        c.push([
          a[t][0],
          -a[t][1]
        ]);
      var s = Ne(a), l = Ne(c), f = l[0] === s[0], h = l[l.length - 1] === s[s.length - 1], g = [];
      for (t = s.length - 1; t >= 0; --t)
        g.push(n[a[s[t]][2]]);
      for (t = +f; t < l.length - h; ++t)
        g.push(n[a[l[t]][2]]);
      return g;
    }
    var r = Ae, e = Ce;
    return arguments.length ? t(n) : (t.x = function (n) {
      return arguments.length ? (r = n, t) : r;
    }, t.y = function (n) {
      return arguments.length ? (e = n, t) : e;
    }, t);
  }, Bo.geom.polygon = function (n) {
    return ga(n, Vc), n;
  };
  var Vc = Bo.geom.polygon.prototype = [];
  Vc.area = function () {
    for (var n, t = -1, r = this.length, e = this[r - 1], u = 0; ++t < r;)
      n = e, e = this[t], u += n[1] * e[0] - n[0] * e[1];
    return 0.5 * u;
  }, Vc.centroid = function (n) {
    var t, r, e = -1, u = this.length, i = 0, o = 0, a = this[u - 1];
    for (arguments.length || (n = -1 / (6 * this.area())); ++e < u;)
      t = a, a = this[e], r = t[0] * a[1] - a[0] * t[1], i += (t[0] + a[0]) * r, o += (t[1] + a[1]) * r;
    return [
      i * n,
      o * n
    ];
  }, Vc.clip = function (n) {
    for (var t, r, e, u, i, o, a = qe(n), c = -1, s = this.length - qe(this), l = this[s - 1]; ++c < s;) {
      for (t = n.slice(), n.length = 0, u = this[c], i = t[(e = t.length - a) - 1], r = -1; ++r < e;)
        o = t[r], Le(o, l, u) ? (Le(i, l, u) || n.push(Te(i, o, l, u)), n.push(o)) : Le(i, l, u) && n.push(Te(i, o, l, u)), i = o;
      a && n.push(n[0]), l = u;
    }
    return n;
  };
  var $c, Xc, Bc, Jc, Wc, Gc = [], Kc = [];
  Oe.prototype.prepare = function () {
    for (var n, t = this.edges, r = t.length; r--;)
      n = t[r].edge, n.b && n.a || t.splice(r, 1);
    return t.sort(Ye), t.length;
  }, Qe.prototype = {
    start: function () {
      return this.edge.l === this.site ? this.edge.a : this.edge.b;
    },
    end: function () {
      return this.edge.l === this.site ? this.edge.b : this.edge.a;
    }
  }, nu.prototype = {
    insert: function (n, t) {
      var r, e, u;
      if (n) {
        if (t.P = n, t.N = n.N, n.N && (n.N.P = t), n.N = t, n.R) {
          for (n = n.R; n.L;)
            n = n.L;
          n.L = t;
        } else
          n.R = t;
        r = n;
      } else
        this._ ? (n = uu(this._), t.P = null, t.N = n, n.P = n.L = t, r = n) : (t.P = t.N = null, this._ = t, r = null);
      for (t.L = t.R = null, t.U = r, t.C = !0, n = t; r && r.C;)
        e = r.U, r === e.L ? (u = e.R, u && u.C ? (r.C = u.C = !1, e.C = !0, n = e) : (n === r.R && (ru(this, r), n = r, r = n.U), r.C = !1, e.C = !0, eu(this, e))) : (u = e.L, u && u.C ? (r.C = u.C = !1, e.C = !0, n = e) : (n === r.L && (eu(this, r), n = r, r = n.U), r.C = !1, e.C = !0, ru(this, e))), r = n.U;
      this._.C = !1;
    },
    remove: function (n) {
      n.N && (n.N.P = n.P), n.P && (n.P.N = n.N), n.N = n.P = null;
      var t, r, e, u = n.U, i = n.L, o = n.R;
      if (r = i ? o ? uu(o) : i : o, u ? u.L === n ? u.L = r : u.R = r : this._ = r, i && o ? (e = r.C, r.C = n.C, r.L = i, i.U = r, r !== o ? (u = r.U, r.U = n.U, n = r.R, u.L = n, r.R = o, o.U = r) : (r.U = u, u = r, n = r.R)) : (e = n.C, n = r), n && (n.U = u), !e) {
        if (n && n.C)
          return n.C = !1, void 0;
        do {
          if (n === this._)
            break;
          if (n === u.L) {
            if (t = u.R, t.C && (t.C = !1, u.C = !0, ru(this, u), t = u.R), t.L && t.L.C || t.R && t.R.C) {
              t.R && t.R.C || (t.L.C = !1, t.C = !0, eu(this, t), t = u.R), t.C = u.C, u.C = t.R.C = !1, ru(this, u), n = this._;
              break;
            }
          } else if (t = u.L, t.C && (t.C = !1, u.C = !0, eu(this, u), t = u.L), t.L && t.L.C || t.R && t.R.C) {
            t.L && t.L.C || (t.R.C = !1, t.C = !0, ru(this, t), t = u.L), t.C = u.C, u.C = t.L.C = !1, eu(this, u), n = this._;
            break;
          }
          t.C = !0, n = u, u = u.U;
        } while (!n.C);
        n && (n.C = !1);
      }
    }
  }, Bo.geom.voronoi = function (n) {
    function t(n) {
      var t = new Array(n.length), e = a[0][0], u = a[0][1], i = a[1][0], o = a[1][1];
      return iu(r(n), a).cells.forEach(function (r, a) {
        var c = r.edges, s = r.site, l = t[a] = c.length ? c.map(function (n) {
            var t = n.start();
            return [
              t.x,
              t.y
            ];
          }) : s.x >= e && s.x <= i && s.y >= u && s.y <= o ? [
            [
              e,
              o
            ],
            [
              i,
              o
            ],
            [
              i,
              u
            ],
            [
              e,
              u
            ]
          ] : [];
        l.point = n[a];
      }), t;
    }
    function r(n) {
      return n.map(function (n, t) {
        return {
          x: Math.round(i(n, t) / Ca) * Ca,
          y: Math.round(o(n, t) / Ca) * Ca,
          i: t
        };
      });
    }
    var e = Ae, u = Ce, i = e, o = u, a = Qc;
    return n ? t(n) : (t.links = function (n) {
      return iu(r(n)).edges.filter(function (n) {
        return n.l && n.r;
      }).map(function (t) {
        return {
          source: n[t.l.i],
          target: n[t.r.i]
        };
      });
    }, t.triangles = function (n) {
      var t = [];
      return iu(r(n)).cells.forEach(function (r, e) {
        for (var u, i, o = r.site, a = r.edges.sort(Ye), c = -1, s = a.length, l = a[s - 1].edge, f = l.l === o ? l.r : l.l; ++c < s;)
          u = l, i = f, l = a[c].edge, f = l.l === o ? l.r : l.l, e < i.i && e < f.i && au(o, i, f) < 0 && t.push([
            n[e],
            n[i.i],
            n[f.i]
          ]);
      }), t;
    }, t.x = function (n) {
      return arguments.length ? (i = Et(e = n), t) : e;
    }, t.y = function (n) {
      return arguments.length ? (o = Et(u = n), t) : u;
    }, t.clipExtent = function (n) {
      return arguments.length ? (a = null == n ? Qc : n, t) : a === Qc ? null : a;
    }, t.size = function (n) {
      return arguments.length ? t.clipExtent(n && [
        [
          0,
          0
        ],
        n
      ]) : a === Qc ? null : a && a[1];
    }, t);
  };
  var Qc = [
      [
        -1000000,
        -1000000
      ],
      [
        1000000,
        1000000
      ]
    ];
  Bo.geom.delaunay = function (n) {
    return Bo.geom.voronoi().triangles(n);
  }, Bo.geom.quadtree = function (n, t, r, e, u) {
    function i(n) {
      function i(n, t, r, e, u, i, o, a) {
        if (!isNaN(r) && !isNaN(e))
          if (n.leaf) {
            var c = n.x, l = n.y;
            if (null != c)
              if (ca(c - r) + ca(l - e) < 0.01)
                s(n, t, r, e, u, i, o, a);
              else {
                var f = n.point;
                n.x = n.y = n.point = null, s(n, f, c, l, u, i, o, a), s(n, t, r, e, u, i, o, a);
              }
            else
              n.x = r, n.y = e, n.point = t;
          } else
            s(n, t, r, e, u, i, o, a);
      }
      function s(n, t, r, e, u, o, a, c) {
        var s = 0.5 * (u + a), l = 0.5 * (o + c), f = r >= s, h = e >= l, g = (h << 1) + f;
        n.leaf = !1, n = n.nodes[g] || (n.nodes[g] = lu()), f ? u = s : a = s, h ? o = l : c = l, i(n, t, r, e, u, o, a, c);
      }
      var l, f, h, g, p, v, d, m, y, x = Et(a), M = Et(c);
      if (null != t)
        v = t, d = r, m = e, y = u;
      else if (m = y = -(v = d = 1 / 0), f = [], h = [], p = n.length, o)
        for (g = 0; p > g; ++g)
          l = n[g], l.x < v && (v = l.x), l.y < d && (d = l.y), l.x > m && (m = l.x), l.y > y && (y = l.y), f.push(l.x), h.push(l.y);
      else
        for (g = 0; p > g; ++g) {
          var _ = +x(l = n[g], g), b = +M(l, g);
          v > _ && (v = _), d > b && (d = b), _ > m && (m = _), b > y && (y = b), f.push(_), h.push(b);
        }
      var w = m - v, S = y - d;
      w > S ? y = d + w : m = v + S;
      var k = lu();
      if (k.add = function (n) {
          i(k, n, +x(n, ++g), +M(n, g), v, d, m, y);
        }, k.visit = function (n) {
          fu(n, k, v, d, m, y);
        }, g = -1, null == t) {
        for (; ++g < p;)
          i(k, n[g], f[g], h[g], v, d, m, y);
        --g;
      } else
        n.forEach(k.add);
      return f = h = n = l = null, k;
    }
    var o, a = Ae, c = Ce;
    return (o = arguments.length) ? (a = cu, c = su, 3 === o && (u = r, e = t, r = t = 0), i(n)) : (i.x = function (n) {
      return arguments.length ? (a = n, i) : a;
    }, i.y = function (n) {
      return arguments.length ? (c = n, i) : c;
    }, i.extent = function (n) {
      return arguments.length ? (null == n ? t = r = e = u = null : (t = +n[0][0], r = +n[0][1], e = +n[1][0], u = +n[1][1]), i) : null == t ? null : [
        [
          t,
          r
        ],
        [
          e,
          u
        ]
      ];
    }, i.size = function (n) {
      return arguments.length ? (null == n ? t = r = e = u = null : (t = r = 0, e = +n[0], u = +n[1]), i) : null == t ? null : [
        e - t,
        u - r
      ];
    }, i);
  }, Bo.interpolateRgb = hu, Bo.interpolateObject = gu, Bo.interpolateNumber = pu, Bo.interpolateString = vu;
  var ns = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, ts = new RegExp(ns.source, 'g');
  Bo.interpolate = du, Bo.interpolators = [function (n, t) {
      var r = typeof t;
      return ('string' === r ? $a.has(t) || /^(#|rgb\(|hsl\()/.test(t) ? hu : vu : t instanceof rt ? hu : Array.isArray(t) ? mu : 'object' === r && isNaN(t) ? gu : pu)(n, t);
    }], Bo.interpolateArray = mu;
  var rs = function () {
      return At;
    }, es = Bo.map({
      linear: rs,
      poly: Su,
      quad: function () {
        return _u;
      },
      cubic: function () {
        return bu;
      },
      sin: function () {
        return ku;
      },
      exp: function () {
        return Eu;
      },
      circle: function () {
        return Au;
      },
      elastic: Cu,
      back: Nu,
      bounce: function () {
        return zu;
      }
    }), us = Bo.map({
      'in': At,
      out: xu,
      'in-out': Mu,
      'out-in': function (n) {
        return Mu(xu(n));
      }
    });
  Bo.ease = function (n) {
    var t = n.indexOf('-'), r = t >= 0 ? n.substring(0, t) : n, e = t >= 0 ? n.substring(t + 1) : 'in';
    return r = es.get(r) || rs, e = us.get(e) || At, yu(e(r.apply(null, Jo.call(arguments, 1))));
  }, Bo.interpolateHcl = Lu, Bo.interpolateHsl = Tu, Bo.interpolateLab = qu, Bo.interpolateRound = Ru, Bo.transform = function (n) {
    var t = Go.createElementNS(Bo.ns.prefix.svg, 'g');
    return (Bo.transform = function (n) {
      if (null != n) {
        t.setAttribute('transform', n);
        var r = t.transform.baseVal.consolidate();
      }
      return new Du(r ? r.matrix : is);
    })(n);
  }, Du.prototype.toString = function () {
    return 'translate(' + this.translate + ')rotate(' + this.rotate + ')skewX(' + this.skew + ')scale(' + this.scale + ')';
  };
  var is = {
      a: 1,
      b: 0,
      c: 0,
      d: 1,
      e: 0,
      f: 0
    };
  Bo.interpolateTransform = Hu, Bo.layout = {}, Bo.layout.bundle = function () {
    return function (n) {
      for (var t = [], r = -1, e = n.length; ++r < e;)
        t.push(Iu(n[r]));
      return t;
    };
  }, Bo.layout.chord = function () {
    function n() {
      var n, s, f, h, g, p = {}, v = [], d = Bo.range(i), m = [];
      for (r = [], e = [], n = 0, h = -1; ++h < i;) {
        for (s = 0, g = -1; ++g < i;)
          s += u[h][g];
        v.push(s), m.push(Bo.range(i)), n += s;
      }
      for (o && d.sort(function (n, t) {
          return o(v[n], v[t]);
        }), a && m.forEach(function (n, t) {
          n.sort(function (n, r) {
            return a(u[t][n], u[t][r]);
          });
        }), n = (Ea - l * i) / n, s = 0, h = -1; ++h < i;) {
        for (f = s, g = -1; ++g < i;) {
          var y = d[h], x = m[y][g], M = u[y][x], _ = s, b = s += M * n;
          p[y + '-' + x] = {
            index: y,
            subindex: x,
            startAngle: _,
            endAngle: b,
            value: M
          };
        }
        e[y] = {
          index: y,
          startAngle: f,
          endAngle: s,
          value: (s - f) / n
        }, s += l;
      }
      for (h = -1; ++h < i;)
        for (g = h - 1; ++g < i;) {
          var w = p[h + '-' + g], S = p[g + '-' + h];
          (w.value || S.value) && r.push(w.value < S.value ? {
            source: S,
            target: w
          } : {
            source: w,
            target: S
          });
        }
      c && t();
    }
    function t() {
      r.sort(function (n, t) {
        return c((n.source.value + n.target.value) / 2, (t.source.value + t.target.value) / 2);
      });
    }
    var r, e, u, i, o, a, c, s = {}, l = 0;
    return s.matrix = function (n) {
      return arguments.length ? (i = (u = n) && u.length, r = e = null, s) : u;
    }, s.padding = function (n) {
      return arguments.length ? (l = n, r = e = null, s) : l;
    }, s.sortGroups = function (n) {
      return arguments.length ? (o = n, r = e = null, s) : o;
    }, s.sortSubgroups = function (n) {
      return arguments.length ? (a = n, r = null, s) : a;
    }, s.sortChords = function (n) {
      return arguments.length ? (c = n, r && t(), s) : c;
    }, s.chords = function () {
      return r || n(), r;
    }, s.groups = function () {
      return e || n(), e;
    }, s;
  }, Bo.layout.force = function () {
    function n(n) {
      return function (t, r, e, u) {
        if (t.point !== n) {
          var i = t.cx - n.x, o = t.cy - n.y, a = u - r, c = i * i + o * o;
          if (c > a * a / d) {
            if (p > c) {
              var s = t.charge / c;
              n.px -= i * s, n.py -= o * s;
            }
            return !0;
          }
          if (t.point && c && p > c) {
            var s = t.pointCharge / c;
            n.px -= i * s, n.py -= o * s;
          }
        }
        return !t.charge;
      };
    }
    function t(n) {
      n.px = Bo.event.x, n.py = Bo.event.y, a.resume();
    }
    var r, e, u, i, o, a = {}, c = Bo.dispatch('start', 'tick', 'end'), s = [
        1,
        1
      ], l = 0.9, f = os, h = as, g = -30, p = cs, v = 0.1, d = 0.64, m = [], y = [];
    return a.tick = function () {
      if ((e *= 0.99) < 0.005)
        return c.end({
          type: 'end',
          alpha: e = 0
        }), !0;
      var t, r, a, f, h, p, d, x, M, _ = m.length, b = y.length;
      for (r = 0; b > r; ++r)
        a = y[r], f = a.source, h = a.target, x = h.x - f.x, M = h.y - f.y, (p = x * x + M * M) && (p = e * i[r] * ((p = Math.sqrt(p)) - u[r]) / p, x *= p, M *= p, h.x -= x * (d = f.weight / (h.weight + f.weight)), h.y -= M * d, f.x += x * (d = 1 - d), f.y += M * d);
      if ((d = e * v) && (x = s[0] / 2, M = s[1] / 2, r = -1, d))
        for (; ++r < _;)
          a = m[r], a.x += (x - a.x) * d, a.y += (M - a.y) * d;
      if (g)
        for (Ju(t = Bo.geom.quadtree(m), e, o), r = -1; ++r < _;)
          (a = m[r]).fixed || t.visit(n(a));
      for (r = -1; ++r < _;)
        a = m[r], a.fixed ? (a.x = a.px, a.y = a.py) : (a.x -= (a.px - (a.px = a.x)) * l, a.y -= (a.py - (a.py = a.y)) * l);
      c.tick({
        type: 'tick',
        alpha: e
      });
    }, a.nodes = function (n) {
      return arguments.length ? (m = n, a) : m;
    }, a.links = function (n) {
      return arguments.length ? (y = n, a) : y;
    }, a.size = function (n) {
      return arguments.length ? (s = n, a) : s;
    }, a.linkDistance = function (n) {
      return arguments.length ? (f = 'function' == typeof n ? n : +n, a) : f;
    }, a.distance = a.linkDistance, a.linkStrength = function (n) {
      return arguments.length ? (h = 'function' == typeof n ? n : +n, a) : h;
    }, a.friction = function (n) {
      return arguments.length ? (l = +n, a) : l;
    }, a.charge = function (n) {
      return arguments.length ? (g = 'function' == typeof n ? n : +n, a) : g;
    }, a.chargeDistance = function (n) {
      return arguments.length ? (p = n * n, a) : Math.sqrt(p);
    }, a.gravity = function (n) {
      return arguments.length ? (v = +n, a) : v;
    }, a.theta = function (n) {
      return arguments.length ? (d = n * n, a) : Math.sqrt(d);
    }, a.alpha = function (n) {
      return arguments.length ? (n = +n, e ? e = n > 0 ? n : 0 : n > 0 && (c.start({
        type: 'start',
        alpha: e = n
      }), Bo.timer(a.tick)), a) : e;
    }, a.start = function () {
      function n(n, e) {
        if (!r) {
          for (r = new Array(c), a = 0; c > a; ++a)
            r[a] = [];
          for (a = 0; s > a; ++a) {
            var u = y[a];
            r[u.source.index].push(u.target), r[u.target.index].push(u.source);
          }
        }
        for (var i, o = r[t], a = -1, s = o.length; ++a < s;)
          if (!isNaN(i = o[a][n]))
            return i;
        return Math.random() * e;
      }
      var t, r, e, c = m.length, l = y.length, p = s[0], v = s[1];
      for (t = 0; c > t; ++t)
        (e = m[t]).index = t, e.weight = 0;
      for (t = 0; l > t; ++t)
        e = y[t], 'number' == typeof e.source && (e.source = m[e.source]), 'number' == typeof e.target && (e.target = m[e.target]), ++e.source.weight, ++e.target.weight;
      for (t = 0; c > t; ++t)
        e = m[t], isNaN(e.x) && (e.x = n('x', p)), isNaN(e.y) && (e.y = n('y', v)), isNaN(e.px) && (e.px = e.x), isNaN(e.py) && (e.py = e.y);
      if (u = [], 'function' == typeof f)
        for (t = 0; l > t; ++t)
          u[t] = +f.call(this, y[t], t);
      else
        for (t = 0; l > t; ++t)
          u[t] = f;
      if (i = [], 'function' == typeof h)
        for (t = 0; l > t; ++t)
          i[t] = +h.call(this, y[t], t);
      else
        for (t = 0; l > t; ++t)
          i[t] = h;
      if (o = [], 'function' == typeof g)
        for (t = 0; c > t; ++t)
          o[t] = +g.call(this, m[t], t);
      else
        for (t = 0; c > t; ++t)
          o[t] = g;
      return a.resume();
    }, a.resume = function () {
      return a.alpha(0.1);
    }, a.stop = function () {
      return a.alpha(0);
    }, a.drag = function () {
      return r || (r = Bo.behavior.drag().origin(At).on('dragstart.force', Vu).on('drag.force', t).on('dragend.force', $u)), arguments.length ? (this.on('mouseover.force', Xu).on('mouseout.force', Bu).call(r), void 0) : r;
    }, Bo.rebind(a, c, 'on');
  };
  var os = 20, as = 1, cs = 1 / 0;
  Bo.layout.hierarchy = function () {
    function n(u) {
      var i, o = [u], a = [];
      for (u.depth = 0; null != (i = o.pop());)
        if (a.push(i), (s = r.call(n, i, i.depth)) && (c = s.length)) {
          for (var c, s, l; --c >= 0;)
            o.push(l = s[c]), l.parent = i, l.depth = i.depth + 1;
          e && (i.value = 0), i.children = s;
        } else
          e && (i.value = +e.call(n, i, i.depth) || 0), delete i.children;
      return Ku(u, function (n) {
        var r, u;
        t && (r = n.children) && r.sort(t), e && (u = n.parent) && (u.value += n.value);
      }), a;
    }
    var t = ti, r = Qu, e = ni;
    return n.sort = function (r) {
      return arguments.length ? (t = r, n) : t;
    }, n.children = function (t) {
      return arguments.length ? (r = t, n) : r;
    }, n.value = function (t) {
      return arguments.length ? (e = t, n) : e;
    }, n.revalue = function (t) {
      return e && (Gu(t, function (n) {
        n.children && (n.value = 0);
      }), Ku(t, function (t) {
        var r;
        t.children || (t.value = +e.call(n, t, t.depth) || 0), (r = t.parent) && (r.value += t.value);
      })), t;
    }, n;
  }, Bo.layout.partition = function () {
    function n(t, r, e, u) {
      var i = t.children;
      if (t.x = r, t.y = t.depth * u, t.dx = e, t.dy = u, i && (o = i.length)) {
        var o, a, c, s = -1;
        for (e = t.value ? e / t.value : 0; ++s < o;)
          n(a = i[s], r, c = a.value * e, u), r += c;
      }
    }
    function t(n) {
      var r = n.children, e = 0;
      if (r && (u = r.length))
        for (var u, i = -1; ++i < u;)
          e = Math.max(e, t(r[i]));
      return 1 + e;
    }
    function r(r, i) {
      var o = e.call(this, r, i);
      return n(o[0], 0, u[0], u[1] / t(o[0])), o;
    }
    var e = Bo.layout.hierarchy(), u = [
        1,
        1
      ];
    return r.size = function (n) {
      return arguments.length ? (u = n, r) : u;
    }, Wu(r, e);
  }, Bo.layout.pie = function () {
    function n(i) {
      var o = i.map(function (r, e) {
          return +t.call(n, r, e);
        }), a = +('function' == typeof e ? e.apply(this, arguments) : e), c = (('function' == typeof u ? u.apply(this, arguments) : u) - a) / Bo.sum(o), s = Bo.range(i.length);
      null != r && s.sort(r === ss ? function (n, t) {
        return o[t] - o[n];
      } : function (n, t) {
        return r(i[n], i[t]);
      });
      var l = [];
      return s.forEach(function (n) {
        var t;
        l[n] = {
          data: i[n],
          value: t = o[n],
          startAngle: a,
          endAngle: a += t * c
        };
      }), l;
    }
    var t = Number, r = ss, e = 0, u = Ea;
    return n.value = function (r) {
      return arguments.length ? (t = r, n) : t;
    }, n.sort = function (t) {
      return arguments.length ? (r = t, n) : r;
    }, n.startAngle = function (t) {
      return arguments.length ? (e = t, n) : e;
    }, n.endAngle = function (t) {
      return arguments.length ? (u = t, n) : u;
    }, n;
  };
  var ss = {};
  Bo.layout.stack = function () {
    function n(a, c) {
      var s = a.map(function (r, e) {
          return t.call(n, r, e);
        }), l = s.map(function (t) {
          return t.map(function (t, r) {
            return [
              i.call(n, t, r),
              o.call(n, t, r)
            ];
          });
        }), f = r.call(n, l, c);
      s = Bo.permute(s, f), l = Bo.permute(l, f);
      var h, g, p, v = e.call(n, l, c), d = s.length, m = s[0].length;
      for (g = 0; m > g; ++g)
        for (u.call(n, s[0][g], p = v[g], l[0][g][1]), h = 1; d > h; ++h)
          u.call(n, s[h][g], p += l[h - 1][g][1], l[h][g][1]);
      return a;
    }
    var t = At, r = oi, e = ai, u = ii, i = ei, o = ui;
    return n.values = function (r) {
      return arguments.length ? (t = r, n) : t;
    }, n.order = function (t) {
      return arguments.length ? (r = 'function' == typeof t ? t : ls.get(t) || oi, n) : r;
    }, n.offset = function (t) {
      return arguments.length ? (e = 'function' == typeof t ? t : fs.get(t) || ai, n) : e;
    }, n.x = function (t) {
      return arguments.length ? (i = t, n) : i;
    }, n.y = function (t) {
      return arguments.length ? (o = t, n) : o;
    }, n.out = function (t) {
      return arguments.length ? (u = t, n) : u;
    }, n;
  };
  var ls = Bo.map({
      'inside-out': function (n) {
        var t, r, e = n.length, u = n.map(ci), i = n.map(si), o = Bo.range(e).sort(function (n, t) {
            return u[n] - u[t];
          }), a = 0, c = 0, s = [], l = [];
        for (t = 0; e > t; ++t)
          r = o[t], c > a ? (a += i[r], s.push(r)) : (c += i[r], l.push(r));
        return l.reverse().concat(s);
      },
      reverse: function (n) {
        return Bo.range(n.length).reverse();
      },
      'default': oi
    }), fs = Bo.map({
      silhouette: function (n) {
        var t, r, e, u = n.length, i = n[0].length, o = [], a = 0, c = [];
        for (r = 0; i > r; ++r) {
          for (t = 0, e = 0; u > t; t++)
            e += n[t][r][1];
          e > a && (a = e), o.push(e);
        }
        for (r = 0; i > r; ++r)
          c[r] = (a - o[r]) / 2;
        return c;
      },
      wiggle: function (n) {
        var t, r, e, u, i, o, a, c, s, l = n.length, f = n[0], h = f.length, g = [];
        for (g[0] = c = s = 0, r = 1; h > r; ++r) {
          for (t = 0, u = 0; l > t; ++t)
            u += n[t][r][1];
          for (t = 0, i = 0, a = f[r][0] - f[r - 1][0]; l > t; ++t) {
            for (e = 0, o = (n[t][r][1] - n[t][r - 1][1]) / (2 * a); t > e; ++e)
              o += (n[e][r][1] - n[e][r - 1][1]) / a;
            i += o * n[t][r][1];
          }
          g[r] = c -= u ? i / u * a : 0, s > c && (s = c);
        }
        for (r = 0; h > r; ++r)
          g[r] -= s;
        return g;
      },
      expand: function (n) {
        var t, r, e, u = n.length, i = n[0].length, o = 1 / u, a = [];
        for (r = 0; i > r; ++r) {
          for (t = 0, e = 0; u > t; t++)
            e += n[t][r][1];
          if (e)
            for (t = 0; u > t; t++)
              n[t][r][1] /= e;
          else
            for (t = 0; u > t; t++)
              n[t][r][1] = o;
        }
        for (r = 0; i > r; ++r)
          a[r] = 0;
        return a;
      },
      zero: ai
    });
  Bo.layout.histogram = function () {
    function n(n, i) {
      for (var o, a, c = [], s = n.map(r, this), l = e.call(this, s, i), f = u.call(this, l, s, i), i = -1, h = s.length, g = f.length - 1, p = t ? 1 : 1 / h; ++i < g;)
        o = c[i] = [], o.dx = f[i + 1] - (o.x = f[i]), o.y = 0;
      if (g > 0)
        for (i = -1; ++i < h;)
          a = s[i], a >= l[0] && a <= l[1] && (o = c[Bo.bisect(f, a, 1, g) - 1], o.y += p, o.push(n[i]));
      return c;
    }
    var t = !0, r = Number, e = gi, u = fi;
    return n.value = function (t) {
      return arguments.length ? (r = t, n) : r;
    }, n.range = function (t) {
      return arguments.length ? (e = Et(t), n) : e;
    }, n.bins = function (t) {
      return arguments.length ? (u = 'number' == typeof t ? function (n) {
        return hi(n, t);
      } : Et(t), n) : u;
    }, n.frequency = function (r) {
      return arguments.length ? (t = !!r, n) : t;
    }, n;
  }, Bo.layout.pack = function () {
    function n(n, i) {
      var o = r.call(this, n, i), a = o[0], c = u[0], s = u[1], l = null == t ? Math.sqrt : 'function' == typeof t ? t : function () {
          return t;
        };
      if (a.x = a.y = 0, Ku(a, function (n) {
          n.r = +l(n.value);
        }), Ku(a, yi), e) {
        var f = e * (t ? 1 : Math.max(2 * a.r / c, 2 * a.r / s)) / 2;
        Ku(a, function (n) {
          n.r += f;
        }), Ku(a, yi), Ku(a, function (n) {
          n.r -= f;
        });
      }
      return _i(a, c / 2, s / 2, t ? 1 : 1 / Math.max(2 * a.r / c, 2 * a.r / s)), o;
    }
    var t, r = Bo.layout.hierarchy().sort(pi), e = 0, u = [
        1,
        1
      ];
    return n.size = function (t) {
      return arguments.length ? (u = t, n) : u;
    }, n.radius = function (r) {
      return arguments.length ? (t = null == r || 'function' == typeof r ? r : +r, n) : t;
    }, n.padding = function (t) {
      return arguments.length ? (e = +t, n) : e;
    }, Wu(n, r);
  }, Bo.layout.tree = function () {
    function n(n, u) {
      var l = o.call(this, n, u), f = l[0], h = t(f);
      if (Ku(h, r), h.parent.m = -h.z, Gu(h, e), s)
        Gu(f, i);
      else {
        var g = f, p = f, v = f;
        Gu(f, function (n) {
          n.x < g.x && (g = n), n.x > p.x && (p = n), n.depth > v.depth && (v = n);
        });
        var d = a(g, p) / 2 - g.x, m = c[0] / (p.x + a(p, g) / 2 + d), y = c[1] / (v.depth || 1);
        Gu(f, function (n) {
          n.x = (n.x + d) * m, n.y = n.depth * y;
        });
      }
      return l;
    }
    function t(n) {
      for (var t, r = {
            A: null,
            children: [n]
          }, e = [r]; null != (t = e.pop());)
        for (var u, i = t.children, o = 0, a = i.length; a > o; ++o)
          e.push((i[o] = u = {
            _: i[o],
            parent: t,
            children: (u = i[o].children) && u.slice() || [],
            A: null,
            a: null,
            z: 0,
            m: 0,
            c: 0,
            s: 0,
            t: null,
            i: o
          }).a = u);
      return r.children[0];
    }
    function r(n) {
      var t = n.children, r = n.parent.children, e = n.i ? r[n.i - 1] : null;
      if (t.length) {
        Ai(n);
        var i = (t[0].z + t[t.length - 1].z) / 2;
        e ? (n.z = e.z + a(n._, e._), n.m = n.z - i) : n.z = i;
      } else
        e && (n.z = e.z + a(n._, e._));
      n.parent.A = u(n, e, n.parent.A || r[0]);
    }
    function e(n) {
      n._.x = n.z + n.parent.m, n.m += n.parent.m;
    }
    function u(n, t, r) {
      if (t) {
        for (var e, u = n, i = n, o = t, c = u.parent.children[0], s = u.m, l = i.m, f = o.m, h = c.m; o = ki(o), u = Si(u), o && u;)
          c = Si(c), i = ki(i), i.a = n, e = o.z + f - u.z - s + a(o._, u._), e > 0 && (Ei(Ci(o, n, r), n, e), s += e, l += e), f += o.m, s += u.m, h += c.m, l += i.m;
        o && !ki(i) && (i.t = o, i.m += f - l), u && !Si(c) && (c.t = u, c.m += s - h, r = n);
      }
      return r;
    }
    function i(n) {
      n.x *= c[0], n.y = n.depth * c[1];
    }
    var o = Bo.layout.hierarchy().sort(null).value(null), a = wi, c = [
        1,
        1
      ], s = null;
    return n.separation = function (t) {
      return arguments.length ? (a = t, n) : a;
    }, n.size = function (t) {
      return arguments.length ? (s = null == (c = t) ? i : null, n) : s ? null : c;
    }, n.nodeSize = function (t) {
      return arguments.length ? (s = null == (c = t) ? null : i, n) : s ? c : null;
    }, Wu(n, o);
  }, Bo.layout.cluster = function () {
    function n(n, i) {
      var o, a = t.call(this, n, i), c = a[0], s = 0;
      Ku(c, function (n) {
        var t = n.children;
        t && t.length ? (n.x = zi(t), n.y = Ni(t)) : (n.x = o ? s += r(n, o) : 0, n.y = 0, o = n);
      });
      var l = Li(c), f = Ti(c), h = l.x - r(l, f) / 2, g = f.x + r(f, l) / 2;
      return Ku(c, u ? function (n) {
        n.x = (n.x - c.x) * e[0], n.y = (c.y - n.y) * e[1];
      } : function (n) {
        n.x = (n.x - h) / (g - h) * e[0], n.y = (1 - (c.y ? n.y / c.y : 1)) * e[1];
      }), a;
    }
    var t = Bo.layout.hierarchy().sort(null).value(null), r = wi, e = [
        1,
        1
      ], u = !1;
    return n.separation = function (t) {
      return arguments.length ? (r = t, n) : r;
    }, n.size = function (t) {
      return arguments.length ? (u = null == (e = t), n) : u ? null : e;
    }, n.nodeSize = function (t) {
      return arguments.length ? (u = null != (e = t), n) : u ? e : null;
    }, Wu(n, t);
  }, Bo.layout.treemap = function () {
    function n(n, t) {
      for (var r, e, u = -1, i = n.length; ++u < i;)
        e = (r = n[u]).value * (0 > t ? 0 : t), r.area = isNaN(e) || 0 >= e ? 0 : e;
    }
    function t(r) {
      var i = r.children;
      if (i && i.length) {
        var o, a, c, s = f(r), l = [], h = i.slice(), p = 1 / 0, v = 'slice' === g ? s.dx : 'dice' === g ? s.dy : 'slice-dice' === g ? 1 & r.depth ? s.dy : s.dx : Math.min(s.dx, s.dy);
        for (n(h, s.dx * s.dy / r.value), l.area = 0; (c = h.length) > 0;)
          l.push(o = h[c - 1]), l.area += o.area, 'squarify' !== g || (a = e(l, v)) <= p ? (h.pop(), p = a) : (l.area -= l.pop().area, u(l, v, s, !1), v = Math.min(s.dx, s.dy), l.length = l.area = 0, p = 1 / 0);
        l.length && (u(l, v, s, !0), l.length = l.area = 0), i.forEach(t);
      }
    }
    function r(t) {
      var e = t.children;
      if (e && e.length) {
        var i, o = f(t), a = e.slice(), c = [];
        for (n(a, o.dx * o.dy / t.value), c.area = 0; i = a.pop();)
          c.push(i), c.area += i.area, null != i.z && (u(c, i.z ? o.dx : o.dy, o, !a.length), c.length = c.area = 0);
        e.forEach(r);
      }
    }
    function e(n, t) {
      for (var r, e = n.area, u = 0, i = 1 / 0, o = -1, a = n.length; ++o < a;)
        (r = n[o].area) && (i > r && (i = r), r > u && (u = r));
      return e *= e, t *= t, e ? Math.max(t * u * p / e, e / (t * i * p)) : 1 / 0;
    }
    function u(n, t, r, e) {
      var u, i = -1, o = n.length, a = r.x, s = r.y, l = t ? c(n.area / t) : 0;
      if (t == r.dx) {
        for ((e || l > r.dy) && (l = r.dy); ++i < o;)
          u = n[i], u.x = a, u.y = s, u.dy = l, a += u.dx = Math.min(r.x + r.dx - a, l ? c(u.area / l) : 0);
        u.z = !0, u.dx += r.x + r.dx - a, r.y += l, r.dy -= l;
      } else {
        for ((e || l > r.dx) && (l = r.dx); ++i < o;)
          u = n[i], u.x = a, u.y = s, u.dx = l, s += u.dy = Math.min(r.y + r.dy - s, l ? c(u.area / l) : 0);
        u.z = !1, u.dy += r.y + r.dy - s, r.x += l, r.dx -= l;
      }
    }
    function i(e) {
      var u = o || a(e), i = u[0];
      return i.x = 0, i.y = 0, i.dx = s[0], i.dy = s[1], o && a.revalue(i), n([i], i.dx * i.dy / i.value), (o ? r : t)(i), h && (o = u), u;
    }
    var o, a = Bo.layout.hierarchy(), c = Math.round, s = [
        1,
        1
      ], l = null, f = qi, h = !1, g = 'squarify', p = 0.5 * (1 + Math.sqrt(5));
    return i.size = function (n) {
      return arguments.length ? (s = n, i) : s;
    }, i.padding = function (n) {
      function t(t) {
        var r = n.call(i, t, t.depth);
        return null == r ? qi(t) : Ri(t, 'number' == typeof r ? [
          r,
          r,
          r,
          r
        ] : r);
      }
      function r(t) {
        return Ri(t, n);
      }
      if (!arguments.length)
        return l;
      var e;
      return f = null == (l = n) ? qi : 'function' == (e = typeof n) ? t : 'number' === e ? (n = [
        n,
        n,
        n,
        n
      ], r) : r, i;
    }, i.round = function (n) {
      return arguments.length ? (c = n ? Math.round : Number, i) : c != Number;
    }, i.sticky = function (n) {
      return arguments.length ? (h = n, o = null, i) : h;
    }, i.ratio = function (n) {
      return arguments.length ? (p = n, i) : p;
    }, i.mode = function (n) {
      return arguments.length ? (g = n + '', i) : g;
    }, Wu(i, a);
  }, Bo.random = {
    normal: function (n, t) {
      var r = arguments.length;
      return 2 > r && (t = 1), 1 > r && (n = 0), function () {
        var r, e, u;
        do
          r = 2 * Math.random() - 1, e = 2 * Math.random() - 1, u = r * r + e * e;
        while (!u || u > 1);
        return n + t * r * Math.sqrt(-2 * Math.log(u) / u);
      };
    },
    logNormal: function () {
      var n = Bo.random.normal.apply(Bo, arguments);
      return function () {
        return Math.exp(n());
      };
    },
    bates: function (n) {
      var t = Bo.random.irwinHall(n);
      return function () {
        return t() / n;
      };
    },
    irwinHall: function (n) {
      return function () {
        for (var t = 0, r = 0; n > r; r++)
          t += Math.random();
        return t;
      };
    }
  }, Bo.scale = {};
  var hs = {
      floor: At,
      ceil: At
    };
  Bo.scale.linear = function () {
    return Oi([
      0,
      1
    ], [
      0,
      1
    ], du, !1);
  };
  var gs = {
      s: 1,
      g: 1,
      p: 1,
      r: 1,
      e: 1
    };
  Bo.scale.log = function () {
    return Ji(Bo.scale.linear().domain([
      0,
      1
    ]), 10, !0, [
      1,
      10
    ]);
  };
  var ps = Bo.format('.0e'), vs = {
      floor: function (n) {
        return -Math.ceil(-n);
      },
      ceil: function (n) {
        return -Math.floor(-n);
      }
    };
  Bo.scale.pow = function () {
    return Wi(Bo.scale.linear(), 1, [
      0,
      1
    ]);
  }, Bo.scale.sqrt = function () {
    return Bo.scale.pow().exponent(0.5);
  }, Bo.scale.ordinal = function () {
    return Ki([], {
      t: 'range',
      a: [[]]
    });
  }, Bo.scale.category10 = function () {
    return Bo.scale.ordinal().range(ds);
  }, Bo.scale.category20 = function () {
    return Bo.scale.ordinal().range(ms);
  }, Bo.scale.category20b = function () {
    return Bo.scale.ordinal().range(ys);
  }, Bo.scale.category20c = function () {
    return Bo.scale.ordinal().range(xs);
  };
  var ds = [
      2062260,
      16744206,
      2924588,
      14034728,
      9725885,
      9197131,
      14907330,
      8355711,
      12369186,
      1556175
    ].map(mt), ms = [
      2062260,
      11454440,
      16744206,
      16759672,
      2924588,
      10018698,
      14034728,
      16750742,
      9725885,
      12955861,
      9197131,
      12885140,
      14907330,
      16234194,
      8355711,
      13092807,
      12369186,
      14408589,
      1556175,
      10410725
    ].map(mt), ys = [
      3750777,
      5395619,
      7040719,
      10264286,
      6519097,
      9216594,
      11915115,
      13556636,
      9202993,
      12426809,
      15186514,
      15190932,
      8666169,
      11356490,
      14049643,
      15177372,
      8077683,
      10834324,
      13528509,
      14589654
    ].map(mt), xs = [
      3244733,
      7057110,
      10406625,
      13032431,
      15095053,
      16616764,
      16625259,
      16634018,
      3253076,
      7652470,
      10607003,
      13101504,
      7695281,
      10394312,
      12369372,
      14342891,
      6513507,
      9868950,
      12434877,
      14277081
    ].map(mt);
  Bo.scale.quantile = function () {
    return Qi([], []);
  }, Bo.scale.quantize = function () {
    return no(0, 1, [
      0,
      1
    ]);
  }, Bo.scale.threshold = function () {
    return to([0.5], [
      0,
      1
    ]);
  }, Bo.scale.identity = function () {
    return ro([
      0,
      1
    ]);
  }, Bo.svg = {}, Bo.svg.arc = function () {
    function n() {
      var n = t.apply(this, arguments), i = r.apply(this, arguments), o = e.apply(this, arguments) + Ms, a = u.apply(this, arguments) + Ms, c = (o > a && (c = o, o = a, a = c), a - o), s = ka > c ? '0' : '1', l = Math.cos(o), f = Math.sin(o), h = Math.cos(a), g = Math.sin(a);
      return c >= _s ? n ? 'M0,' + i + 'A' + i + ',' + i + ' 0 1,1 0,' + -i + 'A' + i + ',' + i + ' 0 1,1 0,' + i + 'M0,' + n + 'A' + n + ',' + n + ' 0 1,0 0,' + -n + 'A' + n + ',' + n + ' 0 1,0 0,' + n + 'Z' : 'M0,' + i + 'A' + i + ',' + i + ' 0 1,1 0,' + -i + 'A' + i + ',' + i + ' 0 1,1 0,' + i + 'Z' : n ? 'M' + i * l + ',' + i * f + 'A' + i + ',' + i + ' 0 ' + s + ',1 ' + i * h + ',' + i * g + 'L' + n * h + ',' + n * g + 'A' + n + ',' + n + ' 0 ' + s + ',0 ' + n * l + ',' + n * f + 'Z' : 'M' + i * l + ',' + i * f + 'A' + i + ',' + i + ' 0 ' + s + ',1 ' + i * h + ',' + i * g + 'L0,0' + 'Z';
    }
    var t = eo, r = uo, e = io, u = oo;
    return n.innerRadius = function (r) {
      return arguments.length ? (t = Et(r), n) : t;
    }, n.outerRadius = function (t) {
      return arguments.length ? (r = Et(t), n) : r;
    }, n.startAngle = function (t) {
      return arguments.length ? (e = Et(t), n) : e;
    }, n.endAngle = function (t) {
      return arguments.length ? (u = Et(t), n) : u;
    }, n.centroid = function () {
      var n = (t.apply(this, arguments) + r.apply(this, arguments)) / 2, i = (e.apply(this, arguments) + u.apply(this, arguments)) / 2 + Ms;
      return [
        Math.cos(i) * n,
        Math.sin(i) * n
      ];
    }, n;
  };
  var Ms = -Aa, _s = Ea - Ca;
  Bo.svg.line = function () {
    return ao(At);
  };
  var bs = Bo.map({
      linear: co,
      'linear-closed': so,
      step: lo,
      'step-before': fo,
      'step-after': ho,
      basis: xo,
      'basis-open': Mo,
      'basis-closed': _o,
      bundle: bo,
      cardinal: vo,
      'cardinal-open': go,
      'cardinal-closed': po,
      monotone: Co
    });
  bs.forEach(function (n, t) {
    t.key = n, t.closed = /-closed$/.test(n);
  });
  var ws = [
      0,
      2 / 3,
      1 / 3,
      0
    ], Ss = [
      0,
      1 / 3,
      2 / 3,
      0
    ], ks = [
      0,
      1 / 6,
      2 / 3,
      1 / 6
    ];
  Bo.svg.line.radial = function () {
    var n = ao(No);
    return n.radius = n.x, delete n.x, n.angle = n.y, delete n.y, n;
  }, fo.reverse = ho, ho.reverse = fo, Bo.svg.area = function () {
    return zo(At);
  }, Bo.svg.area.radial = function () {
    var n = zo(No);
    return n.radius = n.x, delete n.x, n.innerRadius = n.x0, delete n.x0, n.outerRadius = n.x1, delete n.x1, n.angle = n.y, delete n.y, n.startAngle = n.y0, delete n.y0, n.endAngle = n.y1, delete n.y1, n;
  }, Bo.svg.chord = function () {
    function n(n, a) {
      var c = t(this, i, n, a), s = t(this, o, n, a);
      return 'M' + c.p0 + e(c.r, c.p1, c.a1 - c.a0) + (r(c, s) ? u(c.r, c.p1, c.r, c.p0) : u(c.r, c.p1, s.r, s.p0) + e(s.r, s.p1, s.a1 - s.a0) + u(s.r, s.p1, c.r, c.p0)) + 'Z';
    }
    function t(n, t, r, e) {
      var u = t.call(n, r, e), i = a.call(n, u, e), o = c.call(n, u, e) + Ms, l = s.call(n, u, e) + Ms;
      return {
        r: i,
        a0: o,
        a1: l,
        p0: [
          i * Math.cos(o),
          i * Math.sin(o)
        ],
        p1: [
          i * Math.cos(l),
          i * Math.sin(l)
        ]
      };
    }
    function r(n, t) {
      return n.a0 == t.a0 && n.a1 == t.a1;
    }
    function e(n, t, r) {
      return 'A' + n + ',' + n + ' 0 ' + +(r > ka) + ',1 ' + t;
    }
    function u(n, t, r, e) {
      return 'Q 0,0 ' + e;
    }
    var i = me, o = ye, a = Lo, c = io, s = oo;
    return n.radius = function (t) {
      return arguments.length ? (a = Et(t), n) : a;
    }, n.source = function (t) {
      return arguments.length ? (i = Et(t), n) : i;
    }, n.target = function (t) {
      return arguments.length ? (o = Et(t), n) : o;
    }, n.startAngle = function (t) {
      return arguments.length ? (c = Et(t), n) : c;
    }, n.endAngle = function (t) {
      return arguments.length ? (s = Et(t), n) : s;
    }, n;
  }, Bo.svg.diagonal = function () {
    function n(n, u) {
      var i = t.call(this, n, u), o = r.call(this, n, u), a = (i.y + o.y) / 2, c = [
          i,
          {
            x: i.x,
            y: a
          },
          {
            x: o.x,
            y: a
          },
          o
        ];
      return c = c.map(e), 'M' + c[0] + 'C' + c[1] + ' ' + c[2] + ' ' + c[3];
    }
    var t = me, r = ye, e = To;
    return n.source = function (r) {
      return arguments.length ? (t = Et(r), n) : t;
    }, n.target = function (t) {
      return arguments.length ? (r = Et(t), n) : r;
    }, n.projection = function (t) {
      return arguments.length ? (e = t, n) : e;
    }, n;
  }, Bo.svg.diagonal.radial = function () {
    var n = Bo.svg.diagonal(), t = To, r = n.projection;
    return n.projection = function (n) {
      return arguments.length ? r(qo(t = n)) : t;
    }, n;
  }, Bo.svg.symbol = function () {
    function n(n, e) {
      return (Es.get(t.call(this, n, e)) || Po)(r.call(this, n, e));
    }
    var t = Do, r = Ro;
    return n.type = function (r) {
      return arguments.length ? (t = Et(r), n) : t;
    }, n.size = function (t) {
      return arguments.length ? (r = Et(t), n) : r;
    }, n;
  };
  var Es = Bo.map({
      circle: Po,
      cross: function (n) {
        var t = Math.sqrt(n / 5) / 2;
        return 'M' + -3 * t + ',' + -t + 'H' + -t + 'V' + -3 * t + 'H' + t + 'V' + -t + 'H' + 3 * t + 'V' + t + 'H' + t + 'V' + 3 * t + 'H' + -t + 'V' + t + 'H' + -3 * t + 'Z';
      },
      diamond: function (n) {
        var t = Math.sqrt(n / (2 * zs)), r = t * zs;
        return 'M0,' + -t + 'L' + r + ',0' + ' 0,' + t + ' ' + -r + ',0' + 'Z';
      },
      square: function (n) {
        var t = Math.sqrt(n) / 2;
        return 'M' + -t + ',' + -t + 'L' + t + ',' + -t + ' ' + t + ',' + t + ' ' + -t + ',' + t + 'Z';
      },
      'triangle-down': function (n) {
        var t = Math.sqrt(n / Ns), r = t * Ns / 2;
        return 'M0,' + r + 'L' + t + ',' + -r + ' ' + -t + ',' + -r + 'Z';
      },
      'triangle-up': function (n) {
        var t = Math.sqrt(n / Ns), r = t * Ns / 2;
        return 'M0,' + -r + 'L' + t + ',' + r + ' ' + -t + ',' + r + 'Z';
      }
    });
  Bo.svg.symbolTypes = Es.keys();
  var As, Cs, Ns = Math.sqrt(3), zs = Math.tan(30 * za), Ls = [], Ts = 0;
  Ls.call = ya.call, Ls.empty = ya.empty, Ls.node = ya.node, Ls.size = ya.size, Bo.transition = function (n) {
    return arguments.length ? As ? n.transition() : n : _a.transition();
  }, Bo.transition.prototype = Ls, Ls.select = function (n) {
    var t, r, e, u = this.id, i = [];
    n = b(n);
    for (var o = -1, a = this.length; ++o < a;) {
      i.push(t = []);
      for (var c = this[o], s = -1, l = c.length; ++s < l;)
        (e = c[s]) && (r = n.call(e, e.__data__, s, o)) ? ('__data__' in e && (r.__data__ = e.__data__), Fo(r, s, u, e.__transition__[u]), t.push(r)) : t.push(null);
    }
    return Uo(i, u);
  }, Ls.selectAll = function (n) {
    var t, r, e, u, i, o = this.id, a = [];
    n = w(n);
    for (var c = -1, s = this.length; ++c < s;)
      for (var l = this[c], f = -1, h = l.length; ++f < h;)
        if (e = l[f]) {
          i = e.__transition__[o], r = n.call(e, e.__data__, f, c), a.push(t = []);
          for (var g = -1, p = r.length; ++g < p;)
            (u = r[g]) && Fo(u, g, o, i), t.push(u);
        }
    return Uo(a, o);
  }, Ls.filter = function (n) {
    var t, r, e, u = [];
    'function' != typeof n && (n = R(n));
    for (var i = 0, o = this.length; o > i; i++) {
      u.push(t = []);
      for (var r = this[i], a = 0, c = r.length; c > a; a++)
        (e = r[a]) && n.call(e, e.__data__, a, i) && t.push(e);
    }
    return Uo(u, this.id);
  }, Ls.tween = function (n, t) {
    var r = this.id;
    return arguments.length < 2 ? this.node().__transition__[r].tween.get(n) : P(this, null == t ? function (t) {
      t.__transition__[r].tween.remove(n);
    } : function (e) {
      e.__transition__[r].tween.set(n, t);
    });
  }, Ls.attr = function (n, t) {
    function r() {
      this.removeAttribute(a);
    }
    function e() {
      this.removeAttributeNS(a.space, a.local);
    }
    function u(n) {
      return null == n ? r : (n += '', function () {
        var t, r = this.getAttribute(a);
        return r !== n && (t = o(r, n), function (n) {
          this.setAttribute(a, t(n));
        });
      });
    }
    function i(n) {
      return null == n ? e : (n += '', function () {
        var t, r = this.getAttributeNS(a.space, a.local);
        return r !== n && (t = o(r, n), function (n) {
          this.setAttributeNS(a.space, a.local, t(n));
        });
      });
    }
    if (arguments.length < 2) {
      for (t in n)
        this.attr(t, n[t]);
      return this;
    }
    var o = 'transform' == n ? Hu : du, a = Bo.ns.qualify(n);
    return jo(this, 'attr.' + n, t, a.local ? i : u);
  }, Ls.attrTween = function (n, t) {
    function r(n, r) {
      var e = t.call(this, n, r, this.getAttribute(u));
      return e && function (n) {
        this.setAttribute(u, e(n));
      };
    }
    function e(n, r) {
      var e = t.call(this, n, r, this.getAttributeNS(u.space, u.local));
      return e && function (n) {
        this.setAttributeNS(u.space, u.local, e(n));
      };
    }
    var u = Bo.ns.qualify(n);
    return this.tween('attr.' + n, u.local ? e : r);
  }, Ls.style = function (n, t, r) {
    function e() {
      this.style.removeProperty(n);
    }
    function u(t) {
      return null == t ? e : (t += '', function () {
        var e, u = Qo.getComputedStyle(this, null).getPropertyValue(n);
        return u !== t && (e = du(u, t), function (t) {
          this.style.setProperty(n, e(t), r);
        });
      });
    }
    var i = arguments.length;
    if (3 > i) {
      if ('string' != typeof n) {
        2 > i && (t = '');
        for (r in n)
          this.style(r, n[r], t);
        return this;
      }
      r = '';
    }
    return jo(this, 'style.' + n, t, u);
  }, Ls.styleTween = function (n, t, r) {
    function e(e, u) {
      var i = t.call(this, e, u, Qo.getComputedStyle(this, null).getPropertyValue(n));
      return i && function (t) {
        this.style.setProperty(n, i(t), r);
      };
    }
    return arguments.length < 3 && (r = ''), this.tween('style.' + n, e);
  }, Ls.text = function (n) {
    return jo(this, 'text', n, Ho);
  }, Ls.remove = function () {
    return this.each('end.transition', function () {
      var n;
      this.__transition__.count < 2 && (n = this.parentNode) && n.removeChild(this);
    });
  }, Ls.ease = function (n) {
    var t = this.id;
    return arguments.length < 1 ? this.node().__transition__[t].ease : ('function' != typeof n && (n = Bo.ease.apply(Bo, arguments)), P(this, function (r) {
      r.__transition__[t].ease = n;
    }));
  }, Ls.delay = function (n) {
    var t = this.id;
    return arguments.length < 1 ? this.node().__transition__[t].delay : P(this, 'function' == typeof n ? function (r, e, u) {
      r.__transition__[t].delay = +n.call(r, r.__data__, e, u);
    } : (n = +n, function (r) {
      r.__transition__[t].delay = n;
    }));
  }, Ls.duration = function (n) {
    var t = this.id;
    return arguments.length < 1 ? this.node().__transition__[t].duration : P(this, 'function' == typeof n ? function (r, e, u) {
      r.__transition__[t].duration = Math.max(1, n.call(r, r.__data__, e, u));
    } : (n = Math.max(1, n), function (r) {
      r.__transition__[t].duration = n;
    }));
  }, Ls.each = function (n, t) {
    var r = this.id;
    if (arguments.length < 2) {
      var e = Cs, u = As;
      As = r, P(this, function (t, e, u) {
        Cs = t.__transition__[r], n.call(t, t.__data__, e, u);
      }), Cs = e, As = u;
    } else
      P(this, function (e) {
        var u = e.__transition__[r];
        (u.event || (u.event = Bo.dispatch('start', 'end'))).on(n, t);
      });
    return this;
  }, Ls.transition = function () {
    for (var n, t, r, e, u = this.id, i = ++Ts, o = [], a = 0, c = this.length; c > a; a++) {
      o.push(n = []);
      for (var t = this[a], s = 0, l = t.length; l > s; s++)
        (r = t[s]) && (e = Object.create(r.__transition__[u]), e.delay += e.duration, Fo(r, s, i, e)), n.push(r);
    }
    return Uo(o, i);
  }, Bo.svg.axis = function () {
    function n(n) {
      n.each(function () {
        var n, s = Bo.select(this), l = this.__chart__ || r, f = this.__chart__ = r.copy(), h = null == c ? f.ticks ? f.ticks.apply(f, a) : f.domain() : c, g = null == t ? f.tickFormat ? f.tickFormat.apply(f, a) : At : t, p = s.selectAll('.tick').data(h, f), v = p.enter().insert('g', '.domain').attr('class', 'tick').style('opacity', Ca), d = Bo.transition(p.exit()).style('opacity', Ca).remove(), m = Bo.transition(p.order()).style('opacity', 1), y = Pi(f), x = s.selectAll('.domain').data([0]), M = (x.enter().append('path').attr('class', 'domain'), Bo.transition(x));
        v.append('line'), v.append('text');
        var _ = v.select('line'), b = m.select('line'), w = p.select('text').text(g), S = v.select('text'), k = m.select('text');
        switch (e) {
        case 'bottom':
          n = Oo, _.attr('y2', u), S.attr('y', Math.max(u, 0) + o), b.attr('x2', 0).attr('y2', u), k.attr('x', 0).attr('y', Math.max(u, 0) + o), w.attr('dy', '.71em').style('text-anchor', 'middle'), M.attr('d', 'M' + y[0] + ',' + i + 'V0H' + y[1] + 'V' + i);
          break;
        case 'top':
          n = Oo, _.attr('y2', -u), S.attr('y', -(Math.max(u, 0) + o)), b.attr('x2', 0).attr('y2', -u), k.attr('x', 0).attr('y', -(Math.max(u, 0) + o)), w.attr('dy', '0em').style('text-anchor', 'middle'), M.attr('d', 'M' + y[0] + ',' + -i + 'V0H' + y[1] + 'V' + -i);
          break;
        case 'left':
          n = Io, _.attr('x2', -u), S.attr('x', -(Math.max(u, 0) + o)), b.attr('x2', -u).attr('y2', 0), k.attr('x', -(Math.max(u, 0) + o)).attr('y', 0), w.attr('dy', '.32em').style('text-anchor', 'end'), M.attr('d', 'M' + -i + ',' + y[0] + 'H0V' + y[1] + 'H' + -i);
          break;
        case 'right':
          n = Io, _.attr('x2', u), S.attr('x', Math.max(u, 0) + o), b.attr('x2', u).attr('y2', 0), k.attr('x', Math.max(u, 0) + o).attr('y', 0), w.attr('dy', '.32em').style('text-anchor', 'start'), M.attr('d', 'M' + i + ',' + y[0] + 'H0V' + y[1] + 'H' + i);
        }
        if (f.rangeBand) {
          var E = f, A = E.rangeBand() / 2;
          l = f = function (n) {
            return E(n) + A;
          };
        } else
          l.rangeBand ? l = f : d.call(n, f);
        v.call(n, l), m.call(n, f);
      });
    }
    var t, r = Bo.scale.linear(), e = qs, u = 6, i = 6, o = 3, a = [10], c = null;
    return n.scale = function (t) {
      return arguments.length ? (r = t, n) : r;
    }, n.orient = function (t) {
      return arguments.length ? (e = t in Rs ? t + '' : qs, n) : e;
    }, n.ticks = function () {
      return arguments.length ? (a = arguments, n) : a;
    }, n.tickValues = function (t) {
      return arguments.length ? (c = t, n) : c;
    }, n.tickFormat = function (r) {
      return arguments.length ? (t = r, n) : t;
    }, n.tickSize = function (t) {
      var r = arguments.length;
      return r ? (u = +t, i = +arguments[r - 1], n) : u;
    }, n.innerTickSize = function (t) {
      return arguments.length ? (u = +t, n) : u;
    }, n.outerTickSize = function (t) {
      return arguments.length ? (i = +t, n) : i;
    }, n.tickPadding = function (t) {
      return arguments.length ? (o = +t, n) : o;
    }, n.tickSubdivide = function () {
      return arguments.length && n;
    }, n;
  };
  var qs = 'bottom', Rs = {
      top: 1,
      right: 1,
      bottom: 1,
      left: 1
    };
  Bo.svg.brush = function () {
    function n(i) {
      i.each(function () {
        var i = Bo.select(this).style('pointer-events', 'all').style('-webkit-tap-highlight-color', 'rgba(0,0,0,0)').on('mousedown.brush', u).on('touchstart.brush', u), o = i.selectAll('.background').data([0]);
        o.enter().append('rect').attr('class', 'background').style('visibility', 'hidden').style('cursor', 'crosshair'), i.selectAll('.extent').data([0]).enter().append('rect').attr('class', 'extent').style('cursor', 'move');
        var a = i.selectAll('.resize').data(p, At);
        a.exit().remove(), a.enter().append('g').attr('class', function (n) {
          return 'resize ' + n;
        }).style('cursor', function (n) {
          return Ds[n];
        }).append('rect').attr('x', function (n) {
          return /[ew]$/.test(n) ? -3 : null;
        }).attr('y', function (n) {
          return /^[ns]/.test(n) ? -3 : null;
        }).attr('width', 6).attr('height', 6).style('visibility', 'hidden'), a.style('display', n.empty() ? 'none' : null);
        var l, f = Bo.transition(i), h = Bo.transition(o);
        c && (l = Pi(c), h.attr('x', l[0]).attr('width', l[1] - l[0]), r(f)), s && (l = Pi(s), h.attr('y', l[0]).attr('height', l[1] - l[0]), e(f)), t(f);
      });
    }
    function t(n) {
      n.selectAll('.resize').attr('transform', function (n) {
        return 'translate(' + l[+/e$/.test(n)] + ',' + f[+/^s/.test(n)] + ')';
      });
    }
    function r(n) {
      n.select('.extent').attr('x', l[0]), n.selectAll('.extent,.n>rect,.s>rect').attr('width', l[1] - l[0]);
    }
    function e(n) {
      n.select('.extent').attr('y', f[0]), n.selectAll('.extent,.e>rect,.w>rect').attr('height', f[1] - f[0]);
    }
    function u() {
      function u() {
        32 == Bo.event.keyCode && (C || (x = null, z[0] -= l[1], z[1] -= f[1], C = 2), y());
      }
      function p() {
        32 == Bo.event.keyCode && 2 == C && (z[0] += l[1], z[1] += f[1], C = 0, y());
      }
      function v() {
        var n = Bo.mouse(_), u = !1;
        M && (n[0] += M[0], n[1] += M[1]), C || (Bo.event.altKey ? (x || (x = [
          (l[0] + l[1]) / 2,
          (f[0] + f[1]) / 2
        ]), z[0] = l[+(n[0] < x[0])], z[1] = f[+(n[1] < x[1])]) : x = null), E && d(n, c, 0) && (r(S), u = !0), A && d(n, s, 1) && (e(S), u = !0), u && (t(S), w({
          type: 'brush',
          mode: C ? 'move' : 'resize'
        }));
      }
      function d(n, t, r) {
        var e, u, a = Pi(t), c = a[0], s = a[1], p = z[r], v = r ? f : l, d = v[1] - v[0];
        return C && (c -= p, s -= d + p), e = (r ? g : h) ? Math.max(c, Math.min(s, n[r])) : n[r], C ? u = (e += p) + d : (x && (p = Math.max(c, Math.min(s, 2 * x[r] - e))), e > p ? (u = e, e = p) : u = p), v[0] != e || v[1] != u ? (r ? o = null : i = null, v[0] = e, v[1] = u, !0) : void 0;
      }
      function m() {
        v(), S.style('pointer-events', 'all').selectAll('.resize').style('display', n.empty() ? 'none' : null), Bo.select('body').style('cursor', null), L.on('mousemove.brush', null).on('mouseup.brush', null).on('touchmove.brush', null).on('touchend.brush', null).on('keydown.brush', null).on('keyup.brush', null), N(), w({ type: 'brushend' });
      }
      var x, M, _ = this, b = Bo.select(Bo.event.target), w = a.of(_, arguments), S = Bo.select(_), k = b.datum(), E = !/^(n|s)$/.test(k) && c, A = !/^(e|w)$/.test(k) && s, C = b.classed('extent'), N = Y(), z = Bo.mouse(_), L = Bo.select(Qo).on('keydown.brush', u).on('keyup.brush', p);
      if (Bo.event.changedTouches ? L.on('touchmove.brush', v).on('touchend.brush', m) : L.on('mousemove.brush', v).on('mouseup.brush', m), S.interrupt().selectAll('*').interrupt(), C)
        z[0] = l[0] - z[0], z[1] = f[0] - z[1];
      else if (k) {
        var T = +/w$/.test(k), q = +/^n/.test(k);
        M = [
          l[1 - T] - z[0],
          f[1 - q] - z[1]
        ], z[0] = l[T], z[1] = f[q];
      } else
        Bo.event.altKey && (x = z.slice());
      S.style('pointer-events', 'none').selectAll('.resize').style('display', null), Bo.select('body').style('cursor', b.style('cursor')), w({ type: 'brushstart' }), v();
    }
    var i, o, a = M(n, 'brushstart', 'brush', 'brushend'), c = null, s = null, l = [
        0,
        0
      ], f = [
        0,
        0
      ], h = !0, g = !0, p = Ps[0];
    return n.event = function (n) {
      n.each(function () {
        var n = a.of(this, arguments), t = {
            x: l,
            y: f,
            i: i,
            j: o
          }, r = this.__chart__ || t;
        this.__chart__ = t, As ? Bo.select(this).transition().each('start.brush', function () {
          i = r.i, o = r.j, l = r.x, f = r.y, n({ type: 'brushstart' });
        }).tween('brush:brush', function () {
          var r = mu(l, t.x), e = mu(f, t.y);
          return i = o = null, function (u) {
            l = t.x = r(u), f = t.y = e(u), n({
              type: 'brush',
              mode: 'resize'
            });
          };
        }).each('end.brush', function () {
          i = t.i, o = t.j, n({
            type: 'brush',
            mode: 'resize'
          }), n({ type: 'brushend' });
        }) : (n({ type: 'brushstart' }), n({
          type: 'brush',
          mode: 'resize'
        }), n({ type: 'brushend' }));
      });
    }, n.x = function (t) {
      return arguments.length ? (c = t, p = Ps[!c << 1 | !s], n) : c;
    }, n.y = function (t) {
      return arguments.length ? (s = t, p = Ps[!c << 1 | !s], n) : s;
    }, n.clamp = function (t) {
      return arguments.length ? (c && s ? (h = !!t[0], g = !!t[1]) : c ? h = !!t : s && (g = !!t), n) : c && s ? [
        h,
        g
      ] : c ? h : s ? g : null;
    }, n.extent = function (t) {
      var r, e, u, a, h;
      return arguments.length ? (c && (r = t[0], e = t[1], s && (r = r[0], e = e[0]), i = [
        r,
        e
      ], c.invert && (r = c(r), e = c(e)), r > e && (h = r, r = e, e = h), (r != l[0] || e != l[1]) && (l = [
        r,
        e
      ])), s && (u = t[0], a = t[1], c && (u = u[1], a = a[1]), o = [
        u,
        a
      ], s.invert && (u = s(u), a = s(a)), u > a && (h = u, u = a, a = h), (u != f[0] || a != f[1]) && (f = [
        u,
        a
      ])), n) : (c && (i ? (r = i[0], e = i[1]) : (r = l[0], e = l[1], c.invert && (r = c.invert(r), e = c.invert(e)), r > e && (h = r, r = e, e = h))), s && (o ? (u = o[0], a = o[1]) : (u = f[0], a = f[1], s.invert && (u = s.invert(u), a = s.invert(a)), u > a && (h = u, u = a, a = h))), c && s ? [
        [
          r,
          u
        ],
        [
          e,
          a
        ]
      ] : c ? [
        r,
        e
      ] : s && [
        u,
        a
      ]);
    }, n.clear = function () {
      return n.empty() || (l = [
        0,
        0
      ], f = [
        0,
        0
      ], i = o = null), n;
    }, n.empty = function () {
      return !!c && l[0] == l[1] || !!s && f[0] == f[1];
    }, Bo.rebind(n, a, 'on');
  };
  var Ds = {
      n: 'ns-resize',
      e: 'ew-resize',
      s: 'ns-resize',
      w: 'ew-resize',
      nw: 'nwse-resize',
      ne: 'nesw-resize',
      se: 'nwse-resize',
      sw: 'nesw-resize'
    }, Ps = [
      [
        'n',
        'e',
        's',
        'w',
        'nw',
        'ne',
        'se',
        'sw'
      ],
      [
        'e',
        'w'
      ],
      [
        'n',
        's'
      ],
      []
    ], Us = rc.format = cc.timeFormat, js = Us.utc, Hs = js('%Y-%m-%dT%H:%M:%S.%LZ');
  Us.iso = Date.prototype.toISOString && +new Date('2000-01-01T00:00:00.000Z') ? Yo : Hs, Yo.parse = function (n) {
    var t = new Date(n);
    return isNaN(t) ? null : t;
  }, Yo.toString = Hs.toString, rc.second = Ht(function (n) {
    return new ec(1000 * Math.floor(n / 1000));
  }, function (n, t) {
    n.setTime(n.getTime() + 1000 * Math.floor(t));
  }, function (n) {
    return n.getSeconds();
  }), rc.seconds = rc.second.range, rc.seconds.utc = rc.second.utc.range, rc.minute = Ht(function (n) {
    return new ec(60000 * Math.floor(n / 60000));
  }, function (n, t) {
    n.setTime(n.getTime() + 60000 * Math.floor(t));
  }, function (n) {
    return n.getMinutes();
  }), rc.minutes = rc.minute.range, rc.minutes.utc = rc.minute.utc.range, rc.hour = Ht(function (n) {
    var t = n.getTimezoneOffset() / 60;
    return new ec(3600000 * (Math.floor(n / 3600000 - t) + t));
  }, function (n, t) {
    n.setTime(n.getTime() + 3600000 * Math.floor(t));
  }, function (n) {
    return n.getHours();
  }), rc.hours = rc.hour.range, rc.hours.utc = rc.hour.utc.range, rc.month = Ht(function (n) {
    return n = rc.day(n), n.setDate(1), n;
  }, function (n, t) {
    n.setMonth(n.getMonth() + t);
  }, function (n) {
    return n.getMonth();
  }), rc.months = rc.month.range, rc.months.utc = rc.month.utc.range;
  var Fs = [
      1000,
      5000,
      15000,
      30000,
      60000,
      300000,
      900000,
      1800000,
      3600000,
      10800000,
      21600000,
      43200000,
      86400000,
      172800000,
      604800000,
      2592000000,
      7776000000,
      31536000000
    ], Os = [
      [
        rc.second,
        1
      ],
      [
        rc.second,
        5
      ],
      [
        rc.second,
        15
      ],
      [
        rc.second,
        30
      ],
      [
        rc.minute,
        1
      ],
      [
        rc.minute,
        5
      ],
      [
        rc.minute,
        15
      ],
      [
        rc.minute,
        30
      ],
      [
        rc.hour,
        1
      ],
      [
        rc.hour,
        3
      ],
      [
        rc.hour,
        6
      ],
      [
        rc.hour,
        12
      ],
      [
        rc.day,
        1
      ],
      [
        rc.day,
        2
      ],
      [
        rc.week,
        1
      ],
      [
        rc.month,
        1
      ],
      [
        rc.month,
        3
      ],
      [
        rc.year,
        1
      ]
    ], Is = Us.multi([
      [
        '.%L',
        function (n) {
          return n.getMilliseconds();
        }
      ],
      [
        ':%S',
        function (n) {
          return n.getSeconds();
        }
      ],
      [
        '%I:%M',
        function (n) {
          return n.getMinutes();
        }
      ],
      [
        '%I %p',
        function (n) {
          return n.getHours();
        }
      ],
      [
        '%a %d',
        function (n) {
          return n.getDay() && 1 != n.getDate();
        }
      ],
      [
        '%b %d',
        function (n) {
          return 1 != n.getDate();
        }
      ],
      [
        '%B',
        function (n) {
          return n.getMonth();
        }
      ],
      [
        '%Y',
        Ar
      ]
    ]), Ys = {
      range: function (n, t, r) {
        return Bo.range(Math.ceil(n / r) * r, +t, r).map(Vo);
      },
      floor: At,
      ceil: At
    };
  Os.year = rc.year, rc.scale = function () {
    return Zo(Bo.scale.linear(), Os, Is);
  };
  var Zs = Os.map(function (n) {
      return [
        n[0].utc,
        n[1]
      ];
    }), Vs = js.multi([
      [
        '.%L',
        function (n) {
          return n.getUTCMilliseconds();
        }
      ],
      [
        ':%S',
        function (n) {
          return n.getUTCSeconds();
        }
      ],
      [
        '%I:%M',
        function (n) {
          return n.getUTCMinutes();
        }
      ],
      [
        '%I %p',
        function (n) {
          return n.getUTCHours();
        }
      ],
      [
        '%a %d',
        function (n) {
          return n.getUTCDay() && 1 != n.getUTCDate();
        }
      ],
      [
        '%b %d',
        function (n) {
          return 1 != n.getUTCDate();
        }
      ],
      [
        '%B',
        function (n) {
          return n.getUTCMonth();
        }
      ],
      [
        '%Y',
        Ar
      ]
    ]);
  Zs.year = rc.year.utc, rc.scale.utc = function () {
    return Zo(Bo.scale.linear(), Zs, Vs);
  }, Bo.text = Ct(function (n) {
    return n.responseText;
  }), Bo.json = function (n, t) {
    return Nt(n, 'application/json', $o, t);
  }, Bo.html = function (n, t) {
    return Nt(n, 'text/html', Xo, t);
  }, Bo.xml = Ct(function (n) {
    return n.responseXML;
  }), 'function' == typeof define && define.amd ? define(Bo) : 'object' == typeof module && module.exports ? module.exports = Bo : this.d3 = Bo;
}();
this.createjs = this.createjs || {};
(function () {
  var c = function () {
    throw 'UID cannot be instantiated';
  };
  c._nextID = 0;
  c.get = function () {
    return c._nextID++;
  };
  createjs.UID = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function () {
      this.initialize();
    }, b = c.prototype;
  c.initialize = function (a) {
    a.addEventListener = b.addEventListener;
    a.removeEventListener = b.removeEventListener;
    a.removeAllEventListeners = b.removeAllEventListeners;
    a.hasEventListener = b.hasEventListener;
    a.dispatchEvent = b.dispatchEvent;
  };
  b._listeners = null;
  b.initialize = function () {
  };
  b.addEventListener = function (a, m) {
    var b = this._listeners;
    b ? this.removeEventListener(a, m) : b = this._listeners = {};
    var d = b[a];
    d || (d = b[a] = []);
    d.push(m);
    return m;
  };
  b.removeEventListener = function (a, m) {
    var b = this._listeners;
    if (b) {
      var d = b[a];
      if (d)
        for (var e = 0, c = d.length; e < c; e++)
          if (d[e] == m) {
            1 == c ? delete b[a] : d.splice(e, 1);
            break;
          }
    }
  };
  b.removeAllEventListeners = function (a) {
    a ? this._listeners && delete this._listeners[a] : this._listeners = null;
  };
  b.dispatchEvent = function (a, m) {
    var b = !1, d = this._listeners;
    if (a && d) {
      'string' == typeof a && (a = { type: a });
      d = d[a.type];
      if (!d)
        return b;
      a.target = m || this;
      for (var d = d.slice(), e = 0, c = d.length; e < c; e++)
        var h = d[e], b = h.handleEvent ? b || h.handleEvent(a) : b || h(a);
    }
    return !!b;
  };
  b.hasEventListener = function (a) {
    var m = this._listeners;
    return !(!m || !m[a]);
  };
  b.toString = function () {
    return '[EventDispatcher]';
  };
  createjs.EventDispatcher = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function () {
    throw 'Ticker cannot be instantiated.';
  };
  c.useRAF = !1;
  c.addEventListener = null;
  c.removeEventListener = null;
  c.removeAllEventListeners = null;
  c.dispatchEvent = null;
  c.hasEventListener = null;
  c._listeners = null;
  createjs.EventDispatcher.initialize(c);
  c._listeners = null;
  c._pauseable = null;
  c._paused = !1;
  c._inited = !1;
  c._startTime = 0;
  c._pausedTime = 0;
  c._ticks = 0;
  c._pausedTicks = 0;
  c._interval = 50;
  c._lastTime = 0;
  c._times = null;
  c._tickTimes = null;
  c._rafActive = !1;
  c._timeoutID = null;
  c.addListener = function (a, m) {
    null != a && (c.removeListener(a), c._pauseable[c._listeners.length] = null == m ? !0 : m, c._listeners.push(a));
  };
  c.init = function () {
    c._inited = !0;
    c._times = [];
    c._tickTimes = [];
    c._pauseable = [];
    c._listeners = [];
    c._times.push(c._lastTime = c._startTime = c._getTime());
    c.setInterval(c._interval);
  };
  c.removeListener = function (a) {
    var m = c._listeners;
    m && (a = m.indexOf(a), -1 != a && (m.splice(a, 1), c._pauseable.splice(a, 1)));
  };
  c.removeAllListeners = function () {
    c._listeners = [];
    c._pauseable = [];
  };
  c.setInterval = function (a) {
    c._interval = a;
    c._inited && c._setupTick();
  };
  c.getInterval = function () {
    return c._interval;
  };
  c.setFPS = function (a) {
    c.setInterval(1000 / a);
  };
  c.getFPS = function () {
    return 1000 / c._interval;
  };
  c.getMeasuredFPS = function (a) {
    if (2 > c._times.length)
      return -1;
    null == a && (a = c.getFPS() | 0);
    a = Math.min(c._times.length - 1, a);
    return 1000 / ((c._times[0] - c._times[a]) / a);
  };
  c.setPaused = function (a) {
    c._paused = a;
  };
  c.getPaused = function () {
    return c._paused;
  };
  c.getTime = function (a) {
    return c._getTime() - c._startTime - (a ? c._pausedTime : 0);
  };
  c.getTicks = function (a) {
    return c._ticks - (a ? c._pausedTicks : 0);
  };
  c._handleAF = function () {
    c._rafActive = !1;
    c._setupTick();
    c._getTime() - c._lastTime >= 0.97 * (c._interval - 1) && c._tick();
  };
  c._handleTimeout = function () {
    c.timeoutID = null;
    c._setupTick();
    c._tick();
  };
  c._setupTick = function () {
    if (!(c._rafActive || null != c.timeoutID)) {
      if (c.useRAF) {
        var a = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame;
        if (a) {
          a(c._handleAF);
          c._rafActive = !0;
          return;
        }
      }
      c.timeoutID = setTimeout(c._handleTimeout, c._interval);
    }
  };
  c._tick = function () {
    var a = c._getTime();
    c._ticks++;
    var m = a - c._lastTime, b = c._paused;
    b && (c._pausedTicks++, c._pausedTime += m);
    c._lastTime = a;
    for (var d = c._pauseable, e = c._listeners.slice(), f = e ? e.length : 0, h = 0; h < f; h++) {
      var k = e[h];
      null == k || b && d[h] || (k.tick ? k.tick(m, b) : k instanceof Function && k(m, b));
    }
    c.dispatchEvent({
      type: 'tick',
      paused: b,
      delta: m,
      time: a,
      runTime: a - c._pausedTime
    });
    for (c._tickTimes.unshift(c._getTime() - a); 100 < c._tickTimes.length;)
      c._tickTimes.pop();
    for (c._times.unshift(a); 100 < c._times.length;)
      c._times.pop();
  };
  var b = window.performance && (performance.now || performance.mozNow || performance.msNow || performance.oNow || performance.webkitNow);
  c._getTime = function () {
    return b && b.call(performance) || new Date().getTime();
  };
  c.init();
  createjs.Ticker = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function (a, m, b, d, e, c, h, k, j) {
      this.initialize(a, m, b, d, e, c, h, k, j);
    }, b = c.prototype;
  b.stageX = 0;
  b.stageY = 0;
  b.rawX = 0;
  b.rawY = 0;
  b.type = null;
  b.nativeEvent = null;
  b.onMouseMove = null;
  b.onMouseUp = null;
  b.target = null;
  b.pointerID = 0;
  b.primary = !1;
  b.addEventListener = null;
  b.removeEventListener = null;
  b.removeAllEventListeners = null;
  b.dispatchEvent = null;
  b.hasEventListener = null;
  b._listeners = null;
  createjs.EventDispatcher.initialize(b);
  b.initialize = function (a, m, b, d, e, c, h, k, j) {
    this.type = a;
    this.stageX = m;
    this.stageY = b;
    this.target = d;
    this.nativeEvent = e;
    this.pointerID = c;
    this.primary = h;
    this.rawX = null == k ? m : k;
    this.rawY = null == j ? b : j;
  };
  b.clone = function () {
    return new c(this.type, this.stageX, this.stageY, this.target, this.nativeEvent, this.pointerID, this.primary, this.rawX, this.rawY);
  };
  b.toString = function () {
    return '[MouseEvent (type=' + this.type + ' stageX=' + this.stageX + ' stageY=' + this.stageY + ')]';
  };
  createjs.MouseEvent = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function (a, m, b, d, c, f) {
      this.initialize(a, m, b, d, c, f);
    }, b = c.prototype;
  c.identity = null;
  c.DEG_TO_RAD = Math.PI / 180;
  b.a = 1;
  b.b = 0;
  b.c = 0;
  b.d = 1;
  b.tx = 0;
  b.ty = 0;
  b.alpha = 1;
  b.shadow = null;
  b.compositeOperation = null;
  b.initialize = function (a, m, b, d, c, f) {
    null != a && (this.a = a);
    this.b = m || 0;
    this.c = b || 0;
    null != d && (this.d = d);
    this.tx = c || 0;
    this.ty = f || 0;
    return this;
  };
  b.prepend = function (a, b, g, d, c, f) {
    var h = this.tx;
    if (1 != a || 0 != b || 0 != g || 1 != d) {
      var k = this.a, j = this.c;
      this.a = k * a + this.b * g;
      this.b = k * b + this.b * d;
      this.c = j * a + this.d * g;
      this.d = j * b + this.d * d;
    }
    this.tx = h * a + this.ty * g + c;
    this.ty = h * b + this.ty * d + f;
    return this;
  };
  b.append = function (a, b, g, d, c, f) {
    var h = this.a, k = this.b, j = this.c, l = this.d;
    this.a = a * h + b * j;
    this.b = a * k + b * l;
    this.c = g * h + d * j;
    this.d = g * k + d * l;
    this.tx = c * h + f * j + this.tx;
    this.ty = c * k + f * l + this.ty;
    return this;
  };
  b.prependMatrix = function (a) {
    this.prepend(a.a, a.b, a.c, a.d, a.tx, a.ty);
    this.prependProperties(a.alpha, a.shadow, a.compositeOperation);
    return this;
  };
  b.appendMatrix = function (a) {
    this.append(a.a, a.b, a.c, a.d, a.tx, a.ty);
    this.appendProperties(a.alpha, a.shadow, a.compositeOperation);
    return this;
  };
  b.prependTransform = function (a, b, g, d, e, f, h, k, j) {
    if (e % 360) {
      var l = e * c.DEG_TO_RAD;
      e = Math.cos(l);
      l = Math.sin(l);
    } else
      e = 1, l = 0;
    if (k || j)
      this.tx -= k, this.ty -= j;
    f || h ? (f *= c.DEG_TO_RAD, h *= c.DEG_TO_RAD, this.prepend(e * g, l * g, -l * d, e * d, 0, 0), this.prepend(Math.cos(h), Math.sin(h), -Math.sin(f), Math.cos(f), a, b)) : this.prepend(e * g, l * g, -l * d, e * d, a, b);
    return this;
  };
  b.appendTransform = function (a, b, g, d, e, f, h, k, j) {
    if (e % 360) {
      var l = e * c.DEG_TO_RAD;
      e = Math.cos(l);
      l = Math.sin(l);
    } else
      e = 1, l = 0;
    f || h ? (f *= c.DEG_TO_RAD, h *= c.DEG_TO_RAD, this.append(Math.cos(h), Math.sin(h), -Math.sin(f), Math.cos(f), a, b), this.append(e * g, l * g, -l * d, e * d, 0, 0)) : this.append(e * g, l * g, -l * d, e * d, a, b);
    if (k || j)
      this.tx -= k * this.a + j * this.c, this.ty -= k * this.b + j * this.d;
    return this;
  };
  b.rotate = function (a) {
    var b = Math.cos(a);
    a = Math.sin(a);
    var g = this.a, d = this.c, c = this.tx;
    this.a = g * b - this.b * a;
    this.b = g * a + this.b * b;
    this.c = d * b - this.d * a;
    this.d = d * a + this.d * b;
    this.tx = c * b - this.ty * a;
    this.ty = c * a + this.ty * b;
    return this;
  };
  b.skew = function (a, b) {
    a *= c.DEG_TO_RAD;
    b *= c.DEG_TO_RAD;
    this.append(Math.cos(b), Math.sin(b), -Math.sin(a), Math.cos(a), 0, 0);
    return this;
  };
  b.scale = function (a, b) {
    this.a *= a;
    this.d *= b;
    this.c *= a;
    this.b *= b;
    this.tx *= a;
    this.ty *= b;
    return this;
  };
  b.translate = function (a, b) {
    this.tx += a;
    this.ty += b;
    return this;
  };
  b.identity = function () {
    this.alpha = this.a = this.d = 1;
    this.b = this.c = this.tx = this.ty = 0;
    this.shadow = this.compositeOperation = null;
    return this;
  };
  b.invert = function () {
    var a = this.a, b = this.b, g = this.c, d = this.d, c = this.tx, f = a * d - b * g;
    this.a = d / f;
    this.b = -b / f;
    this.c = -g / f;
    this.d = a / f;
    this.tx = (g * this.ty - d * c) / f;
    this.ty = -(a * this.ty - b * c) / f;
    return this;
  };
  b.isIdentity = function () {
    return 0 == this.tx && 0 == this.ty && 1 == this.a && 0 == this.b && 0 == this.c && 1 == this.d;
  };
  b.decompose = function (a) {
    null == a && (a = {});
    a.x = this.tx;
    a.y = this.ty;
    a.scaleX = Math.sqrt(this.a * this.a + this.b * this.b);
    a.scaleY = Math.sqrt(this.c * this.c + this.d * this.d);
    var b = Math.atan2(-this.c, this.d), g = Math.atan2(this.b, this.a);
    b == g ? (a.rotation = g / c.DEG_TO_RAD, 0 > this.a && 0 <= this.d && (a.rotation += 0 >= a.rotation ? 180 : -180), a.skewX = a.skewY = 0) : (a.skewX = b / c.DEG_TO_RAD, a.skewY = g / c.DEG_TO_RAD);
    return a;
  };
  b.reinitialize = function (a, b, g, d, c, f, h, k, j) {
    this.initialize(a, b, g, d, c, f);
    this.alpha = h || 1;
    this.shadow = k;
    this.compositeOperation = j;
    return this;
  };
  b.appendProperties = function (a, b, g) {
    this.alpha *= a;
    this.shadow = b || this.shadow;
    this.compositeOperation = g || this.compositeOperation;
    return this;
  };
  b.prependProperties = function (a, b, g) {
    this.alpha *= a;
    this.shadow = this.shadow || b;
    this.compositeOperation = this.compositeOperation || g;
    return this;
  };
  b.clone = function () {
    var a = new c(this.a, this.b, this.c, this.d, this.tx, this.ty);
    a.shadow = this.shadow;
    a.alpha = this.alpha;
    a.compositeOperation = this.compositeOperation;
    return a;
  };
  b.toString = function () {
    return '[Matrix2D (a=' + this.a + ' b=' + this.b + ' c=' + this.c + ' d=' + this.d + ' tx=' + this.tx + ' ty=' + this.ty + ')]';
  };
  c.identity = new c(1, 0, 0, 1, 0, 0);
  createjs.Matrix2D = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function (a, b) {
      this.initialize(a, b);
    }, b = c.prototype;
  b.x = 0;
  b.y = 0;
  b.initialize = function (a, b) {
    this.x = null == a ? 0 : a;
    this.y = null == b ? 0 : b;
  };
  b.clone = function () {
    return new c(this.x, this.y);
  };
  b.toString = function () {
    return '[Point (x=' + this.x + ' y=' + this.y + ')]';
  };
  createjs.Point = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function (a, b, g, d) {
      this.initialize(a, b, g, d);
    }, b = c.prototype;
  b.x = 0;
  b.y = 0;
  b.width = 0;
  b.height = 0;
  b.initialize = function (a, b, g, d) {
    this.x = null == a ? 0 : a;
    this.y = null == b ? 0 : b;
    this.width = null == g ? 0 : g;
    this.height = null == d ? 0 : d;
  };
  b.clone = function () {
    return new c(this.x, this.y, this.width, this.height);
  };
  b.toString = function () {
    return '[Rectangle (x=' + this.x + ' y=' + this.y + ' width=' + this.width + ' height=' + this.height + ')]';
  };
  createjs.Rectangle = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function (a, b, g, d, c, f, h) {
      this.initialize(a, b, g, d, c, f, h);
    }, b = c.prototype;
  b.target = null;
  b.overLabel = null;
  b.outLabel = null;
  b.downLabel = null;
  b.play = !1;
  b._isPressed = !1;
  b._isOver = !1;
  b.initialize = function (a, b, g, d, c, f, h) {
    a.addEventListener && (this.target = a, a.cursor = 'pointer', this.overLabel = null == g ? 'over' : g, this.outLabel = null == b ? 'out' : b, this.downLabel = null == d ? 'down' : d, this.play = c, this.setEnabled(!0), this.handleEvent({}), f && (h && (f.actionsEnabled = !1, f.gotoAndStop && f.gotoAndStop(h)), a.hitArea = f));
  };
  b.setEnabled = function (a) {
    var b = this.target;
    a ? (b.addEventListener('mouseover', this), b.addEventListener('mouseout', this), b.addEventListener('mousedown', this)) : (b.removeEventListener('mouseover', this), b.removeEventListener('mouseout', this), b.removeEventListener('mousedown', this));
  };
  b.toString = function () {
    return '[ButtonHelper]';
  };
  b.handleEvent = function (a) {
    var b = this.target, g = a.type;
    'mousedown' == g ? (a.addEventListener('mouseup', this), this._isPressed = !0, a = this.downLabel) : 'mouseup' == g ? (this._isPressed = !1, a = this._isOver ? this.overLabel : this.outLabel) : 'mouseover' == g ? (this._isOver = !0, a = this._isPressed ? this.downLabel : this.overLabel) : (this._isOver = !1, a = this._isPressed ? this.overLabel : this.outLabel);
    this.play ? b.gotoAndPlay && b.gotoAndPlay(a) : b.gotoAndStop && b.gotoAndStop(a);
  };
  createjs.ButtonHelper = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function (a, b, g, d) {
      this.initialize(a, b, g, d);
    }, b = c.prototype;
  c.identity = null;
  b.color = null;
  b.offsetX = 0;
  b.offsetY = 0;
  b.blur = 0;
  b.initialize = function (a, b, g, d) {
    this.color = a;
    this.offsetX = b;
    this.offsetY = g;
    this.blur = d;
  };
  b.toString = function () {
    return '[Shadow]';
  };
  b.clone = function () {
    return new c(this.color, this.offsetX, this.offsetY, this.blur);
  };
  c.identity = new c('transparent', 0, 0, 0);
  createjs.Shadow = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function (a) {
      this.initialize(a);
    }, b = c.prototype;
  b.complete = !0;
  b.onComplete = null;
  b.addEventListener = null;
  b.removeEventListener = null;
  b.removeAllEventListeners = null;
  b.dispatchEvent = null;
  b.hasEventListener = null;
  b._listeners = null;
  createjs.EventDispatcher.initialize(b);
  b._animations = null;
  b._frames = null;
  b._images = null;
  b._data = null;
  b._loadCount = 0;
  b._frameHeight = 0;
  b._frameWidth = 0;
  b._numFrames = 0;
  b._regX = 0;
  b._regY = 0;
  b.initialize = function (a) {
    var b, g, d;
    if (null != a) {
      if (a.images && 0 < (g = a.images.length)) {
        d = this._images = [];
        for (b = 0; b < g; b++) {
          var c = a.images[b];
          if ('string' == typeof c) {
            var f = c, c = new Image();
            c.src = f;
          }
          d.push(c);
          !c.getContext && !c.complete && (this._loadCount++, this.complete = !1, function (a) {
            c.onload = function () {
              a._handleImageLoad();
            };
          }(this));
        }
      }
      if (null != a.frames)
        if (a.frames instanceof Array) {
          this._frames = [];
          d = a.frames;
          b = 0;
          for (g = d.length; b < g; b++)
            f = d[b], this._frames.push({
              image: this._images[f[4] ? f[4] : 0],
              rect: new createjs.Rectangle(f[0], f[1], f[2], f[3]),
              regX: f[5] || 0,
              regY: f[6] || 0
            });
        } else
          g = a.frames, this._frameWidth = g.width, this._frameHeight = g.height, this._regX = g.regX || 0, this._regY = g.regY || 0, this._numFrames = g.count, 0 == this._loadCount && this._calculateFrames();
      if (null != (g = a.animations)) {
        this._animations = [];
        this._data = {};
        for (var h in g) {
          a = { name: h };
          f = g[h];
          if ('number' == typeof f)
            d = a.frames = [f];
          else if (f instanceof Array)
            if (1 == f.length)
              a.frames = [f[0]];
            else {
              a.frequency = f[3];
              a.next = f[2];
              d = a.frames = [];
              for (b = f[0]; b <= f[1]; b++)
                d.push(b);
            }
          else
            a.frequency = f.frequency, a.next = f.next, b = f.frames, d = a.frames = 'number' == typeof b ? [b] : b.slice(0);
          a.next = 2 > d.length || !1 == a.next ? null : null == a.next || !0 == a.next ? h : a.next;
          a.frequency || (a.frequency = 1);
          this._animations.push(h);
          this._data[h] = a;
        }
      }
    }
  };
  b.getNumFrames = function (a) {
    if (null == a)
      return this._frames ? this._frames.length : this._numFrames;
    a = this._data[a];
    return null == a ? 0 : a.frames.length;
  };
  b.getAnimations = function () {
    return this._animations.slice(0);
  };
  b.getAnimation = function (a) {
    return this._data[a];
  };
  b.getFrame = function (a) {
    var b;
    return this.complete && this._frames && (b = this._frames[a]) ? b : null;
  };
  b.getFrameBounds = function (a) {
    return (a = this.getFrame(a)) ? new createjs.Rectangle(-a.regX, -a.regY, a.rect.width, a.rect.height) : null;
  };
  b.toString = function () {
    return '[SpriteSheet]';
  };
  b.clone = function () {
    var a = new c();
    a.complete = this.complete;
    a._animations = this._animations;
    a._frames = this._frames;
    a._images = this._images;
    a._data = this._data;
    a._frameHeight = this._frameHeight;
    a._frameWidth = this._frameWidth;
    a._numFrames = this._numFrames;
    a._loadCount = this._loadCount;
    return a;
  };
  b._handleImageLoad = function () {
    0 == --this._loadCount && (this._calculateFrames(), this.complete = !0, this.onComplete && this.onComplete(), this.dispatchEvent('complete'));
  };
  b._calculateFrames = function () {
    if (!(this._frames || 0 == this._frameWidth)) {
      this._frames = [];
      for (var a = 0, b = this._frameWidth, g = this._frameHeight, d = 0, c = this._images; d < c.length; d++) {
        for (var f = c[d], h = (f.width + 1) / b | 0, k = (f.height + 1) / g | 0, k = 0 < this._numFrames ? Math.min(this._numFrames - a, h * k) : h * k, j = 0; j < k; j++)
          this._frames.push({
            image: f,
            rect: new createjs.Rectangle(j % h * b, (j / h | 0) * g, b, g),
            regX: this._regX,
            regY: this._regY
          });
        a += k;
      }
      this._numFrames = a;
    }
  };
  createjs.SpriteSheet = c;
}());
this.createjs = this.createjs || {};
(function () {
  function c(a, b, d) {
    this.f = a;
    this.params = b;
    this.path = null == d ? !0 : d;
  }
  c.prototype.exec = function (a) {
    this.f.apply(a, this.params);
  };
  var b = function () {
      this.initialize();
    }, a = b.prototype;
  b.getRGB = function (a, b, d, c) {
    null != a && null == d && (c = b, d = a & 255, b = a >> 8 & 255, a = a >> 16 & 255);
    return null == c ? 'rgb(' + a + ',' + b + ',' + d + ')' : 'rgba(' + a + ',' + b + ',' + d + ',' + c + ')';
  };
  b.getHSL = function (a, b, d, c) {
    return null == c ? 'hsl(' + a % 360 + ',' + b + '%,' + d + '%)' : 'hsla(' + a % 360 + ',' + b + '%,' + d + '%,' + c + ')';
  };
  b.BASE_64 = {
    A: 0,
    B: 1,
    C: 2,
    D: 3,
    E: 4,
    F: 5,
    G: 6,
    H: 7,
    I: 8,
    J: 9,
    K: 10,
    L: 11,
    M: 12,
    N: 13,
    O: 14,
    P: 15,
    Q: 16,
    R: 17,
    S: 18,
    T: 19,
    U: 20,
    V: 21,
    W: 22,
    X: 23,
    Y: 24,
    Z: 25,
    a: 26,
    b: 27,
    c: 28,
    d: 29,
    e: 30,
    f: 31,
    g: 32,
    h: 33,
    i: 34,
    j: 35,
    k: 36,
    l: 37,
    m: 38,
    n: 39,
    o: 40,
    p: 41,
    q: 42,
    r: 43,
    s: 44,
    t: 45,
    u: 46,
    v: 47,
    w: 48,
    x: 49,
    y: 50,
    z: 51,
    '0': 52,
    1: 53,
    2: 54,
    3: 55,
    4: 56,
    5: 57,
    6: 58,
    7: 59,
    8: 60,
    9: 61,
    '+': 62,
    '/': 63
  };
  b.STROKE_CAPS_MAP = [
    'butt',
    'round',
    'square'
  ];
  b.STROKE_JOINTS_MAP = [
    'miter',
    'round',
    'bevel'
  ];
  b._ctx = (createjs.createCanvas ? createjs.createCanvas() : document.createElement('canvas')).getContext('2d');
  b.beginCmd = new c(b._ctx.beginPath, [], !1);
  b.fillCmd = new c(b._ctx.fill, [], !1);
  b.strokeCmd = new c(b._ctx.stroke, [], !1);
  a._strokeInstructions = null;
  a._strokeStyleInstructions = null;
  a._ignoreScaleStroke = !1;
  a._fillInstructions = null;
  a._instructions = null;
  a._oldInstructions = null;
  a._activeInstructions = null;
  a._active = !1;
  a._dirty = !1;
  a.initialize = function () {
    this.clear();
    this._ctx = b._ctx;
  };
  a.isEmpty = function () {
    return !(this._instructions.length || this._oldInstructions.length || this._activeInstructions.length);
  };
  a.draw = function (a) {
    this._dirty && this._updateInstructions();
    for (var b = this._instructions, d = 0, c = b.length; d < c; d++)
      b[d].exec(a);
  };
  a.drawAsPath = function (a) {
    this._dirty && this._updateInstructions();
    for (var b, d = this._instructions, c = 0, f = d.length; c < f; c++)
      ((b = d[c]).path || 0 == c) && b.exec(a);
  };
  a.moveTo = function (a, b) {
    this._activeInstructions.push(new c(this._ctx.moveTo, [
      a,
      b
    ]));
    return this;
  };
  a.lineTo = function (a, b) {
    this._dirty = this._active = !0;
    this._activeInstructions.push(new c(this._ctx.lineTo, [
      a,
      b
    ]));
    return this;
  };
  a.arcTo = function (a, b, d, e, f) {
    this._dirty = this._active = !0;
    this._activeInstructions.push(new c(this._ctx.arcTo, [
      a,
      b,
      d,
      e,
      f
    ]));
    return this;
  };
  a.arc = function (a, b, d, e, f, h) {
    this._dirty = this._active = !0;
    null == h && (h = !1);
    this._activeInstructions.push(new c(this._ctx.arc, [
      a,
      b,
      d,
      e,
      f,
      h
    ]));
    return this;
  };
  a.quadraticCurveTo = function (a, b, d, e) {
    this._dirty = this._active = !0;
    this._activeInstructions.push(new c(this._ctx.quadraticCurveTo, [
      a,
      b,
      d,
      e
    ]));
    return this;
  };
  a.bezierCurveTo = function (a, b, d, e, f, h) {
    this._dirty = this._active = !0;
    this._activeInstructions.push(new c(this._ctx.bezierCurveTo, [
      a,
      b,
      d,
      e,
      f,
      h
    ]));
    return this;
  };
  a.rect = function (a, b, d, e) {
    this._dirty = this._active = !0;
    this._activeInstructions.push(new c(this._ctx.rect, [
      a,
      b,
      d,
      e
    ]));
    return this;
  };
  a.closePath = function () {
    this._active && (this._dirty = !0, this._activeInstructions.push(new c(this._ctx.closePath, [])));
    return this;
  };
  a.clear = function () {
    this._instructions = [];
    this._oldInstructions = [];
    this._activeInstructions = [];
    this._strokeStyleInstructions = this._strokeInstructions = this._fillInstructions = null;
    this._active = this._dirty = !1;
    return this;
  };
  a.beginFill = function (a) {
    this._active && this._newPath();
    this._fillInstructions = a ? [
      new c(this._setProp, [
        'fillStyle',
        a
      ], !1),
      b.fillCmd
    ] : null;
    return this;
  };
  a.beginLinearGradientFill = function (a, g, d, e, f, h) {
    this._active && this._newPath();
    d = this._ctx.createLinearGradient(d, e, f, h);
    e = 0;
    for (f = a.length; e < f; e++)
      d.addColorStop(g[e], a[e]);
    this._fillInstructions = [
      new c(this._setProp, [
        'fillStyle',
        d
      ], !1),
      b.fillCmd
    ];
    return this;
  };
  a.beginRadialGradientFill = function (a, g, d, e, f, h, k, j) {
    this._active && this._newPath();
    d = this._ctx.createRadialGradient(d, e, f, h, k, j);
    e = 0;
    for (f = a.length; e < f; e++)
      d.addColorStop(g[e], a[e]);
    this._fillInstructions = [
      new c(this._setProp, [
        'fillStyle',
        d
      ], !1),
      b.fillCmd
    ];
    return this;
  };
  a.beginBitmapFill = function (a, g, d) {
    this._active && this._newPath();
    a = this._ctx.createPattern(a, g || '');
    a = new c(this._setProp, [
      'fillStyle',
      a
    ], !1);
    this._fillInstructions = d ? [
      a,
      new c(this._ctx.save, [], !1),
      new c(this._ctx.transform, [
        d.a,
        d.b,
        d.c,
        d.d,
        d.tx,
        d.ty
      ], !1),
      b.fillCmd,
      new c(this._ctx.restore, [], !1)
    ] : [
      a,
      b.fillCmd
    ];
    return this;
  };
  a.endFill = function () {
    return this.beginFill();
  };
  a.setStrokeStyle = function (a, g, d, e, f) {
    this._active && this._newPath();
    this._strokeStyleInstructions = [
      new c(this._setProp, [
        'lineWidth',
        null == a ? '1' : a
      ], !1),
      new c(this._setProp, [
        'lineCap',
        null == g ? 'butt' : isNaN(g) ? g : b.STROKE_CAPS_MAP[g]
      ], !1),
      new c(this._setProp, [
        'lineJoin',
        null == d ? 'miter' : isNaN(d) ? d : b.STROKE_JOINTS_MAP[d]
      ], !1),
      new c(this._setProp, [
        'miterLimit',
        null == e ? '10' : e
      ], !1)
    ];
    this._ignoreScaleStroke = f;
    return this;
  };
  a.beginStroke = function (a) {
    this._active && this._newPath();
    this._strokeInstructions = a ? [new c(this._setProp, [
        'strokeStyle',
        a
      ], !1)] : null;
    return this;
  };
  a.beginLinearGradientStroke = function (a, b, d, e, f, h) {
    this._active && this._newPath();
    d = this._ctx.createLinearGradient(d, e, f, h);
    e = 0;
    for (f = a.length; e < f; e++)
      d.addColorStop(b[e], a[e]);
    this._strokeInstructions = [new c(this._setProp, [
        'strokeStyle',
        d
      ], !1)];
    return this;
  };
  a.beginRadialGradientStroke = function (a, b, d, e, f, h, k, j) {
    this._active && this._newPath();
    d = this._ctx.createRadialGradient(d, e, f, h, k, j);
    e = 0;
    for (f = a.length; e < f; e++)
      d.addColorStop(b[e], a[e]);
    this._strokeInstructions = [new c(this._setProp, [
        'strokeStyle',
        d
      ], !1)];
    return this;
  };
  a.beginBitmapStroke = function (a, b) {
    this._active && this._newPath();
    var d = this._ctx.createPattern(a, b || '');
    this._strokeInstructions = [new c(this._setProp, [
        'strokeStyle',
        d
      ], !1)];
    return this;
  };
  a.endStroke = function () {
    this.beginStroke();
    return this;
  };
  a.curveTo = a.quadraticCurveTo;
  a.drawRect = a.rect;
  a.drawRoundRect = function (a, b, d, c, f) {
    this.drawRoundRectComplex(a, b, d, c, f, f, f, f);
    return this;
  };
  a.drawRoundRectComplex = function (a, b, d, e, f, h, k, j) {
    var l = (d < e ? d : e) / 2, n = 0, q = 0, p = 0, s = 0;
    0 > f && (f *= n = -1);
    f > l && (f = l);
    0 > h && (h *= q = -1);
    h > l && (h = l);
    0 > k && (k *= p = -1);
    k > l && (k = l);
    0 > j && (j *= s = -1);
    j > l && (j = l);
    this._dirty = this._active = !0;
    var l = this._ctx.arcTo, r = this._ctx.lineTo;
    this._activeInstructions.push(new c(this._ctx.moveTo, [
      a + d - h,
      b
    ]), new c(l, [
      a + d + h * q,
      b - h * q,
      a + d,
      b + h,
      h
    ]), new c(r, [
      a + d,
      b + e - k
    ]), new c(l, [
      a + d + k * p,
      b + e + k * p,
      a + d - k,
      b + e,
      k
    ]), new c(r, [
      a + j,
      b + e
    ]), new c(l, [
      a - j * s,
      b + e + j * s,
      a,
      b + e - j,
      j
    ]), new c(r, [
      a,
      b + f
    ]), new c(l, [
      a - f * n,
      b - f * n,
      a + f,
      b,
      f
    ]), new c(this._ctx.closePath));
    return this;
  };
  a.drawCircle = function (a, b, d) {
    this.arc(a, b, d, 0, 2 * Math.PI);
    return this;
  };
  a.drawEllipse = function (a, b, d, e) {
    this._dirty = this._active = !0;
    var f = 0.5522848 * (d / 2), h = 0.5522848 * (e / 2), k = a + d, j = b + e;
    d = a + d / 2;
    e = b + e / 2;
    this._activeInstructions.push(new c(this._ctx.moveTo, [
      a,
      e
    ]), new c(this._ctx.bezierCurveTo, [
      a,
      e - h,
      d - f,
      b,
      d,
      b
    ]), new c(this._ctx.bezierCurveTo, [
      d + f,
      b,
      k,
      e - h,
      k,
      e
    ]), new c(this._ctx.bezierCurveTo, [
      k,
      e + h,
      d + f,
      j,
      d,
      j
    ]), new c(this._ctx.bezierCurveTo, [
      d - f,
      j,
      a,
      e + h,
      a,
      e
    ]));
    return this;
  };
  a.drawPolyStar = function (a, b, d, e, f, h) {
    this._dirty = this._active = !0;
    null == f && (f = 0);
    f = 1 - f;
    h = null == h ? 0 : h / (180 / Math.PI);
    var k = Math.PI / e;
    this._activeInstructions.push(new c(this._ctx.moveTo, [
      a + Math.cos(h) * d,
      b + Math.sin(h) * d
    ]));
    for (var j = 0; j < e; j++)
      h += k, 1 != f && this._activeInstructions.push(new c(this._ctx.lineTo, [
        a + Math.cos(h) * d * f,
        b + Math.sin(h) * d * f
      ])), h += k, this._activeInstructions.push(new c(this._ctx.lineTo, [
        a + Math.cos(h) * d,
        b + Math.sin(h) * d
      ]));
    return this;
  };
  a.decodePath = function (a) {
    for (var g = [
          this.moveTo,
          this.lineTo,
          this.quadraticCurveTo,
          this.bezierCurveTo,
          this.closePath
        ], d = [
          2,
          2,
          4,
          6,
          0
        ], c = 0, f = a.length, h = [], k = 0, j = 0, l = b.BASE_64; c < f;) {
      var n = a.charAt(c), q = l[n], p = q >> 3, s = g[p];
      if (!s || q & 3)
        throw 'bad path data (@' + c + '): ' + n;
      n = d[p];
      p || (k = j = 0);
      h.length = 0;
      c++;
      q = (q >> 2 & 1) + 2;
      for (p = 0; p < n; p++) {
        var r = l[a.charAt(c)], u = r >> 5 ? -1 : 1, r = (r & 31) << 6 | l[a.charAt(c + 1)];
        3 == q && (r = r << 6 | l[a.charAt(c + 2)]);
        r = u * r / 10;
        p % 2 ? k = r += k : j = r += j;
        h[p] = r;
        c += q;
      }
      s.apply(this, h);
    }
    return this;
  };
  a.clone = function () {
    var a = new b();
    a._instructions = this._instructions.slice();
    a._activeInstructions = this._activeInstructions.slice();
    a._oldInstructions = this._oldInstructions.slice();
    this._fillInstructions && (a._fillInstructions = this._fillInstructions.slice());
    this._strokeInstructions && (a._strokeInstructions = this._strokeInstructions.slice());
    this._strokeStyleInstructions && (a._strokeStyleInstructions = this._strokeStyleInstructions.slice());
    a._active = this._active;
    a._dirty = this._dirty;
    return a;
  };
  a.toString = function () {
    return '[Graphics]';
  };
  a.mt = a.moveTo;
  a.lt = a.lineTo;
  a.at = a.arcTo;
  a.bt = a.bezierCurveTo;
  a.qt = a.quadraticCurveTo;
  a.a = a.arc;
  a.r = a.rect;
  a.cp = a.closePath;
  a.c = a.clear;
  a.f = a.beginFill;
  a.lf = a.beginLinearGradientFill;
  a.rf = a.beginRadialGradientFill;
  a.bf = a.beginBitmapFill;
  a.ef = a.endFill;
  a.ss = a.setStrokeStyle;
  a.s = a.beginStroke;
  a.ls = a.beginLinearGradientStroke;
  a.rs = a.beginRadialGradientStroke;
  a.bs = a.beginBitmapStroke;
  a.es = a.endStroke;
  a.dr = a.drawRect;
  a.rr = a.drawRoundRect;
  a.rc = a.drawRoundRectComplex;
  a.dc = a.drawCircle;
  a.de = a.drawEllipse;
  a.dp = a.drawPolyStar;
  a.p = a.decodePath;
  a._updateInstructions = function () {
    this._instructions = this._oldInstructions.slice();
    this._instructions.push(b.beginCmd);
    this._instructions.push.apply(this._instructions, this._activeInstructions);
    this._fillInstructions && this._instructions.push.apply(this._instructions, this._fillInstructions);
    this._strokeInstructions && (this._strokeStyleInstructions && this._instructions.push.apply(this._instructions, this._strokeStyleInstructions), this._instructions.push.apply(this._instructions, this._strokeInstructions), this._ignoreScaleStroke ? this._instructions.push(new c(this._ctx.save, [], !1), new c(this._ctx.setTransform, [
      1,
      0,
      0,
      1,
      0,
      0
    ], !1), b.strokeCmd, new c(this._ctx.restore, [], !1)) : this._instructions.push(b.strokeCmd));
  };
  a._newPath = function () {
    this._dirty && this._updateInstructions();
    this._oldInstructions = this._instructions;
    this._activeInstructions = [];
    this._active = this._dirty = !1;
  };
  a._setProp = function (a, b) {
    this[a] = b;
  };
  createjs.Graphics = b;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function () {
      this.initialize();
    }, b = c.prototype;
  c.suppressCrossDomainErrors = !1;
  c._hitTestCanvas = createjs.createCanvas ? createjs.createCanvas() : document.createElement('canvas');
  c._hitTestCanvas.width = c._hitTestCanvas.height = 1;
  c._hitTestContext = c._hitTestCanvas.getContext('2d');
  c._nextCacheID = 1;
  b.alpha = 1;
  b.cacheCanvas = null;
  b.id = -1;
  b.mouseEnabled = !0;
  b.name = null;
  b.parent = null;
  b.regX = 0;
  b.regY = 0;
  b.rotation = 0;
  b.scaleX = 1;
  b.scaleY = 1;
  b.skewX = 0;
  b.skewY = 0;
  b.shadow = null;
  b.visible = !0;
  b.x = 0;
  b.y = 0;
  b.compositeOperation = null;
  b.snapToPixel = !1;
  b.onPress = null;
  b.onClick = null;
  b.onDoubleClick = null;
  b.onMouseOver = null;
  b.onMouseOut = null;
  b.onTick = null;
  b.filters = null;
  b.cacheID = 0;
  b.mask = null;
  b.hitArea = null;
  b.cursor = null;
  b.addEventListener = null;
  b.removeEventListener = null;
  b.removeAllEventListeners = null;
  b.dispatchEvent = null;
  b.hasEventListener = null;
  b._listeners = null;
  createjs.EventDispatcher.initialize(b);
  b._cacheOffsetX = 0;
  b._cacheOffsetY = 0;
  b._cacheScale = 1;
  b._cacheDataURLID = 0;
  b._cacheDataURL = null;
  b._matrix = null;
  b.initialize = function () {
    this.id = createjs.UID.get();
    this._matrix = new createjs.Matrix2D();
  };
  b.isVisible = function () {
    return !(!this.visible || !(0 < this.alpha && 0 != this.scaleX && 0 != this.scaleY));
  };
  b.draw = function (a, b) {
    var c = this.cacheCanvas;
    if (b || !c)
      return !1;
    var d = this._cacheScale;
    a.drawImage(c, this._cacheOffsetX, this._cacheOffsetY, c.width / d, c.height / d);
    return !0;
  };
  b.updateContext = function (a) {
    var b, c = this.mask;
    c && (c.graphics && !c.graphics.isEmpty()) && (b = c.getMatrix(c._matrix), a.transform(b.a, b.b, b.c, b.d, b.tx, b.ty), c.graphics.drawAsPath(a), a.clip(), b.invert(), a.transform(b.a, b.b, b.c, b.d, b.tx, b.ty));
    b = this._matrix.identity().appendTransform(this.x, this.y, this.scaleX, this.scaleY, this.rotation, this.skewX, this.skewY, this.regX, this.regY);
    createjs.Stage._snapToPixelEnabled && this.snapToPixel ? a.transform(b.a, b.b, b.c, b.d, b.tx + 0.5 | 0, b.ty + 0.5 | 0) : a.transform(b.a, b.b, b.c, b.d, b.tx, b.ty);
    a.globalAlpha *= this.alpha;
    this.compositeOperation && (a.globalCompositeOperation = this.compositeOperation);
    this.shadow && this._applyShadow(a, this.shadow);
  };
  b.cache = function (a, b, c, d, e) {
    e = e || 1;
    this.cacheCanvas || (this.cacheCanvas = createjs.createCanvas ? createjs.createCanvas() : document.createElement('canvas'));
    this.cacheCanvas.width = Math.ceil(c * e);
    this.cacheCanvas.height = Math.ceil(d * e);
    this._cacheOffsetX = a;
    this._cacheOffsetY = b;
    this._cacheScale = e || 1;
    this.updateCache();
  };
  b.updateCache = function (a) {
    var b = this.cacheCanvas, g = this._cacheScale, d = this._cacheOffsetX * g, e = this._cacheOffsetY * g;
    if (!b)
      throw 'cache() must be called before updateCache()';
    var f = b.getContext('2d');
    f.save();
    a || f.clearRect(0, 0, b.width + 1, b.height + 1);
    f.globalCompositeOperation = a;
    f.setTransform(g, 0, 0, g, -d, -e);
    this.draw(f, !0);
    this._applyFilters();
    f.restore();
    this.cacheID = c._nextCacheID++;
  };
  b.uncache = function () {
    this._cacheDataURL = this.cacheCanvas = null;
    this.cacheID = this._cacheOffsetX = this._cacheOffsetY = 0;
    this._cacheScale = 1;
  };
  b.getCacheDataURL = function () {
    if (!this.cacheCanvas)
      return null;
    this.cacheID != this._cacheDataURLID && (this._cacheDataURL = this.cacheCanvas.toDataURL());
    return this._cacheDataURL;
  };
  b.getStage = function () {
    for (var a = this; a.parent;)
      a = a.parent;
    return a instanceof createjs.Stage ? a : null;
  };
  b.localToGlobal = function (a, b) {
    var c = this.getConcatenatedMatrix(this._matrix);
    if (null == c)
      return null;
    c.append(1, 0, 0, 1, a, b);
    return new createjs.Point(c.tx, c.ty);
  };
  b.globalToLocal = function (a, b) {
    var c = this.getConcatenatedMatrix(this._matrix);
    if (null == c)
      return null;
    c.invert();
    c.append(1, 0, 0, 1, a, b);
    return new createjs.Point(c.tx, c.ty);
  };
  b.localToLocal = function (a, b, c) {
    a = this.localToGlobal(a, b);
    return c.globalToLocal(a.x, a.y);
  };
  b.setTransform = function (a, b, c, d, e, f, h, k, j) {
    this.x = a || 0;
    this.y = b || 0;
    this.scaleX = null == c ? 1 : c;
    this.scaleY = null == d ? 1 : d;
    this.rotation = e || 0;
    this.skewX = f || 0;
    this.skewY = h || 0;
    this.regX = k || 0;
    this.regY = j || 0;
    return this;
  };
  b.getMatrix = function (a) {
    return (a ? a.identity() : new createjs.Matrix2D()).appendTransform(this.x, this.y, this.scaleX, this.scaleY, this.rotation, this.skewX, this.skewY, this.regX, this.regY).appendProperties(this.alpha, this.shadow, this.compositeOperation);
  };
  b.getConcatenatedMatrix = function (a) {
    a ? a.identity() : a = new createjs.Matrix2D();
    for (var b = this; null != b;)
      a.prependTransform(b.x, b.y, b.scaleX, b.scaleY, b.rotation, b.skewX, b.skewY, b.regX, b.regY).prependProperties(b.alpha, b.shadow, b.compositeOperation), b = b.parent;
    return a;
  };
  b.hitTest = function (a, b) {
    var g = c._hitTestContext;
    g.setTransform(1, 0, 0, 1, -a, -b);
    this.draw(g);
    var d = this._testHit(g);
    g.setTransform(1, 0, 0, 1, 0, 0);
    g.clearRect(0, 0, 2, 2);
    return d;
  };
  b.set = function (a) {
    for (var b in a)
      this[b] = a[b];
    return this;
  };
  b.clone = function () {
    var a = new c();
    this.cloneProps(a);
    return a;
  };
  b.toString = function () {
    return '[DisplayObject (name=' + this.name + ')]';
  };
  b.cloneProps = function (a) {
    a.alpha = this.alpha;
    a.name = this.name;
    a.regX = this.regX;
    a.regY = this.regY;
    a.rotation = this.rotation;
    a.scaleX = this.scaleX;
    a.scaleY = this.scaleY;
    a.shadow = this.shadow;
    a.skewX = this.skewX;
    a.skewY = this.skewY;
    a.visible = this.visible;
    a.x = this.x;
    a.y = this.y;
    a.mouseEnabled = this.mouseEnabled;
    a.compositeOperation = this.compositeOperation;
    this.cacheCanvas && (a.cacheCanvas = this.cacheCanvas.cloneNode(!0), a.cacheCanvas.getContext('2d').putImageData(this.cacheCanvas.getContext('2d').getImageData(0, 0, this.cacheCanvas.width, this.cacheCanvas.height), 0, 0));
  };
  b._applyShadow = function (a, b) {
    b = b || Shadow.identity;
    a.shadowColor = b.color;
    a.shadowOffsetX = b.offsetX;
    a.shadowOffsetY = b.offsetY;
    a.shadowBlur = b.blur;
  };
  b._tick = function (a) {
    this.onTick && this.onTick.apply(this, a);
    var b = this._listeners;
    b && b.tick && this.dispatchEvent({
      type: 'tick',
      params: a
    });
  };
  b._testHit = function (a) {
    try {
      var b = 1 < a.getImageData(0, 0, 1, 1).data[3];
    } catch (g) {
      if (!c.suppressCrossDomainErrors)
        throw 'An error has occurred. This is most likely due to security restrictions on reading canvas pixel data with local or cross-domain images.';
    }
    return b;
  };
  b._applyFilters = function () {
    if (this.filters && 0 != this.filters.length && this.cacheCanvas)
      for (var a = this.filters.length, b = this.cacheCanvas.getContext('2d'), c = this.cacheCanvas.width, d = this.cacheCanvas.height, e = 0; e < a; e++)
        this.filters[e].applyFilter(b, 0, 0, c, d);
  };
  b._hasMouseHandler = function (a) {
    var b = this._listeners;
    return !!(a & 1 && (this.onPress || this.onClick || this.onDoubleClick || b && (this.hasEventListener('mousedown') || this.hasEventListener('click') || this.hasEventListener('dblclick'))) || a & 2 && (this.onMouseOver || this.onMouseOut || this.cursor || b && (this.hasEventListener('mouseover') || this.hasEventListener('mouseout'))));
  };
  createjs.DisplayObject = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function () {
      this.initialize();
    }, b = c.prototype = new createjs.DisplayObject();
  b.children = null;
  b.DisplayObject_initialize = b.initialize;
  b.initialize = function () {
    this.DisplayObject_initialize();
    this.children = [];
  };
  b.isVisible = function () {
    var a = this.cacheCanvas || this.children.length;
    return !(!this.visible || !(0 < this.alpha && 0 != this.scaleX && 0 != this.scaleY && a));
  };
  b.DisplayObject_draw = b.draw;
  b.draw = function (a, b) {
    if (this.DisplayObject_draw(a, b))
      return !0;
    for (var c = this.children.slice(0), d = 0, e = c.length; d < e; d++) {
      var f = c[d];
      f.isVisible() && (a.save(), f.updateContext(a), f.draw(a), a.restore());
    }
    return !0;
  };
  b.addChild = function (a) {
    if (null == a)
      return a;
    var b = arguments.length;
    if (1 < b) {
      for (var c = 0; c < b; c++)
        this.addChild(arguments[c]);
      return arguments[b - 1];
    }
    a.parent && a.parent.removeChild(a);
    a.parent = this;
    this.children.push(a);
    return a;
  };
  b.addChildAt = function (a, b) {
    var c = arguments.length, d = arguments[c - 1];
    if (0 > d || d > this.children.length)
      return arguments[c - 2];
    if (2 < c) {
      for (var e = 0; e < c - 1; e++)
        this.addChildAt(arguments[e], d + e);
      return arguments[c - 2];
    }
    a.parent && a.parent.removeChild(a);
    a.parent = this;
    this.children.splice(b, 0, a);
    return a;
  };
  b.removeChild = function (a) {
    var b = arguments.length;
    if (1 < b) {
      for (var c = !0, d = 0; d < b; d++)
        c = c && this.removeChild(arguments[d]);
      return c;
    }
    return this.removeChildAt(this.children.indexOf(a));
  };
  b.removeChildAt = function (a) {
    var b = arguments.length;
    if (1 < b) {
      for (var c = [], d = 0; d < b; d++)
        c[d] = arguments[d];
      c.sort(function (a, b) {
        return b - a;
      });
      for (var e = !0, d = 0; d < b; d++)
        e = e && this.removeChildAt(c[d]);
      return e;
    }
    if (0 > a || a > this.children.length - 1)
      return !1;
    if (b = this.children[a])
      b.parent = null;
    this.children.splice(a, 1);
    return !0;
  };
  b.removeAllChildren = function () {
    for (var a = this.children; a.length;)
      a.pop().parent = null;
  };
  b.getChildAt = function (a) {
    return this.children[a];
  };
  b.getChildByName = function (a) {
    for (var b = this.children, c = 0, d = b.length; c < d; c++)
      if (b[c].name == a)
        return b[c];
    return null;
  };
  b.sortChildren = function (a) {
    this.children.sort(a);
  };
  b.getChildIndex = function (a) {
    return this.children.indexOf(a);
  };
  b.getNumChildren = function () {
    return this.children.length;
  };
  b.swapChildrenAt = function (a, b) {
    var c = this.children, d = c[a], e = c[b];
    d && e && (c[a] = e, c[b] = d);
  };
  b.swapChildren = function (a, b) {
    for (var c = this.children, d, e, f = 0, h = c.length; f < h && !(c[f] == a && (d = f), c[f] == b && (e = f), null != d && null != e); f++);
    f != h && (c[d] = b, c[e] = a);
  };
  b.setChildIndex = function (a, b) {
    var c = this.children, d = c.length;
    if (!(a.parent != this || 0 > b || b >= d)) {
      for (var e = 0; e < d && c[e] != a; e++);
      e == d || e == b || (c.splice(e, 1), b < e && b--, c.splice(b, 0, a));
    }
  };
  b.contains = function (a) {
    for (; a;) {
      if (a == this)
        return !0;
      a = a.parent;
    }
    return !1;
  };
  b.hitTest = function (a, b) {
    return null != this.getObjectUnderPoint(a, b);
  };
  b.getObjectsUnderPoint = function (a, b) {
    var c = [], d = this.localToGlobal(a, b);
    this._getObjectsUnderPoint(d.x, d.y, c);
    return c;
  };
  b.getObjectUnderPoint = function (a, b) {
    var c = this.localToGlobal(a, b);
    return this._getObjectsUnderPoint(c.x, c.y);
  };
  b.clone = function (a) {
    var b = new c();
    this.cloneProps(b);
    if (a)
      for (var g = b.children = [], d = 0, e = this.children.length; d < e; d++) {
        var f = this.children[d].clone(a);
        f.parent = b;
        g.push(f);
      }
    return b;
  };
  b.toString = function () {
    return '[Container (name=' + this.name + ')]';
  };
  b.DisplayObject__tick = b._tick;
  b._tick = function (a) {
    for (var b = this.children.length - 1; 0 <= b; b--) {
      var c = this.children[b];
      c._tick && c._tick(a);
    }
    this.DisplayObject__tick(a);
  };
  b._getObjectsUnderPoint = function (a, b, g, d) {
    var e = createjs.DisplayObject._hitTestContext, f = this._matrix, h = this._hasMouseHandler(d);
    if (!this.hitArea && (this.cacheCanvas && h) && (this.getConcatenatedMatrix(f), e.setTransform(f.a, f.b, f.c, f.d, f.tx - a, f.ty - b), e.globalAlpha = f.alpha, this.draw(e), this._testHit(e)))
      return e.setTransform(1, 0, 0, 1, 0, 0), e.clearRect(0, 0, 2, 2), this;
    for (var k = this.children.length - 1; 0 <= k; k--) {
      var j = this.children[k], l = j.hitArea;
      if (j.visible && !(!l && !j.isVisible() || d && !j.mouseEnabled)) {
        var n = d && j._hasMouseHandler(d);
        if (j instanceof c && (!l || !n))
          if (h) {
            if (j = j._getObjectsUnderPoint(a, b))
              return this;
          } else {
            if (j = j._getObjectsUnderPoint(a, b, g, d), !g && j)
              return j;
          }
        else if (!d || h || n)
          if (j.getConcatenatedMatrix(f), l && (f.appendTransform(l.x, l.y, l.scaleX, l.scaleY, l.rotation, l.skewX, l.skewY, l.regX, l.regY), f.alpha = l.alpha), e.globalAlpha = f.alpha, e.setTransform(f.a, f.b, f.c, f.d, f.tx - a, f.ty - b), (l || j).draw(e), this._testHit(e)) {
            e.setTransform(1, 0, 0, 1, 0, 0);
            e.clearRect(0, 0, 2, 2);
            if (h)
              return this;
            if (g)
              g.push(j);
            else
              return j;
          }
      }
    }
    return null;
  };
  createjs.Container = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function (a) {
      this.initialize(a);
    }, b = c.prototype = new createjs.Container();
  c._snapToPixelEnabled = !1;
  b.autoClear = !0;
  b.canvas = null;
  b.mouseX = 0;
  b.mouseY = 0;
  b.onMouseMove = null;
  b.onMouseUp = null;
  b.onMouseDown = null;
  b.snapToPixelEnabled = !1;
  b.mouseInBounds = !1;
  b.tickOnUpdate = !0;
  b.mouseMoveOutside = !1;
  b._pointerData = null;
  b._pointerCount = 0;
  b._primaryPointerID = null;
  b._mouseOverIntervalID = null;
  b.Container_initialize = b.initialize;
  b.initialize = function (a) {
    this.Container_initialize();
    this.canvas = 'string' == typeof a ? document.getElementById(a) : a;
    this._pointerData = {};
    this.enableDOMEvents(!0);
  };
  b.update = function () {
    if (this.canvas) {
      this.autoClear && this.clear();
      c._snapToPixelEnabled = this.snapToPixelEnabled;
      this.tickOnUpdate && this._tick(arguments.length ? arguments : null);
      var a = this.canvas.getContext('2d');
      a.save();
      this.updateContext(a);
      this.draw(a, !1);
      a.restore();
    }
  };
  b.tick = b.update;
  b.handleEvent = function (a) {
    'tick' == a.type && this.update(a);
  };
  b.clear = function () {
    if (this.canvas) {
      var a = this.canvas.getContext('2d');
      a.setTransform(1, 0, 0, 1, 0, 0);
      a.clearRect(0, 0, this.canvas.width + 1, this.canvas.height + 1);
    }
  };
  b.toDataURL = function (a, b) {
    b || (b = 'image/png');
    var c = this.canvas.getContext('2d'), d = this.canvas.width, e = this.canvas.height, f;
    if (a) {
      f = c.getImageData(0, 0, d, e);
      var h = c.globalCompositeOperation;
      c.globalCompositeOperation = 'destination-over';
      c.fillStyle = a;
      c.fillRect(0, 0, d, e);
    }
    var k = this.canvas.toDataURL(b);
    a && (c.clearRect(0, 0, d + 1, e + 1), c.putImageData(f, 0, 0), c.globalCompositeOperation = h);
    return k;
  };
  b.enableMouseOver = function (a) {
    this._mouseOverIntervalID && (clearInterval(this._mouseOverIntervalID), this._mouseOverIntervalID = null);
    if (null == a)
      a = 20;
    else if (0 >= a)
      return;
    var b = this;
    this._mouseOverIntervalID = setInterval(function () {
      b._testMouseOver();
    }, 1000 / Math.min(50, a));
  };
  b.enableDOMEvents = function (a) {
    null == a && (a = !0);
    var b, c = this._eventListeners;
    if (!a && c) {
      for (b in c)
        a = c[b], a.t.removeEventListener(b, a.f);
      this._eventListeners = null;
    } else if (a && !c && this.canvas) {
      a = window.addEventListener ? window : document;
      var d = this, c = this._eventListeners = {};
      c.mouseup = {
        t: a,
        f: function (a) {
          d._handleMouseUp(a);
        }
      };
      c.mousemove = {
        t: a,
        f: function (a) {
          d._handleMouseMove(a);
        }
      };
      c.dblclick = {
        t: a,
        f: function (a) {
          d._handleDoubleClick(a);
        }
      };
      c.mousedown = {
        t: this.canvas,
        f: function (a) {
          d._handleMouseDown(a);
        }
      };
      for (b in c)
        a = c[b], a.t.addEventListener(b, a.f);
    }
  };
  b.clone = function () {
    var a = new c(null);
    this.cloneProps(a);
    return a;
  };
  b.toString = function () {
    return '[Stage (name=' + this.name + ')]';
  };
  b._getPointerData = function (a) {
    var b = this._pointerData[a];
    if (!b && (b = this._pointerData[a] = {
        x: 0,
        y: 0
      }, null == this._primaryPointerID || -1 == this._primaryPointerID))
      this._primaryPointerID = a;
    return b;
  };
  b._handleMouseMove = function (a) {
    a || (a = window.event);
    this._handlePointerMove(-1, a, a.pageX, a.pageY);
  };
  b._handlePointerMove = function (a, b, c, d) {
    if (this.canvas) {
      var e = this._getPointerData(a), f = e.inBounds;
      this._updatePointerPosition(a, c, d);
      if (f || e.inBounds || this.mouseMoveOutside) {
        if (this.onMouseMove || this.hasEventListener('stagemousemove'))
          c = new createjs.MouseEvent('stagemousemove', e.x, e.y, this, b, a, a == this._primaryPointerID, e.rawX, e.rawY), this.onMouseMove && this.onMouseMove(c), this.dispatchEvent(c);
        if ((d = e.event) && (d.onMouseMove || d.hasEventListener('mousemove')))
          c = new createjs.MouseEvent('mousemove', e.x, e.y, d.target, b, a, a == this._primaryPointerID, e.rawX, e.rawY), d.onMouseMove && d.onMouseMove(c), d.dispatchEvent(c, d.target);
      }
    }
  };
  b._updatePointerPosition = function (a, b, c) {
    var d = this._getElementRect(this.canvas);
    b -= d.left;
    c -= d.top;
    var e = this.canvas.width, f = this.canvas.height;
    b /= (d.right - d.left) / e;
    c /= (d.bottom - d.top) / f;
    d = this._getPointerData(a);
    (d.inBounds = 0 <= b && 0 <= c && b <= e - 1 && c <= f - 1) ? (d.x = b, d.y = c) : this.mouseMoveOutside && (d.x = 0 > b ? 0 : b > e - 1 ? e - 1 : b, d.y = 0 > c ? 0 : c > f - 1 ? f - 1 : c);
    d.rawX = b;
    d.rawY = c;
    a == this._primaryPointerID && (this.mouseX = d.x, this.mouseY = d.y, this.mouseInBounds = d.inBounds);
  };
  b._getElementRect = function (a) {
    var b;
    try {
      b = a.getBoundingClientRect();
    } catch (c) {
      b = {
        top: a.offsetTop,
        left: a.offsetLeft,
        width: a.offsetWidth,
        height: a.offsetHeight
      };
    }
    var d = (window.pageXOffset || document.scrollLeft || 0) - (document.clientLeft || document.body.clientLeft || 0), e = (window.pageYOffset || document.scrollTop || 0) - (document.clientTop || document.body.clientTop || 0), f = window.getComputedStyle ? getComputedStyle(a) : a.currentStyle;
    a = parseInt(f.paddingLeft) + parseInt(f.borderLeftWidth);
    var h = parseInt(f.paddingTop) + parseInt(f.borderTopWidth), k = parseInt(f.paddingRight) + parseInt(f.borderRightWidth), f = parseInt(f.paddingBottom) + parseInt(f.borderBottomWidth);
    return {
      left: b.left + d + a,
      right: b.right + d - k,
      top: b.top + e + h,
      bottom: b.bottom + e - f
    };
  };
  b._handleMouseUp = function (a) {
    this._handlePointerUp(-1, a, !1);
  };
  b._handlePointerUp = function (a, b, c) {
    var d = this._getPointerData(a), e;
    if (this.onMouseMove || this.hasEventListener('stagemouseup'))
      e = new createjs.MouseEvent('stagemouseup', d.x, d.y, this, b, a, a == this._primaryPointerID, d.rawX, d.rawY), this.onMouseUp && this.onMouseUp(e), this.dispatchEvent(e);
    var f = d.event;
    if (f && (f.onMouseUp || f.hasEventListener('mouseup')))
      e = new createjs.MouseEvent('mouseup', d.x, d.y, f.target, b, a, a == this._primaryPointerID, d.rawX, d.rawY), f.onMouseUp && f.onMouseUp(e), f.dispatchEvent(e, f.target);
    if ((f = d.target) && (f.onClick || f.hasEventListener('click')) && this._getObjectsUnderPoint(d.x, d.y, null, !0, this._mouseOverIntervalID ? 3 : 1) == f)
      e = new createjs.MouseEvent('click', d.x, d.y, f, b, a, a == this._primaryPointerID, d.rawX, d.rawY), f.onClick && f.onClick(e), f.dispatchEvent(e);
    c ? (a == this._primaryPointerID && (this._primaryPointerID = null), delete this._pointerData[a]) : d.event = d.target = null;
  };
  b._handleMouseDown = function (a) {
    this._handlePointerDown(-1, a, !1);
  };
  b._handlePointerDown = function (a, b, c, d) {
    var e = this._getPointerData(a);
    null != d && this._updatePointerPosition(a, c, d);
    if (this.onMouseDown || this.hasEventListener('stagemousedown'))
      c = new createjs.MouseEvent('stagemousedown', e.x, e.y, this, b, a, a == this._primaryPointerID, e.rawX, e.rawY), this.onMouseDown && this.onMouseDown(c), this.dispatchEvent(c);
    if (d = this._getObjectsUnderPoint(e.x, e.y, null, this._mouseOverIntervalID ? 3 : 1))
      if (e.target = d, d.onPress || d.hasEventListener('mousedown'))
        if (c = new createjs.MouseEvent('mousedown', e.x, e.y, d, b, a, a == this._primaryPointerID, e.rawX, e.rawY), d.onPress && d.onPress(c), d.dispatchEvent(c), c.onMouseMove || c.onMouseUp || c.hasEventListener('mousemove') || c.hasEventListener('mouseup'))
          e.event = c;
  };
  b._testMouseOver = function () {
    if (-1 == this._primaryPointerID && !(this.mouseX == this._mouseOverX && this.mouseY == this._mouseOverY && this.mouseInBounds)) {
      var a = null;
      this.mouseInBounds && (a = this._getObjectsUnderPoint(this.mouseX, this.mouseY, null, 3), this._mouseOverX = this.mouseX, this._mouseOverY = this.mouseY);
      var b = this._mouseOverTarget;
      if (b != a) {
        var c = this._getPointerData(-1);
        if (b && (b.onMouseOut || b.hasEventListener('mouseout'))) {
          var d = new createjs.MouseEvent('mouseout', c.x, c.y, b, null, -1, c.rawX, c.rawY);
          b.onMouseOut && b.onMouseOut(d);
          b.dispatchEvent(d);
        }
        b && (this.canvas.style.cursor = '');
        if (a && (a.onMouseOver || a.hasEventListener('mouseover')))
          d = new createjs.MouseEvent('mouseover', c.x, c.y, a, null, -1, c.rawX, c.rawY), a.onMouseOver && a.onMouseOver(d), a.dispatchEvent(d);
        a && (this.canvas.style.cursor = a.cursor || '');
        this._mouseOverTarget = a;
      }
    }
  };
  b._handleDoubleClick = function (a) {
    var b = this._getPointerData(-1), c = this._getObjectsUnderPoint(b.x, b.y, null, this._mouseOverIntervalID ? 3 : 1);
    if (c && (c.onDoubleClick || c.hasEventListener('dblclick')))
      evt = new createjs.MouseEvent('dblclick', b.x, b.y, c, a, -1, !0, b.rawX, b.rawY), c.onDoubleClick && c.onDoubleClick(evt), c.dispatchEvent(evt);
  };
  createjs.Stage = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function (a) {
      this.initialize(a);
    }, b = c.prototype = new createjs.DisplayObject();
  b.image = null;
  b.snapToPixel = !0;
  b.sourceRect = null;
  b.DisplayObject_initialize = b.initialize;
  b.initialize = function (a) {
    this.DisplayObject_initialize();
    'string' == typeof a ? (this.image = new Image(), this.image.src = a) : this.image = a;
  };
  b.isVisible = function () {
    var a = this.cacheCanvas || this.image && (this.image.complete || this.image.getContext || 2 <= this.image.readyState);
    return !(!this.visible || !(0 < this.alpha && 0 != this.scaleX && 0 != this.scaleY && a));
  };
  b.DisplayObject_draw = b.draw;
  b.draw = function (a, b) {
    if (this.DisplayObject_draw(a, b))
      return !0;
    var c = this.sourceRect;
    c ? a.drawImage(this.image, c.x, c.y, c.width, c.height, 0, 0, c.width, c.height) : a.drawImage(this.image, 0, 0);
    return !0;
  };
  b.clone = function () {
    var a = new c(this.image);
    this.sourceRect && (a.sourceRect = this.sourceRect.clone());
    this.cloneProps(a);
    return a;
  };
  b.toString = function () {
    return '[Bitmap (name=' + this.name + ')]';
  };
  createjs.Bitmap = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function (a) {
      this.initialize(a);
    }, b = c.prototype = new createjs.DisplayObject();
  b.onAnimationEnd = null;
  b.currentFrame = -1;
  b.currentAnimation = null;
  b.paused = !0;
  b.spriteSheet = null;
  b.snapToPixel = !0;
  b.offset = 0;
  b.currentAnimationFrame = 0;
  b.addEventListener = null;
  b.removeEventListener = null;
  b.removeAllEventListeners = null;
  b.dispatchEvent = null;
  b.hasEventListener = null;
  b._listeners = null;
  createjs.EventDispatcher.initialize(b);
  b._advanceCount = 0;
  b._animation = null;
  b.DisplayObject_initialize = b.initialize;
  b.initialize = function (a) {
    this.DisplayObject_initialize();
    this.spriteSheet = a;
  };
  b.isVisible = function () {
    var a = this.cacheCanvas || this.spriteSheet.complete && 0 <= this.currentFrame;
    return !(!this.visible || !(0 < this.alpha && 0 != this.scaleX && 0 != this.scaleY && a));
  };
  b.DisplayObject_draw = b.draw;
  b.draw = function (a, b) {
    if (this.DisplayObject_draw(a, b))
      return !0;
    this._normalizeFrame();
    var c = this.spriteSheet.getFrame(this.currentFrame);
    if (c) {
      var d = c.rect;
      a.drawImage(c.image, d.x, d.y, d.width, d.height, -c.regX, -c.regY, d.width, d.height);
      return !0;
    }
  };
  b.play = function () {
    this.paused = !1;
  };
  b.stop = function () {
    this.paused = !0;
  };
  b.gotoAndPlay = function (a) {
    this.paused = !1;
    this._goto(a);
  };
  b.gotoAndStop = function (a) {
    this.paused = !0;
    this._goto(a);
  };
  b.advance = function () {
    this._animation ? this.currentAnimationFrame++ : this.currentFrame++;
    this._normalizeFrame();
  };
  b.getBounds = function () {
    return this.spriteSheet.getFrameBounds(this.currentFrame);
  };
  b.clone = function () {
    var a = new c(this.spriteSheet);
    this.cloneProps(a);
    return a;
  };
  b.toString = function () {
    return '[BitmapAnimation (name=' + this.name + ')]';
  };
  b.DisplayObject__tick = b._tick;
  b._tick = function (a) {
    var b = this._animation ? this._animation.frequency : 1;
    !this.paused && 0 == (++this._advanceCount + this.offset) % b && this.advance();
    this.DisplayObject__tick(a);
  };
  b._normalizeFrame = function () {
    var a = this._animation, b = this.currentFrame, c = this.paused, d;
    if (a)
      if (d = a.frames.length, this.currentAnimationFrame >= d) {
        var e = a.next;
        this._dispatchAnimationEnd(a, b, c, e, d - 1) || (e ? this._goto(e) : (this.paused = !0, this.currentAnimationFrame = a.frames.length - 1, this.currentFrame = a.frames[this.currentAnimationFrame]));
      } else
        this.currentFrame = a.frames[this.currentAnimationFrame];
    else
      d = this.spriteSheet.getNumFrames(), b >= d && !this._dispatchAnimationEnd(a, b, c, d - 1) && (this.currentFrame = 0);
  };
  b._dispatchAnimationEnd = function (a, b, c, d, e) {
    var f = a ? a.name : null;
    this.onAnimationEnd && this.onAnimationEnd(this, f, d);
    this.dispatchEvent({
      type: 'animationend',
      name: f,
      next: d
    });
    !c && this.paused && (this.currentAnimationFrame = e);
    return this.paused != c || this._animation != a || this.currentFrame != b;
  };
  b.DisplayObject_cloneProps = b.cloneProps;
  b.cloneProps = function (a) {
    this.DisplayObject_cloneProps(a);
    a.onAnimationEnd = this.onAnimationEnd;
    a.currentFrame = this.currentFrame;
    a.currentAnimation = this.currentAnimation;
    a.paused = this.paused;
    a.offset = this.offset;
    a._animation = this._animation;
    a.currentAnimationFrame = this.currentAnimationFrame;
  };
  b._goto = function (a) {
    if (isNaN(a)) {
      var b = this.spriteSheet.getAnimation(a);
      b && (this.currentAnimationFrame = 0, this._animation = b, this.currentAnimation = a, this._normalizeFrame());
    } else
      this.currentAnimation = this._animation = null, this.currentFrame = a;
  };
  createjs.BitmapAnimation = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function (a) {
      this.initialize(a);
    }, b = c.prototype = new createjs.DisplayObject();
  b.graphics = null;
  b.DisplayObject_initialize = b.initialize;
  b.initialize = function (a) {
    this.DisplayObject_initialize();
    this.graphics = a ? a : new createjs.Graphics();
  };
  b.isVisible = function () {
    var a = this.cacheCanvas || this.graphics && !this.graphics.isEmpty();
    return !(!this.visible || !(0 < this.alpha && 0 != this.scaleX && 0 != this.scaleY && a));
  };
  b.DisplayObject_draw = b.draw;
  b.draw = function (a, b) {
    if (this.DisplayObject_draw(a, b))
      return !0;
    this.graphics.draw(a);
    return !0;
  };
  b.clone = function (a) {
    a = new c(a && this.graphics ? this.graphics.clone() : this.graphics);
    this.cloneProps(a);
    return a;
  };
  b.toString = function () {
    return '[Shape (name=' + this.name + ')]';
  };
  createjs.Shape = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function (a, b, c) {
      this.initialize(a, b, c);
    }, b = c.prototype = new createjs.DisplayObject();
  c._workingContext = (createjs.createCanvas ? createjs.createCanvas() : document.createElement('canvas')).getContext('2d');
  b.text = '';
  b.font = null;
  b.color = '#000';
  b.textAlign = 'left';
  b.textBaseline = 'top';
  b.maxWidth = null;
  b.outline = !1;
  b.lineHeight = 0;
  b.lineWidth = null;
  b.DisplayObject_initialize = b.initialize;
  b.initialize = function (a, b, c) {
    this.DisplayObject_initialize();
    this.text = a;
    this.font = b;
    this.color = c ? c : '#000';
  };
  b.isVisible = function () {
    var a = this.cacheCanvas || null != this.text && '' !== this.text;
    return !(!this.visible || !(0 < this.alpha && 0 != this.scaleX && 0 != this.scaleY && a));
  };
  b.DisplayObject_draw = b.draw;
  b.draw = function (a, b) {
    if (this.DisplayObject_draw(a, b))
      return !0;
    this.outline ? a.strokeStyle = this.color : a.fillStyle = this.color;
    a.font = this.font;
    a.textAlign = this.textAlign || 'start';
    a.textBaseline = this.textBaseline || 'alphabetic';
    this._drawText(a);
    return !0;
  };
  b.getMeasuredWidth = function () {
    return this._getWorkingContext().measureText(this.text).width;
  };
  b.getMeasuredLineHeight = function () {
    return 1.2 * this._getWorkingContext().measureText('M').width;
  };
  b.getMeasuredHeight = function () {
    return this._drawText() * (this.lineHeight || this.getMeasuredLineHeight());
  };
  b.clone = function () {
    var a = new c(this.text, this.font, this.color);
    this.cloneProps(a);
    return a;
  };
  b.toString = function () {
    return '[Text (text=' + (20 < this.text.length ? this.text.substr(0, 17) + '...' : this.text) + ')]';
  };
  b.DisplayObject_cloneProps = b.cloneProps;
  b.cloneProps = function (a) {
    this.DisplayObject_cloneProps(a);
    a.textAlign = this.textAlign;
    a.textBaseline = this.textBaseline;
    a.maxWidth = this.maxWidth;
    a.outline = this.outline;
    a.lineHeight = this.lineHeight;
    a.lineWidth = this.lineWidth;
  };
  b._getWorkingContext = function () {
    var a = c._workingContext;
    a.font = this.font;
    a.textAlign = this.textAlign || 'start';
    a.textBaseline = this.textBaseline || 'alphabetic';
    return a;
  };
  b._drawText = function (a) {
    var b = !!a;
    b || (a = this._getWorkingContext());
    for (var c = String(this.text).split(/(?:\r\n|\r|\n)/), d = this.lineHeight || this.getMeasuredLineHeight(), e = 0, f = 0, h = c.length; f < h; f++) {
      var k = a.measureText(c[f]).width;
      if (null == this.lineWidth || k < this.lineWidth)
        b && this._drawTextLine(a, c[f], e * d);
      else {
        for (var k = c[f].split(/(\s)/), j = k[0], l = 1, n = k.length; l < n; l += 2)
          a.measureText(j + k[l] + k[l + 1]).width > this.lineWidth ? (b && this._drawTextLine(a, j, e * d), e++, j = k[l + 1]) : j += k[l] + k[l + 1];
        b && this._drawTextLine(a, j, e * d);
      }
      e++;
    }
    return e;
  };
  b._drawTextLine = function (a, b, c) {
    this.outline ? a.strokeText(b, 0, c, this.maxWidth || 65535) : a.fillText(b, 0, c, this.maxWidth || 65535);
  };
  createjs.Text = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function () {
    throw 'SpriteSheetUtils cannot be instantiated';
  };
  c._workingCanvas = createjs.createCanvas ? createjs.createCanvas() : document.createElement('canvas');
  c._workingContext = c._workingCanvas.getContext('2d');
  c.addFlippedFrames = function (b, a, m, g) {
    if (a || m || g) {
      var d = 0;
      a && c._flip(b, ++d, !0, !1);
      m && c._flip(b, ++d, !1, !0);
      g && c._flip(b, ++d, !0, !0);
    }
  };
  c.extractFrame = function (b, a) {
    isNaN(a) && (a = b.getAnimation(a).frames[0]);
    var m = b.getFrame(a);
    if (!m)
      return null;
    var g = m.rect, d = c._workingCanvas;
    d.width = g.width;
    d.height = g.height;
    c._workingContext.drawImage(m.image, g.x, g.y, g.width, g.height, 0, 0, g.width, g.height);
    m = new Image();
    m.src = d.toDataURL('image/png');
    return m;
  };
  c.mergeAlpha = function (b, a, c) {
    c || (c = createjs.createCanvas ? createjs.createCanvas() : document.createElement('canvas'));
    c.width = Math.max(a.width, b.width);
    c.height = Math.max(a.height, b.height);
    var g = c.getContext('2d');
    g.save();
    g.drawImage(b, 0, 0);
    g.globalCompositeOperation = 'destination-in';
    g.drawImage(a, 0, 0);
    g.restore();
    return c;
  };
  c._flip = function (b, a, m, g) {
    for (var d = b._images, e = c._workingCanvas, f = c._workingContext, h = d.length / a, k = 0; k < h; k++) {
      var j = d[k];
      j.__tmp = k;
      f.setTransform(1, 0, 0, 1, 0, 0);
      f.clearRect(0, 0, e.width + 1, e.height + 1);
      e.width = j.width;
      e.height = j.height;
      f.setTransform(m ? -1 : 1, 0, 0, g ? -1 : 1, m ? j.width : 0, g ? j.height : 0);
      f.drawImage(j, 0, 0);
      var l = new Image();
      l.src = e.toDataURL('image/png');
      l.width = j.width;
      l.height = j.height;
      d.push(l);
    }
    f = b._frames;
    e = f.length / a;
    for (k = 0; k < e; k++) {
      var j = f[k], n = j.rect.clone(), l = d[j.image.__tmp + h * a], q = {
          image: l,
          rect: n,
          regX: j.regX,
          regY: j.regY
        };
      m && (n.x = l.width - n.x - n.width, q.regX = n.width - j.regX);
      g && (n.y = l.height - n.y - n.height, q.regY = n.height - j.regY);
      f.push(q);
    }
    m = '_' + (m ? 'h' : '') + (g ? 'v' : '');
    g = b._animations;
    b = b._data;
    d = g.length / a;
    for (k = 0; k < d; k++) {
      f = g[k];
      j = b[f];
      h = {
        name: f + m,
        frequency: j.frequency,
        next: j.next,
        frames: []
      };
      j.next && (h.next += m);
      f = j.frames;
      j = 0;
      for (l = f.length; j < l; j++)
        h.frames.push(f[j] + e * a);
      b[h.name] = h;
      g.push(h.name);
    }
  };
  createjs.SpriteSheetUtils = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function () {
      this.initialize();
    }, b = c.prototype;
  c.ERR_DIMENSIONS = 'frame dimensions exceed max spritesheet dimensions';
  c.ERR_RUNNING = 'a build is already running';
  b.maxWidth = 2048;
  b.maxHeight = 2048;
  b.spriteSheet = null;
  b.scale = 1;
  b.padding = 1;
  b.timeSlice = 0.3;
  b.progress = -1;
  b.onComplete = null;
  b.onProgress = null;
  b.addEventListener = null;
  b.removeEventListener = null;
  b.removeAllEventListeners = null;
  b.dispatchEvent = null;
  b.hasEventListener = null;
  b._listeners = null;
  createjs.EventDispatcher.initialize(b);
  b._frames = null;
  b._animations = null;
  b._data = null;
  b._nextFrameIndex = 0;
  b._index = 0;
  b._timerID = null;
  b._scale = 1;
  b.initialize = function () {
    this._frames = [];
    this._animations = {};
  };
  b.addFrame = function (a, b, g, d, e, f) {
    if (this._data)
      throw c.ERR_RUNNING;
    b = b || a.bounds || a.nominalBounds;
    !b && a.getBounds && (b = a.getBounds());
    if (!b)
      return null;
    g = g || 1;
    return this._frames.push({
      source: a,
      sourceRect: b,
      scale: g,
      funct: d,
      params: e,
      scope: f,
      index: this._frames.length,
      height: b.height * g
    }) - 1;
  };
  b.addAnimation = function (a, b, g, d) {
    if (this._data)
      throw c.ERR_RUNNING;
    this._animations[a] = {
      frames: b,
      next: g,
      frequency: d
    };
  };
  b.addMovieClip = function (a, b, g) {
    if (this._data)
      throw c.ERR_RUNNING;
    var d = a.frameBounds, e = b || a.bounds || a.nominalBounds;
    !e && a.getBounds && (e = a.getBounds());
    if (!e && !d)
      return null;
    b = this._frames.length;
    for (var f = a.timeline.duration, h = 0; h < f; h++)
      this.addFrame(a, d && d[h] ? d[h] : e, g, function (a) {
        var b = this.actionsEnabled;
        this.actionsEnabled = !1;
        this.gotoAndStop(a);
        this.actionsEnabled = b;
      }, [h], a);
    h = a.timeline._labels;
    a = [];
    for (var k in h)
      a.push({
        index: h[k],
        label: k
      });
    if (a.length) {
      a.sort(function (a, b) {
        return a.index - b.index;
      });
      h = 0;
      for (k = a.length; h < k; h++) {
        g = a[h].label;
        for (var d = b + (h == k - 1 ? f : a[h + 1].index), e = [], j = b + a[h].index; j < d; j++)
          e.push(j);
        this.addAnimation(g, e, !0);
      }
    }
  };
  b.build = function () {
    if (this._data)
      throw c.ERR_RUNNING;
    for (this._startBuild(); this._drawNext(););
    this._endBuild();
    return this.spriteSheet;
  };
  b.buildAsync = function (a) {
    if (this._data)
      throw c.ERR_RUNNING;
    this.timeSlice = a;
    this._startBuild();
    var b = this;
    this._timerID = setTimeout(function () {
      b._run();
    }, 50 - 50 * Math.max(0.01, Math.min(0.99, this.timeSlice || 0.3)));
  };
  b.stopAsync = function () {
    clearTimeout(this._timerID);
    this._data = null;
  };
  b.clone = function () {
    throw 'SpriteSheetBuilder cannot be cloned.';
  };
  b.toString = function () {
    return '[SpriteSheetBuilder]';
  };
  b._startBuild = function () {
    var a = this.padding || 0;
    this.progress = 0;
    this.spriteSheet = null;
    this._index = 0;
    this._scale = this.scale;
    var b = [];
    this._data = {
      images: [],
      frames: b,
      animations: this._animations
    };
    var g = this._frames.slice();
    g.sort(function (a, b) {
      return a.height <= b.height ? -1 : 1;
    });
    if (g[g.length - 1].height + 2 * a > this.maxHeight)
      throw c.ERR_DIMENSIONS;
    for (var d = 0, e = 0, f = 0; g.length;) {
      var h = this._fillRow(g, d, f, b, a);
      h.w > e && (e = h.w);
      d += h.h;
      if (!h.h || !g.length) {
        var k = createjs.createCanvas ? createjs.createCanvas() : document.createElement('canvas');
        k.width = this._getSize(e, this.maxWidth);
        k.height = this._getSize(d, this.maxHeight);
        this._data.images[f] = k;
        h.h || (e = d = 0, f++);
      }
    }
  };
  b._getSize = function (a, b) {
    for (var c = 4; Math.pow(2, ++c) < a;);
    return Math.min(b, Math.pow(2, c));
  };
  b._fillRow = function (a, b, g, d, e) {
    var f = this.maxWidth, h = this.maxHeight;
    b += e;
    for (var h = h - b, k = e, j = 0, l = a.length - 1; 0 <= l; l--) {
      var n = a[l], q = this._scale * n.scale, p = n.sourceRect, s = n.source, r = Math.floor(q * p.x - e), u = Math.floor(q * p.y - e), t = Math.ceil(q * p.height + 2 * e), p = Math.ceil(q * p.width + 2 * e);
      if (p > f)
        throw c.ERR_DIMENSIONS;
      t > h || k + p > f || (n.img = g, n.rect = new createjs.Rectangle(k, b, p, t), j = j || t, a.splice(l, 1), d[n.index] = [
        k,
        b,
        p,
        t,
        g,
        Math.round(-r + q * s.regX - e),
        Math.round(-u + q * s.regY - e)
      ], k += p);
    }
    return {
      w: k,
      h: j
    };
  };
  b._endBuild = function () {
    this.spriteSheet = new createjs.SpriteSheet(this._data);
    this._data = null;
    this.progress = 1;
    this.onComplete && this.onComplete(this);
    this.dispatchEvent('complete');
  };
  b._run = function () {
    for (var a = 50 * Math.max(0.01, Math.min(0.99, this.timeSlice || 0.3)), b = new Date().getTime() + a, c = !1; b > new Date().getTime();)
      if (!this._drawNext()) {
        c = !0;
        break;
      }
    if (c)
      this._endBuild();
    else {
      var d = this;
      this._timerID = setTimeout(function () {
        d._run();
      }, 50 - a);
    }
    a = this.progress = this._index / this._frames.length;
    this.onProgress && this.onProgress(this, a);
    this.dispatchEvent({
      type: 'progress',
      progress: a
    });
  };
  b._drawNext = function () {
    var a = this._frames[this._index], b = a.scale * this._scale, c = a.rect, d = a.sourceRect, e = this._data.images[a.img].getContext('2d');
    a.funct && a.funct.apply(a.scope, a.params);
    e.save();
    e.beginPath();
    e.rect(c.x, c.y, c.width, c.height);
    e.clip();
    e.translate(Math.ceil(c.x - d.x * b), Math.ceil(c.y - d.y * b));
    e.scale(b, b);
    a.source.draw(e);
    e.restore();
    return ++this._index < this._frames.length;
  };
  createjs.SpriteSheetBuilder = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function (a) {
      this.initialize(a);
    }, b = c.prototype = new createjs.DisplayObject();
  b.htmlElement = null;
  b._oldMtx = null;
  b.DisplayObject_initialize = b.initialize;
  b.initialize = function (a) {
    'string' == typeof a && (a = document.getElementById(a));
    this.DisplayObject_initialize();
    this.mouseEnabled = !1;
    this.htmlElement = a;
    a = a.style;
    a.position = 'absolute';
    a.transformOrigin = a.WebkitTransformOrigin = a.msTransformOrigin = a.MozTransformOrigin = a.OTransformOrigin = '0% 0%';
  };
  b.isVisible = function () {
    return null != this.htmlElement;
  };
  b.draw = function () {
    if (null != this.htmlElement) {
      var a = this.getConcatenatedMatrix(this._matrix), b = this.htmlElement.style;
      if (this.visible)
        b.visibility = 'visible';
      else
        return !0;
      var c = this._oldMtx || {};
      c.alpha != a.alpha && (b.opacity = '' + a.alpha, c.alpha = a.alpha);
      if (c.tx != a.tx || c.ty != a.ty || c.a != a.a || c.b != a.b || c.c != a.c || c.d != a.d)
        b.transform = b.WebkitTransform = b.OTransform = b.msTransform = [
          'matrix(' + a.a,
          a.b,
          a.c,
          a.d,
          a.tx + 0.5 | 0,
          (a.ty + 0.5 | 0) + ')'
        ].join(), b.MozTransform = [
          'matrix(' + a.a,
          a.b,
          a.c,
          a.d,
          (a.tx + 0.5 | 0) + 'px',
          (a.ty + 0.5 | 0) + 'px)'
        ].join(), this._oldMtx = a.clone();
      return !0;
    }
  };
  b.cache = function () {
  };
  b.uncache = function () {
  };
  b.updateCache = function () {
  };
  b.hitTest = function () {
  };
  b.localToGlobal = function () {
  };
  b.globalToLocal = function () {
  };
  b.localToLocal = function () {
  };
  b.clone = function () {
    throw 'DOMElement cannot be cloned.';
  };
  b.toString = function () {
    return '[DOMElement (name=' + this.name + ')]';
  };
  b.DisplayObject__tick = b._tick;
  b._tick = function (a) {
    this.htmlElement.style.visibility = 'hidden';
    this.DisplayObject__tick(a);
  };
  createjs.DOMElement = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function () {
      this.initialize();
    }, b = c.prototype;
  b.initialize = function () {
  };
  b.getBounds = function () {
    return new createjs.Rectangle(0, 0, 0, 0);
  };
  b.applyFilter = function () {
  };
  b.toString = function () {
    return '[Filter]';
  };
  b.clone = function () {
    return new c();
  };
  createjs.Filter = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function () {
    throw 'Touch cannot be instantiated';
  };
  c.isSupported = function () {
    return 'ontouchstart' in window || window.navigator.msPointerEnabled;
  };
  c.enable = function (b, a, m) {
    if (!b || !b.canvas || !c.isSupported())
      return !1;
    b.__touch = {
      pointers: {},
      multitouch: !a,
      preventDefault: !m,
      count: 0
    };
    'ontouchstart' in window ? c._IOS_enable(b) : window.navigator.msPointerEnabled && c._IE_enable(b);
    return !0;
  };
  c.disable = function (b) {
    b && ('ontouchstart' in window ? c._IOS_disable(b) : window.navigator.msPointerEnabled && c._IE_disable(b));
  };
  c._IOS_enable = function (b) {
    var a = b.canvas, m = b.__touch.f = function (a) {
        c._IOS_handleEvent(b, a);
      };
    a.addEventListener('touchstart', m, !1);
    a.addEventListener('touchmove', m, !1);
    a.addEventListener('touchend', m, !1);
    a.addEventListener('touchcancel', m, !1);
  };
  c._IOS_disable = function (b) {
    var a = b.canvas;
    a && (b = b.__touch.f, a.removeEventListener('touchstart', b, !1), a.removeEventListener('touchmove', b, !1), a.removeEventListener('touchend', b, !1), a.removeEventListener('touchcancel', b, !1));
  };
  c._IOS_handleEvent = function (b, a) {
    if (b) {
      b.__touch.preventDefault && a.preventDefault && a.preventDefault();
      for (var c = a.changedTouches, g = a.type, d = 0, e = c.length; d < e; d++) {
        var f = c[d], h = f.identifier;
        f.target == b.canvas && ('touchstart' == g ? this._handleStart(b, h, a, f.pageX, f.pageY) : 'touchmove' == g ? this._handleMove(b, h, a, f.pageX, f.pageY) : ('touchend' == g || 'touchcancel' == g) && this._handleEnd(b, h, a));
      }
    }
  };
  c._IE_enable = function (b) {
    var a = b.canvas, m = b.__touch.f = function (a) {
        c._IE_handleEvent(b, a);
      };
    a.addEventListener('MSPointerDown', m, !1);
    window.addEventListener('MSPointerMove', m, !1);
    window.addEventListener('MSPointerUp', m, !1);
    window.addEventListener('MSPointerCancel', m, !1);
    b.__touch.preventDefault && (a.style.msTouchAction = 'none');
    b.__touch.activeIDs = {};
  };
  c._IE_disable = function (b) {
    var a = b.__touch.f;
    window.removeEventListener('MSPointerMove', a, !1);
    window.removeEventListener('MSPointerUp', a, !1);
    window.removeEventListener('MSPointerCancel', a, !1);
    b.canvas && b.canvas.removeEventListener('MSPointerDown', a, !1);
  };
  c._IE_handleEvent = function (b, a) {
    if (b) {
      b.__touch.preventDefault && a.preventDefault && a.preventDefault();
      var c = a.type, g = a.pointerId, d = b.__touch.activeIDs;
      if ('MSPointerDown' == c)
        a.srcElement == b.canvas && (d[g] = !0, this._handleStart(b, g, a, a.pageX, a.pageY));
      else if (d[g])
        if ('MSPointerMove' == c)
          this._handleMove(b, g, a, a.pageX, a.pageY);
        else if ('MSPointerUp' == c || 'MSPointerCancel' == c)
          delete d[g], this._handleEnd(b, g, a);
    }
  };
  c._handleStart = function (b, a, c, g, d) {
    var e = b.__touch;
    if (e.multitouch || !e.count) {
      var f = e.pointers;
      f[a] || (f[a] = !0, e.count++, b._handlePointerDown(a, c, g, d));
    }
  };
  c._handleMove = function (b, a, c, g, d) {
    b.__touch.pointers[a] && b._handlePointerMove(a, c, g, d);
  };
  c._handleEnd = function (b, a, c) {
    var g = b.__touch, d = g.pointers;
    d[a] && (g.count--, b._handlePointerUp(a, c, !0), delete d[a]);
  };
  createjs.Touch = c;
}());
(function () {
  var c = this.createjs = this.createjs || {}, c = c.EaselJS = c.EaselJS || {};
  c.version = '0.6.1';
  c.buildDate = 'Tue, 14 May 2013 21:43:02 GMT';
}());
this.createjs = this.createjs || {};
(function () {
  var b = function () {
      this.initialize();
    }, a = b.prototype;
  b.initialize = function (d) {
    d.addEventListener = a.addEventListener;
    d.removeEventListener = a.removeEventListener;
    d.removeAllEventListeners = a.removeAllEventListeners;
    d.hasEventListener = a.hasEventListener;
    d.dispatchEvent = a.dispatchEvent;
  };
  a._listeners = null;
  a.initialize = function () {
  };
  a.addEventListener = function (d, a) {
    var c = this._listeners;
    c ? this.removeEventListener(d, a) : c = this._listeners = {};
    var b = c[d];
    b || (b = c[d] = []);
    b.push(a);
    return a;
  };
  a.removeEventListener = function (d, a) {
    var c = this._listeners;
    if (c) {
      var b = c[d];
      if (b)
        for (var f = 0, g = b.length; f < g; f++)
          if (b[f] == a) {
            1 == g ? delete c[d] : b.splice(f, 1);
            break;
          }
    }
  };
  a.removeAllEventListeners = function (d) {
    d ? this._listeners && delete this._listeners[d] : this._listeners = null;
  };
  a.dispatchEvent = function (d, a) {
    var c = !1, b = this._listeners;
    if (d && b) {
      'string' == typeof d && (d = { type: d });
      b = b[d.type];
      if (!b)
        return c;
      d.target = a || this;
      for (var b = b.slice(), f = 0, g = b.length; f < g; f++)
        var j = b[f], c = j.handleEvent ? c || j.handleEvent(d) : c || j(d);
    }
    return !!c;
  };
  a.hasEventListener = function (d) {
    var a = this._listeners;
    return !(!a || !a[d]);
  };
  a.toString = function () {
    return '[EventDispatcher]';
  };
  createjs.EventDispatcher = b;
}());
this.createjs = this.createjs || {};
(function () {
  var b = function (d, a, c) {
      this.initialize(d, a, c);
    }, a = b.prototype;
  b.NONE = 0;
  b.LOOP = 1;
  b.REVERSE = 2;
  b.IGNORE = {};
  b._tweens = [];
  b._plugins = {};
  b.get = function (d, a, c, e) {
    e && b.removeTweens(d);
    return new b(d, a, c);
  };
  b.tick = function (d, a) {
    for (var c = b._tweens.slice(), e = c.length - 1; 0 <= e; e--) {
      var f = c[e];
      a && !f.ignoreGlobalPause || f._paused || f.tick(f._useTicks ? 1 : d);
    }
  };
  createjs.Ticker && createjs.Ticker.addListener(b, !1);
  b.removeTweens = function (d) {
    if (d.tweenjs_count) {
      for (var a = b._tweens, c = a.length - 1; 0 <= c; c--)
        a[c]._target == d && (a[c]._paused = !0, a.splice(c, 1));
      d.tweenjs_count = 0;
    }
  };
  b.removeAllTweens = function () {
    for (var d = b._tweens, a = 0, c = d.length; a < c; a++) {
      var e = d[a];
      e.paused = !0;
      e.target.tweenjs_count = 0;
    }
    d.length = 0;
  };
  b.hasActiveTweens = function (d) {
    return d ? d.tweenjs_count : b._tweens && b._tweens.length;
  };
  b.installPlugin = function (d, a) {
    var c = d.priority;
    null == c && (d.priority = c = 0);
    for (var e = 0, f = a.length, g = b._plugins; e < f; e++) {
      var j = a[e];
      if (g[j]) {
        for (var l = g[j], k = 0, p = l.length; k < p && !(c < l[k].priority); k++);
        g[j].splice(k, 0, d);
      } else
        g[j] = [d];
    }
  };
  b._register = function (d, a) {
    var c = d._target;
    a ? (c && (c.tweenjs_count = c.tweenjs_count ? c.tweenjs_count + 1 : 1), b._tweens.push(d)) : (c && c.tweenjs_count--, c = b._tweens.indexOf(d), -1 != c && b._tweens.splice(c, 1));
  };
  a.addEventListener = null;
  a.removeEventListener = null;
  a.removeAllEventListeners = null;
  a.dispatchEvent = null;
  a.hasEventListener = null;
  a._listeners = null;
  createjs.EventDispatcher.initialize(a);
  a.ignoreGlobalPause = !1;
  a.loop = !1;
  a.duration = 0;
  a.pluginData = null;
  a.onChange = null;
  a.change = null;
  a.target = null;
  a.position = null;
  a._paused = !1;
  a._curQueueProps = null;
  a._initQueueProps = null;
  a._steps = null;
  a._actions = null;
  a._prevPosition = 0;
  a._stepPosition = 0;
  a._prevPos = -1;
  a._target = null;
  a._useTicks = !1;
  a.initialize = function (d, a, c) {
    this.target = this._target = d;
    a && (this._useTicks = a.useTicks, this.ignoreGlobalPause = a.ignoreGlobalPause, this.loop = a.loop, this.onChange = a.onChange, a.override && b.removeTweens(d));
    this.pluginData = c || {};
    this._curQueueProps = {};
    this._initQueueProps = {};
    this._steps = [];
    this._actions = [];
    a && a.paused ? this._paused = !0 : b._register(this, !0);
    a && null != a.position && this.setPosition(a.position, b.NONE);
  };
  a.wait = function (a) {
    if (null == a || 0 >= a)
      return this;
    var b = this._cloneProps(this._curQueueProps);
    return this._addStep({
      d: a,
      p0: b,
      e: this._linearEase,
      p1: b
    });
  };
  a.to = function (a, b, c) {
    if (isNaN(b) || 0 > b)
      b = 0;
    return this._addStep({
      d: b || 0,
      p0: this._cloneProps(this._curQueueProps),
      e: c,
      p1: this._cloneProps(this._appendQueueProps(a))
    });
  };
  a.call = function (a, b, c) {
    return this._addAction({
      f: a,
      p: b ? b : [this],
      o: c ? c : this._target
    });
  };
  a.set = function (a, b) {
    return this._addAction({
      f: this._set,
      o: this,
      p: [
        a,
        b ? b : this._target
      ]
    });
  };
  a.play = function (a) {
    return this.call(a.setPaused, [!1], a);
  };
  a.pause = function (a) {
    a || (a = this);
    return this.call(a.setPaused, [!0], a);
  };
  a.setPosition = function (a, b) {
    0 > a && (a = 0);
    null == b && (b = 1);
    var c = a, e = !1;
    c >= this.duration && (this.loop ? c %= this.duration : (c = this.duration, e = !0));
    if (c == this._prevPos)
      return e;
    var f = this._prevPos;
    this.position = this._prevPos = c;
    this._prevPosition = a;
    if (this._target)
      if (e)
        this._updateTargetProps(null, 1);
      else if (0 < this._steps.length) {
        for (var g = 0, j = this._steps.length; g < j && !(this._steps[g].t > c); g++);
        g = this._steps[g - 1];
        this._updateTargetProps(g, (this._stepPosition = c - g.t) / g.d);
      }
    0 != b && 0 < this._actions.length && (this._useTicks ? this._runActions(c, c) : 1 == b && c < f ? (f != this.duration && this._runActions(f, this.duration), this._runActions(0, c, !0)) : this._runActions(f, c));
    e && this.setPaused(!0);
    this.onChange && this.onChange(this);
    this.dispatchEvent('change');
    return e;
  };
  a.tick = function (a) {
    this._paused || this.setPosition(this._prevPosition + a);
  };
  a.setPaused = function (a) {
    this._paused = !!a;
    b._register(this, !a);
    return this;
  };
  a.w = a.wait;
  a.t = a.to;
  a.c = a.call;
  a.s = a.set;
  a.toString = function () {
    return '[Tween]';
  };
  a.clone = function () {
    throw 'Tween can not be cloned.';
  };
  a._updateTargetProps = function (a, h) {
    var c, e, f, g;
    !a && 1 == h ? c = e = this._curQueueProps : (a.e && (h = a.e(h, 0, 1, 1)), c = a.p0, e = a.p1);
    for (n in this._initQueueProps) {
      if (null == (f = c[n]))
        c[n] = f = this._initQueueProps[n];
      if (null == (g = e[n]))
        e[n] = g = f;
      f = f == g || 0 == h || 1 == h || 'number' != typeof f ? 1 == h ? g : f : f + (g - f) * h;
      var j = !1;
      if (g = b._plugins[n])
        for (var l = 0, k = g.length; l < k; l++) {
          var p = g[l].tween(this, n, f, c, e, h, !!a && c == e, !a);
          p == b.IGNORE ? j = !0 : f = p;
        }
      j || (this._target[n] = f);
    }
  };
  a._runActions = function (a, b, c) {
    var e = a, f = b, g = -1, j = this._actions.length, l = 1;
    a > b && (e = b, f = a, g = j, j = l = -1);
    for (; (g += l) != j;) {
      b = this._actions[g];
      var k = b.t;
      (k == f || k > e && k < f || c && k == a) && b.f.apply(b.o, b.p);
    }
  };
  a._appendQueueProps = function (a) {
    var h, c, e, f, g, j;
    for (j in a) {
      if (void 0 === this._initQueueProps[j]) {
        c = this._target[j];
        if (h = b._plugins[j]) {
          e = 0;
          for (f = h.length; e < f; e++)
            c = h[e].init(this, j, c);
        }
        this._initQueueProps[j] = void 0 === c ? null : c;
      } else
        c = this._curQueueProps[j];
      if (h = b._plugins[j]) {
        g = g || {};
        e = 0;
        for (f = h.length; e < f; e++)
          h[e].step && h[e].step(this, j, c, a[j], g);
      }
      this._curQueueProps[j] = a[j];
    }
    g && this._appendQueueProps(g);
    return this._curQueueProps;
  };
  a._cloneProps = function (a) {
    var b = {}, c;
    for (c in a)
      b[c] = a[c];
    return b;
  };
  a._addStep = function (a) {
    0 < a.d && (this._steps.push(a), a.t = this.duration, this.duration += a.d);
    return this;
  };
  a._addAction = function (a) {
    a.t = this.duration;
    this._actions.push(a);
    return this;
  };
  a._set = function (a, b) {
    for (var c in a)
      b[c] = a[c];
  };
  createjs.Tween = b;
}());
this.createjs = this.createjs || {};
(function () {
  var b = function (a, b, c) {
      this.initialize(a, b, c);
    }, a = b.prototype;
  a.ignoreGlobalPause = !1;
  a.duration = 0;
  a.loop = !1;
  a.onChange = null;
  a.position = null;
  a._paused = !1;
  a._tweens = null;
  a._labels = null;
  a._prevPosition = 0;
  a._prevPos = -1;
  a._useTicks = !1;
  a.initialize = function (a, b, c) {
    this._tweens = [];
    c && (this._useTicks = c.useTicks, this.loop = c.loop, this.ignoreGlobalPause = c.ignoreGlobalPause, this.onChange = c.onChange);
    a && this.addTween.apply(this, a);
    this.setLabels(b);
    c && c.paused ? this._paused = !0 : createjs.Tween._register(this, !0);
    c && null != c.position && this.setPosition(c.position, createjs.Tween.NONE);
  };
  a.addTween = function (a) {
    var b = arguments.length;
    if (1 < b) {
      for (var c = 0; c < b; c++)
        this.addTween(arguments[c]);
      return arguments[0];
    }
    if (0 == b)
      return null;
    this.removeTween(a);
    this._tweens.push(a);
    a.setPaused(!0);
    a._paused = !1;
    a._useTicks = this._useTicks;
    a.duration > this.duration && (this.duration = a.duration);
    0 <= this._prevPos && a.setPosition(this._prevPos, createjs.Tween.NONE);
    return a;
  };
  a.removeTween = function (a) {
    var b = arguments.length;
    if (1 < b) {
      for (var c = !0, e = 0; e < b; e++)
        c = c && this.removeTween(arguments[e]);
      return c;
    }
    if (0 == b)
      return !1;
    b = this._tweens.indexOf(a);
    return -1 != b ? (this._tweens.splice(b, 1), a.duration >= this.duration && this.updateDuration(), !0) : !1;
  };
  a.addLabel = function (a, b) {
    this._labels[a] = b;
  };
  a.setLabels = function (a) {
    this._labels = a ? a : {};
  };
  a.gotoAndPlay = function (a) {
    this.setPaused(!1);
    this._goto(a);
  };
  a.gotoAndStop = function (a) {
    this.setPaused(!0);
    this._goto(a);
  };
  a.setPosition = function (a, b) {
    0 > a && (a = 0);
    var c = this.loop ? a % this.duration : a, e = !this.loop && a >= this.duration;
    if (c == this._prevPos)
      return e;
    this._prevPosition = a;
    this.position = this._prevPos = c;
    for (var f = 0, g = this._tweens.length; f < g; f++)
      if (this._tweens[f].setPosition(c, b), c != this._prevPos)
        return !1;
    e && this.setPaused(!0);
    this.onChange && this.onChange(this);
    return e;
  };
  a.setPaused = function (a) {
    this._paused = !!a;
    createjs.Tween._register(this, !a);
  };
  a.updateDuration = function () {
    for (var a = this.duration = 0, b = this._tweens.length; a < b; a++) {
      var c = this._tweens[a];
      c.duration > this.duration && (this.duration = c.duration);
    }
  };
  a.tick = function (a) {
    this.setPosition(this._prevPosition + a);
  };
  a.resolve = function (a) {
    var b = parseFloat(a);
    isNaN(b) && (b = this._labels[a]);
    return b;
  };
  a.toString = function () {
    return '[Timeline]';
  };
  a.clone = function () {
    throw 'Timeline can not be cloned.';
  };
  a._goto = function (a) {
    a = this.resolve(a);
    null != a && this.setPosition(a);
  };
  createjs.Timeline = b;
}());
this.createjs = this.createjs || {};
(function () {
  var b = function () {
    throw 'Ease cannot be instantiated.';
  };
  b.linear = function (a) {
    return a;
  };
  b.none = b.linear;
  b.get = function (a) {
    -1 > a && (a = -1);
    1 < a && (a = 1);
    return function (b) {
      return 0 == a ? b : 0 > a ? b * (b * -a + 1 + a) : b * ((2 - b) * a + (1 - a));
    };
  };
  b.getPowIn = function (a) {
    return function (b) {
      return Math.pow(b, a);
    };
  };
  b.getPowOut = function (a) {
    return function (b) {
      return 1 - Math.pow(1 - b, a);
    };
  };
  b.getPowInOut = function (a) {
    return function (b) {
      return 1 > (b *= 2) ? 0.5 * Math.pow(b, a) : 1 - 0.5 * Math.abs(Math.pow(2 - b, a));
    };
  };
  b.quadIn = b.getPowIn(2);
  b.quadOut = b.getPowOut(2);
  b.quadInOut = b.getPowInOut(2);
  b.cubicIn = b.getPowIn(3);
  b.cubicOut = b.getPowOut(3);
  b.cubicInOut = b.getPowInOut(3);
  b.quartIn = b.getPowIn(4);
  b.quartOut = b.getPowOut(4);
  b.quartInOut = b.getPowInOut(4);
  b.quintIn = b.getPowIn(5);
  b.quintOut = b.getPowOut(5);
  b.quintInOut = b.getPowInOut(5);
  b.sineIn = function (a) {
    return 1 - Math.cos(a * Math.PI / 2);
  };
  b.sineOut = function (a) {
    return Math.sin(a * Math.PI / 2);
  };
  b.sineInOut = function (a) {
    return -0.5 * (Math.cos(Math.PI * a) - 1);
  };
  b.getBackIn = function (a) {
    return function (b) {
      return b * b * ((a + 1) * b - a);
    };
  };
  b.backIn = b.getBackIn(1.7);
  b.getBackOut = function (a) {
    return function (b) {
      return --b * b * ((a + 1) * b + a) + 1;
    };
  };
  b.backOut = b.getBackOut(1.7);
  b.getBackInOut = function (a) {
    a *= 1.525;
    return function (b) {
      return 1 > (b *= 2) ? 0.5 * b * b * ((a + 1) * b - a) : 0.5 * ((b -= 2) * b * ((a + 1) * b + a) + 2);
    };
  };
  b.backInOut = b.getBackInOut(1.7);
  b.circIn = function (a) {
    return -(Math.sqrt(1 - a * a) - 1);
  };
  b.circOut = function (a) {
    return Math.sqrt(1 - --a * a);
  };
  b.circInOut = function (a) {
    return 1 > (a *= 2) ? -0.5 * (Math.sqrt(1 - a * a) - 1) : 0.5 * (Math.sqrt(1 - (a -= 2) * a) + 1);
  };
  b.bounceIn = function (a) {
    return 1 - b.bounceOut(1 - a);
  };
  b.bounceOut = function (a) {
    return a < 1 / 2.75 ? 7.5625 * a * a : a < 2 / 2.75 ? 7.5625 * (a -= 1.5 / 2.75) * a + 0.75 : a < 2.5 / 2.75 ? 7.5625 * (a -= 2.25 / 2.75) * a + 0.9375 : 7.5625 * (a -= 2.625 / 2.75) * a + 0.984375;
  };
  b.bounceInOut = function (a) {
    return 0.5 > a ? 0.5 * b.bounceIn(2 * a) : 0.5 * b.bounceOut(2 * a - 1) + 0.5;
  };
  b.getElasticIn = function (a, b) {
    var h = 2 * Math.PI;
    return function (c) {
      if (0 == c || 1 == c)
        return c;
      var e = b / h * Math.asin(1 / a);
      return -(a * Math.pow(2, 10 * (c -= 1)) * Math.sin((c - e) * h / b));
    };
  };
  b.elasticIn = b.getElasticIn(1, 0.3);
  b.getElasticOut = function (a, b) {
    var h = 2 * Math.PI;
    return function (c) {
      if (0 == c || 1 == c)
        return c;
      var e = b / h * Math.asin(1 / a);
      return a * Math.pow(2, -10 * c) * Math.sin((c - e) * h / b) + 1;
    };
  };
  b.elasticOut = b.getElasticOut(1, 0.3);
  b.getElasticInOut = function (a, b) {
    var h = 2 * Math.PI;
    return function (c) {
      var e = b / h * Math.asin(1 / a);
      return 1 > (c *= 2) ? -0.5 * a * Math.pow(2, 10 * (c -= 1)) * Math.sin((c - e) * h / b) : 0.5 * a * Math.pow(2, -10 * (c -= 1)) * Math.sin((c - e) * h / b) + 1;
    };
  };
  b.elasticInOut = b.getElasticInOut(1, 0.3 * 1.5);
  createjs.Ease = b;
}());
this.createjs = this.createjs || {};
(function () {
  var b = function () {
    throw 'MotionGuidePlugin cannot be instantiated.';
  };
  b.priority = 0;
  b.install = function () {
    createjs.Tween.installPlugin(b, [
      'guide',
      'x',
      'y',
      'rotation'
    ]);
    return createjs.Tween.IGNORE;
  };
  b.init = function (a, b, h) {
    a = a.target;
    a.hasOwnProperty('x') || (a.x = 0);
    a.hasOwnProperty('y') || (a.y = 0);
    a.hasOwnProperty('rotation') || (a.rotation = 0);
    return 'guide' == b ? null : h;
  };
  b.step = function (a, d, h, c, e) {
    if ('guide' != d)
      return c;
    var f;
    c.hasOwnProperty('path') || (c.path = []);
    a = c.path;
    c.hasOwnProperty('end') || (c.end = 1);
    c.hasOwnProperty('start') || (c.start = h && h.hasOwnProperty('end') && h.path === a ? h.end : 0);
    if (c.hasOwnProperty('_segments') && c._length)
      return c;
    h = a.length;
    if (6 <= h && 0 == (h - 2) % 4) {
      c._segments = [];
      c._length = 0;
      for (d = 2; d < h; d += 4) {
        for (var g = a[d - 2], j = a[d - 1], l = a[d + 0], k = a[d + 1], p = a[d + 2], x = a[d + 3], v = g, w = j, s, m, r = 0, t = [], u = 1; 10 >= u; u++) {
          m = u / 10;
          var q = 1 - m;
          s = q * q * g + 2 * q * m * l + m * m * p;
          m = q * q * j + 2 * q * m * k + m * m * x;
          r += t[t.push(Math.sqrt((f = s - v) * f + (f = m - w) * f)) - 1];
          v = s;
          w = m;
        }
        c._segments.push(r);
        c._segments.push(t);
        c._length += r;
      }
    } else
      throw 'invalid \'path\' data, please see documentation for valid paths';
    f = c.orient;
    c.orient = !1;
    b.calc(c, c.end, e);
    c.orient = f;
    return c;
  };
  b.tween = function (a, d, h, c, e, f, g) {
    e = e.guide;
    if (void 0 == e || e === c.guide)
      return h;
    e.lastRatio != f && (b.calc(e, (e.end - e.start) * (g ? e.end : f) + e.start, a.target), e.orient && (a.target.rotation += c.rotation || 0), e.lastRatio = f);
    return !e.orient && 'rotation' == d ? h : a.target[d];
  };
  b.calc = function (a, d, h) {
    void 0 == a._segments && b.validate(a);
    void 0 == h && (h = {
      x: 0,
      y: 0,
      rotation: 0
    });
    var c = a._segments, e = a.path, f = a._length * d, g = c.length - 2;
    for (d = 0; f > c[d] && d < g;)
      f -= c[d], d += 2;
    for (var c = c[d + 1], j = 0, g = c.length - 1; f > c[j] && j < g;)
      f -= c[j], j++;
    f = j / ++g + f / (g * c[j]);
    d = 2 * d + 2;
    g = 1 - f;
    h.x = g * g * e[d - 2] + 2 * g * f * e[d + 0] + f * f * e[d + 2];
    h.y = g * g * e[d - 1] + 2 * g * f * e[d + 1] + f * f * e[d + 3];
    a.orient && (h.rotation = 57.2957795 * Math.atan2((e[d + 1] - e[d - 1]) * g + (e[d + 3] - e[d + 1]) * f, (e[d + 0] - e[d - 2]) * g + (e[d + 2] - e[d + 0]) * f));
    return h;
  };
  createjs.MotionGuidePlugin = b;
}());
(function () {
  var b = this.createjs = this.createjs || {}, b = b.TweenJS = b.TweenJS || {};
  b.version = '0.4.0';
  b.buildDate = 'Tue, 12 Feb 2013 21:08:16 GMT';
}());
this.createjs = this.createjs || {};
(function () {
  var d = function (b, a, c, f) {
      this.initialize(b, a, c, f);
    }, a = d.prototype = new createjs.Container();
  d.INDEPENDENT = 'independent';
  d.SINGLE_FRAME = 'single';
  d.SYNCHED = 'synched';
  a.startPosition = 0;
  a.loop = !0;
  a.currentFrame = 0;
  a.timeline = null;
  a.paused = !1;
  a.actionsEnabled = !0;
  a.autoReset = !0;
  a._synchOffset = 0;
  a._prevPos = -1;
  a._prevPosition = 0;
  a.Container_initialize = a.initialize;
  a.initialize = function (b, a, c, f) {
    this.mode = b || d.INDEPENDENT;
    this.startPosition = a || 0;
    this.loop = c;
    props = {
      paused: !0,
      position: a,
      useTicks: !0
    };
    this.Container_initialize();
    this.timeline = new createjs.Timeline(null, f, props);
    this._managed = {};
  };
  a.isVisible = function () {
    return !(!this.visible || !(0 < this.alpha && 0 != this.scaleX && 0 != this.scaleY));
  };
  a.Container_draw = a.draw;
  a.draw = function (b, a, c) {
    if (this.DisplayObject_draw(b, a))
      return !0;
    this._updateTimeline();
    this.Container_draw(b, a, c);
  };
  a.play = function () {
    this.paused = !1;
  };
  a.stop = function () {
    this.paused = !0;
  };
  a.gotoAndPlay = function (b) {
    this.paused = !1;
    this._goto(b);
  };
  a.gotoAndStop = function (b) {
    this.paused = !0;
    this._goto(b);
  };
  a.clone = function () {
    throw 'MovieClip cannot be cloned.';
  };
  a.toString = function () {
    return '[MovieClip (name=' + this.name + ')]';
  };
  a.Container__tick = a._tick;
  a._tick = function (b) {
    !this.paused && this.mode == d.INDEPENDENT && (this._prevPosition = 0 > this._prevPos ? 0 : this._prevPosition + 1);
    this.Container__tick(b);
  };
  a._goto = function (b) {
    b = this.timeline.resolve(b);
    null != b && (-1 == this._prevPos && (this._prevPos = NaN), this._prevPosition = b, this._updateTimeline());
  };
  a._reset = function () {
    this._prevPos = -1;
    this.currentFrame = 0;
  };
  a._updateTimeline = function () {
    var b = this.timeline, a = b._tweens, c = this.children, f = this.mode != d.INDEPENDENT;
    b.loop = null == this.loop ? !0 : this.loop;
    f ? b.setPosition(this.startPosition + (this.mode == d.SINGLE_FRAME ? 0 : this._synchOffset), createjs.Tween.NONE) : b.setPosition(0 > this._prevPos ? 0 : this._prevPosition, this.actionsEnabled ? null : createjs.Tween.NONE);
    this._prevPosition = b._prevPosition;
    if (this._prevPos != b._prevPos) {
      this.currentFrame = this._prevPos = b._prevPos;
      for (var e in this._managed)
        this._managed[e] = 1;
      for (b = a.length - 1; 0 <= b; b--)
        e = a[b], f = e._target, f != this && (e = e._stepPosition, f instanceof createjs.DisplayObject ? this._addManagedChild(f, e) : this._setState(f.state, e));
      for (b = c.length - 1; 0 <= b; b--)
        a = c[b].id, 1 == this._managed[a] && (this.removeChildAt(b), delete this._managed[a]);
    }
  };
  a._setState = function (b, a) {
    if (b)
      for (var c = 0, f = b.length; c < f; c++) {
        var e = b[c], d = e.t, e = e.p, g;
        for (g in e)
          d[g] = e[g];
        this._addManagedChild(d, a);
      }
  };
  a._addManagedChild = function (b, a) {
    b._off || (this.addChild(b), b instanceof d && (b._synchOffset = a, b.mode == d.INDEPENDENT && (b.autoReset && !this._managed[b.id]) && b._reset()), this._managed[b.id] = 2);
  };
  createjs.MovieClip = d;
  var g = function () {
    throw 'MovieClipPlugin cannot be instantiated.';
  };
  g.priority = 100;
  g.install = function () {
    createjs.Tween.installPlugin(g, ['startPosition']);
  };
  g.init = function (b, a, c) {
    return c;
  };
  g.step = function () {
  };
  g.tween = function (b, a, c, f, e, g) {
    return !(b.target instanceof d) ? c : 1 == g ? e[a] : f[a];
  };
  g.install();
}());
(function () {
  this.BLADE = this.BLADE || {};
}.call(this), function () {
  var a, b, c;
  this.BLADE = this.BLADE || {}, a = this.BLADE, c = function (a, b) {
    return 0 === a.numer ? null : 1 === a.denom ? 1 === a.numer ? '' + b : '' + b + ' ** ' + a.numer : '' + b + ' ** ' + a;
  }, b = function () {
    function b(b, c, d, e, f, g, h) {
      if (7 !== arguments.length)
        throw {
          name: 'DimensionError',
          message: 'Expecting 7 arguments'
        };
      if ('number' == typeof b)
        this.M = new a.Rational(b, 1);
      else {
        if (!(b instanceof a.Rational))
          throw {
            name: 'DimensionError',
            message: 'mass must be a Rational or number'
          };
        this.M = b;
      }
      if ('number' == typeof c)
        this.L = new a.Rational(c, 1);
      else {
        if (!(c instanceof a.Rational))
          throw {
            name: 'DimensionError',
            message: 'length must be a Rational or number'
          };
        this.L = c;
      }
      if ('number' == typeof d)
        this.T = new a.Rational(d, 1);
      else {
        if (!(d instanceof a.Rational))
          throw {
            name: 'DimensionError',
            message: 'time must be a Rational or number'
          };
        this.T = d;
      }
      if ('number' == typeof e)
        this.Q = new a.Rational(e, 1);
      else {
        if (!(e instanceof a.Rational))
          throw {
            name: 'DimensionError',
            message: 'charge must be a Rational or number'
          };
        this.Q = e;
      }
      if ('number' == typeof f)
        this.temperature = new a.Rational(f, 1);
      else {
        if (!(f instanceof a.Rational))
          throw {
            name: 'DimensionError',
            message: '(thermodynamic) temperature must be a Rational or number'
          };
        this.temperature = f;
      }
      if ('number' == typeof g)
        this.amount = new a.Rational(g, 1);
      else {
        if (!(g instanceof a.Rational))
          throw {
            name: 'DimensionError',
            message: 'amount (of substance) must be a Rational or number'
          };
        this.amount = g;
      }
      if ('number' == typeof h)
        this.intensity = new a.Rational(h, 1);
      else {
        if (!(h instanceof a.Rational))
          throw {
            name: 'DimensionError',
            message: '(luminous) intensity must be a Rational or number'
          };
        this.intensity = h;
      }
    }
    return b.prototype.compatible = function (a) {
      if (this.M.equals(a.M) && this.L.equals(a.L) && this.T.equals(a.T) && this.Q.equals(a.Q) && this.temperature.equals(a.temperature) && this.amount.equals(a.amount) && this.intensity.equals(a.intensity))
        return this;
      throw {
        name: 'DimensionError',
        message: 'Dimensions must be equal (' + this + ', ' + a + ')'
      };
    }, b.prototype.mul = function (b) {
      return new a.Dimensions(this.M.add(b.M), this.L.add(b.L), this.T.add(b.T), this.Q.add(b.Q), this.temperature.add(b.temperature), this.amount.add(b.amount), this.intensity.add(b.intensity));
    }, b.prototype.div = function (b) {
      return new a.Dimensions(this.M.sub(b.M), this.L.sub(b.L), this.T.sub(b.T), this.Q.sub(b.Q), this.temperature.sub(b.temperature), this.amount.sub(b.amount), this.intensity.sub(b.intensity));
    }, b.prototype.pow = function (b) {
      return new a.Dimensions(this.M.mul(b), this.L.mul(b), this.T.mul(b), this.Q.mul(b), this.temperature.mul(b), this.amount.mul(b), this.intensity.mul(b));
    }, b.prototype.dimensionless = function () {
      return this.M.isZero() && this.L.isZero() && this.T.isZero() && this.Q.isZero() && this.temperature.isZero() && this.amount.isZero() && this.intensity.isZero();
    }, b.prototype.isZero = function () {
      return this.M.isZero() && this.L.isZero() && this.T.isZero() && this.Q.isZero() && this.temperature.isZero() && this.amount.isZero() && this.intensity.isZero();
    }, b.prototype.negative = function () {
      return new a.Dimensions(this.M.negative(), this.L.negative(), this.T.negative(), this.Q.negative(), this.temperature.negative(), this.amount.negative(), this.intensity.negative());
    }, b.prototype.toString = function () {
      return [
        c(this.M, 'mass'),
        c(this.L, 'length'),
        c(this.T, 'time'),
        c(this.Q, 'charge'),
        c(this.temperature, 'thermodynamic temperature'),
        c(this.amount, 'amount of substance'),
        c(this.intensity, 'luminous intensity')
      ].filter(function (a) {
        return 'string' == typeof a;
      }).join(' * ');
    }, b;
  }(), this.BLADE.Dimensions = b;
}.call(this), function () {
  var a, b, c;
  this.BLADE = this.BLADE || {}, a = this.BLADE, c = function (b, c, d, e, f, g, h, i, j) {
    var k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, A, B, C, D, E, F, G, H, I;
    return x = +f, y = +g, z = +h, A = -i, t = f * x + g * y + h * z - i * A, u = 0, v = 0, w = 0, k = +t, l = -u, m = -v, n = -w, B = x * k + y * l + z * m - A * n, C = x * l + y * k - z * n + A * m, D = x * m + y * n + z * k - A * l, E = x * n + y * m - z * l + A * k, s = f * B + g * C + h * D - i * E, o = B / s, p = C / s, q = D / s, r = E / s, F = b * o + c * p + d * q - e * r, G = b * p + c * o - d * r + e * q, H = b * q + c * r + d * o - e * p, I = b * r + c * q - d * p + e * o, 'undefined' != typeof j ? (j.w = F, j.x = G, j.y = H, j.xy = I) : new a.Euclidean2(F, G, H, I);
  }, b = function () {
    function b(a, b, c, d) {
      this.w = a || 0, this.x = b, this.y = c, this.xy = d;
    }
    return b.fromCartesian = function (b, c, d, e) {
      return new a.Euclidean2(b, c, d, e);
    }, b.fromPolar = function (b, c, d, e) {
      return new a.Euclidean2(b, c * Math.cos(d), c * Math.sin(d), e);
    }, b.prototype.coordinates = function () {
      return [
        this.w,
        this.x,
        this.y,
        this.xy
      ];
    }, b.prototype.coordinate = function (a) {
      switch (a) {
      case 0:
        return this.w;
      case 1:
        return this.x;
      case 2:
        return this.y;
      case 3:
        return this.xy;
      default:
        throw new Error('index must be in the range [0..3]');
      }
    }, b.add = function (b, c) {
      var d, e, f, g, h, i, j, k, l, m, n, o;
      return d = b[0], e = b[1], f = b[2], g = b[3], h = c[0], i = c[1], j = c[2], k = c[3], l = a.e2gaASM.add00(d, e, f, g, h, i, j, k), m = a.e2gaASM.add01(d, e, f, g, h, i, j, k), n = a.e2gaASM.add10(d, e, f, g, h, i, j, k), o = a.e2gaASM.add11(d, e, f, g, h, i, j, k), [
        l,
        m,
        n,
        o
      ];
    }, b.prototype.add = function (c) {
      var d;
      return d = b.add(this.coordinates(), c.coordinates()), new a.Euclidean2(d[0], d[1], d[2], d[3]);
    }, b.sub = function (b, c) {
      var d, e, f, g, h, i, j, k, l, m, n, o;
      return d = b[0], e = b[1], f = b[2], g = b[3], h = c[0], i = c[1], j = c[2], k = c[3], l = a.bladeASM.subE2(d, e, f, g, h, i, j, k, 0), m = a.bladeASM.subE2(d, e, f, g, h, i, j, k, 1), n = a.bladeASM.subE2(d, e, f, g, h, i, j, k, 2), o = a.bladeASM.subE2(d, e, f, g, h, i, j, k, 3), [
        l,
        m,
        n,
        o
      ];
    }, b.prototype.sub = function (c) {
      var d;
      return d = b.sub(this.coordinates(), c.coordinates()), new a.Euclidean2(d[0], d[1], d[2], d[3]);
    }, b.mul = function (b, c) {
      var d, e, f, g, h, i, j, k, l, m, n, o;
      return d = b[0], e = b[1], f = b[2], g = b[3], h = c[0], i = c[1], j = c[2], k = c[3], l = a.bladeASM.mulE2(d, e, f, g, h, i, j, k, 0), m = a.bladeASM.mulE2(d, e, f, g, h, i, j, k, 1), n = a.bladeASM.mulE2(d, e, f, g, h, i, j, k, 2), o = a.bladeASM.mulE2(d, e, f, g, h, i, j, k, 3), [
        l,
        m,
        n,
        o
      ];
    }, b.prototype.mul = function (c) {
      var d;
      return 'number' == typeof c ? new a.Euclidean2(this.w * c, this.x * c, this.y * c, this.xy * c) : (d = b.mul(this.coordinates(), c.coordinates()), new a.Euclidean2(d[0], d[1], d[2], d[3]));
    }, b.prototype.div = function (b) {
      return 'number' == typeof b ? new a.Euclidean2(this.w / b, this.x / b, this.y / b, this.xy / b) : c(this.w, this.x, this.y, this.xy, b.w, b.x, b.y, b.xy, void 0);
    }, b.wedge = function (b, c) {
      var d, e, f, g, h, i, j, k, l, m, n, o;
      return d = b[0], e = b[1], f = b[2], g = b[3], h = c[0], i = c[1], j = c[2], k = c[3], l = a.bladeASM.extE2(d, e, f, g, h, i, j, k, 0), m = a.bladeASM.extE2(d, e, f, g, h, i, j, k, 1), n = a.bladeASM.extE2(d, e, f, g, h, i, j, k, 2), o = a.bladeASM.extE2(d, e, f, g, h, i, j, k, 3), [
        l,
        m,
        n,
        o
      ];
    }, b.prototype.wedge = function (c) {
      var d;
      return d = b.wedge(this.coordinates(), c.coordinates()), new a.Euclidean2(d[0], d[1], d[2], d[3]);
    }, b.lshift = function (b, c) {
      var d, e, f, g, h, i, j, k, l, m, n, o;
      return d = b[0], e = b[1], f = b[2], g = b[3], h = c[0], i = c[1], j = c[2], k = c[3], l = a.bladeASM.lcoE2(d, e, f, g, h, i, j, k, 0), m = a.bladeASM.lcoE2(d, e, f, g, h, i, j, k, 1), n = a.bladeASM.lcoE2(d, e, f, g, h, i, j, k, 2), o = a.bladeASM.lcoE2(d, e, f, g, h, i, j, k, 3), [
        l,
        m,
        n,
        o
      ];
    }, b.prototype.lshift = function (c) {
      var d;
      return d = b.lshift(this.coordinates(), c.coordinates()), new a.Euclidean2(d[0], d[1], d[2], d[3]);
    }, b.rshift = function (b, c) {
      var d, e, f, g, h, i, j, k, l, m, n, o;
      return d = b[0], e = b[1], f = b[2], g = b[3], h = c[0], i = c[1], j = c[2], k = c[3], l = a.bladeASM.rcoE2(d, e, f, g, h, i, j, k, 0), m = a.bladeASM.rcoE2(d, e, f, g, h, i, j, k, 1), n = a.bladeASM.rcoE2(d, e, f, g, h, i, j, k, 2), o = a.bladeASM.rcoE2(d, e, f, g, h, i, j, k, 3), [
        l,
        m,
        n,
        o
      ];
    }, b.prototype.rshift = function (c) {
      var d;
      return d = b.rshift(this.coordinates(), c.coordinates()), new a.Euclidean2(d[0], d[1], d[2], d[3]);
    }, b.prototype.grade = function (b) {
      switch (b) {
      case 0:
        return new a.Euclidean2(this.w, 0, 0, 0);
      case 1:
        return new a.Euclidean2(0, this.x, this.y, 0);
      case 2:
        return new a.Euclidean2(0, 0, 0, this.xy);
      default:
        return new a.Euclidean2(0, 0, 0, 0);
      }
    }, b.prototype.quadrance = function () {
      var a, b, c, d;
      return a = this.w, b = this.x, d = this.y, c = this.xy, a * a + b * b + d * d + c * c;
    }, b.prototype.isNaN = function () {
      return isNaN(this.w) || isNaN(this.x) || isNaN(this.y) || isNaN(this.xy);
    }, b.prototype.toString = function () {
      return a.bladeSTR.stringFromCoordinates([
        this.w,
        this.x,
        this.y,
        this.xy
      ], [
        '1',
        'e1',
        'e2',
        'e12'
      ]);
    }, b.prototype.toStringIJK = function () {
      return a.bladeSTR.stringFromCoordinates(this.coordinates(), [
        '1',
        'i',
        'j',
        'I'
      ]);
    }, b.prototype.toStringLATEX = function () {
      return a.bladeSTR.stringFromCoordinates(this.coordinates(), [
        '1',
        'e_{1}',
        'e_{2}',
        'e_{12}'
      ]);
    }, b;
  }(), this.BLADE.Euclidean2 = b;
}.call(this), function () {
  var a, b, c, d;
  this.BLADE = this.BLADE || {}, a = this.BLADE, d = function (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q) {
    var r;
    switch (a = +a, b = +b, c = +c, d = +d, e = +e, f = +f, g = +g, h = +h, i = +i, j = +j, k = +k, l = +l, m = +m, n = +n, o = +o, p = +p, q = 0 | q, r = 0, ~~q) {
    case 0:
      r = +(a * i + b * j + c * k + d * l - e * m - f * n - g * o - h * p);
      break;
    case 1:
      r = +(a * j + b * i - c * m + d * o + e * k - f * p - g * l - h * n);
      break;
    case 2:
      r = +(a * k + b * m + c * i - d * n - e * j + f * l - g * p - h * o);
      break;
    case 3:
      r = +(a * l - b * o + c * n + d * i - e * p - f * k + g * j - h * m);
      break;
    case 4:
      r = +(a * m + b * k - c * j + d * p + e * i - f * o + g * n + h * l);
      break;
    case 5:
      r = +(a * n + b * p + c * l - d * k + e * o + f * i - g * m + h * j);
      break;
    case 6:
      r = +(a * o - b * l + c * p + d * j - e * n + f * m + g * i + h * k);
      break;
    case 7:
      r = +(a * p + b * n + c * o + d * m + e * l + f * j + g * k + h * i);
    }
    return +r;
  }, c = function (b, c, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s) {
    var t, u, v, w, x, y, z, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z, $, _, ab, bb, cb, db, eb, fb, gb, hb, ib, jb, kb, lb, mb, nb, ob, pb, qb, rb, sb, tb, ub, vb;
    return S = +k, T = +l, U = +m, V = -n, W = +o, X = -p, Y = -q, Z = -r, K = d(k, l, m, o, n, q, -p, r, S, T, U, W, V, Y, -X, Z, 0), L = d(k, l, m, o, n, q, -p, r, S, T, U, W, V, Y, -X, Z, 1), M = d(k, l, m, o, n, q, -p, r, S, T, U, W, V, Y, -X, Z, 2), N = 0, O = d(k, l, m, o, n, q, -p, r, S, T, U, W, V, Y, -X, Z, 3), P = 0, Q = 0, R = 0, t = +K, u = -L, v = -M, w = -N, x = -O, y = -P, z = -Q, A = +R, $ = d(S, T, U, W, V, Y, -X, Z, t, u, v, x, w, z, -y, A, 0), _ = d(S, T, U, W, V, Y, -X, Z, t, u, v, x, w, z, -y, A, 1), ab = d(S, T, U, W, V, Y, -X, Z, t, u, v, x, w, z, -y, A, 2), bb = d(S, T, U, W, V, Y, -X, Z, t, u, v, x, w, z, -y, A, 4), cb = d(S, T, U, W, V, Y, -X, Z, t, u, v, x, w, z, -y, A, 3), db = -d(S, T, U, W, V, Y, -X, Z, t, u, v, x, w, z, -y, A, 6), eb = d(S, T, U, W, V, Y, -X, Z, t, u, v, x, w, z, -y, A, 5), fb = d(S, T, U, W, V, Y, -X, Z, t, u, v, x, w, z, -y, A, 7), J = d(k, l, m, o, n, q, -p, r, $, _, ab, cb, bb, eb, -db, fb, 0), B = $ / J, C = _ / J, D = ab / J, E = bb / J, F = cb / J, G = db / J, H = eb / J, I = fb / J, ib = d(b, c, e, g, f, i, -h, j, B, C, D, F, E, H, -G, I, 0), jb = d(b, c, e, g, f, i, -h, j, B, C, D, F, E, H, -G, I, 1), kb = d(b, c, e, g, f, i, -h, j, B, C, D, F, E, H, -G, I, 2), lb = d(b, c, e, g, f, i, -h, j, B, C, D, F, E, H, -G, I, 4), mb = d(b, c, e, g, f, i, -h, j, B, C, D, F, E, H, -G, I, 3), nb = -d(b, c, e, g, f, i, -h, j, B, C, D, F, E, H, -G, I, 6), ob = d(b, c, e, g, f, i, -h, j, B, C, D, F, E, H, -G, I, 5), pb = d(b, c, e, g, f, i, -h, j, B, C, D, F, E, H, -G, I, 7), gb = ib, hb = jb, sb = kb, ub = mb, qb = lb, tb = ob, vb = -nb, rb = pb, 'undefined' != typeof s ? (s.w = gb, s.x = hb, s.y = sb, s.z = ub, s.xy = qb, s.yz = tb, s.zx = vb, s.xyz = rb) : new a.Euclidean3(gb, hb, sb, ub, qb, tb, vb, rb);
  }, b = function () {
    function b(a, b, c, d, e, f, g, h) {
      this.w = a || 0, this.x = b || 0, this.y = c || 0, this.z = d || 0, this.xy = e || 0, this.yz = f || 0, this.zx = g || 0, this.xyz = h || 0;
    }
    return b.fromCartesian = function (b, c, d, e, f, g, h, i) {
      return new a.Euclidean3(b, c, d, e, f, g, h, i);
    }, b.prototype.coordinates = function () {
      return [
        this.w,
        this.x,
        this.y,
        this.z,
        this.xy,
        this.yz,
        this.zx,
        this.xyz
      ];
    }, b.prototype.coordinate = function (a) {
      switch (a) {
      case 0:
        return this.w;
      case 1:
        return this.x;
      case 2:
        return this.y;
      case 3:
        return this.z;
      case 4:
        return this.xy;
      case 5:
        return this.yz;
      case 6:
        return this.zx;
      case 7:
        return this.xyz;
      default:
        throw new Error('index must be in the range [0..7]');
      }
    }, b.compute = function (a, b, c, d, e) {
      var f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, A, B, C;
      return f = d(b, 0), g = d(b, 1), h = d(b, 2), i = d(b, 3), j = d(b, 4), k = d(b, 5), l = d(b, 6), m = d(b, 7), n = d(c, 0), o = d(c, 1), p = d(c, 2), q = d(c, 3), r = d(c, 4), s = d(c, 5), t = d(c, 6), u = d(c, 7), v = a(f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, 0), w = a(f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, 1), x = a(f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, 2), y = a(f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, 3), z = a(f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, 4), A = a(f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, 5), B = a(f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, 6), C = a(f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, 7), e(v, w, x, y, z, A, B, C);
    }, b.prototype.add = function (c) {
      var d, e;
      return d = function (a, b) {
        return a[b];
      }, e = function (a, c, d, e, f, g, h, i) {
        return b.fromCartesian(a, c, d, e, f, g, h, i);
      }, b.compute(a.bladeASM.addE3, [
        this.w,
        this.x,
        this.y,
        this.z,
        this.xy,
        this.yz,
        this.zx,
        this.xyz
      ], [
        c.w,
        c.x,
        c.y,
        c.z,
        c.xy,
        c.yz,
        c.zx,
        c.xyz
      ], d, e);
    }, b.prototype.sub = function (c) {
      var d, e;
      return d = function (a, b) {
        return a[b];
      }, e = function (a, c, d, e, f, g, h, i) {
        return b.fromCartesian(a, c, d, e, f, g, h, i);
      }, b.compute(a.bladeASM.subE3, [
        this.w,
        this.x,
        this.y,
        this.z,
        this.xy,
        this.yz,
        this.zx,
        this.xyz
      ], [
        c.w,
        c.x,
        c.y,
        c.z,
        c.xy,
        c.yz,
        c.zx,
        c.xyz
      ], d, e);
    }, b.prototype.mul = function (c) {
      var d, e;
      return 'number' == typeof c ? new a.Euclidean3(this.w * c, this.x * c, this.y * c, this.z * c, this.xy * c, this.yz * c, this.zx * c, this.xyz * c) : (d = function (a, b) {
        return a[b];
      }, e = function (a, c, d, e, f, g, h, i) {
        return b.fromCartesian(a, c, d, e, f, g, h, i);
      }, b.compute(a.bladeASM.mulE3, [
        this.w,
        this.x,
        this.y,
        this.z,
        this.xy,
        this.yz,
        this.zx,
        this.xyz
      ], [
        c.w,
        c.x,
        c.y,
        c.z,
        c.xy,
        c.yz,
        c.zx,
        c.xyz
      ], d, e));
    }, b.prototype.div = function (b) {
      return 'number' == typeof b ? new a.Euclidean3(this.w / b, this.x / b, this.y / b, this.z / b, this.xy / b, this.yz / b, this.zx / b, this.xyz / b) : c(this.w, this.x, this.y, this.xy, this.z, -this.zx, this.yz, this.xyz, b.w, b.x, b.y, b.xy, b.z, -b.zx, b.yz, b.xyz, void 0);
    }, b.prototype.wedge = function (c) {
      var d, e;
      return d = function (a, b) {
        return a[b];
      }, e = function (a, c, d, e, f, g, h, i) {
        return b.fromCartesian(a, c, d, e, f, g, h, i);
      }, b.compute(a.bladeASM.extE3, [
        this.w,
        this.x,
        this.y,
        this.z,
        this.xy,
        this.yz,
        this.zx,
        this.xyz
      ], [
        c.w,
        c.x,
        c.y,
        c.z,
        c.xy,
        c.yz,
        c.zx,
        c.xyz
      ], d, e);
    }, b.prototype.lshift = function (c) {
      var d, e;
      return d = function (a, b) {
        return a[b];
      }, e = function (a, c, d, e, f, g, h, i) {
        return b.fromCartesian(a, c, d, e, f, g, h, i);
      }, b.compute(a.bladeASM.lcoE3, [
        this.w,
        this.x,
        this.y,
        this.z,
        this.xy,
        this.yz,
        this.zx,
        this.xyz
      ], [
        c.w,
        c.x,
        c.y,
        c.z,
        c.xy,
        c.yz,
        c.zx,
        c.xyz
      ], d, e);
    }, b.prototype.rshift = function (c) {
      var d, e;
      return d = function (a, b) {
        return a[b];
      }, e = function (a, c, d, e, f, g, h, i) {
        return b.fromCartesian(a, c, d, e, f, g, h, i);
      }, b.compute(a.bladeASM.rcoE3, [
        this.w,
        this.x,
        this.y,
        this.z,
        this.xy,
        this.yz,
        this.zx,
        this.xyz
      ], [
        c.w,
        c.x,
        c.y,
        c.z,
        c.xy,
        c.yz,
        c.zx,
        c.xyz
      ], d, e);
    }, b.prototype.grade = function (a) {
      switch (a) {
      case 0:
        return b.fromCartesian(this.w, 0, 0, 0, 0, 0, 0, 0);
      case 1:
        return b.fromCartesian(0, this.x, this.y, this.z, 0, 0, 0, 0);
      case 2:
        return b.fromCartesian(0, 0, 0, 0, this.xy, this.yz, this.zx, 0);
      case 3:
        return b.fromCartesian(0, 0, 0, 0, 0, 0, 0, this.xyz);
      default:
        return b.fromCartesian(0, 0, 0, 0, 0, 0, 0, 0);
      }
    }, b.prototype.dot = function (a) {
      return this.x * a.x + this.y * a.y + this.z * a.z;
    }, b.prototype.cross = function (b) {
      var c, d, e, f, g, h, i, j, k;
      return d = this.x, g = this.y, j = this.z, e = b.x, h = b.y, k = b.z, c = g * k - j * h, f = j * e - d * k, i = d * h - g * e, new a.Euclidean3(0, c, f, i, 0, 0, 0, 0);
    }, b.prototype.length = function () {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    }, b.prototype.toString = function () {
      return a.bladeSTR.stringFromCoordinates([
        this.w,
        this.x,
        this.y,
        this.z,
        this.xy,
        this.yz,
        this.zx,
        this.xyz
      ], [
        '1',
        'e1',
        'e2',
        'e3',
        'e12',
        'e23',
        'e31',
        'e123'
      ]);
    }, b.prototype.toStringIJK = function () {
      return a.bladeSTR.stringFromCoordinates([
        this.w,
        this.x,
        this.y,
        this.z,
        this.xy,
        this.yz,
        this.zx,
        this.xyz
      ], [
        '1',
        'i',
        'j',
        'k',
        'ij',
        'jk',
        'ki',
        'I'
      ]);
    }, b.prototype.toStringLATEX = function () {
      return a.bladeSTR.stringFromCoordinates([
        this.w,
        this.x,
        this.y,
        this.z,
        this.xy,
        this.yz,
        this.zx,
        this.xyz
      ], [
        '1',
        'e_{1}',
        'e_{2}',
        'e_{3}',
        'e_{12}',
        'e_{23}',
        'e_{31}',
        'e_{123}'
      ]);
    }, b;
  }(), this.BLADE.Euclidean3 = b;
}.call(this), function () {
  var a, b;
  this.BLADE = this.BLADE || {}, a = this.BLADE, b = function () {
    function b(a, b, c) {
      this.a = a, this.b = b, this.c = c;
    }
    return b.prototype.meetWithLine = function (b) {
      var c, d, e, f, g, h, i;
      return c = this.a, e = this.b, g = this.c, d = b.a, f = b.b, h = b.c, i = c * f - d * e, new a.Point2((e * h - f * g) / i, (d * g - c * h) / i);
    }, b.prototype.passesThroughPoint = function (a, b) {
      return Math.abs(this.a * a.x + this.b * a.y + this.c) < b;
    }, b.prototype.reflectPoint = function (b) {
      var c, d, e, f, g, h, i, j, k, l, m;
      return c = this.a, d = c * c, e = this.b, f = e * e, g = this.c, h = d - f, i = d + f, l = b.x, m = b.y, j = -(2 * c * (e * m + g) + l * i) / h, k = (2 * e * (c * l + g) + m * i) / h, new a.Point2(j, k);
    }, b;
  }(), this.BLADE.Line2 = b;
}.call(this), function () {
  var a, b;
  this.BLADE = this.BLADE || {}, a = this.BLADE, b = function () {
    function b(b, c) {
      var d;
      d = c.scale, 1 === d ? (this.quantity = b, this.uom = c) : (this.quantity = b.mul(d), this.uom = new a.Unit(1, c.dimensions, c.labels));
    }
    return b.prototype.add = function (b) {
      if (b instanceof a.Measure)
        return new a.Measure(this.quantity.add(b.quantity), this.uom.compatible(b.uom));
      throw new Error('Measure.add(rhs): rhs must be a Measure.');
    }, b.prototype.sub = function (b) {
      if (b instanceof a.Measure)
        return new a.Measure(this.quantity.sub(b.quantity), this.uom.compatible(b.uom));
      throw new Error('Measure.sub(rhs): rhs must be a Measure.');
    }, b.prototype.mul = function (b) {
      if (b instanceof a.Measure)
        return new a.Measure(this.quantity.mul(b.quantity), this.uom.mul(b.uom));
      if (b instanceof a.Unit)
        return new a.Measure(this.quantity, this.uom.mul(b));
      if ('number' == typeof b)
        return new a.Measure(this.quantity.mul(b), this.uom);
      throw new Error('Measure.mul(rhs): rhs must be a [Measure, Unit, number]');
    }, b.prototype.div = function (b) {
      if (b instanceof a.Measure)
        return new a.Measure(this.quantity.div(b.quantity), this.uom.div(b.uom));
      if (b instanceof a.Unit)
        return new a.Measure(this.quantity, this.uom.div(b));
      if ('number' == typeof b)
        return new a.Measure(this.quantity.div(b), this.uom);
      throw new Error('Measure.div(rhs): rhs must be a [Measure, Unit, number]');
    }, b.prototype.wedge = function (b) {
      if (b instanceof a.Measure)
        return new a.Measure(this.quantity.wedge(b.quantity), this.uom.mul(b.uom));
      throw new Error('Measure.wedge(rhs): rhs must be a Measure');
    }, b.prototype.toString = function () {
      return '' + this.quantity + ' ' + this.uom;
    }, b;
  }(), this.BLADE.Measure = b;
}.call(this), function () {
  var a, b;
  this.BLADE = this.BLADE || {}, a = this.BLADE, b = function () {
    function b(a, b) {
      this.x = a, this.y = b;
    }
    return b.prototype.joinToPoint = function (b) {
      var c, d, e, f;
      return c = this.x, e = this.y, d = b.x, f = b.y, new a.Line2(e - f, d - c, c * f - d * e);
    }, b.prototype.liesOnLine = function (a, b) {
      return Math.abs(a.a * this.x + a.b * this.y + a.c) < b;
    }, b.prototype.quadrance = function (a) {
      var b, c, d, e, f, g;
      return d = this.x, f = this.y, e = a.x, g = a.y, b = e - d, c = g - f, b * b + c * c;
    }, b.prototype.reflectAboutLine = function (b) {
      var c, d, e, f, g, h, i, j, k, l, m;
      return c = b.a, d = c * c, e = b.b, f = e * e, g = b.c, h = d - f, i = d + f, l = this.x, m = this.y, j = -(2 * c * (e * m + g) + l * i) / h, k = (2 * e * (c * l + g) + m * i) / h, new a.Point2(j, k);
    }, b.prototype.signedArea = function (b, c) {
      var d, e;
      return d = this.vectorTo(b), e = this.vectorTo(c), d.wedge(e).mul(new a.Euclidean2(0.5, 0, 0, 0));
    }, b.prototype.vectorTo = function (b) {
      return new a.Euclidean2(0, b.x - this.x, b.y - this.y, 0);
    }, b;
  }(), this.BLADE.Point2 = b;
}.call(this), function () {
  var a, b, c;
  this.BLADE = this.BLADE || {}, a = this.BLADE, c = function (a, b) {
    var c;
    for (0 > a && (a = -a), 0 > b && (b = -b), b > a && (c = a, a = b, b = c);;) {
      if (a %= b, 0 === a)
        return b;
      if (b %= a, 0 === b)
        return a;
    }
  }, b = function () {
    function b(a, b) {
      var d;
      if (0 === b)
        throw new Error('denominator must not be zero');
      d = 0 === a ? 1 : c(Math.abs(a), Math.abs(b)), 0 > b && (a = -a, b = -b), this.numer = a / d, this.denom = b / d;
    }
    return b.prototype.add = function (b) {
      return 'number' == typeof b ? new a.Rational(this.numer + this.denom * b, this.denom) : new a.Rational(this.numer * b.denom + this.denom * b.numer, this.denom * b.denom);
    }, b.prototype.sub = function (b) {
      return 'number' == typeof b ? new a.Rational(this.numer - this.denom * b, this.denom) : new a.Rational(this.numer * b.denom - this.denom * b.numer, this.denom * b.denom);
    }, b.prototype.mul = function (b) {
      return 'number' == typeof b ? new a.Rational(this.numer * b, this.denom) : new a.Rational(this.numer * b.numer, this.denom * b.denom);
    }, b.prototype.div = function (b) {
      return 'number' == typeof b ? new a.Rational(this.numer, this.denom * b) : new a.Rational(this.numer * b.denom, this.denom * b.numer);
    }, b.prototype.isZero = function () {
      return 0 === this.numer;
    }, b.prototype.negative = function () {
      return new a.Rational(-this.numer, this.denom);
    }, b.prototype.equals = function (b) {
      return b instanceof a.Rational ? this.numer * b.denom === this.denom * b.numer : !1;
    }, b.prototype.toString = function () {
      return '' + this.numer + '/' + this.denom;
    }, b;
  }(), this.BLADE.Rational = b;
}.call(this), function () {
  var a, b, c;
  this.BLADE = this.BLADE || {}, a = this.BLADE, c = function (a, b) {
    return 0 === a.numer ? null : 1 === a.denom ? 1 === a.numer ? '' + b : '' + b + ' ** ' + a.numer : '' + b + ' ** ' + a;
  }, b = function () {
    function b(a, b, c) {
      if (7 !== c.length)
        throw new Error('Expecting 7 elements in the labels array.');
      this.scale = a, this.dimensions = b, this.labels = c;
    }
    return b.prototype.compatible = function (a) {
      var c;
      if (a instanceof b)
        return c = this.dimensions.compatible(a.dimensions), this;
      throw new Error('Illegal Argument for Unit.compatible: ' + a);
    }, b.prototype.add = function (c) {
      if (c instanceof b)
        return new a.Unit(this.scale + c.scale, this.dimensions.compatible(c.dimensions), this.labels);
      throw new Error('Illegal Argument for Unit.add: ' + c);
    }, b.prototype.sub = function (c) {
      if (c instanceof b)
        return new a.Unit(this.scale - c.scale, this.dimensions.compatible(c.dimensions), this.labels);
      throw new Error('Illegal Argument for Unit.sub: ' + c);
    }, b.prototype.mul = function (c) {
      if ('number' == typeof c)
        return new a.Unit(this.scale * c, this.dimensions, this.labels);
      if (c instanceof b)
        return new a.Unit(this.scale * c.scale, this.dimensions.mul(c.dimensions), this.labels);
      throw new Error('Illegal Argument for mul: ' + c);
    }, b.prototype.div = function (c) {
      if ('number' == typeof c)
        return new a.Unit(this.scale / c, this.dimensions, this.labels);
      if (c instanceof b)
        return new a.Unit(this.scale / c.scale, this.dimensions.div(c.dimensions), this.labels);
      throw new Error('Illegal Argument for div: ' + c);
    }, b.prototype.pow = function (b) {
      if ('number' == typeof b)
        return new a.Unit(Math.pow(this.scale, b), this.dimensions.pow(b), this.labels);
      throw new Error('Illegal Argument for div: ' + b);
    }, b.prototype.inverse = function () {
      return new a.Unit(1 / this.scale, this.dimensions.negative(), this.labels);
    }, b.prototype.toString = function () {
      var a, b, d;
      return a = 1 === this.scale || this.dimensions.isZero() ? '' : ' ', b = 1 === this.scale ? '' : '' + this.scale, d = [
        c(this.dimensions.M, this.labels[0]),
        c(this.dimensions.L, this.labels[1]),
        c(this.dimensions.T, this.labels[2]),
        c(this.dimensions.Q, this.labels[3]),
        c(this.dimensions.temperature, this.labels[4]),
        c(this.dimensions.amount, this.labels[5]),
        c(this.dimensions.intensity, this.labels[6])
      ].filter(function (a) {
        return 'string' == typeof a;
      }).join(' '), '' + b + a + d;
    }, b;
  }(), this.BLADE.Unit = b, this.BLADE.UNIT_SYMBOLS = [
    'kg',
    'm',
    's',
    'C',
    'K',
    'mol',
    'cd'
  ], this.BLADE.UNIT_DIMLESS = new b(1, new this.BLADE.Dimensions(0, 0, 0, 0, 0, 0, 0), this.BLADE.UNIT_SYMBOLS), this.BLADE.UNIT_KILOGRAM = new b(1, new this.BLADE.Dimensions(1, 0, 0, 0, 0, 0, 0), this.BLADE.UNIT_SYMBOLS), this.BLADE.UNIT_METER = new b(1, new this.BLADE.Dimensions(0, 1, 0, 0, 0, 0, 0), this.BLADE.UNIT_SYMBOLS), this.BLADE.UNIT_SECOND = new b(1, new this.BLADE.Dimensions(0, 0, 1, 0, 0, 0, 0), this.BLADE.UNIT_SYMBOLS), this.BLADE.UNIT_AMPERE = new b(1, new this.BLADE.Dimensions(0, 0, -1, 1, 0, 0, 0), this.BLADE.UNIT_SYMBOLS), this.BLADE.UNIT_KELVIN = new b(1, new this.BLADE.Dimensions(0, 0, 0, 0, 1, 0, 0), this.BLADE.UNIT_SYMBOLS), this.BLADE.UNIT_MOLE = new b(1, new this.BLADE.Dimensions(0, 0, 0, 0, 0, 1, 0), this.BLADE.UNIT_SYMBOLS), this.BLADE.UNIT_CANDELA = new b(1, new this.BLADE.Dimensions(0, 0, 0, 0, 0, 0, 1), this.BLADE.UNIT_SYMBOLS), this.BLADE.UNIT_COULOMB = new b(1, new this.BLADE.Dimensions(0, 0, 0, 1, 0, 0, 0), this.BLADE.UNIT_SYMBOLS), this.BLADE.UNIT_INCH = new b(0.0254, new this.BLADE.Dimensions(0, 1, 0, 0, 0, 0, 0), this.BLADE.UNIT_SYMBOLS), this.BLADE.UNIT_FOOT = new b(0.3048, new this.BLADE.Dimensions(0, 1, 0, 0, 0, 0, 0), this.BLADE.UNIT_SYMBOLS), this.BLADE.UNIT_YARD = new b(0.9144, new this.BLADE.Dimensions(0, 1, 0, 0, 0, 0, 0), this.BLADE.UNIT_SYMBOLS), this.BLADE.UNIT_MILE = new b(1609.344, new this.BLADE.Dimensions(0, 1, 0, 0, 0, 0, 0), this.BLADE.UNIT_SYMBOLS), this.BLADE.UNIT_POUND = new b(0.45359237, new this.BLADE.Dimensions(1, 0, 0, 0, 0, 0, 0), this.BLADE.UNIT_SYMBOLS);
}.call(this), function () {
  this.BLADE = this.BLADE || {}, this.BLADE.bladeASM = function () {
    function a(a, b, c, d, e, f, g, h, i) {
      a = +a, b = +b, c = +c, d = +d, e = +e, f = +f, g = +g, h = +h, i = 0 | i;
      var j = 0;
      switch (~~i) {
      case 0:
        j = +(a + e);
        break;
      case 1:
        j = +(b + f);
        break;
      case 2:
        j = +(c + g);
        break;
      case 3:
        j = +(d + h);
      }
      return +j;
    }
    function b(a, b, c, d, e, f, g, h, i) {
      a = +a, b = +b, c = +c, d = +d, e = +e, f = +f, g = +g, h = +h, i = 0 | i;
      var j = 0;
      switch (~~i) {
      case 0:
        j = +(a - e);
        break;
      case 1:
        j = +(b - f);
        break;
      case 2:
        j = +(c - g);
        break;
      case 3:
        j = +(d - h);
      }
      return +j;
    }
    function c(a, b, c, d, e, f, g, h, i) {
      a = +a, b = +b, c = +c, d = +d, e = +e, f = +f, g = +g, h = +h, i = 0 | i;
      var j = 0;
      switch (~~i) {
      case 0:
        j = +(a * e + b * f + c * g - d * h);
        break;
      case 1:
        j = +(a * f + b * e - c * h + d * g);
        break;
      case 2:
        j = +(a * g + b * h + c * e - d * f);
        break;
      case 3:
        j = +(a * h + b * g - c * f + d * e);
      }
      return +j;
    }
    function d(a, b, c, d, e, f, g, h, i) {
      a = +a, b = +b, c = +c, d = +d, e = +e, f = +f, g = +g, h = +h, i = 0 | i;
      var j = 0;
      switch (~~i) {
      case 0:
        j = +(a * e);
        break;
      case 1:
        j = +(a * f + b * e);
        break;
      case 2:
        j = +(a * g + c * e);
        break;
      case 3:
        j = +(a * h + b * g - c * f + d * e);
      }
      return +j;
    }
    function e(a, b, c, d, e, f, g, h, i) {
      a = +a, b = +b, c = +c, d = +d, e = +e, f = +f, g = +g, h = +h, i = 0 | i;
      var j = 0;
      switch (~~i) {
      case 0:
        j = +(a * e + b * f + c * g - d * h);
        break;
      case 1:
        j = +(a * f - c * h);
        break;
      case 2:
        j = +(a * g + b * h);
        break;
      case 3:
        j = +(a * h);
      }
      return +j;
    }
    function f(a, b, c, d, e, f, g, h, i) {
      a = +a, b = +b, c = +c, d = +d, e = +e, f = +f, g = +g, h = +h, i = 0 | i;
      var j = 0;
      switch (~~i) {
      case 0:
        j = +(a * e + b * f + c * g - d * h);
        break;
      case 1:
        j = +(-b * e - d * g);
        break;
      case 2:
        j = +(-c * e + d * f);
        break;
      case 3:
        j = +(d * e);
      }
      return +j;
    }
    function g(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q) {
      a = +a, b = +b, c = +c, d = +d, e = +e, f = +f, g = +g, h = +h, i = +i, j = +j, k = +k, l = +l, m = +m, n = +n, o = +o, p = +p, q = 0 | q;
      var r = 0;
      switch (~~q) {
      case 0:
        r = +(a + i);
        break;
      case 1:
        r = +(b + j);
        break;
      case 2:
        r = +(c + k);
        break;
      case 3:
        r = +(d + l);
        break;
      case 4:
        r = +(e + m);
        break;
      case 5:
        r = +(f + n);
        break;
      case 6:
        r = +(g + o);
        break;
      case 7:
        r = +(h + p);
      }
      return +r;
    }
    function h(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q) {
      a = +a, b = +b, c = +c, d = +d, e = +e, f = +f, g = +g, h = +h, i = +i, j = +j, k = +k, l = +l, m = +m, n = +n, o = +o, p = +p, q = 0 | q;
      var r = 0;
      switch (~~q) {
      case 0:
        r = +(a - i);
        break;
      case 1:
        r = +(b - j);
        break;
      case 2:
        r = +(c - k);
        break;
      case 3:
        r = +(d - l);
        break;
      case 4:
        r = +(e - m);
        break;
      case 5:
        r = +(f - n);
        break;
      case 6:
        r = +(g - o);
        break;
      case 7:
        r = +(h - p);
      }
      return +r;
    }
    function i(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q) {
      a = +a, b = +b, c = +c, d = +d, e = +e, f = +f, g = +g, h = +h, i = +i, j = +j, k = +k, l = +l, m = +m, n = +n, o = +o, p = +p, q = 0 | q;
      var r = 0;
      switch (~~q) {
      case 0:
        r = +(a * i + b * j + c * k + d * l - e * m - f * n - g * o - h * p);
        break;
      case 1:
        r = +(a * j + b * i - c * m + d * o + e * k - f * p - g * l - h * n);
        break;
      case 2:
        r = +(a * k + b * m + c * i - d * n - e * j + f * l - g * p - h * o);
        break;
      case 3:
        r = +(a * l - b * o + c * n + d * i - e * p - f * k + g * j - h * m);
        break;
      case 4:
        r = +(a * m + b * k - c * j + d * p + e * i - f * o + g * n + h * l);
        break;
      case 5:
        r = +(a * n + b * p + c * l - d * k + e * o + f * i - g * m + h * j);
        break;
      case 6:
        r = +(a * o - b * l + c * p + d * j - e * n + f * m + g * i + h * k);
        break;
      case 7:
        r = +(a * p + b * n + c * o + d * m + e * l + f * j + g * k + h * i);
      }
      return +r;
    }
    function j(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q) {
      a = +a, b = +b, c = +c, d = +d, e = +e, f = +f, g = +g, h = +h, i = +i, j = +j, k = +k, l = +l, m = +m, n = +n, o = +o, p = +p, q = 0 | q;
      var r = 0;
      switch (~~q) {
      case 0:
        r = +(a * i);
        break;
      case 1:
        r = +(a * j + b * i);
        break;
      case 2:
        r = +(a * k + c * i);
        break;
      case 3:
        r = +(a * l + d * i);
        break;
      case 4:
        r = +(a * m + b * k - c * j + e * i);
        break;
      case 5:
        r = +(a * n + c * l - d * k + f * i);
        break;
      case 6:
        r = +(a * o - b * l + d * j + g * i);
        break;
      case 7:
        r = +(a * p + b * n + c * o + d * m + e * l + f * j + g * k + h * i);
      }
      return +r;
    }
    function k(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q) {
      a = +a, b = +b, c = +c, d = +d, e = +e, f = +f, g = +g, h = +h, i = +i, j = +j, k = +k, l = +l, m = +m, n = +n, o = +o, p = +p, q = 0 | q;
      var r = 0;
      switch (~~q) {
      case 0:
        r = +(a * i + b * j + c * k + d * l - e * m - f * n - g * o - h * p);
        break;
      case 1:
        r = +(a * j - c * m + d * o - f * p);
        break;
      case 2:
        r = +(a * k + b * m - d * n - g * p);
        break;
      case 3:
        r = +(a * l - b * o + c * n - e * p);
        break;
      case 4:
        r = +(a * m + d * p);
        break;
      case 5:
        r = +(a * n + b * p);
        break;
      case 6:
        r = +(a * o + c * p);
        break;
      case 7:
        r = +(a * p);
      }
      return +r;
    }
    function l(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q) {
      a = +a, b = +b, c = +c, d = +d, e = +e, f = +f, g = +g, h = +h, i = +i, j = +j, k = +k, l = +l, m = +m, n = +n, o = +o, p = +p, q = 0 | q;
      var r = 0;
      switch (~~q) {
      case 0:
        r = +(a * i + b * j + c * k + d * l - e * m - f * n - g * o - h * p);
        break;
      case 1:
        r = +(+b * i + e * k - g * l - h * n);
        break;
      case 2:
        r = +(+c * i - e * j + f * l - h * o);
        break;
      case 3:
        r = +(+d * i - f * k + g * j - h * m);
        break;
      case 4:
        r = +(+e * i + h * l);
        break;
      case 5:
        r = +(+f * i + h * j);
        break;
      case 6:
        r = +(+g * i + h * k);
        break;
      case 7:
        r = +(+h * i);
      }
      return +r;
    }
    return {
      addE2: a,
      subE2: b,
      mulE2: c,
      extE2: d,
      lcoE2: e,
      rcoE2: f,
      addE3: g,
      subE3: h,
      mulE3: i,
      extE3: j,
      lcoE3: k,
      rcoE3: l
    };
  }('object' == typeof window ? window : void 0, {}, new ArrayBuffer(4096));
}.call(this), function () {
  this.BLADE = this.BLADE || {}, this.BLADE.bladeSTR = function () {
    'use strict';
    function a(a, b) {
      var c, d, e, f, g, h;
      for (e = [], c = function (a, b) {
          var c;
          if (0 !== a) {
            if (a >= 0 ? e.length > 0 && e.push('+') : e.push('-'), c = Math.abs(a), 1 === c)
              return e.push(b);
            if (e.push(c.toString()), '1' !== b)
              return e.push('*'), e.push(b);
          }
        }, d = g = 0, h = a.length - 1; h >= 0 ? h >= g : g >= h; d = h >= 0 ? ++g : --g)
        c(a[d], b[d]);
      return f = e.length > 0 ? e.join('') : '0';
    }
    return { stringFromCoordinates: a };
  }();
}.call(this), function () {
  this.BLADE = this.BLADE || {}, this.BLADE.e2gaASM = function () {
    function a(a, b, c, d, e, f, g, h) {
      return a = +a, b = +b, c = +c, d = +d, e = +e, f = +f, g = +g, h = +h, +(a + e);
    }
    function b(a, b, c, d, e, f, g, h) {
      return a = +a, b = +b, c = +c, d = +d, e = +e, f = +f, g = +g, h = +h, +(b + f);
    }
    function c(a, b, c, d, e, f, g, h) {
      return a = +a, b = +b, c = +c, d = +d, e = +e, f = +f, g = +g, h = +h, +(c + g);
    }
    function d(a, b, c, d, e, f, g, h) {
      return a = +a, b = +b, c = +c, d = +d, e = +e, f = +f, g = +g, h = +h, +(d + h);
    }
    return {
      add00: a,
      add01: b,
      add10: c,
      add11: d
    };
  }('object' == typeof window ? window : void 0, {}, new ArrayBuffer(4096));
}.call(this));
'use strict';
var THREE = { REVISION: '67' };
self.console = self.console || {
  info: function () {
  },
  log: function () {
  },
  debug: function () {
  },
  warn: function () {
  },
  error: function () {
  }
};
(function () {
  for (var a = 0, b = [
        'ms',
        'moz',
        'webkit',
        'o'
      ], c = 0; c < b.length && !self.requestAnimationFrame; ++c)
    self.requestAnimationFrame = self[b[c] + 'RequestAnimationFrame'], self.cancelAnimationFrame = self[b[c] + 'CancelAnimationFrame'] || self[b[c] + 'CancelRequestAnimationFrame'];
  void 0 === self.requestAnimationFrame && void 0 !== self.setTimeout && (self.requestAnimationFrame = function (b) {
    var c = Date.now(), f = Math.max(0, 16 - (c - a)), g = self.setTimeout(function () {
        b(c + f);
      }, f);
    a = c + f;
    return g;
  });
  void 0 === self.cancelAnimationFrame && void 0 !== self.clearTimeout && (self.cancelAnimationFrame = function (a) {
    self.clearTimeout(a);
  });
}());
THREE.CullFaceNone = 0;
THREE.CullFaceBack = 1;
THREE.CullFaceFront = 2;
THREE.CullFaceFrontBack = 3;
THREE.FrontFaceDirectionCW = 0;
THREE.FrontFaceDirectionCCW = 1;
THREE.BasicShadowMap = 0;
THREE.PCFShadowMap = 1;
THREE.PCFSoftShadowMap = 2;
THREE.FrontSide = 0;
THREE.BackSide = 1;
THREE.DoubleSide = 2;
THREE.NoShading = 0;
THREE.FlatShading = 1;
THREE.SmoothShading = 2;
THREE.NoColors = 0;
THREE.FaceColors = 1;
THREE.VertexColors = 2;
THREE.NoBlending = 0;
THREE.NormalBlending = 1;
THREE.AdditiveBlending = 2;
THREE.SubtractiveBlending = 3;
THREE.MultiplyBlending = 4;
THREE.CustomBlending = 5;
THREE.AddEquation = 100;
THREE.SubtractEquation = 101;
THREE.ReverseSubtractEquation = 102;
THREE.ZeroFactor = 200;
THREE.OneFactor = 201;
THREE.SrcColorFactor = 202;
THREE.OneMinusSrcColorFactor = 203;
THREE.SrcAlphaFactor = 204;
THREE.OneMinusSrcAlphaFactor = 205;
THREE.DstAlphaFactor = 206;
THREE.OneMinusDstAlphaFactor = 207;
THREE.DstColorFactor = 208;
THREE.OneMinusDstColorFactor = 209;
THREE.SrcAlphaSaturateFactor = 210;
THREE.MultiplyOperation = 0;
THREE.MixOperation = 1;
THREE.AddOperation = 2;
THREE.UVMapping = function () {
};
THREE.CubeReflectionMapping = function () {
};
THREE.CubeRefractionMapping = function () {
};
THREE.SphericalReflectionMapping = function () {
};
THREE.SphericalRefractionMapping = function () {
};
THREE.RepeatWrapping = 1000;
THREE.ClampToEdgeWrapping = 1001;
THREE.MirroredRepeatWrapping = 1002;
THREE.NearestFilter = 1003;
THREE.NearestMipMapNearestFilter = 1004;
THREE.NearestMipMapLinearFilter = 1005;
THREE.LinearFilter = 1006;
THREE.LinearMipMapNearestFilter = 1007;
THREE.LinearMipMapLinearFilter = 1008;
THREE.UnsignedByteType = 1009;
THREE.ByteType = 1010;
THREE.ShortType = 1011;
THREE.UnsignedShortType = 1012;
THREE.IntType = 1013;
THREE.UnsignedIntType = 1014;
THREE.FloatType = 1015;
THREE.UnsignedShort4444Type = 1016;
THREE.UnsignedShort5551Type = 1017;
THREE.UnsignedShort565Type = 1018;
THREE.AlphaFormat = 1019;
THREE.RGBFormat = 1020;
THREE.RGBAFormat = 1021;
THREE.LuminanceFormat = 1022;
THREE.LuminanceAlphaFormat = 1023;
THREE.RGB_S3TC_DXT1_Format = 2001;
THREE.RGBA_S3TC_DXT1_Format = 2002;
THREE.RGBA_S3TC_DXT3_Format = 2003;
THREE.RGBA_S3TC_DXT5_Format = 2004;
THREE.Color = function (a) {
  return 3 === arguments.length ? this.setRGB(arguments[0], arguments[1], arguments[2]) : this.set(a);
};
THREE.Color.prototype = {
  constructor: THREE.Color,
  r: 1,
  g: 1,
  b: 1,
  set: function (a) {
    a instanceof THREE.Color ? this.copy(a) : 'number' === typeof a ? this.setHex(a) : 'string' === typeof a && this.setStyle(a);
    return this;
  },
  setHex: function (a) {
    a = Math.floor(a);
    this.r = (a >> 16 & 255) / 255;
    this.g = (a >> 8 & 255) / 255;
    this.b = (a & 255) / 255;
    return this;
  },
  setRGB: function (a, b, c) {
    this.r = a;
    this.g = b;
    this.b = c;
    return this;
  },
  setHSL: function (a, b, c) {
    if (0 === b)
      this.r = this.g = this.b = c;
    else {
      var d = function (a, b, c) {
        0 > c && (c += 1);
        1 < c && (c -= 1);
        return c < 1 / 6 ? a + 6 * (b - a) * c : 0.5 > c ? b : c < 2 / 3 ? a + 6 * (b - a) * (2 / 3 - c) : a;
      };
      b = 0.5 >= c ? c * (1 + b) : c + b - c * b;
      c = 2 * c - b;
      this.r = d(c, b, a + 1 / 3);
      this.g = d(c, b, a);
      this.b = d(c, b, a - 1 / 3);
    }
    return this;
  },
  setStyle: function (a) {
    if (/^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.test(a))
      return a = /^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.exec(a), this.r = Math.min(255, parseInt(a[1], 10)) / 255, this.g = Math.min(255, parseInt(a[2], 10)) / 255, this.b = Math.min(255, parseInt(a[3], 10)) / 255, this;
    if (/^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.test(a))
      return a = /^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.exec(a), this.r = Math.min(100, parseInt(a[1], 10)) / 100, this.g = Math.min(100, parseInt(a[2], 10)) / 100, this.b = Math.min(100, parseInt(a[3], 10)) / 100, this;
    if (/^\#([0-9a-f]{6})$/i.test(a))
      return a = /^\#([0-9a-f]{6})$/i.exec(a), this.setHex(parseInt(a[1], 16)), this;
    if (/^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.test(a))
      return a = /^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.exec(a), this.setHex(parseInt(a[1] + a[1] + a[2] + a[2] + a[3] + a[3], 16)), this;
    if (/^(\w+)$/i.test(a))
      return this.setHex(THREE.ColorKeywords[a]), this;
  },
  copy: function (a) {
    this.r = a.r;
    this.g = a.g;
    this.b = a.b;
    return this;
  },
  copyGammaToLinear: function (a) {
    this.r = a.r * a.r;
    this.g = a.g * a.g;
    this.b = a.b * a.b;
    return this;
  },
  copyLinearToGamma: function (a) {
    this.r = Math.sqrt(a.r);
    this.g = Math.sqrt(a.g);
    this.b = Math.sqrt(a.b);
    return this;
  },
  convertGammaToLinear: function () {
    var a = this.r, b = this.g, c = this.b;
    this.r = a * a;
    this.g = b * b;
    this.b = c * c;
    return this;
  },
  convertLinearToGamma: function () {
    this.r = Math.sqrt(this.r);
    this.g = Math.sqrt(this.g);
    this.b = Math.sqrt(this.b);
    return this;
  },
  getHex: function () {
    return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0;
  },
  getHexString: function () {
    return ('000000' + this.getHex().toString(16)).slice(-6);
  },
  getHSL: function (a) {
    a = a || {
      h: 0,
      s: 0,
      l: 0
    };
    var b = this.r, c = this.g, d = this.b, e = Math.max(b, c, d), f = Math.min(b, c, d), g, h = (f + e) / 2;
    if (f === e)
      f = g = 0;
    else {
      var k = e - f, f = 0.5 >= h ? k / (e + f) : k / (2 - e - f);
      switch (e) {
      case b:
        g = (c - d) / k + (c < d ? 6 : 0);
        break;
      case c:
        g = (d - b) / k + 2;
        break;
      case d:
        g = (b - c) / k + 4;
      }
      g /= 6;
    }
    a.h = g;
    a.s = f;
    a.l = h;
    return a;
  },
  getStyle: function () {
    return 'rgb(' + (255 * this.r | 0) + ',' + (255 * this.g | 0) + ',' + (255 * this.b | 0) + ')';
  },
  offsetHSL: function (a, b, c) {
    var d = this.getHSL();
    d.h += a;
    d.s += b;
    d.l += c;
    this.setHSL(d.h, d.s, d.l);
    return this;
  },
  add: function (a) {
    this.r += a.r;
    this.g += a.g;
    this.b += a.b;
    return this;
  },
  addColors: function (a, b) {
    this.r = a.r + b.r;
    this.g = a.g + b.g;
    this.b = a.b + b.b;
    return this;
  },
  addScalar: function (a) {
    this.r += a;
    this.g += a;
    this.b += a;
    return this;
  },
  multiply: function (a) {
    this.r *= a.r;
    this.g *= a.g;
    this.b *= a.b;
    return this;
  },
  multiplyScalar: function (a) {
    this.r *= a;
    this.g *= a;
    this.b *= a;
    return this;
  },
  lerp: function (a, b) {
    this.r += (a.r - this.r) * b;
    this.g += (a.g - this.g) * b;
    this.b += (a.b - this.b) * b;
    return this;
  },
  equals: function (a) {
    return a.r === this.r && a.g === this.g && a.b === this.b;
  },
  fromArray: function (a) {
    this.r = a[0];
    this.g = a[1];
    this.b = a[2];
    return this;
  },
  toArray: function () {
    return [
      this.r,
      this.g,
      this.b
    ];
  },
  clone: function () {
    return new THREE.Color().setRGB(this.r, this.g, this.b);
  }
};
THREE.ColorKeywords = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
THREE.Quaternion = function (a, b, c, d) {
  this._x = a || 0;
  this._y = b || 0;
  this._z = c || 0;
  this._w = void 0 !== d ? d : 1;
};
THREE.Quaternion.prototype = {
  constructor: THREE.Quaternion,
  _x: 0,
  _y: 0,
  _z: 0,
  _w: 0,
  get x() {
    return this._x;
  },
  set x(a) {
    this._x = a;
    this.onChangeCallback();
  },
  get y() {
    return this._y;
  },
  set y(a) {
    this._y = a;
    this.onChangeCallback();
  },
  get z() {
    return this._z;
  },
  set z(a) {
    this._z = a;
    this.onChangeCallback();
  },
  get w() {
    return this._w;
  },
  set w(a) {
    this._w = a;
    this.onChangeCallback();
  },
  set: function (a, b, c, d) {
    this._x = a;
    this._y = b;
    this._z = c;
    this._w = d;
    this.onChangeCallback();
    return this;
  },
  copy: function (a) {
    this._x = a._x;
    this._y = a._y;
    this._z = a._z;
    this._w = a._w;
    this.onChangeCallback();
    return this;
  },
  setFromEuler: function (a, b) {
    if (!1 === a instanceof THREE.Euler)
      throw Error('ERROR: Quaternion\'s .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.  Please update your code.');
    var c = Math.cos(a._x / 2), d = Math.cos(a._y / 2), e = Math.cos(a._z / 2), f = Math.sin(a._x / 2), g = Math.sin(a._y / 2), h = Math.sin(a._z / 2);
    'XYZ' === a.order ? (this._x = f * d * e + c * g * h, this._y = c * g * e - f * d * h, this._z = c * d * h + f * g * e, this._w = c * d * e - f * g * h) : 'YXZ' === a.order ? (this._x = f * d * e + c * g * h, this._y = c * g * e - f * d * h, this._z = c * d * h - f * g * e, this._w = c * d * e + f * g * h) : 'ZXY' === a.order ? (this._x = f * d * e - c * g * h, this._y = c * g * e + f * d * h, this._z = c * d * h + f * g * e, this._w = c * d * e - f * g * h) : 'ZYX' === a.order ? (this._x = f * d * e - c * g * h, this._y = c * g * e + f * d * h, this._z = c * d * h - f * g * e, this._w = c * d * e + f * g * h) : 'YZX' === a.order ? (this._x = f * d * e + c * g * h, this._y = c * g * e + f * d * h, this._z = c * d * h - f * g * e, this._w = c * d * e - f * g * h) : 'XZY' === a.order && (this._x = f * d * e - c * g * h, this._y = c * g * e - f * d * h, this._z = c * d * h + f * g * e, this._w = c * d * e + f * g * h);
    if (!1 !== b)
      this.onChangeCallback();
    return this;
  },
  setFromAxisAngle: function (a, b) {
    var c = b / 2, d = Math.sin(c);
    this._x = a.x * d;
    this._y = a.y * d;
    this._z = a.z * d;
    this._w = Math.cos(c);
    this.onChangeCallback();
    return this;
  },
  setFromRotationMatrix: function (a) {
    var b = a.elements, c = b[0];
    a = b[4];
    var d = b[8], e = b[1], f = b[5], g = b[9], h = b[2], k = b[6], b = b[10], l = c + f + b;
    0 < l ? (c = 0.5 / Math.sqrt(l + 1), this._w = 0.25 / c, this._x = (k - g) * c, this._y = (d - h) * c, this._z = (e - a) * c) : c > f && c > b ? (c = 2 * Math.sqrt(1 + c - f - b), this._w = (k - g) / c, this._x = 0.25 * c, this._y = (a + e) / c, this._z = (d + h) / c) : f > b ? (c = 2 * Math.sqrt(1 + f - c - b), this._w = (d - h) / c, this._x = (a + e) / c, this._y = 0.25 * c, this._z = (g + k) / c) : (c = 2 * Math.sqrt(1 + b - c - f), this._w = (e - a) / c, this._x = (d + h) / c, this._y = (g + k) / c, this._z = 0.25 * c);
    this.onChangeCallback();
    return this;
  },
  setFromUnitVectors: function () {
    var a, b;
    return function (c, d) {
      void 0 === a && (a = new THREE.Vector3());
      b = c.dot(d) + 1;
      0.000001 > b ? (b = 0, Math.abs(c.x) > Math.abs(c.z) ? a.set(-c.y, c.x, 0) : a.set(0, -c.z, c.y)) : a.crossVectors(c, d);
      this._x = a.x;
      this._y = a.y;
      this._z = a.z;
      this._w = b;
      this.normalize();
      return this;
    };
  }(),
  inverse: function () {
    this.conjugate().normalize();
    return this;
  },
  conjugate: function () {
    this._x *= -1;
    this._y *= -1;
    this._z *= -1;
    this.onChangeCallback();
    return this;
  },
  lengthSq: function () {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  },
  length: function () {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  },
  normalize: function () {
    var a = this.length();
    0 === a ? (this._z = this._y = this._x = 0, this._w = 1) : (a = 1 / a, this._x *= a, this._y *= a, this._z *= a, this._w *= a);
    this.onChangeCallback();
    return this;
  },
  multiply: function (a, b) {
    return void 0 !== b ? (console.warn('DEPRECATED: Quaternion\'s .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.'), this.multiplyQuaternions(a, b)) : this.multiplyQuaternions(this, a);
  },
  multiplyQuaternions: function (a, b) {
    var c = a._x, d = a._y, e = a._z, f = a._w, g = b._x, h = b._y, k = b._z, l = b._w;
    this._x = c * l + f * g + d * k - e * h;
    this._y = d * l + f * h + e * g - c * k;
    this._z = e * l + f * k + c * h - d * g;
    this._w = f * l - c * g - d * h - e * k;
    this.onChangeCallback();
    return this;
  },
  multiplyVector3: function (a) {
    console.warn('DEPRECATED: Quaternion\'s .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.');
    return a.applyQuaternion(this);
  },
  slerp: function (a, b) {
    var c = this._x, d = this._y, e = this._z, f = this._w, g = f * a._w + c * a._x + d * a._y + e * a._z;
    0 > g ? (this._w = -a._w, this._x = -a._x, this._y = -a._y, this._z = -a._z, g = -g) : this.copy(a);
    if (1 <= g)
      return this._w = f, this._x = c, this._y = d, this._z = e, this;
    var h = Math.acos(g), k = Math.sqrt(1 - g * g);
    if (0.001 > Math.abs(k))
      return this._w = 0.5 * (f + this._w), this._x = 0.5 * (c + this._x), this._y = 0.5 * (d + this._y), this._z = 0.5 * (e + this._z), this;
    g = Math.sin((1 - b) * h) / k;
    h = Math.sin(b * h) / k;
    this._w = f * g + this._w * h;
    this._x = c * g + this._x * h;
    this._y = d * g + this._y * h;
    this._z = e * g + this._z * h;
    this.onChangeCallback();
    return this;
  },
  equals: function (a) {
    return a._x === this._x && a._y === this._y && a._z === this._z && a._w === this._w;
  },
  fromArray: function (a) {
    this._x = a[0];
    this._y = a[1];
    this._z = a[2];
    this._w = a[3];
    this.onChangeCallback();
    return this;
  },
  toArray: function () {
    return [
      this._x,
      this._y,
      this._z,
      this._w
    ];
  },
  onChange: function (a) {
    this.onChangeCallback = a;
    return this;
  },
  onChangeCallback: function () {
  },
  clone: function () {
    return new THREE.Quaternion(this._x, this._y, this._z, this._w);
  }
};
THREE.Quaternion.slerp = function (a, b, c, d) {
  return c.copy(a).slerp(b, d);
};
THREE.Vector2 = function (a, b) {
  this.x = a || 0;
  this.y = b || 0;
};
THREE.Vector2.prototype = {
  constructor: THREE.Vector2,
  set: function (a, b) {
    this.x = a;
    this.y = b;
    return this;
  },
  setX: function (a) {
    this.x = a;
    return this;
  },
  setY: function (a) {
    this.y = a;
    return this;
  },
  setComponent: function (a, b) {
    switch (a) {
    case 0:
      this.x = b;
      break;
    case 1:
      this.y = b;
      break;
    default:
      throw Error('index is out of range: ' + a);
    }
  },
  getComponent: function (a) {
    switch (a) {
    case 0:
      return this.x;
    case 1:
      return this.y;
    default:
      throw Error('index is out of range: ' + a);
    }
  },
  copy: function (a) {
    this.x = a.x;
    this.y = a.y;
    return this;
  },
  add: function (a, b) {
    if (void 0 !== b)
      return console.warn('DEPRECATED: Vector2\'s .add() now only accepts one argument. Use .addVectors( a, b ) instead.'), this.addVectors(a, b);
    this.x += a.x;
    this.y += a.y;
    return this;
  },
  addVectors: function (a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    return this;
  },
  addScalar: function (a) {
    this.x += a;
    this.y += a;
    return this;
  },
  sub: function (a, b) {
    if (void 0 !== b)
      return console.warn('DEPRECATED: Vector2\'s .sub() now only accepts one argument. Use .subVectors( a, b ) instead.'), this.subVectors(a, b);
    this.x -= a.x;
    this.y -= a.y;
    return this;
  },
  subVectors: function (a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    return this;
  },
  multiply: function (a) {
    this.x *= a.x;
    this.y *= a.y;
    return this;
  },
  multiplyScalar: function (a) {
    this.x *= a;
    this.y *= a;
    return this;
  },
  divide: function (a) {
    this.x /= a.x;
    this.y /= a.y;
    return this;
  },
  divideScalar: function (a) {
    0 !== a ? (a = 1 / a, this.x *= a, this.y *= a) : this.y = this.x = 0;
    return this;
  },
  min: function (a) {
    this.x > a.x && (this.x = a.x);
    this.y > a.y && (this.y = a.y);
    return this;
  },
  max: function (a) {
    this.x < a.x && (this.x = a.x);
    this.y < a.y && (this.y = a.y);
    return this;
  },
  clamp: function (a, b) {
    this.x < a.x ? this.x = a.x : this.x > b.x && (this.x = b.x);
    this.y < a.y ? this.y = a.y : this.y > b.y && (this.y = b.y);
    return this;
  },
  clampScalar: function () {
    var a, b;
    return function (c, d) {
      void 0 === a && (a = new THREE.Vector2(), b = new THREE.Vector2());
      a.set(c, c);
      b.set(d, d);
      return this.clamp(a, b);
    };
  }(),
  floor: function () {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    return this;
  },
  ceil: function () {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    return this;
  },
  round: function () {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    return this;
  },
  roundToZero: function () {
    this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y);
    return this;
  },
  negate: function () {
    return this.multiplyScalar(-1);
  },
  dot: function (a) {
    return this.x * a.x + this.y * a.y;
  },
  lengthSq: function () {
    return this.x * this.x + this.y * this.y;
  },
  length: function () {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  },
  normalize: function () {
    return this.divideScalar(this.length());
  },
  distanceTo: function (a) {
    return Math.sqrt(this.distanceToSquared(a));
  },
  distanceToSquared: function (a) {
    var b = this.x - a.x;
    a = this.y - a.y;
    return b * b + a * a;
  },
  setLength: function (a) {
    var b = this.length();
    0 !== b && a !== b && this.multiplyScalar(a / b);
    return this;
  },
  lerp: function (a, b) {
    this.x += (a.x - this.x) * b;
    this.y += (a.y - this.y) * b;
    return this;
  },
  equals: function (a) {
    return a.x === this.x && a.y === this.y;
  },
  fromArray: function (a) {
    this.x = a[0];
    this.y = a[1];
    return this;
  },
  toArray: function () {
    return [
      this.x,
      this.y
    ];
  },
  clone: function () {
    return new THREE.Vector2(this.x, this.y);
  }
};
THREE.Vector3 = function (a, b, c) {
  this.x = a || 0;
  this.y = b || 0;
  this.z = c || 0;
};
THREE.Vector3.prototype = {
  constructor: THREE.Vector3,
  set: function (a, b, c) {
    this.x = a;
    this.y = b;
    this.z = c;
    return this;
  },
  setX: function (a) {
    this.x = a;
    return this;
  },
  setY: function (a) {
    this.y = a;
    return this;
  },
  setZ: function (a) {
    this.z = a;
    return this;
  },
  setComponent: function (a, b) {
    switch (a) {
    case 0:
      this.x = b;
      break;
    case 1:
      this.y = b;
      break;
    case 2:
      this.z = b;
      break;
    default:
      throw Error('index is out of range: ' + a);
    }
  },
  getComponent: function (a) {
    switch (a) {
    case 0:
      return this.x;
    case 1:
      return this.y;
    case 2:
      return this.z;
    default:
      throw Error('index is out of range: ' + a);
    }
  },
  copy: function (a) {
    this.x = a.x;
    this.y = a.y;
    this.z = a.z;
    return this;
  },
  add: function (a, b) {
    if (void 0 !== b)
      return console.warn('DEPRECATED: Vector3\'s .add() now only accepts one argument. Use .addVectors( a, b ) instead.'), this.addVectors(a, b);
    this.x += a.x;
    this.y += a.y;
    this.z += a.z;
    return this;
  },
  addScalar: function (a) {
    this.x += a;
    this.y += a;
    this.z += a;
    return this;
  },
  addVectors: function (a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;
    return this;
  },
  sub: function (a, b) {
    if (void 0 !== b)
      return console.warn('DEPRECATED: Vector3\'s .sub() now only accepts one argument. Use .subVectors( a, b ) instead.'), this.subVectors(a, b);
    this.x -= a.x;
    this.y -= a.y;
    this.z -= a.z;
    return this;
  },
  subVectors: function (a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;
    return this;
  },
  multiply: function (a, b) {
    if (void 0 !== b)
      return console.warn('DEPRECATED: Vector3\'s .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.'), this.multiplyVectors(a, b);
    this.x *= a.x;
    this.y *= a.y;
    this.z *= a.z;
    return this;
  },
  multiplyScalar: function (a) {
    this.x *= a;
    this.y *= a;
    this.z *= a;
    return this;
  },
  multiplyVectors: function (a, b) {
    this.x = a.x * b.x;
    this.y = a.y * b.y;
    this.z = a.z * b.z;
    return this;
  },
  applyEuler: function () {
    var a;
    return function (b) {
      !1 === b instanceof THREE.Euler && console.error('ERROR: Vector3\'s .applyEuler() now expects a Euler rotation rather than a Vector3 and order.  Please update your code.');
      void 0 === a && (a = new THREE.Quaternion());
      this.applyQuaternion(a.setFromEuler(b));
      return this;
    };
  }(),
  applyAxisAngle: function () {
    var a;
    return function (b, c) {
      void 0 === a && (a = new THREE.Quaternion());
      this.applyQuaternion(a.setFromAxisAngle(b, c));
      return this;
    };
  }(),
  applyMatrix3: function (a) {
    var b = this.x, c = this.y, d = this.z;
    a = a.elements;
    this.x = a[0] * b + a[3] * c + a[6] * d;
    this.y = a[1] * b + a[4] * c + a[7] * d;
    this.z = a[2] * b + a[5] * c + a[8] * d;
    return this;
  },
  applyMatrix4: function (a) {
    var b = this.x, c = this.y, d = this.z;
    a = a.elements;
    this.x = a[0] * b + a[4] * c + a[8] * d + a[12];
    this.y = a[1] * b + a[5] * c + a[9] * d + a[13];
    this.z = a[2] * b + a[6] * c + a[10] * d + a[14];
    return this;
  },
  applyProjection: function (a) {
    var b = this.x, c = this.y, d = this.z;
    a = a.elements;
    var e = 1 / (a[3] * b + a[7] * c + a[11] * d + a[15]);
    this.x = (a[0] * b + a[4] * c + a[8] * d + a[12]) * e;
    this.y = (a[1] * b + a[5] * c + a[9] * d + a[13]) * e;
    this.z = (a[2] * b + a[6] * c + a[10] * d + a[14]) * e;
    return this;
  },
  applyQuaternion: function (a) {
    var b = this.x, c = this.y, d = this.z, e = a.x, f = a.y, g = a.z;
    a = a.w;
    var h = a * b + f * d - g * c, k = a * c + g * b - e * d, l = a * d + e * c - f * b, b = -e * b - f * c - g * d;
    this.x = h * a + b * -e + k * -g - l * -f;
    this.y = k * a + b * -f + l * -e - h * -g;
    this.z = l * a + b * -g + h * -f - k * -e;
    return this;
  },
  transformDirection: function (a) {
    var b = this.x, c = this.y, d = this.z;
    a = a.elements;
    this.x = a[0] * b + a[4] * c + a[8] * d;
    this.y = a[1] * b + a[5] * c + a[9] * d;
    this.z = a[2] * b + a[6] * c + a[10] * d;
    this.normalize();
    return this;
  },
  divide: function (a) {
    this.x /= a.x;
    this.y /= a.y;
    this.z /= a.z;
    return this;
  },
  divideScalar: function (a) {
    0 !== a ? (a = 1 / a, this.x *= a, this.y *= a, this.z *= a) : this.z = this.y = this.x = 0;
    return this;
  },
  min: function (a) {
    this.x > a.x && (this.x = a.x);
    this.y > a.y && (this.y = a.y);
    this.z > a.z && (this.z = a.z);
    return this;
  },
  max: function (a) {
    this.x < a.x && (this.x = a.x);
    this.y < a.y && (this.y = a.y);
    this.z < a.z && (this.z = a.z);
    return this;
  },
  clamp: function (a, b) {
    this.x < a.x ? this.x = a.x : this.x > b.x && (this.x = b.x);
    this.y < a.y ? this.y = a.y : this.y > b.y && (this.y = b.y);
    this.z < a.z ? this.z = a.z : this.z > b.z && (this.z = b.z);
    return this;
  },
  clampScalar: function () {
    var a, b;
    return function (c, d) {
      void 0 === a && (a = new THREE.Vector3(), b = new THREE.Vector3());
      a.set(c, c, c);
      b.set(d, d, d);
      return this.clamp(a, b);
    };
  }(),
  floor: function () {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    return this;
  },
  ceil: function () {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    return this;
  },
  round: function () {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    return this;
  },
  roundToZero: function () {
    this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y);
    this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z);
    return this;
  },
  negate: function () {
    return this.multiplyScalar(-1);
  },
  dot: function (a) {
    return this.x * a.x + this.y * a.y + this.z * a.z;
  },
  lengthSq: function () {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  },
  length: function () {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  },
  lengthManhattan: function () {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  },
  normalize: function () {
    return this.divideScalar(this.length());
  },
  setLength: function (a) {
    var b = this.length();
    0 !== b && a !== b && this.multiplyScalar(a / b);
    return this;
  },
  lerp: function (a, b) {
    this.x += (a.x - this.x) * b;
    this.y += (a.y - this.y) * b;
    this.z += (a.z - this.z) * b;
    return this;
  },
  cross: function (a, b) {
    if (void 0 !== b)
      return console.warn('DEPRECATED: Vector3\'s .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.'), this.crossVectors(a, b);
    var c = this.x, d = this.y, e = this.z;
    this.x = d * a.z - e * a.y;
    this.y = e * a.x - c * a.z;
    this.z = c * a.y - d * a.x;
    return this;
  },
  crossVectors: function (a, b) {
    var c = a.x, d = a.y, e = a.z, f = b.x, g = b.y, h = b.z;
    this.x = d * h - e * g;
    this.y = e * f - c * h;
    this.z = c * g - d * f;
    return this;
  },
  projectOnVector: function () {
    var a, b;
    return function (c) {
      void 0 === a && (a = new THREE.Vector3());
      a.copy(c).normalize();
      b = this.dot(a);
      return this.copy(a).multiplyScalar(b);
    };
  }(),
  projectOnPlane: function () {
    var a;
    return function (b) {
      void 0 === a && (a = new THREE.Vector3());
      a.copy(this).projectOnVector(b);
      return this.sub(a);
    };
  }(),
  reflect: function () {
    var a;
    return function (b) {
      void 0 === a && (a = new THREE.Vector3());
      return this.sub(a.copy(b).multiplyScalar(2 * this.dot(b)));
    };
  }(),
  angleTo: function (a) {
    a = this.dot(a) / (this.length() * a.length());
    return Math.acos(THREE.Math.clamp(a, -1, 1));
  },
  distanceTo: function (a) {
    return Math.sqrt(this.distanceToSquared(a));
  },
  distanceToSquared: function (a) {
    var b = this.x - a.x, c = this.y - a.y;
    a = this.z - a.z;
    return b * b + c * c + a * a;
  },
  setEulerFromRotationMatrix: function (a, b) {
    console.error('REMOVED: Vector3\'s setEulerFromRotationMatrix has been removed in favor of Euler.setFromRotationMatrix(), please update your code.');
  },
  setEulerFromQuaternion: function (a, b) {
    console.error('REMOVED: Vector3\'s setEulerFromQuaternion: has been removed in favor of Euler.setFromQuaternion(), please update your code.');
  },
  getPositionFromMatrix: function (a) {
    console.warn('DEPRECATED: Vector3\'s .getPositionFromMatrix() has been renamed to .setFromMatrixPosition(). Please update your code.');
    return this.setFromMatrixPosition(a);
  },
  getScaleFromMatrix: function (a) {
    console.warn('DEPRECATED: Vector3\'s .getScaleFromMatrix() has been renamed to .setFromMatrixScale(). Please update your code.');
    return this.setFromMatrixScale(a);
  },
  getColumnFromMatrix: function (a, b) {
    console.warn('DEPRECATED: Vector3\'s .getColumnFromMatrix() has been renamed to .setFromMatrixColumn(). Please update your code.');
    return this.setFromMatrixColumn(a, b);
  },
  setFromMatrixPosition: function (a) {
    this.x = a.elements[12];
    this.y = a.elements[13];
    this.z = a.elements[14];
    return this;
  },
  setFromMatrixScale: function (a) {
    var b = this.set(a.elements[0], a.elements[1], a.elements[2]).length(), c = this.set(a.elements[4], a.elements[5], a.elements[6]).length();
    a = this.set(a.elements[8], a.elements[9], a.elements[10]).length();
    this.x = b;
    this.y = c;
    this.z = a;
    return this;
  },
  setFromMatrixColumn: function (a, b) {
    var c = 4 * a, d = b.elements;
    this.x = d[c];
    this.y = d[c + 1];
    this.z = d[c + 2];
    return this;
  },
  equals: function (a) {
    return a.x === this.x && a.y === this.y && a.z === this.z;
  },
  fromArray: function (a) {
    this.x = a[0];
    this.y = a[1];
    this.z = a[2];
    return this;
  },
  toArray: function () {
    return [
      this.x,
      this.y,
      this.z
    ];
  },
  clone: function () {
    return new THREE.Vector3(this.x, this.y, this.z);
  }
};
THREE.Vector4 = function (a, b, c, d) {
  this.x = a || 0;
  this.y = b || 0;
  this.z = c || 0;
  this.w = void 0 !== d ? d : 1;
};
THREE.Vector4.prototype = {
  constructor: THREE.Vector4,
  set: function (a, b, c, d) {
    this.x = a;
    this.y = b;
    this.z = c;
    this.w = d;
    return this;
  },
  setX: function (a) {
    this.x = a;
    return this;
  },
  setY: function (a) {
    this.y = a;
    return this;
  },
  setZ: function (a) {
    this.z = a;
    return this;
  },
  setW: function (a) {
    this.w = a;
    return this;
  },
  setComponent: function (a, b) {
    switch (a) {
    case 0:
      this.x = b;
      break;
    case 1:
      this.y = b;
      break;
    case 2:
      this.z = b;
      break;
    case 3:
      this.w = b;
      break;
    default:
      throw Error('index is out of range: ' + a);
    }
  },
  getComponent: function (a) {
    switch (a) {
    case 0:
      return this.x;
    case 1:
      return this.y;
    case 2:
      return this.z;
    case 3:
      return this.w;
    default:
      throw Error('index is out of range: ' + a);
    }
  },
  copy: function (a) {
    this.x = a.x;
    this.y = a.y;
    this.z = a.z;
    this.w = void 0 !== a.w ? a.w : 1;
    return this;
  },
  add: function (a, b) {
    if (void 0 !== b)
      return console.warn('DEPRECATED: Vector4\'s .add() now only accepts one argument. Use .addVectors( a, b ) instead.'), this.addVectors(a, b);
    this.x += a.x;
    this.y += a.y;
    this.z += a.z;
    this.w += a.w;
    return this;
  },
  addScalar: function (a) {
    this.x += a;
    this.y += a;
    this.z += a;
    this.w += a;
    return this;
  },
  addVectors: function (a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;
    this.w = a.w + b.w;
    return this;
  },
  sub: function (a, b) {
    if (void 0 !== b)
      return console.warn('DEPRECATED: Vector4\'s .sub() now only accepts one argument. Use .subVectors( a, b ) instead.'), this.subVectors(a, b);
    this.x -= a.x;
    this.y -= a.y;
    this.z -= a.z;
    this.w -= a.w;
    return this;
  },
  subVectors: function (a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;
    this.w = a.w - b.w;
    return this;
  },
  multiplyScalar: function (a) {
    this.x *= a;
    this.y *= a;
    this.z *= a;
    this.w *= a;
    return this;
  },
  applyMatrix4: function (a) {
    var b = this.x, c = this.y, d = this.z, e = this.w;
    a = a.elements;
    this.x = a[0] * b + a[4] * c + a[8] * d + a[12] * e;
    this.y = a[1] * b + a[5] * c + a[9] * d + a[13] * e;
    this.z = a[2] * b + a[6] * c + a[10] * d + a[14] * e;
    this.w = a[3] * b + a[7] * c + a[11] * d + a[15] * e;
    return this;
  },
  divideScalar: function (a) {
    0 !== a ? (a = 1 / a, this.x *= a, this.y *= a, this.z *= a, this.w *= a) : (this.z = this.y = this.x = 0, this.w = 1);
    return this;
  },
  setAxisAngleFromQuaternion: function (a) {
    this.w = 2 * Math.acos(a.w);
    var b = Math.sqrt(1 - a.w * a.w);
    0.0001 > b ? (this.x = 1, this.z = this.y = 0) : (this.x = a.x / b, this.y = a.y / b, this.z = a.z / b);
    return this;
  },
  setAxisAngleFromRotationMatrix: function (a) {
    var b, c, d;
    a = a.elements;
    var e = a[0];
    d = a[4];
    var f = a[8], g = a[1], h = a[5], k = a[9];
    c = a[2];
    b = a[6];
    var l = a[10];
    if (0.01 > Math.abs(d - g) && 0.01 > Math.abs(f - c) && 0.01 > Math.abs(k - b)) {
      if (0.1 > Math.abs(d + g) && 0.1 > Math.abs(f + c) && 0.1 > Math.abs(k + b) && 0.1 > Math.abs(e + h + l - 3))
        return this.set(1, 0, 0, 0), this;
      a = Math.PI;
      e = (e + 1) / 2;
      h = (h + 1) / 2;
      l = (l + 1) / 2;
      d = (d + g) / 4;
      f = (f + c) / 4;
      k = (k + b) / 4;
      e > h && e > l ? 0.01 > e ? (b = 0, d = c = 0.707106781) : (b = Math.sqrt(e), c = d / b, d = f / b) : h > l ? 0.01 > h ? (b = 0.707106781, c = 0, d = 0.707106781) : (c = Math.sqrt(h), b = d / c, d = k / c) : 0.01 > l ? (c = b = 0.707106781, d = 0) : (d = Math.sqrt(l), b = f / d, c = k / d);
      this.set(b, c, d, a);
      return this;
    }
    a = Math.sqrt((b - k) * (b - k) + (f - c) * (f - c) + (g - d) * (g - d));
    0.001 > Math.abs(a) && (a = 1);
    this.x = (b - k) / a;
    this.y = (f - c) / a;
    this.z = (g - d) / a;
    this.w = Math.acos((e + h + l - 1) / 2);
    return this;
  },
  min: function (a) {
    this.x > a.x && (this.x = a.x);
    this.y > a.y && (this.y = a.y);
    this.z > a.z && (this.z = a.z);
    this.w > a.w && (this.w = a.w);
    return this;
  },
  max: function (a) {
    this.x < a.x && (this.x = a.x);
    this.y < a.y && (this.y = a.y);
    this.z < a.z && (this.z = a.z);
    this.w < a.w && (this.w = a.w);
    return this;
  },
  clamp: function (a, b) {
    this.x < a.x ? this.x = a.x : this.x > b.x && (this.x = b.x);
    this.y < a.y ? this.y = a.y : this.y > b.y && (this.y = b.y);
    this.z < a.z ? this.z = a.z : this.z > b.z && (this.z = b.z);
    this.w < a.w ? this.w = a.w : this.w > b.w && (this.w = b.w);
    return this;
  },
  clampScalar: function () {
    var a, b;
    return function (c, d) {
      void 0 === a && (a = new THREE.Vector4(), b = new THREE.Vector4());
      a.set(c, c, c, c);
      b.set(d, d, d, d);
      return this.clamp(a, b);
    };
  }(),
  floor: function () {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    this.w = Math.floor(this.w);
    return this;
  },
  ceil: function () {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    this.w = Math.ceil(this.w);
    return this;
  },
  round: function () {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    this.w = Math.round(this.w);
    return this;
  },
  roundToZero: function () {
    this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y);
    this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z);
    this.w = 0 > this.w ? Math.ceil(this.w) : Math.floor(this.w);
    return this;
  },
  negate: function () {
    return this.multiplyScalar(-1);
  },
  dot: function (a) {
    return this.x * a.x + this.y * a.y + this.z * a.z + this.w * a.w;
  },
  lengthSq: function () {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  },
  length: function () {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  },
  lengthManhattan: function () {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  },
  normalize: function () {
    return this.divideScalar(this.length());
  },
  setLength: function (a) {
    var b = this.length();
    0 !== b && a !== b && this.multiplyScalar(a / b);
    return this;
  },
  lerp: function (a, b) {
    this.x += (a.x - this.x) * b;
    this.y += (a.y - this.y) * b;
    this.z += (a.z - this.z) * b;
    this.w += (a.w - this.w) * b;
    return this;
  },
  equals: function (a) {
    return a.x === this.x && a.y === this.y && a.z === this.z && a.w === this.w;
  },
  fromArray: function (a) {
    this.x = a[0];
    this.y = a[1];
    this.z = a[2];
    this.w = a[3];
    return this;
  },
  toArray: function () {
    return [
      this.x,
      this.y,
      this.z,
      this.w
    ];
  },
  clone: function () {
    return new THREE.Vector4(this.x, this.y, this.z, this.w);
  }
};
THREE.Euler = function (a, b, c, d) {
  this._x = a || 0;
  this._y = b || 0;
  this._z = c || 0;
  this._order = d || THREE.Euler.DefaultOrder;
};
THREE.Euler.RotationOrders = 'XYZ YZX ZXY XZY YXZ ZYX'.split(' ');
THREE.Euler.DefaultOrder = 'XYZ';
THREE.Euler.prototype = {
  constructor: THREE.Euler,
  _x: 0,
  _y: 0,
  _z: 0,
  _order: THREE.Euler.DefaultOrder,
  get x() {
    return this._x;
  },
  set x(a) {
    this._x = a;
    this.onChangeCallback();
  },
  get y() {
    return this._y;
  },
  set y(a) {
    this._y = a;
    this.onChangeCallback();
  },
  get z() {
    return this._z;
  },
  set z(a) {
    this._z = a;
    this.onChangeCallback();
  },
  get order() {
    return this._order;
  },
  set order(a) {
    this._order = a;
    this.onChangeCallback();
  },
  set: function (a, b, c, d) {
    this._x = a;
    this._y = b;
    this._z = c;
    this._order = d || this._order;
    this.onChangeCallback();
    return this;
  },
  copy: function (a) {
    this._x = a._x;
    this._y = a._y;
    this._z = a._z;
    this._order = a._order;
    this.onChangeCallback();
    return this;
  },
  setFromRotationMatrix: function (a, b) {
    var c = THREE.Math.clamp, d = a.elements, e = d[0], f = d[4], g = d[8], h = d[1], k = d[5], l = d[9], n = d[2], q = d[6], d = d[10];
    b = b || this._order;
    'XYZ' === b ? (this._y = Math.asin(c(g, -1, 1)), 0.99999 > Math.abs(g) ? (this._x = Math.atan2(-l, d), this._z = Math.atan2(-f, e)) : (this._x = Math.atan2(q, k), this._z = 0)) : 'YXZ' === b ? (this._x = Math.asin(-c(l, -1, 1)), 0.99999 > Math.abs(l) ? (this._y = Math.atan2(g, d), this._z = Math.atan2(h, k)) : (this._y = Math.atan2(-n, e), this._z = 0)) : 'ZXY' === b ? (this._x = Math.asin(c(q, -1, 1)), 0.99999 > Math.abs(q) ? (this._y = Math.atan2(-n, d), this._z = Math.atan2(-f, k)) : (this._y = 0, this._z = Math.atan2(h, e))) : 'ZYX' === b ? (this._y = Math.asin(-c(n, -1, 1)), 0.99999 > Math.abs(n) ? (this._x = Math.atan2(q, d), this._z = Math.atan2(h, e)) : (this._x = 0, this._z = Math.atan2(-f, k))) : 'YZX' === b ? (this._z = Math.asin(c(h, -1, 1)), 0.99999 > Math.abs(h) ? (this._x = Math.atan2(-l, k), this._y = Math.atan2(-n, e)) : (this._x = 0, this._y = Math.atan2(g, d))) : 'XZY' === b ? (this._z = Math.asin(-c(f, -1, 1)), 0.99999 > Math.abs(f) ? (this._x = Math.atan2(q, k), this._y = Math.atan2(g, e)) : (this._x = Math.atan2(-l, d), this._y = 0)) : console.warn('WARNING: Euler.setFromRotationMatrix() given unsupported order: ' + b);
    this._order = b;
    this.onChangeCallback();
    return this;
  },
  setFromQuaternion: function (a, b, c) {
    var d = THREE.Math.clamp, e = a.x * a.x, f = a.y * a.y, g = a.z * a.z, h = a.w * a.w;
    b = b || this._order;
    'XYZ' === b ? (this._x = Math.atan2(2 * (a.x * a.w - a.y * a.z), h - e - f + g), this._y = Math.asin(d(2 * (a.x * a.z + a.y * a.w), -1, 1)), this._z = Math.atan2(2 * (a.z * a.w - a.x * a.y), h + e - f - g)) : 'YXZ' === b ? (this._x = Math.asin(d(2 * (a.x * a.w - a.y * a.z), -1, 1)), this._y = Math.atan2(2 * (a.x * a.z + a.y * a.w), h - e - f + g), this._z = Math.atan2(2 * (a.x * a.y + a.z * a.w), h - e + f - g)) : 'ZXY' === b ? (this._x = Math.asin(d(2 * (a.x * a.w + a.y * a.z), -1, 1)), this._y = Math.atan2(2 * (a.y * a.w - a.z * a.x), h - e - f + g), this._z = Math.atan2(2 * (a.z * a.w - a.x * a.y), h - e + f - g)) : 'ZYX' === b ? (this._x = Math.atan2(2 * (a.x * a.w + a.z * a.y), h - e - f + g), this._y = Math.asin(d(2 * (a.y * a.w - a.x * a.z), -1, 1)), this._z = Math.atan2(2 * (a.x * a.y + a.z * a.w), h + e - f - g)) : 'YZX' === b ? (this._x = Math.atan2(2 * (a.x * a.w - a.z * a.y), h - e + f - g), this._y = Math.atan2(2 * (a.y * a.w - a.x * a.z), h + e - f - g), this._z = Math.asin(d(2 * (a.x * a.y + a.z * a.w), -1, 1))) : 'XZY' === b ? (this._x = Math.atan2(2 * (a.x * a.w + a.y * a.z), h - e + f - g), this._y = Math.atan2(2 * (a.x * a.z + a.y * a.w), h + e - f - g), this._z = Math.asin(d(2 * (a.z * a.w - a.x * a.y), -1, 1))) : console.warn('WARNING: Euler.setFromQuaternion() given unsupported order: ' + b);
    this._order = b;
    if (!1 !== c)
      this.onChangeCallback();
    return this;
  },
  reorder: function () {
    var a = new THREE.Quaternion();
    return function (b) {
      a.setFromEuler(this);
      this.setFromQuaternion(a, b);
    };
  }(),
  equals: function (a) {
    return a._x === this._x && a._y === this._y && a._z === this._z && a._order === this._order;
  },
  fromArray: function (a) {
    this._x = a[0];
    this._y = a[1];
    this._z = a[2];
    void 0 !== a[3] && (this._order = a[3]);
    this.onChangeCallback();
    return this;
  },
  toArray: function () {
    return [
      this._x,
      this._y,
      this._z,
      this._order
    ];
  },
  onChange: function (a) {
    this.onChangeCallback = a;
    return this;
  },
  onChangeCallback: function () {
  },
  clone: function () {
    return new THREE.Euler(this._x, this._y, this._z, this._order);
  }
};
THREE.Line3 = function (a, b) {
  this.start = void 0 !== a ? a : new THREE.Vector3();
  this.end = void 0 !== b ? b : new THREE.Vector3();
};
THREE.Line3.prototype = {
  constructor: THREE.Line3,
  set: function (a, b) {
    this.start.copy(a);
    this.end.copy(b);
    return this;
  },
  copy: function (a) {
    this.start.copy(a.start);
    this.end.copy(a.end);
    return this;
  },
  center: function (a) {
    return (a || new THREE.Vector3()).addVectors(this.start, this.end).multiplyScalar(0.5);
  },
  delta: function (a) {
    return (a || new THREE.Vector3()).subVectors(this.end, this.start);
  },
  distanceSq: function () {
    return this.start.distanceToSquared(this.end);
  },
  distance: function () {
    return this.start.distanceTo(this.end);
  },
  at: function (a, b) {
    var c = b || new THREE.Vector3();
    return this.delta(c).multiplyScalar(a).add(this.start);
  },
  closestPointToPointParameter: function () {
    var a = new THREE.Vector3(), b = new THREE.Vector3();
    return function (c, d) {
      a.subVectors(c, this.start);
      b.subVectors(this.end, this.start);
      var e = b.dot(b), e = b.dot(a) / e;
      d && (e = THREE.Math.clamp(e, 0, 1));
      return e;
    };
  }(),
  closestPointToPoint: function (a, b, c) {
    a = this.closestPointToPointParameter(a, b);
    c = c || new THREE.Vector3();
    return this.delta(c).multiplyScalar(a).add(this.start);
  },
  applyMatrix4: function (a) {
    this.start.applyMatrix4(a);
    this.end.applyMatrix4(a);
    return this;
  },
  equals: function (a) {
    return a.start.equals(this.start) && a.end.equals(this.end);
  },
  clone: function () {
    return new THREE.Line3().copy(this);
  }
};
THREE.Box2 = function (a, b) {
  this.min = void 0 !== a ? a : new THREE.Vector2(Infinity, Infinity);
  this.max = void 0 !== b ? b : new THREE.Vector2(-Infinity, -Infinity);
};
THREE.Box2.prototype = {
  constructor: THREE.Box2,
  set: function (a, b) {
    this.min.copy(a);
    this.max.copy(b);
    return this;
  },
  setFromPoints: function (a) {
    if (0 < a.length) {
      var b = a[0];
      this.min.copy(b);
      this.max.copy(b);
      for (var c = 1, d = a.length; c < d; c++)
        b = a[c], b.x < this.min.x ? this.min.x = b.x : b.x > this.max.x && (this.max.x = b.x), b.y < this.min.y ? this.min.y = b.y : b.y > this.max.y && (this.max.y = b.y);
    } else
      this.makeEmpty();
    return this;
  },
  setFromCenterAndSize: function () {
    var a = new THREE.Vector2();
    return function (b, c) {
      var d = a.copy(c).multiplyScalar(0.5);
      this.min.copy(b).sub(d);
      this.max.copy(b).add(d);
      return this;
    };
  }(),
  copy: function (a) {
    this.min.copy(a.min);
    this.max.copy(a.max);
    return this;
  },
  makeEmpty: function () {
    this.min.x = this.min.y = Infinity;
    this.max.x = this.max.y = -Infinity;
    return this;
  },
  empty: function () {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  },
  center: function (a) {
    return (a || new THREE.Vector2()).addVectors(this.min, this.max).multiplyScalar(0.5);
  },
  size: function (a) {
    return (a || new THREE.Vector2()).subVectors(this.max, this.min);
  },
  expandByPoint: function (a) {
    this.min.min(a);
    this.max.max(a);
    return this;
  },
  expandByVector: function (a) {
    this.min.sub(a);
    this.max.add(a);
    return this;
  },
  expandByScalar: function (a) {
    this.min.addScalar(-a);
    this.max.addScalar(a);
    return this;
  },
  containsPoint: function (a) {
    return a.x < this.min.x || a.x > this.max.x || a.y < this.min.y || a.y > this.max.y ? !1 : !0;
  },
  containsBox: function (a) {
    return this.min.x <= a.min.x && a.max.x <= this.max.x && this.min.y <= a.min.y && a.max.y <= this.max.y ? !0 : !1;
  },
  getParameter: function (a, b) {
    return (b || new THREE.Vector2()).set((a.x - this.min.x) / (this.max.x - this.min.x), (a.y - this.min.y) / (this.max.y - this.min.y));
  },
  isIntersectionBox: function (a) {
    return a.max.x < this.min.x || a.min.x > this.max.x || a.max.y < this.min.y || a.min.y > this.max.y ? !1 : !0;
  },
  clampPoint: function (a, b) {
    return (b || new THREE.Vector2()).copy(a).clamp(this.min, this.max);
  },
  distanceToPoint: function () {
    var a = new THREE.Vector2();
    return function (b) {
      return a.copy(b).clamp(this.min, this.max).sub(b).length();
    };
  }(),
  intersect: function (a) {
    this.min.max(a.min);
    this.max.min(a.max);
    return this;
  },
  union: function (a) {
    this.min.min(a.min);
    this.max.max(a.max);
    return this;
  },
  translate: function (a) {
    this.min.add(a);
    this.max.add(a);
    return this;
  },
  equals: function (a) {
    return a.min.equals(this.min) && a.max.equals(this.max);
  },
  clone: function () {
    return new THREE.Box2().copy(this);
  }
};
THREE.Box3 = function (a, b) {
  this.min = void 0 !== a ? a : new THREE.Vector3(Infinity, Infinity, Infinity);
  this.max = void 0 !== b ? b : new THREE.Vector3(-Infinity, -Infinity, -Infinity);
};
THREE.Box3.prototype = {
  constructor: THREE.Box3,
  set: function (a, b) {
    this.min.copy(a);
    this.max.copy(b);
    return this;
  },
  addPoint: function (a) {
    a.x < this.min.x ? this.min.x = a.x : a.x > this.max.x && (this.max.x = a.x);
    a.y < this.min.y ? this.min.y = a.y : a.y > this.max.y && (this.max.y = a.y);
    a.z < this.min.z ? this.min.z = a.z : a.z > this.max.z && (this.max.z = a.z);
    return this;
  },
  setFromPoints: function (a) {
    if (0 < a.length) {
      var b = a[0];
      this.min.copy(b);
      this.max.copy(b);
      for (var b = 1, c = a.length; b < c; b++)
        this.addPoint(a[b]);
    } else
      this.makeEmpty();
    return this;
  },
  setFromCenterAndSize: function () {
    var a = new THREE.Vector3();
    return function (b, c) {
      var d = a.copy(c).multiplyScalar(0.5);
      this.min.copy(b).sub(d);
      this.max.copy(b).add(d);
      return this;
    };
  }(),
  setFromObject: function () {
    var a = new THREE.Vector3();
    return function (b) {
      var c = this;
      b.updateMatrixWorld(!0);
      this.makeEmpty();
      b.traverse(function (b) {
        if (void 0 !== b.geometry && void 0 !== b.geometry.vertices)
          for (var e = b.geometry.vertices, f = 0, g = e.length; f < g; f++)
            a.copy(e[f]), a.applyMatrix4(b.matrixWorld), c.expandByPoint(a);
      });
      return this;
    };
  }(),
  copy: function (a) {
    this.min.copy(a.min);
    this.max.copy(a.max);
    return this;
  },
  makeEmpty: function () {
    this.min.x = this.min.y = this.min.z = Infinity;
    this.max.x = this.max.y = this.max.z = -Infinity;
    return this;
  },
  empty: function () {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  },
  center: function (a) {
    return (a || new THREE.Vector3()).addVectors(this.min, this.max).multiplyScalar(0.5);
  },
  size: function (a) {
    return (a || new THREE.Vector3()).subVectors(this.max, this.min);
  },
  expandByPoint: function (a) {
    this.min.min(a);
    this.max.max(a);
    return this;
  },
  expandByVector: function (a) {
    this.min.sub(a);
    this.max.add(a);
    return this;
  },
  expandByScalar: function (a) {
    this.min.addScalar(-a);
    this.max.addScalar(a);
    return this;
  },
  containsPoint: function (a) {
    return a.x < this.min.x || a.x > this.max.x || a.y < this.min.y || a.y > this.max.y || a.z < this.min.z || a.z > this.max.z ? !1 : !0;
  },
  containsBox: function (a) {
    return this.min.x <= a.min.x && a.max.x <= this.max.x && this.min.y <= a.min.y && a.max.y <= this.max.y && this.min.z <= a.min.z && a.max.z <= this.max.z ? !0 : !1;
  },
  getParameter: function (a, b) {
    return (b || new THREE.Vector3()).set((a.x - this.min.x) / (this.max.x - this.min.x), (a.y - this.min.y) / (this.max.y - this.min.y), (a.z - this.min.z) / (this.max.z - this.min.z));
  },
  isIntersectionBox: function (a) {
    return a.max.x < this.min.x || a.min.x > this.max.x || a.max.y < this.min.y || a.min.y > this.max.y || a.max.z < this.min.z || a.min.z > this.max.z ? !1 : !0;
  },
  clampPoint: function (a, b) {
    return (b || new THREE.Vector3()).copy(a).clamp(this.min, this.max);
  },
  distanceToPoint: function () {
    var a = new THREE.Vector3();
    return function (b) {
      return a.copy(b).clamp(this.min, this.max).sub(b).length();
    };
  }(),
  getBoundingSphere: function () {
    var a = new THREE.Vector3();
    return function (b) {
      b = b || new THREE.Sphere();
      b.center = this.center();
      b.radius = 0.5 * this.size(a).length();
      return b;
    };
  }(),
  intersect: function (a) {
    this.min.max(a.min);
    this.max.min(a.max);
    return this;
  },
  union: function (a) {
    this.min.min(a.min);
    this.max.max(a.max);
    return this;
  },
  applyMatrix4: function () {
    var a = [
        new THREE.Vector3(),
        new THREE.Vector3(),
        new THREE.Vector3(),
        new THREE.Vector3(),
        new THREE.Vector3(),
        new THREE.Vector3(),
        new THREE.Vector3(),
        new THREE.Vector3()
      ];
    return function (b) {
      a[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(b);
      a[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(b);
      a[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(b);
      a[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(b);
      a[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(b);
      a[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(b);
      a[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(b);
      a[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(b);
      this.makeEmpty();
      this.setFromPoints(a);
      return this;
    };
  }(),
  translate: function (a) {
    this.min.add(a);
    this.max.add(a);
    return this;
  },
  equals: function (a) {
    return a.min.equals(this.min) && a.max.equals(this.max);
  },
  clone: function () {
    return new THREE.Box3().copy(this);
  }
};
THREE.Matrix3 = function (a, b, c, d, e, f, g, h, k) {
  var l = this.elements = new Float32Array(9);
  l[0] = void 0 !== a ? a : 1;
  l[3] = b || 0;
  l[6] = c || 0;
  l[1] = d || 0;
  l[4] = void 0 !== e ? e : 1;
  l[7] = f || 0;
  l[2] = g || 0;
  l[5] = h || 0;
  l[8] = void 0 !== k ? k : 1;
};
THREE.Matrix3.prototype = {
  constructor: THREE.Matrix3,
  set: function (a, b, c, d, e, f, g, h, k) {
    var l = this.elements;
    l[0] = a;
    l[3] = b;
    l[6] = c;
    l[1] = d;
    l[4] = e;
    l[7] = f;
    l[2] = g;
    l[5] = h;
    l[8] = k;
    return this;
  },
  identity: function () {
    this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
    return this;
  },
  copy: function (a) {
    a = a.elements;
    this.set(a[0], a[3], a[6], a[1], a[4], a[7], a[2], a[5], a[8]);
    return this;
  },
  multiplyVector3: function (a) {
    console.warn('DEPRECATED: Matrix3\'s .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.');
    return a.applyMatrix3(this);
  },
  multiplyVector3Array: function (a) {
    console.warn('DEPRECATED: Matrix3\'s .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.');
    return this.applyToVector3Array(a);
  },
  applyToVector3Array: function () {
    var a = new THREE.Vector3();
    return function (b, c, d) {
      void 0 === c && (c = 0);
      void 0 === d && (d = b.length);
      for (var e = 0; e < d; e += 3, c += 3)
        a.x = b[c], a.y = b[c + 1], a.z = b[c + 2], a.applyMatrix3(this), b[c] = a.x, b[c + 1] = a.y, b[c + 2] = a.z;
      return b;
    };
  }(),
  multiplyScalar: function (a) {
    var b = this.elements;
    b[0] *= a;
    b[3] *= a;
    b[6] *= a;
    b[1] *= a;
    b[4] *= a;
    b[7] *= a;
    b[2] *= a;
    b[5] *= a;
    b[8] *= a;
    return this;
  },
  determinant: function () {
    var a = this.elements, b = a[0], c = a[1], d = a[2], e = a[3], f = a[4], g = a[5], h = a[6], k = a[7], a = a[8];
    return b * f * a - b * g * k - c * e * a + c * g * h + d * e * k - d * f * h;
  },
  getInverse: function (a, b) {
    var c = a.elements, d = this.elements;
    d[0] = c[10] * c[5] - c[6] * c[9];
    d[1] = -c[10] * c[1] + c[2] * c[9];
    d[2] = c[6] * c[1] - c[2] * c[5];
    d[3] = -c[10] * c[4] + c[6] * c[8];
    d[4] = c[10] * c[0] - c[2] * c[8];
    d[5] = -c[6] * c[0] + c[2] * c[4];
    d[6] = c[9] * c[4] - c[5] * c[8];
    d[7] = -c[9] * c[0] + c[1] * c[8];
    d[8] = c[5] * c[0] - c[1] * c[4];
    c = c[0] * d[0] + c[1] * d[3] + c[2] * d[6];
    if (0 === c) {
      if (b)
        throw Error('Matrix3.getInverse(): can\'t invert matrix, determinant is 0');
      console.warn('Matrix3.getInverse(): can\'t invert matrix, determinant is 0');
      this.identity();
      return this;
    }
    this.multiplyScalar(1 / c);
    return this;
  },
  transpose: function () {
    var a, b = this.elements;
    a = b[1];
    b[1] = b[3];
    b[3] = a;
    a = b[2];
    b[2] = b[6];
    b[6] = a;
    a = b[5];
    b[5] = b[7];
    b[7] = a;
    return this;
  },
  flattenToArrayOffset: function (a, b) {
    var c = this.elements;
    a[b] = c[0];
    a[b + 1] = c[1];
    a[b + 2] = c[2];
    a[b + 3] = c[3];
    a[b + 4] = c[4];
    a[b + 5] = c[5];
    a[b + 6] = c[6];
    a[b + 7] = c[7];
    a[b + 8] = c[8];
    return a;
  },
  getNormalMatrix: function (a) {
    this.getInverse(a).transpose();
    return this;
  },
  transposeIntoArray: function (a) {
    var b = this.elements;
    a[0] = b[0];
    a[1] = b[3];
    a[2] = b[6];
    a[3] = b[1];
    a[4] = b[4];
    a[5] = b[7];
    a[6] = b[2];
    a[7] = b[5];
    a[8] = b[8];
    return this;
  },
  fromArray: function (a) {
    this.elements.set(a);
    return this;
  },
  toArray: function () {
    var a = this.elements;
    return [
      a[0],
      a[1],
      a[2],
      a[3],
      a[4],
      a[5],
      a[6],
      a[7],
      a[8]
    ];
  },
  clone: function () {
    var a = this.elements;
    return new THREE.Matrix3(a[0], a[3], a[6], a[1], a[4], a[7], a[2], a[5], a[8]);
  }
};
THREE.Matrix4 = function (a, b, c, d, e, f, g, h, k, l, n, q, p, s, t, r) {
  var v = this.elements = new Float32Array(16);
  v[0] = void 0 !== a ? a : 1;
  v[4] = b || 0;
  v[8] = c || 0;
  v[12] = d || 0;
  v[1] = e || 0;
  v[5] = void 0 !== f ? f : 1;
  v[9] = g || 0;
  v[13] = h || 0;
  v[2] = k || 0;
  v[6] = l || 0;
  v[10] = void 0 !== n ? n : 1;
  v[14] = q || 0;
  v[3] = p || 0;
  v[7] = s || 0;
  v[11] = t || 0;
  v[15] = void 0 !== r ? r : 1;
};
THREE.Matrix4.prototype = {
  constructor: THREE.Matrix4,
  set: function (a, b, c, d, e, f, g, h, k, l, n, q, p, s, t, r) {
    var v = this.elements;
    v[0] = a;
    v[4] = b;
    v[8] = c;
    v[12] = d;
    v[1] = e;
    v[5] = f;
    v[9] = g;
    v[13] = h;
    v[2] = k;
    v[6] = l;
    v[10] = n;
    v[14] = q;
    v[3] = p;
    v[7] = s;
    v[11] = t;
    v[15] = r;
    return this;
  },
  identity: function () {
    this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    return this;
  },
  copy: function (a) {
    this.elements.set(a.elements);
    return this;
  },
  extractPosition: function (a) {
    console.warn('DEPRECATED: Matrix4\'s .extractPosition() has been renamed to .copyPosition().');
    return this.copyPosition(a);
  },
  copyPosition: function (a) {
    var b = this.elements;
    a = a.elements;
    b[12] = a[12];
    b[13] = a[13];
    b[14] = a[14];
    return this;
  },
  extractRotation: function () {
    var a = new THREE.Vector3();
    return function (b) {
      var c = this.elements;
      b = b.elements;
      var d = 1 / a.set(b[0], b[1], b[2]).length(), e = 1 / a.set(b[4], b[5], b[6]).length(), f = 1 / a.set(b[8], b[9], b[10]).length();
      c[0] = b[0] * d;
      c[1] = b[1] * d;
      c[2] = b[2] * d;
      c[4] = b[4] * e;
      c[5] = b[5] * e;
      c[6] = b[6] * e;
      c[8] = b[8] * f;
      c[9] = b[9] * f;
      c[10] = b[10] * f;
      return this;
    };
  }(),
  makeRotationFromEuler: function (a) {
    !1 === a instanceof THREE.Euler && console.error('ERROR: Matrix\'s .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.  Please update your code.');
    var b = this.elements, c = a.x, d = a.y, e = a.z, f = Math.cos(c), c = Math.sin(c), g = Math.cos(d), d = Math.sin(d), h = Math.cos(e), e = Math.sin(e);
    if ('XYZ' === a.order) {
      a = f * h;
      var k = f * e, l = c * h, n = c * e;
      b[0] = g * h;
      b[4] = -g * e;
      b[8] = d;
      b[1] = k + l * d;
      b[5] = a - n * d;
      b[9] = -c * g;
      b[2] = n - a * d;
      b[6] = l + k * d;
      b[10] = f * g;
    } else
      'YXZ' === a.order ? (a = g * h, k = g * e, l = d * h, n = d * e, b[0] = a + n * c, b[4] = l * c - k, b[8] = f * d, b[1] = f * e, b[5] = f * h, b[9] = -c, b[2] = k * c - l, b[6] = n + a * c, b[10] = f * g) : 'ZXY' === a.order ? (a = g * h, k = g * e, l = d * h, n = d * e, b[0] = a - n * c, b[4] = -f * e, b[8] = l + k * c, b[1] = k + l * c, b[5] = f * h, b[9] = n - a * c, b[2] = -f * d, b[6] = c, b[10] = f * g) : 'ZYX' === a.order ? (a = f * h, k = f * e, l = c * h, n = c * e, b[0] = g * h, b[4] = l * d - k, b[8] = a * d + n, b[1] = g * e, b[5] = n * d + a, b[9] = k * d - l, b[2] = -d, b[6] = c * g, b[10] = f * g) : 'YZX' === a.order ? (a = f * g, k = f * d, l = c * g, n = c * d, b[0] = g * h, b[4] = n - a * e, b[8] = l * e + k, b[1] = e, b[5] = f * h, b[9] = -c * h, b[2] = -d * h, b[6] = k * e + l, b[10] = a - n * e) : 'XZY' === a.order && (a = f * g, k = f * d, l = c * g, n = c * d, b[0] = g * h, b[4] = -e, b[8] = d * h, b[1] = a * e + n, b[5] = f * h, b[9] = k * e - l, b[2] = l * e - k, b[6] = c * h, b[10] = n * e + a);
    b[3] = 0;
    b[7] = 0;
    b[11] = 0;
    b[12] = 0;
    b[13] = 0;
    b[14] = 0;
    b[15] = 1;
    return this;
  },
  setRotationFromQuaternion: function (a) {
    console.warn('DEPRECATED: Matrix4\'s .setRotationFromQuaternion() has been deprecated in favor of makeRotationFromQuaternion.  Please update your code.');
    return this.makeRotationFromQuaternion(a);
  },
  makeRotationFromQuaternion: function (a) {
    var b = this.elements, c = a.x, d = a.y, e = a.z, f = a.w, g = c + c, h = d + d, k = e + e;
    a = c * g;
    var l = c * h, c = c * k, n = d * h, d = d * k, e = e * k, g = f * g, h = f * h, f = f * k;
    b[0] = 1 - (n + e);
    b[4] = l - f;
    b[8] = c + h;
    b[1] = l + f;
    b[5] = 1 - (a + e);
    b[9] = d - g;
    b[2] = c - h;
    b[6] = d + g;
    b[10] = 1 - (a + n);
    b[3] = 0;
    b[7] = 0;
    b[11] = 0;
    b[12] = 0;
    b[13] = 0;
    b[14] = 0;
    b[15] = 1;
    return this;
  },
  lookAt: function () {
    var a = new THREE.Vector3(), b = new THREE.Vector3(), c = new THREE.Vector3();
    return function (d, e, f) {
      var g = this.elements;
      c.subVectors(d, e).normalize();
      0 === c.length() && (c.z = 1);
      a.crossVectors(f, c).normalize();
      0 === a.length() && (c.x += 0.0001, a.crossVectors(f, c).normalize());
      b.crossVectors(c, a);
      g[0] = a.x;
      g[4] = b.x;
      g[8] = c.x;
      g[1] = a.y;
      g[5] = b.y;
      g[9] = c.y;
      g[2] = a.z;
      g[6] = b.z;
      g[10] = c.z;
      return this;
    };
  }(),
  multiply: function (a, b) {
    return void 0 !== b ? (console.warn('DEPRECATED: Matrix4\'s .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.'), this.multiplyMatrices(a, b)) : this.multiplyMatrices(this, a);
  },
  multiplyMatrices: function (a, b) {
    var c = a.elements, d = b.elements, e = this.elements, f = c[0], g = c[4], h = c[8], k = c[12], l = c[1], n = c[5], q = c[9], p = c[13], s = c[2], t = c[6], r = c[10], v = c[14], w = c[3], u = c[7], y = c[11], c = c[15], L = d[0], x = d[4], N = d[8], J = d[12], B = d[1], K = d[5], A = d[9], G = d[13], D = d[2], C = d[6], F = d[10], z = d[14], H = d[3], E = d[7], Q = d[11], d = d[15];
    e[0] = f * L + g * B + h * D + k * H;
    e[4] = f * x + g * K + h * C + k * E;
    e[8] = f * N + g * A + h * F + k * Q;
    e[12] = f * J + g * G + h * z + k * d;
    e[1] = l * L + n * B + q * D + p * H;
    e[5] = l * x + n * K + q * C + p * E;
    e[9] = l * N + n * A + q * F + p * Q;
    e[13] = l * J + n * G + q * z + p * d;
    e[2] = s * L + t * B + r * D + v * H;
    e[6] = s * x + t * K + r * C + v * E;
    e[10] = s * N + t * A + r * F + v * Q;
    e[14] = s * J + t * G + r * z + v * d;
    e[3] = w * L + u * B + y * D + c * H;
    e[7] = w * x + u * K + y * C + c * E;
    e[11] = w * N + u * A + y * F + c * Q;
    e[15] = w * J + u * G + y * z + c * d;
    return this;
  },
  multiplyToArray: function (a, b, c) {
    var d = this.elements;
    this.multiplyMatrices(a, b);
    c[0] = d[0];
    c[1] = d[1];
    c[2] = d[2];
    c[3] = d[3];
    c[4] = d[4];
    c[5] = d[5];
    c[6] = d[6];
    c[7] = d[7];
    c[8] = d[8];
    c[9] = d[9];
    c[10] = d[10];
    c[11] = d[11];
    c[12] = d[12];
    c[13] = d[13];
    c[14] = d[14];
    c[15] = d[15];
    return this;
  },
  multiplyScalar: function (a) {
    var b = this.elements;
    b[0] *= a;
    b[4] *= a;
    b[8] *= a;
    b[12] *= a;
    b[1] *= a;
    b[5] *= a;
    b[9] *= a;
    b[13] *= a;
    b[2] *= a;
    b[6] *= a;
    b[10] *= a;
    b[14] *= a;
    b[3] *= a;
    b[7] *= a;
    b[11] *= a;
    b[15] *= a;
    return this;
  },
  multiplyVector3: function (a) {
    console.warn('DEPRECATED: Matrix4\'s .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.');
    return a.applyProjection(this);
  },
  multiplyVector4: function (a) {
    console.warn('DEPRECATED: Matrix4\'s .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.');
    return a.applyMatrix4(this);
  },
  multiplyVector3Array: function (a) {
    console.warn('DEPRECATED: Matrix4\'s .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.');
    return this.applyToVector3Array(a);
  },
  applyToVector3Array: function () {
    var a = new THREE.Vector3();
    return function (b, c, d) {
      void 0 === c && (c = 0);
      void 0 === d && (d = b.length);
      for (var e = 0; e < d; e += 3, c += 3)
        a.x = b[c], a.y = b[c + 1], a.z = b[c + 2], a.applyMatrix4(this), b[c] = a.x, b[c + 1] = a.y, b[c + 2] = a.z;
      return b;
    };
  }(),
  rotateAxis: function (a) {
    console.warn('DEPRECATED: Matrix4\'s .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.');
    a.transformDirection(this);
  },
  crossVector: function (a) {
    console.warn('DEPRECATED: Matrix4\'s .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.');
    return a.applyMatrix4(this);
  },
  determinant: function () {
    var a = this.elements, b = a[0], c = a[4], d = a[8], e = a[12], f = a[1], g = a[5], h = a[9], k = a[13], l = a[2], n = a[6], q = a[10], p = a[14];
    return a[3] * (+e * h * n - d * k * n - e * g * q + c * k * q + d * g * p - c * h * p) + a[7] * (+b * h * p - b * k * q + e * f * q - d * f * p + d * k * l - e * h * l) + a[11] * (+b * k * n - b * g * p - e * f * n + c * f * p + e * g * l - c * k * l) + a[15] * (-d * g * l - b * h * n + b * g * q + d * f * n - c * f * q + c * h * l);
  },
  transpose: function () {
    var a = this.elements, b;
    b = a[1];
    a[1] = a[4];
    a[4] = b;
    b = a[2];
    a[2] = a[8];
    a[8] = b;
    b = a[6];
    a[6] = a[9];
    a[9] = b;
    b = a[3];
    a[3] = a[12];
    a[12] = b;
    b = a[7];
    a[7] = a[13];
    a[13] = b;
    b = a[11];
    a[11] = a[14];
    a[14] = b;
    return this;
  },
  flattenToArrayOffset: function (a, b) {
    var c = this.elements;
    a[b] = c[0];
    a[b + 1] = c[1];
    a[b + 2] = c[2];
    a[b + 3] = c[3];
    a[b + 4] = c[4];
    a[b + 5] = c[5];
    a[b + 6] = c[6];
    a[b + 7] = c[7];
    a[b + 8] = c[8];
    a[b + 9] = c[9];
    a[b + 10] = c[10];
    a[b + 11] = c[11];
    a[b + 12] = c[12];
    a[b + 13] = c[13];
    a[b + 14] = c[14];
    a[b + 15] = c[15];
    return a;
  },
  getPosition: function () {
    var a = new THREE.Vector3();
    return function () {
      console.warn('DEPRECATED: Matrix4\'s .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.');
      var b = this.elements;
      return a.set(b[12], b[13], b[14]);
    };
  }(),
  setPosition: function (a) {
    var b = this.elements;
    b[12] = a.x;
    b[13] = a.y;
    b[14] = a.z;
    return this;
  },
  getInverse: function (a, b) {
    var c = this.elements, d = a.elements, e = d[0], f = d[4], g = d[8], h = d[12], k = d[1], l = d[5], n = d[9], q = d[13], p = d[2], s = d[6], t = d[10], r = d[14], v = d[3], w = d[7], u = d[11], d = d[15];
    c[0] = n * r * w - q * t * w + q * s * u - l * r * u - n * s * d + l * t * d;
    c[4] = h * t * w - g * r * w - h * s * u + f * r * u + g * s * d - f * t * d;
    c[8] = g * q * w - h * n * w + h * l * u - f * q * u - g * l * d + f * n * d;
    c[12] = h * n * s - g * q * s - h * l * t + f * q * t + g * l * r - f * n * r;
    c[1] = q * t * v - n * r * v - q * p * u + k * r * u + n * p * d - k * t * d;
    c[5] = g * r * v - h * t * v + h * p * u - e * r * u - g * p * d + e * t * d;
    c[9] = h * n * v - g * q * v - h * k * u + e * q * u + g * k * d - e * n * d;
    c[13] = g * q * p - h * n * p + h * k * t - e * q * t - g * k * r + e * n * r;
    c[2] = l * r * v - q * s * v + q * p * w - k * r * w - l * p * d + k * s * d;
    c[6] = h * s * v - f * r * v - h * p * w + e * r * w + f * p * d - e * s * d;
    c[10] = f * q * v - h * l * v + h * k * w - e * q * w - f * k * d + e * l * d;
    c[14] = h * l * p - f * q * p - h * k * s + e * q * s + f * k * r - e * l * r;
    c[3] = n * s * v - l * t * v - n * p * w + k * t * w + l * p * u - k * s * u;
    c[7] = f * t * v - g * s * v + g * p * w - e * t * w - f * p * u + e * s * u;
    c[11] = g * l * v - f * n * v - g * k * w + e * n * w + f * k * u - e * l * u;
    c[15] = f * n * p - g * l * p + g * k * s - e * n * s - f * k * t + e * l * t;
    c = e * c[0] + k * c[4] + p * c[8] + v * c[12];
    if (0 == c) {
      if (b)
        throw Error('Matrix4.getInverse(): can\'t invert matrix, determinant is 0');
      console.warn('Matrix4.getInverse(): can\'t invert matrix, determinant is 0');
      this.identity();
      return this;
    }
    this.multiplyScalar(1 / c);
    return this;
  },
  translate: function (a) {
    console.warn('DEPRECATED: Matrix4\'s .translate() has been removed.');
  },
  rotateX: function (a) {
    console.warn('DEPRECATED: Matrix4\'s .rotateX() has been removed.');
  },
  rotateY: function (a) {
    console.warn('DEPRECATED: Matrix4\'s .rotateY() has been removed.');
  },
  rotateZ: function (a) {
    console.warn('DEPRECATED: Matrix4\'s .rotateZ() has been removed.');
  },
  rotateByAxis: function (a, b) {
    console.warn('DEPRECATED: Matrix4\'s .rotateByAxis() has been removed.');
  },
  scale: function (a) {
    var b = this.elements, c = a.x, d = a.y;
    a = a.z;
    b[0] *= c;
    b[4] *= d;
    b[8] *= a;
    b[1] *= c;
    b[5] *= d;
    b[9] *= a;
    b[2] *= c;
    b[6] *= d;
    b[10] *= a;
    b[3] *= c;
    b[7] *= d;
    b[11] *= a;
    return this;
  },
  getMaxScaleOnAxis: function () {
    var a = this.elements;
    return Math.sqrt(Math.max(a[0] * a[0] + a[1] * a[1] + a[2] * a[2], Math.max(a[4] * a[4] + a[5] * a[5] + a[6] * a[6], a[8] * a[8] + a[9] * a[9] + a[10] * a[10])));
  },
  makeTranslation: function (a, b, c) {
    this.set(1, 0, 0, a, 0, 1, 0, b, 0, 0, 1, c, 0, 0, 0, 1);
    return this;
  },
  makeRotationX: function (a) {
    var b = Math.cos(a);
    a = Math.sin(a);
    this.set(1, 0, 0, 0, 0, b, -a, 0, 0, a, b, 0, 0, 0, 0, 1);
    return this;
  },
  makeRotationY: function (a) {
    var b = Math.cos(a);
    a = Math.sin(a);
    this.set(b, 0, a, 0, 0, 1, 0, 0, -a, 0, b, 0, 0, 0, 0, 1);
    return this;
  },
  makeRotationZ: function (a) {
    var b = Math.cos(a);
    a = Math.sin(a);
    this.set(b, -a, 0, 0, a, b, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    return this;
  },
  makeRotationAxis: function (a, b) {
    var c = Math.cos(b), d = Math.sin(b), e = 1 - c, f = a.x, g = a.y, h = a.z, k = e * f, l = e * g;
    this.set(k * f + c, k * g - d * h, k * h + d * g, 0, k * g + d * h, l * g + c, l * h - d * f, 0, k * h - d * g, l * h + d * f, e * h * h + c, 0, 0, 0, 0, 1);
    return this;
  },
  makeScale: function (a, b, c) {
    this.set(a, 0, 0, 0, 0, b, 0, 0, 0, 0, c, 0, 0, 0, 0, 1);
    return this;
  },
  compose: function (a, b, c) {
    this.makeRotationFromQuaternion(b);
    this.scale(c);
    this.setPosition(a);
    return this;
  },
  decompose: function () {
    var a = new THREE.Vector3(), b = new THREE.Matrix4();
    return function (c, d, e) {
      var f = this.elements, g = a.set(f[0], f[1], f[2]).length(), h = a.set(f[4], f[5], f[6]).length(), k = a.set(f[8], f[9], f[10]).length();
      0 > this.determinant() && (g = -g);
      c.x = f[12];
      c.y = f[13];
      c.z = f[14];
      b.elements.set(this.elements);
      c = 1 / g;
      var f = 1 / h, l = 1 / k;
      b.elements[0] *= c;
      b.elements[1] *= c;
      b.elements[2] *= c;
      b.elements[4] *= f;
      b.elements[5] *= f;
      b.elements[6] *= f;
      b.elements[8] *= l;
      b.elements[9] *= l;
      b.elements[10] *= l;
      d.setFromRotationMatrix(b);
      e.x = g;
      e.y = h;
      e.z = k;
      return this;
    };
  }(),
  makeFrustum: function (a, b, c, d, e, f) {
    var g = this.elements;
    g[0] = 2 * e / (b - a);
    g[4] = 0;
    g[8] = (b + a) / (b - a);
    g[12] = 0;
    g[1] = 0;
    g[5] = 2 * e / (d - c);
    g[9] = (d + c) / (d - c);
    g[13] = 0;
    g[2] = 0;
    g[6] = 0;
    g[10] = -(f + e) / (f - e);
    g[14] = -2 * f * e / (f - e);
    g[3] = 0;
    g[7] = 0;
    g[11] = -1;
    g[15] = 0;
    return this;
  },
  makePerspective: function (a, b, c, d) {
    a = c * Math.tan(THREE.Math.degToRad(0.5 * a));
    var e = -a;
    return this.makeFrustum(e * b, a * b, e, a, c, d);
  },
  makeOrthographic: function (a, b, c, d, e, f) {
    var g = this.elements, h = b - a, k = c - d, l = f - e;
    g[0] = 2 / h;
    g[4] = 0;
    g[8] = 0;
    g[12] = -((b + a) / h);
    g[1] = 0;
    g[5] = 2 / k;
    g[9] = 0;
    g[13] = -((c + d) / k);
    g[2] = 0;
    g[6] = 0;
    g[10] = -2 / l;
    g[14] = -((f + e) / l);
    g[3] = 0;
    g[7] = 0;
    g[11] = 0;
    g[15] = 1;
    return this;
  },
  fromArray: function (a) {
    this.elements.set(a);
    return this;
  },
  toArray: function () {
    var a = this.elements;
    return [
      a[0],
      a[1],
      a[2],
      a[3],
      a[4],
      a[5],
      a[6],
      a[7],
      a[8],
      a[9],
      a[10],
      a[11],
      a[12],
      a[13],
      a[14],
      a[15]
    ];
  },
  clone: function () {
    var a = this.elements;
    return new THREE.Matrix4(a[0], a[4], a[8], a[12], a[1], a[5], a[9], a[13], a[2], a[6], a[10], a[14], a[3], a[7], a[11], a[15]);
  }
};
THREE.Ray = function (a, b) {
  this.origin = void 0 !== a ? a : new THREE.Vector3();
  this.direction = void 0 !== b ? b : new THREE.Vector3();
};
THREE.Ray.prototype = {
  constructor: THREE.Ray,
  set: function (a, b) {
    this.origin.copy(a);
    this.direction.copy(b);
    return this;
  },
  copy: function (a) {
    this.origin.copy(a.origin);
    this.direction.copy(a.direction);
    return this;
  },
  at: function (a, b) {
    return (b || new THREE.Vector3()).copy(this.direction).multiplyScalar(a).add(this.origin);
  },
  recast: function () {
    var a = new THREE.Vector3();
    return function (b) {
      this.origin.copy(this.at(b, a));
      return this;
    };
  }(),
  closestPointToPoint: function (a, b) {
    var c = b || new THREE.Vector3();
    c.subVectors(a, this.origin);
    var d = c.dot(this.direction);
    return 0 > d ? c.copy(this.origin) : c.copy(this.direction).multiplyScalar(d).add(this.origin);
  },
  distanceToPoint: function () {
    var a = new THREE.Vector3();
    return function (b) {
      var c = a.subVectors(b, this.origin).dot(this.direction);
      if (0 > c)
        return this.origin.distanceTo(b);
      a.copy(this.direction).multiplyScalar(c).add(this.origin);
      return a.distanceTo(b);
    };
  }(),
  distanceSqToSegment: function (a, b, c, d) {
    var e = a.clone().add(b).multiplyScalar(0.5), f = b.clone().sub(a).normalize(), g = 0.5 * a.distanceTo(b), h = this.origin.clone().sub(e);
    a = -this.direction.dot(f);
    b = h.dot(this.direction);
    var k = -h.dot(f), l = h.lengthSq(), n = Math.abs(1 - a * a), q, p;
    0 <= n ? (h = a * k - b, q = a * b - k, p = g * n, 0 <= h ? q >= -p ? q <= p ? (g = 1 / n, h *= g, q *= g, a = h * (h + a * q + 2 * b) + q * (a * h + q + 2 * k) + l) : (q = g, h = Math.max(0, -(a * q + b)), a = -h * h + q * (q + 2 * k) + l) : (q = -g, h = Math.max(0, -(a * q + b)), a = -h * h + q * (q + 2 * k) + l) : q <= -p ? (h = Math.max(0, -(-a * g + b)), q = 0 < h ? -g : Math.min(Math.max(-g, -k), g), a = -h * h + q * (q + 2 * k) + l) : q <= p ? (h = 0, q = Math.min(Math.max(-g, -k), g), a = q * (q + 2 * k) + l) : (h = Math.max(0, -(a * g + b)), q = 0 < h ? g : Math.min(Math.max(-g, -k), g), a = -h * h + q * (q + 2 * k) + l)) : (q = 0 < a ? -g : g, h = Math.max(0, -(a * q + b)), a = -h * h + q * (q + 2 * k) + l);
    c && c.copy(this.direction.clone().multiplyScalar(h).add(this.origin));
    d && d.copy(f.clone().multiplyScalar(q).add(e));
    return a;
  },
  isIntersectionSphere: function (a) {
    return this.distanceToPoint(a.center) <= a.radius;
  },
  isIntersectionPlane: function (a) {
    var b = a.distanceToPoint(this.origin);
    return 0 === b || 0 > a.normal.dot(this.direction) * b ? !0 : !1;
  },
  distanceToPlane: function (a) {
    var b = a.normal.dot(this.direction);
    if (0 == b)
      return 0 == a.distanceToPoint(this.origin) ? 0 : null;
    a = -(this.origin.dot(a.normal) + a.constant) / b;
    return 0 <= a ? a : null;
  },
  intersectPlane: function (a, b) {
    var c = this.distanceToPlane(a);
    return null === c ? null : this.at(c, b);
  },
  isIntersectionBox: function () {
    var a = new THREE.Vector3();
    return function (b) {
      return null !== this.intersectBox(b, a);
    };
  }(),
  intersectBox: function (a, b) {
    var c, d, e, f, g;
    d = 1 / this.direction.x;
    f = 1 / this.direction.y;
    g = 1 / this.direction.z;
    var h = this.origin;
    0 <= d ? (c = (a.min.x - h.x) * d, d *= a.max.x - h.x) : (c = (a.max.x - h.x) * d, d *= a.min.x - h.x);
    0 <= f ? (e = (a.min.y - h.y) * f, f *= a.max.y - h.y) : (e = (a.max.y - h.y) * f, f *= a.min.y - h.y);
    if (c > f || e > d)
      return null;
    if (e > c || c !== c)
      c = e;
    if (f < d || d !== d)
      d = f;
    0 <= g ? (e = (a.min.z - h.z) * g, g *= a.max.z - h.z) : (e = (a.max.z - h.z) * g, g *= a.min.z - h.z);
    if (c > g || e > d)
      return null;
    if (e > c || c !== c)
      c = e;
    if (g < d || d !== d)
      d = g;
    return 0 > d ? null : this.at(0 <= c ? c : d, b);
  },
  intersectTriangle: function () {
    var a = new THREE.Vector3(), b = new THREE.Vector3(), c = new THREE.Vector3(), d = new THREE.Vector3();
    return function (e, f, g, h, k) {
      b.subVectors(f, e);
      c.subVectors(g, e);
      d.crossVectors(b, c);
      f = this.direction.dot(d);
      if (0 < f) {
        if (h)
          return null;
        h = 1;
      } else if (0 > f)
        h = -1, f = -f;
      else
        return null;
      a.subVectors(this.origin, e);
      e = h * this.direction.dot(c.crossVectors(a, c));
      if (0 > e)
        return null;
      g = h * this.direction.dot(b.cross(a));
      if (0 > g || e + g > f)
        return null;
      e = -h * a.dot(d);
      return 0 > e ? null : this.at(e / f, k);
    };
  }(),
  applyMatrix4: function (a) {
    this.direction.add(this.origin).applyMatrix4(a);
    this.origin.applyMatrix4(a);
    this.direction.sub(this.origin);
    this.direction.normalize();
    return this;
  },
  equals: function (a) {
    return a.origin.equals(this.origin) && a.direction.equals(this.direction);
  },
  clone: function () {
    return new THREE.Ray().copy(this);
  }
};
THREE.Sphere = function (a, b) {
  this.center = void 0 !== a ? a : new THREE.Vector3();
  this.radius = void 0 !== b ? b : 0;
};
THREE.Sphere.prototype = {
  constructor: THREE.Sphere,
  set: function (a, b) {
    this.center.copy(a);
    this.radius = b;
    return this;
  },
  setFromPoints: function () {
    var a = new THREE.Box3();
    return function (b, c) {
      var d = this.center;
      void 0 !== c ? d.copy(c) : a.setFromPoints(b).center(d);
      for (var e = 0, f = 0, g = b.length; f < g; f++)
        e = Math.max(e, d.distanceToSquared(b[f]));
      this.radius = Math.sqrt(e);
      return this;
    };
  }(),
  copy: function (a) {
    this.center.copy(a.center);
    this.radius = a.radius;
    return this;
  },
  empty: function () {
    return 0 >= this.radius;
  },
  containsPoint: function (a) {
    return a.distanceToSquared(this.center) <= this.radius * this.radius;
  },
  distanceToPoint: function (a) {
    return a.distanceTo(this.center) - this.radius;
  },
  intersectsSphere: function (a) {
    var b = this.radius + a.radius;
    return a.center.distanceToSquared(this.center) <= b * b;
  },
  clampPoint: function (a, b) {
    var c = this.center.distanceToSquared(a), d = b || new THREE.Vector3();
    d.copy(a);
    c > this.radius * this.radius && (d.sub(this.center).normalize(), d.multiplyScalar(this.radius).add(this.center));
    return d;
  },
  getBoundingBox: function (a) {
    a = a || new THREE.Box3();
    a.set(this.center, this.center);
    a.expandByScalar(this.radius);
    return a;
  },
  applyMatrix4: function (a) {
    this.center.applyMatrix4(a);
    this.radius *= a.getMaxScaleOnAxis();
    return this;
  },
  translate: function (a) {
    this.center.add(a);
    return this;
  },
  equals: function (a) {
    return a.center.equals(this.center) && a.radius === this.radius;
  },
  clone: function () {
    return new THREE.Sphere().copy(this);
  }
};
THREE.Frustum = function (a, b, c, d, e, f) {
  this.planes = [
    void 0 !== a ? a : new THREE.Plane(),
    void 0 !== b ? b : new THREE.Plane(),
    void 0 !== c ? c : new THREE.Plane(),
    void 0 !== d ? d : new THREE.Plane(),
    void 0 !== e ? e : new THREE.Plane(),
    void 0 !== f ? f : new THREE.Plane()
  ];
};
THREE.Frustum.prototype = {
  constructor: THREE.Frustum,
  set: function (a, b, c, d, e, f) {
    var g = this.planes;
    g[0].copy(a);
    g[1].copy(b);
    g[2].copy(c);
    g[3].copy(d);
    g[4].copy(e);
    g[5].copy(f);
    return this;
  },
  copy: function (a) {
    for (var b = this.planes, c = 0; 6 > c; c++)
      b[c].copy(a.planes[c]);
    return this;
  },
  setFromMatrix: function (a) {
    var b = this.planes, c = a.elements;
    a = c[0];
    var d = c[1], e = c[2], f = c[3], g = c[4], h = c[5], k = c[6], l = c[7], n = c[8], q = c[9], p = c[10], s = c[11], t = c[12], r = c[13], v = c[14], c = c[15];
    b[0].setComponents(f - a, l - g, s - n, c - t).normalize();
    b[1].setComponents(f + a, l + g, s + n, c + t).normalize();
    b[2].setComponents(f + d, l + h, s + q, c + r).normalize();
    b[3].setComponents(f - d, l - h, s - q, c - r).normalize();
    b[4].setComponents(f - e, l - k, s - p, c - v).normalize();
    b[5].setComponents(f + e, l + k, s + p, c + v).normalize();
    return this;
  },
  intersectsObject: function () {
    var a = new THREE.Sphere();
    return function (b) {
      var c = b.geometry;
      null === c.boundingSphere && c.computeBoundingSphere();
      a.copy(c.boundingSphere);
      a.applyMatrix4(b.matrixWorld);
      return this.intersectsSphere(a);
    };
  }(),
  intersectsSphere: function (a) {
    var b = this.planes, c = a.center;
    a = -a.radius;
    for (var d = 0; 6 > d; d++)
      if (b[d].distanceToPoint(c) < a)
        return !1;
    return !0;
  },
  intersectsBox: function () {
    var a = new THREE.Vector3(), b = new THREE.Vector3();
    return function (c) {
      for (var d = this.planes, e = 0; 6 > e; e++) {
        var f = d[e];
        a.x = 0 < f.normal.x ? c.min.x : c.max.x;
        b.x = 0 < f.normal.x ? c.max.x : c.min.x;
        a.y = 0 < f.normal.y ? c.min.y : c.max.y;
        b.y = 0 < f.normal.y ? c.max.y : c.min.y;
        a.z = 0 < f.normal.z ? c.min.z : c.max.z;
        b.z = 0 < f.normal.z ? c.max.z : c.min.z;
        var g = f.distanceToPoint(a), f = f.distanceToPoint(b);
        if (0 > g && 0 > f)
          return !1;
      }
      return !0;
    };
  }(),
  containsPoint: function (a) {
    for (var b = this.planes, c = 0; 6 > c; c++)
      if (0 > b[c].distanceToPoint(a))
        return !1;
    return !0;
  },
  clone: function () {
    return new THREE.Frustum().copy(this);
  }
};
THREE.Plane = function (a, b) {
  this.normal = void 0 !== a ? a : new THREE.Vector3(1, 0, 0);
  this.constant = void 0 !== b ? b : 0;
};
THREE.Plane.prototype = {
  constructor: THREE.Plane,
  set: function (a, b) {
    this.normal.copy(a);
    this.constant = b;
    return this;
  },
  setComponents: function (a, b, c, d) {
    this.normal.set(a, b, c);
    this.constant = d;
    return this;
  },
  setFromNormalAndCoplanarPoint: function (a, b) {
    this.normal.copy(a);
    this.constant = -b.dot(this.normal);
    return this;
  },
  setFromCoplanarPoints: function () {
    var a = new THREE.Vector3(), b = new THREE.Vector3();
    return function (c, d, e) {
      d = a.subVectors(e, d).cross(b.subVectors(c, d)).normalize();
      this.setFromNormalAndCoplanarPoint(d, c);
      return this;
    };
  }(),
  copy: function (a) {
    this.normal.copy(a.normal);
    this.constant = a.constant;
    return this;
  },
  normalize: function () {
    var a = 1 / this.normal.length();
    this.normal.multiplyScalar(a);
    this.constant *= a;
    return this;
  },
  negate: function () {
    this.constant *= -1;
    this.normal.negate();
    return this;
  },
  distanceToPoint: function (a) {
    return this.normal.dot(a) + this.constant;
  },
  distanceToSphere: function (a) {
    return this.distanceToPoint(a.center) - a.radius;
  },
  projectPoint: function (a, b) {
    return this.orthoPoint(a, b).sub(a).negate();
  },
  orthoPoint: function (a, b) {
    var c = this.distanceToPoint(a);
    return (b || new THREE.Vector3()).copy(this.normal).multiplyScalar(c);
  },
  isIntersectionLine: function (a) {
    var b = this.distanceToPoint(a.start);
    a = this.distanceToPoint(a.end);
    return 0 > b && 0 < a || 0 > a && 0 < b;
  },
  intersectLine: function () {
    var a = new THREE.Vector3();
    return function (b, c) {
      var d = c || new THREE.Vector3(), e = b.delta(a), f = this.normal.dot(e);
      if (0 == f) {
        if (0 == this.distanceToPoint(b.start))
          return d.copy(b.start);
      } else
        return f = -(b.start.dot(this.normal) + this.constant) / f, 0 > f || 1 < f ? void 0 : d.copy(e).multiplyScalar(f).add(b.start);
    };
  }(),
  coplanarPoint: function (a) {
    return (a || new THREE.Vector3()).copy(this.normal).multiplyScalar(-this.constant);
  },
  applyMatrix4: function () {
    var a = new THREE.Vector3(), b = new THREE.Vector3(), c = new THREE.Matrix3();
    return function (d, e) {
      var f = e || c.getNormalMatrix(d), f = a.copy(this.normal).applyMatrix3(f), g = this.coplanarPoint(b);
      g.applyMatrix4(d);
      this.setFromNormalAndCoplanarPoint(f, g);
      return this;
    };
  }(),
  translate: function (a) {
    this.constant -= a.dot(this.normal);
    return this;
  },
  equals: function (a) {
    return a.normal.equals(this.normal) && a.constant == this.constant;
  },
  clone: function () {
    return new THREE.Plane().copy(this);
  }
};
THREE.Math = {
  generateUUID: function () {
    var a = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split(''), b = Array(36), c = 0, d;
    return function () {
      for (var e = 0; 36 > e; e++)
        8 == e || 13 == e || 18 == e || 23 == e ? b[e] = '-' : 14 == e ? b[e] = '4' : (2 >= c && (c = 33554432 + 16777216 * Math.random() | 0), d = c & 15, c >>= 4, b[e] = a[19 == e ? d & 3 | 8 : d]);
      return b.join('');
    };
  }(),
  clamp: function (a, b, c) {
    return a < b ? b : a > c ? c : a;
  },
  clampBottom: function (a, b) {
    return a < b ? b : a;
  },
  mapLinear: function (a, b, c, d, e) {
    return d + (a - b) * (e - d) / (c - b);
  },
  smoothstep: function (a, b, c) {
    if (a <= b)
      return 0;
    if (a >= c)
      return 1;
    a = (a - b) / (c - b);
    return a * a * (3 - 2 * a);
  },
  smootherstep: function (a, b, c) {
    if (a <= b)
      return 0;
    if (a >= c)
      return 1;
    a = (a - b) / (c - b);
    return a * a * a * (a * (6 * a - 15) + 10);
  },
  random16: function () {
    return (65280 * Math.random() + 255 * Math.random()) / 65535;
  },
  randInt: function (a, b) {
    return a + Math.floor(Math.random() * (b - a + 1));
  },
  randFloat: function (a, b) {
    return a + Math.random() * (b - a);
  },
  randFloatSpread: function (a) {
    return a * (0.5 - Math.random());
  },
  sign: function (a) {
    return 0 > a ? -1 : 0 < a ? 1 : 0;
  },
  degToRad: function () {
    var a = Math.PI / 180;
    return function (b) {
      return b * a;
    };
  }(),
  radToDeg: function () {
    var a = 180 / Math.PI;
    return function (b) {
      return b * a;
    };
  }(),
  isPowerOfTwo: function (a) {
    return 0 === (a & a - 1) && 0 !== a;
  }
};
THREE.Spline = function (a) {
  function b(a, b, c, d, e, f, g) {
    a = 0.5 * (c - a);
    d = 0.5 * (d - b);
    return (2 * (b - c) + a + d) * g + (-3 * (b - c) - 2 * a - d) * f + a * e + b;
  }
  this.points = a;
  var c = [], d = {
      x: 0,
      y: 0,
      z: 0
    }, e, f, g, h, k, l, n, q, p;
  this.initFromArray = function (a) {
    this.points = [];
    for (var b = 0; b < a.length; b++)
      this.points[b] = {
        x: a[b][0],
        y: a[b][1],
        z: a[b][2]
      };
  };
  this.getPoint = function (a) {
    e = (this.points.length - 1) * a;
    f = Math.floor(e);
    g = e - f;
    c[0] = 0 === f ? f : f - 1;
    c[1] = f;
    c[2] = f > this.points.length - 2 ? this.points.length - 1 : f + 1;
    c[3] = f > this.points.length - 3 ? this.points.length - 1 : f + 2;
    l = this.points[c[0]];
    n = this.points[c[1]];
    q = this.points[c[2]];
    p = this.points[c[3]];
    h = g * g;
    k = g * h;
    d.x = b(l.x, n.x, q.x, p.x, g, h, k);
    d.y = b(l.y, n.y, q.y, p.y, g, h, k);
    d.z = b(l.z, n.z, q.z, p.z, g, h, k);
    return d;
  };
  this.getControlPointsArray = function () {
    var a, b, c = this.points.length, d = [];
    for (a = 0; a < c; a++)
      b = this.points[a], d[a] = [
        b.x,
        b.y,
        b.z
      ];
    return d;
  };
  this.getLength = function (a) {
    var b, c, d, e = b = b = 0, f = new THREE.Vector3(), g = new THREE.Vector3(), h = [], k = 0;
    h[0] = 0;
    a || (a = 100);
    c = this.points.length * a;
    f.copy(this.points[0]);
    for (a = 1; a < c; a++)
      b = a / c, d = this.getPoint(b), g.copy(d), k += g.distanceTo(f), f.copy(d), b *= this.points.length - 1, b = Math.floor(b), b != e && (h[b] = k, e = b);
    h[h.length] = k;
    return {
      chunks: h,
      total: k
    };
  };
  this.reparametrizeByArcLength = function (a) {
    var b, c, d, e, f, g, h = [], k = new THREE.Vector3(), l = this.getLength();
    h.push(k.copy(this.points[0]).clone());
    for (b = 1; b < this.points.length; b++) {
      c = l.chunks[b] - l.chunks[b - 1];
      g = Math.ceil(a * c / l.total);
      e = (b - 1) / (this.points.length - 1);
      f = b / (this.points.length - 1);
      for (c = 1; c < g - 1; c++)
        d = e + 1 / g * c * (f - e), d = this.getPoint(d), h.push(k.copy(d).clone());
      h.push(k.copy(this.points[b]).clone());
    }
    this.points = h;
  };
};
THREE.Triangle = function (a, b, c) {
  this.a = void 0 !== a ? a : new THREE.Vector3();
  this.b = void 0 !== b ? b : new THREE.Vector3();
  this.c = void 0 !== c ? c : new THREE.Vector3();
};
THREE.Triangle.normal = function () {
  var a = new THREE.Vector3();
  return function (b, c, d, e) {
    e = e || new THREE.Vector3();
    e.subVectors(d, c);
    a.subVectors(b, c);
    e.cross(a);
    b = e.lengthSq();
    return 0 < b ? e.multiplyScalar(1 / Math.sqrt(b)) : e.set(0, 0, 0);
  };
}();
THREE.Triangle.barycoordFromPoint = function () {
  var a = new THREE.Vector3(), b = new THREE.Vector3(), c = new THREE.Vector3();
  return function (d, e, f, g, h) {
    a.subVectors(g, e);
    b.subVectors(f, e);
    c.subVectors(d, e);
    d = a.dot(a);
    e = a.dot(b);
    f = a.dot(c);
    var k = b.dot(b);
    g = b.dot(c);
    var l = d * k - e * e;
    h = h || new THREE.Vector3();
    if (0 == l)
      return h.set(-2, -1, -1);
    l = 1 / l;
    k = (k * f - e * g) * l;
    d = (d * g - e * f) * l;
    return h.set(1 - k - d, d, k);
  };
}();
THREE.Triangle.containsPoint = function () {
  var a = new THREE.Vector3();
  return function (b, c, d, e) {
    b = THREE.Triangle.barycoordFromPoint(b, c, d, e, a);
    return 0 <= b.x && 0 <= b.y && 1 >= b.x + b.y;
  };
}();
THREE.Triangle.prototype = {
  constructor: THREE.Triangle,
  set: function (a, b, c) {
    this.a.copy(a);
    this.b.copy(b);
    this.c.copy(c);
    return this;
  },
  setFromPointsAndIndices: function (a, b, c, d) {
    this.a.copy(a[b]);
    this.b.copy(a[c]);
    this.c.copy(a[d]);
    return this;
  },
  copy: function (a) {
    this.a.copy(a.a);
    this.b.copy(a.b);
    this.c.copy(a.c);
    return this;
  },
  area: function () {
    var a = new THREE.Vector3(), b = new THREE.Vector3();
    return function () {
      a.subVectors(this.c, this.b);
      b.subVectors(this.a, this.b);
      return 0.5 * a.cross(b).length();
    };
  }(),
  midpoint: function (a) {
    return (a || new THREE.Vector3()).addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  },
  normal: function (a) {
    return THREE.Triangle.normal(this.a, this.b, this.c, a);
  },
  plane: function (a) {
    return (a || new THREE.Plane()).setFromCoplanarPoints(this.a, this.b, this.c);
  },
  barycoordFromPoint: function (a, b) {
    return THREE.Triangle.barycoordFromPoint(a, this.a, this.b, this.c, b);
  },
  containsPoint: function (a) {
    return THREE.Triangle.containsPoint(a, this.a, this.b, this.c);
  },
  equals: function (a) {
    return a.a.equals(this.a) && a.b.equals(this.b) && a.c.equals(this.c);
  },
  clone: function () {
    return new THREE.Triangle().copy(this);
  }
};
THREE.Vertex = function (a) {
  console.warn('THREE.Vertex has been DEPRECATED. Use THREE.Vector3 instead.');
  return a;
};
THREE.Clock = function (a) {
  this.autoStart = void 0 !== a ? a : !0;
  this.elapsedTime = this.oldTime = this.startTime = 0;
  this.running = !1;
};
THREE.Clock.prototype = {
  constructor: THREE.Clock,
  start: function () {
    this.oldTime = this.startTime = void 0 !== self.performance && void 0 !== self.performance.now ? self.performance.now() : Date.now();
    this.running = !0;
  },
  stop: function () {
    this.getElapsedTime();
    this.running = !1;
  },
  getElapsedTime: function () {
    this.getDelta();
    return this.elapsedTime;
  },
  getDelta: function () {
    var a = 0;
    this.autoStart && !this.running && this.start();
    if (this.running) {
      var b = void 0 !== self.performance && void 0 !== self.performance.now ? self.performance.now() : Date.now(), a = 0.001 * (b - this.oldTime);
      this.oldTime = b;
      this.elapsedTime += a;
    }
    return a;
  }
};
THREE.EventDispatcher = function () {
};
THREE.EventDispatcher.prototype = {
  constructor: THREE.EventDispatcher,
  apply: function (a) {
    a.addEventListener = THREE.EventDispatcher.prototype.addEventListener;
    a.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener;
    a.removeEventListener = THREE.EventDispatcher.prototype.removeEventListener;
    a.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent;
  },
  addEventListener: function (a, b) {
    void 0 === this._listeners && (this._listeners = {});
    var c = this._listeners;
    void 0 === c[a] && (c[a] = []);
    -1 === c[a].indexOf(b) && c[a].push(b);
  },
  hasEventListener: function (a, b) {
    if (void 0 === this._listeners)
      return !1;
    var c = this._listeners;
    return void 0 !== c[a] && -1 !== c[a].indexOf(b) ? !0 : !1;
  },
  removeEventListener: function (a, b) {
    if (void 0 !== this._listeners) {
      var c = this._listeners[a];
      if (void 0 !== c) {
        var d = c.indexOf(b);
        -1 !== d && c.splice(d, 1);
      }
    }
  },
  dispatchEvent: function (a) {
    if (void 0 !== this._listeners) {
      var b = this._listeners[a.type];
      if (void 0 !== b) {
        a.target = this;
        for (var c = [], d = b.length, e = 0; e < d; e++)
          c[e] = b[e];
        for (e = 0; e < d; e++)
          c[e].call(this, a);
      }
    }
  }
};
(function (a) {
  a.Raycaster = function (b, c, d, e) {
    this.ray = new a.Ray(b, c);
    this.near = d || 0;
    this.far = e || Infinity;
  };
  var b = new a.Sphere(), c = new a.Ray();
  new a.Plane();
  new a.Vector3();
  var d = new a.Vector3(), e = new a.Matrix4(), f = function (a, b) {
      return a.distance - b.distance;
    }, g = new a.Vector3(), h = new a.Vector3(), k = new a.Vector3(), l = function (f, n, s) {
      if (f instanceof a.Sprite) {
        d.setFromMatrixPosition(f.matrixWorld);
        var t = n.ray.distanceToPoint(d);
        if (t > f.scale.x)
          return s;
        s.push({
          distance: t,
          point: f.position,
          face: null,
          object: f
        });
      } else if (f instanceof a.LOD)
        d.setFromMatrixPosition(f.matrixWorld), t = n.ray.origin.distanceTo(d), l(f.getObjectForDistance(t), n, s);
      else if (f instanceof a.Mesh) {
        var r = f.geometry;
        null === r.boundingSphere && r.computeBoundingSphere();
        b.copy(r.boundingSphere);
        b.applyMatrix4(f.matrixWorld);
        if (!1 === n.ray.isIntersectionSphere(b))
          return s;
        e.getInverse(f.matrixWorld);
        c.copy(n.ray).applyMatrix4(e);
        if (null !== r.boundingBox && !1 === c.isIntersectionBox(r.boundingBox))
          return s;
        if (r instanceof a.BufferGeometry) {
          var v = f.material;
          if (void 0 === v)
            return s;
          var w = r.attributes, u, y, L = n.precision;
          if (void 0 !== w.index) {
            var x = w.index.array, N = w.position.array, J = r.offsets;
            0 === J.length && (J = [{
                start: 0,
                count: N.length,
                index: 0
              }]);
            for (var B = 0, K = J.length; B < K; ++B)
              for (var w = J[B].start, A = J[B].index, r = w, G = w + J[B].count; r < G; r += 3) {
                w = A + x[r];
                u = A + x[r + 1];
                y = A + x[r + 2];
                g.set(N[3 * w], N[3 * w + 1], N[3 * w + 2]);
                h.set(N[3 * u], N[3 * u + 1], N[3 * u + 2]);
                k.set(N[3 * y], N[3 * y + 1], N[3 * y + 2]);
                var D = v.side === a.BackSide ? c.intersectTriangle(k, h, g, !0) : c.intersectTriangle(g, h, k, v.side !== a.DoubleSide);
                null !== D && (D.applyMatrix4(f.matrixWorld), t = n.ray.origin.distanceTo(D), t < L || t < n.near || t > n.far || s.push({
                  distance: t,
                  point: D,
                  indices: [
                    w,
                    u,
                    y
                  ],
                  face: null,
                  faceIndex: null,
                  object: f
                }));
              }
          } else
            for (N = w.position.array, r = 0, G = w.position.array.length; r < G; r += 3)
              w = r, u = r + 1, y = r + 2, g.set(N[3 * w], N[3 * w + 1], N[3 * w + 2]), h.set(N[3 * u], N[3 * u + 1], N[3 * u + 2]), k.set(N[3 * y], N[3 * y + 1], N[3 * y + 2]), D = v.side === a.BackSide ? c.intersectTriangle(k, h, g, !0) : c.intersectTriangle(g, h, k, v.side !== a.DoubleSide), null !== D && (D.applyMatrix4(f.matrixWorld), t = n.ray.origin.distanceTo(D), t < L || t < n.near || t > n.far || s.push({
                distance: t,
                point: D,
                indices: [
                  w,
                  u,
                  y
                ],
                face: null,
                faceIndex: null,
                object: f
              }));
        } else if (r instanceof a.Geometry)
          for (N = f.material instanceof a.MeshFaceMaterial, J = !0 === N ? f.material.materials : null, L = n.precision, x = r.vertices, B = 0, K = r.faces.length; B < K; B++)
            if (A = r.faces[B], v = !0 === N ? J[A.materialIndex] : f.material, void 0 !== v) {
              w = x[A.a];
              u = x[A.b];
              y = x[A.c];
              if (!0 === v.morphTargets) {
                t = r.morphTargets;
                D = f.morphTargetInfluences;
                g.set(0, 0, 0);
                h.set(0, 0, 0);
                k.set(0, 0, 0);
                for (var G = 0, C = t.length; G < C; G++) {
                  var F = D[G];
                  if (0 !== F) {
                    var z = t[G].vertices;
                    g.x += (z[A.a].x - w.x) * F;
                    g.y += (z[A.a].y - w.y) * F;
                    g.z += (z[A.a].z - w.z) * F;
                    h.x += (z[A.b].x - u.x) * F;
                    h.y += (z[A.b].y - u.y) * F;
                    h.z += (z[A.b].z - u.z) * F;
                    k.x += (z[A.c].x - y.x) * F;
                    k.y += (z[A.c].y - y.y) * F;
                    k.z += (z[A.c].z - y.z) * F;
                  }
                }
                g.add(w);
                h.add(u);
                k.add(y);
                w = g;
                u = h;
                y = k;
              }
              D = v.side === a.BackSide ? c.intersectTriangle(y, u, w, !0) : c.intersectTriangle(w, u, y, v.side !== a.DoubleSide);
              null !== D && (D.applyMatrix4(f.matrixWorld), t = n.ray.origin.distanceTo(D), t < L || t < n.near || t > n.far || s.push({
                distance: t,
                point: D,
                face: A,
                faceIndex: B,
                object: f
              }));
            }
      } else if (f instanceof a.Line) {
        L = n.linePrecision;
        v = L * L;
        r = f.geometry;
        null === r.boundingSphere && r.computeBoundingSphere();
        b.copy(r.boundingSphere);
        b.applyMatrix4(f.matrixWorld);
        if (!1 === n.ray.isIntersectionSphere(b))
          return s;
        e.getInverse(f.matrixWorld);
        c.copy(n.ray).applyMatrix4(e);
        if (r instanceof a.Geometry)
          for (x = r.vertices, L = x.length, w = new a.Vector3(), u = new a.Vector3(), y = f.type === a.LineStrip ? 1 : 2, r = 0; r < L - 1; r += y)
            c.distanceSqToSegment(x[r], x[r + 1], u, w) > v || (t = c.origin.distanceTo(u), t < n.near || t > n.far || s.push({
              distance: t,
              point: w.clone().applyMatrix4(f.matrixWorld),
              face: null,
              faceIndex: null,
              object: f
            }));
      }
    }, n = function (a, b, c) {
      a = a.getDescendants();
      for (var d = 0, e = a.length; d < e; d++)
        l(a[d], b, c);
    };
  a.Raycaster.prototype.precision = 0.0001;
  a.Raycaster.prototype.linePrecision = 1;
  a.Raycaster.prototype.set = function (a, b) {
    this.ray.set(a, b);
  };
  a.Raycaster.prototype.intersectObject = function (a, b) {
    var c = [];
    !0 === b && n(a, this, c);
    l(a, this, c);
    c.sort(f);
    return c;
  };
  a.Raycaster.prototype.intersectObjects = function (a, b) {
    for (var c = [], d = 0, e = a.length; d < e; d++)
      l(a[d], this, c), !0 === b && n(a[d], this, c);
    c.sort(f);
    return c;
  };
}(THREE));
THREE.Object3D = function () {
  this.id = THREE.Object3DIdCount++;
  this.uuid = THREE.Math.generateUUID();
  this.name = '';
  this.parent = void 0;
  this.children = [];
  this.up = new THREE.Vector3(0, 1, 0);
  this.position = new THREE.Vector3();
  var a = this;
  Object.defineProperties(this, {
    rotation: {
      enumerable: !0,
      value: new THREE.Euler().onChange(function () {
        a.quaternion.setFromEuler(a.rotation, !1);
      })
    },
    quaternion: {
      enumerable: !0,
      value: new THREE.Quaternion().onChange(function () {
        a.rotation.setFromQuaternion(a.quaternion, void 0, !1);
      })
    },
    scale: {
      enumerable: !0,
      value: new THREE.Vector3(1, 1, 1)
    }
  });
  this.renderDepth = null;
  this.rotationAutoUpdate = !0;
  this.matrix = new THREE.Matrix4();
  this.matrixWorld = new THREE.Matrix4();
  this.matrixAutoUpdate = !0;
  this.matrixWorldNeedsUpdate = !1;
  this.visible = !0;
  this.receiveShadow = this.castShadow = !1;
  this.frustumCulled = !0;
  this.userData = {};
};
THREE.Object3D.prototype = {
  constructor: THREE.Object3D,
  get eulerOrder() {
    console.warn('DEPRECATED: Object3D\'s .eulerOrder has been moved to Object3D\'s .rotation.order.');
    return this.rotation.order;
  },
  set eulerOrder(a) {
    console.warn('DEPRECATED: Object3D\'s .eulerOrder has been moved to Object3D\'s .rotation.order.');
    this.rotation.order = a;
  },
  get useQuaternion() {
    console.warn('DEPRECATED: Object3D\'s .useQuaternion has been removed. The library now uses quaternions by default.');
  },
  set useQuaternion(a) {
    console.warn('DEPRECATED: Object3D\'s .useQuaternion has been removed. The library now uses quaternions by default.');
  },
  applyMatrix: function (a) {
    this.matrix.multiplyMatrices(a, this.matrix);
    this.matrix.decompose(this.position, this.quaternion, this.scale);
  },
  setRotationFromAxisAngle: function (a, b) {
    this.quaternion.setFromAxisAngle(a, b);
  },
  setRotationFromEuler: function (a) {
    this.quaternion.setFromEuler(a, !0);
  },
  setRotationFromMatrix: function (a) {
    this.quaternion.setFromRotationMatrix(a);
  },
  setRotationFromQuaternion: function (a) {
    this.quaternion.copy(a);
  },
  rotateOnAxis: function () {
    var a = new THREE.Quaternion();
    return function (b, c) {
      a.setFromAxisAngle(b, c);
      this.quaternion.multiply(a);
      return this;
    };
  }(),
  rotateX: function () {
    var a = new THREE.Vector3(1, 0, 0);
    return function (b) {
      return this.rotateOnAxis(a, b);
    };
  }(),
  rotateY: function () {
    var a = new THREE.Vector3(0, 1, 0);
    return function (b) {
      return this.rotateOnAxis(a, b);
    };
  }(),
  rotateZ: function () {
    var a = new THREE.Vector3(0, 0, 1);
    return function (b) {
      return this.rotateOnAxis(a, b);
    };
  }(),
  translateOnAxis: function () {
    var a = new THREE.Vector3();
    return function (b, c) {
      a.copy(b);
      a.applyQuaternion(this.quaternion);
      this.position.add(a.multiplyScalar(c));
      return this;
    };
  }(),
  translate: function (a, b) {
    console.warn('DEPRECATED: Object3D\'s .translate() has been removed. Use .translateOnAxis( axis, distance ) instead. Note args have been changed.');
    return this.translateOnAxis(b, a);
  },
  translateX: function () {
    var a = new THREE.Vector3(1, 0, 0);
    return function (b) {
      return this.translateOnAxis(a, b);
    };
  }(),
  translateY: function () {
    var a = new THREE.Vector3(0, 1, 0);
    return function (b) {
      return this.translateOnAxis(a, b);
    };
  }(),
  translateZ: function () {
    var a = new THREE.Vector3(0, 0, 1);
    return function (b) {
      return this.translateOnAxis(a, b);
    };
  }(),
  localToWorld: function (a) {
    return a.applyMatrix4(this.matrixWorld);
  },
  worldToLocal: function () {
    var a = new THREE.Matrix4();
    return function (b) {
      return b.applyMatrix4(a.getInverse(this.matrixWorld));
    };
  }(),
  lookAt: function () {
    var a = new THREE.Matrix4();
    return function (b) {
      a.lookAt(b, this.position, this.up);
      this.quaternion.setFromRotationMatrix(a);
    };
  }(),
  add: function (a) {
    if (a === this)
      console.warn('THREE.Object3D.add: An object can\'t be added as a child of itself.');
    else if (a instanceof THREE.Object3D) {
      void 0 !== a.parent && a.parent.remove(a);
      a.parent = this;
      a.dispatchEvent({ type: 'added' });
      this.children.push(a);
      for (var b = this; void 0 !== b.parent;)
        b = b.parent;
      void 0 !== b && b instanceof THREE.Scene && b.__addObject(a);
    }
  },
  remove: function (a) {
    var b = this.children.indexOf(a);
    if (-1 !== b) {
      a.parent = void 0;
      a.dispatchEvent({ type: 'removed' });
      this.children.splice(b, 1);
      for (b = this; void 0 !== b.parent;)
        b = b.parent;
      void 0 !== b && b instanceof THREE.Scene && b.__removeObject(a);
    }
  },
  traverse: function (a) {
    a(this);
    for (var b = 0, c = this.children.length; b < c; b++)
      this.children[b].traverse(a);
  },
  getObjectById: function (a, b) {
    for (var c = 0, d = this.children.length; c < d; c++) {
      var e = this.children[c];
      if (e.id === a || !0 === b && (e = e.getObjectById(a, b), void 0 !== e))
        return e;
    }
  },
  getObjectByName: function (a, b) {
    for (var c = 0, d = this.children.length; c < d; c++) {
      var e = this.children[c];
      if (e.name === a || !0 === b && (e = e.getObjectByName(a, b), void 0 !== e))
        return e;
    }
  },
  getChildByName: function (a, b) {
    console.warn('DEPRECATED: Object3D\'s .getChildByName() has been renamed to .getObjectByName().');
    return this.getObjectByName(a, b);
  },
  getDescendants: function (a) {
    void 0 === a && (a = []);
    Array.prototype.push.apply(a, this.children);
    for (var b = 0, c = this.children.length; b < c; b++)
      this.children[b].getDescendants(a);
    return a;
  },
  updateMatrix: function () {
    this.matrix.compose(this.position, this.quaternion, this.scale);
    this.matrixWorldNeedsUpdate = !0;
  },
  updateMatrixWorld: function (a) {
    !0 === this.matrixAutoUpdate && this.updateMatrix();
    if (!0 === this.matrixWorldNeedsUpdate || !0 === a)
      void 0 === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, a = !0;
    for (var b = 0, c = this.children.length; b < c; b++)
      this.children[b].updateMatrixWorld(a);
  },
  clone: function (a, b) {
    void 0 === a && (a = new THREE.Object3D());
    void 0 === b && (b = !0);
    a.name = this.name;
    a.up.copy(this.up);
    a.position.copy(this.position);
    a.quaternion.copy(this.quaternion);
    a.scale.copy(this.scale);
    a.renderDepth = this.renderDepth;
    a.rotationAutoUpdate = this.rotationAutoUpdate;
    a.matrix.copy(this.matrix);
    a.matrixWorld.copy(this.matrixWorld);
    a.matrixAutoUpdate = this.matrixAutoUpdate;
    a.matrixWorldNeedsUpdate = this.matrixWorldNeedsUpdate;
    a.visible = this.visible;
    a.castShadow = this.castShadow;
    a.receiveShadow = this.receiveShadow;
    a.frustumCulled = this.frustumCulled;
    a.userData = JSON.parse(JSON.stringify(this.userData));
    if (!0 === b)
      for (var c = 0; c < this.children.length; c++)
        a.add(this.children[c].clone());
    return a;
  }
};
THREE.EventDispatcher.prototype.apply(THREE.Object3D.prototype);
THREE.Object3DIdCount = 0;
THREE.Projector = function () {
  function a() {
    if (n === p) {
      var a = new THREE.RenderableVertex();
      q.push(a);
      p++;
      n++;
      return a;
    }
    return q[n++];
  }
  function b() {
    if (t === v) {
      var a = new THREE.RenderableFace();
      r.push(a);
      v++;
      t++;
      return a;
    }
    return r[t++];
  }
  function c() {
    if (u === L) {
      var a = new THREE.RenderableLine();
      y.push(a);
      L++;
      u++;
      return a;
    }
    return y[u++];
  }
  function d(a, b) {
    return a.z !== b.z ? b.z - a.z : a.id !== b.id ? a.id - b.id : 0;
  }
  function e(a, b) {
    var c = 0, d = 1, e = a.z + a.w, f = b.z + b.w, g = -a.z + a.w, h = -b.z + b.w;
    if (0 <= e && 0 <= f && 0 <= g && 0 <= h)
      return !0;
    if (0 > e && 0 > f || 0 > g && 0 > h)
      return !1;
    0 > e ? c = Math.max(c, e / (e - f)) : 0 > f && (d = Math.min(d, e / (e - f)));
    0 > g ? c = Math.max(c, g / (g - h)) : 0 > h && (d = Math.min(d, g / (g - h)));
    if (d < c)
      return !1;
    a.lerp(b, c);
    b.lerp(a, 1 - d);
    return !0;
  }
  var f, g, h = [], k = 0, l, n, q = [], p = 0, s, t, r = [], v = 0, w, u, y = [], L = 0, x, N, J = [], B = 0, K = {
      objects: [],
      lights: [],
      elements: []
    }, A = new THREE.Vector3(), G = new THREE.Vector3(), D = new THREE.Vector3(), C = new THREE.Vector3(), F = new THREE.Vector4(), z = new THREE.Box3(new THREE.Vector3(-1, -1, -1), new THREE.Vector3(1, 1, 1)), H = new THREE.Box3(), E = Array(3), Q = new THREE.Matrix4(), Y = new THREE.Matrix4(), U, la = new THREE.Matrix4(), W = new THREE.Matrix3(), R = new THREE.Frustum(), I = new THREE.Vector4(), da = new THREE.Vector4();
  this.projectVector = function (a, b) {
    b.matrixWorldInverse.getInverse(b.matrixWorld);
    Y.multiplyMatrices(b.projectionMatrix, b.matrixWorldInverse);
    return a.applyProjection(Y);
  };
  this.unprojectVector = function () {
    var a = new THREE.Matrix4();
    return function (b, c) {
      a.getInverse(c.projectionMatrix);
      Y.multiplyMatrices(c.matrixWorld, a);
      return b.applyProjection(Y);
    };
  }();
  this.pickingRay = function (a, b) {
    a.z = -1;
    var c = new THREE.Vector3(a.x, a.y, 1);
    this.unprojectVector(a, b);
    this.unprojectVector(c, b);
    c.sub(a).normalize();
    return new THREE.Raycaster(a, c);
  };
  var V = function (a) {
      if (!1 !== a.visible) {
        if (a instanceof THREE.Light)
          K.lights.push(a);
        else if (a instanceof THREE.Mesh || a instanceof THREE.Line || a instanceof THREE.Sprite)
          if (!1 === a.frustumCulled || !0 === R.intersectsObject(a)) {
            if (g === k) {
              var b = new THREE.RenderableObject();
              h.push(b);
              k++;
              g++;
              f = b;
            } else
              f = h[g++];
            f.id = a.id;
            f.object = a;
            null !== a.renderDepth ? f.z = a.renderDepth : (C.setFromMatrixPosition(a.matrixWorld), C.applyProjection(Y), f.z = C.z);
            K.objects.push(f);
          }
        for (var b = 0, c = a.children.length; b < c; b++)
          V(a.children[b]);
      }
    }, X = new function () {
      var d = [], e = [], f = null, g = null, h = new THREE.Matrix3(), k = function (a) {
          var b = a.positionWorld, c = a.positionScreen;
          b.copy(a.position).applyMatrix4(U);
          c.copy(b).applyMatrix4(Y);
          b = 1 / c.w;
          c.x *= b;
          c.y *= b;
          c.z *= b;
          a.visible = -1 <= c.x && 1 >= c.x && -1 <= c.y && 1 >= c.y && -1 <= c.z && 1 >= c.z;
        }, n = function (a, b, c) {
          if (!0 === a.visible || !0 === b.visible || !0 === c.visible)
            return !0;
          E[0] = a.positionScreen;
          E[1] = b.positionScreen;
          E[2] = c.positionScreen;
          return z.isIntersectionBox(H.setFromPoints(E));
        }, r = function (a, b, c) {
          return 0 > (c.positionScreen.x - a.positionScreen.x) * (b.positionScreen.y - a.positionScreen.y) - (c.positionScreen.y - a.positionScreen.y) * (b.positionScreen.x - a.positionScreen.x);
        };
      return {
        setObject: function (a) {
          f = a;
          g = f.material;
          h.getNormalMatrix(f.matrixWorld);
          d.length = 0;
          e.length = 0;
        },
        projectVertex: k,
        checkTriangleVisibility: n,
        checkBackfaceCulling: r,
        pushVertex: function (b, c, d) {
          l = a();
          l.position.set(b, c, d);
          k(l);
        },
        pushNormal: function (a, b, c) {
          d.push(a, b, c);
        },
        pushUv: function (a, b) {
          e.push(a, b);
        },
        pushLine: function (a, b) {
          var d = q[a], e = q[b];
          w = c();
          w.id = f.id;
          w.v1.copy(d);
          w.v2.copy(e);
          w.z = (d.positionScreen.z + e.positionScreen.z) / 2;
          w.material = f.material;
          K.elements.push(w);
        },
        pushTriangle: function (a, c, k) {
          var l = q[a], p = q[c], t = q[k];
          if (!1 !== n(l, p, t) && (g.side === THREE.DoubleSide || !0 === r(l, p, t))) {
            s = b();
            s.id = f.id;
            s.v1.copy(l);
            s.v2.copy(p);
            s.v3.copy(t);
            s.z = (l.positionScreen.z + p.positionScreen.z + t.positionScreen.z) / 3;
            for (l = 0; 3 > l; l++)
              p = 3 * arguments[l], t = s.vertexNormalsModel[l], t.set(d[p], d[p + 1], d[p + 2]), t.applyMatrix3(h).normalize(), p = 2 * arguments[l], s.uvs[l].set(e[p], e[p + 1]);
            s.vertexNormalsLength = 3;
            s.material = f.material;
            K.elements.push(s);
          }
        }
      };
    }();
  this.projectScene = function (f, h, k, l) {
    var r, p, v, y, L, C, z, E;
    N = u = t = 0;
    K.elements.length = 0;
    !0 === f.autoUpdate && f.updateMatrixWorld();
    void 0 === h.parent && h.updateMatrixWorld();
    Q.copy(h.matrixWorldInverse.getInverse(h.matrixWorld));
    Y.multiplyMatrices(h.projectionMatrix, Q);
    R.setFromMatrix(Y);
    g = 0;
    K.objects.length = 0;
    K.lights.length = 0;
    V(f);
    !0 === k && K.objects.sort(d);
    f = 0;
    for (k = K.objects.length; f < k; f++)
      if (r = K.objects[f].object, p = r.geometry, X.setObject(r), U = r.matrixWorld, n = 0, r instanceof THREE.Mesh)
        if (p instanceof THREE.BufferGeometry) {
          if (C = p.attributes, r = p.offsets, void 0 !== C.position) {
            z = C.position.array;
            p = 0;
            for (y = z.length; p < y; p += 3)
              X.pushVertex(z[p], z[p + 1], z[p + 2]);
            if (void 0 !== C.normal)
              for (E = C.normal.array, p = 0, y = E.length; p < y; p += 3)
                X.pushNormal(E[p], E[p + 1], E[p + 2]);
            if (void 0 !== C.uv)
              for (E = C.uv.array, p = 0, y = E.length; p < y; p += 2)
                X.pushUv(E[p], E[p + 1]);
            if (void 0 !== C.index)
              if (C = C.index.array, 0 < r.length)
                for (f = 0; f < r.length; f++)
                  for (y = r[f], z = y.index, p = y.start, y = y.start + y.count; p < y; p += 3)
                    X.pushTriangle(C[p] + z, C[p + 1] + z, C[p + 2] + z);
              else
                for (p = 0, y = C.length; p < y; p += 3)
                  X.pushTriangle(C[p], C[p + 1], C[p + 2]);
            else
              for (p = 0, y = z.length / 3; p < y; p += 3)
                X.pushTriangle(p, p + 1, p + 2);
          }
        } else {
          if (p instanceof THREE.Geometry) {
            v = p.vertices;
            y = p.faces;
            C = p.faceVertexUvs[0];
            W.getNormalMatrix(U);
            z = r.material instanceof THREE.MeshFaceMaterial;
            E = !0 === z ? r.material : null;
            for (var H = 0, Fa = v.length; H < Fa; H++) {
              var ia = v[H];
              X.pushVertex(ia.x, ia.y, ia.z);
            }
            H = 0;
            for (Fa = y.length; H < Fa; H++) {
              v = y[H];
              var ma = !0 === z ? E.materials[v.materialIndex] : r.material;
              if (void 0 !== ma) {
                var ya = ma.side, ia = q[v.a], Z = q[v.b], qa = q[v.c];
                if (!0 === ma.morphTargets) {
                  L = p.morphTargets;
                  var ua = r.morphTargetInfluences, Ca = ia.position, va = Z.position, Da = qa.position;
                  A.set(0, 0, 0);
                  G.set(0, 0, 0);
                  D.set(0, 0, 0);
                  for (var Ja = 0, ja = L.length; Ja < ja; Ja++) {
                    var ra = ua[Ja];
                    if (0 !== ra) {
                      var Ka = L[Ja].vertices;
                      A.x += (Ka[v.a].x - Ca.x) * ra;
                      A.y += (Ka[v.a].y - Ca.y) * ra;
                      A.z += (Ka[v.a].z - Ca.z) * ra;
                      G.x += (Ka[v.b].x - va.x) * ra;
                      G.y += (Ka[v.b].y - va.y) * ra;
                      G.z += (Ka[v.b].z - va.z) * ra;
                      D.x += (Ka[v.c].x - Da.x) * ra;
                      D.y += (Ka[v.c].y - Da.y) * ra;
                      D.z += (Ka[v.c].z - Da.z) * ra;
                    }
                  }
                  ia.position.add(A);
                  Z.position.add(G);
                  qa.position.add(D);
                  X.projectVertex(ia);
                  X.projectVertex(Z);
                  X.projectVertex(qa);
                }
                if (!1 !== X.checkTriangleVisibility(ia, Z, qa)) {
                  ua = X.checkBackfaceCulling(ia, Z, qa);
                  if (ya !== THREE.DoubleSide) {
                    if (ya === THREE.FrontSide && !1 === ua)
                      continue;
                    if (ya === THREE.BackSide && !0 === ua)
                      continue;
                  }
                  s = b();
                  s.id = r.id;
                  s.v1.copy(ia);
                  s.v2.copy(Z);
                  s.v3.copy(qa);
                  s.normalModel.copy(v.normal);
                  !1 !== ua || ya !== THREE.BackSide && ya !== THREE.DoubleSide || s.normalModel.negate();
                  s.normalModel.applyMatrix3(W).normalize();
                  L = v.vertexNormals;
                  Ca = 0;
                  for (va = Math.min(L.length, 3); Ca < va; Ca++)
                    Da = s.vertexNormalsModel[Ca], Da.copy(L[Ca]), !1 !== ua || ya !== THREE.BackSide && ya !== THREE.DoubleSide || Da.negate(), Da.applyMatrix3(W).normalize();
                  s.vertexNormalsLength = L.length;
                  ya = C[H];
                  if (void 0 !== ya)
                    for (L = 0; 3 > L; L++)
                      s.uvs[L].copy(ya[L]);
                  s.color = v.color;
                  s.material = ma;
                  s.z = (ia.positionScreen.z + Z.positionScreen.z + qa.positionScreen.z) / 3;
                  K.elements.push(s);
                }
              }
            }
          }
        }
      else if (r instanceof THREE.Line)
        if (p instanceof THREE.BufferGeometry) {
          if (C = p.attributes, void 0 !== C.position) {
            z = C.position.array;
            p = 0;
            for (y = z.length; p < y; p += 3)
              X.pushVertex(z[p], z[p + 1], z[p + 2]);
            if (void 0 !== C.index)
              for (C = C.index.array, p = 0, y = C.length; p < y; p += 2)
                X.pushLine(C[p], C[p + 1]);
            else
              for (p = 0, y = z.length / 3 - 1; p < y; p++)
                X.pushLine(p, p + 1);
          }
        } else {
          if (p instanceof THREE.Geometry && (la.multiplyMatrices(Y, U), v = r.geometry.vertices, 0 !== v.length))
            for (ia = a(), ia.positionScreen.copy(v[0]).applyMatrix4(la), p = r.type === THREE.LinePieces ? 2 : 1, H = 1, Fa = v.length; H < Fa; H++)
              ia = a(), ia.positionScreen.copy(v[H]).applyMatrix4(la), 0 < (H + 1) % p || (Z = q[n - 2], I.copy(ia.positionScreen), da.copy(Z.positionScreen), !0 === e(I, da) && (I.multiplyScalar(1 / I.w), da.multiplyScalar(1 / da.w), w = c(), w.id = r.id, w.v1.positionScreen.copy(I), w.v2.positionScreen.copy(da), w.z = Math.max(I.z, da.z), w.material = r.material, r.material.vertexColors === THREE.VertexColors && (w.vertexColors[0].copy(r.geometry.colors[H]), w.vertexColors[1].copy(r.geometry.colors[H - 1])), K.elements.push(w)));
        }
      else
        r instanceof THREE.Sprite && (F.set(U.elements[12], U.elements[13], U.elements[14], 1), F.applyMatrix4(Y), p = 1 / F.w, F.z *= p, -1 <= F.z && 1 >= F.z && (N === B ? (y = new THREE.RenderableSprite(), J.push(y), B++, N++, x = y) : x = J[N++], x.id = r.id, x.x = F.x * p, x.y = F.y * p, x.z = F.z, x.object = r, x.rotation = r.rotation, x.scale.x = r.scale.x * Math.abs(x.x - (F.x + h.projectionMatrix.elements[0]) / (F.w + h.projectionMatrix.elements[12])), x.scale.y = r.scale.y * Math.abs(x.y - (F.y + h.projectionMatrix.elements[5]) / (F.w + h.projectionMatrix.elements[13])), x.material = r.material, K.elements.push(x)));
    !0 === l && K.elements.sort(d);
    return K;
  };
};
THREE.Face3 = function (a, b, c, d, e, f) {
  this.a = a;
  this.b = b;
  this.c = c;
  this.normal = d instanceof THREE.Vector3 ? d : new THREE.Vector3();
  this.vertexNormals = d instanceof Array ? d : [];
  this.color = e instanceof THREE.Color ? e : new THREE.Color();
  this.vertexColors = e instanceof Array ? e : [];
  this.vertexTangents = [];
  this.materialIndex = void 0 !== f ? f : 0;
};
THREE.Face3.prototype = {
  constructor: THREE.Face3,
  clone: function () {
    var a = new THREE.Face3(this.a, this.b, this.c);
    a.normal.copy(this.normal);
    a.color.copy(this.color);
    a.materialIndex = this.materialIndex;
    var b, c;
    b = 0;
    for (c = this.vertexNormals.length; b < c; b++)
      a.vertexNormals[b] = this.vertexNormals[b].clone();
    b = 0;
    for (c = this.vertexColors.length; b < c; b++)
      a.vertexColors[b] = this.vertexColors[b].clone();
    b = 0;
    for (c = this.vertexTangents.length; b < c; b++)
      a.vertexTangents[b] = this.vertexTangents[b].clone();
    return a;
  }
};
THREE.Face4 = function (a, b, c, d, e, f, g) {
  console.warn('THREE.Face4 has been removed. A THREE.Face3 will be created instead.');
  return new THREE.Face3(a, b, c, e, f, g);
};
THREE.BufferAttribute = function () {
};
THREE.BufferAttribute.prototype = {
  constructor: THREE.BufferAttribute,
  get length() {
    return this.array.length;
  },
  set: function (a) {
    this.array.set(a);
  },
  setX: function (a, b) {
    this.array[a * this.itemSize] = b;
  },
  setY: function (a, b) {
    this.array[a * this.itemSize + 1] = b;
  },
  setZ: function (a, b) {
    this.array[a * this.itemSize + 2] = b;
  },
  setXY: function (a, b, c) {
    a *= this.itemSize;
    this.array[a] = b;
    this.array[a + 1] = c;
  },
  setXYZ: function (a, b, c, d) {
    a *= this.itemSize;
    this.array[a] = b;
    this.array[a + 1] = c;
    this.array[a + 2] = d;
  },
  setXYZW: function (a, b, c, d, e) {
    a *= this.itemSize;
    this.array[a] = b;
    this.array[a + 1] = c;
    this.array[a + 2] = d;
    this.array[a + 3] = e;
  }
};
THREE.Int8Attribute = function (a, b) {
  this.array = new Int8Array(a * b);
  this.itemSize = b;
};
THREE.Int8Attribute.prototype = Object.create(THREE.BufferAttribute.prototype);
THREE.Uint8Attribute = function (a, b) {
  this.array = new Uint8Array(a * b);
  this.itemSize = b;
};
THREE.Uint8Attribute.prototype = Object.create(THREE.BufferAttribute.prototype);
THREE.Uint8ClampedAttribute = function (a, b) {
  this.array = new Uint8ClampedArray(a * b);
  this.itemSize = b;
};
THREE.Uint8ClampedAttribute.prototype = Object.create(THREE.BufferAttribute.prototype);
THREE.Int16Attribute = function (a, b) {
  this.array = new Int16Array(a * b);
  this.itemSize = b;
};
THREE.Int16Attribute.prototype = Object.create(THREE.BufferAttribute.prototype);
THREE.Uint16Attribute = function (a, b) {
  this.array = new Uint16Array(a * b);
  this.itemSize = b;
};
THREE.Uint16Attribute.prototype = Object.create(THREE.BufferAttribute.prototype);
THREE.Int32Attribute = function (a, b) {
  this.array = new Int32Array(a * b);
  this.itemSize = b;
};
THREE.Int32Attribute.prototype = Object.create(THREE.BufferAttribute.prototype);
THREE.Uint32Attribute = function (a, b) {
  this.array = new Uint32Array(a * b);
  this.itemSize = b;
};
THREE.Uint32Attribute.prototype = Object.create(THREE.BufferAttribute.prototype);
THREE.Float32Attribute = function (a, b) {
  this.array = new Float32Array(a * b);
  this.itemSize = b;
};
THREE.Float32Attribute.prototype = Object.create(THREE.BufferAttribute.prototype);
THREE.Float64Attribute = function (a, b) {
  this.array = new Float64Array(a * b);
  this.itemSize = b;
};
THREE.Float64Attribute.prototype = Object.create(THREE.BufferAttribute.prototype);
THREE.BufferGeometry = function () {
  this.id = THREE.GeometryIdCount++;
  this.uuid = THREE.Math.generateUUID();
  this.name = '';
  this.attributes = {};
  this.offsets = this.drawcalls = [];
  this.boundingSphere = this.boundingBox = null;
};
THREE.BufferGeometry.prototype = {
  constructor: THREE.BufferGeometry,
  addAttribute: function (a, b, c) {
    !1 === b instanceof THREE.BufferAttribute ? (console.warn('DEPRECATED: BufferGeometry\'s addAttribute() now expects ( name, attribute ).'), this.attributes[a] = {
      array: b,
      itemSize: c
    }) : this.attributes[a] = b;
  },
  getAttribute: function (a) {
    return this.attributes[a];
  },
  addDrawCall: function (a, b, c) {
    this.drawcalls.push({
      start: a,
      count: b,
      index: void 0 !== c ? c : 0
    });
  },
  applyMatrix: function (a) {
    var b = this.attributes.position;
    void 0 !== b && (a.applyToVector3Array(b.array), b.needsUpdate = !0);
    b = this.attributes.normal;
    void 0 !== b && (new THREE.Matrix3().getNormalMatrix(a).applyToVector3Array(b.array), b.needsUpdate = !0);
  },
  computeBoundingBox: function () {
    null === this.boundingBox && (this.boundingBox = new THREE.Box3());
    var a = this.attributes.position.array;
    if (a) {
      var b = this.boundingBox;
      3 <= a.length && (b.min.x = b.max.x = a[0], b.min.y = b.max.y = a[1], b.min.z = b.max.z = a[2]);
      for (var c = 3, d = a.length; c < d; c += 3) {
        var e = a[c], f = a[c + 1], g = a[c + 2];
        e < b.min.x ? b.min.x = e : e > b.max.x && (b.max.x = e);
        f < b.min.y ? b.min.y = f : f > b.max.y && (b.max.y = f);
        g < b.min.z ? b.min.z = g : g > b.max.z && (b.max.z = g);
      }
    }
    if (void 0 === a || 0 === a.length)
      this.boundingBox.min.set(0, 0, 0), this.boundingBox.max.set(0, 0, 0);
  },
  computeBoundingSphere: function () {
    var a = new THREE.Box3(), b = new THREE.Vector3();
    return function () {
      null === this.boundingSphere && (this.boundingSphere = new THREE.Sphere());
      var c = this.attributes.position.array;
      if (c) {
        a.makeEmpty();
        for (var d = this.boundingSphere.center, e = 0, f = c.length; e < f; e += 3)
          b.set(c[e], c[e + 1], c[e + 2]), a.addPoint(b);
        a.center(d);
        for (var g = 0, e = 0, f = c.length; e < f; e += 3)
          b.set(c[e], c[e + 1], c[e + 2]), g = Math.max(g, d.distanceToSquared(b));
        this.boundingSphere.radius = Math.sqrt(g);
      }
    };
  }(),
  computeFaceNormals: function () {
  },
  computeVertexNormals: function () {
    if (this.attributes.position) {
      var a, b, c, d;
      a = this.attributes.position.array.length;
      if (void 0 === this.attributes.normal)
        this.attributes.normal = {
          itemSize: 3,
          array: new Float32Array(a)
        };
      else
        for (a = 0, b = this.attributes.normal.array.length; a < b; a++)
          this.attributes.normal.array[a] = 0;
      var e = this.attributes.position.array, f = this.attributes.normal.array, g, h, k, l, n, q, p = new THREE.Vector3(), s = new THREE.Vector3(), t = new THREE.Vector3(), r = new THREE.Vector3(), v = new THREE.Vector3();
      if (this.attributes.index) {
        var w = this.attributes.index.array, u = 0 < this.offsets.length ? this.offsets : [{
              start: 0,
              count: w.length,
              index: 0
            }];
        c = 0;
        for (d = u.length; c < d; ++c) {
          b = u[c].start;
          g = u[c].count;
          var y = u[c].index;
          a = b;
          for (b += g; a < b; a += 3)
            g = y + w[a], h = y + w[a + 1], k = y + w[a + 2], l = e[3 * g], n = e[3 * g + 1], q = e[3 * g + 2], p.set(l, n, q), l = e[3 * h], n = e[3 * h + 1], q = e[3 * h + 2], s.set(l, n, q), l = e[3 * k], n = e[3 * k + 1], q = e[3 * k + 2], t.set(l, n, q), r.subVectors(t, s), v.subVectors(p, s), r.cross(v), f[3 * g] += r.x, f[3 * g + 1] += r.y, f[3 * g + 2] += r.z, f[3 * h] += r.x, f[3 * h + 1] += r.y, f[3 * h + 2] += r.z, f[3 * k] += r.x, f[3 * k + 1] += r.y, f[3 * k + 2] += r.z;
        }
      } else
        for (a = 0, b = e.length; a < b; a += 9)
          l = e[a], n = e[a + 1], q = e[a + 2], p.set(l, n, q), l = e[a + 3], n = e[a + 4], q = e[a + 5], s.set(l, n, q), l = e[a + 6], n = e[a + 7], q = e[a + 8], t.set(l, n, q), r.subVectors(t, s), v.subVectors(p, s), r.cross(v), f[a] = r.x, f[a + 1] = r.y, f[a + 2] = r.z, f[a + 3] = r.x, f[a + 4] = r.y, f[a + 5] = r.z, f[a + 6] = r.x, f[a + 7] = r.y, f[a + 8] = r.z;
      this.normalizeNormals();
      this.normalsNeedUpdate = !0;
    }
  },
  computeTangents: function () {
    function a(a, b, c) {
      q = d[3 * a];
      p = d[3 * a + 1];
      s = d[3 * a + 2];
      t = d[3 * b];
      r = d[3 * b + 1];
      v = d[3 * b + 2];
      w = d[3 * c];
      u = d[3 * c + 1];
      y = d[3 * c + 2];
      L = f[2 * a];
      x = f[2 * a + 1];
      N = f[2 * b];
      J = f[2 * b + 1];
      B = f[2 * c];
      K = f[2 * c + 1];
      A = t - q;
      G = w - q;
      D = r - p;
      C = u - p;
      F = v - s;
      z = y - s;
      H = N - L;
      E = B - L;
      Q = J - x;
      Y = K - x;
      U = 1 / (H * Y - E * Q);
      la.set((Y * A - Q * G) * U, (Y * D - Q * C) * U, (Y * F - Q * z) * U);
      W.set((H * G - E * A) * U, (H * C - E * D) * U, (H * z - E * F) * U);
      k[a].add(la);
      k[b].add(la);
      k[c].add(la);
      l[a].add(W);
      l[b].add(W);
      l[c].add(W);
    }
    function b(a) {
      fa.x = e[3 * a];
      fa.y = e[3 * a + 1];
      fa.z = e[3 * a + 2];
      za.copy(fa);
      Ea = k[a];
      wa.copy(Ea);
      wa.sub(fa.multiplyScalar(fa.dot(Ea))).normalize();
      Ha.crossVectors(za, Ea);
      Ga = Ha.dot(l[a]);
      Ia = 0 > Ga ? -1 : 1;
      h[4 * a] = wa.x;
      h[4 * a + 1] = wa.y;
      h[4 * a + 2] = wa.z;
      h[4 * a + 3] = Ia;
    }
    if (void 0 === this.attributes.index || void 0 === this.attributes.position || void 0 === this.attributes.normal || void 0 === this.attributes.uv)
      console.warn('Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()');
    else {
      var c = this.attributes.index.array, d = this.attributes.position.array, e = this.attributes.normal.array, f = this.attributes.uv.array, g = d.length / 3;
      void 0 === this.attributes.tangent && (this.attributes.tangent = {
        itemSize: 4,
        array: new Float32Array(4 * g)
      });
      for (var h = this.attributes.tangent.array, k = [], l = [], n = 0; n < g; n++)
        k[n] = new THREE.Vector3(), l[n] = new THREE.Vector3();
      var q, p, s, t, r, v, w, u, y, L, x, N, J, B, K, A, G, D, C, F, z, H, E, Q, Y, U, la = new THREE.Vector3(), W = new THREE.Vector3(), R, I, da, V, X, P = this.offsets, n = 0;
      for (I = P.length; n < I; ++n) {
        R = P[n].start;
        da = P[n].count;
        var ga = P[n].index, g = R;
        for (R += da; g < R; g += 3)
          da = ga + c[g], V = ga + c[g + 1], X = ga + c[g + 2], a(da, V, X);
      }
      var wa = new THREE.Vector3(), Ha = new THREE.Vector3(), fa = new THREE.Vector3(), za = new THREE.Vector3(), Ia, Ea, Ga, n = 0;
      for (I = P.length; n < I; ++n)
        for (R = P[n].start, da = P[n].count, ga = P[n].index, g = R, R += da; g < R; g += 3)
          da = ga + c[g], V = ga + c[g + 1], X = ga + c[g + 2], b(da), b(V), b(X);
    }
  },
  computeOffsets: function (a) {
    var b = a;
    void 0 === a && (b = 65535);
    Date.now();
    a = this.attributes.index.array;
    for (var c = this.attributes.position.array, d = a.length / 3, e = new Uint16Array(a.length), f = 0, g = 0, h = [{
            start: 0,
            count: 0,
            index: 0
          }], k = h[0], l = 0, n = 0, q = new Int32Array(6), p = new Int32Array(c.length), s = new Int32Array(c.length), t = 0; t < c.length; t++)
      p[t] = -1, s[t] = -1;
    for (c = 0; c < d; c++) {
      for (var r = n = 0; 3 > r; r++)
        t = a[3 * c + r], -1 == p[t] ? (q[2 * r] = t, q[2 * r + 1] = -1, n++) : p[t] < k.index ? (q[2 * r] = t, q[2 * r + 1] = -1, l++) : (q[2 * r] = t, q[2 * r + 1] = p[t]);
      if (g + n > k.index + b)
        for (k = {
            start: f,
            count: 0,
            index: g
          }, h.push(k), n = 0; 6 > n; n += 2)
          r = q[n + 1], -1 < r && r < k.index && (q[n + 1] = -1);
      for (n = 0; 6 > n; n += 2)
        t = q[n], r = q[n + 1], -1 === r && (r = g++), p[t] = r, s[r] = t, e[f++] = r - k.index, k.count++;
    }
    this.reorderBuffers(e, s, g);
    return this.offsets = h;
  },
  merge: function () {
    console.log('BufferGeometry.merge(): TODO');
  },
  normalizeNormals: function () {
    for (var a = this.attributes.normal.array, b, c, d, e = 0, f = a.length; e < f; e += 3)
      b = a[e], c = a[e + 1], d = a[e + 2], b = 1 / Math.sqrt(b * b + c * c + d * d), a[e] *= b, a[e + 1] *= b, a[e + 2] *= b;
  },
  reorderBuffers: function (a, b, c) {
    var d = {}, e = [
        Int8Array,
        Uint8Array,
        Uint8ClampedArray,
        Int16Array,
        Uint16Array,
        Int32Array,
        Uint32Array,
        Float32Array,
        Float64Array
      ], f;
    for (f in this.attributes)
      if ('index' != f)
        for (var g = this.attributes[f].array, h = 0, k = e.length; h < k; h++) {
          var l = e[h];
          if (g instanceof l) {
            d[f] = new l(this.attributes[f].itemSize * c);
            break;
          }
        }
    for (e = 0; e < c; e++)
      for (f in g = b[e], this.attributes)
        if ('index' != f)
          for (var h = this.attributes[f].array, k = this.attributes[f].itemSize, l = d[f], n = 0; n < k; n++)
            l[e * k + n] = h[g * k + n];
    this.attributes.index.array = a;
    for (f in this.attributes)
      'index' != f && (this.attributes[f].array = d[f], this.attributes[f].numItems = this.attributes[f].itemSize * c);
  },
  clone: function () {
    var a = new THREE.BufferGeometry(), b = [
        Int8Array,
        Uint8Array,
        Uint8ClampedArray,
        Int16Array,
        Uint16Array,
        Int32Array,
        Uint32Array,
        Float32Array,
        Float64Array
      ], c;
    for (c in this.attributes) {
      for (var d = this.attributes[c], e = d.array, f = {
            itemSize: d.itemSize,
            array: null
          }, d = 0, g = b.length; d < g; d++) {
        var h = b[d];
        if (e instanceof h) {
          f.array = new h(e);
          break;
        }
      }
      a.attributes[c] = f;
    }
    d = 0;
    for (g = this.offsets.length; d < g; d++)
      b = this.offsets[d], a.offsets.push({
        start: b.start,
        index: b.index,
        count: b.count
      });
    return a;
  },
  dispose: function () {
    this.dispatchEvent({ type: 'dispose' });
  }
};
THREE.EventDispatcher.prototype.apply(THREE.BufferGeometry.prototype);
THREE.Geometry = function () {
  this.id = THREE.GeometryIdCount++;
  this.uuid = THREE.Math.generateUUID();
  this.name = '';
  this.vertices = [];
  this.colors = [];
  this.faces = [];
  this.faceVertexUvs = [[]];
  this.morphTargets = [];
  this.morphColors = [];
  this.morphNormals = [];
  this.skinWeights = [];
  this.skinIndices = [];
  this.lineDistances = [];
  this.boundingSphere = this.boundingBox = null;
  this.hasTangents = !1;
  this.dynamic = !0;
  this.buffersNeedUpdate = this.lineDistancesNeedUpdate = this.colorsNeedUpdate = this.tangentsNeedUpdate = this.normalsNeedUpdate = this.uvsNeedUpdate = this.elementsNeedUpdate = this.verticesNeedUpdate = !1;
};
THREE.Geometry.prototype = {
  constructor: THREE.Geometry,
  applyMatrix: function (a) {
    for (var b = new THREE.Matrix3().getNormalMatrix(a), c = 0, d = this.vertices.length; c < d; c++)
      this.vertices[c].applyMatrix4(a);
    c = 0;
    for (d = this.faces.length; c < d; c++) {
      a = this.faces[c];
      a.normal.applyMatrix3(b).normalize();
      for (var e = 0, f = a.vertexNormals.length; e < f; e++)
        a.vertexNormals[e].applyMatrix3(b).normalize();
    }
    this.boundingBox instanceof THREE.Box3 && this.computeBoundingBox();
    this.boundingSphere instanceof THREE.Sphere && this.computeBoundingSphere();
  },
  computeFaceNormals: function () {
    for (var a = new THREE.Vector3(), b = new THREE.Vector3(), c = 0, d = this.faces.length; c < d; c++) {
      var e = this.faces[c], f = this.vertices[e.a], g = this.vertices[e.b];
      a.subVectors(this.vertices[e.c], g);
      b.subVectors(f, g);
      a.cross(b);
      a.normalize();
      e.normal.copy(a);
    }
  },
  computeVertexNormals: function (a) {
    var b, c, d;
    d = Array(this.vertices.length);
    b = 0;
    for (c = this.vertices.length; b < c; b++)
      d[b] = new THREE.Vector3();
    if (a) {
      var e, f, g, h = new THREE.Vector3(), k = new THREE.Vector3();
      new THREE.Vector3();
      new THREE.Vector3();
      new THREE.Vector3();
      a = 0;
      for (b = this.faces.length; a < b; a++)
        c = this.faces[a], e = this.vertices[c.a], f = this.vertices[c.b], g = this.vertices[c.c], h.subVectors(g, f), k.subVectors(e, f), h.cross(k), d[c.a].add(h), d[c.b].add(h), d[c.c].add(h);
    } else
      for (a = 0, b = this.faces.length; a < b; a++)
        c = this.faces[a], d[c.a].add(c.normal), d[c.b].add(c.normal), d[c.c].add(c.normal);
    b = 0;
    for (c = this.vertices.length; b < c; b++)
      d[b].normalize();
    a = 0;
    for (b = this.faces.length; a < b; a++)
      c = this.faces[a], c.vertexNormals[0] = d[c.a].clone(), c.vertexNormals[1] = d[c.b].clone(), c.vertexNormals[2] = d[c.c].clone();
  },
  computeMorphNormals: function () {
    var a, b, c, d, e;
    c = 0;
    for (d = this.faces.length; c < d; c++)
      for (e = this.faces[c], e.__originalFaceNormal ? e.__originalFaceNormal.copy(e.normal) : e.__originalFaceNormal = e.normal.clone(), e.__originalVertexNormals || (e.__originalVertexNormals = []), a = 0, b = e.vertexNormals.length; a < b; a++)
        e.__originalVertexNormals[a] ? e.__originalVertexNormals[a].copy(e.vertexNormals[a]) : e.__originalVertexNormals[a] = e.vertexNormals[a].clone();
    var f = new THREE.Geometry();
    f.faces = this.faces;
    a = 0;
    for (b = this.morphTargets.length; a < b; a++) {
      if (!this.morphNormals[a]) {
        this.morphNormals[a] = {};
        this.morphNormals[a].faceNormals = [];
        this.morphNormals[a].vertexNormals = [];
        e = this.morphNormals[a].faceNormals;
        var g = this.morphNormals[a].vertexNormals, h, k;
        c = 0;
        for (d = this.faces.length; c < d; c++)
          h = new THREE.Vector3(), k = {
            a: new THREE.Vector3(),
            b: new THREE.Vector3(),
            c: new THREE.Vector3()
          }, e.push(h), g.push(k);
      }
      g = this.morphNormals[a];
      f.vertices = this.morphTargets[a].vertices;
      f.computeFaceNormals();
      f.computeVertexNormals();
      c = 0;
      for (d = this.faces.length; c < d; c++)
        e = this.faces[c], h = g.faceNormals[c], k = g.vertexNormals[c], h.copy(e.normal), k.a.copy(e.vertexNormals[0]), k.b.copy(e.vertexNormals[1]), k.c.copy(e.vertexNormals[2]);
    }
    c = 0;
    for (d = this.faces.length; c < d; c++)
      e = this.faces[c], e.normal = e.__originalFaceNormal, e.vertexNormals = e.__originalVertexNormals;
  },
  computeTangents: function () {
    var a, b, c, d, e, f, g, h, k, l, n, q, p, s, t, r, v, w = [], u = [];
    c = new THREE.Vector3();
    var y = new THREE.Vector3(), L = new THREE.Vector3(), x = new THREE.Vector3(), N = new THREE.Vector3();
    a = 0;
    for (b = this.vertices.length; a < b; a++)
      w[a] = new THREE.Vector3(), u[a] = new THREE.Vector3();
    a = 0;
    for (b = this.faces.length; a < b; a++)
      e = this.faces[a], f = this.faceVertexUvs[0][a], d = e.a, v = e.b, e = e.c, g = this.vertices[d], h = this.vertices[v], k = this.vertices[e], l = f[0], n = f[1], q = f[2], f = h.x - g.x, p = k.x - g.x, s = h.y - g.y, t = k.y - g.y, h = h.z - g.z, g = k.z - g.z, k = n.x - l.x, r = q.x - l.x, n = n.y - l.y, l = q.y - l.y, q = 1 / (k * l - r * n), c.set((l * f - n * p) * q, (l * s - n * t) * q, (l * h - n * g) * q), y.set((k * p - r * f) * q, (k * t - r * s) * q, (k * g - r * h) * q), w[d].add(c), w[v].add(c), w[e].add(c), u[d].add(y), u[v].add(y), u[e].add(y);
    y = [
      'a',
      'b',
      'c',
      'd'
    ];
    a = 0;
    for (b = this.faces.length; a < b; a++)
      for (e = this.faces[a], c = 0; c < Math.min(e.vertexNormals.length, 3); c++)
        N.copy(e.vertexNormals[c]), d = e[y[c]], v = w[d], L.copy(v), L.sub(N.multiplyScalar(N.dot(v))).normalize(), x.crossVectors(e.vertexNormals[c], v), d = x.dot(u[d]), d = 0 > d ? -1 : 1, e.vertexTangents[c] = new THREE.Vector4(L.x, L.y, L.z, d);
    this.hasTangents = !0;
  },
  computeLineDistances: function () {
    for (var a = 0, b = this.vertices, c = 0, d = b.length; c < d; c++)
      0 < c && (a += b[c].distanceTo(b[c - 1])), this.lineDistances[c] = a;
  },
  computeBoundingBox: function () {
    null === this.boundingBox && (this.boundingBox = new THREE.Box3());
    this.boundingBox.setFromPoints(this.vertices);
  },
  computeBoundingSphere: function () {
    null === this.boundingSphere && (this.boundingSphere = new THREE.Sphere());
    this.boundingSphere.setFromPoints(this.vertices);
  },
  merge: function (a, b, c) {
    if (!1 === a instanceof THREE.Geometry)
      console.error('THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', a);
    else {
      var d, e = this.vertices.length, f = this.vertices, g = a.vertices, h = this.faces, k = a.faces, l = this.faceVertexUvs[0];
      a = a.faceVertexUvs[0];
      void 0 === c && (c = 0);
      void 0 !== b && (d = new THREE.Matrix3().getNormalMatrix(b));
      for (var n = 0, q = g.length; n < q; n++) {
        var p = g[n].clone();
        void 0 !== b && p.applyMatrix4(b);
        f.push(p);
      }
      n = 0;
      for (q = k.length; n < q; n++) {
        var g = k[n], s, t = g.vertexNormals, r = g.vertexColors, p = new THREE.Face3(g.a + e, g.b + e, g.c + e);
        p.normal.copy(g.normal);
        void 0 !== d && p.normal.applyMatrix3(d).normalize();
        b = 0;
        for (f = t.length; b < f; b++)
          s = t[b].clone(), void 0 !== d && s.applyMatrix3(d).normalize(), p.vertexNormals.push(s);
        p.color.copy(g.color);
        b = 0;
        for (f = r.length; b < f; b++)
          s = r[b], p.vertexColors.push(s.clone());
        p.materialIndex = g.materialIndex + c;
        h.push(p);
      }
      n = 0;
      for (q = a.length; n < q; n++)
        if (c = a[n], d = [], void 0 !== c) {
          b = 0;
          for (f = c.length; b < f; b++)
            d.push(new THREE.Vector2(c[b].x, c[b].y));
          l.push(d);
        }
    }
  },
  mergeVertices: function () {
    var a = {}, b = [], c = [], d, e = Math.pow(10, 4), f, g;
    f = 0;
    for (g = this.vertices.length; f < g; f++)
      d = this.vertices[f], d = Math.round(d.x * e) + '_' + Math.round(d.y * e) + '_' + Math.round(d.z * e), void 0 === a[d] ? (a[d] = f, b.push(this.vertices[f]), c[f] = b.length - 1) : c[f] = c[a[d]];
    a = [];
    f = 0;
    for (g = this.faces.length; f < g; f++)
      for (e = this.faces[f], e.a = c[e.a], e.b = c[e.b], e.c = c[e.c], e = [
          e.a,
          e.b,
          e.c
        ], d = 0; 3 > d; d++)
        if (e[d] == e[(d + 1) % 3]) {
          a.push(f);
          break;
        }
    for (f = a.length - 1; 0 <= f; f--)
      for (e = a[f], this.faces.splice(e, 1), c = 0, g = this.faceVertexUvs.length; c < g; c++)
        this.faceVertexUvs[c].splice(e, 1);
    f = this.vertices.length - b.length;
    this.vertices = b;
    return f;
  },
  makeGroups: function () {
    var a = 0;
    return function (b, c) {
      var d, e, f, g, h = {}, k = this.morphTargets.length, l = this.morphNormals.length;
      this.geometryGroups = {};
      d = 0;
      for (e = this.faces.length; d < e; d++)
        f = this.faces[d], f = b ? f.materialIndex : 0, f in h || (h[f] = {
          hash: f,
          counter: 0
        }), g = h[f].hash + '_' + h[f].counter, g in this.geometryGroups || (this.geometryGroups[g] = {
          faces3: [],
          materialIndex: f,
          vertices: 0,
          numMorphTargets: k,
          numMorphNormals: l
        }), this.geometryGroups[g].vertices + 3 > c && (h[f].counter += 1, g = h[f].hash + '_' + h[f].counter, g in this.geometryGroups || (this.geometryGroups[g] = {
          faces3: [],
          materialIndex: f,
          vertices: 0,
          numMorphTargets: k,
          numMorphNormals: l
        })), this.geometryGroups[g].faces3.push(d), this.geometryGroups[g].vertices += 3;
      this.geometryGroupsList = [];
      for (var n in this.geometryGroups)
        this.geometryGroups[n].id = a++, this.geometryGroupsList.push(this.geometryGroups[n]);
    };
  }(),
  clone: function () {
    for (var a = new THREE.Geometry(), b = this.vertices, c = 0, d = b.length; c < d; c++)
      a.vertices.push(b[c].clone());
    b = this.faces;
    c = 0;
    for (d = b.length; c < d; c++)
      a.faces.push(b[c].clone());
    b = this.faceVertexUvs[0];
    c = 0;
    for (d = b.length; c < d; c++) {
      for (var e = b[c], f = [], g = 0, h = e.length; g < h; g++)
        f.push(new THREE.Vector2(e[g].x, e[g].y));
      a.faceVertexUvs[0].push(f);
    }
    return a;
  },
  dispose: function () {
    this.dispatchEvent({ type: 'dispose' });
  }
};
THREE.EventDispatcher.prototype.apply(THREE.Geometry.prototype);
THREE.GeometryIdCount = 0;
THREE.Camera = function () {
  THREE.Object3D.call(this);
  this.matrixWorldInverse = new THREE.Matrix4();
  this.projectionMatrix = new THREE.Matrix4();
};
THREE.Camera.prototype = Object.create(THREE.Object3D.prototype);
THREE.Camera.prototype.lookAt = function () {
  var a = new THREE.Matrix4();
  return function (b) {
    a.lookAt(this.position, b, this.up);
    this.quaternion.setFromRotationMatrix(a);
  };
}();
THREE.Camera.prototype.clone = function (a) {
  void 0 === a && (a = new THREE.Camera());
  THREE.Object3D.prototype.clone.call(this, a);
  a.matrixWorldInverse.copy(this.matrixWorldInverse);
  a.projectionMatrix.copy(this.projectionMatrix);
  return a;
};
THREE.OrthographicCamera = function (a, b, c, d, e, f) {
  THREE.Camera.call(this);
  this.left = a;
  this.right = b;
  this.top = c;
  this.bottom = d;
  this.near = void 0 !== e ? e : 0.1;
  this.far = void 0 !== f ? f : 2000;
  this.updateProjectionMatrix();
};
THREE.OrthographicCamera.prototype = Object.create(THREE.Camera.prototype);
THREE.OrthographicCamera.prototype.updateProjectionMatrix = function () {
  this.projectionMatrix.makeOrthographic(this.left, this.right, this.top, this.bottom, this.near, this.far);
};
THREE.OrthographicCamera.prototype.clone = function () {
  var a = new THREE.OrthographicCamera();
  THREE.Camera.prototype.clone.call(this, a);
  a.left = this.left;
  a.right = this.right;
  a.top = this.top;
  a.bottom = this.bottom;
  a.near = this.near;
  a.far = this.far;
  return a;
};
THREE.PerspectiveCamera = function (a, b, c, d) {
  THREE.Camera.call(this);
  this.fov = void 0 !== a ? a : 50;
  this.aspect = void 0 !== b ? b : 1;
  this.near = void 0 !== c ? c : 0.1;
  this.far = void 0 !== d ? d : 2000;
  this.updateProjectionMatrix();
};
THREE.PerspectiveCamera.prototype = Object.create(THREE.Camera.prototype);
THREE.PerspectiveCamera.prototype.setLens = function (a, b) {
  void 0 === b && (b = 24);
  this.fov = 2 * THREE.Math.radToDeg(Math.atan(b / (2 * a)));
  this.updateProjectionMatrix();
};
THREE.PerspectiveCamera.prototype.setViewOffset = function (a, b, c, d, e, f) {
  this.fullWidth = a;
  this.fullHeight = b;
  this.x = c;
  this.y = d;
  this.width = e;
  this.height = f;
  this.updateProjectionMatrix();
};
THREE.PerspectiveCamera.prototype.updateProjectionMatrix = function () {
  if (this.fullWidth) {
    var a = this.fullWidth / this.fullHeight, b = Math.tan(THREE.Math.degToRad(0.5 * this.fov)) * this.near, c = -b, d = a * c, a = Math.abs(a * b - d), c = Math.abs(b - c);
    this.projectionMatrix.makeFrustum(d + this.x * a / this.fullWidth, d + (this.x + this.width) * a / this.fullWidth, b - (this.y + this.height) * c / this.fullHeight, b - this.y * c / this.fullHeight, this.near, this.far);
  } else
    this.projectionMatrix.makePerspective(this.fov, this.aspect, this.near, this.far);
};
THREE.PerspectiveCamera.prototype.clone = function () {
  var a = new THREE.PerspectiveCamera();
  THREE.Camera.prototype.clone.call(this, a);
  a.fov = this.fov;
  a.aspect = this.aspect;
  a.near = this.near;
  a.far = this.far;
  return a;
};
THREE.Light = function (a) {
  THREE.Object3D.call(this);
  this.color = new THREE.Color(a);
};
THREE.Light.prototype = Object.create(THREE.Object3D.prototype);
THREE.Light.prototype.clone = function (a) {
  void 0 === a && (a = new THREE.Light());
  THREE.Object3D.prototype.clone.call(this, a);
  a.color.copy(this.color);
  return a;
};
THREE.AmbientLight = function (a) {
  THREE.Light.call(this, a);
};
THREE.AmbientLight.prototype = Object.create(THREE.Light.prototype);
THREE.AmbientLight.prototype.clone = function () {
  var a = new THREE.AmbientLight();
  THREE.Light.prototype.clone.call(this, a);
  return a;
};
THREE.AreaLight = function (a, b) {
  THREE.Light.call(this, a);
  this.normal = new THREE.Vector3(0, -1, 0);
  this.right = new THREE.Vector3(1, 0, 0);
  this.intensity = void 0 !== b ? b : 1;
  this.height = this.width = 1;
  this.constantAttenuation = 1.5;
  this.linearAttenuation = 0.5;
  this.quadraticAttenuation = 0.1;
};
THREE.AreaLight.prototype = Object.create(THREE.Light.prototype);
THREE.DirectionalLight = function (a, b) {
  THREE.Light.call(this, a);
  this.position.set(0, 1, 0);
  this.target = new THREE.Object3D();
  this.intensity = void 0 !== b ? b : 1;
  this.onlyShadow = this.castShadow = !1;
  this.shadowCameraNear = 50;
  this.shadowCameraFar = 5000;
  this.shadowCameraLeft = -500;
  this.shadowCameraTop = this.shadowCameraRight = 500;
  this.shadowCameraBottom = -500;
  this.shadowCameraVisible = !1;
  this.shadowBias = 0;
  this.shadowDarkness = 0.5;
  this.shadowMapHeight = this.shadowMapWidth = 512;
  this.shadowCascade = !1;
  this.shadowCascadeOffset = new THREE.Vector3(0, 0, -1000);
  this.shadowCascadeCount = 2;
  this.shadowCascadeBias = [
    0,
    0,
    0
  ];
  this.shadowCascadeWidth = [
    512,
    512,
    512
  ];
  this.shadowCascadeHeight = [
    512,
    512,
    512
  ];
  this.shadowCascadeNearZ = [
    -1,
    0.99,
    0.998
  ];
  this.shadowCascadeFarZ = [
    0.99,
    0.998,
    1
  ];
  this.shadowCascadeArray = [];
  this.shadowMatrix = this.shadowCamera = this.shadowMapSize = this.shadowMap = null;
};
THREE.DirectionalLight.prototype = Object.create(THREE.Light.prototype);
THREE.DirectionalLight.prototype.clone = function () {
  var a = new THREE.DirectionalLight();
  THREE.Light.prototype.clone.call(this, a);
  a.target = this.target.clone();
  a.intensity = this.intensity;
  a.castShadow = this.castShadow;
  a.onlyShadow = this.onlyShadow;
  a.shadowCameraNear = this.shadowCameraNear;
  a.shadowCameraFar = this.shadowCameraFar;
  a.shadowCameraLeft = this.shadowCameraLeft;
  a.shadowCameraRight = this.shadowCameraRight;
  a.shadowCameraTop = this.shadowCameraTop;
  a.shadowCameraBottom = this.shadowCameraBottom;
  a.shadowCameraVisible = this.shadowCameraVisible;
  a.shadowBias = this.shadowBias;
  a.shadowDarkness = this.shadowDarkness;
  a.shadowMapWidth = this.shadowMapWidth;
  a.shadowMapHeight = this.shadowMapHeight;
  a.shadowCascade = this.shadowCascade;
  a.shadowCascadeOffset.copy(this.shadowCascadeOffset);
  a.shadowCascadeCount = this.shadowCascadeCount;
  a.shadowCascadeBias = this.shadowCascadeBias.slice(0);
  a.shadowCascadeWidth = this.shadowCascadeWidth.slice(0);
  a.shadowCascadeHeight = this.shadowCascadeHeight.slice(0);
  a.shadowCascadeNearZ = this.shadowCascadeNearZ.slice(0);
  a.shadowCascadeFarZ = this.shadowCascadeFarZ.slice(0);
  return a;
};
THREE.HemisphereLight = function (a, b, c) {
  THREE.Light.call(this, a);
  this.position.set(0, 100, 0);
  this.groundColor = new THREE.Color(b);
  this.intensity = void 0 !== c ? c : 1;
};
THREE.HemisphereLight.prototype = Object.create(THREE.Light.prototype);
THREE.HemisphereLight.prototype.clone = function () {
  var a = new THREE.HemisphereLight();
  THREE.Light.prototype.clone.call(this, a);
  a.groundColor.copy(this.groundColor);
  a.intensity = this.intensity;
  return a;
};
THREE.PointLight = function (a, b, c) {
  THREE.Light.call(this, a);
  this.intensity = void 0 !== b ? b : 1;
  this.distance = void 0 !== c ? c : 0;
};
THREE.PointLight.prototype = Object.create(THREE.Light.prototype);
THREE.PointLight.prototype.clone = function () {
  var a = new THREE.PointLight();
  THREE.Light.prototype.clone.call(this, a);
  a.intensity = this.intensity;
  a.distance = this.distance;
  return a;
};
THREE.SpotLight = function (a, b, c, d, e) {
  THREE.Light.call(this, a);
  this.position.set(0, 1, 0);
  this.target = new THREE.Object3D();
  this.intensity = void 0 !== b ? b : 1;
  this.distance = void 0 !== c ? c : 0;
  this.angle = void 0 !== d ? d : Math.PI / 3;
  this.exponent = void 0 !== e ? e : 10;
  this.onlyShadow = this.castShadow = !1;
  this.shadowCameraNear = 50;
  this.shadowCameraFar = 5000;
  this.shadowCameraFov = 50;
  this.shadowCameraVisible = !1;
  this.shadowBias = 0;
  this.shadowDarkness = 0.5;
  this.shadowMapHeight = this.shadowMapWidth = 512;
  this.shadowMatrix = this.shadowCamera = this.shadowMapSize = this.shadowMap = null;
};
THREE.SpotLight.prototype = Object.create(THREE.Light.prototype);
THREE.SpotLight.prototype.clone = function () {
  var a = new THREE.SpotLight();
  THREE.Light.prototype.clone.call(this, a);
  a.target = this.target.clone();
  a.intensity = this.intensity;
  a.distance = this.distance;
  a.angle = this.angle;
  a.exponent = this.exponent;
  a.castShadow = this.castShadow;
  a.onlyShadow = this.onlyShadow;
  a.shadowCameraNear = this.shadowCameraNear;
  a.shadowCameraFar = this.shadowCameraFar;
  a.shadowCameraFov = this.shadowCameraFov;
  a.shadowCameraVisible = this.shadowCameraVisible;
  a.shadowBias = this.shadowBias;
  a.shadowDarkness = this.shadowDarkness;
  a.shadowMapWidth = this.shadowMapWidth;
  a.shadowMapHeight = this.shadowMapHeight;
  return a;
};
THREE.Cache = function () {
  this.files = {};
};
THREE.Cache.prototype = {
  constructor: THREE.Cache,
  add: function (a, b) {
    this.files[a] = b;
  },
  get: function (a) {
    return this.files[a];
  },
  remove: function (a) {
    delete this.files[a];
  },
  clear: function () {
    this.files = {};
  }
};
THREE.Loader = function (a) {
  this.statusDomElement = (this.showStatus = a) ? THREE.Loader.prototype.addStatusElement() : null;
  this.imageLoader = new THREE.ImageLoader();
  this.onLoadStart = function () {
  };
  this.onLoadProgress = function () {
  };
  this.onLoadComplete = function () {
  };
};
THREE.Loader.prototype = {
  constructor: THREE.Loader,
  crossOrigin: void 0,
  addStatusElement: function () {
    var a = document.createElement('div');
    a.style.position = 'absolute';
    a.style.right = '0px';
    a.style.top = '0px';
    a.style.fontSize = '0.8em';
    a.style.textAlign = 'left';
    a.style.background = 'rgba(0,0,0,0.25)';
    a.style.color = '#fff';
    a.style.width = '120px';
    a.style.padding = '0.5em 0.5em 0.5em 0.5em';
    a.style.zIndex = 1000;
    a.innerHTML = 'Loading ...';
    return a;
  },
  updateProgress: function (a) {
    var b = 'Loaded ', b = a.total ? b + ((100 * a.loaded / a.total).toFixed(0) + '%') : b + ((a.loaded / 1024).toFixed(2) + ' KB');
    this.statusDomElement.innerHTML = b;
  },
  extractUrlBase: function (a) {
    a = a.split('/');
    if (1 === a.length)
      return './';
    a.pop();
    return a.join('/') + '/';
  },
  initMaterials: function (a, b) {
    for (var c = [], d = 0; d < a.length; ++d)
      c[d] = this.createMaterial(a[d], b);
    return c;
  },
  needsTangents: function (a) {
    for (var b = 0, c = a.length; b < c; b++)
      if (a[b] instanceof THREE.ShaderMaterial)
        return !0;
    return !1;
  },
  createMaterial: function (a, b) {
    function c(a) {
      a = Math.log(a) / Math.LN2;
      return Math.pow(2, Math.round(a));
    }
    function d(a, d, e, g, h, k, r) {
      var v = /\.dds$/i.test(e), w = b + e;
      if (v) {
        var u = THREE.ImageUtils.loadCompressedTexture(w);
        a[d] = u;
      } else
        u = document.createElement('canvas'), a[d] = new THREE.Texture(u);
      a[d].sourceFile = e;
      g && (a[d].repeat.set(g[0], g[1]), 1 !== g[0] && (a[d].wrapS = THREE.RepeatWrapping), 1 !== g[1] && (a[d].wrapT = THREE.RepeatWrapping));
      h && a[d].offset.set(h[0], h[1]);
      k && (e = {
        repeat: THREE.RepeatWrapping,
        mirror: THREE.MirroredRepeatWrapping
      }, void 0 !== e[k[0]] && (a[d].wrapS = e[k[0]]), void 0 !== e[k[1]] && (a[d].wrapT = e[k[1]]));
      r && (a[d].anisotropy = r);
      v || (u = a[d], f.imageLoader.crossOrigin = f.crossOrigin, f.imageLoader.load(w, function (a) {
        if (!1 === THREE.Math.isPowerOfTwo(a.width) || !1 === THREE.Math.isPowerOfTwo(a.height)) {
          var b = c(a.width), d = c(a.height);
          u.image.width = b;
          u.image.height = d;
          u.image.getContext('2d').drawImage(a, 0, 0, b, d);
        } else
          u.image = a;
        u.needsUpdate = !0;
      }));
    }
    function e(a) {
      return (255 * a[0] << 16) + (255 * a[1] << 8) + 255 * a[2];
    }
    var f = this, g = 'MeshLambertMaterial', h = {
        color: 15658734,
        opacity: 1,
        map: null,
        lightMap: null,
        normalMap: null,
        bumpMap: null,
        wireframe: !1
      };
    if (a.shading) {
      var k = a.shading.toLowerCase();
      'phong' === k ? g = 'MeshPhongMaterial' : 'basic' === k && (g = 'MeshBasicMaterial');
    }
    void 0 !== a.blending && void 0 !== THREE[a.blending] && (h.blending = THREE[a.blending]);
    if (void 0 !== a.transparent || 1 > a.opacity)
      h.transparent = a.transparent;
    void 0 !== a.depthTest && (h.depthTest = a.depthTest);
    void 0 !== a.depthWrite && (h.depthWrite = a.depthWrite);
    void 0 !== a.visible && (h.visible = a.visible);
    void 0 !== a.flipSided && (h.side = THREE.BackSide);
    void 0 !== a.doubleSided && (h.side = THREE.DoubleSide);
    void 0 !== a.wireframe && (h.wireframe = a.wireframe);
    void 0 !== a.vertexColors && ('face' === a.vertexColors ? h.vertexColors = THREE.FaceColors : a.vertexColors && (h.vertexColors = THREE.VertexColors));
    a.colorDiffuse ? h.color = e(a.colorDiffuse) : a.DbgColor && (h.color = a.DbgColor);
    a.colorSpecular && (h.specular = e(a.colorSpecular));
    a.colorAmbient && (h.ambient = e(a.colorAmbient));
    a.colorEmissive && (h.emissive = e(a.colorEmissive));
    a.transparency && (h.opacity = a.transparency);
    a.specularCoef && (h.shininess = a.specularCoef);
    a.mapDiffuse && b && d(h, 'map', a.mapDiffuse, a.mapDiffuseRepeat, a.mapDiffuseOffset, a.mapDiffuseWrap, a.mapDiffuseAnisotropy);
    a.mapLight && b && d(h, 'lightMap', a.mapLight, a.mapLightRepeat, a.mapLightOffset, a.mapLightWrap, a.mapLightAnisotropy);
    a.mapBump && b && d(h, 'bumpMap', a.mapBump, a.mapBumpRepeat, a.mapBumpOffset, a.mapBumpWrap, a.mapBumpAnisotropy);
    a.mapNormal && b && d(h, 'normalMap', a.mapNormal, a.mapNormalRepeat, a.mapNormalOffset, a.mapNormalWrap, a.mapNormalAnisotropy);
    a.mapSpecular && b && d(h, 'specularMap', a.mapSpecular, a.mapSpecularRepeat, a.mapSpecularOffset, a.mapSpecularWrap, a.mapSpecularAnisotropy);
    a.mapBumpScale && (h.bumpScale = a.mapBumpScale);
    a.mapNormal ? (g = THREE.ShaderLib.normalmap, k = THREE.UniformsUtils.clone(g.uniforms), k.tNormal.value = h.normalMap, a.mapNormalFactor && k.uNormalScale.value.set(a.mapNormalFactor, a.mapNormalFactor), h.map && (k.tDiffuse.value = h.map, k.enableDiffuse.value = !0), h.specularMap && (k.tSpecular.value = h.specularMap, k.enableSpecular.value = !0), h.lightMap && (k.tAO.value = h.lightMap, k.enableAO.value = !0), k.diffuse.value.setHex(h.color), k.specular.value.setHex(h.specular), k.ambient.value.setHex(h.ambient), k.shininess.value = h.shininess, void 0 !== h.opacity && (k.opacity.value = h.opacity), g = new THREE.ShaderMaterial({
      fragmentShader: g.fragmentShader,
      vertexShader: g.vertexShader,
      uniforms: k,
      lights: !0,
      fog: !0
    }), h.transparent && (g.transparent = !0)) : g = new THREE[g](h);
    void 0 !== a.DbgName && (g.name = a.DbgName);
    return g;
  }
};
THREE.XHRLoader = function (a) {
  this.cache = new THREE.Cache();
  this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
};
THREE.XHRLoader.prototype = {
  constructor: THREE.XHRLoader,
  load: function (a, b, c, d) {
    var e = this, f = e.cache.get(a);
    void 0 !== f ? b(f) : (f = new XMLHttpRequest(), void 0 !== b && f.addEventListener('load', function (c) {
      e.cache.add(a, c.target.responseText);
      b(c.target.responseText);
      e.manager.itemEnd(a);
    }, !1), void 0 !== c && f.addEventListener('progress', function (a) {
      c(a);
    }, !1), void 0 !== d && f.addEventListener('error', function (a) {
      d(a);
    }, !1), void 0 !== this.crossOrigin && (f.crossOrigin = this.crossOrigin), f.open('GET', a, !0), f.send(null), e.manager.itemStart(a));
  },
  setCrossOrigin: function (a) {
    this.crossOrigin = a;
  }
};
THREE.ImageLoader = function (a) {
  this.cache = new THREE.Cache();
  this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
};
THREE.ImageLoader.prototype = {
  constructor: THREE.ImageLoader,
  load: function (a, b, c, d) {
    var e = this, f = e.cache.get(a);
    if (void 0 !== f)
      b(f);
    else
      return f = document.createElement('img'), void 0 !== b && f.addEventListener('load', function (c) {
        e.cache.add(a, this);
        b(this);
        e.manager.itemEnd(a);
      }, !1), void 0 !== c && f.addEventListener('progress', function (a) {
        c(a);
      }, !1), void 0 !== d && f.addEventListener('error', function (a) {
        d(a);
      }, !1), void 0 !== this.crossOrigin && (f.crossOrigin = this.crossOrigin), f.src = a, e.manager.itemStart(a), f;
  },
  setCrossOrigin: function (a) {
    this.crossOrigin = a;
  }
};
THREE.JSONLoader = function (a) {
  THREE.Loader.call(this, a);
  this.withCredentials = !1;
};
THREE.JSONLoader.prototype = Object.create(THREE.Loader.prototype);
THREE.JSONLoader.prototype.load = function (a, b, c) {
  c = c && 'string' === typeof c ? c : this.extractUrlBase(a);
  this.onLoadStart();
  this.loadAjaxJSON(this, a, b, c);
};
THREE.JSONLoader.prototype.loadAjaxJSON = function (a, b, c, d, e) {
  var f = new XMLHttpRequest(), g = 0;
  f.onreadystatechange = function () {
    if (f.readyState === f.DONE)
      if (200 === f.status || 0 === f.status) {
        if (f.responseText) {
          var h = JSON.parse(f.responseText);
          if (void 0 !== h.metadata && 'scene' === h.metadata.type) {
            console.error('THREE.JSONLoader: "' + b + '" seems to be a Scene. Use THREE.SceneLoader instead.');
            return;
          }
          h = a.parse(h, d);
          c(h.geometry, h.materials);
        } else
          console.error('THREE.JSONLoader: "' + b + '" seems to be unreachable or the file is empty.');
        a.onLoadComplete();
      } else
        console.error('THREE.JSONLoader: Couldn\'t load "' + b + '" (' + f.status + ')');
    else
      f.readyState === f.LOADING ? e && (0 === g && (g = f.getResponseHeader('Content-Length')), e({
        total: g,
        loaded: f.responseText.length
      })) : f.readyState === f.HEADERS_RECEIVED && void 0 !== e && (g = f.getResponseHeader('Content-Length'));
  };
  f.open('GET', b, !0);
  f.withCredentials = this.withCredentials;
  f.send(null);
};
THREE.JSONLoader.prototype.parse = function (a, b) {
  var c = new THREE.Geometry(), d = void 0 !== a.scale ? 1 / a.scale : 1;
  (function (b) {
    var d, g, h, k, l, n, q, p, s, t, r, v, w, u = a.faces;
    n = a.vertices;
    var y = a.normals, L = a.colors, x = 0;
    if (void 0 !== a.uvs) {
      for (d = 0; d < a.uvs.length; d++)
        a.uvs[d].length && x++;
      for (d = 0; d < x; d++)
        c.faceVertexUvs[d] = [];
    }
    k = 0;
    for (l = n.length; k < l;)
      d = new THREE.Vector3(), d.x = n[k++] * b, d.y = n[k++] * b, d.z = n[k++] * b, c.vertices.push(d);
    k = 0;
    for (l = u.length; k < l;)
      if (b = u[k++], s = b & 1, h = b & 2, d = b & 8, q = b & 16, t = b & 32, n = b & 64, b &= 128, s) {
        s = new THREE.Face3();
        s.a = u[k];
        s.b = u[k + 1];
        s.c = u[k + 3];
        r = new THREE.Face3();
        r.a = u[k + 1];
        r.b = u[k + 2];
        r.c = u[k + 3];
        k += 4;
        h && (h = u[k++], s.materialIndex = h, r.materialIndex = h);
        h = c.faces.length;
        if (d)
          for (d = 0; d < x; d++)
            for (v = a.uvs[d], c.faceVertexUvs[d][h] = [], c.faceVertexUvs[d][h + 1] = [], g = 0; 4 > g; g++)
              p = u[k++], w = v[2 * p], p = v[2 * p + 1], w = new THREE.Vector2(w, p), 2 !== g && c.faceVertexUvs[d][h].push(w), 0 !== g && c.faceVertexUvs[d][h + 1].push(w);
        q && (q = 3 * u[k++], s.normal.set(y[q++], y[q++], y[q]), r.normal.copy(s.normal));
        if (t)
          for (d = 0; 4 > d; d++)
            q = 3 * u[k++], t = new THREE.Vector3(y[q++], y[q++], y[q]), 2 !== d && s.vertexNormals.push(t), 0 !== d && r.vertexNormals.push(t);
        n && (n = u[k++], n = L[n], s.color.setHex(n), r.color.setHex(n));
        if (b)
          for (d = 0; 4 > d; d++)
            n = u[k++], n = L[n], 2 !== d && s.vertexColors.push(new THREE.Color(n)), 0 !== d && r.vertexColors.push(new THREE.Color(n));
        c.faces.push(s);
        c.faces.push(r);
      } else {
        s = new THREE.Face3();
        s.a = u[k++];
        s.b = u[k++];
        s.c = u[k++];
        h && (h = u[k++], s.materialIndex = h);
        h = c.faces.length;
        if (d)
          for (d = 0; d < x; d++)
            for (v = a.uvs[d], c.faceVertexUvs[d][h] = [], g = 0; 3 > g; g++)
              p = u[k++], w = v[2 * p], p = v[2 * p + 1], w = new THREE.Vector2(w, p), c.faceVertexUvs[d][h].push(w);
        q && (q = 3 * u[k++], s.normal.set(y[q++], y[q++], y[q]));
        if (t)
          for (d = 0; 3 > d; d++)
            q = 3 * u[k++], t = new THREE.Vector3(y[q++], y[q++], y[q]), s.vertexNormals.push(t);
        n && (n = u[k++], s.color.setHex(L[n]));
        if (b)
          for (d = 0; 3 > d; d++)
            n = u[k++], s.vertexColors.push(new THREE.Color(L[n]));
        c.faces.push(s);
      }
  }(d));
  (function () {
    var b = void 0 !== a.influencesPerVertex ? a.influencesPerVertex : 2;
    if (a.skinWeights)
      for (var d = 0, g = a.skinWeights.length; d < g; d += b)
        c.skinWeights.push(new THREE.Vector4(a.skinWeights[d], 1 < b ? a.skinWeights[d + 1] : 0, 2 < b ? a.skinWeights[d + 2] : 0, 3 < b ? a.skinWeights[d + 3] : 0));
    if (a.skinIndices)
      for (d = 0, g = a.skinIndices.length; d < g; d += b)
        c.skinIndices.push(new THREE.Vector4(a.skinIndices[d], 1 < b ? a.skinIndices[d + 1] : 0, 2 < b ? a.skinIndices[d + 2] : 0, 3 < b ? a.skinIndices[d + 3] : 0));
    c.bones = a.bones;
    c.bones && 0 < c.bones.length && (c.skinWeights.length !== c.skinIndices.length || c.skinIndices.length !== c.vertices.length) && console.warn('When skinning, number of vertices (' + c.vertices.length + '), skinIndices (' + c.skinIndices.length + '), and skinWeights (' + c.skinWeights.length + ') should match.');
    c.animation = a.animation;
    c.animations = a.animations;
  }());
  (function (b) {
    if (void 0 !== a.morphTargets) {
      var d, g, h, k, l, n;
      d = 0;
      for (g = a.morphTargets.length; d < g; d++)
        for (c.morphTargets[d] = {}, c.morphTargets[d].name = a.morphTargets[d].name, c.morphTargets[d].vertices = [], l = c.morphTargets[d].vertices, n = a.morphTargets[d].vertices, h = 0, k = n.length; h < k; h += 3) {
          var q = new THREE.Vector3();
          q.x = n[h] * b;
          q.y = n[h + 1] * b;
          q.z = n[h + 2] * b;
          l.push(q);
        }
    }
    if (void 0 !== a.morphColors)
      for (d = 0, g = a.morphColors.length; d < g; d++)
        for (c.morphColors[d] = {}, c.morphColors[d].name = a.morphColors[d].name, c.morphColors[d].colors = [], k = c.morphColors[d].colors, l = a.morphColors[d].colors, b = 0, h = l.length; b < h; b += 3)
          n = new THREE.Color(16755200), n.setRGB(l[b], l[b + 1], l[b + 2]), k.push(n);
  }(d));
  c.computeFaceNormals();
  c.computeBoundingSphere();
  if (void 0 === a.materials || 0 === a.materials.length)
    return { geometry: c };
  d = this.initMaterials(a.materials, b);
  this.needsTangents(d) && c.computeTangents();
  return {
    geometry: c,
    materials: d
  };
};
THREE.LoadingManager = function (a, b, c) {
  var d = this, e = 0, f = 0;
  this.onLoad = a;
  this.onProgress = b;
  this.onError = c;
  this.itemStart = function (a) {
    f++;
  };
  this.itemEnd = function (a) {
    e++;
    if (void 0 !== d.onProgress)
      d.onProgress(a, e, f);
    if (e === f && void 0 !== d.onLoad)
      d.onLoad();
  };
};
THREE.DefaultLoadingManager = new THREE.LoadingManager();
THREE.BufferGeometryLoader = function (a) {
  this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
};
THREE.BufferGeometryLoader.prototype = {
  constructor: THREE.BufferGeometryLoader,
  load: function (a, b, c, d) {
    var e = this;
    c = new THREE.XHRLoader();
    c.setCrossOrigin(this.crossOrigin);
    c.load(a, function (a) {
      b(e.parse(JSON.parse(a)));
    });
  },
  setCrossOrigin: function (a) {
    this.crossOrigin = a;
  },
  parse: function (a) {
    var b = new THREE.BufferGeometry(), c = a.attributes, d = a.offsets;
    a = a.boundingSphere;
    for (var e in c) {
      var f = c[e];
      b.attributes[e] = {
        itemSize: f.itemSize,
        array: new self[f.type](f.array)
      };
    }
    void 0 !== d && (b.offsets = JSON.parse(JSON.stringify(d)));
    void 0 !== a && (b.boundingSphere = new THREE.Sphere(new THREE.Vector3().fromArray(void 0 !== a.center ? a.center : [
      0,
      0,
      0
    ]), a.radius));
    return b;
  }
};
THREE.MaterialLoader = function (a) {
  this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
};
THREE.MaterialLoader.prototype = {
  constructor: THREE.MaterialLoader,
  load: function (a, b, c, d) {
    var e = this;
    c = new THREE.XHRLoader();
    c.setCrossOrigin(this.crossOrigin);
    c.load(a, function (a) {
      b(e.parse(JSON.parse(a)));
    });
  },
  setCrossOrigin: function (a) {
    this.crossOrigin = a;
  },
  parse: function (a) {
    var b = new THREE[a.type]();
    void 0 !== a.color && b.color.setHex(a.color);
    void 0 !== a.ambient && b.ambient.setHex(a.ambient);
    void 0 !== a.emissive && b.emissive.setHex(a.emissive);
    void 0 !== a.specular && b.specular.setHex(a.specular);
    void 0 !== a.shininess && (b.shininess = a.shininess);
    void 0 !== a.vertexColors && (b.vertexColors = a.vertexColors);
    void 0 !== a.blending && (b.blending = a.blending);
    void 0 !== a.side && (b.side = a.side);
    void 0 !== a.opacity && (b.opacity = a.opacity);
    void 0 !== a.transparent && (b.transparent = a.transparent);
    void 0 !== a.wireframe && (b.wireframe = a.wireframe);
    if (void 0 !== a.materials)
      for (var c = 0, d = a.materials.length; c < d; c++)
        b.materials.push(this.parse(a.materials[c]));
    return b;
  }
};
THREE.ObjectLoader = function (a) {
  this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
};
THREE.ObjectLoader.prototype = {
  constructor: THREE.ObjectLoader,
  load: function (a, b, c, d) {
    var e = this;
    c = new THREE.XHRLoader(e.manager);
    c.setCrossOrigin(this.crossOrigin);
    c.load(a, function (a) {
      b(e.parse(JSON.parse(a)));
    });
  },
  setCrossOrigin: function (a) {
    this.crossOrigin = a;
  },
  parse: function (a) {
    var b = this.parseGeometries(a.geometries), c = this.parseMaterials(a.materials);
    return this.parseObject(a.object, b, c);
  },
  parseGeometries: function (a) {
    var b = {};
    if (void 0 !== a)
      for (var c = new THREE.JSONLoader(), d = new THREE.BufferGeometryLoader(), e = 0, f = a.length; e < f; e++) {
        var g, h = a[e];
        switch (h.type) {
        case 'PlaneGeometry':
          g = new THREE.PlaneGeometry(h.width, h.height, h.widthSegments, h.heightSegments);
          break;
        case 'BoxGeometry':
        case 'CubeGeometry':
          g = new THREE.BoxGeometry(h.width, h.height, h.depth, h.widthSegments, h.heightSegments, h.depthSegments);
          break;
        case 'CircleGeometry':
          g = new THREE.CircleGeometry(h.radius, h.segments);
          break;
        case 'CylinderGeometry':
          g = new THREE.CylinderGeometry(h.radiusTop, h.radiusBottom, h.height, h.radialSegments, h.heightSegments, h.openEnded);
          break;
        case 'SphereGeometry':
          g = new THREE.SphereGeometry(h.radius, h.widthSegments, h.heightSegments, h.phiStart, h.phiLength, h.thetaStart, h.thetaLength);
          break;
        case 'IcosahedronGeometry':
          g = new THREE.IcosahedronGeometry(h.radius, h.detail);
          break;
        case 'TorusGeometry':
          g = new THREE.TorusGeometry(h.radius, h.tube, h.radialSegments, h.tubularSegments, h.arc);
          break;
        case 'TorusKnotGeometry':
          g = new THREE.TorusKnotGeometry(h.radius, h.tube, h.radialSegments, h.tubularSegments, h.p, h.q, h.heightScale);
          break;
        case 'BufferGeometry':
          g = d.parse(h.data);
          break;
        case 'Geometry':
          g = c.parse(h.data).geometry;
        }
        g.uuid = h.uuid;
        void 0 !== h.name && (g.name = h.name);
        b[h.uuid] = g;
      }
    return b;
  },
  parseMaterials: function (a) {
    var b = {};
    if (void 0 !== a)
      for (var c = new THREE.MaterialLoader(), d = 0, e = a.length; d < e; d++) {
        var f = a[d], g = c.parse(f);
        g.uuid = f.uuid;
        void 0 !== f.name && (g.name = f.name);
        b[f.uuid] = g;
      }
    return b;
  },
  parseObject: function () {
    var a = new THREE.Matrix4();
    return function (b, c, d) {
      var e;
      switch (b.type) {
      case 'Scene':
        e = new THREE.Scene();
        break;
      case 'PerspectiveCamera':
        e = new THREE.PerspectiveCamera(b.fov, b.aspect, b.near, b.far);
        break;
      case 'OrthographicCamera':
        e = new THREE.OrthographicCamera(b.left, b.right, b.top, b.bottom, b.near, b.far);
        break;
      case 'AmbientLight':
        e = new THREE.AmbientLight(b.color);
        break;
      case 'DirectionalLight':
        e = new THREE.DirectionalLight(b.color, b.intensity);
        break;
      case 'PointLight':
        e = new THREE.PointLight(b.color, b.intensity, b.distance);
        break;
      case 'SpotLight':
        e = new THREE.SpotLight(b.color, b.intensity, b.distance, b.angle, b.exponent);
        break;
      case 'HemisphereLight':
        e = new THREE.HemisphereLight(b.color, b.groundColor, b.intensity);
        break;
      case 'Mesh':
        e = c[b.geometry];
        var f = d[b.material];
        void 0 === e && console.error('THREE.ObjectLoader: Undefined geometry ' + b.geometry);
        void 0 === f && console.error('THREE.ObjectLoader: Undefined material ' + b.material);
        e = new THREE.Mesh(e, f);
        break;
      case 'Sprite':
        f = d[b.material];
        void 0 === f && console.error('THREE.ObjectLoader: Undefined material ' + b.material);
        e = new THREE.Sprite(f);
        break;
      default:
        e = new THREE.Object3D();
      }
      e.uuid = b.uuid;
      void 0 !== b.name && (e.name = b.name);
      void 0 !== b.matrix ? (a.fromArray(b.matrix), a.decompose(e.position, e.quaternion, e.scale)) : (void 0 !== b.position && e.position.fromArray(b.position), void 0 !== b.rotation && e.rotation.fromArray(b.rotation), void 0 !== b.scale && e.scale.fromArray(b.scale));
      void 0 !== b.visible && (e.visible = b.visible);
      void 0 !== b.userData && (e.userData = b.userData);
      if (void 0 !== b.children)
        for (var g in b.children)
          e.add(this.parseObject(b.children[g], c, d));
      return e;
    };
  }()
};
THREE.SceneLoader = function () {
  this.onLoadStart = function () {
  };
  this.onLoadProgress = function () {
  };
  this.onLoadComplete = function () {
  };
  this.callbackSync = function () {
  };
  this.callbackProgress = function () {
  };
  this.geometryHandlers = {};
  this.hierarchyHandlers = {};
  this.addGeometryHandler('ascii', THREE.JSONLoader);
};
THREE.SceneLoader.prototype = {
  constructor: THREE.SceneLoader,
  load: function (a, b, c, d) {
    var e = this;
    c = new THREE.XHRLoader(e.manager);
    c.setCrossOrigin(this.crossOrigin);
    c.load(a, function (c) {
      e.parse(JSON.parse(c), b, a);
    });
  },
  setCrossOrigin: function (a) {
    this.crossOrigin = a;
  },
  addGeometryHandler: function (a, b) {
    this.geometryHandlers[a] = { loaderClass: b };
  },
  addHierarchyHandler: function (a, b) {
    this.hierarchyHandlers[a] = { loaderClass: b };
  },
  parse: function (a, b, c) {
    function d(a, b) {
      return 'relativeToHTML' == b ? a : s + a;
    }
    function e() {
      f(B.scene, A.objects);
    }
    function f(a, b) {
      var c, e, g, h, l, n;
      for (n in b) {
        var q = B.objects[n], s = b[n];
        if (void 0 === q) {
          if (s.type && s.type in p.hierarchyHandlers) {
            if (void 0 === s.loading) {
              c = {
                type: 1,
                url: 1,
                material: 1,
                position: 1,
                rotation: 1,
                scale: 1,
                visible: 1,
                children: 1,
                userData: 1,
                skin: 1,
                morph: 1,
                mirroredLoop: 1,
                duration: 1
              };
              var u = {}, w;
              for (w in s)
                w in c || (u[w] = s[w]);
              r = B.materials[s.material];
              s.loading = !0;
              c = p.hierarchyHandlers[s.type].loaderObject;
              c.options ? c.load(d(s.url, A.urlBaseType), k(n, a, r, s)) : c.load(d(s.url, A.urlBaseType), k(n, a, r, s), u);
            }
          } else if (void 0 !== s.geometry) {
            if (t = B.geometries[s.geometry]) {
              q = !1;
              r = B.materials[s.material];
              q = r instanceof THREE.ShaderMaterial;
              e = s.position;
              g = s.rotation;
              h = s.scale;
              c = s.matrix;
              l = s.quaternion;
              s.material || (r = new THREE.MeshFaceMaterial(B.face_materials[s.geometry]));
              r instanceof THREE.MeshFaceMaterial && 0 === r.materials.length && (r = new THREE.MeshFaceMaterial(B.face_materials[s.geometry]));
              if (r instanceof THREE.MeshFaceMaterial)
                for (u = 0; u < r.materials.length; u++)
                  q = q || r.materials[u] instanceof THREE.ShaderMaterial;
              q && t.computeTangents();
              s.skin ? q = new THREE.SkinnedMesh(t, r) : s.morph ? (q = new THREE.MorphAnimMesh(t, r), void 0 !== s.duration && (q.duration = s.duration), void 0 !== s.time && (q.time = s.time), void 0 !== s.mirroredLoop && (q.mirroredLoop = s.mirroredLoop), r.morphNormals && t.computeMorphNormals()) : q = new THREE.Mesh(t, r);
              q.name = n;
              c ? (q.matrixAutoUpdate = !1, q.matrix.set(c[0], c[1], c[2], c[3], c[4], c[5], c[6], c[7], c[8], c[9], c[10], c[11], c[12], c[13], c[14], c[15])) : (q.position.fromArray(e), l ? q.quaternion.fromArray(l) : q.rotation.fromArray(g), q.scale.fromArray(h));
              q.visible = s.visible;
              q.castShadow = s.castShadow;
              q.receiveShadow = s.receiveShadow;
              a.add(q);
              B.objects[n] = q;
            }
          } else if ('AmbientLight' === s.type || 'PointLight' === s.type || 'DirectionalLight' === s.type || 'SpotLight' === s.type || 'HemisphereLight' === s.type || 'AreaLight' === s.type) {
            u = s.color;
            c = s.intensity;
            e = s.distance;
            g = s.position;
            h = s.rotation;
            switch (s.type) {
            case 'AmbientLight':
              y = new THREE.AmbientLight(u);
              break;
            case 'PointLight':
              y = new THREE.PointLight(u, c, e);
              y.position.fromArray(g);
              break;
            case 'DirectionalLight':
              y = new THREE.DirectionalLight(u, c);
              y.position.fromArray(s.direction);
              break;
            case 'SpotLight':
              y = new THREE.SpotLight(u, c, e, 1);
              y.angle = s.angle;
              y.position.fromArray(g);
              y.target.set(g[0], g[1] - e, g[2]);
              y.target.applyEuler(new THREE.Euler(h[0], h[1], h[2], 'XYZ'));
              break;
            case 'HemisphereLight':
              y = new THREE.DirectionalLight(u, c, e);
              y.target.set(g[0], g[1] - e, g[2]);
              y.target.applyEuler(new THREE.Euler(h[0], h[1], h[2], 'XYZ'));
              break;
            case 'AreaLight':
              y = new THREE.AreaLight(u, c), y.position.fromArray(g), y.width = s.size, y.height = s.size_y;
            }
            a.add(y);
            y.name = n;
            B.lights[n] = y;
            B.objects[n] = y;
          } else
            'PerspectiveCamera' === s.type || 'OrthographicCamera' === s.type ? (e = s.position, g = s.rotation, l = s.quaternion, 'PerspectiveCamera' === s.type ? v = new THREE.PerspectiveCamera(s.fov, s.aspect, s.near, s.far) : 'OrthographicCamera' === s.type && (v = new THREE.OrthographicCamera(s.left, s.right, s.top, s.bottom, s.near, s.far)), v.name = n, v.position.fromArray(e), void 0 !== l ? v.quaternion.fromArray(l) : void 0 !== g && v.rotation.fromArray(g), a.add(v), B.cameras[n] = v, B.objects[n] = v) : (e = s.position, g = s.rotation, h = s.scale, l = s.quaternion, q = new THREE.Object3D(), q.name = n, q.position.fromArray(e), l ? q.quaternion.fromArray(l) : q.rotation.fromArray(g), q.scale.fromArray(h), q.visible = void 0 !== s.visible ? s.visible : !1, a.add(q), B.objects[n] = q, B.empties[n] = q);
          if (q) {
            if (void 0 !== s.userData)
              for (var L in s.userData)
                q.userData[L] = s.userData[L];
            if (void 0 !== s.groups)
              for (u = 0; u < s.groups.length; u++)
                c = s.groups[u], void 0 === B.groups[c] && (B.groups[c] = []), B.groups[c].push(n);
          }
        }
        void 0 !== q && void 0 !== s.children && f(q, s.children);
      }
    }
    function g(a, b, c, d, f) {
      var g = f.rotation, h = f.quaternion, k = f.scale;
      a.position.fromArray(f.position);
      h ? a.quaternion.fromArray(h) : a.rotation.fromArray(g);
      a.scale.fromArray(k);
      d && a.traverse(function (a) {
        a.material = d;
      });
      var l = void 0 !== f.visible ? f.visible : !0;
      a.traverse(function (a) {
        a.visible = l;
      });
      c.add(a);
      a.name = b;
      B.objects[b] = a;
      e();
    }
    function h(a) {
      return function (b, c) {
        b.name = a;
        B.geometries[a] = b;
        B.face_materials[a] = c;
        e();
        L -= 1;
        p.onLoadComplete();
        n();
      };
    }
    function k(a, b, c, d) {
      return function (e) {
        g(e.content ? e.content : e.dae ? e.scene : e, a, b, c, d);
        L -= 1;
        p.onLoadComplete();
        n();
      };
    }
    function l(a) {
      return function (b, c) {
        b.name = a;
        B.geometries[a] = b;
        B.face_materials[a] = c;
      };
    }
    function n() {
      p.callbackProgress({
        totalModels: N,
        totalTextures: J,
        loadedModels: N - L,
        loadedTextures: J - x
      }, B);
      p.onLoadProgress();
      if (0 === L && 0 === x) {
        for (var a = 0; a < K.length; a++) {
          var c = K[a], d = B.objects[c.targetName];
          d ? c.object.target = d : (c.object.target = new THREE.Object3D(), B.scene.add(c.object.target));
          c.object.target.userData.targetInverse = c.object;
        }
        b(B);
      }
    }
    function q(a, b) {
      b(a);
      if (void 0 !== a.children)
        for (var c in a.children)
          q(a.children[c], b);
    }
    var p = this, s = THREE.Loader.prototype.extractUrlBase(c), t, r, v, w, u, y, L, x, N, J, B, K = [], A = a, G;
    for (G in this.geometryHandlers)
      a = this.geometryHandlers[G].loaderClass, this.geometryHandlers[G].loaderObject = new a();
    for (G in this.hierarchyHandlers)
      a = this.hierarchyHandlers[G].loaderClass, this.hierarchyHandlers[G].loaderObject = new a();
    x = L = 0;
    B = {
      scene: new THREE.Scene(),
      geometries: {},
      face_materials: {},
      materials: {},
      textures: {},
      objects: {},
      cameras: {},
      lights: {},
      fogs: {},
      empties: {},
      groups: {}
    };
    A.transform && (G = A.transform.position, a = A.transform.rotation, c = A.transform.scale, G && B.scene.position.fromArray(G), a && B.scene.rotation.fromArray(a), c && B.scene.scale.fromArray(c), G || a || c) && (B.scene.updateMatrix(), B.scene.updateMatrixWorld());
    G = function (a) {
      return function () {
        x -= a;
        n();
        p.onLoadComplete();
      };
    };
    for (var D in A.fogs)
      a = A.fogs[D], 'linear' === a.type ? w = new THREE.Fog(0, a.near, a.far) : 'exp2' === a.type && (w = new THREE.FogExp2(0, a.density)), a = a.color, w.color.setRGB(a[0], a[1], a[2]), B.fogs[D] = w;
    for (var C in A.geometries)
      w = A.geometries[C], w.type in this.geometryHandlers && (L += 1, p.onLoadStart());
    for (var F in A.objects)
      q(A.objects[F], function (a) {
        a.type && a.type in p.hierarchyHandlers && (L += 1, p.onLoadStart());
      });
    N = L;
    for (C in A.geometries)
      if (w = A.geometries[C], 'cube' === w.type)
        t = new THREE.BoxGeometry(w.width, w.height, w.depth, w.widthSegments, w.heightSegments, w.depthSegments), t.name = C, B.geometries[C] = t;
      else if ('plane' === w.type)
        t = new THREE.PlaneGeometry(w.width, w.height, w.widthSegments, w.heightSegments), t.name = C, B.geometries[C] = t;
      else if ('sphere' === w.type)
        t = new THREE.SphereGeometry(w.radius, w.widthSegments, w.heightSegments), t.name = C, B.geometries[C] = t;
      else if ('cylinder' === w.type)
        t = new THREE.CylinderGeometry(w.topRad, w.botRad, w.height, w.radSegs, w.heightSegs), t.name = C, B.geometries[C] = t;
      else if ('torus' === w.type)
        t = new THREE.TorusGeometry(w.radius, w.tube, w.segmentsR, w.segmentsT), t.name = C, B.geometries[C] = t;
      else if ('icosahedron' === w.type)
        t = new THREE.IcosahedronGeometry(w.radius, w.subdivisions), t.name = C, B.geometries[C] = t;
      else if (w.type in this.geometryHandlers) {
        F = {};
        for (u in w)
          'type' !== u && 'url' !== u && (F[u] = w[u]);
        this.geometryHandlers[w.type].loaderObject.load(d(w.url, A.urlBaseType), h(C), F);
      } else
        'embedded' === w.type && (F = A.embeds[w.id], F.metadata = A.metadata, F && (F = this.geometryHandlers.ascii.loaderObject.parse(F, ''), l(C)(F.geometry, F.materials)));
    for (var z in A.textures)
      if (C = A.textures[z], C.url instanceof Array)
        for (x += C.url.length, u = 0; u < C.url.length; u++)
          p.onLoadStart();
      else
        x += 1, p.onLoadStart();
    J = x;
    for (z in A.textures) {
      C = A.textures[z];
      void 0 !== C.mapping && void 0 !== THREE[C.mapping] && (C.mapping = new THREE[C.mapping]());
      if (C.url instanceof Array) {
        F = C.url.length;
        w = [];
        for (u = 0; u < F; u++)
          w[u] = d(C.url[u], A.urlBaseType);
        u = (u = /\.dds$/i.test(w[0])) ? THREE.ImageUtils.loadCompressedTextureCube(w, C.mapping, G(F)) : THREE.ImageUtils.loadTextureCube(w, C.mapping, G(F));
      } else
        u = /\.dds$/i.test(C.url), F = d(C.url, A.urlBaseType), w = G(1), u = u ? THREE.ImageUtils.loadCompressedTexture(F, C.mapping, w) : THREE.ImageUtils.loadTexture(F, C.mapping, w), void 0 !== THREE[C.minFilter] && (u.minFilter = THREE[C.minFilter]), void 0 !== THREE[C.magFilter] && (u.magFilter = THREE[C.magFilter]), C.anisotropy && (u.anisotropy = C.anisotropy), C.repeat && (u.repeat.set(C.repeat[0], C.repeat[1]), 1 !== C.repeat[0] && (u.wrapS = THREE.RepeatWrapping), 1 !== C.repeat[1] && (u.wrapT = THREE.RepeatWrapping)), C.offset && u.offset.set(C.offset[0], C.offset[1]), C.wrap && (F = {
          repeat: THREE.RepeatWrapping,
          mirror: THREE.MirroredRepeatWrapping
        }, void 0 !== F[C.wrap[0]] && (u.wrapS = F[C.wrap[0]]), void 0 !== F[C.wrap[1]] && (u.wrapT = F[C.wrap[1]]));
      B.textures[z] = u;
    }
    var H, E;
    for (H in A.materials) {
      z = A.materials[H];
      for (E in z.parameters)
        'envMap' === E || 'map' === E || 'lightMap' === E || 'bumpMap' === E ? z.parameters[E] = B.textures[z.parameters[E]] : 'shading' === E ? z.parameters[E] = 'flat' === z.parameters[E] ? THREE.FlatShading : THREE.SmoothShading : 'side' === E ? z.parameters[E] = 'double' == z.parameters[E] ? THREE.DoubleSide : 'back' == z.parameters[E] ? THREE.BackSide : THREE.FrontSide : 'blending' === E ? z.parameters[E] = z.parameters[E] in THREE ? THREE[z.parameters[E]] : THREE.NormalBlending : 'combine' === E ? z.parameters[E] = z.parameters[E] in THREE ? THREE[z.parameters[E]] : THREE.MultiplyOperation : 'vertexColors' === E ? 'face' == z.parameters[E] ? z.parameters[E] = THREE.FaceColors : z.parameters[E] && (z.parameters[E] = THREE.VertexColors) : 'wrapRGB' === E && (G = z.parameters[E], z.parameters[E] = new THREE.Vector3(G[0], G[1], G[2]));
      void 0 !== z.parameters.opacity && 1 > z.parameters.opacity && (z.parameters.transparent = !0);
      z.parameters.normalMap ? (G = THREE.ShaderLib.normalmap, C = THREE.UniformsUtils.clone(G.uniforms), u = z.parameters.color, F = z.parameters.specular, w = z.parameters.ambient, D = z.parameters.shininess, C.tNormal.value = B.textures[z.parameters.normalMap], z.parameters.normalScale && C.uNormalScale.value.set(z.parameters.normalScale[0], z.parameters.normalScale[1]), z.parameters.map && (C.tDiffuse.value = z.parameters.map, C.enableDiffuse.value = !0), z.parameters.envMap && (C.tCube.value = z.parameters.envMap, C.enableReflection.value = !0, C.reflectivity.value = z.parameters.reflectivity), z.parameters.lightMap && (C.tAO.value = z.parameters.lightMap, C.enableAO.value = !0), z.parameters.specularMap && (C.tSpecular.value = B.textures[z.parameters.specularMap], C.enableSpecular.value = !0), z.parameters.displacementMap && (C.tDisplacement.value = B.textures[z.parameters.displacementMap], C.enableDisplacement.value = !0, C.uDisplacementBias.value = z.parameters.displacementBias, C.uDisplacementScale.value = z.parameters.displacementScale), C.diffuse.value.setHex(u), C.specular.value.setHex(F), C.ambient.value.setHex(w), C.shininess.value = D, z.parameters.opacity && (C.opacity.value = z.parameters.opacity), r = new THREE.ShaderMaterial({
        fragmentShader: G.fragmentShader,
        vertexShader: G.vertexShader,
        uniforms: C,
        lights: !0,
        fog: !0
      })) : r = new THREE[z.type](z.parameters);
      r.name = H;
      B.materials[H] = r;
    }
    for (H in A.materials)
      if (z = A.materials[H], z.parameters.materials) {
        E = [];
        for (u = 0; u < z.parameters.materials.length; u++)
          E.push(B.materials[z.parameters.materials[u]]);
        B.materials[H].materials = E;
      }
    e();
    B.cameras && A.defaults.camera && (B.currentCamera = B.cameras[A.defaults.camera]);
    B.fogs && A.defaults.fog && (B.scene.fog = B.fogs[A.defaults.fog]);
    p.callbackSync(B);
    n();
  }
};
THREE.TextureLoader = function (a) {
  this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
};
THREE.TextureLoader.prototype = {
  constructor: THREE.TextureLoader,
  load: function (a, b, c, d) {
    c = new THREE.ImageLoader(this.manager);
    c.setCrossOrigin(this.crossOrigin);
    c.load(a, function (a) {
      a = new THREE.Texture(a);
      a.needsUpdate = !0;
      void 0 !== b && b(a);
    });
  },
  setCrossOrigin: function (a) {
    this.crossOrigin = a;
  }
};
THREE.Material = function () {
  this.id = THREE.MaterialIdCount++;
  this.uuid = THREE.Math.generateUUID();
  this.name = '';
  this.side = THREE.FrontSide;
  this.opacity = 1;
  this.transparent = !1;
  this.blending = THREE.NormalBlending;
  this.blendSrc = THREE.SrcAlphaFactor;
  this.blendDst = THREE.OneMinusSrcAlphaFactor;
  this.blendEquation = THREE.AddEquation;
  this.depthWrite = this.depthTest = !0;
  this.polygonOffset = !1;
  this.overdraw = this.alphaTest = this.polygonOffsetUnits = this.polygonOffsetFactor = 0;
  this.needsUpdate = this.visible = !0;
};
THREE.Material.prototype = {
  constructor: THREE.Material,
  setValues: function (a) {
    if (void 0 !== a)
      for (var b in a) {
        var c = a[b];
        if (void 0 === c)
          console.warn('THREE.Material: \'' + b + '\' parameter is undefined.');
        else if (b in this) {
          var d = this[b];
          d instanceof THREE.Color ? d.set(c) : d instanceof THREE.Vector3 && c instanceof THREE.Vector3 ? d.copy(c) : this[b] = 'overdraw' == b ? Number(c) : c;
        }
      }
  },
  clone: function (a) {
    void 0 === a && (a = new THREE.Material());
    a.name = this.name;
    a.side = this.side;
    a.opacity = this.opacity;
    a.transparent = this.transparent;
    a.blending = this.blending;
    a.blendSrc = this.blendSrc;
    a.blendDst = this.blendDst;
    a.blendEquation = this.blendEquation;
    a.depthTest = this.depthTest;
    a.depthWrite = this.depthWrite;
    a.polygonOffset = this.polygonOffset;
    a.polygonOffsetFactor = this.polygonOffsetFactor;
    a.polygonOffsetUnits = this.polygonOffsetUnits;
    a.alphaTest = this.alphaTest;
    a.overdraw = this.overdraw;
    a.visible = this.visible;
    return a;
  },
  dispose: function () {
    this.dispatchEvent({ type: 'dispose' });
  }
};
THREE.EventDispatcher.prototype.apply(THREE.Material.prototype);
THREE.MaterialIdCount = 0;
THREE.LineBasicMaterial = function (a) {
  THREE.Material.call(this);
  this.color = new THREE.Color(16777215);
  this.linewidth = 1;
  this.linejoin = this.linecap = 'round';
  this.vertexColors = !1;
  this.fog = !0;
  this.setValues(a);
};
THREE.LineBasicMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.LineBasicMaterial.prototype.clone = function () {
  var a = new THREE.LineBasicMaterial();
  THREE.Material.prototype.clone.call(this, a);
  a.color.copy(this.color);
  a.linewidth = this.linewidth;
  a.linecap = this.linecap;
  a.linejoin = this.linejoin;
  a.vertexColors = this.vertexColors;
  a.fog = this.fog;
  return a;
};
THREE.LineDashedMaterial = function (a) {
  THREE.Material.call(this);
  this.color = new THREE.Color(16777215);
  this.scale = this.linewidth = 1;
  this.dashSize = 3;
  this.gapSize = 1;
  this.vertexColors = !1;
  this.fog = !0;
  this.setValues(a);
};
THREE.LineDashedMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.LineDashedMaterial.prototype.clone = function () {
  var a = new THREE.LineDashedMaterial();
  THREE.Material.prototype.clone.call(this, a);
  a.color.copy(this.color);
  a.linewidth = this.linewidth;
  a.scale = this.scale;
  a.dashSize = this.dashSize;
  a.gapSize = this.gapSize;
  a.vertexColors = this.vertexColors;
  a.fog = this.fog;
  return a;
};
THREE.MeshBasicMaterial = function (a) {
  THREE.Material.call(this);
  this.color = new THREE.Color(16777215);
  this.envMap = this.specularMap = this.lightMap = this.map = null;
  this.combine = THREE.MultiplyOperation;
  this.reflectivity = 1;
  this.refractionRatio = 0.98;
  this.fog = !0;
  this.shading = THREE.SmoothShading;
  this.wireframe = !1;
  this.wireframeLinewidth = 1;
  this.wireframeLinejoin = this.wireframeLinecap = 'round';
  this.vertexColors = THREE.NoColors;
  this.morphTargets = this.skinning = !1;
  this.setValues(a);
};
THREE.MeshBasicMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.MeshBasicMaterial.prototype.clone = function () {
  var a = new THREE.MeshBasicMaterial();
  THREE.Material.prototype.clone.call(this, a);
  a.color.copy(this.color);
  a.map = this.map;
  a.lightMap = this.lightMap;
  a.specularMap = this.specularMap;
  a.envMap = this.envMap;
  a.combine = this.combine;
  a.reflectivity = this.reflectivity;
  a.refractionRatio = this.refractionRatio;
  a.fog = this.fog;
  a.shading = this.shading;
  a.wireframe = this.wireframe;
  a.wireframeLinewidth = this.wireframeLinewidth;
  a.wireframeLinecap = this.wireframeLinecap;
  a.wireframeLinejoin = this.wireframeLinejoin;
  a.vertexColors = this.vertexColors;
  a.skinning = this.skinning;
  a.morphTargets = this.morphTargets;
  return a;
};
THREE.MeshLambertMaterial = function (a) {
  THREE.Material.call(this);
  this.color = new THREE.Color(16777215);
  this.ambient = new THREE.Color(16777215);
  this.emissive = new THREE.Color(0);
  this.wrapAround = !1;
  this.wrapRGB = new THREE.Vector3(1, 1, 1);
  this.envMap = this.specularMap = this.lightMap = this.map = null;
  this.combine = THREE.MultiplyOperation;
  this.reflectivity = 1;
  this.refractionRatio = 0.98;
  this.fog = !0;
  this.shading = THREE.SmoothShading;
  this.wireframe = !1;
  this.wireframeLinewidth = 1;
  this.wireframeLinejoin = this.wireframeLinecap = 'round';
  this.vertexColors = THREE.NoColors;
  this.morphNormals = this.morphTargets = this.skinning = !1;
  this.setValues(a);
};
THREE.MeshLambertMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.MeshLambertMaterial.prototype.clone = function () {
  var a = new THREE.MeshLambertMaterial();
  THREE.Material.prototype.clone.call(this, a);
  a.color.copy(this.color);
  a.ambient.copy(this.ambient);
  a.emissive.copy(this.emissive);
  a.wrapAround = this.wrapAround;
  a.wrapRGB.copy(this.wrapRGB);
  a.map = this.map;
  a.lightMap = this.lightMap;
  a.specularMap = this.specularMap;
  a.envMap = this.envMap;
  a.combine = this.combine;
  a.reflectivity = this.reflectivity;
  a.refractionRatio = this.refractionRatio;
  a.fog = this.fog;
  a.shading = this.shading;
  a.wireframe = this.wireframe;
  a.wireframeLinewidth = this.wireframeLinewidth;
  a.wireframeLinecap = this.wireframeLinecap;
  a.wireframeLinejoin = this.wireframeLinejoin;
  a.vertexColors = this.vertexColors;
  a.skinning = this.skinning;
  a.morphTargets = this.morphTargets;
  a.morphNormals = this.morphNormals;
  return a;
};
THREE.MeshPhongMaterial = function (a) {
  THREE.Material.call(this);
  this.color = new THREE.Color(16777215);
  this.ambient = new THREE.Color(16777215);
  this.emissive = new THREE.Color(0);
  this.specular = new THREE.Color(1118481);
  this.shininess = 30;
  this.wrapAround = this.metal = !1;
  this.wrapRGB = new THREE.Vector3(1, 1, 1);
  this.bumpMap = this.lightMap = this.map = null;
  this.bumpScale = 1;
  this.normalMap = null;
  this.normalScale = new THREE.Vector2(1, 1);
  this.envMap = this.specularMap = null;
  this.combine = THREE.MultiplyOperation;
  this.reflectivity = 1;
  this.refractionRatio = 0.98;
  this.fog = !0;
  this.shading = THREE.SmoothShading;
  this.wireframe = !1;
  this.wireframeLinewidth = 1;
  this.wireframeLinejoin = this.wireframeLinecap = 'round';
  this.vertexColors = THREE.NoColors;
  this.morphNormals = this.morphTargets = this.skinning = !1;
  this.setValues(a);
};
THREE.MeshPhongMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.MeshPhongMaterial.prototype.clone = function () {
  var a = new THREE.MeshPhongMaterial();
  THREE.Material.prototype.clone.call(this, a);
  a.color.copy(this.color);
  a.ambient.copy(this.ambient);
  a.emissive.copy(this.emissive);
  a.specular.copy(this.specular);
  a.shininess = this.shininess;
  a.metal = this.metal;
  a.wrapAround = this.wrapAround;
  a.wrapRGB.copy(this.wrapRGB);
  a.map = this.map;
  a.lightMap = this.lightMap;
  a.bumpMap = this.bumpMap;
  a.bumpScale = this.bumpScale;
  a.normalMap = this.normalMap;
  a.normalScale.copy(this.normalScale);
  a.specularMap = this.specularMap;
  a.envMap = this.envMap;
  a.combine = this.combine;
  a.reflectivity = this.reflectivity;
  a.refractionRatio = this.refractionRatio;
  a.fog = this.fog;
  a.shading = this.shading;
  a.wireframe = this.wireframe;
  a.wireframeLinewidth = this.wireframeLinewidth;
  a.wireframeLinecap = this.wireframeLinecap;
  a.wireframeLinejoin = this.wireframeLinejoin;
  a.vertexColors = this.vertexColors;
  a.skinning = this.skinning;
  a.morphTargets = this.morphTargets;
  a.morphNormals = this.morphNormals;
  return a;
};
THREE.MeshDepthMaterial = function (a) {
  THREE.Material.call(this);
  this.wireframe = this.morphTargets = !1;
  this.wireframeLinewidth = 1;
  this.setValues(a);
};
THREE.MeshDepthMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.MeshDepthMaterial.prototype.clone = function () {
  var a = new THREE.MeshDepthMaterial();
  THREE.Material.prototype.clone.call(this, a);
  a.wireframe = this.wireframe;
  a.wireframeLinewidth = this.wireframeLinewidth;
  return a;
};
THREE.MeshNormalMaterial = function (a) {
  THREE.Material.call(this, a);
  this.shading = THREE.FlatShading;
  this.wireframe = !1;
  this.wireframeLinewidth = 1;
  this.morphTargets = !1;
  this.setValues(a);
};
THREE.MeshNormalMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.MeshNormalMaterial.prototype.clone = function () {
  var a = new THREE.MeshNormalMaterial();
  THREE.Material.prototype.clone.call(this, a);
  a.shading = this.shading;
  a.wireframe = this.wireframe;
  a.wireframeLinewidth = this.wireframeLinewidth;
  return a;
};
THREE.MeshFaceMaterial = function (a) {
  this.materials = a instanceof Array ? a : [];
};
THREE.MeshFaceMaterial.prototype.clone = function () {
  for (var a = new THREE.MeshFaceMaterial(), b = 0; b < this.materials.length; b++)
    a.materials.push(this.materials[b].clone());
  return a;
};
THREE.ParticleSystemMaterial = function (a) {
  THREE.Material.call(this);
  this.color = new THREE.Color(16777215);
  this.map = null;
  this.size = 1;
  this.sizeAttenuation = !0;
  this.vertexColors = !1;
  this.fog = !0;
  this.setValues(a);
};
THREE.ParticleSystemMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.ParticleSystemMaterial.prototype.clone = function () {
  var a = new THREE.ParticleSystemMaterial();
  THREE.Material.prototype.clone.call(this, a);
  a.color.copy(this.color);
  a.map = this.map;
  a.size = this.size;
  a.sizeAttenuation = this.sizeAttenuation;
  a.vertexColors = this.vertexColors;
  a.fog = this.fog;
  return a;
};
THREE.ParticleBasicMaterial = THREE.ParticleSystemMaterial;
THREE.ShaderMaterial = function (a) {
  THREE.Material.call(this);
  this.vertexShader = this.fragmentShader = 'void main() {}';
  this.uniforms = {};
  this.defines = {};
  this.attributes = null;
  this.shading = THREE.SmoothShading;
  this.linewidth = 1;
  this.wireframe = !1;
  this.wireframeLinewidth = 1;
  this.lights = this.fog = !1;
  this.vertexColors = THREE.NoColors;
  this.morphNormals = this.morphTargets = this.skinning = !1;
  this.defaultAttributeValues = {
    color: [
      1,
      1,
      1
    ],
    uv: [
      0,
      0
    ],
    uv2: [
      0,
      0
    ]
  };
  this.index0AttributeName = void 0;
  this.setValues(a);
};
THREE.ShaderMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.ShaderMaterial.prototype.clone = function () {
  var a = new THREE.ShaderMaterial();
  THREE.Material.prototype.clone.call(this, a);
  a.fragmentShader = this.fragmentShader;
  a.vertexShader = this.vertexShader;
  a.uniforms = THREE.UniformsUtils.clone(this.uniforms);
  a.attributes = this.attributes;
  a.defines = this.defines;
  a.shading = this.shading;
  a.wireframe = this.wireframe;
  a.wireframeLinewidth = this.wireframeLinewidth;
  a.fog = this.fog;
  a.lights = this.lights;
  a.vertexColors = this.vertexColors;
  a.skinning = this.skinning;
  a.morphTargets = this.morphTargets;
  a.morphNormals = this.morphNormals;
  return a;
};
THREE.RawShaderMaterial = function (a) {
  THREE.ShaderMaterial.call(this, a);
};
THREE.RawShaderMaterial.prototype = Object.create(THREE.ShaderMaterial.prototype);
THREE.RawShaderMaterial.prototype.clone = function () {
  var a = new THREE.RawShaderMaterial();
  THREE.ShaderMaterial.prototype.clone.call(this, a);
  return a;
};
THREE.SpriteMaterial = function (a) {
  THREE.Material.call(this);
  this.color = new THREE.Color(16777215);
  this.map = null;
  this.rotation = 0;
  this.fog = !1;
  this.setValues(a);
};
THREE.SpriteMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.SpriteMaterial.prototype.clone = function () {
  var a = new THREE.SpriteMaterial();
  THREE.Material.prototype.clone.call(this, a);
  a.color.copy(this.color);
  a.map = this.map;
  a.rotation = this.rotation;
  a.fog = this.fog;
  return a;
};
THREE.SpriteCanvasMaterial = function (a) {
  THREE.Material.call(this);
  this.color = new THREE.Color(16777215);
  this.program = function (a, c) {
  };
  this.setValues(a);
};
THREE.SpriteCanvasMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.SpriteCanvasMaterial.prototype.clone = function () {
  var a = new THREE.SpriteCanvasMaterial();
  THREE.Material.prototype.clone.call(this, a);
  a.color.copy(this.color);
  a.program = this.program;
  return a;
};
THREE.ParticleCanvasMaterial = THREE.SpriteCanvasMaterial;
THREE.Texture = function (a, b, c, d, e, f, g, h, k) {
  this.id = THREE.TextureIdCount++;
  this.uuid = THREE.Math.generateUUID();
  this.name = '';
  this.image = a;
  this.mipmaps = [];
  this.mapping = void 0 !== b ? b : new THREE.UVMapping();
  this.wrapS = void 0 !== c ? c : THREE.ClampToEdgeWrapping;
  this.wrapT = void 0 !== d ? d : THREE.ClampToEdgeWrapping;
  this.magFilter = void 0 !== e ? e : THREE.LinearFilter;
  this.minFilter = void 0 !== f ? f : THREE.LinearMipMapLinearFilter;
  this.anisotropy = void 0 !== k ? k : 1;
  this.format = void 0 !== g ? g : THREE.RGBAFormat;
  this.type = void 0 !== h ? h : THREE.UnsignedByteType;
  this.offset = new THREE.Vector2(0, 0);
  this.repeat = new THREE.Vector2(1, 1);
  this.generateMipmaps = !0;
  this.premultiplyAlpha = !1;
  this.flipY = !0;
  this.unpackAlignment = 4;
  this._needsUpdate = !1;
  this.onUpdate = null;
};
THREE.Texture.prototype = {
  constructor: THREE.Texture,
  get needsUpdate() {
    return this._needsUpdate;
  },
  set needsUpdate(a) {
    !0 === a && this.update();
    this._needsUpdate = a;
  },
  clone: function (a) {
    void 0 === a && (a = new THREE.Texture());
    a.image = this.image;
    a.mipmaps = this.mipmaps.slice(0);
    a.mapping = this.mapping;
    a.wrapS = this.wrapS;
    a.wrapT = this.wrapT;
    a.magFilter = this.magFilter;
    a.minFilter = this.minFilter;
    a.anisotropy = this.anisotropy;
    a.format = this.format;
    a.type = this.type;
    a.offset.copy(this.offset);
    a.repeat.copy(this.repeat);
    a.generateMipmaps = this.generateMipmaps;
    a.premultiplyAlpha = this.premultiplyAlpha;
    a.flipY = this.flipY;
    a.unpackAlignment = this.unpackAlignment;
    return a;
  },
  update: function () {
    this.dispatchEvent({ type: 'update' });
  },
  dispose: function () {
    this.dispatchEvent({ type: 'dispose' });
  }
};
THREE.EventDispatcher.prototype.apply(THREE.Texture.prototype);
THREE.TextureIdCount = 0;
THREE.CompressedTexture = function (a, b, c, d, e, f, g, h, k, l, n) {
  THREE.Texture.call(this, null, f, g, h, k, l, d, e, n);
  this.image = {
    width: b,
    height: c
  };
  this.mipmaps = a;
  this.generateMipmaps = !1;
};
THREE.CompressedTexture.prototype = Object.create(THREE.Texture.prototype);
THREE.CompressedTexture.prototype.clone = function () {
  var a = new THREE.CompressedTexture();
  THREE.Texture.prototype.clone.call(this, a);
  return a;
};
THREE.DataTexture = function (a, b, c, d, e, f, g, h, k, l, n) {
  THREE.Texture.call(this, null, f, g, h, k, l, d, e, n);
  this.image = {
    data: a,
    width: b,
    height: c
  };
};
THREE.DataTexture.prototype = Object.create(THREE.Texture.prototype);
THREE.DataTexture.prototype.clone = function () {
  var a = new THREE.DataTexture();
  THREE.Texture.prototype.clone.call(this, a);
  return a;
};
THREE.ParticleSystem = function (a, b) {
  THREE.Object3D.call(this);
  this.geometry = void 0 !== a ? a : new THREE.Geometry();
  this.material = void 0 !== b ? b : new THREE.ParticleSystemMaterial({ color: 16777215 * Math.random() });
  this.frustumCulled = this.sortParticles = !1;
};
THREE.ParticleSystem.prototype = Object.create(THREE.Object3D.prototype);
THREE.ParticleSystem.prototype.clone = function (a) {
  void 0 === a && (a = new THREE.ParticleSystem(this.geometry, this.material));
  a.sortParticles = this.sortParticles;
  THREE.Object3D.prototype.clone.call(this, a);
  return a;
};
THREE.Line = function (a, b, c) {
  THREE.Object3D.call(this);
  this.geometry = void 0 !== a ? a : new THREE.Geometry();
  this.material = void 0 !== b ? b : new THREE.LineBasicMaterial({ color: 16777215 * Math.random() });
  this.type = void 0 !== c ? c : THREE.LineStrip;
};
THREE.LineStrip = 0;
THREE.LinePieces = 1;
THREE.Line.prototype = Object.create(THREE.Object3D.prototype);
THREE.Line.prototype.clone = function (a) {
  void 0 === a && (a = new THREE.Line(this.geometry, this.material, this.type));
  THREE.Object3D.prototype.clone.call(this, a);
  return a;
};
THREE.Mesh = function (a, b) {
  THREE.Object3D.call(this);
  this.geometry = void 0 !== a ? a : new THREE.Geometry();
  this.material = void 0 !== b ? b : new THREE.MeshBasicMaterial({ color: 16777215 * Math.random() });
  this.updateMorphTargets();
};
THREE.Mesh.prototype = Object.create(THREE.Object3D.prototype);
THREE.Mesh.prototype.updateMorphTargets = function () {
  if (void 0 !== this.geometry.morphTargets && 0 < this.geometry.morphTargets.length) {
    this.morphTargetBase = -1;
    this.morphTargetForcedOrder = [];
    this.morphTargetInfluences = [];
    this.morphTargetDictionary = {};
    for (var a = 0, b = this.geometry.morphTargets.length; a < b; a++)
      this.morphTargetInfluences.push(0), this.morphTargetDictionary[this.geometry.morphTargets[a].name] = a;
  }
};
THREE.Mesh.prototype.getMorphTargetIndexByName = function (a) {
  if (void 0 !== this.morphTargetDictionary[a])
    return this.morphTargetDictionary[a];
  console.log('THREE.Mesh.getMorphTargetIndexByName: morph target ' + a + ' does not exist. Returning 0.');
  return 0;
};
THREE.Mesh.prototype.clone = function (a, b) {
  void 0 === a && (a = new THREE.Mesh(this.geometry, this.material));
  THREE.Object3D.prototype.clone.call(this, a, b);
  return a;
};
THREE.Bone = function (a) {
  THREE.Object3D.call(this);
  this.skin = a;
  this.skinMatrix = new THREE.Matrix4();
  this.accumulatedSclWeight = this.accumulatedPosWeight = this.accumulatedRotWeight = 0;
};
THREE.Bone.prototype = Object.create(THREE.Object3D.prototype);
THREE.Bone.prototype.update = function (a, b) {
  this.matrixAutoUpdate && (b |= this.updateMatrix());
  if (b || this.matrixWorldNeedsUpdate)
    a ? this.skinMatrix.multiplyMatrices(a, this.matrix) : this.skinMatrix.copy(this.matrix), this.matrixWorldNeedsUpdate = !1, b = !0, this.accumulatedSclWeight = this.accumulatedPosWeight = this.accumulatedRotWeight = 0;
  for (var c = 0, d = this.children.length; c < d; c++)
    this.children[c].update(this.skinMatrix, b);
};
THREE.Skeleton = function (a, b) {
  this.useVertexTexture = void 0 !== b ? b : !0;
  this.bones = [];
  this.boneMatrices = [];
  var c, d, e, f, g;
  if (void 0 !== a) {
    for (var h = 0; h < a.length; ++h)
      d = a[h], e = d.pos, f = d.rotq, g = d.scl, c = this.addBone(), c.name = d.name, c.position.set(e[0], e[1], e[2]), c.quaternion.set(f[0], f[1], f[2], f[3]), void 0 !== g ? c.scale.set(g[0], g[1], g[2]) : c.scale.set(1, 1, 1);
    for (h = 0; h < a.length; ++h)
      d = a[h], -1 !== d.parent && this.bones[d.parent].add(this.bones[h]);
    c = this.bones.length;
    this.useVertexTexture ? (this.boneTextureHeight = this.boneTextureWidth = c = 256 < c ? 64 : 64 < c ? 32 : 16 < c ? 16 : 8, this.boneMatrices = new Float32Array(this.boneTextureWidth * this.boneTextureHeight * 4), this.boneTexture = new THREE.DataTexture(this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType), this.boneTexture.minFilter = THREE.NearestFilter, this.boneTexture.magFilter = THREE.NearestFilter, this.boneTexture.generateMipmaps = !1, this.boneTexture.flipY = !1) : this.boneMatrices = new Float32Array(16 * c);
  }
};
THREE.Skeleton.prototype = Object.create(THREE.Mesh.prototype);
THREE.Skeleton.prototype.addBone = function (a) {
  void 0 === a && (a = new THREE.Bone(this));
  this.bones.push(a);
  return a;
};
THREE.Skeleton.prototype.calculateInverses = function (a) {
  this.boneInverses = [];
  a = 0;
  for (var b = this.bones.length; a < b; ++a) {
    var c = new THREE.Matrix4();
    c.getInverse(this.bones[a].skinMatrix);
    this.boneInverses.push(c);
  }
};
THREE.SkinnedMesh = function (a, b, c) {
  THREE.Mesh.call(this, a, b);
  this.skeleton = new THREE.Skeleton(this.geometry && this.geometry.bones, c);
  for (a = 0; a < this.skeleton.bones.length; ++a)
    b = this.skeleton.bones[a], void 0 === b.parent && this.add(b);
  this.identityMatrix = new THREE.Matrix4();
  this.pose();
};
THREE.SkinnedMesh.prototype = Object.create(THREE.Mesh.prototype);
THREE.SkinnedMesh.prototype.updateMatrixWorld = function () {
  var a = new THREE.Matrix4();
  return function (b) {
    this.matrixAutoUpdate && this.updateMatrix();
    if (this.matrixWorldNeedsUpdate || b)
      this.parent ? this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix) : this.matrixWorld.copy(this.matrix), this.matrixWorldNeedsUpdate = !1;
    b = 0;
    for (var c = this.children.length; b < c; b++) {
      var d = this.children[b];
      d instanceof THREE.Bone ? d.update(this.identityMatrix, !1) : d.updateMatrixWorld(!0);
    }
    void 0 === this.skeleton.boneInverses && this.skeleton.calculateInverses();
    b = 0;
    for (c = this.skeleton.bones.length; b < c; b++)
      a.multiplyMatrices(this.skeleton.bones[b].skinMatrix, this.skeleton.boneInverses[b]), a.flattenToArrayOffset(this.skeleton.boneMatrices, 16 * b);
    this.skeleton.useVertexTexture && (this.skeleton.boneTexture.needsUpdate = !0);
  };
}();
THREE.SkinnedMesh.prototype.pose = function () {
  this.updateMatrixWorld(!0);
  this.normalizeSkinWeights();
};
THREE.SkinnedMesh.prototype.normalizeSkinWeights = function () {
  if (this.geometry instanceof THREE.Geometry)
    for (var a = 0; a < this.geometry.skinIndices.length; a++) {
      var b = this.geometry.skinWeights[a], c = 1 / b.lengthManhattan();
      Infinity !== c ? b.multiplyScalar(c) : b.set(1);
    }
};
THREE.SkinnedMesh.prototype.clone = function (a) {
  void 0 === a && (a = new THREE.SkinnedMesh(this.geometry, this.material, this.useVertexTexture));
  THREE.Mesh.prototype.clone.call(this, a);
  return a;
};
THREE.MorphAnimMesh = function (a, b) {
  THREE.Mesh.call(this, a, b);
  this.duration = 1000;
  this.mirroredLoop = !1;
  this.currentKeyframe = this.lastKeyframe = this.time = 0;
  this.direction = 1;
  this.directionBackwards = !1;
  this.setFrameRange(0, this.geometry.morphTargets.length - 1);
};
THREE.MorphAnimMesh.prototype = Object.create(THREE.Mesh.prototype);
THREE.MorphAnimMesh.prototype.setFrameRange = function (a, b) {
  this.startKeyframe = a;
  this.endKeyframe = b;
  this.length = this.endKeyframe - this.startKeyframe + 1;
};
THREE.MorphAnimMesh.prototype.setDirectionForward = function () {
  this.direction = 1;
  this.directionBackwards = !1;
};
THREE.MorphAnimMesh.prototype.setDirectionBackward = function () {
  this.direction = -1;
  this.directionBackwards = !0;
};
THREE.MorphAnimMesh.prototype.parseAnimations = function () {
  var a = this.geometry;
  a.animations || (a.animations = {});
  for (var b, c = a.animations, d = /([a-z]+)(\d+)/, e = 0, f = a.morphTargets.length; e < f; e++) {
    var g = a.morphTargets[e].name.match(d);
    if (g && 1 < g.length) {
      g = g[1];
      c[g] || (c[g] = {
        start: Infinity,
        end: -Infinity
      });
      var h = c[g];
      e < h.start && (h.start = e);
      e > h.end && (h.end = e);
      b || (b = g);
    }
  }
  a.firstAnimation = b;
};
THREE.MorphAnimMesh.prototype.setAnimationLabel = function (a, b, c) {
  this.geometry.animations || (this.geometry.animations = {});
  this.geometry.animations[a] = {
    start: b,
    end: c
  };
};
THREE.MorphAnimMesh.prototype.playAnimation = function (a, b) {
  var c = this.geometry.animations[a];
  c ? (this.setFrameRange(c.start, c.end), this.duration = (c.end - c.start) / b * 1000, this.time = 0) : console.warn('animation[' + a + '] undefined');
};
THREE.MorphAnimMesh.prototype.updateAnimation = function (a) {
  var b = this.duration / this.length;
  this.time += this.direction * a;
  if (this.mirroredLoop) {
    if (this.time > this.duration || 0 > this.time)
      this.direction *= -1, this.time > this.duration && (this.time = this.duration, this.directionBackwards = !0), 0 > this.time && (this.time = 0, this.directionBackwards = !1);
  } else
    this.time %= this.duration, 0 > this.time && (this.time += this.duration);
  a = this.startKeyframe + THREE.Math.clamp(Math.floor(this.time / b), 0, this.length - 1);
  a !== this.currentKeyframe && (this.morphTargetInfluences[this.lastKeyframe] = 0, this.morphTargetInfluences[this.currentKeyframe] = 1, this.morphTargetInfluences[a] = 0, this.lastKeyframe = this.currentKeyframe, this.currentKeyframe = a);
  b = this.time % b / b;
  this.directionBackwards && (b = 1 - b);
  this.morphTargetInfluences[this.currentKeyframe] = b;
  this.morphTargetInfluences[this.lastKeyframe] = 1 - b;
};
THREE.MorphAnimMesh.prototype.clone = function (a) {
  void 0 === a && (a = new THREE.MorphAnimMesh(this.geometry, this.material));
  a.duration = this.duration;
  a.mirroredLoop = this.mirroredLoop;
  a.time = this.time;
  a.lastKeyframe = this.lastKeyframe;
  a.currentKeyframe = this.currentKeyframe;
  a.direction = this.direction;
  a.directionBackwards = this.directionBackwards;
  THREE.Mesh.prototype.clone.call(this, a);
  return a;
};
THREE.LOD = function () {
  THREE.Object3D.call(this);
  this.objects = [];
};
THREE.LOD.prototype = Object.create(THREE.Object3D.prototype);
THREE.LOD.prototype.addLevel = function (a, b) {
  void 0 === b && (b = 0);
  b = Math.abs(b);
  for (var c = 0; c < this.objects.length && !(b < this.objects[c].distance); c++);
  this.objects.splice(c, 0, {
    distance: b,
    object: a
  });
  this.add(a);
};
THREE.LOD.prototype.getObjectForDistance = function (a) {
  for (var b = 1, c = this.objects.length; b < c && !(a < this.objects[b].distance); b++);
  return this.objects[b - 1].object;
};
THREE.LOD.prototype.update = function () {
  var a = new THREE.Vector3(), b = new THREE.Vector3();
  return function (c) {
    if (1 < this.objects.length) {
      a.setFromMatrixPosition(c.matrixWorld);
      b.setFromMatrixPosition(this.matrixWorld);
      c = a.distanceTo(b);
      this.objects[0].object.visible = !0;
      for (var d = 1, e = this.objects.length; d < e; d++)
        if (c >= this.objects[d].distance)
          this.objects[d - 1].object.visible = !1, this.objects[d].object.visible = !0;
        else
          break;
      for (; d < e; d++)
        this.objects[d].object.visible = !1;
    }
  };
}();
THREE.LOD.prototype.clone = function (a) {
  void 0 === a && (a = new THREE.LOD());
  THREE.Object3D.prototype.clone.call(this, a);
  for (var b = 0, c = this.objects.length; b < c; b++) {
    var d = this.objects[b].object.clone();
    d.visible = 0 === b;
    a.addLevel(d, this.objects[b].distance);
  }
  return a;
};
THREE.Sprite = function () {
  var a = new THREE.Float32Attribute(3, 3);
  a.set([
    -0.5,
    -0.5,
    0,
    0.5,
    -0.5,
    0,
    0.5,
    0.5,
    0
  ]);
  var b = new THREE.BufferGeometry();
  b.addAttribute('position', a);
  return function (a) {
    THREE.Object3D.call(this);
    this.geometry = b;
    this.material = void 0 !== a ? a : new THREE.SpriteMaterial();
  };
}();
THREE.Sprite.prototype = Object.create(THREE.Object3D.prototype);
THREE.Sprite.prototype.updateMatrix = function () {
  this.matrix.compose(this.position, this.quaternion, this.scale);
  this.matrixWorldNeedsUpdate = !0;
};
THREE.Sprite.prototype.clone = function (a) {
  void 0 === a && (a = new THREE.Sprite(this.material));
  THREE.Object3D.prototype.clone.call(this, a);
  return a;
};
THREE.Particle = THREE.Sprite;
THREE.Scene = function () {
  THREE.Object3D.call(this);
  this.overrideMaterial = this.fog = null;
  this.autoUpdate = !0;
  this.matrixAutoUpdate = !1;
  this.__lights = [];
  this.__objectsAdded = [];
  this.__objectsRemoved = [];
};
THREE.Scene.prototype = Object.create(THREE.Object3D.prototype);
THREE.Scene.prototype.__addObject = function (a) {
  if (a instanceof THREE.Light)
    -1 === this.__lights.indexOf(a) && this.__lights.push(a), a.target && void 0 === a.target.parent && this.add(a.target);
  else if (!(a instanceof THREE.Camera || a instanceof THREE.Bone)) {
    this.__objectsAdded.push(a);
    var b = this.__objectsRemoved.indexOf(a);
    -1 !== b && this.__objectsRemoved.splice(b, 1);
  }
  this.dispatchEvent({
    type: 'objectAdded',
    object: a
  });
  a.dispatchEvent({
    type: 'addedToScene',
    scene: this
  });
  for (b = 0; b < a.children.length; b++)
    this.__addObject(a.children[b]);
};
THREE.Scene.prototype.__removeObject = function (a) {
  if (a instanceof THREE.Light) {
    var b = this.__lights.indexOf(a);
    -1 !== b && this.__lights.splice(b, 1);
    if (a.shadowCascadeArray)
      for (b = 0; b < a.shadowCascadeArray.length; b++)
        this.__removeObject(a.shadowCascadeArray[b]);
  } else
    a instanceof THREE.Camera || (this.__objectsRemoved.push(a), b = this.__objectsAdded.indexOf(a), -1 !== b && this.__objectsAdded.splice(b, 1));
  this.dispatchEvent({
    type: 'objectRemoved',
    object: a
  });
  a.dispatchEvent({
    type: 'removedFromScene',
    scene: this
  });
  for (b = 0; b < a.children.length; b++)
    this.__removeObject(a.children[b]);
};
THREE.Scene.prototype.clone = function (a) {
  void 0 === a && (a = new THREE.Scene());
  THREE.Object3D.prototype.clone.call(this, a);
  null !== this.fog && (a.fog = this.fog.clone());
  null !== this.overrideMaterial && (a.overrideMaterial = this.overrideMaterial.clone());
  a.autoUpdate = this.autoUpdate;
  a.matrixAutoUpdate = this.matrixAutoUpdate;
  return a;
};
THREE.Fog = function (a, b, c) {
  this.name = '';
  this.color = new THREE.Color(a);
  this.near = void 0 !== b ? b : 1;
  this.far = void 0 !== c ? c : 1000;
};
THREE.Fog.prototype.clone = function () {
  return new THREE.Fog(this.color.getHex(), this.near, this.far);
};
THREE.FogExp2 = function (a, b) {
  this.name = '';
  this.color = new THREE.Color(a);
  this.density = void 0 !== b ? b : 0.00025;
};
THREE.FogExp2.prototype.clone = function () {
  return new THREE.FogExp2(this.color.getHex(), this.density);
};
THREE.CanvasRenderer = function (a) {
  function b(a, b, c, d) {
    l(b);
    n(c);
    q(d);
    p(a.getStyle());
    A.stroke();
    qa.expandByScalar(2 * b);
  }
  function c(a) {
    s(a.getStyle());
    A.fill();
  }
  function d(a) {
    e(a.target);
  }
  function e(a) {
    var b = a.wrapS === THREE.RepeatWrapping, c = a.wrapT === THREE.RepeatWrapping, d = a.image, e = document.createElement('canvas');
    e.width = d.width;
    e.height = d.height;
    var f = e.getContext('2d');
    f.setTransform(1, 0, 0, -1, 0, d.height);
    f.drawImage(d, 0, 0);
    Ga[a.id] = A.createPattern(e, !0 === b && !0 === c ? 'repeat' : !0 === b && !1 === c ? 'repeat-x' : !1 === b && !0 === c ? 'repeat-y' : 'no-repeat');
  }
  function f(a, b, c, f, g, h, k, l, n, m, p, r, q) {
    if (!(q instanceof THREE.DataTexture)) {
      !1 === q.hasEventListener('update', d) && (void 0 !== q.image && 0 < q.image.width && e(q), q.addEventListener('update', d));
      var t = Ga[q.id];
      if (void 0 !== t) {
        s(t);
        var t = q.offset.x / q.repeat.x, u = q.offset.y / q.repeat.y, w = q.image.width * q.repeat.x;
        q = q.image.height * q.repeat.y;
        k = (k + t) * w;
        l = (l + u) * q;
        c -= a;
        f -= b;
        g -= a;
        h -= b;
        n = (n + t) * w - k;
        m = (m + u) * q - l;
        p = (p + t) * w - k;
        r = (r + u) * q - l;
        q = n * r - p * m;
        0 !== q && (t = 1 / q, q = (r * c - m * g) * t, m = (r * f - m * h) * t, c = (n * g - p * c) * t, f = (n * h - p * f) * t, a = a - q * k - c * l, b = b - m * k - f * l, A.save(), A.transform(q, m, c, f, a, b), A.fill(), A.restore());
      } else
        s('rgba(0,0,0,1)'), A.fill();
    }
  }
  function g(a, b, c) {
    var d = b.x - a.x, e = b.y - a.y, f = d * d + e * e;
    0 !== f && (c /= Math.sqrt(f), d *= c, e *= c, b.x += d, b.y += e, a.x -= d, a.y -= e);
  }
  function h(a) {
    C !== a && (C = A.globalAlpha = a);
  }
  function k(a) {
    F !== a && (a === THREE.NormalBlending ? A.globalCompositeOperation = 'source-over' : a === THREE.AdditiveBlending ? A.globalCompositeOperation = 'lighter' : a === THREE.SubtractiveBlending && (A.globalCompositeOperation = 'darker'), F = a);
  }
  function l(a) {
    E !== a && (E = A.lineWidth = a);
  }
  function n(a) {
    Q !== a && (Q = A.lineCap = a);
  }
  function q(a) {
    Y !== a && (Y = A.lineJoin = a);
  }
  function p(a) {
    z !== a && (z = A.strokeStyle = a);
  }
  function s(a) {
    H !== a && (H = A.fillStyle = a);
  }
  function t(a, b) {
    if (U !== a || la !== b)
      A.setLineDash([
        a,
        b
      ]), U = a, la = b;
  }
  console.log('THREE.CanvasRenderer', THREE.REVISION);
  var r = THREE.Math.smoothstep;
  a = a || {};
  var v = this, w, u, y, L = new THREE.Projector(), x = void 0 !== a.canvas ? a.canvas : document.createElement('canvas'), N = x.width, J = x.height, B = Math.floor(N / 2), K = Math.floor(J / 2), A = x.getContext('2d', { alpha: !0 === a.alpha }), G = new THREE.Color(0), D = 0, C = 1, F = 0, z = null, H = null, E = null, Q = null, Y = null, U = null, la = 0, W, R, I, da;
  new THREE.RenderableVertex();
  new THREE.RenderableVertex();
  var V, X, P, ga, wa, Ha, fa = new THREE.Color();
  new THREE.Color();
  new THREE.Color();
  new THREE.Color();
  new THREE.Color();
  var za = new THREE.Color(), Ia = new THREE.Color(), Ea = new THREE.Color(), Ga = {}, ha, Oa, Ra, Sa, Fa, ia, ma, ya = new THREE.Box2(), Z = new THREE.Box2(), qa = new THREE.Box2(), ua = new THREE.Color(), Ca = new THREE.Color(), va = new THREE.Color(), Da = new THREE.Vector3(), Ja = new THREE.Vector3(), ja = new THREE.Vector3(), ra = new THREE.Matrix3();
  void 0 === A.setLineDash && (A.setLineDash = function () {
  });
  this.domElement = x;
  this.devicePixelRatio = void 0 !== a.devicePixelRatio ? a.devicePixelRatio : void 0 !== self.devicePixelRatio ? self.devicePixelRatio : 1;
  this.sortElements = this.sortObjects = this.autoClear = !0;
  this.info = {
    render: {
      vertices: 0,
      faces: 0
    }
  };
  this.supportsVertexTextures = function () {
  };
  this.setFaceCulling = function () {
  };
  this.setSize = function (a, b, c) {
    N = a * this.devicePixelRatio;
    J = b * this.devicePixelRatio;
    x.width = N;
    x.height = J;
    B = Math.floor(N / 2);
    K = Math.floor(J / 2);
    !1 !== c && (x.style.width = a + 'px', x.style.height = b + 'px');
    ya.min.set(-B, -K);
    ya.max.set(B, K);
    Z.min.set(-B, -K);
    Z.max.set(B, K);
    C = 1;
    F = 0;
    Y = Q = E = H = z = null;
    this.setViewport(0, 0, a, b);
  };
  this.setViewport = function (a, b, c, d) {
    A.setTransform(c * this.devicePixelRatio / N, 0, 0, -(d * this.devicePixelRatio) / J, a * this.devicePixelRatio, J - b * this.devicePixelRatio);
    A.translate(B, K);
  };
  this.setScissor = function () {
  };
  this.enableScissorTest = function () {
  };
  this.setClearColor = function (a, b) {
    G.set(a);
    D = void 0 !== b ? b : 1;
    Z.min.set(-B, -K);
    Z.max.set(B, K);
  };
  this.setClearColorHex = function (a, b) {
    console.warn('DEPRECATED: .setClearColorHex() is being removed. Use .setClearColor() instead.');
    this.setClearColor(a, b);
  };
  this.getMaxAnisotropy = function () {
    return 0;
  };
  this.clear = function () {
    !1 === Z.empty() && (Z.intersect(ya), Z.expandByScalar(2), 1 > D && A.clearRect(Z.min.x | 0, Z.min.y | 0, Z.max.x - Z.min.x | 0, Z.max.y - Z.min.y | 0), 0 < D && (k(THREE.NormalBlending), h(1), s('rgba(' + Math.floor(255 * G.r) + ',' + Math.floor(255 * G.g) + ',' + Math.floor(255 * G.b) + ',' + D + ')'), A.fillRect(Z.min.x | 0, Z.min.y | 0, Z.max.x - Z.min.x | 0, Z.max.y - Z.min.y | 0)), Z.makeEmpty());
  };
  this.clearColor = function () {
  };
  this.clearDepth = function () {
  };
  this.clearStencil = function () {
  };
  this.render = function (a, x) {
    if (!1 === x instanceof THREE.Camera)
      console.error('THREE.CanvasRenderer.render: camera is not an instance of THREE.Camera.');
    else {
      !0 === this.autoClear && this.clear();
      v.info.render.vertices = 0;
      v.info.render.faces = 0;
      w = L.projectScene(a, x, this.sortObjects, this.sortElements);
      u = w.elements;
      y = w.lights;
      W = x;
      ra.getNormalMatrix(x.matrixWorldInverse);
      ua.setRGB(0, 0, 0);
      Ca.setRGB(0, 0, 0);
      va.setRGB(0, 0, 0);
      for (var C = 0, J = y.length; C < J; C++) {
        var z = y[C], G = z.color;
        z instanceof THREE.AmbientLight ? ua.add(G) : z instanceof THREE.DirectionalLight ? Ca.add(G) : z instanceof THREE.PointLight && va.add(G);
      }
      C = 0;
      for (J = u.length; C < J; C++) {
        var E = u[C], N = E.material;
        if (void 0 !== N && 0 !== N.opacity) {
          qa.makeEmpty();
          if (E instanceof THREE.RenderableSprite) {
            R = E;
            R.x *= B;
            R.y *= K;
            var z = R, H = E, G = N;
            h(G.opacity);
            k(G.blending);
            var m = H.scale.x * B, H = H.scale.y * K, E = 0.5 * Math.sqrt(m * m + H * H);
            qa.min.set(z.x - E, z.y - E);
            qa.max.set(z.x + E, z.y + E);
            if (G instanceof THREE.SpriteMaterial || G instanceof THREE.ParticleSystemMaterial) {
              var D = G.map;
              if (null !== D) {
                !1 === D.hasEventListener('update', d) && (void 0 !== D.image && 0 < D.image.width && e(D), D.addEventListener('update', d));
                E = Ga[D.id];
                void 0 !== E ? s(E) : s('rgba( 0, 0, 0, 1 )');
                var F = D.image, E = F.width * D.offset.x, N = F.height * D.offset.y, Q = F.width * D.repeat.x, D = F.height * D.repeat.y, F = m / Q, U = H / D;
                A.save();
                A.translate(z.x, z.y);
                0 !== G.rotation && A.rotate(G.rotation);
                A.translate(-m / 2, -H / 2);
                A.scale(F, U);
                A.translate(-E, -N);
                A.fillRect(E, N, Q, D);
              } else
                s(G.color.getStyle()), A.save(), A.translate(z.x, z.y), 0 !== G.rotation && A.rotate(G.rotation), A.scale(m, -H), A.fillRect(-0.5, -0.5, 1, 1);
              A.restore();
            } else
              G instanceof THREE.SpriteCanvasMaterial && (p(G.color.getStyle()), s(G.color.getStyle()), A.save(), A.translate(z.x, z.y), 0 !== G.rotation && A.rotate(G.rotation), A.scale(m, H), G.program(A), A.restore());
          } else if (E instanceof THREE.RenderableLine) {
            if (R = E.v1, I = E.v2, R.positionScreen.x *= B, R.positionScreen.y *= K, I.positionScreen.x *= B, I.positionScreen.y *= K, qa.setFromPoints([
                R.positionScreen,
                I.positionScreen
              ]), !0 === ya.isIntersectionBox(qa))
              if (z = R, G = I, m = E, H = N, h(H.opacity), k(H.blending), A.beginPath(), A.moveTo(z.positionScreen.x, z.positionScreen.y), A.lineTo(G.positionScreen.x, G.positionScreen.y), H instanceof THREE.LineBasicMaterial) {
                l(H.linewidth);
                n(H.linecap);
                q(H.linejoin);
                if (H.vertexColors !== THREE.VertexColors)
                  p(H.color.getStyle());
                else if (E = m.vertexColors[0].getStyle(), m = m.vertexColors[1].getStyle(), E === m)
                  p(E);
                else {
                  try {
                    var Y = A.createLinearGradient(z.positionScreen.x, z.positionScreen.y, G.positionScreen.x, G.positionScreen.y);
                    Y.addColorStop(0, E);
                    Y.addColorStop(1, m);
                  } catch (la) {
                    Y = E;
                  }
                  p(Y);
                }
                A.stroke();
                qa.expandByScalar(2 * H.linewidth);
              } else
                H instanceof THREE.LineDashedMaterial && (l(H.linewidth), n(H.linecap), q(H.linejoin), p(H.color.getStyle()), t(H.dashSize, H.gapSize), A.stroke(), qa.expandByScalar(2 * H.linewidth), t(null, null));
          } else if (E instanceof THREE.RenderableFace) {
            R = E.v1;
            I = E.v2;
            da = E.v3;
            if (-1 > R.positionScreen.z || 1 < R.positionScreen.z)
              continue;
            if (-1 > I.positionScreen.z || 1 < I.positionScreen.z)
              continue;
            if (-1 > da.positionScreen.z || 1 < da.positionScreen.z)
              continue;
            R.positionScreen.x *= B;
            R.positionScreen.y *= K;
            I.positionScreen.x *= B;
            I.positionScreen.y *= K;
            da.positionScreen.x *= B;
            da.positionScreen.y *= K;
            0 < N.overdraw && (g(R.positionScreen, I.positionScreen, N.overdraw), g(I.positionScreen, da.positionScreen, N.overdraw), g(da.positionScreen, R.positionScreen, N.overdraw));
            qa.setFromPoints([
              R.positionScreen,
              I.positionScreen,
              da.positionScreen
            ]);
            if (!0 === ya.isIntersectionBox(qa)) {
              G = R;
              m = I;
              H = da;
              z = N;
              v.info.render.vertices += 3;
              v.info.render.faces++;
              h(z.opacity);
              k(z.blending);
              V = G.positionScreen.x;
              X = G.positionScreen.y;
              P = m.positionScreen.x;
              ga = m.positionScreen.y;
              wa = H.positionScreen.x;
              Ha = H.positionScreen.y;
              var N = V, Q = X, D = P, F = ga, U = wa, Db = Ha;
              A.beginPath();
              A.moveTo(N, Q);
              A.lineTo(D, F);
              A.lineTo(U, Db);
              A.closePath();
              if ((z instanceof THREE.MeshLambertMaterial || z instanceof THREE.MeshPhongMaterial) && null === z.map) {
                za.copy(z.color);
                Ia.copy(z.emissive);
                z.vertexColors === THREE.FaceColors && za.multiply(E.color);
                fa.copy(ua);
                Ja.copy(G.positionWorld).add(m.positionWorld).add(H.positionWorld).divideScalar(3);
                G = Ja;
                m = E.normalModel;
                H = fa;
                E = 0;
                for (N = y.length; E < N; E++)
                  Q = y[E], Ea.copy(Q.color), Q instanceof THREE.DirectionalLight ? (D = Da.setFromMatrixPosition(Q.matrixWorld).normalize(), F = m.dot(D), 0 >= F || (F *= Q.intensity, H.add(Ea.multiplyScalar(F)))) : Q instanceof THREE.PointLight && (D = Da.setFromMatrixPosition(Q.matrixWorld), F = m.dot(Da.subVectors(D, G).normalize()), 0 >= F || (F *= 0 == Q.distance ? 1 : 1 - Math.min(G.distanceTo(D) / Q.distance, 1), 0 != F && (F *= Q.intensity, H.add(Ea.multiplyScalar(F)))));
                fa.multiply(za).add(Ia);
                !0 === z.wireframe ? b(fa, z.wireframeLinewidth, z.wireframeLinecap, z.wireframeLinejoin) : c(fa);
              } else
                z instanceof THREE.MeshBasicMaterial || z instanceof THREE.MeshLambertMaterial || z instanceof THREE.MeshPhongMaterial ? null !== z.map ? z.map.mapping instanceof THREE.UVMapping && (ha = E.uvs, f(V, X, P, ga, wa, Ha, ha[0].x, ha[0].y, ha[1].x, ha[1].y, ha[2].x, ha[2].y, z.map)) : null !== z.envMap ? z.envMap.mapping instanceof THREE.SphericalReflectionMapping ? (ja.copy(E.vertexNormalsModel[0]).applyMatrix3(ra), Oa = 0.5 * ja.x + 0.5, Ra = 0.5 * ja.y + 0.5, ja.copy(E.vertexNormalsModel[1]).applyMatrix3(ra), Sa = 0.5 * ja.x + 0.5, Fa = 0.5 * ja.y + 0.5, ja.copy(E.vertexNormalsModel[2]).applyMatrix3(ra), ia = 0.5 * ja.x + 0.5, ma = 0.5 * ja.y + 0.5, f(V, X, P, ga, wa, Ha, Oa, Ra, Sa, Fa, ia, ma, z.envMap)) : z.envMap.mapping instanceof THREE.SphericalRefractionMapping && (ja.copy(E.vertexNormalsModel[0]).applyMatrix3(ra), Oa = -0.5 * ja.x + 0.5, Ra = -0.5 * ja.y + 0.5, ja.copy(E.vertexNormalsModel[1]).applyMatrix3(ra), Sa = -0.5 * ja.x + 0.5, Fa = -0.5 * ja.y + 0.5, ja.copy(E.vertexNormalsModel[2]).applyMatrix3(ra), ia = -0.5 * ja.x + 0.5, ma = -0.5 * ja.y + 0.5, f(V, X, P, ga, wa, Ha, Oa, Ra, Sa, Fa, ia, ma, z.envMap)) : (fa.copy(z.color), z.vertexColors === THREE.FaceColors && fa.multiply(E.color), !0 === z.wireframe ? b(fa, z.wireframeLinewidth, z.wireframeLinecap, z.wireframeLinejoin) : c(fa)) : (z instanceof THREE.MeshDepthMaterial ? fa.r = fa.g = fa.b = 1 - r(G.positionScreen.z * G.positionScreen.w, W.near, W.far) : z instanceof THREE.MeshNormalMaterial ? (ja.copy(E.normalModel).applyMatrix3(ra), fa.setRGB(ja.x, ja.y, ja.z).multiplyScalar(0.5).addScalar(0.5)) : fa.setRGB(1, 1, 1), !0 === z.wireframe ? b(fa, z.wireframeLinewidth, z.wireframeLinecap, z.wireframeLinejoin) : c(fa));
            }
          }
          Z.union(qa);
        }
      }
    }
  };
};
THREE.ShaderChunk = {
  fog_pars_fragment: '#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif',
  fog_fragment: '#ifdef USE_FOG\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\n\t#else\n\t\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n\t#endif\n\t#ifdef FOG_EXP2\n\t\tconst float LOG2 = 1.442695;\n\t\tfloat fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\n\t\tfogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, depth );\n\t#endif\n\tgl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\n#endif',
  envmap_pars_fragment: '#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\tuniform samplerCube envMap;\n\tuniform float flipEnvMap;\n\tuniform int combine;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\t\tuniform bool useRefract;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif',
  envmap_fragment: '#ifdef USE_ENVMAP\n\tvec3 reflectVec;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = normalize( vec3( vec4( normal, 0.0 ) * viewMatrix ) );\n\t\tif ( useRefract ) {\n\t\t\treflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t} else { \n\t\t\treflectVec = reflect( cameraToVertex, worldNormal );\n\t\t}\n\t#else\n\t\treflectVec = vReflect;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tfloat flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n\t\tvec4 cubeColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 cubeColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#endif\n\t#ifdef GAMMA_INPUT\n\t\tcubeColor.xyz *= cubeColor.xyz;\n\t#endif\n\tif ( combine == 1 ) {\n\t\tgl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularStrength * reflectivity );\n\t} else if ( combine == 2 ) {\n\t\tgl_FragColor.xyz += cubeColor.xyz * specularStrength * reflectivity;\n\t} else {\n\t\tgl_FragColor.xyz = mix( gl_FragColor.xyz, gl_FragColor.xyz * cubeColor.xyz, specularStrength * reflectivity );\n\t}\n#endif',
  envmap_pars_vertex: '#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )\n\tvarying vec3 vReflect;\n\tuniform float refractionRatio;\n\tuniform bool useRefract;\n#endif',
  worldpos_vertex: '#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\t#ifdef USE_SKINNING\n\t\tvec4 worldPosition = modelMatrix * skinned;\n\t#endif\n\t#if defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )\n\t\tvec4 worldPosition = modelMatrix * vec4( morphed, 1.0 );\n\t#endif\n\t#if ! defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )\n\t\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n\t#endif\n#endif',
  envmap_vertex: '#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )\n\tvec3 worldNormal = mat3( modelMatrix[ 0 ].xyz, modelMatrix[ 1 ].xyz, modelMatrix[ 2 ].xyz ) * objectNormal;\n\tworldNormal = normalize( worldNormal );\n\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\tif ( useRefract ) {\n\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t} else {\n\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t}\n#endif',
  map_particle_pars_fragment: '#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif',
  map_particle_fragment: '#ifdef USE_MAP\n\tgl_FragColor = gl_FragColor * texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) );\n#endif',
  map_pars_vertex: '#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )\n\tvarying vec2 vUv;\n\tuniform vec4 offsetRepeat;\n#endif',
  map_pars_fragment: '#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif',
  map_vertex: '#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )\n\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n#endif',
  map_fragment: '#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\t#ifdef GAMMA_INPUT\n\t\ttexelColor.xyz *= texelColor.xyz;\n\t#endif\n\tgl_FragColor = gl_FragColor * texelColor;\n#endif',
  lightmap_pars_fragment: '#ifdef USE_LIGHTMAP\n\tvarying vec2 vUv2;\n\tuniform sampler2D lightMap;\n#endif',
  lightmap_pars_vertex: '#ifdef USE_LIGHTMAP\n\tvarying vec2 vUv2;\n#endif',
  lightmap_fragment: '#ifdef USE_LIGHTMAP\n\tgl_FragColor = gl_FragColor * texture2D( lightMap, vUv2 );\n#endif',
  lightmap_vertex: '#ifdef USE_LIGHTMAP\n\tvUv2 = uv2;\n#endif',
  bumpmap_pars_fragment: '#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos );\n\t\tvec3 vSigmaY = dFdy( surf_pos );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif',
  normalmap_pars_fragment: '#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 S = normalize(  q0 * st1.t - q1 * st0.t );\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n\t\tvec3 N = normalize( surf_norm );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif',
  specularmap_pars_fragment: '#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif',
  specularmap_fragment: 'float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif',
  lights_lambert_pars_vertex: 'uniform vec3 ambient;\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 ambientLightColor;\n#if MAX_DIR_LIGHTS > 0\n\tuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n\tuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n#endif\n#if MAX_HEMI_LIGHTS > 0\n\tuniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n\tuniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n\tuniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n#endif\n#if MAX_POINT_LIGHTS > 0\n\tuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n\tuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n\tuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n#endif\n#if MAX_SPOT_LIGHTS > 0\n\tuniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n\tuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n\tuniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n\tuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n\tuniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n\tuniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n#endif\n#ifdef WRAP_AROUND\n\tuniform vec3 wrapRGB;\n#endif',
  lights_lambert_vertex: 'vLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\ntransformedNormal = normalize( transformedNormal );\n#if MAX_DIR_LIGHTS > 0\nfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\tvec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\n\tvec3 dirVector = normalize( lDirection.xyz );\n\tfloat dotProduct = dot( transformedNormal, dirVector );\n\tvec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );\n\t#ifdef DOUBLE_SIDED\n\t\tvec3 directionalLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n\t\t#ifdef WRAP_AROUND\n\t\t\tvec3 directionalLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n\t\t#endif\n\t#endif\n\t#ifdef WRAP_AROUND\n\t\tvec3 directionalLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n\t\tdirectionalLightWeighting = mix( directionalLightWeighting, directionalLightWeightingHalf, wrapRGB );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tdirectionalLightWeightingBack = mix( directionalLightWeightingBack, directionalLightWeightingHalfBack, wrapRGB );\n\t\t#endif\n\t#endif\n\tvLightFront += directionalLightColor[ i ] * directionalLightWeighting;\n\t#ifdef DOUBLE_SIDED\n\t\tvLightBack += directionalLightColor[ i ] * directionalLightWeightingBack;\n\t#endif\n}\n#endif\n#if MAX_POINT_LIGHTS > 0\n\tfor( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\t\tvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\n\t\tvec3 lVector = lPosition.xyz - mvPosition.xyz;\n\t\tfloat lDistance = 1.0;\n\t\tif ( pointLightDistance[ i ] > 0.0 )\n\t\t\tlDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\n\t\tlVector = normalize( lVector );\n\t\tfloat dotProduct = dot( transformedNormal, lVector );\n\t\tvec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n\t\t\t#ifdef WRAP_AROUND\n\t\t\t\tvec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n\t\t\t#endif\n\t\t#endif\n\t\t#ifdef WRAP_AROUND\n\t\t\tvec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n\t\t\tpointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );\n\t\t\t#ifdef DOUBLE_SIDED\n\t\t\t\tpointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );\n\t\t\t#endif\n\t\t#endif\n\t\tvLightFront += pointLightColor[ i ] * pointLightWeighting * lDistance;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += pointLightColor[ i ] * pointLightWeightingBack * lDistance;\n\t\t#endif\n\t}\n#endif\n#if MAX_SPOT_LIGHTS > 0\n\tfor( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\t\tvec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\n\t\tvec3 lVector = lPosition.xyz - mvPosition.xyz;\n\t\tfloat spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - worldPosition.xyz ) );\n\t\tif ( spotEffect > spotLightAngleCos[ i ] ) {\n\t\t\tspotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );\n\t\t\tfloat lDistance = 1.0;\n\t\t\tif ( spotLightDistance[ i ] > 0.0 )\n\t\t\t\tlDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\n\t\t\tlVector = normalize( lVector );\n\t\t\tfloat dotProduct = dot( transformedNormal, lVector );\n\t\t\tvec3 spotLightWeighting = vec3( max( dotProduct, 0.0 ) );\n\t\t\t#ifdef DOUBLE_SIDED\n\t\t\t\tvec3 spotLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n\t\t\t\t#ifdef WRAP_AROUND\n\t\t\t\t\tvec3 spotLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n\t\t\t\t#endif\n\t\t\t#endif\n\t\t\t#ifdef WRAP_AROUND\n\t\t\t\tvec3 spotLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n\t\t\t\tspotLightWeighting = mix( spotLightWeighting, spotLightWeightingHalf, wrapRGB );\n\t\t\t\t#ifdef DOUBLE_SIDED\n\t\t\t\t\tspotLightWeightingBack = mix( spotLightWeightingBack, spotLightWeightingHalfBack, wrapRGB );\n\t\t\t\t#endif\n\t\t\t#endif\n\t\t\tvLightFront += spotLightColor[ i ] * spotLightWeighting * lDistance * spotEffect;\n\t\t\t#ifdef DOUBLE_SIDED\n\t\t\t\tvLightBack += spotLightColor[ i ] * spotLightWeightingBack * lDistance * spotEffect;\n\t\t\t#endif\n\t\t}\n\t}\n#endif\n#if MAX_HEMI_LIGHTS > 0\n\tfor( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\t\tvec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\n\t\tvec3 lVector = normalize( lDirection.xyz );\n\t\tfloat dotProduct = dot( transformedNormal, lVector );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n\t\tfloat hemiDiffuseWeightBack = -0.5 * dotProduct + 0.5;\n\t\tvLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );\n\t\t#endif\n\t}\n#endif\nvLightFront = vLightFront * diffuse + ambient * ambientLightColor + emissive;\n#ifdef DOUBLE_SIDED\n\tvLightBack = vLightBack * diffuse + ambient * ambientLightColor + emissive;\n#endif',
  lights_phong_pars_vertex: '#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\tvarying vec3 vWorldPosition;\n#endif',
  lights_phong_vertex: '#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\tvWorldPosition = worldPosition.xyz;\n#endif',
  lights_phong_pars_fragment: 'uniform vec3 ambientLightColor;\n#if MAX_DIR_LIGHTS > 0\n\tuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n\tuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n#endif\n#if MAX_HEMI_LIGHTS > 0\n\tuniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n\tuniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n\tuniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n#endif\n#if MAX_POINT_LIGHTS > 0\n\tuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n\tuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n\tuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n#endif\n#if MAX_SPOT_LIGHTS > 0\n\tuniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n\tuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n\tuniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n\tuniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n\tuniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n\tuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n#endif\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\tvarying vec3 vWorldPosition;\n#endif\n#ifdef WRAP_AROUND\n\tuniform vec3 wrapRGB;\n#endif\nvarying vec3 vViewPosition;\nvarying vec3 vNormal;',
  lights_phong_fragment: 'vec3 normal = normalize( vNormal );\nvec3 viewPosition = normalize( vViewPosition );\n#ifdef DOUBLE_SIDED\n\tnormal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n#endif\n#ifdef USE_NORMALMAP\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n#if MAX_POINT_LIGHTS > 0\n\tvec3 pointDiffuse  = vec3( 0.0 );\n\tvec3 pointSpecular = vec3( 0.0 );\n\tfor ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\t\tvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\n\t\tvec3 lVector = lPosition.xyz + vViewPosition.xyz;\n\t\tfloat lDistance = 1.0;\n\t\tif ( pointLightDistance[ i ] > 0.0 )\n\t\t\tlDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\n\t\tlVector = normalize( lVector );\n\t\tfloat dotProduct = dot( normal, lVector );\n\t\t#ifdef WRAP_AROUND\n\t\t\tfloat pointDiffuseWeightFull = max( dotProduct, 0.0 );\n\t\t\tfloat pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\t\t\tvec3 pointDiffuseWeight = mix( vec3( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\n\t\t#else\n\t\t\tfloat pointDiffuseWeight = max( dotProduct, 0.0 );\n\t\t#endif\n\t\tpointDiffuse  += diffuse * pointLightColor[ i ] * pointDiffuseWeight * lDistance;\n\t\tvec3 pointHalfVector = normalize( lVector + viewPosition );\n\t\tfloat pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\n\t\tfloat pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininess ), 0.0 );\n\t\tfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\n\t\tvec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, pointHalfVector ), 0.0 ), 5.0 );\n\t\tpointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance * specularNormalization;\n\t}\n#endif\n#if MAX_SPOT_LIGHTS > 0\n\tvec3 spotDiffuse  = vec3( 0.0 );\n\tvec3 spotSpecular = vec3( 0.0 );\n\tfor ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\t\tvec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\n\t\tvec3 lVector = lPosition.xyz + vViewPosition.xyz;\n\t\tfloat lDistance = 1.0;\n\t\tif ( spotLightDistance[ i ] > 0.0 )\n\t\t\tlDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\n\t\tlVector = normalize( lVector );\n\t\tfloat spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\n\t\tif ( spotEffect > spotLightAngleCos[ i ] ) {\n\t\t\tspotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );\n\t\t\tfloat dotProduct = dot( normal, lVector );\n\t\t\t#ifdef WRAP_AROUND\n\t\t\t\tfloat spotDiffuseWeightFull = max( dotProduct, 0.0 );\n\t\t\t\tfloat spotDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\t\t\t\tvec3 spotDiffuseWeight = mix( vec3( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\n\t\t\t#else\n\t\t\t\tfloat spotDiffuseWeight = max( dotProduct, 0.0 );\n\t\t\t#endif\n\t\t\tspotDiffuse += diffuse * spotLightColor[ i ] * spotDiffuseWeight * lDistance * spotEffect;\n\t\t\tvec3 spotHalfVector = normalize( lVector + viewPosition );\n\t\t\tfloat spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\n\t\t\tfloat spotSpecularWeight = specularStrength * max( pow( spotDotNormalHalf, shininess ), 0.0 );\n\t\t\tfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\n\t\t\tvec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, spotHalfVector ), 0.0 ), 5.0 );\n\t\t\tspotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * lDistance * specularNormalization * spotEffect;\n\t\t}\n\t}\n#endif\n#if MAX_DIR_LIGHTS > 0\n\tvec3 dirDiffuse  = vec3( 0.0 );\n\tvec3 dirSpecular = vec3( 0.0 );\n\tfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\t\tvec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\n\t\tvec3 dirVector = normalize( lDirection.xyz );\n\t\tfloat dotProduct = dot( normal, dirVector );\n\t\t#ifdef WRAP_AROUND\n\t\t\tfloat dirDiffuseWeightFull = max( dotProduct, 0.0 );\n\t\t\tfloat dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\t\t\tvec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );\n\t\t#else\n\t\t\tfloat dirDiffuseWeight = max( dotProduct, 0.0 );\n\t\t#endif\n\t\tdirDiffuse  += diffuse * directionalLightColor[ i ] * dirDiffuseWeight;\n\t\tvec3 dirHalfVector = normalize( dirVector + viewPosition );\n\t\tfloat dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\n\t\tfloat dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininess ), 0.0 );\n\t\tfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\n\t\tvec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( dirVector, dirHalfVector ), 0.0 ), 5.0 );\n\t\tdirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\n\t}\n#endif\n#if MAX_HEMI_LIGHTS > 0\n\tvec3 hemiDiffuse  = vec3( 0.0 );\n\tvec3 hemiSpecular = vec3( 0.0 );\n\tfor( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\t\tvec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\n\t\tvec3 lVector = normalize( lDirection.xyz );\n\t\tfloat dotProduct = dot( normal, lVector );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n\t\tvec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\t\themiDiffuse += diffuse * hemiColor;\n\t\tvec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\n\t\tfloat hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\n\t\tfloat hemiSpecularWeightSky = specularStrength * max( pow( hemiDotNormalHalfSky, shininess ), 0.0 );\n\t\tvec3 lVectorGround = -lVector;\n\t\tvec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\n\t\tfloat hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\n\t\tfloat hemiSpecularWeightGround = specularStrength * max( pow( hemiDotNormalHalfGround, shininess ), 0.0 );\n\t\tfloat dotProductGround = dot( normal, lVectorGround );\n\t\tfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\n\t\tvec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, hemiHalfVectorSky ), 0.0 ), 5.0 );\n\t\tvec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 0.0 ), 5.0 );\n\t\themiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\n\t}\n#endif\nvec3 totalDiffuse = vec3( 0.0 );\nvec3 totalSpecular = vec3( 0.0 );\n#if MAX_DIR_LIGHTS > 0\n\ttotalDiffuse += dirDiffuse;\n\ttotalSpecular += dirSpecular;\n#endif\n#if MAX_HEMI_LIGHTS > 0\n\ttotalDiffuse += hemiDiffuse;\n\ttotalSpecular += hemiSpecular;\n#endif\n#if MAX_POINT_LIGHTS > 0\n\ttotalDiffuse += pointDiffuse;\n\ttotalSpecular += pointSpecular;\n#endif\n#if MAX_SPOT_LIGHTS > 0\n\ttotalDiffuse += spotDiffuse;\n\ttotalSpecular += spotSpecular;\n#endif\n#ifdef METAL\n\tgl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient + totalSpecular );\n#else\n\tgl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient ) + totalSpecular;\n#endif',
  color_pars_fragment: '#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif',
  color_fragment: '#ifdef USE_COLOR\n\tgl_FragColor = gl_FragColor * vec4( vColor, 1.0 );\n#endif',
  color_pars_vertex: '#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif',
  color_vertex: '#ifdef USE_COLOR\n\t#ifdef GAMMA_INPUT\n\t\tvColor = color * color;\n\t#else\n\t\tvColor = color;\n\t#endif\n#endif',
  skinning_pars_vertex: '#ifdef USE_SKINNING\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureWidth;\n\t\tuniform int boneTextureHeight;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureWidth ) );\n\t\t\tfloat y = floor( j / float( boneTextureWidth ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureWidth );\n\t\t\tfloat dy = 1.0 / float( boneTextureHeight );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneGlobalMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneGlobalMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif',
  skinbase_vertex: '#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif',
  skinning_vertex: '#ifdef USE_SKINNING\n\t#ifdef USE_MORPHTARGETS\n\tvec4 skinVertex = vec4( morphed, 1.0 );\n\t#else\n\tvec4 skinVertex = vec4( position, 1.0 );\n\t#endif\n\tvec4 skinned  = boneMatX * skinVertex * skinWeight.x;\n\tskinned      += boneMatY * skinVertex * skinWeight.y;\n\tskinned      += boneMatZ * skinVertex * skinWeight.z;\n\tskinned      += boneMatW * skinVertex * skinWeight.w;\n#endif',
  morphtarget_pars_vertex: '#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif',
  morphtarget_vertex: '#ifdef USE_MORPHTARGETS\n\tvec3 morphed = vec3( 0.0 );\n\tmorphed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\tmorphed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\tmorphed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\tmorphed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\tmorphed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\tmorphed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\tmorphed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\tmorphed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n\tmorphed += position;\n#endif',
  default_vertex: 'vec4 mvPosition;\n#ifdef USE_SKINNING\n\tmvPosition = modelViewMatrix * skinned;\n#endif\n#if !defined( USE_SKINNING ) && defined( USE_MORPHTARGETS )\n\tmvPosition = modelViewMatrix * vec4( morphed, 1.0 );\n#endif\n#if !defined( USE_SKINNING ) && ! defined( USE_MORPHTARGETS )\n\tmvPosition = modelViewMatrix * vec4( position, 1.0 );\n#endif\ngl_Position = projectionMatrix * mvPosition;',
  morphnormal_vertex: '#ifdef USE_MORPHNORMALS\n\tvec3 morphedNormal = vec3( 0.0 );\n\tmorphedNormal +=  ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tmorphedNormal +=  ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tmorphedNormal +=  ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tmorphedNormal +=  ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n\tmorphedNormal += normal;\n#endif',
  skinnormal_vertex: '#ifdef USE_SKINNING\n\tmat4 skinMatrix = skinWeight.x * boneMatX;\n\tskinMatrix \t+= skinWeight.y * boneMatY;\n\tskinMatrix \t+= skinWeight.z * boneMatZ;\n\tskinMatrix \t+= skinWeight.w * boneMatW;\n\t#ifdef USE_MORPHNORMALS\n\tvec4 skinnedNormal = skinMatrix * vec4( morphedNormal, 0.0 );\n\t#else\n\tvec4 skinnedNormal = skinMatrix * vec4( normal, 0.0 );\n\t#endif\n#endif',
  defaultnormal_vertex: 'vec3 objectNormal;\n#ifdef USE_SKINNING\n\tobjectNormal = skinnedNormal.xyz;\n#endif\n#if !defined( USE_SKINNING ) && defined( USE_MORPHNORMALS )\n\tobjectNormal = morphedNormal;\n#endif\n#if !defined( USE_SKINNING ) && ! defined( USE_MORPHNORMALS )\n\tobjectNormal = normal;\n#endif\n#ifdef FLIP_SIDED\n\tobjectNormal = -objectNormal;\n#endif\nvec3 transformedNormal = normalMatrix * objectNormal;',
  shadowmap_pars_fragment: '#ifdef USE_SHADOWMAP\n\tuniform sampler2D shadowMap[ MAX_SHADOWS ];\n\tuniform vec2 shadowMapSize[ MAX_SHADOWS ];\n\tuniform float shadowDarkness[ MAX_SHADOWS ];\n\tuniform float shadowBias[ MAX_SHADOWS ];\n\tvarying vec4 vShadowCoord[ MAX_SHADOWS ];\n\tfloat unpackDepth( const in vec4 rgba_depth ) {\n\t\tconst vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n\t\tfloat depth = dot( rgba_depth, bit_shift );\n\t\treturn depth;\n\t}\n#endif',
  shadowmap_fragment: '#ifdef USE_SHADOWMAP\n\t#ifdef SHADOWMAP_DEBUG\n\t\tvec3 frustumColors[3];\n\t\tfrustumColors[0] = vec3( 1.0, 0.5, 0.0 );\n\t\tfrustumColors[1] = vec3( 0.0, 1.0, 0.8 );\n\t\tfrustumColors[2] = vec3( 0.0, 0.5, 1.0 );\n\t#endif\n\t#ifdef SHADOWMAP_CASCADE\n\t\tint inFrustumCount = 0;\n\t#endif\n\tfloat fDepth;\n\tvec3 shadowColor = vec3( 1.0 );\n\tfor( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\t\tvec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\t#ifdef SHADOWMAP_CASCADE\n\t\t\tinFrustumCount += int( inFrustum );\n\t\t\tbvec3 frustumTestVec = bvec3( inFrustum, inFrustumCount == 1, shadowCoord.z <= 1.0 );\n\t\t#else\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\t#endif\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t\tshadowCoord.z += shadowBias[ i ];\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\t\tfloat shadow = 0.0;\n\t\t\t\tconst float shadowDelta = 1.0 / 9.0;\n\t\t\t\tfloat xPixelOffset = 1.0 / shadowMapSize[ i ].x;\n\t\t\t\tfloat yPixelOffset = 1.0 / shadowMapSize[ i ].y;\n\t\t\t\tfloat dx0 = -1.25 * xPixelOffset;\n\t\t\t\tfloat dy0 = -1.25 * yPixelOffset;\n\t\t\t\tfloat dx1 = 1.25 * xPixelOffset;\n\t\t\t\tfloat dy1 = 1.25 * yPixelOffset;\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\t\t\t\tshadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\t\tfloat shadow = 0.0;\n\t\t\t\tfloat xPixelOffset = 1.0 / shadowMapSize[ i ].x;\n\t\t\t\tfloat yPixelOffset = 1.0 / shadowMapSize[ i ].y;\n\t\t\t\tfloat dx0 = -1.0 * xPixelOffset;\n\t\t\t\tfloat dy0 = -1.0 * yPixelOffset;\n\t\t\t\tfloat dx1 = 1.0 * xPixelOffset;\n\t\t\t\tfloat dy1 = 1.0 * yPixelOffset;\n\t\t\t\tmat3 shadowKernel;\n\t\t\t\tmat3 depthKernel;\n\t\t\t\tdepthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n\t\t\t\tdepthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n\t\t\t\tdepthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n\t\t\t\tdepthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n\t\t\t\tdepthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n\t\t\t\tdepthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n\t\t\t\tdepthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n\t\t\t\tdepthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n\t\t\t\tdepthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n\t\t\t\tvec3 shadowZ = vec3( shadowCoord.z );\n\t\t\t\tshadowKernel[0] = vec3(lessThan(depthKernel[0], shadowZ ));\n\t\t\t\tshadowKernel[0] *= vec3(0.25);\n\t\t\t\tshadowKernel[1] = vec3(lessThan(depthKernel[1], shadowZ ));\n\t\t\t\tshadowKernel[1] *= vec3(0.25);\n\t\t\t\tshadowKernel[2] = vec3(lessThan(depthKernel[2], shadowZ ));\n\t\t\t\tshadowKernel[2] *= vec3(0.25);\n\t\t\t\tvec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );\n\t\t\t\tshadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );\n\t\t\t\tshadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );\n\t\t\t\tvec4 shadowValues;\n\t\t\t\tshadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );\n\t\t\t\tshadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );\n\t\t\t\tshadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );\n\t\t\t\tshadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );\n\t\t\t\tshadow = dot( shadowValues, vec4( 1.0 ) );\n\t\t\t\tshadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n\t\t\t#else\n\t\t\t\tvec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\n\t\t\t\tfloat fDepth = unpackDepth( rgbaDepth );\n\t\t\t\tif ( fDepth < shadowCoord.z )\n\t\t\t\t\tshadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );\n\t\t\t#endif\n\t\t}\n\t\t#ifdef SHADOWMAP_DEBUG\n\t\t\t#ifdef SHADOWMAP_CASCADE\n\t\t\t\tif ( inFrustum && inFrustumCount == 1 ) gl_FragColor.xyz *= frustumColors[ i ];\n\t\t\t#else\n\t\t\t\tif ( inFrustum ) gl_FragColor.xyz *= frustumColors[ i ];\n\t\t\t#endif\n\t\t#endif\n\t}\n\t#ifdef GAMMA_OUTPUT\n\t\tshadowColor *= shadowColor;\n\t#endif\n\tgl_FragColor.xyz = gl_FragColor.xyz * shadowColor;\n#endif',
  shadowmap_pars_vertex: '#ifdef USE_SHADOWMAP\n\tvarying vec4 vShadowCoord[ MAX_SHADOWS ];\n\tuniform mat4 shadowMatrix[ MAX_SHADOWS ];\n#endif',
  shadowmap_vertex: '#ifdef USE_SHADOWMAP\n\tfor( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\t\tvShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\n\t}\n#endif',
  alphatest_fragment: '#ifdef ALPHATEST\n\tif ( gl_FragColor.a < ALPHATEST ) discard;\n#endif',
  linear_to_gamma_fragment: '#ifdef GAMMA_OUTPUT\n\tgl_FragColor.xyz = sqrt( gl_FragColor.xyz );\n#endif',
  logdepthbuf_pars_vertex: '#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n\tuniform float logDepthBufFC;\n#endif',
  logdepthbuf_vertex: '#ifdef USE_LOGDEPTHBUF\n\tgl_Position.z = log2(max(1e-6, gl_Position.w + 1.0)) * logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n#else\n\t\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\t#endif\n#endif',
  logdepthbuf_pars_fragment: '#ifdef USE_LOGDEPTHBUF\n\tuniform float logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\t#extension GL_EXT_frag_depth : enable\n\t\tvarying float vFragDepth;\n\t#endif\n#endif',
  logdepthbuf_fragment: '#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n#endif'
};
THREE.UniformsUtils = {
  merge: function (a) {
    var b, c, d, e = {};
    for (b = 0; b < a.length; b++)
      for (c in d = this.clone(a[b]), d)
        e[c] = d[c];
    return e;
  },
  clone: function (a) {
    var b, c, d, e = {};
    for (b in a)
      for (c in e[b] = {}, a[b])
        d = a[b][c], e[b][c] = d instanceof THREE.Color || d instanceof THREE.Vector2 || d instanceof THREE.Vector3 || d instanceof THREE.Vector4 || d instanceof THREE.Matrix4 || d instanceof THREE.Texture ? d.clone() : d instanceof Array ? d.slice() : d;
    return e;
  }
};
THREE.UniformsLib = {
  common: {
    diffuse: {
      type: 'c',
      value: new THREE.Color(15658734)
    },
    opacity: {
      type: 'f',
      value: 1
    },
    map: {
      type: 't',
      value: null
    },
    offsetRepeat: {
      type: 'v4',
      value: new THREE.Vector4(0, 0, 1, 1)
    },
    lightMap: {
      type: 't',
      value: null
    },
    specularMap: {
      type: 't',
      value: null
    },
    envMap: {
      type: 't',
      value: null
    },
    flipEnvMap: {
      type: 'f',
      value: -1
    },
    useRefract: {
      type: 'i',
      value: 0
    },
    reflectivity: {
      type: 'f',
      value: 1
    },
    refractionRatio: {
      type: 'f',
      value: 0.98
    },
    combine: {
      type: 'i',
      value: 0
    },
    morphTargetInfluences: {
      type: 'f',
      value: 0
    }
  },
  bump: {
    bumpMap: {
      type: 't',
      value: null
    },
    bumpScale: {
      type: 'f',
      value: 1
    }
  },
  normalmap: {
    normalMap: {
      type: 't',
      value: null
    },
    normalScale: {
      type: 'v2',
      value: new THREE.Vector2(1, 1)
    }
  },
  fog: {
    fogDensity: {
      type: 'f',
      value: 0.00025
    },
    fogNear: {
      type: 'f',
      value: 1
    },
    fogFar: {
      type: 'f',
      value: 2000
    },
    fogColor: {
      type: 'c',
      value: new THREE.Color(16777215)
    }
  },
  lights: {
    ambientLightColor: {
      type: 'fv',
      value: []
    },
    directionalLightDirection: {
      type: 'fv',
      value: []
    },
    directionalLightColor: {
      type: 'fv',
      value: []
    },
    hemisphereLightDirection: {
      type: 'fv',
      value: []
    },
    hemisphereLightSkyColor: {
      type: 'fv',
      value: []
    },
    hemisphereLightGroundColor: {
      type: 'fv',
      value: []
    },
    pointLightColor: {
      type: 'fv',
      value: []
    },
    pointLightPosition: {
      type: 'fv',
      value: []
    },
    pointLightDistance: {
      type: 'fv1',
      value: []
    },
    spotLightColor: {
      type: 'fv',
      value: []
    },
    spotLightPosition: {
      type: 'fv',
      value: []
    },
    spotLightDirection: {
      type: 'fv',
      value: []
    },
    spotLightDistance: {
      type: 'fv1',
      value: []
    },
    spotLightAngleCos: {
      type: 'fv1',
      value: []
    },
    spotLightExponent: {
      type: 'fv1',
      value: []
    }
  },
  particle: {
    psColor: {
      type: 'c',
      value: new THREE.Color(15658734)
    },
    opacity: {
      type: 'f',
      value: 1
    },
    size: {
      type: 'f',
      value: 1
    },
    scale: {
      type: 'f',
      value: 1
    },
    map: {
      type: 't',
      value: null
    },
    fogDensity: {
      type: 'f',
      value: 0.00025
    },
    fogNear: {
      type: 'f',
      value: 1
    },
    fogFar: {
      type: 'f',
      value: 2000
    },
    fogColor: {
      type: 'c',
      value: new THREE.Color(16777215)
    }
  },
  shadowmap: {
    shadowMap: {
      type: 'tv',
      value: []
    },
    shadowMapSize: {
      type: 'v2v',
      value: []
    },
    shadowBias: {
      type: 'fv1',
      value: []
    },
    shadowDarkness: {
      type: 'fv1',
      value: []
    },
    shadowMatrix: {
      type: 'm4v',
      value: []
    }
  }
};
THREE.ShaderLib = {
  basic: {
    uniforms: THREE.UniformsUtils.merge([
      THREE.UniformsLib.common,
      THREE.UniformsLib.fog,
      THREE.UniformsLib.shadowmap
    ]),
    vertexShader: [
      THREE.ShaderChunk.map_pars_vertex,
      THREE.ShaderChunk.lightmap_pars_vertex,
      THREE.ShaderChunk.envmap_pars_vertex,
      THREE.ShaderChunk.color_pars_vertex,
      THREE.ShaderChunk.morphtarget_pars_vertex,
      THREE.ShaderChunk.skinning_pars_vertex,
      THREE.ShaderChunk.shadowmap_pars_vertex,
      THREE.ShaderChunk.logdepthbuf_pars_vertex,
      'void main() {',
      THREE.ShaderChunk.map_vertex,
      THREE.ShaderChunk.lightmap_vertex,
      THREE.ShaderChunk.color_vertex,
      THREE.ShaderChunk.skinbase_vertex,
      '\t#ifdef USE_ENVMAP',
      THREE.ShaderChunk.morphnormal_vertex,
      THREE.ShaderChunk.skinnormal_vertex,
      THREE.ShaderChunk.defaultnormal_vertex,
      '\t#endif',
      THREE.ShaderChunk.morphtarget_vertex,
      THREE.ShaderChunk.skinning_vertex,
      THREE.ShaderChunk.default_vertex,
      THREE.ShaderChunk.logdepthbuf_vertex,
      THREE.ShaderChunk.worldpos_vertex,
      THREE.ShaderChunk.envmap_vertex,
      THREE.ShaderChunk.shadowmap_vertex,
      '}'
    ].join('\n'),
    fragmentShader: [
      'uniform vec3 diffuse;\nuniform float opacity;',
      THREE.ShaderChunk.color_pars_fragment,
      THREE.ShaderChunk.map_pars_fragment,
      THREE.ShaderChunk.lightmap_pars_fragment,
      THREE.ShaderChunk.envmap_pars_fragment,
      THREE.ShaderChunk.fog_pars_fragment,
      THREE.ShaderChunk.shadowmap_pars_fragment,
      THREE.ShaderChunk.specularmap_pars_fragment,
      THREE.ShaderChunk.logdepthbuf_pars_fragment,
      'void main() {\n\tgl_FragColor = vec4( diffuse, opacity );',
      THREE.ShaderChunk.logdepthbuf_fragment,
      THREE.ShaderChunk.map_fragment,
      THREE.ShaderChunk.alphatest_fragment,
      THREE.ShaderChunk.specularmap_fragment,
      THREE.ShaderChunk.lightmap_fragment,
      THREE.ShaderChunk.color_fragment,
      THREE.ShaderChunk.envmap_fragment,
      THREE.ShaderChunk.shadowmap_fragment,
      THREE.ShaderChunk.linear_to_gamma_fragment,
      THREE.ShaderChunk.fog_fragment,
      '}'
    ].join('\n')
  },
  lambert: {
    uniforms: THREE.UniformsUtils.merge([
      THREE.UniformsLib.common,
      THREE.UniformsLib.fog,
      THREE.UniformsLib.lights,
      THREE.UniformsLib.shadowmap,
      {
        ambient: {
          type: 'c',
          value: new THREE.Color(16777215)
        },
        emissive: {
          type: 'c',
          value: new THREE.Color(0)
        },
        wrapRGB: {
          type: 'v3',
          value: new THREE.Vector3(1, 1, 1)
        }
      }
    ]),
    vertexShader: [
      '#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif',
      THREE.ShaderChunk.map_pars_vertex,
      THREE.ShaderChunk.lightmap_pars_vertex,
      THREE.ShaderChunk.envmap_pars_vertex,
      THREE.ShaderChunk.lights_lambert_pars_vertex,
      THREE.ShaderChunk.color_pars_vertex,
      THREE.ShaderChunk.morphtarget_pars_vertex,
      THREE.ShaderChunk.skinning_pars_vertex,
      THREE.ShaderChunk.shadowmap_pars_vertex,
      THREE.ShaderChunk.logdepthbuf_pars_vertex,
      'void main() {',
      THREE.ShaderChunk.map_vertex,
      THREE.ShaderChunk.lightmap_vertex,
      THREE.ShaderChunk.color_vertex,
      THREE.ShaderChunk.morphnormal_vertex,
      THREE.ShaderChunk.skinbase_vertex,
      THREE.ShaderChunk.skinnormal_vertex,
      THREE.ShaderChunk.defaultnormal_vertex,
      THREE.ShaderChunk.morphtarget_vertex,
      THREE.ShaderChunk.skinning_vertex,
      THREE.ShaderChunk.default_vertex,
      THREE.ShaderChunk.logdepthbuf_vertex,
      THREE.ShaderChunk.worldpos_vertex,
      THREE.ShaderChunk.envmap_vertex,
      THREE.ShaderChunk.lights_lambert_vertex,
      THREE.ShaderChunk.shadowmap_vertex,
      '}'
    ].join('\n'),
    fragmentShader: [
      'uniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif',
      THREE.ShaderChunk.color_pars_fragment,
      THREE.ShaderChunk.map_pars_fragment,
      THREE.ShaderChunk.lightmap_pars_fragment,
      THREE.ShaderChunk.envmap_pars_fragment,
      THREE.ShaderChunk.fog_pars_fragment,
      THREE.ShaderChunk.shadowmap_pars_fragment,
      THREE.ShaderChunk.specularmap_pars_fragment,
      THREE.ShaderChunk.logdepthbuf_pars_fragment,
      'void main() {\n\tgl_FragColor = vec4( vec3( 1.0 ), opacity );',
      THREE.ShaderChunk.logdepthbuf_fragment,
      THREE.ShaderChunk.map_fragment,
      THREE.ShaderChunk.alphatest_fragment,
      THREE.ShaderChunk.specularmap_fragment,
      '\t#ifdef DOUBLE_SIDED\n\t\tif ( gl_FrontFacing )\n\t\t\tgl_FragColor.xyz *= vLightFront;\n\t\telse\n\t\t\tgl_FragColor.xyz *= vLightBack;\n\t#else\n\t\tgl_FragColor.xyz *= vLightFront;\n\t#endif',
      THREE.ShaderChunk.lightmap_fragment,
      THREE.ShaderChunk.color_fragment,
      THREE.ShaderChunk.envmap_fragment,
      THREE.ShaderChunk.shadowmap_fragment,
      THREE.ShaderChunk.linear_to_gamma_fragment,
      THREE.ShaderChunk.fog_fragment,
      '}'
    ].join('\n')
  },
  phong: {
    uniforms: THREE.UniformsUtils.merge([
      THREE.UniformsLib.common,
      THREE.UniformsLib.bump,
      THREE.UniformsLib.normalmap,
      THREE.UniformsLib.fog,
      THREE.UniformsLib.lights,
      THREE.UniformsLib.shadowmap,
      {
        ambient: {
          type: 'c',
          value: new THREE.Color(16777215)
        },
        emissive: {
          type: 'c',
          value: new THREE.Color(0)
        },
        specular: {
          type: 'c',
          value: new THREE.Color(1118481)
        },
        shininess: {
          type: 'f',
          value: 30
        },
        wrapRGB: {
          type: 'v3',
          value: new THREE.Vector3(1, 1, 1)
        }
      }
    ]),
    vertexShader: [
      '#define PHONG\nvarying vec3 vViewPosition;\nvarying vec3 vNormal;',
      THREE.ShaderChunk.map_pars_vertex,
      THREE.ShaderChunk.lightmap_pars_vertex,
      THREE.ShaderChunk.envmap_pars_vertex,
      THREE.ShaderChunk.lights_phong_pars_vertex,
      THREE.ShaderChunk.color_pars_vertex,
      THREE.ShaderChunk.morphtarget_pars_vertex,
      THREE.ShaderChunk.skinning_pars_vertex,
      THREE.ShaderChunk.shadowmap_pars_vertex,
      THREE.ShaderChunk.logdepthbuf_pars_vertex,
      'void main() {',
      THREE.ShaderChunk.map_vertex,
      THREE.ShaderChunk.lightmap_vertex,
      THREE.ShaderChunk.color_vertex,
      THREE.ShaderChunk.morphnormal_vertex,
      THREE.ShaderChunk.skinbase_vertex,
      THREE.ShaderChunk.skinnormal_vertex,
      THREE.ShaderChunk.defaultnormal_vertex,
      '\tvNormal = normalize( transformedNormal );',
      THREE.ShaderChunk.morphtarget_vertex,
      THREE.ShaderChunk.skinning_vertex,
      THREE.ShaderChunk.default_vertex,
      THREE.ShaderChunk.logdepthbuf_vertex,
      '\tvViewPosition = -mvPosition.xyz;',
      THREE.ShaderChunk.worldpos_vertex,
      THREE.ShaderChunk.envmap_vertex,
      THREE.ShaderChunk.lights_phong_vertex,
      THREE.ShaderChunk.shadowmap_vertex,
      '}'
    ].join('\n'),
    fragmentShader: [
      'uniform vec3 diffuse;\nuniform float opacity;\nuniform vec3 ambient;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;',
      THREE.ShaderChunk.color_pars_fragment,
      THREE.ShaderChunk.map_pars_fragment,
      THREE.ShaderChunk.lightmap_pars_fragment,
      THREE.ShaderChunk.envmap_pars_fragment,
      THREE.ShaderChunk.fog_pars_fragment,
      THREE.ShaderChunk.lights_phong_pars_fragment,
      THREE.ShaderChunk.shadowmap_pars_fragment,
      THREE.ShaderChunk.bumpmap_pars_fragment,
      THREE.ShaderChunk.normalmap_pars_fragment,
      THREE.ShaderChunk.specularmap_pars_fragment,
      THREE.ShaderChunk.logdepthbuf_pars_fragment,
      'void main() {\n\tgl_FragColor = vec4( vec3( 1.0 ), opacity );',
      THREE.ShaderChunk.logdepthbuf_fragment,
      THREE.ShaderChunk.map_fragment,
      THREE.ShaderChunk.alphatest_fragment,
      THREE.ShaderChunk.specularmap_fragment,
      THREE.ShaderChunk.lights_phong_fragment,
      THREE.ShaderChunk.lightmap_fragment,
      THREE.ShaderChunk.color_fragment,
      THREE.ShaderChunk.envmap_fragment,
      THREE.ShaderChunk.shadowmap_fragment,
      THREE.ShaderChunk.linear_to_gamma_fragment,
      THREE.ShaderChunk.fog_fragment,
      '}'
    ].join('\n')
  },
  particle_basic: {
    uniforms: THREE.UniformsUtils.merge([
      THREE.UniformsLib.particle,
      THREE.UniformsLib.shadowmap
    ]),
    vertexShader: [
      'uniform float size;\nuniform float scale;',
      THREE.ShaderChunk.color_pars_vertex,
      THREE.ShaderChunk.shadowmap_pars_vertex,
      THREE.ShaderChunk.logdepthbuf_pars_vertex,
      'void main() {',
      THREE.ShaderChunk.color_vertex,
      '\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / length( mvPosition.xyz ) );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif\n\tgl_Position = projectionMatrix * mvPosition;',
      THREE.ShaderChunk.logdepthbuf_vertex,
      THREE.ShaderChunk.worldpos_vertex,
      THREE.ShaderChunk.shadowmap_vertex,
      '}'
    ].join('\n'),
    fragmentShader: [
      'uniform vec3 psColor;\nuniform float opacity;',
      THREE.ShaderChunk.color_pars_fragment,
      THREE.ShaderChunk.map_particle_pars_fragment,
      THREE.ShaderChunk.fog_pars_fragment,
      THREE.ShaderChunk.shadowmap_pars_fragment,
      THREE.ShaderChunk.logdepthbuf_pars_fragment,
      'void main() {\n\tgl_FragColor = vec4( psColor, opacity );',
      THREE.ShaderChunk.logdepthbuf_fragment,
      THREE.ShaderChunk.map_particle_fragment,
      THREE.ShaderChunk.alphatest_fragment,
      THREE.ShaderChunk.color_fragment,
      THREE.ShaderChunk.shadowmap_fragment,
      THREE.ShaderChunk.fog_fragment,
      '}'
    ].join('\n')
  },
  dashed: {
    uniforms: THREE.UniformsUtils.merge([
      THREE.UniformsLib.common,
      THREE.UniformsLib.fog,
      {
        scale: {
          type: 'f',
          value: 1
        },
        dashSize: {
          type: 'f',
          value: 1
        },
        totalSize: {
          type: 'f',
          value: 2
        }
      }
    ]),
    vertexShader: [
      'uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;',
      THREE.ShaderChunk.color_pars_vertex,
      THREE.ShaderChunk.logdepthbuf_pars_vertex,
      'void main() {',
      THREE.ShaderChunk.color_vertex,
      '\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;',
      THREE.ShaderChunk.logdepthbuf_vertex,
      '}'
    ].join('\n'),
    fragmentShader: [
      'uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;',
      THREE.ShaderChunk.color_pars_fragment,
      THREE.ShaderChunk.fog_pars_fragment,
      THREE.ShaderChunk.logdepthbuf_pars_fragment,
      'void main() {\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tgl_FragColor = vec4( diffuse, opacity );',
      THREE.ShaderChunk.logdepthbuf_fragment,
      THREE.ShaderChunk.color_fragment,
      THREE.ShaderChunk.fog_fragment,
      '}'
    ].join('\n')
  },
  depth: {
    uniforms: {
      mNear: {
        type: 'f',
        value: 1
      },
      mFar: {
        type: 'f',
        value: 2000
      },
      opacity: {
        type: 'f',
        value: 1
      }
    },
    vertexShader: [
      THREE.ShaderChunk.morphtarget_pars_vertex,
      THREE.ShaderChunk.logdepthbuf_pars_vertex,
      'void main() {',
      THREE.ShaderChunk.morphtarget_vertex,
      THREE.ShaderChunk.default_vertex,
      THREE.ShaderChunk.logdepthbuf_vertex,
      '}'
    ].join('\n'),
    fragmentShader: [
      'uniform float mNear;\nuniform float mFar;\nuniform float opacity;',
      THREE.ShaderChunk.logdepthbuf_pars_fragment,
      'void main() {',
      THREE.ShaderChunk.logdepthbuf_fragment,
      '\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\n\t#else\n\t\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n\t#endif\n\tfloat color = 1.0 - smoothstep( mNear, mFar, depth );\n\tgl_FragColor = vec4( vec3( color ), opacity );\n}'
    ].join('\n')
  },
  normal: {
    uniforms: {
      opacity: {
        type: 'f',
        value: 1
      }
    },
    vertexShader: [
      'varying vec3 vNormal;',
      THREE.ShaderChunk.morphtarget_pars_vertex,
      THREE.ShaderChunk.logdepthbuf_pars_vertex,
      'void main() {\n\tvNormal = normalize( normalMatrix * normal );',
      THREE.ShaderChunk.morphtarget_vertex,
      THREE.ShaderChunk.default_vertex,
      THREE.ShaderChunk.logdepthbuf_vertex,
      '}'
    ].join('\n'),
    fragmentShader: [
      'uniform float opacity;\nvarying vec3 vNormal;',
      THREE.ShaderChunk.logdepthbuf_pars_fragment,
      'void main() {\n\tgl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );',
      THREE.ShaderChunk.logdepthbuf_fragment,
      '}'
    ].join('\n')
  },
  normalmap: {
    uniforms: THREE.UniformsUtils.merge([
      THREE.UniformsLib.fog,
      THREE.UniformsLib.lights,
      THREE.UniformsLib.shadowmap,
      {
        enableAO: {
          type: 'i',
          value: 0
        },
        enableDiffuse: {
          type: 'i',
          value: 0
        },
        enableSpecular: {
          type: 'i',
          value: 0
        },
        enableReflection: {
          type: 'i',
          value: 0
        },
        enableDisplacement: {
          type: 'i',
          value: 0
        },
        tDisplacement: {
          type: 't',
          value: null
        },
        tDiffuse: {
          type: 't',
          value: null
        },
        tCube: {
          type: 't',
          value: null
        },
        tNormal: {
          type: 't',
          value: null
        },
        tSpecular: {
          type: 't',
          value: null
        },
        tAO: {
          type: 't',
          value: null
        },
        uNormalScale: {
          type: 'v2',
          value: new THREE.Vector2(1, 1)
        },
        uDisplacementBias: {
          type: 'f',
          value: 0
        },
        uDisplacementScale: {
          type: 'f',
          value: 1
        },
        diffuse: {
          type: 'c',
          value: new THREE.Color(16777215)
        },
        specular: {
          type: 'c',
          value: new THREE.Color(1118481)
        },
        ambient: {
          type: 'c',
          value: new THREE.Color(16777215)
        },
        shininess: {
          type: 'f',
          value: 30
        },
        opacity: {
          type: 'f',
          value: 1
        },
        useRefract: {
          type: 'i',
          value: 0
        },
        refractionRatio: {
          type: 'f',
          value: 0.98
        },
        reflectivity: {
          type: 'f',
          value: 0.5
        },
        uOffset: {
          type: 'v2',
          value: new THREE.Vector2(0, 0)
        },
        uRepeat: {
          type: 'v2',
          value: new THREE.Vector2(1, 1)
        },
        wrapRGB: {
          type: 'v3',
          value: new THREE.Vector3(1, 1, 1)
        }
      }
    ]),
    fragmentShader: [
      'uniform vec3 ambient;\nuniform vec3 diffuse;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\nuniform bool enableDiffuse;\nuniform bool enableSpecular;\nuniform bool enableAO;\nuniform bool enableReflection;\nuniform sampler2D tDiffuse;\nuniform sampler2D tNormal;\nuniform sampler2D tSpecular;\nuniform sampler2D tAO;\nuniform samplerCube tCube;\nuniform vec2 uNormalScale;\nuniform bool useRefract;\nuniform float refractionRatio;\nuniform float reflectivity;\nvarying vec3 vTangent;\nvarying vec3 vBinormal;\nvarying vec3 vNormal;\nvarying vec2 vUv;\nuniform vec3 ambientLightColor;\n#if MAX_DIR_LIGHTS > 0\n\tuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n\tuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n#endif\n#if MAX_HEMI_LIGHTS > 0\n\tuniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n\tuniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n\tuniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n#endif\n#if MAX_POINT_LIGHTS > 0\n\tuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n\tuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n\tuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n#endif\n#if MAX_SPOT_LIGHTS > 0\n\tuniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n\tuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n\tuniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n\tuniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n\tuniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n\tuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n#endif\n#ifdef WRAP_AROUND\n\tuniform vec3 wrapRGB;\n#endif\nvarying vec3 vWorldPosition;\nvarying vec3 vViewPosition;',
      THREE.ShaderChunk.shadowmap_pars_fragment,
      THREE.ShaderChunk.fog_pars_fragment,
      THREE.ShaderChunk.logdepthbuf_pars_fragment,
      'void main() {',
      THREE.ShaderChunk.logdepthbuf_fragment,
      '\tgl_FragColor = vec4( vec3( 1.0 ), opacity );\n\tvec3 specularTex = vec3( 1.0 );\n\tvec3 normalTex = texture2D( tNormal, vUv ).xyz * 2.0 - 1.0;\n\tnormalTex.xy *= uNormalScale;\n\tnormalTex = normalize( normalTex );\n\tif( enableDiffuse ) {\n\t\t#ifdef GAMMA_INPUT\n\t\t\tvec4 texelColor = texture2D( tDiffuse, vUv );\n\t\t\ttexelColor.xyz *= texelColor.xyz;\n\t\t\tgl_FragColor = gl_FragColor * texelColor;\n\t\t#else\n\t\t\tgl_FragColor = gl_FragColor * texture2D( tDiffuse, vUv );\n\t\t#endif\n\t}\n\tif( enableAO ) {\n\t\t#ifdef GAMMA_INPUT\n\t\t\tvec4 aoColor = texture2D( tAO, vUv );\n\t\t\taoColor.xyz *= aoColor.xyz;\n\t\t\tgl_FragColor.xyz = gl_FragColor.xyz * aoColor.xyz;\n\t\t#else\n\t\t\tgl_FragColor.xyz = gl_FragColor.xyz * texture2D( tAO, vUv ).xyz;\n\t\t#endif\n\t}\n\tif( enableSpecular )\n\t\tspecularTex = texture2D( tSpecular, vUv ).xyz;\n\tmat3 tsb = mat3( normalize( vTangent ), normalize( vBinormal ), normalize( vNormal ) );\n\tvec3 finalNormal = tsb * normalTex;\n\t#ifdef FLIP_SIDED\n\t\tfinalNormal = -finalNormal;\n\t#endif\n\tvec3 normal = normalize( finalNormal );\n\tvec3 viewPosition = normalize( vViewPosition );\n\t#if MAX_POINT_LIGHTS > 0\n\t\tvec3 pointDiffuse = vec3( 0.0 );\n\t\tvec3 pointSpecular = vec3( 0.0 );\n\t\tfor ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\t\t\tvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\n\t\t\tvec3 pointVector = lPosition.xyz + vViewPosition.xyz;\n\t\t\tfloat pointDistance = 1.0;\n\t\t\tif ( pointLightDistance[ i ] > 0.0 )\n\t\t\t\tpointDistance = 1.0 - min( ( length( pointVector ) / pointLightDistance[ i ] ), 1.0 );\n\t\t\tpointVector = normalize( pointVector );\n\t\t\t#ifdef WRAP_AROUND\n\t\t\t\tfloat pointDiffuseWeightFull = max( dot( normal, pointVector ), 0.0 );\n\t\t\t\tfloat pointDiffuseWeightHalf = max( 0.5 * dot( normal, pointVector ) + 0.5, 0.0 );\n\t\t\t\tvec3 pointDiffuseWeight = mix( vec3( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\n\t\t\t#else\n\t\t\t\tfloat pointDiffuseWeight = max( dot( normal, pointVector ), 0.0 );\n\t\t\t#endif\n\t\t\tpointDiffuse += pointDistance * pointLightColor[ i ] * diffuse * pointDiffuseWeight;\n\t\t\tvec3 pointHalfVector = normalize( pointVector + viewPosition );\n\t\t\tfloat pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\n\t\t\tfloat pointSpecularWeight = specularTex.r * max( pow( pointDotNormalHalf, shininess ), 0.0 );\n\t\t\tfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\n\t\t\tvec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( pointVector, pointHalfVector ), 5.0 );\n\t\t\tpointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * pointDistance * specularNormalization;\n\t\t}\n\t#endif\n\t#if MAX_SPOT_LIGHTS > 0\n\t\tvec3 spotDiffuse = vec3( 0.0 );\n\t\tvec3 spotSpecular = vec3( 0.0 );\n\t\tfor ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\t\t\tvec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\n\t\t\tvec3 spotVector = lPosition.xyz + vViewPosition.xyz;\n\t\t\tfloat spotDistance = 1.0;\n\t\t\tif ( spotLightDistance[ i ] > 0.0 )\n\t\t\t\tspotDistance = 1.0 - min( ( length( spotVector ) / spotLightDistance[ i ] ), 1.0 );\n\t\t\tspotVector = normalize( spotVector );\n\t\t\tfloat spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\n\t\t\tif ( spotEffect > spotLightAngleCos[ i ] ) {\n\t\t\t\tspotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );\n\t\t\t\t#ifdef WRAP_AROUND\n\t\t\t\t\tfloat spotDiffuseWeightFull = max( dot( normal, spotVector ), 0.0 );\n\t\t\t\t\tfloat spotDiffuseWeightHalf = max( 0.5 * dot( normal, spotVector ) + 0.5, 0.0 );\n\t\t\t\t\tvec3 spotDiffuseWeight = mix( vec3( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\n\t\t\t\t#else\n\t\t\t\t\tfloat spotDiffuseWeight = max( dot( normal, spotVector ), 0.0 );\n\t\t\t\t#endif\n\t\t\t\tspotDiffuse += spotDistance * spotLightColor[ i ] * diffuse * spotDiffuseWeight * spotEffect;\n\t\t\t\tvec3 spotHalfVector = normalize( spotVector + viewPosition );\n\t\t\t\tfloat spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\n\t\t\t\tfloat spotSpecularWeight = specularTex.r * max( pow( spotDotNormalHalf, shininess ), 0.0 );\n\t\t\t\tfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\n\t\t\t\tvec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( spotVector, spotHalfVector ), 5.0 );\n\t\t\t\tspotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * spotDistance * specularNormalization * spotEffect;\n\t\t\t}\n\t\t}\n\t#endif\n\t#if MAX_DIR_LIGHTS > 0\n\t\tvec3 dirDiffuse = vec3( 0.0 );\n\t\tvec3 dirSpecular = vec3( 0.0 );\n\t\tfor( int i = 0; i < MAX_DIR_LIGHTS; i++ ) {\n\t\t\tvec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\n\t\t\tvec3 dirVector = normalize( lDirection.xyz );\n\t\t\t#ifdef WRAP_AROUND\n\t\t\t\tfloat directionalLightWeightingFull = max( dot( normal, dirVector ), 0.0 );\n\t\t\t\tfloat directionalLightWeightingHalf = max( 0.5 * dot( normal, dirVector ) + 0.5, 0.0 );\n\t\t\t\tvec3 dirDiffuseWeight = mix( vec3( directionalLightWeightingFull ), vec3( directionalLightWeightingHalf ), wrapRGB );\n\t\t\t#else\n\t\t\t\tfloat dirDiffuseWeight = max( dot( normal, dirVector ), 0.0 );\n\t\t\t#endif\n\t\t\tdirDiffuse += directionalLightColor[ i ] * diffuse * dirDiffuseWeight;\n\t\t\tvec3 dirHalfVector = normalize( dirVector + viewPosition );\n\t\t\tfloat dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\n\t\t\tfloat dirSpecularWeight = specularTex.r * max( pow( dirDotNormalHalf, shininess ), 0.0 );\n\t\t\tfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\n\t\t\tvec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( dirVector, dirHalfVector ), 5.0 );\n\t\t\tdirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\n\t\t}\n\t#endif\n\t#if MAX_HEMI_LIGHTS > 0\n\t\tvec3 hemiDiffuse  = vec3( 0.0 );\n\t\tvec3 hemiSpecular = vec3( 0.0 );\n\t\tfor( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\t\t\tvec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\n\t\t\tvec3 lVector = normalize( lDirection.xyz );\n\t\t\tfloat dotProduct = dot( normal, lVector );\n\t\t\tfloat hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n\t\t\tvec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\t\t\themiDiffuse += diffuse * hemiColor;\n\t\t\tvec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\n\t\t\tfloat hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\n\t\t\tfloat hemiSpecularWeightSky = specularTex.r * max( pow( hemiDotNormalHalfSky, shininess ), 0.0 );\n\t\t\tvec3 lVectorGround = -lVector;\n\t\t\tvec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\n\t\t\tfloat hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\n\t\t\tfloat hemiSpecularWeightGround = specularTex.r * max( pow( hemiDotNormalHalfGround, shininess ), 0.0 );\n\t\t\tfloat dotProductGround = dot( normal, lVectorGround );\n\t\t\tfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\n\t\t\tvec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, hemiHalfVectorSky ), 5.0 );\n\t\t\tvec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 5.0 );\n\t\t\themiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\n\t\t}\n\t#endif\n\tvec3 totalDiffuse = vec3( 0.0 );\n\tvec3 totalSpecular = vec3( 0.0 );\n\t#if MAX_DIR_LIGHTS > 0\n\t\ttotalDiffuse += dirDiffuse;\n\t\ttotalSpecular += dirSpecular;\n\t#endif\n\t#if MAX_HEMI_LIGHTS > 0\n\t\ttotalDiffuse += hemiDiffuse;\n\t\ttotalSpecular += hemiSpecular;\n\t#endif\n\t#if MAX_POINT_LIGHTS > 0\n\t\ttotalDiffuse += pointDiffuse;\n\t\ttotalSpecular += pointSpecular;\n\t#endif\n\t#if MAX_SPOT_LIGHTS > 0\n\t\ttotalDiffuse += spotDiffuse;\n\t\ttotalSpecular += spotSpecular;\n\t#endif\n\t#ifdef METAL\n\t\tgl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * ambient + totalSpecular );\n\t#else\n\t\tgl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * ambient ) + totalSpecular;\n\t#endif\n\tif ( enableReflection ) {\n\t\tvec3 vReflect;\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tif ( useRefract ) {\n\t\t\tvReflect = refract( cameraToVertex, normal, refractionRatio );\n\t\t} else {\n\t\t\tvReflect = reflect( cameraToVertex, normal );\n\t\t}\n\t\tvec4 cubeColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );\n\t\t#ifdef GAMMA_INPUT\n\t\t\tcubeColor.xyz *= cubeColor.xyz;\n\t\t#endif\n\t\tgl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularTex.r * reflectivity );\n\t}',
      THREE.ShaderChunk.shadowmap_fragment,
      THREE.ShaderChunk.linear_to_gamma_fragment,
      THREE.ShaderChunk.fog_fragment,
      '}'
    ].join('\n'),
    vertexShader: [
      'attribute vec4 tangent;\nuniform vec2 uOffset;\nuniform vec2 uRepeat;\nuniform bool enableDisplacement;\n#ifdef VERTEX_TEXTURES\n\tuniform sampler2D tDisplacement;\n\tuniform float uDisplacementScale;\n\tuniform float uDisplacementBias;\n#endif\nvarying vec3 vTangent;\nvarying vec3 vBinormal;\nvarying vec3 vNormal;\nvarying vec2 vUv;\nvarying vec3 vWorldPosition;\nvarying vec3 vViewPosition;',
      THREE.ShaderChunk.skinning_pars_vertex,
      THREE.ShaderChunk.shadowmap_pars_vertex,
      THREE.ShaderChunk.logdepthbuf_pars_vertex,
      'void main() {',
      THREE.ShaderChunk.skinbase_vertex,
      THREE.ShaderChunk.skinnormal_vertex,
      '\t#ifdef USE_SKINNING\n\t\tvNormal = normalize( normalMatrix * skinnedNormal.xyz );\n\t\tvec4 skinnedTangent = skinMatrix * vec4( tangent.xyz, 0.0 );\n\t\tvTangent = normalize( normalMatrix * skinnedTangent.xyz );\n\t#else\n\t\tvNormal = normalize( normalMatrix * normal );\n\t\tvTangent = normalize( normalMatrix * tangent.xyz );\n\t#endif\n\tvBinormal = normalize( cross( vNormal, vTangent ) * tangent.w );\n\tvUv = uv * uRepeat + uOffset;\n\tvec3 displacedPosition;\n\t#ifdef VERTEX_TEXTURES\n\t\tif ( enableDisplacement ) {\n\t\t\tvec3 dv = texture2D( tDisplacement, uv ).xyz;\n\t\t\tfloat df = uDisplacementScale * dv.x + uDisplacementBias;\n\t\t\tdisplacedPosition = position + normalize( normal ) * df;\n\t\t} else {\n\t\t\t#ifdef USE_SKINNING\n\t\t\t\tvec4 skinVertex = vec4( position, 1.0 );\n\t\t\t\tvec4 skinned  = boneMatX * skinVertex * skinWeight.x;\n\t\t\t\tskinned \t  += boneMatY * skinVertex * skinWeight.y;\n\t\t\t\tskinned \t  += boneMatZ * skinVertex * skinWeight.z;\n\t\t\t\tskinned \t  += boneMatW * skinVertex * skinWeight.w;\n\t\t\t\tdisplacedPosition  = skinned.xyz;\n\t\t\t#else\n\t\t\t\tdisplacedPosition = position;\n\t\t\t#endif\n\t\t}\n\t#else\n\t\t#ifdef USE_SKINNING\n\t\t\tvec4 skinVertex = vec4( position, 1.0 );\n\t\t\tvec4 skinned  = boneMatX * skinVertex * skinWeight.x;\n\t\t\tskinned \t  += boneMatY * skinVertex * skinWeight.y;\n\t\t\tskinned \t  += boneMatZ * skinVertex * skinWeight.z;\n\t\t\tskinned \t  += boneMatW * skinVertex * skinWeight.w;\n\t\t\tdisplacedPosition  = skinned.xyz;\n\t\t#else\n\t\t\tdisplacedPosition = position;\n\t\t#endif\n\t#endif\n\tvec4 mvPosition = modelViewMatrix * vec4( displacedPosition, 1.0 );\n\tvec4 worldPosition = modelMatrix * vec4( displacedPosition, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;',
      THREE.ShaderChunk.logdepthbuf_vertex,
      '\tvWorldPosition = worldPosition.xyz;\n\tvViewPosition = -mvPosition.xyz;\n\t#ifdef USE_SHADOWMAP\n\t\tfor( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\t\t\tvShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\n\t\t}\n\t#endif\n}'
    ].join('\n')
  },
  cube: {
    uniforms: {
      tCube: {
        type: 't',
        value: null
      },
      tFlip: {
        type: 'f',
        value: -1
      }
    },
    vertexShader: [
      'varying vec3 vWorldPosition;',
      THREE.ShaderChunk.logdepthbuf_pars_vertex,
      'void main() {\n\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n\tvWorldPosition = worldPosition.xyz;\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',
      THREE.ShaderChunk.logdepthbuf_vertex,
      '}'
    ].join('\n'),
    fragmentShader: [
      'uniform samplerCube tCube;\nuniform float tFlip;\nvarying vec3 vWorldPosition;',
      THREE.ShaderChunk.logdepthbuf_pars_fragment,
      'void main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );',
      THREE.ShaderChunk.logdepthbuf_fragment,
      '}'
    ].join('\n')
  },
  depthRGBA: {
    uniforms: {},
    vertexShader: [
      THREE.ShaderChunk.morphtarget_pars_vertex,
      THREE.ShaderChunk.skinning_pars_vertex,
      THREE.ShaderChunk.logdepthbuf_pars_vertex,
      'void main() {',
      THREE.ShaderChunk.skinbase_vertex,
      THREE.ShaderChunk.morphtarget_vertex,
      THREE.ShaderChunk.skinning_vertex,
      THREE.ShaderChunk.default_vertex,
      THREE.ShaderChunk.logdepthbuf_vertex,
      '}'
    ].join('\n'),
    fragmentShader: [
      THREE.ShaderChunk.logdepthbuf_pars_fragment,
      'vec4 pack_depth( const in float depth ) {\n\tconst vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\n\tconst vec4 bit_mask  = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\n\tvec4 res = mod( depth * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );\n\tres -= res.xxyz * bit_mask;\n\treturn res;\n}\nvoid main() {',
      THREE.ShaderChunk.logdepthbuf_fragment,
      '\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tgl_FragData[ 0 ] = pack_depth( gl_FragDepthEXT );\n\t#else\n\t\tgl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );\n\t#endif\n}'
    ].join('\n')
  }
};
THREE.WebGLRenderer = function (a) {
  function b(a, b) {
    var c = a.vertices.length, d = b.material;
    if (d.attributes) {
      void 0 === a.__webglCustomAttributesList && (a.__webglCustomAttributesList = []);
      for (var e in d.attributes) {
        var f = d.attributes[e];
        if (!f.__webglInitialized || f.createUniqueBuffers) {
          f.__webglInitialized = !0;
          var g = 1;
          'v2' === f.type ? g = 2 : 'v3' === f.type ? g = 3 : 'v4' === f.type ? g = 4 : 'c' === f.type && (g = 3);
          f.size = g;
          f.array = new Float32Array(c * g);
          f.buffer = m.createBuffer();
          f.buffer.belongsToAttribute = e;
          f.needsUpdate = !0;
        }
        a.__webglCustomAttributesList.push(f);
      }
    }
  }
  function c(a, b) {
    var c = b.geometry, g = a.faces3, h = 3 * g.length, k = 1 * g.length, l = 3 * g.length, g = d(b, a), n = f(g), p = e(g), q = g.vertexColors ? g.vertexColors : !1;
    a.__vertexArray = new Float32Array(3 * h);
    p && (a.__normalArray = new Float32Array(3 * h));
    c.hasTangents && (a.__tangentArray = new Float32Array(4 * h));
    q && (a.__colorArray = new Float32Array(3 * h));
    n && (0 < c.faceVertexUvs.length && (a.__uvArray = new Float32Array(2 * h)), 1 < c.faceVertexUvs.length && (a.__uv2Array = new Float32Array(2 * h)));
    b.geometry.skinWeights.length && b.geometry.skinIndices.length && (a.__skinIndexArray = new Float32Array(4 * h), a.__skinWeightArray = new Float32Array(4 * h));
    c = null !== pb && 21845 < k ? Uint32Array : Uint16Array;
    a.__typeArray = c;
    a.__faceArray = new c(3 * k);
    a.__lineArray = new c(2 * l);
    if (a.numMorphTargets)
      for (a.__morphTargetsArrays = [], c = 0, n = a.numMorphTargets; c < n; c++)
        a.__morphTargetsArrays.push(new Float32Array(3 * h));
    if (a.numMorphNormals)
      for (a.__morphNormalsArrays = [], c = 0, n = a.numMorphNormals; c < n; c++)
        a.__morphNormalsArrays.push(new Float32Array(3 * h));
    a.__webglFaceCount = 3 * k;
    a.__webglLineCount = 2 * l;
    if (g.attributes) {
      void 0 === a.__webglCustomAttributesList && (a.__webglCustomAttributesList = []);
      for (var r in g.attributes) {
        var k = g.attributes[r], l = {}, s;
        for (s in k)
          l[s] = k[s];
        if (!l.__webglInitialized || l.createUniqueBuffers)
          l.__webglInitialized = !0, c = 1, 'v2' === l.type ? c = 2 : 'v3' === l.type ? c = 3 : 'v4' === l.type ? c = 4 : 'c' === l.type && (c = 3), l.size = c, l.array = new Float32Array(h * c), l.buffer = m.createBuffer(), l.buffer.belongsToAttribute = r, k.needsUpdate = !0, l.__original = k;
        a.__webglCustomAttributesList.push(l);
      }
    }
    a.__inittedArrays = !0;
  }
  function d(a, b) {
    return a.material instanceof THREE.MeshFaceMaterial ? a.material.materials[b.materialIndex] : a.material;
  }
  function e(a) {
    return a instanceof THREE.MeshBasicMaterial && !a.envMap || a instanceof THREE.MeshDepthMaterial ? !1 : a && void 0 !== a.shading && a.shading === THREE.SmoothShading ? THREE.SmoothShading : THREE.FlatShading;
  }
  function f(a) {
    return a.map || a.lightMap || a.bumpMap || a.normalMap || a.specularMap || a instanceof THREE.ShaderMaterial ? !0 : !1;
  }
  function g(a, b, c, d) {
    for (var e in b) {
      var f = b[e], g = c[e];
      if (0 <= f)
        if (g) {
          var h = g.itemSize;
          m.bindBuffer(m.ARRAY_BUFFER, g.buffer);
          k(f);
          m.vertexAttribPointer(f, h, m.FLOAT, !1, 0, d * h * 4);
        } else
          a.defaultAttributeValues && (2 === a.defaultAttributeValues[e].length ? m.vertexAttrib2fv(f, a.defaultAttributeValues[e]) : 3 === a.defaultAttributeValues[e].length && m.vertexAttrib3fv(f, a.defaultAttributeValues[e]));
    }
    l();
  }
  function h() {
    for (var a = 0, b = Ka.length; a < b; a++)
      Ka[a] = 0;
  }
  function k(a) {
    Ka[a] = 1;
    0 === ob[a] && (m.enableVertexAttribArray(a), ob[a] = 1);
  }
  function l() {
    for (var a = 0, b = ob.length; a < b; a++)
      ob[a] !== Ka[a] && (m.disableVertexAttribArray(a), ob[a] = 0);
  }
  function n(a, b) {
    return a.z !== b.z ? b.z - a.z : a.id - b.id;
  }
  function q(a, b) {
    return b[0] - a[0];
  }
  function p(a, b, c) {
    if (a.length)
      for (var d = 0, e = a.length; d < e; d++)
        Ia = wa = null, fa = za = ha = Ga = ma = ia = Oa = -1, cb = !0, a[d].render(b, c, ja, ra), Ia = wa = null, fa = za = ha = Ga = ma = ia = Oa = -1, cb = !0;
  }
  function s(a, b, c, d, e, f, g, h) {
    var k, m, l, n;
    b ? (m = a.length - 1, n = b = -1) : (m = 0, b = a.length, n = 1);
    for (var p = m; p !== b; p += n)
      if (k = a[p], k.render) {
        m = k.object;
        l = k.buffer;
        if (h)
          k = h;
        else {
          k = k[c];
          if (!k)
            continue;
          g && P.setBlending(k.blending, k.blendEquation, k.blendSrc, k.blendDst);
          P.setDepthTest(k.depthTest);
          P.setDepthWrite(k.depthWrite);
          G(k.polygonOffset, k.polygonOffsetFactor, k.polygonOffsetUnits);
        }
        P.setMaterialFaces(k);
        l instanceof THREE.BufferGeometry ? P.renderBufferDirect(d, e, f, k, l, m) : P.renderBuffer(d, e, f, k, l, m);
      }
  }
  function t(a, b, c, d, e, f, g) {
    for (var h, k, m = 0, l = a.length; m < l; m++)
      if (h = a[m], k = h.object, k.visible) {
        if (g)
          h = g;
        else {
          h = h[b];
          if (!h)
            continue;
          f && P.setBlending(h.blending, h.blendEquation, h.blendSrc, h.blendDst);
          P.setDepthTest(h.depthTest);
          P.setDepthWrite(h.depthWrite);
          G(h.polygonOffset, h.polygonOffsetFactor, h.polygonOffsetUnits);
        }
        P.renderImmediateObject(c, d, e, h, k);
      }
  }
  function r(a, d) {
    var e, f, g;
    if (void 0 === a.__webglInit && (a.__webglInit = !0, a._modelViewMatrix = new THREE.Matrix4(), a._normalMatrix = new THREE.Matrix3(), f = a.geometry, void 0 !== f && void 0 === f.__webglInit))
      if (f.__webglInit = !0, f.addEventListener('dispose', Eb), f instanceof THREE.BufferGeometry)
        for (g in f.attributes) {
          var h = 'index' === g ? m.ELEMENT_ARRAY_BUFFER : m.ARRAY_BUFFER, k = f.attributes[g];
          k.buffer = m.createBuffer();
          m.bindBuffer(h, k.buffer);
          m.bufferData(h, k.array, m.STATIC_DRAW);
        }
      else if (a instanceof THREE.Mesh)
        for (e in g = a.material, void 0 === f.geometryGroups && f.makeGroups(g instanceof THREE.MeshFaceMaterial, pb ? 4294967296 : 65535), f.geometryGroups) {
          if (g = f.geometryGroups[e], !g.__webglVertexBuffer) {
            h = g;
            h.__webglVertexBuffer = m.createBuffer();
            h.__webglNormalBuffer = m.createBuffer();
            h.__webglTangentBuffer = m.createBuffer();
            h.__webglColorBuffer = m.createBuffer();
            h.__webglUVBuffer = m.createBuffer();
            h.__webglUV2Buffer = m.createBuffer();
            h.__webglSkinIndicesBuffer = m.createBuffer();
            h.__webglSkinWeightsBuffer = m.createBuffer();
            h.__webglFaceBuffer = m.createBuffer();
            h.__webglLineBuffer = m.createBuffer();
            var l = k = void 0;
            if (h.numMorphTargets)
              for (h.__webglMorphTargetsBuffers = [], k = 0, l = h.numMorphTargets; k < l; k++)
                h.__webglMorphTargetsBuffers.push(m.createBuffer());
            if (h.numMorphNormals)
              for (h.__webglMorphNormalsBuffers = [], k = 0, l = h.numMorphNormals; k < l; k++)
                h.__webglMorphNormalsBuffers.push(m.createBuffer());
            P.info.memory.geometries++;
            c(g, a);
            f.verticesNeedUpdate = !0;
            f.morphTargetsNeedUpdate = !0;
            f.elementsNeedUpdate = !0;
            f.uvsNeedUpdate = !0;
            f.normalsNeedUpdate = !0;
            f.tangentsNeedUpdate = !0;
            f.colorsNeedUpdate = !0;
          }
        }
      else
        a instanceof THREE.Line ? f.__webglVertexBuffer || (g = f, g.__webglVertexBuffer = m.createBuffer(), g.__webglColorBuffer = m.createBuffer(), g.__webglLineDistanceBuffer = m.createBuffer(), P.info.memory.geometries++, g = f, h = g.vertices.length, g.__vertexArray = new Float32Array(3 * h), g.__colorArray = new Float32Array(3 * h), g.__lineDistanceArray = new Float32Array(1 * h), g.__webglLineCount = h, b(g, a), f.verticesNeedUpdate = !0, f.colorsNeedUpdate = !0, f.lineDistancesNeedUpdate = !0) : a instanceof THREE.ParticleSystem && !f.__webglVertexBuffer && (g = f, g.__webglVertexBuffer = m.createBuffer(), g.__webglColorBuffer = m.createBuffer(), P.info.memory.geometries++, g = f, h = g.vertices.length, g.__vertexArray = new Float32Array(3 * h), g.__colorArray = new Float32Array(3 * h), g.__sortArray = [], g.__webglParticleCount = h, b(g, a), f.verticesNeedUpdate = !0, f.colorsNeedUpdate = !0);
    if (void 0 === a.__webglActive) {
      if (a instanceof THREE.Mesh)
        if (f = a.geometry, f instanceof THREE.BufferGeometry)
          v(d.__webglObjects, f, a);
        else {
          if (f instanceof THREE.Geometry)
            for (e in f.geometryGroups)
              g = f.geometryGroups[e], v(d.__webglObjects, g, a);
        }
      else
        a instanceof THREE.Line || a instanceof THREE.ParticleSystem ? (f = a.geometry, v(d.__webglObjects, f, a)) : a instanceof THREE.ImmediateRenderObject || a.immediateRenderCallback ? d.__webglObjectsImmediate.push({
          id: null,
          object: a,
          opaque: null,
          transparent: null,
          z: 0
        }) : a instanceof THREE.Sprite ? d.__webglSprites.push(a) : a instanceof THREE.LensFlare && d.__webglFlares.push(a);
      a.__webglActive = !0;
    }
  }
  function v(a, b, c) {
    a.push({
      id: null,
      buffer: b,
      object: c,
      opaque: null,
      transparent: null,
      z: 0
    });
  }
  function w(a) {
    for (var b in a.attributes)
      if (a.attributes[b].needsUpdate)
        return !0;
    return !1;
  }
  function u(a) {
    for (var b in a.attributes)
      a.attributes[b].needsUpdate = !1;
  }
  function y(a, b) {
    a instanceof THREE.Mesh || a instanceof THREE.ParticleSystem || a instanceof THREE.Line ? L(b.__webglObjects, a) : a instanceof THREE.Sprite ? x(b.__webglSprites, a) : a instanceof THREE.LensFlare ? x(b.__webglFlares, a) : (a instanceof THREE.ImmediateRenderObject || a.immediateRenderCallback) && L(b.__webglObjectsImmediate, a);
    delete a.__webglActive;
  }
  function L(a, b) {
    for (var c = a.length - 1; 0 <= c; c--)
      a[c].object === b && a.splice(c, 1);
  }
  function x(a, b) {
    for (var c = a.length - 1; 0 <= c; c--)
      a[c] === b && a.splice(c, 1);
  }
  function N(a, b, c, d, e) {
    Ea = 0;
    d.needsUpdate && (d.program && Fb(d), P.initMaterial(d, b, c, e), d.needsUpdate = !1);
    d.morphTargets && !e.__webglMorphTargetInfluences && (e.__webglMorphTargetInfluences = new Float32Array(P.maxMorphTargets));
    var f = !1, g = d.program, h = g.uniforms, k = d.uniforms;
    g.id !== wa && (m.useProgram(g.program), wa = g.id, f = !0);
    d.id !== fa && (fa = d.id, f = !0);
    if (f || a !== Ia)
      m.uniformMatrix4fv(h.projectionMatrix, !1, a.projectionMatrix.elements), da && m.uniform1f(h.logDepthBufFC, 2 / (Math.log(a.far + 1) / Math.LN2)), a !== Ia && (Ia = a);
    if (d.skinning)
      if (Gb && e.skeleton.useVertexTexture) {
        if (null !== h.boneTexture) {
          var l = J();
          m.uniform1i(h.boneTexture, l);
          P.setTexture(e.skeleton.boneTexture, l);
        }
        null !== h.boneTextureWidth && m.uniform1i(h.boneTextureWidth, e.skeleton.boneTextureWidth);
        null !== h.boneTextureHeight && m.uniform1i(h.boneTextureHeight, e.skeleton.boneTextureHeight);
      } else
        null !== h.boneGlobalMatrices && m.uniformMatrix4fv(h.boneGlobalMatrices, !1, e.skeleton.boneMatrices);
    if (f) {
      c && d.fog && (k.fogColor.value = c.color, c instanceof THREE.Fog ? (k.fogNear.value = c.near, k.fogFar.value = c.far) : c instanceof THREE.FogExp2 && (k.fogDensity.value = c.density));
      if (d instanceof THREE.MeshPhongMaterial || d instanceof THREE.MeshLambertMaterial || d.lights) {
        if (cb) {
          var n, p = l = 0, q = 0, r, s, t, u = Bb, w = u.directional.colors, v = u.directional.positions, y = u.point.colors, A = u.point.positions, L = u.point.distances, x = u.spot.colors, G = u.spot.positions, C = u.spot.distances, E = u.spot.directions, N = u.spot.anglesCos, F = u.spot.exponents, Q = u.hemi.skyColors, I = u.hemi.groundColors, U = u.hemi.positions, Y = 0, ga = 0, R = 0, X = 0, $ = 0, aa = 0, ba = 0, Z = 0, W = n = 0;
          c = t = W = 0;
          for (f = b.length; c < f; c++)
            if (n = b[c], !n.onlyShadow)
              if (r = n.color, s = n.intensity, t = n.distance, n instanceof THREE.AmbientLight)
                n.visible && (P.gammaInput ? (l += r.r * r.r, p += r.g * r.g, q += r.b * r.b) : (l += r.r, p += r.g, q += r.b));
              else if (n instanceof THREE.DirectionalLight) {
                if ($ += 1, n.visible && (oa.setFromMatrixPosition(n.matrixWorld), xa.setFromMatrixPosition(n.target.matrixWorld), oa.sub(xa), oa.normalize(), 0 !== oa.x || 0 !== oa.y || 0 !== oa.z))
                  n = 3 * Y, v[n] = oa.x, v[n + 1] = oa.y, v[n + 2] = oa.z, P.gammaInput ? B(w, n, r, s * s) : K(w, n, r, s), Y += 1;
              } else
                n instanceof THREE.PointLight ? (aa += 1, n.visible && (W = 3 * ga, P.gammaInput ? B(y, W, r, s * s) : K(y, W, r, s), xa.setFromMatrixPosition(n.matrixWorld), A[W] = xa.x, A[W + 1] = xa.y, A[W + 2] = xa.z, L[ga] = t, ga += 1)) : n instanceof THREE.SpotLight ? (ba += 1, n.visible && (W = 3 * R, P.gammaInput ? B(x, W, r, s * s) : K(x, W, r, s), xa.setFromMatrixPosition(n.matrixWorld), G[W] = xa.x, G[W + 1] = xa.y, G[W + 2] = xa.z, C[R] = t, oa.copy(xa), xa.setFromMatrixPosition(n.target.matrixWorld), oa.sub(xa), oa.normalize(), E[W] = oa.x, E[W + 1] = oa.y, E[W + 2] = oa.z, N[R] = Math.cos(n.angle), F[R] = n.exponent, R += 1)) : n instanceof THREE.HemisphereLight && (Z += 1, n.visible && (oa.setFromMatrixPosition(n.matrixWorld), oa.normalize(), 0 !== oa.x || 0 !== oa.y || 0 !== oa.z)) && (t = 3 * X, U[t] = oa.x, U[t + 1] = oa.y, U[t + 2] = oa.z, r = n.color, n = n.groundColor, P.gammaInput ? (s *= s, B(Q, t, r, s), B(I, t, n, s)) : (K(Q, t, r, s), K(I, t, n, s)), X += 1);
          c = 3 * Y;
          for (f = Math.max(w.length, 3 * $); c < f; c++)
            w[c] = 0;
          c = 3 * ga;
          for (f = Math.max(y.length, 3 * aa); c < f; c++)
            y[c] = 0;
          c = 3 * R;
          for (f = Math.max(x.length, 3 * ba); c < f; c++)
            x[c] = 0;
          c = 3 * X;
          for (f = Math.max(Q.length, 3 * Z); c < f; c++)
            Q[c] = 0;
          c = 3 * X;
          for (f = Math.max(I.length, 3 * Z); c < f; c++)
            I[c] = 0;
          u.directional.length = Y;
          u.point.length = ga;
          u.spot.length = R;
          u.hemi.length = X;
          u.ambient[0] = l;
          u.ambient[1] = p;
          u.ambient[2] = q;
          cb = !1;
        }
        c = Bb;
        k.ambientLightColor.value = c.ambient;
        k.directionalLightColor.value = c.directional.colors;
        k.directionalLightDirection.value = c.directional.positions;
        k.pointLightColor.value = c.point.colors;
        k.pointLightPosition.value = c.point.positions;
        k.pointLightDistance.value = c.point.distances;
        k.spotLightColor.value = c.spot.colors;
        k.spotLightPosition.value = c.spot.positions;
        k.spotLightDistance.value = c.spot.distances;
        k.spotLightDirection.value = c.spot.directions;
        k.spotLightAngleCos.value = c.spot.anglesCos;
        k.spotLightExponent.value = c.spot.exponents;
        k.hemisphereLightSkyColor.value = c.hemi.skyColors;
        k.hemisphereLightGroundColor.value = c.hemi.groundColors;
        k.hemisphereLightDirection.value = c.hemi.positions;
      }
      if (d instanceof THREE.MeshBasicMaterial || d instanceof THREE.MeshLambertMaterial || d instanceof THREE.MeshPhongMaterial) {
        k.opacity.value = d.opacity;
        P.gammaInput ? k.diffuse.value.copyGammaToLinear(d.color) : k.diffuse.value = d.color;
        k.map.value = d.map;
        k.lightMap.value = d.lightMap;
        k.specularMap.value = d.specularMap;
        d.bumpMap && (k.bumpMap.value = d.bumpMap, k.bumpScale.value = d.bumpScale);
        d.normalMap && (k.normalMap.value = d.normalMap, k.normalScale.value.copy(d.normalScale));
        var V;
        d.map ? V = d.map : d.specularMap ? V = d.specularMap : d.normalMap ? V = d.normalMap : d.bumpMap && (V = d.bumpMap);
        void 0 !== V && (c = V.offset, V = V.repeat, k.offsetRepeat.value.set(c.x, c.y, V.x, V.y));
        k.envMap.value = d.envMap;
        k.flipEnvMap.value = d.envMap instanceof THREE.WebGLRenderTargetCube ? 1 : -1;
        k.reflectivity.value = d.reflectivity;
        k.refractionRatio.value = d.refractionRatio;
        k.combine.value = d.combine;
        k.useRefract.value = d.envMap && d.envMap.mapping instanceof THREE.CubeRefractionMapping;
      }
      d instanceof THREE.LineBasicMaterial ? (k.diffuse.value = d.color, k.opacity.value = d.opacity) : d instanceof THREE.LineDashedMaterial ? (k.diffuse.value = d.color, k.opacity.value = d.opacity, k.dashSize.value = d.dashSize, k.totalSize.value = d.dashSize + d.gapSize, k.scale.value = d.scale) : d instanceof THREE.ParticleSystemMaterial ? (k.psColor.value = d.color, k.opacity.value = d.opacity, k.size.value = d.size, k.scale.value = H.height / 2, k.map.value = d.map) : d instanceof THREE.MeshPhongMaterial ? (k.shininess.value = d.shininess, P.gammaInput ? (k.ambient.value.copyGammaToLinear(d.ambient), k.emissive.value.copyGammaToLinear(d.emissive), k.specular.value.copyGammaToLinear(d.specular)) : (k.ambient.value = d.ambient, k.emissive.value = d.emissive, k.specular.value = d.specular), d.wrapAround && k.wrapRGB.value.copy(d.wrapRGB)) : d instanceof THREE.MeshLambertMaterial ? (P.gammaInput ? (k.ambient.value.copyGammaToLinear(d.ambient), k.emissive.value.copyGammaToLinear(d.emissive)) : (k.ambient.value = d.ambient, k.emissive.value = d.emissive), d.wrapAround && k.wrapRGB.value.copy(d.wrapRGB)) : d instanceof THREE.MeshDepthMaterial ? (k.mNear.value = a.near, k.mFar.value = a.far, k.opacity.value = d.opacity) : d instanceof THREE.MeshNormalMaterial && (k.opacity.value = d.opacity);
      if (e.receiveShadow && !d._shadowPass && k.shadowMatrix)
        for (c = V = 0, f = b.length; c < f; c++)
          l = b[c], l.castShadow && (l instanceof THREE.SpotLight || l instanceof THREE.DirectionalLight && !l.shadowCascade) && (k.shadowMap.value[V] = l.shadowMap, k.shadowMapSize.value[V] = l.shadowMapSize, k.shadowMatrix.value[V] = l.shadowMatrix, k.shadowDarkness.value[V] = l.shadowDarkness, k.shadowBias.value[V] = l.shadowBias, V++);
      b = d.uniformsList;
      k = 0;
      for (V = b.length; k < V; k++)
        if (f = g.uniforms[b[k][1]])
          if (c = b[k][0], p = c.type, l = c.value, 'i' === p)
            m.uniform1i(f, l);
          else if ('f' === p)
            m.uniform1f(f, l);
          else if ('v2' === p)
            m.uniform2f(f, l.x, l.y);
          else if ('v3' === p)
            m.uniform3f(f, l.x, l.y, l.z);
          else if ('v4' === p)
            m.uniform4f(f, l.x, l.y, l.z, l.w);
          else if ('c' === p)
            m.uniform3f(f, l.r, l.g, l.b);
          else if ('iv1' === p)
            m.uniform1iv(f, l);
          else if ('iv' === p)
            m.uniform3iv(f, l);
          else if ('fv1' === p)
            m.uniform1fv(f, l);
          else if ('fv' === p)
            m.uniform3fv(f, l);
          else if ('v2v' === p) {
            void 0 === c._array && (c._array = new Float32Array(2 * l.length));
            p = 0;
            for (q = l.length; p < q; p++)
              u = 2 * p, c._array[u] = l[p].x, c._array[u + 1] = l[p].y;
            m.uniform2fv(f, c._array);
          } else if ('v3v' === p) {
            void 0 === c._array && (c._array = new Float32Array(3 * l.length));
            p = 0;
            for (q = l.length; p < q; p++)
              u = 3 * p, c._array[u] = l[p].x, c._array[u + 1] = l[p].y, c._array[u + 2] = l[p].z;
            m.uniform3fv(f, c._array);
          } else if ('v4v' === p) {
            void 0 === c._array && (c._array = new Float32Array(4 * l.length));
            p = 0;
            for (q = l.length; p < q; p++)
              u = 4 * p, c._array[u] = l[p].x, c._array[u + 1] = l[p].y, c._array[u + 2] = l[p].z, c._array[u + 3] = l[p].w;
            m.uniform4fv(f, c._array);
          } else if ('m3' === p)
            m.uniformMatrix3fv(f, !1, l.elements);
          else if ('m3v' === p) {
            void 0 === c._array && (c._array = new Float32Array(9 * l.length));
            p = 0;
            for (q = l.length; p < q; p++)
              l[p].flattenToArrayOffset(c._array, 9 * p);
            m.uniformMatrix3fv(f, !1, c._array);
          } else if ('m4' === p)
            m.uniformMatrix4fv(f, !1, l.elements);
          else if ('m4v' === p) {
            void 0 === c._array && (c._array = new Float32Array(16 * l.length));
            p = 0;
            for (q = l.length; p < q; p++)
              l[p].flattenToArrayOffset(c._array, 16 * p);
            m.uniformMatrix4fv(f, !1, c._array);
          } else if ('t' === p) {
            if (u = l, l = J(), m.uniform1i(f, l), u)
              if (u.image instanceof Array && 6 === u.image.length) {
                if (c = u, f = l, 6 === c.image.length)
                  if (c.needsUpdate) {
                    c.image.__webglTextureCube || (c.addEventListener('dispose', Hb), c.image.__webglTextureCube = m.createTexture(), P.info.memory.textures++);
                    m.activeTexture(m.TEXTURE0 + f);
                    m.bindTexture(m.TEXTURE_CUBE_MAP, c.image.__webglTextureCube);
                    m.pixelStorei(m.UNPACK_FLIP_Y_WEBGL, c.flipY);
                    f = c instanceof THREE.CompressedTexture;
                    l = [];
                    for (p = 0; 6 > p; p++)
                      P.autoScaleCubemaps && !f ? (q = l, u = p, w = c.image[p], y = dc, w.width <= y && w.height <= y || (A = Math.max(w.width, w.height), v = Math.floor(w.width * y / A), y = Math.floor(w.height * y / A), A = document.createElement('canvas'), A.width = v, A.height = y, A.getContext('2d').drawImage(w, 0, 0, w.width, w.height, 0, 0, v, y), w = A), q[u] = w) : l[p] = c.image[p];
                    p = l[0];
                    q = THREE.Math.isPowerOfTwo(p.width) && THREE.Math.isPowerOfTwo(p.height);
                    u = z(c.format);
                    w = z(c.type);
                    D(m.TEXTURE_CUBE_MAP, c, q);
                    for (p = 0; 6 > p; p++)
                      if (f)
                        for (y = l[p].mipmaps, A = 0, L = y.length; A < L; A++)
                          v = y[A], c.format !== THREE.RGBAFormat ? m.compressedTexImage2D(m.TEXTURE_CUBE_MAP_POSITIVE_X + p, A, u, v.width, v.height, 0, v.data) : m.texImage2D(m.TEXTURE_CUBE_MAP_POSITIVE_X + p, A, u, v.width, v.height, 0, u, w, v.data);
                      else
                        m.texImage2D(m.TEXTURE_CUBE_MAP_POSITIVE_X + p, 0, u, u, w, l[p]);
                    c.generateMipmaps && q && m.generateMipmap(m.TEXTURE_CUBE_MAP);
                    c.needsUpdate = !1;
                    if (c.onUpdate)
                      c.onUpdate();
                  } else
                    m.activeTexture(m.TEXTURE0 + f), m.bindTexture(m.TEXTURE_CUBE_MAP, c.image.__webglTextureCube);
              } else
                u instanceof THREE.WebGLRenderTargetCube ? (c = u, m.activeTexture(m.TEXTURE0 + l), m.bindTexture(m.TEXTURE_CUBE_MAP, c.__webglTexture)) : P.setTexture(u, l);
          } else if ('tv' === p) {
            void 0 === c._array && (c._array = []);
            p = 0;
            for (q = c.value.length; p < q; p++)
              c._array[p] = J();
            m.uniform1iv(f, c._array);
            p = 0;
            for (q = c.value.length; p < q; p++)
              u = c.value[p], l = c._array[p], u && P.setTexture(u, l);
          } else
            console.warn('THREE.WebGLRenderer: Unknown uniform type: ' + p);
      (d instanceof THREE.ShaderMaterial || d instanceof THREE.MeshPhongMaterial || d.envMap) && null !== h.cameraPosition && (xa.setFromMatrixPosition(a.matrixWorld), m.uniform3f(h.cameraPosition, xa.x, xa.y, xa.z));
      (d instanceof THREE.MeshPhongMaterial || d instanceof THREE.MeshLambertMaterial || d instanceof THREE.ShaderMaterial || d.skinning) && null !== h.viewMatrix && m.uniformMatrix4fv(h.viewMatrix, !1, a.matrixWorldInverse.elements);
    }
    m.uniformMatrix4fv(h.modelViewMatrix, !1, e._modelViewMatrix.elements);
    h.normalMatrix && m.uniformMatrix3fv(h.normalMatrix, !1, e._normalMatrix.elements);
    null !== h.modelMatrix && m.uniformMatrix4fv(h.modelMatrix, !1, e.matrixWorld.elements);
    return g;
  }
  function J() {
    var a = Ea;
    a >= Cb && console.warn('WebGLRenderer: trying to use ' + a + ' texture units while this GPU supports only ' + Cb);
    Ea += 1;
    return a;
  }
  function B(a, b, c, d) {
    a[b] = c.r * c.r * d;
    a[b + 1] = c.g * c.g * d;
    a[b + 2] = c.b * c.b * d;
  }
  function K(a, b, c, d) {
    a[b] = c.r * d;
    a[b + 1] = c.g * d;
    a[b + 2] = c.b * d;
  }
  function A(a) {
    a !== ua && (m.lineWidth(a), ua = a);
  }
  function G(a, b, c) {
    ya !== a && (a ? m.enable(m.POLYGON_OFFSET_FILL) : m.disable(m.POLYGON_OFFSET_FILL), ya = a);
    !a || Z === b && qa === c || (m.polygonOffset(b, c), Z = b, qa = c);
  }
  function D(a, b, c) {
    c ? (m.texParameteri(a, m.TEXTURE_WRAP_S, z(b.wrapS)), m.texParameteri(a, m.TEXTURE_WRAP_T, z(b.wrapT)), m.texParameteri(a, m.TEXTURE_MAG_FILTER, z(b.magFilter)), m.texParameteri(a, m.TEXTURE_MIN_FILTER, z(b.minFilter))) : (m.texParameteri(a, m.TEXTURE_WRAP_S, m.CLAMP_TO_EDGE), m.texParameteri(a, m.TEXTURE_WRAP_T, m.CLAMP_TO_EDGE), m.texParameteri(a, m.TEXTURE_MAG_FILTER, F(b.magFilter)), m.texParameteri(a, m.TEXTURE_MIN_FILTER, F(b.minFilter)));
    db && b.type !== THREE.FloatType && (1 < b.anisotropy || b.__oldAnisotropy) && (m.texParameterf(a, db.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(b.anisotropy, Ib)), b.__oldAnisotropy = b.anisotropy);
  }
  function C(a, b) {
    m.bindRenderbuffer(m.RENDERBUFFER, a);
    b.depthBuffer && !b.stencilBuffer ? (m.renderbufferStorage(m.RENDERBUFFER, m.DEPTH_COMPONENT16, b.width, b.height), m.framebufferRenderbuffer(m.FRAMEBUFFER, m.DEPTH_ATTACHMENT, m.RENDERBUFFER, a)) : b.depthBuffer && b.stencilBuffer ? (m.renderbufferStorage(m.RENDERBUFFER, m.DEPTH_STENCIL, b.width, b.height), m.framebufferRenderbuffer(m.FRAMEBUFFER, m.DEPTH_STENCIL_ATTACHMENT, m.RENDERBUFFER, a)) : m.renderbufferStorage(m.RENDERBUFFER, m.RGBA4, b.width, b.height);
  }
  function F(a) {
    return a === THREE.NearestFilter || a === THREE.NearestMipMapNearestFilter || a === THREE.NearestMipMapLinearFilter ? m.NEAREST : m.LINEAR;
  }
  function z(a) {
    if (a === THREE.RepeatWrapping)
      return m.REPEAT;
    if (a === THREE.ClampToEdgeWrapping)
      return m.CLAMP_TO_EDGE;
    if (a === THREE.MirroredRepeatWrapping)
      return m.MIRRORED_REPEAT;
    if (a === THREE.NearestFilter)
      return m.NEAREST;
    if (a === THREE.NearestMipMapNearestFilter)
      return m.NEAREST_MIPMAP_NEAREST;
    if (a === THREE.NearestMipMapLinearFilter)
      return m.NEAREST_MIPMAP_LINEAR;
    if (a === THREE.LinearFilter)
      return m.LINEAR;
    if (a === THREE.LinearMipMapNearestFilter)
      return m.LINEAR_MIPMAP_NEAREST;
    if (a === THREE.LinearMipMapLinearFilter)
      return m.LINEAR_MIPMAP_LINEAR;
    if (a === THREE.UnsignedByteType)
      return m.UNSIGNED_BYTE;
    if (a === THREE.UnsignedShort4444Type)
      return m.UNSIGNED_SHORT_4_4_4_4;
    if (a === THREE.UnsignedShort5551Type)
      return m.UNSIGNED_SHORT_5_5_5_1;
    if (a === THREE.UnsignedShort565Type)
      return m.UNSIGNED_SHORT_5_6_5;
    if (a === THREE.ByteType)
      return m.BYTE;
    if (a === THREE.ShortType)
      return m.SHORT;
    if (a === THREE.UnsignedShortType)
      return m.UNSIGNED_SHORT;
    if (a === THREE.IntType)
      return m.INT;
    if (a === THREE.UnsignedIntType)
      return m.UNSIGNED_INT;
    if (a === THREE.FloatType)
      return m.FLOAT;
    if (a === THREE.AlphaFormat)
      return m.ALPHA;
    if (a === THREE.RGBFormat)
      return m.RGB;
    if (a === THREE.RGBAFormat)
      return m.RGBA;
    if (a === THREE.LuminanceFormat)
      return m.LUMINANCE;
    if (a === THREE.LuminanceAlphaFormat)
      return m.LUMINANCE_ALPHA;
    if (a === THREE.AddEquation)
      return m.FUNC_ADD;
    if (a === THREE.SubtractEquation)
      return m.FUNC_SUBTRACT;
    if (a === THREE.ReverseSubtractEquation)
      return m.FUNC_REVERSE_SUBTRACT;
    if (a === THREE.ZeroFactor)
      return m.ZERO;
    if (a === THREE.OneFactor)
      return m.ONE;
    if (a === THREE.SrcColorFactor)
      return m.SRC_COLOR;
    if (a === THREE.OneMinusSrcColorFactor)
      return m.ONE_MINUS_SRC_COLOR;
    if (a === THREE.SrcAlphaFactor)
      return m.SRC_ALPHA;
    if (a === THREE.OneMinusSrcAlphaFactor)
      return m.ONE_MINUS_SRC_ALPHA;
    if (a === THREE.DstAlphaFactor)
      return m.DST_ALPHA;
    if (a === THREE.OneMinusDstAlphaFactor)
      return m.ONE_MINUS_DST_ALPHA;
    if (a === THREE.DstColorFactor)
      return m.DST_COLOR;
    if (a === THREE.OneMinusDstColorFactor)
      return m.ONE_MINUS_DST_COLOR;
    if (a === THREE.SrcAlphaSaturateFactor)
      return m.SRC_ALPHA_SATURATE;
    if (void 0 !== Pa) {
      if (a === THREE.RGB_S3TC_DXT1_Format)
        return Pa.COMPRESSED_RGB_S3TC_DXT1_EXT;
      if (a === THREE.RGBA_S3TC_DXT1_Format)
        return Pa.COMPRESSED_RGBA_S3TC_DXT1_EXT;
      if (a === THREE.RGBA_S3TC_DXT3_Format)
        return Pa.COMPRESSED_RGBA_S3TC_DXT3_EXT;
      if (a === THREE.RGBA_S3TC_DXT5_Format)
        return Pa.COMPRESSED_RGBA_S3TC_DXT5_EXT;
    }
    return 0;
  }
  console.log('THREE.WebGLRenderer', THREE.REVISION);
  a = a || {};
  var H = void 0 !== a.canvas ? a.canvas : document.createElement('canvas'), E = void 0 !== a.context ? a.context : null, Q = void 0 !== a.precision ? a.precision : 'highp', Y = void 0 !== a.alpha ? a.alpha : !1, U = void 0 !== a.depth ? a.depth : !0, la = void 0 !== a.stencil ? a.stencil : !0, W = void 0 !== a.antialias ? a.antialias : !1, R = void 0 !== a.premultipliedAlpha ? a.premultipliedAlpha : !0, I = void 0 !== a.preserveDrawingBuffer ? a.preserveDrawingBuffer : !1, da = void 0 !== a.logarithmicDepthBuffer ? a.logarithmicDepthBuffer : !1, V = new THREE.Color(0), X = 0;
  this.domElement = H;
  this.context = null;
  this.devicePixelRatio = void 0 !== a.devicePixelRatio ? a.devicePixelRatio : void 0 !== self.devicePixelRatio ? self.devicePixelRatio : 1;
  this.autoUpdateObjects = this.sortObjects = this.autoClearStencil = this.autoClearDepth = this.autoClearColor = this.autoClear = !0;
  this.shadowMapEnabled = this.gammaOutput = this.gammaInput = !1;
  this.shadowMapAutoUpdate = !0;
  this.shadowMapType = THREE.PCFShadowMap;
  this.shadowMapCullFace = THREE.CullFaceFront;
  this.shadowMapCascade = this.shadowMapDebug = !1;
  this.maxMorphTargets = 8;
  this.maxMorphNormals = 4;
  this.autoScaleCubemaps = !0;
  this.renderPluginsPre = [];
  this.renderPluginsPost = [];
  this.info = {
    memory: {
      programs: 0,
      geometries: 0,
      textures: 0
    },
    render: {
      calls: 0,
      vertices: 0,
      faces: 0,
      points: 0
    }
  };
  var P = this, ga = [], wa = null, Ha = null, fa = -1, za = null, Ia = null, Ea = 0, Ga = -1, ha = -1, Oa = -1, Ra = -1, Sa = -1, Fa = -1, ia = -1, ma = -1, ya = null, Z = null, qa = null, ua = null, Ca = 0, va = 0, Da = H.width, Ja = H.height, ja = 0, ra = 0, Ka = new Uint8Array(16), ob = new Uint8Array(16), Ab = new THREE.Frustum(), Pb = new THREE.Matrix4(), cc = new THREE.Matrix4(), xa = new THREE.Vector3(), oa = new THREE.Vector3(), cb = !0, Bb = {
      ambient: [
        0,
        0,
        0
      ],
      directional: {
        length: 0,
        colors: [],
        positions: []
      },
      point: {
        length: 0,
        colors: [],
        positions: [],
        distances: []
      },
      spot: {
        length: 0,
        colors: [],
        positions: [],
        distances: [],
        directions: [],
        anglesCos: [],
        exponents: []
      },
      hemi: {
        length: 0,
        skyColors: [],
        groundColors: [],
        positions: []
      }
    }, m, sb, xb, db, Pa, pb;
  (function () {
    try {
      var a = {
          alpha: Y,
          depth: U,
          stencil: la,
          antialias: W,
          premultipliedAlpha: R,
          preserveDrawingBuffer: I
        };
      m = E || H.getContext('webgl', a) || H.getContext('experimental-webgl', a);
      if (null === m)
        throw 'Error creating WebGL context.';
    } catch (b) {
      console.error(b);
    }
    sb = m.getExtension('OES_texture_float');
    m.getExtension('OES_texture_float_linear');
    xb = m.getExtension('OES_standard_derivatives');
    db = m.getExtension('EXT_texture_filter_anisotropic') || m.getExtension('MOZ_EXT_texture_filter_anisotropic') || m.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
    Pa = m.getExtension('WEBGL_compressed_texture_s3tc') || m.getExtension('MOZ_WEBGL_compressed_texture_s3tc') || m.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
    pb = m.getExtension('OES_element_index_uint');
    null === sb && console.log('THREE.WebGLRenderer: Float textures not supported.');
    null === xb && console.log('THREE.WebGLRenderer: Standard derivatives not supported.');
    null === db && console.log('THREE.WebGLRenderer: Anisotropic texture filtering not supported.');
    null === Pa && console.log('THREE.WebGLRenderer: S3TC compressed textures not supported.');
    null === pb && console.log('THREE.WebGLRenderer: elementindex as unsigned integer not supported.');
    void 0 === m.getShaderPrecisionFormat && (m.getShaderPrecisionFormat = function () {
      return {
        rangeMin: 1,
        rangeMax: 1,
        precision: 1
      };
    });
    da && m.getExtension('EXT_frag_depth');
  }());
  m.clearColor(0, 0, 0, 1);
  m.clearDepth(1);
  m.clearStencil(0);
  m.enable(m.DEPTH_TEST);
  m.depthFunc(m.LEQUAL);
  m.frontFace(m.CCW);
  m.cullFace(m.BACK);
  m.enable(m.CULL_FACE);
  m.enable(m.BLEND);
  m.blendEquation(m.FUNC_ADD);
  m.blendFunc(m.SRC_ALPHA, m.ONE_MINUS_SRC_ALPHA);
  m.viewport(Ca, va, Da, Ja);
  m.clearColor(V.r, V.g, V.b, X);
  this.context = m;
  var Cb = m.getParameter(m.MAX_TEXTURE_IMAGE_UNITS), Db = m.getParameter(m.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
  m.getParameter(m.MAX_TEXTURE_SIZE);
  var dc = m.getParameter(m.MAX_CUBE_MAP_TEXTURE_SIZE), Ib = db ? m.getParameter(db.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0, Jb = 0 < Db, Gb = Jb && sb;
  Pa && m.getParameter(m.COMPRESSED_TEXTURE_FORMATS);
  var ec = m.getShaderPrecisionFormat(m.VERTEX_SHADER, m.HIGH_FLOAT), qc = m.getShaderPrecisionFormat(m.VERTEX_SHADER, m.MEDIUM_FLOAT);
  m.getShaderPrecisionFormat(m.VERTEX_SHADER, m.LOW_FLOAT);
  var rc = m.getShaderPrecisionFormat(m.FRAGMENT_SHADER, m.HIGH_FLOAT), sc = m.getShaderPrecisionFormat(m.FRAGMENT_SHADER, m.MEDIUM_FLOAT);
  m.getShaderPrecisionFormat(m.FRAGMENT_SHADER, m.LOW_FLOAT);
  var tc = 0 < ec.precision && 0 < rc.precision, Kb = 0 < qc.precision && 0 < sc.precision;
  'highp' !== Q || tc || (Kb ? (Q = 'mediump', console.warn('WebGLRenderer: highp not supported, using mediump')) : (Q = 'lowp', console.warn('WebGLRenderer: highp and mediump not supported, using lowp')));
  'mediump' !== Q || Kb || (Q = 'lowp', console.warn('WebGLRenderer: mediump not supported, using lowp'));
  this.getContext = function () {
    return m;
  };
  this.supportsVertexTextures = function () {
    return Jb;
  };
  this.supportsFloatTextures = function () {
    return sb;
  };
  this.supportsStandardDerivatives = function () {
    return xb;
  };
  this.supportsCompressedTextureS3TC = function () {
    return Pa;
  };
  this.getMaxAnisotropy = function () {
    return Ib;
  };
  this.getPrecision = function () {
    return Q;
  };
  this.setSize = function (a, b, c) {
    H.width = a * this.devicePixelRatio;
    H.height = b * this.devicePixelRatio;
    !1 !== c && (H.style.width = a + 'px', H.style.height = b + 'px');
    this.setViewport(0, 0, a, b);
  };
  this.setViewport = function (a, b, c, d) {
    Ca = a * this.devicePixelRatio;
    va = b * this.devicePixelRatio;
    Da = c * this.devicePixelRatio;
    Ja = d * this.devicePixelRatio;
    m.viewport(Ca, va, Da, Ja);
  };
  this.setScissor = function (a, b, c, d) {
    m.scissor(a * this.devicePixelRatio, b * this.devicePixelRatio, c * this.devicePixelRatio, d * this.devicePixelRatio);
  };
  this.enableScissorTest = function (a) {
    a ? m.enable(m.SCISSOR_TEST) : m.disable(m.SCISSOR_TEST);
  };
  this.setClearColor = function (a, b) {
    V.set(a);
    X = void 0 !== b ? b : 1;
    m.clearColor(V.r, V.g, V.b, X);
  };
  this.setClearColorHex = function (a, b) {
    console.warn('DEPRECATED: .setClearColorHex() is being removed. Use .setClearColor() instead.');
    this.setClearColor(a, b);
  };
  this.getClearColor = function () {
    return V;
  };
  this.getClearAlpha = function () {
    return X;
  };
  this.clear = function (a, b, c) {
    var d = 0;
    if (void 0 === a || a)
      d |= m.COLOR_BUFFER_BIT;
    if (void 0 === b || b)
      d |= m.DEPTH_BUFFER_BIT;
    if (void 0 === c || c)
      d |= m.STENCIL_BUFFER_BIT;
    m.clear(d);
  };
  this.clearColor = function () {
    m.clear(m.COLOR_BUFFER_BIT);
  };
  this.clearDepth = function () {
    m.clear(m.DEPTH_BUFFER_BIT);
  };
  this.clearStencil = function () {
    m.clear(m.STENCIL_BUFFER_BIT);
  };
  this.clearTarget = function (a, b, c, d) {
    this.setRenderTarget(a);
    this.clear(b, c, d);
  };
  this.addPostPlugin = function (a) {
    a.init(this);
    this.renderPluginsPost.push(a);
  };
  this.addPrePlugin = function (a) {
    a.init(this);
    this.renderPluginsPre.push(a);
  };
  this.updateShadowMap = function (a, b) {
    wa = null;
    fa = za = ma = ia = Oa = -1;
    cb = !0;
    ha = Ga = -1;
    this.shadowMapPlugin.update(a, b);
  };
  var Eb = function (a) {
      a = a.target;
      a.removeEventListener('dispose', Eb);
      a.__webglInit = void 0;
      if (a instanceof THREE.BufferGeometry) {
        var b = a.attributes, c;
        for (c in b)
          void 0 !== b[c].buffer && m.deleteBuffer(b[c].buffer);
        P.info.memory.geometries--;
      } else if (void 0 !== a.geometryGroups)
        for (b in a.geometryGroups) {
          c = a.geometryGroups[b];
          if (void 0 !== c.numMorphTargets)
            for (var d = 0, e = c.numMorphTargets; d < e; d++)
              m.deleteBuffer(c.__webglMorphTargetsBuffers[d]);
          if (void 0 !== c.numMorphNormals)
            for (d = 0, e = c.numMorphNormals; d < e; d++)
              m.deleteBuffer(c.__webglMorphNormalsBuffers[d]);
          Qb(c);
        }
      else
        Qb(a);
    }, Hb = function (a) {
      a = a.target;
      a.removeEventListener('dispose', Hb);
      a.image && a.image.__webglTextureCube ? m.deleteTexture(a.image.__webglTextureCube) : a.__webglInit && (a.__webglInit = !1, m.deleteTexture(a.__webglTexture));
      P.info.memory.textures--;
    }, Rb = function (a) {
      a = a.target;
      a.removeEventListener('dispose', Rb);
      if (a && a.__webglTexture)
        if (m.deleteTexture(a.__webglTexture), a instanceof THREE.WebGLRenderTargetCube)
          for (var b = 0; 6 > b; b++)
            m.deleteFramebuffer(a.__webglFramebuffer[b]), m.deleteRenderbuffer(a.__webglRenderbuffer[b]);
        else
          m.deleteFramebuffer(a.__webglFramebuffer), m.deleteRenderbuffer(a.__webglRenderbuffer);
      P.info.memory.textures--;
    }, Sb = function (a) {
      a = a.target;
      a.removeEventListener('dispose', Sb);
      Fb(a);
    }, Qb = function (a) {
      void 0 !== a.__webglVertexBuffer && m.deleteBuffer(a.__webglVertexBuffer);
      void 0 !== a.__webglNormalBuffer && m.deleteBuffer(a.__webglNormalBuffer);
      void 0 !== a.__webglTangentBuffer && m.deleteBuffer(a.__webglTangentBuffer);
      void 0 !== a.__webglColorBuffer && m.deleteBuffer(a.__webglColorBuffer);
      void 0 !== a.__webglUVBuffer && m.deleteBuffer(a.__webglUVBuffer);
      void 0 !== a.__webglUV2Buffer && m.deleteBuffer(a.__webglUV2Buffer);
      void 0 !== a.__webglSkinIndicesBuffer && m.deleteBuffer(a.__webglSkinIndicesBuffer);
      void 0 !== a.__webglSkinWeightsBuffer && m.deleteBuffer(a.__webglSkinWeightsBuffer);
      void 0 !== a.__webglFaceBuffer && m.deleteBuffer(a.__webglFaceBuffer);
      void 0 !== a.__webglLineBuffer && m.deleteBuffer(a.__webglLineBuffer);
      void 0 !== a.__webglLineDistanceBuffer && m.deleteBuffer(a.__webglLineDistanceBuffer);
      if (void 0 !== a.__webglCustomAttributesList)
        for (var b in a.__webglCustomAttributesList)
          m.deleteBuffer(a.__webglCustomAttributesList[b].buffer);
      P.info.memory.geometries--;
    }, Fb = function (a) {
      var b = a.program;
      if (void 0 !== b) {
        a.program = void 0;
        var c, d, e = !1;
        a = 0;
        for (c = ga.length; a < c; a++)
          if (d = ga[a], d.program === b) {
            d.usedTimes--;
            0 === d.usedTimes && (e = !0);
            break;
          }
        if (!0 === e) {
          e = [];
          a = 0;
          for (c = ga.length; a < c; a++)
            d = ga[a], d.program !== b && e.push(d);
          ga = e;
          m.deleteProgram(b);
          P.info.memory.programs--;
        }
      }
    };
  this.renderBufferImmediate = function (a, b, c) {
    h();
    a.hasPositions && !a.__webglVertexBuffer && (a.__webglVertexBuffer = m.createBuffer());
    a.hasNormals && !a.__webglNormalBuffer && (a.__webglNormalBuffer = m.createBuffer());
    a.hasUvs && !a.__webglUvBuffer && (a.__webglUvBuffer = m.createBuffer());
    a.hasColors && !a.__webglColorBuffer && (a.__webglColorBuffer = m.createBuffer());
    a.hasPositions && (m.bindBuffer(m.ARRAY_BUFFER, a.__webglVertexBuffer), m.bufferData(m.ARRAY_BUFFER, a.positionArray, m.DYNAMIC_DRAW), k(b.attributes.position), m.vertexAttribPointer(b.attributes.position, 3, m.FLOAT, !1, 0, 0));
    if (a.hasNormals) {
      m.bindBuffer(m.ARRAY_BUFFER, a.__webglNormalBuffer);
      if (c.shading === THREE.FlatShading) {
        var d, e, f, g, p, n, q, r, s, u, t, w = 3 * a.count;
        for (t = 0; t < w; t += 9)
          u = a.normalArray, d = u[t], e = u[t + 1], f = u[t + 2], g = u[t + 3], n = u[t + 4], r = u[t + 5], p = u[t + 6], q = u[t + 7], s = u[t + 8], d = (d + g + p) / 3, e = (e + n + q) / 3, f = (f + r + s) / 3, u[t] = d, u[t + 1] = e, u[t + 2] = f, u[t + 3] = d, u[t + 4] = e, u[t + 5] = f, u[t + 6] = d, u[t + 7] = e, u[t + 8] = f;
      }
      m.bufferData(m.ARRAY_BUFFER, a.normalArray, m.DYNAMIC_DRAW);
      k(b.attributes.normal);
      m.vertexAttribPointer(b.attributes.normal, 3, m.FLOAT, !1, 0, 0);
    }
    a.hasUvs && c.map && (m.bindBuffer(m.ARRAY_BUFFER, a.__webglUvBuffer), m.bufferData(m.ARRAY_BUFFER, a.uvArray, m.DYNAMIC_DRAW), k(b.attributes.uv), m.vertexAttribPointer(b.attributes.uv, 2, m.FLOAT, !1, 0, 0));
    a.hasColors && c.vertexColors !== THREE.NoColors && (m.bindBuffer(m.ARRAY_BUFFER, a.__webglColorBuffer), m.bufferData(m.ARRAY_BUFFER, a.colorArray, m.DYNAMIC_DRAW), k(b.attributes.color), m.vertexAttribPointer(b.attributes.color, 3, m.FLOAT, !1, 0, 0));
    l();
    m.drawArrays(m.TRIANGLES, 0, a.count);
    a.count = 0;
  };
  this.renderBufferDirect = function (a, b, c, d, e, f) {
    if (!1 !== d.visible) {
      var k = N(a, b, c, d, f);
      a = k.attributes;
      b = e.attributes;
      c = !1;
      k = 16777215 * e.id + 2 * k.id + (d.wireframe ? 1 : 0);
      k !== za && (za = k, c = !0);
      c && h();
      if (f instanceof THREE.Mesh)
        if (f = b.index) {
          var l;
          f.array instanceof Uint32Array ? (k = m.UNSIGNED_INT, l = 4) : (k = m.UNSIGNED_SHORT, l = 2);
          e = e.offsets;
          if (0 === e.length)
            c && (g(d, a, b, 0), m.bindBuffer(m.ELEMENT_ARRAY_BUFFER, f.buffer)), m.drawElements(m.TRIANGLES, f.array.length, k, 0), P.info.render.calls++, P.info.render.vertices += f.array.length, P.info.render.faces += f.array.length / 3;
          else {
            c = !0;
            for (var p = 0, n = e.length; p < n; p++) {
              var q = e[p].index;
              c && (g(d, a, b, q), m.bindBuffer(m.ELEMENT_ARRAY_BUFFER, f.buffer));
              m.drawElements(m.TRIANGLES, e[p].count, k, e[p].start * l);
              P.info.render.calls++;
              P.info.render.vertices += e[p].count;
              P.info.render.faces += e[p].count / 3;
            }
          }
        } else
          c && g(d, a, b, 0), d = e.attributes.position, m.drawArrays(m.TRIANGLES, 0, d.array.length / 3), P.info.render.calls++, P.info.render.vertices += d.array.length / 3, P.info.render.faces += d.array.length / 9;
      else if (f instanceof THREE.ParticleSystem)
        c && g(d, a, b, 0), d = b.position, m.drawArrays(m.POINTS, 0, d.array.length / 3), P.info.render.calls++, P.info.render.points += d.array.length / 3;
      else if (f instanceof THREE.Line)
        if (k = f.type === THREE.LineStrip ? m.LINE_STRIP : m.LINES, A(d.linewidth), f = b.index)
          if (f.array instanceof Uint32Array ? (k = m.UNSIGNED_INT, l = 4) : (k = m.UNSIGNED_SHORT, l = 2), e = e.offsets, 0 === e.length)
            c && (g(d, a, b, 0), m.bindBuffer(m.ELEMENT_ARRAY_BUFFER, f.buffer)), m.drawElements(m.LINES, f.array.length, k, 0), P.info.render.calls++, P.info.render.vertices += f.array.length;
          else
            for (1 < e.length && (c = !0), p = 0, n = e.length; p < n; p++)
              q = e[p].index, c && (g(d, a, b, q), m.bindBuffer(m.ELEMENT_ARRAY_BUFFER, f.buffer)), m.drawElements(m.LINES, e[p].count, k, e[p].start * l), P.info.render.calls++, P.info.render.vertices += e[p].count;
        else
          c && g(d, a, b, 0), d = b.position, m.drawArrays(k, 0, d.array.length / 3), P.info.render.calls++, P.info.render.points += d.array.length / 3;
    }
  };
  this.renderBuffer = function (a, b, c, d, e, f) {
    if (!1 !== d.visible) {
      var g, p;
      c = N(a, b, c, d, f);
      b = c.attributes;
      a = !1;
      c = 16777215 * e.id + 2 * c.id + (d.wireframe ? 1 : 0);
      c !== za && (za = c, a = !0);
      a && h();
      if (!d.morphTargets && 0 <= b.position)
        a && (m.bindBuffer(m.ARRAY_BUFFER, e.__webglVertexBuffer), k(b.position), m.vertexAttribPointer(b.position, 3, m.FLOAT, !1, 0, 0));
      else if (f.morphTargetBase) {
        c = d.program.attributes;
        -1 !== f.morphTargetBase && 0 <= c.position ? (m.bindBuffer(m.ARRAY_BUFFER, e.__webglMorphTargetsBuffers[f.morphTargetBase]), k(c.position), m.vertexAttribPointer(c.position, 3, m.FLOAT, !1, 0, 0)) : 0 <= c.position && (m.bindBuffer(m.ARRAY_BUFFER, e.__webglVertexBuffer), k(c.position), m.vertexAttribPointer(c.position, 3, m.FLOAT, !1, 0, 0));
        if (f.morphTargetForcedOrder.length) {
          var n = 0;
          p = f.morphTargetForcedOrder;
          for (g = f.morphTargetInfluences; n < d.numSupportedMorphTargets && n < p.length;)
            0 <= c['morphTarget' + n] && (m.bindBuffer(m.ARRAY_BUFFER, e.__webglMorphTargetsBuffers[p[n]]), k(c['morphTarget' + n]), m.vertexAttribPointer(c['morphTarget' + n], 3, m.FLOAT, !1, 0, 0)), 0 <= c['morphNormal' + n] && d.morphNormals && (m.bindBuffer(m.ARRAY_BUFFER, e.__webglMorphNormalsBuffers[p[n]]), k(c['morphNormal' + n]), m.vertexAttribPointer(c['morphNormal' + n], 3, m.FLOAT, !1, 0, 0)), f.__webglMorphTargetInfluences[n] = g[p[n]], n++;
        } else {
          p = [];
          g = f.morphTargetInfluences;
          var r, s = g.length;
          for (r = 0; r < s; r++)
            n = g[r], 0 < n && p.push([
              n,
              r
            ]);
          p.length > d.numSupportedMorphTargets ? (p.sort(q), p.length = d.numSupportedMorphTargets) : p.length > d.numSupportedMorphNormals ? p.sort(q) : 0 === p.length && p.push([
            0,
            0
          ]);
          for (n = 0; n < d.numSupportedMorphTargets;)
            p[n] ? (r = p[n][1], 0 <= c['morphTarget' + n] && (m.bindBuffer(m.ARRAY_BUFFER, e.__webglMorphTargetsBuffers[r]), k(c['morphTarget' + n]), m.vertexAttribPointer(c['morphTarget' + n], 3, m.FLOAT, !1, 0, 0)), 0 <= c['morphNormal' + n] && d.morphNormals && (m.bindBuffer(m.ARRAY_BUFFER, e.__webglMorphNormalsBuffers[r]), k(c['morphNormal' + n]), m.vertexAttribPointer(c['morphNormal' + n], 3, m.FLOAT, !1, 0, 0)), f.__webglMorphTargetInfluences[n] = g[r]) : f.__webglMorphTargetInfluences[n] = 0, n++;
        }
        null !== d.program.uniforms.morphTargetInfluences && m.uniform1fv(d.program.uniforms.morphTargetInfluences, f.__webglMorphTargetInfluences);
      }
      if (a) {
        if (e.__webglCustomAttributesList)
          for (g = 0, p = e.__webglCustomAttributesList.length; g < p; g++)
            c = e.__webglCustomAttributesList[g], 0 <= b[c.buffer.belongsToAttribute] && (m.bindBuffer(m.ARRAY_BUFFER, c.buffer), k(b[c.buffer.belongsToAttribute]), m.vertexAttribPointer(b[c.buffer.belongsToAttribute], c.size, m.FLOAT, !1, 0, 0));
        0 <= b.color && (0 < f.geometry.colors.length || 0 < f.geometry.faces.length ? (m.bindBuffer(m.ARRAY_BUFFER, e.__webglColorBuffer), k(b.color), m.vertexAttribPointer(b.color, 3, m.FLOAT, !1, 0, 0)) : d.defaultAttributeValues && m.vertexAttrib3fv(b.color, d.defaultAttributeValues.color));
        0 <= b.normal && (m.bindBuffer(m.ARRAY_BUFFER, e.__webglNormalBuffer), k(b.normal), m.vertexAttribPointer(b.normal, 3, m.FLOAT, !1, 0, 0));
        0 <= b.tangent && (m.bindBuffer(m.ARRAY_BUFFER, e.__webglTangentBuffer), k(b.tangent), m.vertexAttribPointer(b.tangent, 4, m.FLOAT, !1, 0, 0));
        0 <= b.uv && (f.geometry.faceVertexUvs[0] ? (m.bindBuffer(m.ARRAY_BUFFER, e.__webglUVBuffer), k(b.uv), m.vertexAttribPointer(b.uv, 2, m.FLOAT, !1, 0, 0)) : d.defaultAttributeValues && m.vertexAttrib2fv(b.uv, d.defaultAttributeValues.uv));
        0 <= b.uv2 && (f.geometry.faceVertexUvs[1] ? (m.bindBuffer(m.ARRAY_BUFFER, e.__webglUV2Buffer), k(b.uv2), m.vertexAttribPointer(b.uv2, 2, m.FLOAT, !1, 0, 0)) : d.defaultAttributeValues && m.vertexAttrib2fv(b.uv2, d.defaultAttributeValues.uv2));
        d.skinning && 0 <= b.skinIndex && 0 <= b.skinWeight && (m.bindBuffer(m.ARRAY_BUFFER, e.__webglSkinIndicesBuffer), k(b.skinIndex), m.vertexAttribPointer(b.skinIndex, 4, m.FLOAT, !1, 0, 0), m.bindBuffer(m.ARRAY_BUFFER, e.__webglSkinWeightsBuffer), k(b.skinWeight), m.vertexAttribPointer(b.skinWeight, 4, m.FLOAT, !1, 0, 0));
        0 <= b.lineDistance && (m.bindBuffer(m.ARRAY_BUFFER, e.__webglLineDistanceBuffer), k(b.lineDistance), m.vertexAttribPointer(b.lineDistance, 1, m.FLOAT, !1, 0, 0));
      }
      l();
      f instanceof THREE.Mesh ? (f = e.__typeArray === Uint32Array ? m.UNSIGNED_INT : m.UNSIGNED_SHORT, d.wireframe ? (A(d.wireframeLinewidth), a && m.bindBuffer(m.ELEMENT_ARRAY_BUFFER, e.__webglLineBuffer), m.drawElements(m.LINES, e.__webglLineCount, f, 0)) : (a && m.bindBuffer(m.ELEMENT_ARRAY_BUFFER, e.__webglFaceBuffer), m.drawElements(m.TRIANGLES, e.__webglFaceCount, f, 0)), P.info.render.calls++, P.info.render.vertices += e.__webglFaceCount, P.info.render.faces += e.__webglFaceCount / 3) : f instanceof THREE.Line ? (f = f.type === THREE.LineStrip ? m.LINE_STRIP : m.LINES, A(d.linewidth), m.drawArrays(f, 0, e.__webglLineCount), P.info.render.calls++) : f instanceof THREE.ParticleSystem && (m.drawArrays(m.POINTS, 0, e.__webglParticleCount), P.info.render.calls++, P.info.render.points += e.__webglParticleCount);
    }
  };
  this.render = function (a, b, c, d) {
    if (!1 === b instanceof THREE.Camera)
      console.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.');
    else {
      var e, f, g, h, k = a.__lights, l = a.fog;
      fa = -1;
      cb = !0;
      !0 === a.autoUpdate && a.updateMatrixWorld();
      void 0 === b.parent && b.updateMatrixWorld();
      b.matrixWorldInverse.getInverse(b.matrixWorld);
      Pb.multiplyMatrices(b.projectionMatrix, b.matrixWorldInverse);
      Ab.setFromMatrix(Pb);
      this.autoUpdateObjects && this.initWebGLObjects(a);
      p(this.renderPluginsPre, a, b);
      P.info.render.calls = 0;
      P.info.render.vertices = 0;
      P.info.render.faces = 0;
      P.info.render.points = 0;
      this.setRenderTarget(c);
      (this.autoClear || d) && this.clear(this.autoClearColor, this.autoClearDepth, this.autoClearStencil);
      h = a.__webglObjects;
      d = 0;
      for (e = h.length; d < e; d++)
        if (f = h[d], g = f.object, f.id = d, f.render = !1, g.visible && (!(g instanceof THREE.Mesh || g instanceof THREE.ParticleSystem) || !g.frustumCulled || Ab.intersectsObject(g))) {
          var q = g;
          q._modelViewMatrix.multiplyMatrices(b.matrixWorldInverse, q.matrixWorld);
          q._normalMatrix.getNormalMatrix(q._modelViewMatrix);
          var q = f, r = q.object, u = q.buffer, w = r.geometry, r = r.material;
          r instanceof THREE.MeshFaceMaterial ? (r = r.materials[w instanceof THREE.BufferGeometry ? 0 : u.materialIndex], r.transparent ? (q.transparent = r, q.opaque = null) : (q.opaque = r, q.transparent = null)) : r && (r.transparent ? (q.transparent = r, q.opaque = null) : (q.opaque = r, q.transparent = null));
          f.render = !0;
          !0 === this.sortObjects && (null !== g.renderDepth ? f.z = g.renderDepth : (xa.setFromMatrixPosition(g.matrixWorld), xa.applyProjection(Pb), f.z = xa.z));
        }
      this.sortObjects && h.sort(n);
      h = a.__webglObjectsImmediate;
      d = 0;
      for (e = h.length; d < e; d++)
        f = h[d], g = f.object, g.visible && (g._modelViewMatrix.multiplyMatrices(b.matrixWorldInverse, g.matrixWorld), g._normalMatrix.getNormalMatrix(g._modelViewMatrix), g = f.object.material, g.transparent ? (f.transparent = g, f.opaque = null) : (f.opaque = g, f.transparent = null));
      a.overrideMaterial ? (d = a.overrideMaterial, this.setBlending(d.blending, d.blendEquation, d.blendSrc, d.blendDst), this.setDepthTest(d.depthTest), this.setDepthWrite(d.depthWrite), G(d.polygonOffset, d.polygonOffsetFactor, d.polygonOffsetUnits), s(a.__webglObjects, !1, '', b, k, l, !0, d), t(a.__webglObjectsImmediate, '', b, k, l, !1, d)) : (d = null, this.setBlending(THREE.NoBlending), s(a.__webglObjects, !0, 'opaque', b, k, l, !1, d), t(a.__webglObjectsImmediate, 'opaque', b, k, l, !1, d), s(a.__webglObjects, !1, 'transparent', b, k, l, !0, d), t(a.__webglObjectsImmediate, 'transparent', b, k, l, !0, d));
      p(this.renderPluginsPost, a, b);
      c && c.generateMipmaps && c.minFilter !== THREE.NearestFilter && c.minFilter !== THREE.LinearFilter && (c instanceof THREE.WebGLRenderTargetCube ? (m.bindTexture(m.TEXTURE_CUBE_MAP, c.__webglTexture), m.generateMipmap(m.TEXTURE_CUBE_MAP), m.bindTexture(m.TEXTURE_CUBE_MAP, null)) : (m.bindTexture(m.TEXTURE_2D, c.__webglTexture), m.generateMipmap(m.TEXTURE_2D), m.bindTexture(m.TEXTURE_2D, null)));
      this.setDepthTest(!0);
      this.setDepthWrite(!0);
    }
  };
  this.renderImmediateObject = function (a, b, c, d, e) {
    var f = N(a, b, c, d, e);
    za = -1;
    P.setMaterialFaces(d);
    e.immediateRenderCallback ? e.immediateRenderCallback(f, m, Ab) : e.render(function (a) {
      P.renderBufferImmediate(a, f, d);
    });
  };
  this.initWebGLObjects = function (a) {
    a.__webglObjects || (a.__webglObjects = [], a.__webglObjectsImmediate = [], a.__webglSprites = [], a.__webglFlares = []);
    for (; a.__objectsAdded.length;)
      r(a.__objectsAdded[0], a), a.__objectsAdded.splice(0, 1);
    for (; a.__objectsRemoved.length;)
      y(a.__objectsRemoved[0], a), a.__objectsRemoved.splice(0, 1);
    for (var b = 0, g = a.__webglObjects.length; b < g; b++) {
      var h = a.__webglObjects[b].object;
      void 0 === h.__webglInit && (void 0 !== h.__webglActive && y(h, a), r(h, a));
      var k = h, l = k.geometry, p = void 0, n = void 0, s = void 0;
      if (l instanceof THREE.BufferGeometry) {
        var t = m.DYNAMIC_DRAW, v = l.attributes, A = void 0, B = void 0;
        for (A in v)
          B = v[A], B.needsUpdate && ('index' === A ? (m.bindBuffer(m.ELEMENT_ARRAY_BUFFER, B.buffer), m.bufferData(m.ELEMENT_ARRAY_BUFFER, B.array, t)) : (m.bindBuffer(m.ARRAY_BUFFER, B.buffer), m.bufferData(m.ARRAY_BUFFER, B.array, t)), B.needsUpdate = !1);
      } else if (k instanceof THREE.Mesh) {
        for (var z = 0, L = l.geometryGroupsList.length; z < L; z++)
          if (p = l.geometryGroupsList[z], s = d(k, p), l.buffersNeedUpdate && c(p, k), n = s.attributes && w(s), l.verticesNeedUpdate || l.morphTargetsNeedUpdate || l.elementsNeedUpdate || l.uvsNeedUpdate || l.normalsNeedUpdate || l.colorsNeedUpdate || l.tangentsNeedUpdate || n) {
            var x = p, G = k, C = m.DYNAMIC_DRAW, E = !l.dynamic, J = s;
            if (x.__inittedArrays) {
              var H = e(J), P = J.vertexColors ? J.vertexColors : !1, N = f(J), K = H === THREE.SmoothShading, D = void 0, F = void 0, Q = void 0, I = void 0, U = void 0, fa = void 0, Y = void 0, ga = void 0, R = void 0, V = void 0, W = void 0, $ = void 0, aa = void 0, ba = void 0, wa = void 0, X = void 0, Z = void 0, da = void 0, Ia = void 0, Ga = void 0, Ea = void 0, ia = void 0, za = void 0, ja = void 0, Ha = void 0, la = void 0, oa = void 0, qa = void 0, ra = void 0, ha = void 0, ya = void 0, Fa = void 0, Ca = void 0, Da = void 0, ma = void 0, Ka = void 0, ua = void 0, va = void 0, Oa = void 0, Ja = void 0, ab = 0, bb = 0, Ra = 0, Sa = 0, Pa = 0, eb = 0, Ta = 0, qb = 0, Ya = 0, ta = 0, Aa = 0, O = 0, Qa = void 0, fb = x.__vertexArray, cb = x.__uvArray, db = x.__uv2Array, tb = x.__normalArray, Ua = x.__tangentArray, gb = x.__colorArray, Va = x.__skinIndexArray, Wa = x.__skinWeightArray, ob = x.__morphTargetsArrays, sb = x.__morphNormalsArrays, pb = x.__webglCustomAttributesList, M = void 0, Tb = x.__faceArray, ub = x.__lineArray, La = G.geometry, Ab = La.elementsNeedUpdate, xb = La.uvsNeedUpdate, Db = La.normalsNeedUpdate, Gb = La.tangentsNeedUpdate, Hb = La.colorsNeedUpdate, Jb = La.morphTargetsNeedUpdate, fc = La.vertices, ea = x.faces3, hb = La.faces, Bb = La.faceVertexUvs[0], Cb = La.faceVertexUvs[1], gc = La.skinIndices, Ub = La.skinWeights, Vb = La.morphTargets, Eb = La.morphNormals;
              if (La.verticesNeedUpdate) {
                D = 0;
                for (F = ea.length; D < F; D++)
                  I = hb[ea[D]], $ = fc[I.a], aa = fc[I.b], ba = fc[I.c], fb[bb] = $.x, fb[bb + 1] = $.y, fb[bb + 2] = $.z, fb[bb + 3] = aa.x, fb[bb + 4] = aa.y, fb[bb + 5] = aa.z, fb[bb + 6] = ba.x, fb[bb + 7] = ba.y, fb[bb + 8] = ba.z, bb += 9;
                m.bindBuffer(m.ARRAY_BUFFER, x.__webglVertexBuffer);
                m.bufferData(m.ARRAY_BUFFER, fb, C);
              }
              if (Jb)
                for (ma = 0, Ka = Vb.length; ma < Ka; ma++) {
                  D = Aa = 0;
                  for (F = ea.length; D < F; D++)
                    Oa = ea[D], I = hb[Oa], $ = Vb[ma].vertices[I.a], aa = Vb[ma].vertices[I.b], ba = Vb[ma].vertices[I.c], ua = ob[ma], ua[Aa] = $.x, ua[Aa + 1] = $.y, ua[Aa + 2] = $.z, ua[Aa + 3] = aa.x, ua[Aa + 4] = aa.y, ua[Aa + 5] = aa.z, ua[Aa + 6] = ba.x, ua[Aa + 7] = ba.y, ua[Aa + 8] = ba.z, J.morphNormals && (K ? (Ja = Eb[ma].vertexNormals[Oa], da = Ja.a, Ia = Ja.b, Ga = Ja.c) : Ga = Ia = da = Eb[ma].faceNormals[Oa], va = sb[ma], va[Aa] = da.x, va[Aa + 1] = da.y, va[Aa + 2] = da.z, va[Aa + 3] = Ia.x, va[Aa + 4] = Ia.y, va[Aa + 5] = Ia.z, va[Aa + 6] = Ga.x, va[Aa + 7] = Ga.y, va[Aa + 8] = Ga.z), Aa += 9;
                  m.bindBuffer(m.ARRAY_BUFFER, x.__webglMorphTargetsBuffers[ma]);
                  m.bufferData(m.ARRAY_BUFFER, ob[ma], C);
                  J.morphNormals && (m.bindBuffer(m.ARRAY_BUFFER, x.__webglMorphNormalsBuffers[ma]), m.bufferData(m.ARRAY_BUFFER, sb[ma], C));
                }
              if (Ub.length) {
                D = 0;
                for (F = ea.length; D < F; D++)
                  I = hb[ea[D]], ja = Ub[I.a], Ha = Ub[I.b], la = Ub[I.c], Wa[ta] = ja.x, Wa[ta + 1] = ja.y, Wa[ta + 2] = ja.z, Wa[ta + 3] = ja.w, Wa[ta + 4] = Ha.x, Wa[ta + 5] = Ha.y, Wa[ta + 6] = Ha.z, Wa[ta + 7] = Ha.w, Wa[ta + 8] = la.x, Wa[ta + 9] = la.y, Wa[ta + 10] = la.z, Wa[ta + 11] = la.w, oa = gc[I.a], qa = gc[I.b], ra = gc[I.c], Va[ta] = oa.x, Va[ta + 1] = oa.y, Va[ta + 2] = oa.z, Va[ta + 3] = oa.w, Va[ta + 4] = qa.x, Va[ta + 5] = qa.y, Va[ta + 6] = qa.z, Va[ta + 7] = qa.w, Va[ta + 8] = ra.x, Va[ta + 9] = ra.y, Va[ta + 10] = ra.z, Va[ta + 11] = ra.w, ta += 12;
                0 < ta && (m.bindBuffer(m.ARRAY_BUFFER, x.__webglSkinIndicesBuffer), m.bufferData(m.ARRAY_BUFFER, Va, C), m.bindBuffer(m.ARRAY_BUFFER, x.__webglSkinWeightsBuffer), m.bufferData(m.ARRAY_BUFFER, Wa, C));
              }
              if (Hb && P) {
                D = 0;
                for (F = ea.length; D < F; D++)
                  I = hb[ea[D]], Y = I.vertexColors, ga = I.color, 3 === Y.length && P === THREE.VertexColors ? (Ea = Y[0], ia = Y[1], za = Y[2]) : za = ia = Ea = ga, gb[Ya] = Ea.r, gb[Ya + 1] = Ea.g, gb[Ya + 2] = Ea.b, gb[Ya + 3] = ia.r, gb[Ya + 4] = ia.g, gb[Ya + 5] = ia.b, gb[Ya + 6] = za.r, gb[Ya + 7] = za.g, gb[Ya + 8] = za.b, Ya += 9;
                0 < Ya && (m.bindBuffer(m.ARRAY_BUFFER, x.__webglColorBuffer), m.bufferData(m.ARRAY_BUFFER, gb, C));
              }
              if (Gb && La.hasTangents) {
                D = 0;
                for (F = ea.length; D < F; D++)
                  I = hb[ea[D]], R = I.vertexTangents, wa = R[0], X = R[1], Z = R[2], Ua[Ta] = wa.x, Ua[Ta + 1] = wa.y, Ua[Ta + 2] = wa.z, Ua[Ta + 3] = wa.w, Ua[Ta + 4] = X.x, Ua[Ta + 5] = X.y, Ua[Ta + 6] = X.z, Ua[Ta + 7] = X.w, Ua[Ta + 8] = Z.x, Ua[Ta + 9] = Z.y, Ua[Ta + 10] = Z.z, Ua[Ta + 11] = Z.w, Ta += 12;
                m.bindBuffer(m.ARRAY_BUFFER, x.__webglTangentBuffer);
                m.bufferData(m.ARRAY_BUFFER, Ua, C);
              }
              if (Db && H) {
                D = 0;
                for (F = ea.length; D < F; D++)
                  if (I = hb[ea[D]], U = I.vertexNormals, fa = I.normal, 3 === U.length && K)
                    for (ha = 0; 3 > ha; ha++)
                      Fa = U[ha], tb[eb] = Fa.x, tb[eb + 1] = Fa.y, tb[eb + 2] = Fa.z, eb += 3;
                  else
                    for (ha = 0; 3 > ha; ha++)
                      tb[eb] = fa.x, tb[eb + 1] = fa.y, tb[eb + 2] = fa.z, eb += 3;
                m.bindBuffer(m.ARRAY_BUFFER, x.__webglNormalBuffer);
                m.bufferData(m.ARRAY_BUFFER, tb, C);
              }
              if (xb && Bb && N) {
                D = 0;
                for (F = ea.length; D < F; D++)
                  if (Q = ea[D], V = Bb[Q], void 0 !== V)
                    for (ha = 0; 3 > ha; ha++)
                      Ca = V[ha], cb[Ra] = Ca.x, cb[Ra + 1] = Ca.y, Ra += 2;
                0 < Ra && (m.bindBuffer(m.ARRAY_BUFFER, x.__webglUVBuffer), m.bufferData(m.ARRAY_BUFFER, cb, C));
              }
              if (xb && Cb && N) {
                D = 0;
                for (F = ea.length; D < F; D++)
                  if (Q = ea[D], W = Cb[Q], void 0 !== W)
                    for (ha = 0; 3 > ha; ha++)
                      Da = W[ha], db[Sa] = Da.x, db[Sa + 1] = Da.y, Sa += 2;
                0 < Sa && (m.bindBuffer(m.ARRAY_BUFFER, x.__webglUV2Buffer), m.bufferData(m.ARRAY_BUFFER, db, C));
              }
              if (Ab) {
                D = 0;
                for (F = ea.length; D < F; D++)
                  Tb[Pa] = ab, Tb[Pa + 1] = ab + 1, Tb[Pa + 2] = ab + 2, Pa += 3, ub[qb] = ab, ub[qb + 1] = ab + 1, ub[qb + 2] = ab, ub[qb + 3] = ab + 2, ub[qb + 4] = ab + 1, ub[qb + 5] = ab + 2, qb += 6, ab += 3;
                m.bindBuffer(m.ELEMENT_ARRAY_BUFFER, x.__webglFaceBuffer);
                m.bufferData(m.ELEMENT_ARRAY_BUFFER, Tb, C);
                m.bindBuffer(m.ELEMENT_ARRAY_BUFFER, x.__webglLineBuffer);
                m.bufferData(m.ELEMENT_ARRAY_BUFFER, ub, C);
              }
              if (pb)
                for (ha = 0, ya = pb.length; ha < ya; ha++)
                  if (M = pb[ha], M.__original.needsUpdate) {
                    O = 0;
                    if (1 === M.size)
                      if (void 0 === M.boundTo || 'vertices' === M.boundTo)
                        for (D = 0, F = ea.length; D < F; D++)
                          I = hb[ea[D]], M.array[O] = M.value[I.a], M.array[O + 1] = M.value[I.b], M.array[O + 2] = M.value[I.c], O += 3;
                      else {
                        if ('faces' === M.boundTo)
                          for (D = 0, F = ea.length; D < F; D++)
                            Qa = M.value[ea[D]], M.array[O] = Qa, M.array[O + 1] = Qa, M.array[O + 2] = Qa, O += 3;
                      }
                    else if (2 === M.size)
                      if (void 0 === M.boundTo || 'vertices' === M.boundTo)
                        for (D = 0, F = ea.length; D < F; D++)
                          I = hb[ea[D]], $ = M.value[I.a], aa = M.value[I.b], ba = M.value[I.c], M.array[O] = $.x, M.array[O + 1] = $.y, M.array[O + 2] = aa.x, M.array[O + 3] = aa.y, M.array[O + 4] = ba.x, M.array[O + 5] = ba.y, O += 6;
                      else {
                        if ('faces' === M.boundTo)
                          for (D = 0, F = ea.length; D < F; D++)
                            ba = aa = $ = Qa = M.value[ea[D]], M.array[O] = $.x, M.array[O + 1] = $.y, M.array[O + 2] = aa.x, M.array[O + 3] = aa.y, M.array[O + 4] = ba.x, M.array[O + 5] = ba.y, O += 6;
                      }
                    else if (3 === M.size) {
                      var sa;
                      sa = 'c' === M.type ? [
                        'r',
                        'g',
                        'b'
                      ] : [
                        'x',
                        'y',
                        'z'
                      ];
                      if (void 0 === M.boundTo || 'vertices' === M.boundTo)
                        for (D = 0, F = ea.length; D < F; D++)
                          I = hb[ea[D]], $ = M.value[I.a], aa = M.value[I.b], ba = M.value[I.c], M.array[O] = $[sa[0]], M.array[O + 1] = $[sa[1]], M.array[O + 2] = $[sa[2]], M.array[O + 3] = aa[sa[0]], M.array[O + 4] = aa[sa[1]], M.array[O + 5] = aa[sa[2]], M.array[O + 6] = ba[sa[0]], M.array[O + 7] = ba[sa[1]], M.array[O + 8] = ba[sa[2]], O += 9;
                      else if ('faces' === M.boundTo)
                        for (D = 0, F = ea.length; D < F; D++)
                          ba = aa = $ = Qa = M.value[ea[D]], M.array[O] = $[sa[0]], M.array[O + 1] = $[sa[1]], M.array[O + 2] = $[sa[2]], M.array[O + 3] = aa[sa[0]], M.array[O + 4] = aa[sa[1]], M.array[O + 5] = aa[sa[2]], M.array[O + 6] = ba[sa[0]], M.array[O + 7] = ba[sa[1]], M.array[O + 8] = ba[sa[2]], O += 9;
                      else if ('faceVertices' === M.boundTo)
                        for (D = 0, F = ea.length; D < F; D++)
                          Qa = M.value[ea[D]], $ = Qa[0], aa = Qa[1], ba = Qa[2], M.array[O] = $[sa[0]], M.array[O + 1] = $[sa[1]], M.array[O + 2] = $[sa[2]], M.array[O + 3] = aa[sa[0]], M.array[O + 4] = aa[sa[1]], M.array[O + 5] = aa[sa[2]], M.array[O + 6] = ba[sa[0]], M.array[O + 7] = ba[sa[1]], M.array[O + 8] = ba[sa[2]], O += 9;
                    } else if (4 === M.size)
                      if (void 0 === M.boundTo || 'vertices' === M.boundTo)
                        for (D = 0, F = ea.length; D < F; D++)
                          I = hb[ea[D]], $ = M.value[I.a], aa = M.value[I.b], ba = M.value[I.c], M.array[O] = $.x, M.array[O + 1] = $.y, M.array[O + 2] = $.z, M.array[O + 3] = $.w, M.array[O + 4] = aa.x, M.array[O + 5] = aa.y, M.array[O + 6] = aa.z, M.array[O + 7] = aa.w, M.array[O + 8] = ba.x, M.array[O + 9] = ba.y, M.array[O + 10] = ba.z, M.array[O + 11] = ba.w, O += 12;
                      else if ('faces' === M.boundTo)
                        for (D = 0, F = ea.length; D < F; D++)
                          ba = aa = $ = Qa = M.value[ea[D]], M.array[O] = $.x, M.array[O + 1] = $.y, M.array[O + 2] = $.z, M.array[O + 3] = $.w, M.array[O + 4] = aa.x, M.array[O + 5] = aa.y, M.array[O + 6] = aa.z, M.array[O + 7] = aa.w, M.array[O + 8] = ba.x, M.array[O + 9] = ba.y, M.array[O + 10] = ba.z, M.array[O + 11] = ba.w, O += 12;
                      else if ('faceVertices' === M.boundTo)
                        for (D = 0, F = ea.length; D < F; D++)
                          Qa = M.value[ea[D]], $ = Qa[0], aa = Qa[1], ba = Qa[2], M.array[O] = $.x, M.array[O + 1] = $.y, M.array[O + 2] = $.z, M.array[O + 3] = $.w, M.array[O + 4] = aa.x, M.array[O + 5] = aa.y, M.array[O + 6] = aa.z, M.array[O + 7] = aa.w, M.array[O + 8] = ba.x, M.array[O + 9] = ba.y, M.array[O + 10] = ba.z, M.array[O + 11] = ba.w, O += 12;
                    m.bindBuffer(m.ARRAY_BUFFER, M.buffer);
                    m.bufferData(m.ARRAY_BUFFER, M.array, C);
                  }
              E && (delete x.__inittedArrays, delete x.__colorArray, delete x.__normalArray, delete x.__tangentArray, delete x.__uvArray, delete x.__uv2Array, delete x.__faceArray, delete x.__vertexArray, delete x.__lineArray, delete x.__skinIndexArray, delete x.__skinWeightArray);
            }
          }
        l.verticesNeedUpdate = !1;
        l.morphTargetsNeedUpdate = !1;
        l.elementsNeedUpdate = !1;
        l.uvsNeedUpdate = !1;
        l.normalsNeedUpdate = !1;
        l.colorsNeedUpdate = !1;
        l.tangentsNeedUpdate = !1;
        l.buffersNeedUpdate = !1;
        s.attributes && u(s);
      } else if (k instanceof THREE.Line) {
        s = d(k, l);
        n = s.attributes && w(s);
        if (l.verticesNeedUpdate || l.colorsNeedUpdate || l.lineDistancesNeedUpdate || n) {
          var Xa = l, Wb = m.DYNAMIC_DRAW, Lb = void 0, Mb = void 0, Nb = void 0, Xb = void 0, pa = void 0, Yb = void 0, Fb = Xa.vertices, Ib = Xa.colors, Kb = Xa.lineDistances, Qb = Fb.length, Rb = Ib.length, Sb = Kb.length, Zb = Xa.__vertexArray, $b = Xa.__colorArray, lc = Xa.__lineDistanceArray, dc = Xa.colorsNeedUpdate, ec = Xa.lineDistancesNeedUpdate, hc = Xa.__webglCustomAttributesList, ac = void 0, mc = void 0, Ba = void 0, yb = void 0, Ma = void 0, na = void 0;
          if (Xa.verticesNeedUpdate) {
            for (Lb = 0; Lb < Qb; Lb++)
              Xb = Fb[Lb], pa = 3 * Lb, Zb[pa] = Xb.x, Zb[pa + 1] = Xb.y, Zb[pa + 2] = Xb.z;
            m.bindBuffer(m.ARRAY_BUFFER, Xa.__webglVertexBuffer);
            m.bufferData(m.ARRAY_BUFFER, Zb, Wb);
          }
          if (dc) {
            for (Mb = 0; Mb < Rb; Mb++)
              Yb = Ib[Mb], pa = 3 * Mb, $b[pa] = Yb.r, $b[pa + 1] = Yb.g, $b[pa + 2] = Yb.b;
            m.bindBuffer(m.ARRAY_BUFFER, Xa.__webglColorBuffer);
            m.bufferData(m.ARRAY_BUFFER, $b, Wb);
          }
          if (ec) {
            for (Nb = 0; Nb < Sb; Nb++)
              lc[Nb] = Kb[Nb];
            m.bindBuffer(m.ARRAY_BUFFER, Xa.__webglLineDistanceBuffer);
            m.bufferData(m.ARRAY_BUFFER, lc, Wb);
          }
          if (hc)
            for (ac = 0, mc = hc.length; ac < mc; ac++)
              if (na = hc[ac], na.needsUpdate && (void 0 === na.boundTo || 'vertices' === na.boundTo)) {
                pa = 0;
                yb = na.value.length;
                if (1 === na.size)
                  for (Ba = 0; Ba < yb; Ba++)
                    na.array[Ba] = na.value[Ba];
                else if (2 === na.size)
                  for (Ba = 0; Ba < yb; Ba++)
                    Ma = na.value[Ba], na.array[pa] = Ma.x, na.array[pa + 1] = Ma.y, pa += 2;
                else if (3 === na.size)
                  if ('c' === na.type)
                    for (Ba = 0; Ba < yb; Ba++)
                      Ma = na.value[Ba], na.array[pa] = Ma.r, na.array[pa + 1] = Ma.g, na.array[pa + 2] = Ma.b, pa += 3;
                  else
                    for (Ba = 0; Ba < yb; Ba++)
                      Ma = na.value[Ba], na.array[pa] = Ma.x, na.array[pa + 1] = Ma.y, na.array[pa + 2] = Ma.z, pa += 3;
                else if (4 === na.size)
                  for (Ba = 0; Ba < yb; Ba++)
                    Ma = na.value[Ba], na.array[pa] = Ma.x, na.array[pa + 1] = Ma.y, na.array[pa + 2] = Ma.z, na.array[pa + 3] = Ma.w, pa += 4;
                m.bindBuffer(m.ARRAY_BUFFER, na.buffer);
                m.bufferData(m.ARRAY_BUFFER, na.array, Wb);
              }
        }
        l.verticesNeedUpdate = !1;
        l.colorsNeedUpdate = !1;
        l.lineDistancesNeedUpdate = !1;
        s.attributes && u(s);
      } else if (k instanceof THREE.ParticleSystem) {
        s = d(k, l);
        n = s.attributes && w(s);
        if (l.verticesNeedUpdate || l.colorsNeedUpdate || k.sortParticles || n) {
          var ib = l, ic = m.DYNAMIC_DRAW, Ob = k, Na = void 0, jb = void 0, kb = void 0, T = void 0, lb = void 0, rb = void 0, bc = ib.vertices, jc = bc.length, kc = ib.colors, nc = kc.length, vb = ib.__vertexArray, wb = ib.__colorArray, mb = ib.__sortArray, oc = ib.verticesNeedUpdate, pc = ib.colorsNeedUpdate, nb = ib.__webglCustomAttributesList, Za = void 0, zb = void 0, ca = void 0, $a = void 0, ka = void 0, S = void 0;
          if (Ob.sortParticles) {
            cc.copy(Pb);
            cc.multiply(Ob.matrixWorld);
            for (Na = 0; Na < jc; Na++)
              kb = bc[Na], xa.copy(kb), xa.applyProjection(cc), mb[Na] = [
                xa.z,
                Na
              ];
            mb.sort(q);
            for (Na = 0; Na < jc; Na++)
              kb = bc[mb[Na][1]], T = 3 * Na, vb[T] = kb.x, vb[T + 1] = kb.y, vb[T + 2] = kb.z;
            for (jb = 0; jb < nc; jb++)
              T = 3 * jb, rb = kc[mb[jb][1]], wb[T] = rb.r, wb[T + 1] = rb.g, wb[T + 2] = rb.b;
            if (nb)
              for (Za = 0, zb = nb.length; Za < zb; Za++)
                if (S = nb[Za], void 0 === S.boundTo || 'vertices' === S.boundTo)
                  if (T = 0, $a = S.value.length, 1 === S.size)
                    for (ca = 0; ca < $a; ca++)
                      lb = mb[ca][1], S.array[ca] = S.value[lb];
                  else if (2 === S.size)
                    for (ca = 0; ca < $a; ca++)
                      lb = mb[ca][1], ka = S.value[lb], S.array[T] = ka.x, S.array[T + 1] = ka.y, T += 2;
                  else if (3 === S.size)
                    if ('c' === S.type)
                      for (ca = 0; ca < $a; ca++)
                        lb = mb[ca][1], ka = S.value[lb], S.array[T] = ka.r, S.array[T + 1] = ka.g, S.array[T + 2] = ka.b, T += 3;
                    else
                      for (ca = 0; ca < $a; ca++)
                        lb = mb[ca][1], ka = S.value[lb], S.array[T] = ka.x, S.array[T + 1] = ka.y, S.array[T + 2] = ka.z, T += 3;
                  else if (4 === S.size)
                    for (ca = 0; ca < $a; ca++)
                      lb = mb[ca][1], ka = S.value[lb], S.array[T] = ka.x, S.array[T + 1] = ka.y, S.array[T + 2] = ka.z, S.array[T + 3] = ka.w, T += 4;
          } else {
            if (oc)
              for (Na = 0; Na < jc; Na++)
                kb = bc[Na], T = 3 * Na, vb[T] = kb.x, vb[T + 1] = kb.y, vb[T + 2] = kb.z;
            if (pc)
              for (jb = 0; jb < nc; jb++)
                rb = kc[jb], T = 3 * jb, wb[T] = rb.r, wb[T + 1] = rb.g, wb[T + 2] = rb.b;
            if (nb)
              for (Za = 0, zb = nb.length; Za < zb; Za++)
                if (S = nb[Za], S.needsUpdate && (void 0 === S.boundTo || 'vertices' === S.boundTo))
                  if ($a = S.value.length, T = 0, 1 === S.size)
                    for (ca = 0; ca < $a; ca++)
                      S.array[ca] = S.value[ca];
                  else if (2 === S.size)
                    for (ca = 0; ca < $a; ca++)
                      ka = S.value[ca], S.array[T] = ka.x, S.array[T + 1] = ka.y, T += 2;
                  else if (3 === S.size)
                    if ('c' === S.type)
                      for (ca = 0; ca < $a; ca++)
                        ka = S.value[ca], S.array[T] = ka.r, S.array[T + 1] = ka.g, S.array[T + 2] = ka.b, T += 3;
                    else
                      for (ca = 0; ca < $a; ca++)
                        ka = S.value[ca], S.array[T] = ka.x, S.array[T + 1] = ka.y, S.array[T + 2] = ka.z, T += 3;
                  else if (4 === S.size)
                    for (ca = 0; ca < $a; ca++)
                      ka = S.value[ca], S.array[T] = ka.x, S.array[T + 1] = ka.y, S.array[T + 2] = ka.z, S.array[T + 3] = ka.w, T += 4;
          }
          if (oc || Ob.sortParticles)
            m.bindBuffer(m.ARRAY_BUFFER, ib.__webglVertexBuffer), m.bufferData(m.ARRAY_BUFFER, vb, ic);
          if (pc || Ob.sortParticles)
            m.bindBuffer(m.ARRAY_BUFFER, ib.__webglColorBuffer), m.bufferData(m.ARRAY_BUFFER, wb, ic);
          if (nb)
            for (Za = 0, zb = nb.length; Za < zb; Za++)
              if (S = nb[Za], S.needsUpdate || Ob.sortParticles)
                m.bindBuffer(m.ARRAY_BUFFER, S.buffer), m.bufferData(m.ARRAY_BUFFER, S.array, ic);
        }
        l.verticesNeedUpdate = !1;
        l.colorsNeedUpdate = !1;
        s.attributes && u(s);
      }
    }
  };
  this.initMaterial = function (a, b, c, d) {
    var e, f, g, h;
    a.addEventListener('dispose', Sb);
    var k, l, p, n;
    a instanceof THREE.MeshDepthMaterial ? n = 'depth' : a instanceof THREE.MeshNormalMaterial ? n = 'normal' : a instanceof THREE.MeshBasicMaterial ? n = 'basic' : a instanceof THREE.MeshLambertMaterial ? n = 'lambert' : a instanceof THREE.MeshPhongMaterial ? n = 'phong' : a instanceof THREE.LineBasicMaterial ? n = 'basic' : a instanceof THREE.LineDashedMaterial ? n = 'dashed' : a instanceof THREE.ParticleSystemMaterial && (n = 'particle_basic');
    n && (e = THREE.ShaderLib[n], a.uniforms = THREE.UniformsUtils.clone(e.uniforms), a.vertexShader = e.vertexShader, a.fragmentShader = e.fragmentShader);
    p = h = g = f = e = 0;
    for (var q = b.length; p < q; p++) {
      var r = b[p];
      r.onlyShadow || !1 === r.visible || (r instanceof THREE.DirectionalLight && e++, r instanceof THREE.PointLight && f++, r instanceof THREE.SpotLight && g++, r instanceof THREE.HemisphereLight && h++);
    }
    q = p = 0;
    for (r = b.length; q < r; q++) {
      var s = b[q];
      s.castShadow && (s instanceof THREE.SpotLight && p++, s instanceof THREE.DirectionalLight && !s.shadowCascade && p++);
    }
    b = p;
    Gb && d && d.skeleton && d.skeleton.useVertexTexture ? p = 1024 : (p = m.getParameter(m.MAX_VERTEX_UNIFORM_VECTORS), p = Math.floor((p - 20) / 4), void 0 !== d && d instanceof THREE.SkinnedMesh && (p = Math.min(d.skeleton.bones.length, p), p < d.skeleton.bones.length && console.warn('WebGLRenderer: too many bones - ' + d.skeleton.bones.length + ', this GPU supports just ' + p + ' (try OpenGL instead of ANGLE)')));
    c = {
      precision: Q,
      supportsVertexTextures: Jb,
      map: !!a.map,
      envMap: !!a.envMap,
      lightMap: !!a.lightMap,
      bumpMap: !!a.bumpMap,
      normalMap: !!a.normalMap,
      specularMap: !!a.specularMap,
      vertexColors: a.vertexColors,
      fog: c,
      useFog: a.fog,
      fogExp: c instanceof THREE.FogExp2,
      sizeAttenuation: a.sizeAttenuation,
      logarithmicDepthBuffer: da,
      skinning: a.skinning,
      maxBones: p,
      useVertexTexture: Gb && d && d.skeleton && d.skeleton.useVertexTexture,
      morphTargets: a.morphTargets,
      morphNormals: a.morphNormals,
      maxMorphTargets: this.maxMorphTargets,
      maxMorphNormals: this.maxMorphNormals,
      maxDirLights: e,
      maxPointLights: f,
      maxSpotLights: g,
      maxHemiLights: h,
      maxShadows: b,
      shadowMapEnabled: this.shadowMapEnabled && d.receiveShadow && 0 < b,
      shadowMapType: this.shadowMapType,
      shadowMapDebug: this.shadowMapDebug,
      shadowMapCascade: this.shadowMapCascade,
      alphaTest: a.alphaTest,
      metal: a.metal,
      wrapAround: a.wrapAround,
      doubleSided: a.side === THREE.DoubleSide,
      flipSided: a.side === THREE.BackSide
    };
    d = [];
    n ? d.push(n) : (d.push(a.fragmentShader), d.push(a.vertexShader));
    for (var u in a.defines)
      d.push(u), d.push(a.defines[u]);
    for (l in c)
      d.push(l), d.push(c[l]);
    n = d.join();
    var t;
    l = 0;
    for (u = ga.length; l < u; l++)
      if (d = ga[l], d.code === n) {
        t = d;
        t.usedTimes++;
        break;
      }
    void 0 === t && (t = new THREE.WebGLProgram(this, n, a, c), ga.push(t), P.info.memory.programs = ga.length);
    a.program = t;
    t = a.program.attributes;
    if (a.morphTargets)
      for (a.numSupportedMorphTargets = 0, u = 'morphTarget', l = 0; l < this.maxMorphTargets; l++)
        n = u + l, 0 <= t[n] && a.numSupportedMorphTargets++;
    if (a.morphNormals)
      for (a.numSupportedMorphNormals = 0, u = 'morphNormal', l = 0; l < this.maxMorphNormals; l++)
        n = u + l, 0 <= t[n] && a.numSupportedMorphNormals++;
    a.uniformsList = [];
    for (k in a.uniforms)
      a.uniformsList.push([
        a.uniforms[k],
        k
      ]);
  };
  this.setFaceCulling = function (a, b) {
    a === THREE.CullFaceNone ? m.disable(m.CULL_FACE) : (b === THREE.FrontFaceDirectionCW ? m.frontFace(m.CW) : m.frontFace(m.CCW), a === THREE.CullFaceBack ? m.cullFace(m.BACK) : a === THREE.CullFaceFront ? m.cullFace(m.FRONT) : m.cullFace(m.FRONT_AND_BACK), m.enable(m.CULL_FACE));
  };
  this.setMaterialFaces = function (a) {
    var b = a.side === THREE.DoubleSide;
    a = a.side === THREE.BackSide;
    Ga !== b && (b ? m.disable(m.CULL_FACE) : m.enable(m.CULL_FACE), Ga = b);
    ha !== a && (a ? m.frontFace(m.CW) : m.frontFace(m.CCW), ha = a);
  };
  this.setDepthTest = function (a) {
    ia !== a && (a ? m.enable(m.DEPTH_TEST) : m.disable(m.DEPTH_TEST), ia = a);
  };
  this.setDepthWrite = function (a) {
    ma !== a && (m.depthMask(a), ma = a);
  };
  this.setBlending = function (a, b, c, d) {
    a !== Oa && (a === THREE.NoBlending ? m.disable(m.BLEND) : a === THREE.AdditiveBlending ? (m.enable(m.BLEND), m.blendEquation(m.FUNC_ADD), m.blendFunc(m.SRC_ALPHA, m.ONE)) : a === THREE.SubtractiveBlending ? (m.enable(m.BLEND), m.blendEquation(m.FUNC_ADD), m.blendFunc(m.ZERO, m.ONE_MINUS_SRC_COLOR)) : a === THREE.MultiplyBlending ? (m.enable(m.BLEND), m.blendEquation(m.FUNC_ADD), m.blendFunc(m.ZERO, m.SRC_COLOR)) : a === THREE.CustomBlending ? m.enable(m.BLEND) : (m.enable(m.BLEND), m.blendEquationSeparate(m.FUNC_ADD, m.FUNC_ADD), m.blendFuncSeparate(m.SRC_ALPHA, m.ONE_MINUS_SRC_ALPHA, m.ONE, m.ONE_MINUS_SRC_ALPHA)), Oa = a);
    if (a === THREE.CustomBlending) {
      if (b !== Ra && (m.blendEquation(z(b)), Ra = b), c !== Sa || d !== Fa)
        m.blendFunc(z(c), z(d)), Sa = c, Fa = d;
    } else
      Fa = Sa = Ra = null;
  };
  this.setTexture = function (a, b) {
    if (a.needsUpdate) {
      a.__webglInit || (a.__webglInit = !0, a.addEventListener('dispose', Hb), a.__webglTexture = m.createTexture(), P.info.memory.textures++);
      m.activeTexture(m.TEXTURE0 + b);
      m.bindTexture(m.TEXTURE_2D, a.__webglTexture);
      m.pixelStorei(m.UNPACK_FLIP_Y_WEBGL, a.flipY);
      m.pixelStorei(m.UNPACK_PREMULTIPLY_ALPHA_WEBGL, a.premultiplyAlpha);
      m.pixelStorei(m.UNPACK_ALIGNMENT, a.unpackAlignment);
      var c = a.image, d = THREE.Math.isPowerOfTwo(c.width) && THREE.Math.isPowerOfTwo(c.height), e = z(a.format), f = z(a.type);
      D(m.TEXTURE_2D, a, d);
      var g = a.mipmaps;
      if (a instanceof THREE.DataTexture)
        if (0 < g.length && d) {
          for (var h = 0, k = g.length; h < k; h++)
            c = g[h], m.texImage2D(m.TEXTURE_2D, h, e, c.width, c.height, 0, e, f, c.data);
          a.generateMipmaps = !1;
        } else
          m.texImage2D(m.TEXTURE_2D, 0, e, c.width, c.height, 0, e, f, c.data);
      else if (a instanceof THREE.CompressedTexture)
        for (h = 0, k = g.length; h < k; h++)
          c = g[h], a.format !== THREE.RGBAFormat ? m.compressedTexImage2D(m.TEXTURE_2D, h, e, c.width, c.height, 0, c.data) : m.texImage2D(m.TEXTURE_2D, h, e, c.width, c.height, 0, e, f, c.data);
      else if (0 < g.length && d) {
        h = 0;
        for (k = g.length; h < k; h++)
          c = g[h], m.texImage2D(m.TEXTURE_2D, h, e, e, f, c);
        a.generateMipmaps = !1;
      } else
        m.texImage2D(m.TEXTURE_2D, 0, e, e, f, a.image);
      a.generateMipmaps && d && m.generateMipmap(m.TEXTURE_2D);
      a.needsUpdate = !1;
      if (a.onUpdate)
        a.onUpdate();
    } else
      m.activeTexture(m.TEXTURE0 + b), m.bindTexture(m.TEXTURE_2D, a.__webglTexture);
  };
  this.setRenderTarget = function (a) {
    var b = a instanceof THREE.WebGLRenderTargetCube;
    if (a && !a.__webglFramebuffer) {
      void 0 === a.depthBuffer && (a.depthBuffer = !0);
      void 0 === a.stencilBuffer && (a.stencilBuffer = !0);
      a.addEventListener('dispose', Rb);
      a.__webglTexture = m.createTexture();
      P.info.memory.textures++;
      var c = THREE.Math.isPowerOfTwo(a.width) && THREE.Math.isPowerOfTwo(a.height), d = z(a.format), e = z(a.type);
      if (b) {
        a.__webglFramebuffer = [];
        a.__webglRenderbuffer = [];
        m.bindTexture(m.TEXTURE_CUBE_MAP, a.__webglTexture);
        D(m.TEXTURE_CUBE_MAP, a, c);
        for (var f = 0; 6 > f; f++) {
          a.__webglFramebuffer[f] = m.createFramebuffer();
          a.__webglRenderbuffer[f] = m.createRenderbuffer();
          m.texImage2D(m.TEXTURE_CUBE_MAP_POSITIVE_X + f, 0, d, a.width, a.height, 0, d, e, null);
          var g = a, h = m.TEXTURE_CUBE_MAP_POSITIVE_X + f;
          m.bindFramebuffer(m.FRAMEBUFFER, a.__webglFramebuffer[f]);
          m.framebufferTexture2D(m.FRAMEBUFFER, m.COLOR_ATTACHMENT0, h, g.__webglTexture, 0);
          C(a.__webglRenderbuffer[f], a);
        }
        c && m.generateMipmap(m.TEXTURE_CUBE_MAP);
      } else
        a.__webglFramebuffer = m.createFramebuffer(), a.__webglRenderbuffer = a.shareDepthFrom ? a.shareDepthFrom.__webglRenderbuffer : m.createRenderbuffer(), m.bindTexture(m.TEXTURE_2D, a.__webglTexture), D(m.TEXTURE_2D, a, c), m.texImage2D(m.TEXTURE_2D, 0, d, a.width, a.height, 0, d, e, null), d = m.TEXTURE_2D, m.bindFramebuffer(m.FRAMEBUFFER, a.__webglFramebuffer), m.framebufferTexture2D(m.FRAMEBUFFER, m.COLOR_ATTACHMENT0, d, a.__webglTexture, 0), a.shareDepthFrom ? a.depthBuffer && !a.stencilBuffer ? m.framebufferRenderbuffer(m.FRAMEBUFFER, m.DEPTH_ATTACHMENT, m.RENDERBUFFER, a.__webglRenderbuffer) : a.depthBuffer && a.stencilBuffer && m.framebufferRenderbuffer(m.FRAMEBUFFER, m.DEPTH_STENCIL_ATTACHMENT, m.RENDERBUFFER, a.__webglRenderbuffer) : C(a.__webglRenderbuffer, a), c && m.generateMipmap(m.TEXTURE_2D);
      b ? m.bindTexture(m.TEXTURE_CUBE_MAP, null) : m.bindTexture(m.TEXTURE_2D, null);
      m.bindRenderbuffer(m.RENDERBUFFER, null);
      m.bindFramebuffer(m.FRAMEBUFFER, null);
    }
    a ? (b = b ? a.__webglFramebuffer[a.activeCubeFace] : a.__webglFramebuffer, c = a.width, a = a.height, e = d = 0) : (b = null, c = Da, a = Ja, d = Ca, e = va);
    b !== Ha && (m.bindFramebuffer(m.FRAMEBUFFER, b), m.viewport(d, e, c, a), Ha = b);
    ja = c;
    ra = a;
  };
  this.shadowMapPlugin = new THREE.ShadowMapPlugin();
  this.addPrePlugin(this.shadowMapPlugin);
  this.addPostPlugin(new THREE.SpritePlugin());
  this.addPostPlugin(new THREE.LensFlarePlugin());
};
THREE.WebGLRenderTarget = function (a, b, c) {
  this.width = a;
  this.height = b;
  c = c || {};
  this.wrapS = void 0 !== c.wrapS ? c.wrapS : THREE.ClampToEdgeWrapping;
  this.wrapT = void 0 !== c.wrapT ? c.wrapT : THREE.ClampToEdgeWrapping;
  this.magFilter = void 0 !== c.magFilter ? c.magFilter : THREE.LinearFilter;
  this.minFilter = void 0 !== c.minFilter ? c.minFilter : THREE.LinearMipMapLinearFilter;
  this.anisotropy = void 0 !== c.anisotropy ? c.anisotropy : 1;
  this.offset = new THREE.Vector2(0, 0);
  this.repeat = new THREE.Vector2(1, 1);
  this.format = void 0 !== c.format ? c.format : THREE.RGBAFormat;
  this.type = void 0 !== c.type ? c.type : THREE.UnsignedByteType;
  this.depthBuffer = void 0 !== c.depthBuffer ? c.depthBuffer : !0;
  this.stencilBuffer = void 0 !== c.stencilBuffer ? c.stencilBuffer : !0;
  this.generateMipmaps = !0;
  this.shareDepthFrom = null;
};
THREE.WebGLRenderTarget.prototype = {
  constructor: THREE.WebGLRenderTarget,
  setSize: function (a, b) {
    this.width = a;
    this.height = b;
  },
  clone: function () {
    var a = new THREE.WebGLRenderTarget(this.width, this.height);
    a.wrapS = this.wrapS;
    a.wrapT = this.wrapT;
    a.magFilter = this.magFilter;
    a.minFilter = this.minFilter;
    a.anisotropy = this.anisotropy;
    a.offset.copy(this.offset);
    a.repeat.copy(this.repeat);
    a.format = this.format;
    a.type = this.type;
    a.depthBuffer = this.depthBuffer;
    a.stencilBuffer = this.stencilBuffer;
    a.generateMipmaps = this.generateMipmaps;
    a.shareDepthFrom = this.shareDepthFrom;
    return a;
  },
  dispose: function () {
    this.dispatchEvent({ type: 'dispose' });
  }
};
THREE.EventDispatcher.prototype.apply(THREE.WebGLRenderTarget.prototype);
THREE.WebGLRenderTargetCube = function (a, b, c) {
  THREE.WebGLRenderTarget.call(this, a, b, c);
  this.activeCubeFace = 0;
};
THREE.WebGLRenderTargetCube.prototype = Object.create(THREE.WebGLRenderTarget.prototype);
THREE.WebGLProgram = function () {
  var a = 0;
  return function (b, c, d, e) {
    var f = b.context, g = d.fragmentShader, h = d.vertexShader, k = d.uniforms, l = d.attributes, n = d.defines, q = d.index0AttributeName;
    void 0 === q && !0 === e.morphTargets && (q = 'position');
    var p = 'SHADOWMAP_TYPE_BASIC';
    e.shadowMapType === THREE.PCFShadowMap ? p = 'SHADOWMAP_TYPE_PCF' : e.shadowMapType === THREE.PCFSoftShadowMap && (p = 'SHADOWMAP_TYPE_PCF_SOFT');
    var s, t;
    s = [];
    for (var r in n)
      t = n[r], !1 !== t && (t = '#define ' + r + ' ' + t, s.push(t));
    s = s.join('\n');
    n = f.createProgram();
    d instanceof THREE.RawShaderMaterial ? b = d = '' : (d = [
      'precision ' + e.precision + ' float;',
      'precision ' + e.precision + ' int;',
      s,
      e.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',
      b.gammaInput ? '#define GAMMA_INPUT' : '',
      b.gammaOutput ? '#define GAMMA_OUTPUT' : '',
      '#define MAX_DIR_LIGHTS ' + e.maxDirLights,
      '#define MAX_POINT_LIGHTS ' + e.maxPointLights,
      '#define MAX_SPOT_LIGHTS ' + e.maxSpotLights,
      '#define MAX_HEMI_LIGHTS ' + e.maxHemiLights,
      '#define MAX_SHADOWS ' + e.maxShadows,
      '#define MAX_BONES ' + e.maxBones,
      e.map ? '#define USE_MAP' : '',
      e.envMap ? '#define USE_ENVMAP' : '',
      e.lightMap ? '#define USE_LIGHTMAP' : '',
      e.bumpMap ? '#define USE_BUMPMAP' : '',
      e.normalMap ? '#define USE_NORMALMAP' : '',
      e.specularMap ? '#define USE_SPECULARMAP' : '',
      e.vertexColors ? '#define USE_COLOR' : '',
      e.skinning ? '#define USE_SKINNING' : '',
      e.useVertexTexture ? '#define BONE_TEXTURE' : '',
      e.morphTargets ? '#define USE_MORPHTARGETS' : '',
      e.morphNormals ? '#define USE_MORPHNORMALS' : '',
      e.wrapAround ? '#define WRAP_AROUND' : '',
      e.doubleSided ? '#define DOUBLE_SIDED' : '',
      e.flipSided ? '#define FLIP_SIDED' : '',
      e.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
      e.shadowMapEnabled ? '#define ' + p : '',
      e.shadowMapDebug ? '#define SHADOWMAP_DEBUG' : '',
      e.shadowMapCascade ? '#define SHADOWMAP_CASCADE' : '',
      e.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',
      e.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
      'uniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\nattribute vec2 uv2;\n#ifdef USE_COLOR\n\tattribute vec3 color;\n#endif\n#ifdef USE_MORPHTARGETS\n\tattribute vec3 morphTarget0;\n\tattribute vec3 morphTarget1;\n\tattribute vec3 morphTarget2;\n\tattribute vec3 morphTarget3;\n\t#ifdef USE_MORPHNORMALS\n\t\tattribute vec3 morphNormal0;\n\t\tattribute vec3 morphNormal1;\n\t\tattribute vec3 morphNormal2;\n\t\tattribute vec3 morphNormal3;\n\t#else\n\t\tattribute vec3 morphTarget4;\n\t\tattribute vec3 morphTarget5;\n\t\tattribute vec3 morphTarget6;\n\t\tattribute vec3 morphTarget7;\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tattribute vec4 skinIndex;\n\tattribute vec4 skinWeight;\n#endif\n'
    ].join('\n'), b = [
      'precision ' + e.precision + ' float;',
      'precision ' + e.precision + ' int;',
      e.bumpMap || e.normalMap ? '#extension GL_OES_standard_derivatives : enable' : '',
      s,
      '#define MAX_DIR_LIGHTS ' + e.maxDirLights,
      '#define MAX_POINT_LIGHTS ' + e.maxPointLights,
      '#define MAX_SPOT_LIGHTS ' + e.maxSpotLights,
      '#define MAX_HEMI_LIGHTS ' + e.maxHemiLights,
      '#define MAX_SHADOWS ' + e.maxShadows,
      e.alphaTest ? '#define ALPHATEST ' + e.alphaTest : '',
      b.gammaInput ? '#define GAMMA_INPUT' : '',
      b.gammaOutput ? '#define GAMMA_OUTPUT' : '',
      e.useFog && e.fog ? '#define USE_FOG' : '',
      e.useFog && e.fogExp ? '#define FOG_EXP2' : '',
      e.map ? '#define USE_MAP' : '',
      e.envMap ? '#define USE_ENVMAP' : '',
      e.lightMap ? '#define USE_LIGHTMAP' : '',
      e.bumpMap ? '#define USE_BUMPMAP' : '',
      e.normalMap ? '#define USE_NORMALMAP' : '',
      e.specularMap ? '#define USE_SPECULARMAP' : '',
      e.vertexColors ? '#define USE_COLOR' : '',
      e.metal ? '#define METAL' : '',
      e.wrapAround ? '#define WRAP_AROUND' : '',
      e.doubleSided ? '#define DOUBLE_SIDED' : '',
      e.flipSided ? '#define FLIP_SIDED' : '',
      e.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
      e.shadowMapEnabled ? '#define ' + p : '',
      e.shadowMapDebug ? '#define SHADOWMAP_DEBUG' : '',
      e.shadowMapCascade ? '#define SHADOWMAP_CASCADE' : '',
      e.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
      'uniform mat4 viewMatrix;\nuniform vec3 cameraPosition;\n'
    ].join('\n'));
    h = new THREE.WebGLShader(f, f.VERTEX_SHADER, d + h);
    g = new THREE.WebGLShader(f, f.FRAGMENT_SHADER, b + g);
    f.attachShader(n, h);
    f.attachShader(n, g);
    void 0 !== q && f.bindAttribLocation(n, 0, q);
    f.linkProgram(n);
    !1 === f.getProgramParameter(n, f.LINK_STATUS) && (console.error('Could not initialise shader'), console.error('gl.VALIDATE_STATUS', f.getProgramParameter(n, f.VALIDATE_STATUS)), console.error('gl.getError()', f.getError()));
    '' !== f.getProgramInfoLog(n) && console.error('gl.getProgramInfoLog()', f.getProgramInfoLog(n));
    f.deleteShader(h);
    f.deleteShader(g);
    q = 'viewMatrix modelViewMatrix projectionMatrix normalMatrix modelMatrix cameraPosition morphTargetInfluences'.split(' ');
    e.useVertexTexture ? (q.push('boneTexture'), q.push('boneTextureWidth'), q.push('boneTextureHeight')) : q.push('boneGlobalMatrices');
    e.logarithmicDepthBuffer && q.push('logDepthBufFC');
    for (var v in k)
      q.push(v);
    k = q;
    v = {};
    q = 0;
    for (b = k.length; q < b; q++)
      p = k[q], v[p] = f.getUniformLocation(n, p);
    this.uniforms = v;
    q = 'position normal uv uv2 tangent color skinIndex skinWeight lineDistance'.split(' ');
    for (k = 0; k < e.maxMorphTargets; k++)
      q.push('morphTarget' + k);
    for (k = 0; k < e.maxMorphNormals; k++)
      q.push('morphNormal' + k);
    for (var w in l)
      q.push(w);
    e = q;
    l = {};
    w = 0;
    for (k = e.length; w < k; w++)
      v = e[w], l[v] = f.getAttribLocation(n, v);
    this.attributes = l;
    this.id = a++;
    this.code = c;
    this.usedTimes = 1;
    this.program = n;
    this.vertexShader = h;
    this.fragmentShader = g;
    return this;
  };
}();
THREE.WebGLShader = function () {
  var a = function (a) {
    a = a.split('\n');
    for (var c = 0; c < a.length; c++)
      a[c] = c + 1 + ': ' + a[c];
    return a.join('\n');
  };
  return function (b, c, d) {
    c = b.createShader(c);
    b.shaderSource(c, d);
    b.compileShader(c);
    !1 === b.getShaderParameter(c, b.COMPILE_STATUS) && console.error('THREE.WebGLShader: Shader couldn\'t compile.');
    '' !== b.getShaderInfoLog(c) && (console.error('THREE.WebGLShader:', 'gl.getShaderInfoLog()', b.getShaderInfoLog(c)), console.error(a(d)));
    return c;
  };
}();
THREE.RenderableVertex = function () {
  this.position = new THREE.Vector3();
  this.positionWorld = new THREE.Vector3();
  this.positionScreen = new THREE.Vector4();
  this.visible = !0;
};
THREE.RenderableVertex.prototype.copy = function (a) {
  this.positionWorld.copy(a.positionWorld);
  this.positionScreen.copy(a.positionScreen);
};
THREE.RenderableFace = function () {
  this.id = 0;
  this.v1 = new THREE.RenderableVertex();
  this.v2 = new THREE.RenderableVertex();
  this.v3 = new THREE.RenderableVertex();
  this.normalModel = new THREE.Vector3();
  this.vertexNormalsModel = [
    new THREE.Vector3(),
    new THREE.Vector3(),
    new THREE.Vector3()
  ];
  this.vertexNormalsLength = 0;
  this.material = this.color = null;
  this.uvs = [
    new THREE.Vector2(),
    new THREE.Vector2(),
    new THREE.Vector2()
  ];
  this.z = 0;
};
THREE.RenderableObject = function () {
  this.id = 0;
  this.object = null;
  this.z = 0;
};
THREE.RenderableSprite = function () {
  this.id = 0;
  this.object = null;
  this.rotation = this.z = this.y = this.x = 0;
  this.scale = new THREE.Vector2();
  this.material = null;
};
THREE.RenderableLine = function () {
  this.id = 0;
  this.v1 = new THREE.RenderableVertex();
  this.v2 = new THREE.RenderableVertex();
  this.vertexColors = [
    new THREE.Color(),
    new THREE.Color()
  ];
  this.material = null;
  this.z = 0;
};
THREE.GeometryUtils = {
  merge: function (a, b, c) {
    console.warn('DEPRECATED: GeometryUtils\'s .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.');
    var d;
    b instanceof THREE.Mesh && (b.matrixAutoUpdate && b.updateMatrix(), d = b.matrix, b = b.geometry);
    a.merge(b, d, c);
  },
  randomPointInTriangle: function () {
    var a = new THREE.Vector3();
    return function (b, c, d) {
      var e = new THREE.Vector3(), f = THREE.Math.random16(), g = THREE.Math.random16();
      1 < f + g && (f = 1 - f, g = 1 - g);
      var h = 1 - f - g;
      e.copy(b);
      e.multiplyScalar(f);
      a.copy(c);
      a.multiplyScalar(g);
      e.add(a);
      a.copy(d);
      a.multiplyScalar(h);
      e.add(a);
      return e;
    };
  }(),
  randomPointInFace: function (a, b, c) {
    return THREE.GeometryUtils.randomPointInTriangle(b.vertices[a.a], b.vertices[a.b], b.vertices[a.c]);
  },
  randomPointsInGeometry: function (a, b) {
    function c(a) {
      function b(c, d) {
        if (d < c)
          return c;
        var e = c + Math.floor((d - c) / 2);
        return l[e] > a ? b(c, e - 1) : l[e] < a ? b(e + 1, d) : e;
      }
      return b(0, l.length - 1);
    }
    var d, e, f = a.faces, g = a.vertices, h = f.length, k = 0, l = [], n, q, p;
    for (e = 0; e < h; e++)
      d = f[e], n = g[d.a], q = g[d.b], p = g[d.c], d._area = THREE.GeometryUtils.triangleArea(n, q, p), k += d._area, l[e] = k;
    d = [];
    for (e = 0; e < b; e++)
      g = THREE.Math.random16() * k, g = c(g), d[e] = THREE.GeometryUtils.randomPointInFace(f[g], a, !0);
    return d;
  },
  triangleArea: function () {
    var a = new THREE.Vector3(), b = new THREE.Vector3();
    return function (c, d, e) {
      a.subVectors(d, c);
      b.subVectors(e, c);
      a.cross(b);
      return 0.5 * a.length();
    };
  }(),
  center: function (a) {
    a.computeBoundingBox();
    var b = a.boundingBox, c = new THREE.Vector3();
    c.addVectors(b.min, b.max);
    c.multiplyScalar(-0.5);
    a.applyMatrix(new THREE.Matrix4().makeTranslation(c.x, c.y, c.z));
    a.computeBoundingBox();
    return c;
  }
};
THREE.ImageUtils = {
  crossOrigin: void 0,
  loadTexture: function (a, b, c, d) {
    var e = new THREE.ImageLoader();
    e.crossOrigin = this.crossOrigin;
    var f = new THREE.Texture(void 0, b);
    b = e.load(a, function () {
      f.needsUpdate = !0;
      c && c(f);
    }, void 0, function (a) {
      d && d(a);
    });
    f.image = b;
    f.sourceFile = a;
    return f;
  },
  loadCompressedTexture: function (a, b, c, d) {
    var e = new THREE.CompressedTexture();
    e.mapping = b;
    var f = new XMLHttpRequest();
    f.onload = function () {
      var a = THREE.ImageUtils.parseDDS(f.response, !0);
      e.format = a.format;
      e.mipmaps = a.mipmaps;
      e.image.width = a.width;
      e.image.height = a.height;
      e.generateMipmaps = !1;
      e.needsUpdate = !0;
      c && c(e);
    };
    f.onerror = d;
    f.open('GET', a, !0);
    f.responseType = 'arraybuffer';
    f.send(null);
    return e;
  },
  loadTextureCube: function (a, b, c, d) {
    var e = [];
    e.loadCount = 0;
    d = new THREE.ImageLoader();
    d.crossOrigin = this.crossOrigin;
    var f = new THREE.Texture();
    f.image = e;
    void 0 !== b && (f.mapping = b);
    f.flipY = !1;
    b = 0;
    for (var g = a.length; b < g; ++b) {
      var h = d.load(a[b], function () {
          e.loadCount += 1;
          6 === e.loadCount && (f.needsUpdate = !0, c && c(f));
        });
      e[b] = h;
    }
    return f;
  },
  loadCompressedTextureCube: function (a, b, c, d) {
    var e = [];
    e.loadCount = 0;
    var f = new THREE.CompressedTexture();
    f.image = e;
    void 0 !== b && (f.mapping = b);
    f.flipY = !1;
    f.generateMipmaps = !1;
    b = function (a, b) {
      return function () {
        var d = THREE.ImageUtils.parseDDS(a.response, !0);
        b.format = d.format;
        b.mipmaps = d.mipmaps;
        b.width = d.width;
        b.height = d.height;
        e.loadCount += 1;
        6 === e.loadCount && (f.format = d.format, f.needsUpdate = !0, c && c(f));
      };
    };
    if (a instanceof Array)
      for (var g = 0, h = a.length; g < h; ++g) {
        var k = {};
        e[g] = k;
        var l = new XMLHttpRequest();
        l.onload = b(l, k);
        l.onerror = d;
        k = a[g];
        l.open('GET', k, !0);
        l.responseType = 'arraybuffer';
        l.send(null);
      }
    else
      l = new XMLHttpRequest(), l.onload = function () {
        var a = THREE.ImageUtils.parseDDS(l.response, !0);
        if (a.isCubemap) {
          for (var b = a.mipmaps.length / a.mipmapCount, d = 0; d < b; d++) {
            e[d] = { mipmaps: [] };
            for (var g = 0; g < a.mipmapCount; g++)
              e[d].mipmaps.push(a.mipmaps[d * a.mipmapCount + g]), e[d].format = a.format, e[d].width = a.width, e[d].height = a.height;
          }
          f.format = a.format;
          f.needsUpdate = !0;
          c && c(f);
        }
      }, l.onerror = d, l.open('GET', a, !0), l.responseType = 'arraybuffer', l.send(null);
    return f;
  },
  loadDDSTexture: function (a, b, c, d) {
    var e = [];
    e.loadCount = 0;
    var f = new THREE.CompressedTexture();
    f.image = e;
    void 0 !== b && (f.mapping = b);
    f.flipY = !1;
    f.generateMipmaps = !1;
    var g = new XMLHttpRequest();
    g.onload = function () {
      var a = THREE.ImageUtils.parseDDS(g.response, !0);
      if (a.isCubemap)
        for (var b = a.mipmaps.length / a.mipmapCount, d = 0; d < b; d++) {
          e[d] = { mipmaps: [] };
          for (var n = 0; n < a.mipmapCount; n++)
            e[d].mipmaps.push(a.mipmaps[d * a.mipmapCount + n]), e[d].format = a.format, e[d].width = a.width, e[d].height = a.height;
        }
      else
        f.image.width = a.width, f.image.height = a.height, f.mipmaps = a.mipmaps;
      f.format = a.format;
      f.needsUpdate = !0;
      c && c(f);
    };
    g.onerror = d;
    g.open('GET', a, !0);
    g.responseType = 'arraybuffer';
    g.send(null);
    return f;
  },
  parseDDS: function (a, b) {
    function c(a) {
      return a.charCodeAt(0) + (a.charCodeAt(1) << 8) + (a.charCodeAt(2) << 16) + (a.charCodeAt(3) << 24);
    }
    function d(a, b, c, d) {
      var e = c * d * 4;
      a = new Uint8Array(a, b, e);
      for (var e = new Uint8Array(e), f = b = 0, g = 0; g < d; g++)
        for (var h = 0; h < c; h++) {
          var k = a[f];
          f++;
          var l = a[f];
          f++;
          var p = a[f];
          f++;
          var n = a[f];
          f++;
          e[b] = p;
          b++;
          e[b] = l;
          b++;
          e[b] = k;
          b++;
          e[b] = n;
          b++;
        }
      return e;
    }
    var e = {
        mipmaps: [],
        width: 0,
        height: 0,
        format: null,
        mipmapCount: 1
      }, f = c('DXT1'), g = c('DXT3'), h = c('DXT5'), k = new Int32Array(a, 0, 31);
    if (542327876 !== k[0])
      return console.error('ImageUtils.parseDDS(): Invalid magic number in DDS header'), e;
    if (!k[20] & 4)
      return console.error('ImageUtils.parseDDS(): Unsupported format, must contain a FourCC code'), e;
    var l = k[21], n = !1;
    switch (l) {
    case f:
      f = 8;
      e.format = THREE.RGB_S3TC_DXT1_Format;
      break;
    case g:
      f = 16;
      e.format = THREE.RGBA_S3TC_DXT3_Format;
      break;
    case h:
      f = 16;
      e.format = THREE.RGBA_S3TC_DXT5_Format;
      break;
    default:
      if (32 == k[22] && k[23] & 16711680 && k[24] & 65280 && k[25] & 255 && k[26] & 4278190080)
        n = !0, f = 64, e.format = THREE.RGBAFormat;
      else
        return console.error('ImageUtils.parseDDS(): Unsupported FourCC code: ', String.fromCharCode(l & 255, l >> 8 & 255, l >> 16 & 255, l >> 24 & 255)), e;
    }
    e.mipmapCount = 1;
    k[2] & 131072 && !1 !== b && (e.mipmapCount = Math.max(1, k[7]));
    e.isCubemap = k[28] & 512 ? !0 : !1;
    e.width = k[4];
    e.height = k[3];
    for (var k = k[1] + 4, g = e.width, h = e.height, l = e.isCubemap ? 6 : 1, q = 0; q < l; q++) {
      for (var p = 0; p < e.mipmapCount; p++) {
        if (n)
          var s = d(a, k, g, h), t = s.length;
        else
          t = Math.max(4, g) / 4 * Math.max(4, h) / 4 * f, s = new Uint8Array(a, k, t);
        e.mipmaps.push({
          data: s,
          width: g,
          height: h
        });
        k += t;
        g = Math.max(0.5 * g, 1);
        h = Math.max(0.5 * h, 1);
      }
      g = e.width;
      h = e.height;
    }
    return e;
  },
  getNormalMap: function (a, b) {
    var c = function (a) {
      var b = Math.sqrt(a[0] * a[0] + a[1] * a[1] + a[2] * a[2]);
      return [
        a[0] / b,
        a[1] / b,
        a[2] / b
      ];
    };
    b |= 1;
    var d = a.width, e = a.height, f = document.createElement('canvas');
    f.width = d;
    f.height = e;
    var g = f.getContext('2d');
    g.drawImage(a, 0, 0);
    for (var h = g.getImageData(0, 0, d, e).data, k = g.createImageData(d, e), l = k.data, n = 0; n < d; n++)
      for (var q = 0; q < e; q++) {
        var p = 0 > q - 1 ? 0 : q - 1, s = q + 1 > e - 1 ? e - 1 : q + 1, t = 0 > n - 1 ? 0 : n - 1, r = n + 1 > d - 1 ? d - 1 : n + 1, v = [], w = [
            0,
            0,
            h[4 * (q * d + n)] / 255 * b
          ];
        v.push([
          -1,
          0,
          h[4 * (q * d + t)] / 255 * b
        ]);
        v.push([
          -1,
          -1,
          h[4 * (p * d + t)] / 255 * b
        ]);
        v.push([
          0,
          -1,
          h[4 * (p * d + n)] / 255 * b
        ]);
        v.push([
          1,
          -1,
          h[4 * (p * d + r)] / 255 * b
        ]);
        v.push([
          1,
          0,
          h[4 * (q * d + r)] / 255 * b
        ]);
        v.push([
          1,
          1,
          h[4 * (s * d + r)] / 255 * b
        ]);
        v.push([
          0,
          1,
          h[4 * (s * d + n)] / 255 * b
        ]);
        v.push([
          -1,
          1,
          h[4 * (s * d + t)] / 255 * b
        ]);
        p = [];
        t = v.length;
        for (s = 0; s < t; s++) {
          var r = v[s], u = v[(s + 1) % t], r = [
              r[0] - w[0],
              r[1] - w[1],
              r[2] - w[2]
            ], u = [
              u[0] - w[0],
              u[1] - w[1],
              u[2] - w[2]
            ];
          p.push(c([
            r[1] * u[2] - r[2] * u[1],
            r[2] * u[0] - r[0] * u[2],
            r[0] * u[1] - r[1] * u[0]
          ]));
        }
        v = [
          0,
          0,
          0
        ];
        for (s = 0; s < p.length; s++)
          v[0] += p[s][0], v[1] += p[s][1], v[2] += p[s][2];
        v[0] /= p.length;
        v[1] /= p.length;
        v[2] /= p.length;
        w = 4 * (q * d + n);
        l[w] = (v[0] + 1) / 2 * 255 | 0;
        l[w + 1] = (v[1] + 1) / 2 * 255 | 0;
        l[w + 2] = 255 * v[2] | 0;
        l[w + 3] = 255;
      }
    g.putImageData(k, 0, 0);
    return f;
  },
  generateDataTexture: function (a, b, c) {
    var d = a * b, e = new Uint8Array(3 * d), f = Math.floor(255 * c.r), g = Math.floor(255 * c.g);
    c = Math.floor(255 * c.b);
    for (var h = 0; h < d; h++)
      e[3 * h] = f, e[3 * h + 1] = g, e[3 * h + 2] = c;
    a = new THREE.DataTexture(e, a, b, THREE.RGBFormat);
    a.needsUpdate = !0;
    return a;
  }
};
THREE.SceneUtils = {
  createMultiMaterialObject: function (a, b) {
    for (var c = new THREE.Object3D(), d = 0, e = b.length; d < e; d++)
      c.add(new THREE.Mesh(a, b[d]));
    return c;
  },
  detach: function (a, b, c) {
    a.applyMatrix(b.matrixWorld);
    b.remove(a);
    c.add(a);
  },
  attach: function (a, b, c) {
    var d = new THREE.Matrix4();
    d.getInverse(c.matrixWorld);
    a.applyMatrix(d);
    b.remove(a);
    c.add(a);
  }
};
THREE.FontUtils = {
  faces: {},
  face: 'helvetiker',
  weight: 'normal',
  style: 'normal',
  size: 150,
  divisions: 10,
  getFace: function () {
    return this.faces[this.face][this.weight][this.style];
  },
  loadFace: function (a) {
    var b = a.familyName.toLowerCase();
    this.faces[b] = this.faces[b] || {};
    this.faces[b][a.cssFontWeight] = this.faces[b][a.cssFontWeight] || {};
    this.faces[b][a.cssFontWeight][a.cssFontStyle] = a;
    return this.faces[b][a.cssFontWeight][a.cssFontStyle] = a;
  },
  drawText: function (a) {
    var b = this.getFace(), c = this.size / b.resolution, d = 0, e = String(a).split(''), f = e.length, g = [];
    for (a = 0; a < f; a++) {
      var h = new THREE.Path(), h = this.extractGlyphPoints(e[a], b, c, d, h), d = d + h.offset;
      g.push(h.path);
    }
    return {
      paths: g,
      offset: d / 2
    };
  },
  extractGlyphPoints: function (a, b, c, d, e) {
    var f = [], g, h, k, l, n, q, p, s, t, r, v, w = b.glyphs[a] || b.glyphs['?'];
    if (w) {
      if (w.o)
        for (b = w._cachedOutline || (w._cachedOutline = w.o.split(' ')), l = b.length, a = 0; a < l;)
          switch (k = b[a++], k) {
          case 'm':
            k = b[a++] * c + d;
            n = b[a++] * c;
            e.moveTo(k, n);
            break;
          case 'l':
            k = b[a++] * c + d;
            n = b[a++] * c;
            e.lineTo(k, n);
            break;
          case 'q':
            k = b[a++] * c + d;
            n = b[a++] * c;
            s = b[a++] * c + d;
            t = b[a++] * c;
            e.quadraticCurveTo(s, t, k, n);
            if (g = f[f.length - 1])
              for (q = g.x, p = g.y, g = 1, h = this.divisions; g <= h; g++) {
                var u = g / h;
                THREE.Shape.Utils.b2(u, q, s, k);
                THREE.Shape.Utils.b2(u, p, t, n);
              }
            break;
          case 'b':
            if (k = b[a++] * c + d, n = b[a++] * c, s = b[a++] * c + d, t = b[a++] * -c, r = b[a++] * c + d, v = b[a++] * -c, e.bezierCurveTo(k, n, s, t, r, v), g = f[f.length - 1])
              for (q = g.x, p = g.y, g = 1, h = this.divisions; g <= h; g++)
                u = g / h, THREE.Shape.Utils.b3(u, q, s, r, k), THREE.Shape.Utils.b3(u, p, t, v, n);
          }
      return {
        offset: w.ha * c,
        path: e
      };
    }
  }
};
THREE.FontUtils.generateShapes = function (a, b) {
  b = b || {};
  var c = void 0 !== b.curveSegments ? b.curveSegments : 4, d = void 0 !== b.font ? b.font : 'helvetiker', e = void 0 !== b.weight ? b.weight : 'normal', f = void 0 !== b.style ? b.style : 'normal';
  THREE.FontUtils.size = void 0 !== b.size ? b.size : 100;
  THREE.FontUtils.divisions = c;
  THREE.FontUtils.face = d;
  THREE.FontUtils.weight = e;
  THREE.FontUtils.style = f;
  c = THREE.FontUtils.drawText(a).paths;
  d = [];
  e = 0;
  for (f = c.length; e < f; e++)
    Array.prototype.push.apply(d, c[e].toShapes());
  return d;
};
(function (a) {
  var b = function (a) {
    for (var b = a.length, e = 0, f = b - 1, g = 0; g < b; f = g++)
      e += a[f].x * a[g].y - a[g].x * a[f].y;
    return 0.5 * e;
  };
  a.Triangulate = function (a, d) {
    var e = a.length;
    if (3 > e)
      return null;
    var f = [], g = [], h = [], k, l, n;
    if (0 < b(a))
      for (l = 0; l < e; l++)
        g[l] = l;
    else
      for (l = 0; l < e; l++)
        g[l] = e - 1 - l;
    var q = 2 * e;
    for (l = e - 1; 2 < e;) {
      if (0 >= q--) {
        console.log('Warning, unable to triangulate polygon!');
        break;
      }
      k = l;
      e <= k && (k = 0);
      l = k + 1;
      e <= l && (l = 0);
      n = l + 1;
      e <= n && (n = 0);
      var p;
      a: {
        var s = p = void 0, t = void 0, r = void 0, v = void 0, w = void 0, u = void 0, y = void 0, L = void 0, s = a[g[k]].x, t = a[g[k]].y, r = a[g[l]].x, v = a[g[l]].y, w = a[g[n]].x, u = a[g[n]].y;
        if (1e-10 > (r - s) * (u - t) - (v - t) * (w - s))
          p = !1;
        else {
          var x = void 0, N = void 0, J = void 0, B = void 0, K = void 0, A = void 0, G = void 0, D = void 0, C = void 0, F = void 0, C = D = G = L = y = void 0, x = w - r, N = u - v, J = s - w, B = t - u, K = r - s, A = v - t;
          for (p = 0; p < e; p++)
            if (y = a[g[p]].x, L = a[g[p]].y, !(y === s && L === t || y === r && L === v || y === w && L === u) && (G = y - s, D = L - t, C = y - r, F = L - v, y -= w, L -= u, C = x * F - N * C, G = K * D - A * G, D = J * L - B * y, -1e-10 <= C && -1e-10 <= D && -1e-10 <= G)) {
              p = !1;
              break a;
            }
          p = !0;
        }
      }
      if (p) {
        f.push([
          a[g[k]],
          a[g[l]],
          a[g[n]]
        ]);
        h.push([
          g[k],
          g[l],
          g[n]
        ]);
        k = l;
        for (n = l + 1; n < e; k++, n++)
          g[k] = g[n];
        e--;
        q = 2 * e;
      }
    }
    return d ? h : f;
  };
  a.Triangulate.area = b;
  return a;
}(THREE.FontUtils));
self._typeface_js = {
  faces: THREE.FontUtils.faces,
  loadFace: THREE.FontUtils.loadFace
};
THREE.typeface_js = self._typeface_js;
THREE.Curve = function () {
};
THREE.Curve.prototype.getPoint = function (a) {
  console.log('Warning, getPoint() not implemented!');
  return null;
};
THREE.Curve.prototype.getPointAt = function (a) {
  a = this.getUtoTmapping(a);
  return this.getPoint(a);
};
THREE.Curve.prototype.getPoints = function (a) {
  a || (a = 5);
  var b, c = [];
  for (b = 0; b <= a; b++)
    c.push(this.getPoint(b / a));
  return c;
};
THREE.Curve.prototype.getSpacedPoints = function (a) {
  a || (a = 5);
  var b, c = [];
  for (b = 0; b <= a; b++)
    c.push(this.getPointAt(b / a));
  return c;
};
THREE.Curve.prototype.getLength = function () {
  var a = this.getLengths();
  return a[a.length - 1];
};
THREE.Curve.prototype.getLengths = function (a) {
  a || (a = this.__arcLengthDivisions ? this.__arcLengthDivisions : 200);
  if (this.cacheArcLengths && this.cacheArcLengths.length == a + 1 && !this.needsUpdate)
    return this.cacheArcLengths;
  this.needsUpdate = !1;
  var b = [], c, d = this.getPoint(0), e, f = 0;
  b.push(0);
  for (e = 1; e <= a; e++)
    c = this.getPoint(e / a), f += c.distanceTo(d), b.push(f), d = c;
  return this.cacheArcLengths = b;
};
THREE.Curve.prototype.updateArcLengths = function () {
  this.needsUpdate = !0;
  this.getLengths();
};
THREE.Curve.prototype.getUtoTmapping = function (a, b) {
  var c = this.getLengths(), d = 0, e = c.length, f;
  f = b ? b : a * c[e - 1];
  for (var g = 0, h = e - 1, k; g <= h;)
    if (d = Math.floor(g + (h - g) / 2), k = c[d] - f, 0 > k)
      g = d + 1;
    else if (0 < k)
      h = d - 1;
    else {
      h = d;
      break;
    }
  d = h;
  if (c[d] == f)
    return d / (e - 1);
  g = c[d];
  return c = (d + (f - g) / (c[d + 1] - g)) / (e - 1);
};
THREE.Curve.prototype.getTangent = function (a) {
  var b = a - 0.0001;
  a += 0.0001;
  0 > b && (b = 0);
  1 < a && (a = 1);
  b = this.getPoint(b);
  return this.getPoint(a).clone().sub(b).normalize();
};
THREE.Curve.prototype.getTangentAt = function (a) {
  a = this.getUtoTmapping(a);
  return this.getTangent(a);
};
THREE.Curve.Utils = {
  tangentQuadraticBezier: function (a, b, c, d) {
    return 2 * (1 - a) * (c - b) + 2 * a * (d - c);
  },
  tangentCubicBezier: function (a, b, c, d, e) {
    return -3 * b * (1 - a) * (1 - a) + 3 * c * (1 - a) * (1 - a) - 6 * a * c * (1 - a) + 6 * a * d * (1 - a) - 3 * a * a * d + 3 * a * a * e;
  },
  tangentSpline: function (a, b, c, d, e) {
    return 6 * a * a - 6 * a + (3 * a * a - 4 * a + 1) + (-6 * a * a + 6 * a) + (3 * a * a - 2 * a);
  },
  interpolate: function (a, b, c, d, e) {
    a = 0.5 * (c - a);
    d = 0.5 * (d - b);
    var f = e * e;
    return (2 * b - 2 * c + a + d) * e * f + (-3 * b + 3 * c - 2 * a - d) * f + a * e + b;
  }
};
THREE.Curve.create = function (a, b) {
  a.prototype = Object.create(THREE.Curve.prototype);
  a.prototype.getPoint = b;
  return a;
};
THREE.CurvePath = function () {
  this.curves = [];
  this.bends = [];
  this.autoClose = !1;
};
THREE.CurvePath.prototype = Object.create(THREE.Curve.prototype);
THREE.CurvePath.prototype.add = function (a) {
  this.curves.push(a);
};
THREE.CurvePath.prototype.checkConnection = function () {
};
THREE.CurvePath.prototype.closePath = function () {
  var a = this.curves[0].getPoint(0), b = this.curves[this.curves.length - 1].getPoint(1);
  a.equals(b) || this.curves.push(new THREE.LineCurve(b, a));
};
THREE.CurvePath.prototype.getPoint = function (a) {
  var b = a * this.getLength(), c = this.getCurveLengths();
  for (a = 0; a < c.length;) {
    if (c[a] >= b)
      return b = c[a] - b, a = this.curves[a], b = 1 - b / a.getLength(), a.getPointAt(b);
    a++;
  }
  return null;
};
THREE.CurvePath.prototype.getLength = function () {
  var a = this.getCurveLengths();
  return a[a.length - 1];
};
THREE.CurvePath.prototype.getCurveLengths = function () {
  if (this.cacheLengths && this.cacheLengths.length == this.curves.length)
    return this.cacheLengths;
  var a = [], b = 0, c, d = this.curves.length;
  for (c = 0; c < d; c++)
    b += this.curves[c].getLength(), a.push(b);
  return this.cacheLengths = a;
};
THREE.CurvePath.prototype.getBoundingBox = function () {
  var a = this.getPoints(), b, c, d, e, f, g;
  b = c = Number.NEGATIVE_INFINITY;
  e = f = Number.POSITIVE_INFINITY;
  var h, k, l, n, q = a[0] instanceof THREE.Vector3;
  n = q ? new THREE.Vector3() : new THREE.Vector2();
  k = 0;
  for (l = a.length; k < l; k++)
    h = a[k], h.x > b ? b = h.x : h.x < e && (e = h.x), h.y > c ? c = h.y : h.y < f && (f = h.y), q && (h.z > d ? d = h.z : h.z < g && (g = h.z)), n.add(h);
  a = {
    minX: e,
    minY: f,
    maxX: b,
    maxY: c
  };
  q && (a.maxZ = d, a.minZ = g);
  return a;
};
THREE.CurvePath.prototype.createPointsGeometry = function (a) {
  a = this.getPoints(a, !0);
  return this.createGeometry(a);
};
THREE.CurvePath.prototype.createSpacedPointsGeometry = function (a) {
  a = this.getSpacedPoints(a, !0);
  return this.createGeometry(a);
};
THREE.CurvePath.prototype.createGeometry = function (a) {
  for (var b = new THREE.Geometry(), c = 0; c < a.length; c++)
    b.vertices.push(new THREE.Vector3(a[c].x, a[c].y, a[c].z || 0));
  return b;
};
THREE.CurvePath.prototype.addWrapPath = function (a) {
  this.bends.push(a);
};
THREE.CurvePath.prototype.getTransformedPoints = function (a, b) {
  var c = this.getPoints(a), d, e;
  b || (b = this.bends);
  d = 0;
  for (e = b.length; d < e; d++)
    c = this.getWrapPoints(c, b[d]);
  return c;
};
THREE.CurvePath.prototype.getTransformedSpacedPoints = function (a, b) {
  var c = this.getSpacedPoints(a), d, e;
  b || (b = this.bends);
  d = 0;
  for (e = b.length; d < e; d++)
    c = this.getWrapPoints(c, b[d]);
  return c;
};
THREE.CurvePath.prototype.getWrapPoints = function (a, b) {
  var c = this.getBoundingBox(), d, e, f, g, h, k;
  d = 0;
  for (e = a.length; d < e; d++)
    f = a[d], g = f.x, h = f.y, k = g / c.maxX, k = b.getUtoTmapping(k, g), g = b.getPoint(k), k = b.getTangent(k), k.set(-k.y, k.x).multiplyScalar(h), f.x = g.x + k.x, f.y = g.y + k.y;
  return a;
};
THREE.Gyroscope = function () {
  THREE.Object3D.call(this);
};
THREE.Gyroscope.prototype = Object.create(THREE.Object3D.prototype);
THREE.Gyroscope.prototype.updateMatrixWorld = function (a) {
  this.matrixAutoUpdate && this.updateMatrix();
  if (this.matrixWorldNeedsUpdate || a)
    this.parent ? (this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorld.decompose(this.translationWorld, this.quaternionWorld, this.scaleWorld), this.matrix.decompose(this.translationObject, this.quaternionObject, this.scaleObject), this.matrixWorld.compose(this.translationWorld, this.quaternionObject, this.scaleWorld)) : this.matrixWorld.copy(this.matrix), this.matrixWorldNeedsUpdate = !1, a = !0;
  for (var b = 0, c = this.children.length; b < c; b++)
    this.children[b].updateMatrixWorld(a);
};
THREE.Gyroscope.prototype.translationWorld = new THREE.Vector3();
THREE.Gyroscope.prototype.translationObject = new THREE.Vector3();
THREE.Gyroscope.prototype.quaternionWorld = new THREE.Quaternion();
THREE.Gyroscope.prototype.quaternionObject = new THREE.Quaternion();
THREE.Gyroscope.prototype.scaleWorld = new THREE.Vector3();
THREE.Gyroscope.prototype.scaleObject = new THREE.Vector3();
THREE.Path = function (a) {
  THREE.CurvePath.call(this);
  this.actions = [];
  a && this.fromPoints(a);
};
THREE.Path.prototype = Object.create(THREE.CurvePath.prototype);
THREE.PathActions = {
  MOVE_TO: 'moveTo',
  LINE_TO: 'lineTo',
  QUADRATIC_CURVE_TO: 'quadraticCurveTo',
  BEZIER_CURVE_TO: 'bezierCurveTo',
  CSPLINE_THRU: 'splineThru',
  ARC: 'arc',
  ELLIPSE: 'ellipse'
};
THREE.Path.prototype.fromPoints = function (a) {
  this.moveTo(a[0].x, a[0].y);
  for (var b = 1, c = a.length; b < c; b++)
    this.lineTo(a[b].x, a[b].y);
};
THREE.Path.prototype.moveTo = function (a, b) {
  var c = Array.prototype.slice.call(arguments);
  this.actions.push({
    action: THREE.PathActions.MOVE_TO,
    args: c
  });
};
THREE.Path.prototype.lineTo = function (a, b) {
  var c = Array.prototype.slice.call(arguments), d = this.actions[this.actions.length - 1].args, d = new THREE.LineCurve(new THREE.Vector2(d[d.length - 2], d[d.length - 1]), new THREE.Vector2(a, b));
  this.curves.push(d);
  this.actions.push({
    action: THREE.PathActions.LINE_TO,
    args: c
  });
};
THREE.Path.prototype.quadraticCurveTo = function (a, b, c, d) {
  var e = Array.prototype.slice.call(arguments), f = this.actions[this.actions.length - 1].args, f = new THREE.QuadraticBezierCurve(new THREE.Vector2(f[f.length - 2], f[f.length - 1]), new THREE.Vector2(a, b), new THREE.Vector2(c, d));
  this.curves.push(f);
  this.actions.push({
    action: THREE.PathActions.QUADRATIC_CURVE_TO,
    args: e
  });
};
THREE.Path.prototype.bezierCurveTo = function (a, b, c, d, e, f) {
  var g = Array.prototype.slice.call(arguments), h = this.actions[this.actions.length - 1].args, h = new THREE.CubicBezierCurve(new THREE.Vector2(h[h.length - 2], h[h.length - 1]), new THREE.Vector2(a, b), new THREE.Vector2(c, d), new THREE.Vector2(e, f));
  this.curves.push(h);
  this.actions.push({
    action: THREE.PathActions.BEZIER_CURVE_TO,
    args: g
  });
};
THREE.Path.prototype.splineThru = function (a) {
  var b = Array.prototype.slice.call(arguments), c = this.actions[this.actions.length - 1].args, c = [new THREE.Vector2(c[c.length - 2], c[c.length - 1])];
  Array.prototype.push.apply(c, a);
  c = new THREE.SplineCurve(c);
  this.curves.push(c);
  this.actions.push({
    action: THREE.PathActions.CSPLINE_THRU,
    args: b
  });
};
THREE.Path.prototype.arc = function (a, b, c, d, e, f) {
  var g = this.actions[this.actions.length - 1].args;
  this.absarc(a + g[g.length - 2], b + g[g.length - 1], c, d, e, f);
};
THREE.Path.prototype.absarc = function (a, b, c, d, e, f) {
  this.absellipse(a, b, c, c, d, e, f);
};
THREE.Path.prototype.ellipse = function (a, b, c, d, e, f, g) {
  var h = this.actions[this.actions.length - 1].args;
  this.absellipse(a + h[h.length - 2], b + h[h.length - 1], c, d, e, f, g);
};
THREE.Path.prototype.absellipse = function (a, b, c, d, e, f, g) {
  var h = Array.prototype.slice.call(arguments), k = new THREE.EllipseCurve(a, b, c, d, e, f, g);
  this.curves.push(k);
  k = k.getPoint(1);
  h.push(k.x);
  h.push(k.y);
  this.actions.push({
    action: THREE.PathActions.ELLIPSE,
    args: h
  });
};
THREE.Path.prototype.getSpacedPoints = function (a, b) {
  a || (a = 40);
  for (var c = [], d = 0; d < a; d++)
    c.push(this.getPoint(d / a));
  return c;
};
THREE.Path.prototype.getPoints = function (a, b) {
  if (this.useSpacedPoints)
    return console.log('tata'), this.getSpacedPoints(a, b);
  a = a || 12;
  var c = [], d, e, f, g, h, k, l, n, q, p, s, t, r;
  d = 0;
  for (e = this.actions.length; d < e; d++)
    switch (f = this.actions[d], g = f.action, f = f.args, g) {
    case THREE.PathActions.MOVE_TO:
      c.push(new THREE.Vector2(f[0], f[1]));
      break;
    case THREE.PathActions.LINE_TO:
      c.push(new THREE.Vector2(f[0], f[1]));
      break;
    case THREE.PathActions.QUADRATIC_CURVE_TO:
      h = f[2];
      k = f[3];
      q = f[0];
      p = f[1];
      0 < c.length ? (g = c[c.length - 1], s = g.x, t = g.y) : (g = this.actions[d - 1].args, s = g[g.length - 2], t = g[g.length - 1]);
      for (f = 1; f <= a; f++)
        r = f / a, g = THREE.Shape.Utils.b2(r, s, q, h), r = THREE.Shape.Utils.b2(r, t, p, k), c.push(new THREE.Vector2(g, r));
      break;
    case THREE.PathActions.BEZIER_CURVE_TO:
      h = f[4];
      k = f[5];
      q = f[0];
      p = f[1];
      l = f[2];
      n = f[3];
      0 < c.length ? (g = c[c.length - 1], s = g.x, t = g.y) : (g = this.actions[d - 1].args, s = g[g.length - 2], t = g[g.length - 1]);
      for (f = 1; f <= a; f++)
        r = f / a, g = THREE.Shape.Utils.b3(r, s, q, l, h), r = THREE.Shape.Utils.b3(r, t, p, n, k), c.push(new THREE.Vector2(g, r));
      break;
    case THREE.PathActions.CSPLINE_THRU:
      g = this.actions[d - 1].args;
      r = [new THREE.Vector2(g[g.length - 2], g[g.length - 1])];
      g = a * f[0].length;
      r = r.concat(f[0]);
      r = new THREE.SplineCurve(r);
      for (f = 1; f <= g; f++)
        c.push(r.getPointAt(f / g));
      break;
    case THREE.PathActions.ARC:
      h = f[0];
      k = f[1];
      p = f[2];
      l = f[3];
      g = f[4];
      q = !!f[5];
      s = g - l;
      t = 2 * a;
      for (f = 1; f <= t; f++)
        r = f / t, q || (r = 1 - r), r = l + r * s, g = h + p * Math.cos(r), r = k + p * Math.sin(r), c.push(new THREE.Vector2(g, r));
      break;
    case THREE.PathActions.ELLIPSE:
      for (h = f[0], k = f[1], p = f[2], n = f[3], l = f[4], g = f[5], q = !!f[6], s = g - l, t = 2 * a, f = 1; f <= t; f++)
        r = f / t, q || (r = 1 - r), r = l + r * s, g = h + p * Math.cos(r), r = k + n * Math.sin(r), c.push(new THREE.Vector2(g, r));
    }
  d = c[c.length - 1];
  1e-10 > Math.abs(d.x - c[0].x) && 1e-10 > Math.abs(d.y - c[0].y) && c.splice(c.length - 1, 1);
  b && c.push(c[0]);
  return c;
};
THREE.Path.prototype.toShapes = function (a, b) {
  function c(a) {
    for (var b = [], c = 0, d = a.length; c < d; c++) {
      var e = a[c], f = new THREE.Shape();
      f.actions = e.actions;
      f.curves = e.curves;
      b.push(f);
    }
    return b;
  }
  function d(a, b) {
    for (var c = b.length, d = !1, e = c - 1, f = 0; f < c; e = f++) {
      var g = b[e], h = b[f], k = h.x - g.x, l = h.y - g.y;
      if (1e-10 < Math.abs(l)) {
        if (0 > l && (g = b[f], k = -k, h = b[e], l = -l), !(a.y < g.y || a.y > h.y))
          if (a.y == g.y) {
            if (a.x == g.x)
              return !0;
          } else {
            e = l * (a.x - g.x) - k * (a.y - g.y);
            if (0 == e)
              return !0;
            0 > e || (d = !d);
          }
      } else if (a.y == g.y && (h.x <= a.x && a.x <= g.x || g.x <= a.x && a.x <= h.x))
        return !0;
    }
    return d;
  }
  var e = function (a) {
      var b, c, d, e, f = [], g = new THREE.Path();
      b = 0;
      for (c = a.length; b < c; b++)
        d = a[b], e = d.args, d = d.action, d == THREE.PathActions.MOVE_TO && 0 != g.actions.length && (f.push(g), g = new THREE.Path()), g[d].apply(g, e);
      0 != g.actions.length && f.push(g);
      return f;
    }(this.actions);
  if (0 == e.length)
    return [];
  if (!0 === b)
    return c(e);
  var f, g, h, k = [];
  if (1 == e.length)
    return g = e[0], h = new THREE.Shape(), h.actions = g.actions, h.curves = g.curves, k.push(h), k;
  var l = !THREE.Shape.Utils.isClockWise(e[0].getPoints()), l = a ? !l : l;
  h = [];
  var n = [], q = [], p = 0, s;
  n[p] = void 0;
  q[p] = [];
  var t, r;
  t = 0;
  for (r = e.length; t < r; t++)
    g = e[t], s = g.getPoints(), f = THREE.Shape.Utils.isClockWise(s), (f = a ? !f : f) ? (!l && n[p] && p++, n[p] = {
      s: new THREE.Shape(),
      p: s
    }, n[p].s.actions = g.actions, n[p].s.curves = g.curves, l && p++, q[p] = []) : q[p].push({
      h: g,
      p: s[0]
    });
  if (!n[0])
    return c(e);
  if (1 < n.length) {
    t = !1;
    r = [];
    g = 0;
    for (e = n.length; g < e; g++)
      h[g] = [];
    g = 0;
    for (e = n.length; g < e; g++)
      for (f = q[g], l = 0; l < f.length; l++) {
        p = f[l];
        s = !0;
        for (var v = 0; v < n.length; v++)
          d(p.p, n[v].p) && (g != v && r.push({
            froms: g,
            tos: v,
            hole: l
          }), s ? (s = !1, h[v].push(p)) : t = !0);
        s && h[g].push(p);
      }
    0 < r.length && (t || (q = h));
  }
  t = 0;
  for (r = n.length; t < r; t++)
    for (h = n[t].s, k.push(h), g = q[t], e = 0, f = g.length; e < f; e++)
      h.holes.push(g[e].h);
  return k;
};
THREE.Shape = function () {
  THREE.Path.apply(this, arguments);
  this.holes = [];
};
THREE.Shape.prototype = Object.create(THREE.Path.prototype);
THREE.Shape.prototype.extrude = function (a) {
  return new THREE.ExtrudeGeometry(this, a);
};
THREE.Shape.prototype.makeGeometry = function (a) {
  return new THREE.ShapeGeometry(this, a);
};
THREE.Shape.prototype.getPointsHoles = function (a) {
  var b, c = this.holes.length, d = [];
  for (b = 0; b < c; b++)
    d[b] = this.holes[b].getTransformedPoints(a, this.bends);
  return d;
};
THREE.Shape.prototype.getSpacedPointsHoles = function (a) {
  var b, c = this.holes.length, d = [];
  for (b = 0; b < c; b++)
    d[b] = this.holes[b].getTransformedSpacedPoints(a, this.bends);
  return d;
};
THREE.Shape.prototype.extractAllPoints = function (a) {
  return {
    shape: this.getTransformedPoints(a),
    holes: this.getPointsHoles(a)
  };
};
THREE.Shape.prototype.extractPoints = function (a) {
  return this.useSpacedPoints ? this.extractAllSpacedPoints(a) : this.extractAllPoints(a);
};
THREE.Shape.prototype.extractAllSpacedPoints = function (a) {
  return {
    shape: this.getTransformedSpacedPoints(a),
    holes: this.getSpacedPointsHoles(a)
  };
};
THREE.Shape.Utils = {
  triangulateShape: function (a, b) {
    function c(a, b, c) {
      return a.x != b.x ? a.x < b.x ? a.x <= c.x && c.x <= b.x : b.x <= c.x && c.x <= a.x : a.y < b.y ? a.y <= c.y && c.y <= b.y : b.y <= c.y && c.y <= a.y;
    }
    function d(a, b, d, e, f) {
      var g = b.x - a.x, h = b.y - a.y, k = e.x - d.x, l = e.y - d.y, n = a.x - d.x, q = a.y - d.y, J = h * k - g * l, B = h * n - g * q;
      if (1e-10 < Math.abs(J)) {
        if (0 < J) {
          if (0 > B || B > J)
            return [];
          k = l * n - k * q;
          if (0 > k || k > J)
            return [];
        } else {
          if (0 < B || B < J)
            return [];
          k = l * n - k * q;
          if (0 < k || k < J)
            return [];
        }
        if (0 == k)
          return !f || 0 != B && B != J ? [a] : [];
        if (k == J)
          return !f || 0 != B && B != J ? [b] : [];
        if (0 == B)
          return [d];
        if (B == J)
          return [e];
        f = k / J;
        return [{
            x: a.x + f * g,
            y: a.y + f * h
          }];
      }
      if (0 != B || l * n != k * q)
        return [];
      h = 0 == g && 0 == h;
      k = 0 == k && 0 == l;
      if (h && k)
        return a.x != d.x || a.y != d.y ? [] : [a];
      if (h)
        return c(d, e, a) ? [a] : [];
      if (k)
        return c(a, b, d) ? [d] : [];
      0 != g ? (a.x < b.x ? (g = a, k = a.x, h = b, a = b.x) : (g = b, k = b.x, h = a, a = a.x), d.x < e.x ? (b = d, J = d.x, l = e, d = e.x) : (b = e, J = e.x, l = d, d = d.x)) : (a.y < b.y ? (g = a, k = a.y, h = b, a = b.y) : (g = b, k = b.y, h = a, a = a.y), d.y < e.y ? (b = d, J = d.y, l = e, d = e.y) : (b = e, J = e.y, l = d, d = d.y));
      return k <= J ? a < J ? [] : a == J ? f ? [] : [b] : a <= d ? [
        b,
        h
      ] : [
        b,
        l
      ] : k > d ? [] : k == d ? f ? [] : [g] : a <= d ? [
        g,
        h
      ] : [
        g,
        l
      ];
    }
    function e(a, b, c, d) {
      var e = b.x - a.x, f = b.y - a.y;
      b = c.x - a.x;
      c = c.y - a.y;
      var g = d.x - a.x;
      d = d.y - a.y;
      a = e * c - f * b;
      e = e * d - f * g;
      return 1e-10 < Math.abs(a) ? (b = g * c - d * b, 0 < a ? 0 <= e && 0 <= b : 0 <= e || 0 <= b) : 0 < e;
    }
    var f, g, h, k, l, n = {};
    h = a.concat();
    f = 0;
    for (g = b.length; f < g; f++)
      Array.prototype.push.apply(h, b[f]);
    f = 0;
    for (g = h.length; f < g; f++)
      l = h[f].x + ':' + h[f].y, void 0 !== n[l] && console.log('Duplicate point', l), n[l] = f;
    f = function (a, b) {
      function c(a, b) {
        var d = h.length - 1, f = a - 1;
        0 > f && (f = d);
        var g = a + 1;
        g > d && (g = 0);
        d = e(h[a], h[f], h[g], k[b]);
        if (!d)
          return !1;
        d = k.length - 1;
        f = b - 1;
        0 > f && (f = d);
        g = b + 1;
        g > d && (g = 0);
        return (d = e(k[b], k[f], k[g], h[a])) ? !0 : !1;
      }
      function f(a, b) {
        var c, e;
        for (c = 0; c < h.length; c++)
          if (e = c + 1, e %= h.length, e = d(a, b, h[c], h[e], !0), 0 < e.length)
            return !0;
        return !1;
      }
      function g(a, c) {
        var e, f, h, k;
        for (e = 0; e < l.length; e++)
          for (f = b[l[e]], h = 0; h < f.length; h++)
            if (k = h + 1, k %= f.length, k = d(a, c, f[h], f[k], !0), 0 < k.length)
              return !0;
        return !1;
      }
      var h = a.concat(), k, l = [], n, q, N, J, B, K = [], A, G, D, C = 0;
      for (n = b.length; C < n; C++)
        l.push(C);
      A = 0;
      for (var F = 2 * l.length; 0 < l.length;) {
        F--;
        if (0 > F) {
          console.log('Infinite Loop! Holes left:' + l.length + ', Probably Hole outside Shape!');
          break;
        }
        for (q = A; q < h.length; q++) {
          N = h[q];
          n = -1;
          for (C = 0; C < l.length; C++)
            if (J = l[C], B = N.x + ':' + N.y + ':' + J, void 0 === K[B]) {
              k = b[J];
              for (G = 0; G < k.length; G++)
                if (J = k[G], c(q, G) && !f(N, J) && !g(N, J)) {
                  n = G;
                  l.splice(C, 1);
                  A = h.slice(0, q + 1);
                  J = h.slice(q);
                  G = k.slice(n);
                  D = k.slice(0, n + 1);
                  h = A.concat(G).concat(D).concat(J);
                  A = q;
                  break;
                }
              if (0 <= n)
                break;
              K[B] = !0;
            }
          if (0 <= n)
            break;
        }
      }
      return h;
    }(a, b);
    var q = THREE.FontUtils.Triangulate(f, !1);
    f = 0;
    for (g = q.length; f < g; f++)
      for (k = q[f], h = 0; 3 > h; h++)
        l = k[h].x + ':' + k[h].y, l = n[l], void 0 !== l && (k[h] = l);
    return q.concat();
  },
  isClockWise: function (a) {
    return 0 > THREE.FontUtils.Triangulate.area(a);
  },
  b2p0: function (a, b) {
    var c = 1 - a;
    return c * c * b;
  },
  b2p1: function (a, b) {
    return 2 * (1 - a) * a * b;
  },
  b2p2: function (a, b) {
    return a * a * b;
  },
  b2: function (a, b, c, d) {
    return this.b2p0(a, b) + this.b2p1(a, c) + this.b2p2(a, d);
  },
  b3p0: function (a, b) {
    var c = 1 - a;
    return c * c * c * b;
  },
  b3p1: function (a, b) {
    var c = 1 - a;
    return 3 * c * c * a * b;
  },
  b3p2: function (a, b) {
    return 3 * (1 - a) * a * a * b;
  },
  b3p3: function (a, b) {
    return a * a * a * b;
  },
  b3: function (a, b, c, d, e) {
    return this.b3p0(a, b) + this.b3p1(a, c) + this.b3p2(a, d) + this.b3p3(a, e);
  }
};
THREE.LineCurve = function (a, b) {
  this.v1 = a;
  this.v2 = b;
};
THREE.LineCurve.prototype = Object.create(THREE.Curve.prototype);
THREE.LineCurve.prototype.getPoint = function (a) {
  var b = this.v2.clone().sub(this.v1);
  b.multiplyScalar(a).add(this.v1);
  return b;
};
THREE.LineCurve.prototype.getPointAt = function (a) {
  return this.getPoint(a);
};
THREE.LineCurve.prototype.getTangent = function (a) {
  return this.v2.clone().sub(this.v1).normalize();
};
THREE.QuadraticBezierCurve = function (a, b, c) {
  this.v0 = a;
  this.v1 = b;
  this.v2 = c;
};
THREE.QuadraticBezierCurve.prototype = Object.create(THREE.Curve.prototype);
THREE.QuadraticBezierCurve.prototype.getPoint = function (a) {
  var b;
  b = THREE.Shape.Utils.b2(a, this.v0.x, this.v1.x, this.v2.x);
  a = THREE.Shape.Utils.b2(a, this.v0.y, this.v1.y, this.v2.y);
  return new THREE.Vector2(b, a);
};
THREE.QuadraticBezierCurve.prototype.getTangent = function (a) {
  var b;
  b = THREE.Curve.Utils.tangentQuadraticBezier(a, this.v0.x, this.v1.x, this.v2.x);
  a = THREE.Curve.Utils.tangentQuadraticBezier(a, this.v0.y, this.v1.y, this.v2.y);
  b = new THREE.Vector2(b, a);
  b.normalize();
  return b;
};
THREE.CubicBezierCurve = function (a, b, c, d) {
  this.v0 = a;
  this.v1 = b;
  this.v2 = c;
  this.v3 = d;
};
THREE.CubicBezierCurve.prototype = Object.create(THREE.Curve.prototype);
THREE.CubicBezierCurve.prototype.getPoint = function (a) {
  var b;
  b = THREE.Shape.Utils.b3(a, this.v0.x, this.v1.x, this.v2.x, this.v3.x);
  a = THREE.Shape.Utils.b3(a, this.v0.y, this.v1.y, this.v2.y, this.v3.y);
  return new THREE.Vector2(b, a);
};
THREE.CubicBezierCurve.prototype.getTangent = function (a) {
  var b;
  b = THREE.Curve.Utils.tangentCubicBezier(a, this.v0.x, this.v1.x, this.v2.x, this.v3.x);
  a = THREE.Curve.Utils.tangentCubicBezier(a, this.v0.y, this.v1.y, this.v2.y, this.v3.y);
  b = new THREE.Vector2(b, a);
  b.normalize();
  return b;
};
THREE.SplineCurve = function (a) {
  this.points = void 0 == a ? [] : a;
};
THREE.SplineCurve.prototype = Object.create(THREE.Curve.prototype);
THREE.SplineCurve.prototype.getPoint = function (a) {
  var b = new THREE.Vector2(), c = [], d = this.points, e;
  e = (d.length - 1) * a;
  a = Math.floor(e);
  e -= a;
  c[0] = 0 == a ? a : a - 1;
  c[1] = a;
  c[2] = a > d.length - 2 ? d.length - 1 : a + 1;
  c[3] = a > d.length - 3 ? d.length - 1 : a + 2;
  b.x = THREE.Curve.Utils.interpolate(d[c[0]].x, d[c[1]].x, d[c[2]].x, d[c[3]].x, e);
  b.y = THREE.Curve.Utils.interpolate(d[c[0]].y, d[c[1]].y, d[c[2]].y, d[c[3]].y, e);
  return b;
};
THREE.EllipseCurve = function (a, b, c, d, e, f, g) {
  this.aX = a;
  this.aY = b;
  this.xRadius = c;
  this.yRadius = d;
  this.aStartAngle = e;
  this.aEndAngle = f;
  this.aClockwise = g;
};
THREE.EllipseCurve.prototype = Object.create(THREE.Curve.prototype);
THREE.EllipseCurve.prototype.getPoint = function (a) {
  var b;
  b = this.aEndAngle - this.aStartAngle;
  0 > b && (b += 2 * Math.PI);
  b > 2 * Math.PI && (b -= 2 * Math.PI);
  b = !0 === this.aClockwise ? this.aEndAngle + (1 - a) * (2 * Math.PI - b) : this.aStartAngle + a * b;
  a = this.aX + this.xRadius * Math.cos(b);
  b = this.aY + this.yRadius * Math.sin(b);
  return new THREE.Vector2(a, b);
};
THREE.ArcCurve = function (a, b, c, d, e, f) {
  THREE.EllipseCurve.call(this, a, b, c, c, d, e, f);
};
THREE.ArcCurve.prototype = Object.create(THREE.EllipseCurve.prototype);
THREE.LineCurve3 = THREE.Curve.create(function (a, b) {
  this.v1 = a;
  this.v2 = b;
}, function (a) {
  var b = new THREE.Vector3();
  b.subVectors(this.v2, this.v1);
  b.multiplyScalar(a);
  b.add(this.v1);
  return b;
});
THREE.QuadraticBezierCurve3 = THREE.Curve.create(function (a, b, c) {
  this.v0 = a;
  this.v1 = b;
  this.v2 = c;
}, function (a) {
  var b, c;
  b = THREE.Shape.Utils.b2(a, this.v0.x, this.v1.x, this.v2.x);
  c = THREE.Shape.Utils.b2(a, this.v0.y, this.v1.y, this.v2.y);
  a = THREE.Shape.Utils.b2(a, this.v0.z, this.v1.z, this.v2.z);
  return new THREE.Vector3(b, c, a);
});
THREE.CubicBezierCurve3 = THREE.Curve.create(function (a, b, c, d) {
  this.v0 = a;
  this.v1 = b;
  this.v2 = c;
  this.v3 = d;
}, function (a) {
  var b, c;
  b = THREE.Shape.Utils.b3(a, this.v0.x, this.v1.x, this.v2.x, this.v3.x);
  c = THREE.Shape.Utils.b3(a, this.v0.y, this.v1.y, this.v2.y, this.v3.y);
  a = THREE.Shape.Utils.b3(a, this.v0.z, this.v1.z, this.v2.z, this.v3.z);
  return new THREE.Vector3(b, c, a);
});
THREE.SplineCurve3 = THREE.Curve.create(function (a) {
  this.points = void 0 == a ? [] : a;
}, function (a) {
  var b = new THREE.Vector3(), c = [], d = this.points, e;
  a *= d.length - 1;
  e = Math.floor(a);
  a -= e;
  c[0] = 0 == e ? e : e - 1;
  c[1] = e;
  c[2] = e > d.length - 2 ? d.length - 1 : e + 1;
  c[3] = e > d.length - 3 ? d.length - 1 : e + 2;
  e = d[c[0]];
  var f = d[c[1]], g = d[c[2]], c = d[c[3]];
  b.x = THREE.Curve.Utils.interpolate(e.x, f.x, g.x, c.x, a);
  b.y = THREE.Curve.Utils.interpolate(e.y, f.y, g.y, c.y, a);
  b.z = THREE.Curve.Utils.interpolate(e.z, f.z, g.z, c.z, a);
  return b;
});
THREE.ClosedSplineCurve3 = THREE.Curve.create(function (a) {
  this.points = void 0 == a ? [] : a;
}, function (a) {
  var b = new THREE.Vector3(), c = [], d = this.points, e;
  e = (d.length - 0) * a;
  a = Math.floor(e);
  e -= a;
  a += 0 < a ? 0 : (Math.floor(Math.abs(a) / d.length) + 1) * d.length;
  c[0] = (a - 1) % d.length;
  c[1] = a % d.length;
  c[2] = (a + 1) % d.length;
  c[3] = (a + 2) % d.length;
  b.x = THREE.Curve.Utils.interpolate(d[c[0]].x, d[c[1]].x, d[c[2]].x, d[c[3]].x, e);
  b.y = THREE.Curve.Utils.interpolate(d[c[0]].y, d[c[1]].y, d[c[2]].y, d[c[3]].y, e);
  b.z = THREE.Curve.Utils.interpolate(d[c[0]].z, d[c[1]].z, d[c[2]].z, d[c[3]].z, e);
  return b;
});
THREE.AnimationHandler = function () {
  var a = [], b = {}, c = {
      update: function (b) {
        for (var c = 0; c < a.length; c++)
          a[c].update(b);
      },
      addToUpdate: function (b) {
        -1 === a.indexOf(b) && a.push(b);
      },
      removeFromUpdate: function (b) {
        b = a.indexOf(b);
        -1 !== b && a.splice(b, 1);
      },
      add: function (a) {
        void 0 !== b[a.name] && console.log('THREE.AnimationHandler.add: Warning! ' + a.name + ' already exists in library. Overwriting.');
        b[a.name] = a;
        if (!0 !== a.initialized) {
          for (var c = 0; c < a.hierarchy.length; c++) {
            for (var d = 0; d < a.hierarchy[c].keys.length; d++)
              if (0 > a.hierarchy[c].keys[d].time && (a.hierarchy[c].keys[d].time = 0), void 0 !== a.hierarchy[c].keys[d].rot && !(a.hierarchy[c].keys[d].rot instanceof THREE.Quaternion)) {
                var h = a.hierarchy[c].keys[d].rot;
                a.hierarchy[c].keys[d].rot = new THREE.Quaternion().fromArray(h);
              }
            if (a.hierarchy[c].keys.length && void 0 !== a.hierarchy[c].keys[0].morphTargets) {
              h = {};
              for (d = 0; d < a.hierarchy[c].keys.length; d++)
                for (var k = 0; k < a.hierarchy[c].keys[d].morphTargets.length; k++) {
                  var l = a.hierarchy[c].keys[d].morphTargets[k];
                  h[l] = -1;
                }
              a.hierarchy[c].usedMorphTargets = h;
              for (d = 0; d < a.hierarchy[c].keys.length; d++) {
                var n = {};
                for (l in h) {
                  for (k = 0; k < a.hierarchy[c].keys[d].morphTargets.length; k++)
                    if (a.hierarchy[c].keys[d].morphTargets[k] === l) {
                      n[l] = a.hierarchy[c].keys[d].morphTargetsInfluences[k];
                      break;
                    }
                  k === a.hierarchy[c].keys[d].morphTargets.length && (n[l] = 0);
                }
                a.hierarchy[c].keys[d].morphTargetsInfluences = n;
              }
            }
            for (d = 1; d < a.hierarchy[c].keys.length; d++)
              a.hierarchy[c].keys[d].time === a.hierarchy[c].keys[d - 1].time && (a.hierarchy[c].keys.splice(d, 1), d--);
            for (d = 0; d < a.hierarchy[c].keys.length; d++)
              a.hierarchy[c].keys[d].index = d;
          }
          a.initialized = !0;
        }
      },
      remove: function (a) {
        void 0 === b[a] && console.log('THREE.AnimationHandler.add: Warning! ' + a + ' doesn\'t exists in library. Doing nothing.');
        b[a] = void 0;
      },
      get: function (a) {
        if ('string' === typeof a)
          return b[a] ? b[a] : null;
      },
      parse: function (a) {
        var b = [];
        if (a instanceof THREE.SkinnedMesh)
          for (var c = 0; c < a.skeleton.bones.length; c++)
            b.push(a.skeleton.bones[c]);
        else
          d(a, b);
        return b;
      }
    }, d = function (a, b) {
      b.push(a);
      for (var c = 0; c < a.children.length; c++)
        d(a.children[c], b);
    };
  c.LINEAR = 0;
  c.CATMULLROM = 1;
  c.CATMULLROM_FORWARD = 2;
  return c;
}();
THREE.Animation = function (a, b) {
  this.root = a;
  this.data = THREE.AnimationHandler.get(b);
  this.hierarchy = THREE.AnimationHandler.parse(a);
  this.currentTime = 0;
  this.timeScale = 1;
  this.isPlaying = !1;
  this.loop = this.isPaused = !0;
  this.weight = 0;
  this.interpolationType = THREE.AnimationHandler.LINEAR;
};
THREE.Animation.prototype.keyTypes = [
  'pos',
  'rot',
  'scl'
];
THREE.Animation.prototype.play = function (a, b) {
  this.currentTime = void 0 !== a ? a : 0;
  this.weight = void 0 !== b ? b : 1;
  this.isPlaying = !0;
  this.isPaused = !1;
  this.reset();
  THREE.AnimationHandler.addToUpdate(this);
};
THREE.Animation.prototype.pause = function () {
  !0 === this.isPaused ? THREE.AnimationHandler.addToUpdate(this) : THREE.AnimationHandler.removeFromUpdate(this);
  this.isPaused = !this.isPaused;
};
THREE.Animation.prototype.stop = function () {
  this.isPaused = this.isPlaying = !1;
  THREE.AnimationHandler.removeFromUpdate(this);
};
THREE.Animation.prototype.reset = function () {
  for (var a = 0, b = this.hierarchy.length; a < b; a++) {
    var c = this.hierarchy[a];
    c.matrixAutoUpdate = !0;
    void 0 === c.animationCache && (c.animationCache = {});
    void 0 === c.animationCache[this.data.name] && (c.animationCache[this.data.name] = {}, c.animationCache[this.data.name].prevKey = {
      pos: 0,
      rot: 0,
      scl: 0
    }, c.animationCache[this.data.name].nextKey = {
      pos: 0,
      rot: 0,
      scl: 0
    }, c.animationCache[this.data.name].originalMatrix = c instanceof THREE.Bone ? c.skinMatrix : c.matrix);
    for (var c = c.animationCache[this.data.name], d = 0; 3 > d; d++) {
      for (var e = this.keyTypes[d], f = this.data.hierarchy[a].keys[0], g = this.getNextKeyWith(e, a, 1); g.time < this.currentTime && g.index > f.index;)
        f = g, g = this.getNextKeyWith(e, a, g.index + 1);
      c.prevKey[e] = f;
      c.nextKey[e] = g;
    }
  }
};
THREE.Animation.prototype.update = function () {
  var a = [], b = new THREE.Vector3(), c = new THREE.Vector3(), d = new THREE.Quaternion(), e = function (a, b) {
      var c = [], d = [], e, q, p, s, t, r;
      e = (a.length - 1) * b;
      q = Math.floor(e);
      e -= q;
      c[0] = 0 === q ? q : q - 1;
      c[1] = q;
      c[2] = q > a.length - 2 ? q : q + 1;
      c[3] = q > a.length - 3 ? q : q + 2;
      q = a[c[0]];
      s = a[c[1]];
      t = a[c[2]];
      r = a[c[3]];
      c = e * e;
      p = e * c;
      d[0] = f(q[0], s[0], t[0], r[0], e, c, p);
      d[1] = f(q[1], s[1], t[1], r[1], e, c, p);
      d[2] = f(q[2], s[2], t[2], r[2], e, c, p);
      return d;
    }, f = function (a, b, c, d, e, f, p) {
      a = 0.5 * (c - a);
      d = 0.5 * (d - b);
      return (2 * (b - c) + a + d) * p + (-3 * (b - c) - 2 * a - d) * f + a * e + b;
    };
  return function (f) {
    if (!1 !== this.isPlaying && (this.currentTime += f * this.timeScale, 0 !== this.weight)) {
      var h;
      f = this.data.length;
      if (!0 === this.loop && this.currentTime > f)
        this.currentTime %= f, this.reset();
      else if (!1 === this.loop && this.currentTime > f) {
        this.stop();
        return;
      }
      f = 0;
      for (var k = this.hierarchy.length; f < k; f++)
        for (var l = this.hierarchy[f], n = l.animationCache[this.data.name], q = 0; 3 > q; q++) {
          h = this.keyTypes[q];
          var p = n.prevKey[h], s = n.nextKey[h];
          if (s.time <= this.currentTime) {
            p = this.data.hierarchy[f].keys[0];
            for (s = this.getNextKeyWith(h, f, 1); s.time < this.currentTime && s.index > p.index;)
              p = s, s = this.getNextKeyWith(h, f, s.index + 1);
            n.prevKey[h] = p;
            n.nextKey[h] = s;
          }
          l.matrixAutoUpdate = !0;
          l.matrixWorldNeedsUpdate = !0;
          var t = (this.currentTime - p.time) / (s.time - p.time), r = p[h], v = s[h];
          0 > t && (t = 0);
          1 < t && (t = 1);
          if ('pos' === h)
            if (h = l.position, this.interpolationType === THREE.AnimationHandler.LINEAR)
              c.x = r[0] + (v[0] - r[0]) * t, c.y = r[1] + (v[1] - r[1]) * t, c.z = r[2] + (v[2] - r[2]) * t, l instanceof THREE.Bone && (p = this.weight / (this.weight + l.accumulatedPosWeight), h.lerp(c, p), l.accumulatedPosWeight += this.weight);
            else {
              if (this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD)
                a[0] = this.getPrevKeyWith('pos', f, p.index - 1).pos, a[1] = r, a[2] = v, a[3] = this.getNextKeyWith('pos', f, s.index + 1).pos, t = 0.33 * t + 0.33, s = e(a, t), l instanceof THREE.Bone ? (p = this.weight / (this.weight + l.accumulatedPosWeight), l.accumulatedPosWeight += this.weight) : p = 1, h.x += (s[0] - h.x) * p, h.y += (s[1] - h.y) * p, h.z += (s[2] - h.z) * p, this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD && (t = e(a, 1.01 * t), b.set(t[0], t[1], t[2]), b.sub(h), b.y = 0, b.normalize(), h = Math.atan2(b.x, b.z), l.rotation.set(0, h, 0));
            }
          else
            'rot' === h ? (THREE.Quaternion.slerp(r, v, d, t), l instanceof THREE.Bone ? 0 === l.accumulatedRotWeight ? (l.quaternion.copy(d), l.accumulatedRotWeight = this.weight) : (p = this.weight / (this.weight + l.accumulatedRotWeight), THREE.Quaternion.slerp(l.quaternion, d, l.quaternion, p), l.accumulatedRotWeight += this.weight) : l.quaternion.copy(d)) : 'scl' === h && (h = l.scale, c.x = r[0] + (v[0] - r[0]) * t, c.y = r[1] + (v[1] - r[1]) * t, c.z = r[2] + (v[2] - r[2]) * t, l instanceof THREE.Bone && (p = this.weight / (this.weight + l.accumulatedSclWeight), h.lerp(c, p), l.accumulatedSclWeight += this.weight));
        }
      return !0;
    }
  };
}();
THREE.Animation.prototype.getNextKeyWith = function (a, b, c) {
  var d = this.data.hierarchy[b].keys;
  for (c = this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ? c < d.length - 1 ? c : d.length - 1 : c % d.length; c < d.length; c++)
    if (void 0 !== d[c][a])
      return d[c];
  return this.data.hierarchy[b].keys[0];
};
THREE.Animation.prototype.getPrevKeyWith = function (a, b, c) {
  var d = this.data.hierarchy[b].keys;
  for (c = this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ? 0 < c ? c : 0 : 0 <= c ? c : c + d.length; 0 <= c; c--)
    if (void 0 !== d[c][a])
      return d[c];
  return this.data.hierarchy[b].keys[d.length - 1];
};
THREE.KeyFrameAnimation = function (a, b) {
  this.root = a;
  this.data = THREE.AnimationHandler.get(b);
  this.hierarchy = THREE.AnimationHandler.parse(a);
  this.currentTime = 0;
  this.timeScale = 0.001;
  this.isPlaying = !1;
  this.loop = this.isPaused = !0;
  for (var c = 0, d = this.hierarchy.length; c < d; c++) {
    var e = this.data.hierarchy[c].sids, f = this.hierarchy[c];
    if (this.data.hierarchy[c].keys.length && e) {
      for (var g = 0; g < e.length; g++) {
        var h = e[g], k = this.getNextKeyWith(h, c, 0);
        k && k.apply(h);
      }
      f.matrixAutoUpdate = !1;
      this.data.hierarchy[c].node.updateMatrix();
      f.matrixWorldNeedsUpdate = !0;
    }
  }
};
THREE.KeyFrameAnimation.prototype.play = function (a) {
  this.currentTime = void 0 !== a ? a : 0;
  if (!1 === this.isPlaying) {
    this.isPlaying = !0;
    var b = this.hierarchy.length, c, d;
    for (a = 0; a < b; a++)
      c = this.hierarchy[a], d = this.data.hierarchy[a], void 0 === d.animationCache && (d.animationCache = {}, d.animationCache.prevKey = null, d.animationCache.nextKey = null, d.animationCache.originalMatrix = c instanceof THREE.Bone ? c.skinMatrix : c.matrix), c = this.data.hierarchy[a].keys, c.length && (d.animationCache.prevKey = c[0], d.animationCache.nextKey = c[1], this.startTime = Math.min(c[0].time, this.startTime), this.endTime = Math.max(c[c.length - 1].time, this.endTime));
    this.update(0);
  }
  this.isPaused = !1;
  THREE.AnimationHandler.addToUpdate(this);
};
THREE.KeyFrameAnimation.prototype.pause = function () {
  this.isPaused ? THREE.AnimationHandler.addToUpdate(this) : THREE.AnimationHandler.removeFromUpdate(this);
  this.isPaused = !this.isPaused;
};
THREE.KeyFrameAnimation.prototype.stop = function () {
  this.isPaused = this.isPlaying = !1;
  THREE.AnimationHandler.removeFromUpdate(this);
  for (var a = 0; a < this.data.hierarchy.length; a++) {
    var b = this.hierarchy[a], c = this.data.hierarchy[a];
    if (void 0 !== c.animationCache) {
      var d = c.animationCache.originalMatrix;
      b instanceof THREE.Bone ? (d.copy(b.skinMatrix), b.skinMatrix = d) : (d.copy(b.matrix), b.matrix = d);
      delete c.animationCache;
    }
  }
};
THREE.KeyFrameAnimation.prototype.update = function (a) {
  if (!1 !== this.isPlaying) {
    this.currentTime += a * this.timeScale;
    a = this.data.length;
    !0 === this.loop && this.currentTime > a && (this.currentTime %= a);
    this.currentTime = Math.min(this.currentTime, a);
    a = 0;
    for (var b = this.hierarchy.length; a < b; a++) {
      var c = this.hierarchy[a], d = this.data.hierarchy[a], e = d.keys, d = d.animationCache;
      if (e.length) {
        var f = d.prevKey, g = d.nextKey;
        if (g.time <= this.currentTime) {
          for (; g.time < this.currentTime && g.index > f.index;)
            f = g, g = e[f.index + 1];
          d.prevKey = f;
          d.nextKey = g;
        }
        g.time >= this.currentTime ? f.interpolate(g, this.currentTime) : f.interpolate(g, g.time);
        this.data.hierarchy[a].node.updateMatrix();
        c.matrixWorldNeedsUpdate = !0;
      }
    }
  }
};
THREE.KeyFrameAnimation.prototype.getNextKeyWith = function (a, b, c) {
  b = this.data.hierarchy[b].keys;
  for (c %= b.length; c < b.length; c++)
    if (b[c].hasTarget(a))
      return b[c];
  return b[0];
};
THREE.KeyFrameAnimation.prototype.getPrevKeyWith = function (a, b, c) {
  b = this.data.hierarchy[b].keys;
  for (c = 0 <= c ? c : c + b.length; 0 <= c; c--)
    if (b[c].hasTarget(a))
      return b[c];
  return b[b.length - 1];
};
THREE.MorphAnimation = function (a) {
  this.mesh = a;
  this.frames = a.morphTargetInfluences.length;
  this.currentTime = 0;
  this.duration = 1000;
  this.loop = !0;
  this.isPlaying = !1;
};
THREE.MorphAnimation.prototype = {
  play: function () {
    this.isPlaying = !0;
  },
  pause: function () {
    this.isPlaying = !1;
  },
  update: function () {
    var a = 0, b = 0;
    return function (c) {
      if (!1 !== this.isPlaying) {
        this.currentTime += c;
        !0 === this.loop && this.currentTime > this.duration && (this.currentTime %= this.duration);
        this.currentTime = Math.min(this.currentTime, this.duration);
        c = this.duration / this.frames;
        var d = Math.floor(this.currentTime / c);
        d != b && (this.mesh.morphTargetInfluences[a] = 0, this.mesh.morphTargetInfluences[b] = 1, this.mesh.morphTargetInfluences[d] = 0, a = b, b = d);
        this.mesh.morphTargetInfluences[d] = this.currentTime % c / c;
        this.mesh.morphTargetInfluences[a] = 1 - this.mesh.morphTargetInfluences[d];
      }
    };
  }()
};
THREE.CubeCamera = function (a, b, c) {
  THREE.Object3D.call(this);
  var d = new THREE.PerspectiveCamera(90, 1, a, b);
  d.up.set(0, -1, 0);
  d.lookAt(new THREE.Vector3(1, 0, 0));
  this.add(d);
  var e = new THREE.PerspectiveCamera(90, 1, a, b);
  e.up.set(0, -1, 0);
  e.lookAt(new THREE.Vector3(-1, 0, 0));
  this.add(e);
  var f = new THREE.PerspectiveCamera(90, 1, a, b);
  f.up.set(0, 0, 1);
  f.lookAt(new THREE.Vector3(0, 1, 0));
  this.add(f);
  var g = new THREE.PerspectiveCamera(90, 1, a, b);
  g.up.set(0, 0, -1);
  g.lookAt(new THREE.Vector3(0, -1, 0));
  this.add(g);
  var h = new THREE.PerspectiveCamera(90, 1, a, b);
  h.up.set(0, -1, 0);
  h.lookAt(new THREE.Vector3(0, 0, 1));
  this.add(h);
  var k = new THREE.PerspectiveCamera(90, 1, a, b);
  k.up.set(0, -1, 0);
  k.lookAt(new THREE.Vector3(0, 0, -1));
  this.add(k);
  this.renderTarget = new THREE.WebGLRenderTargetCube(c, c, {
    format: THREE.RGBFormat,
    magFilter: THREE.LinearFilter,
    minFilter: THREE.LinearFilter
  });
  this.updateCubeMap = function (a, b) {
    var c = this.renderTarget, p = c.generateMipmaps;
    c.generateMipmaps = !1;
    c.activeCubeFace = 0;
    a.render(b, d, c);
    c.activeCubeFace = 1;
    a.render(b, e, c);
    c.activeCubeFace = 2;
    a.render(b, f, c);
    c.activeCubeFace = 3;
    a.render(b, g, c);
    c.activeCubeFace = 4;
    a.render(b, h, c);
    c.generateMipmaps = p;
    c.activeCubeFace = 5;
    a.render(b, k, c);
  };
};
THREE.CubeCamera.prototype = Object.create(THREE.Object3D.prototype);
THREE.CombinedCamera = function (a, b, c, d, e, f, g) {
  THREE.Camera.call(this);
  this.fov = c;
  this.left = -a / 2;
  this.right = a / 2;
  this.top = b / 2;
  this.bottom = -b / 2;
  this.cameraO = new THREE.OrthographicCamera(a / -2, a / 2, b / 2, b / -2, f, g);
  this.cameraP = new THREE.PerspectiveCamera(c, a / b, d, e);
  this.zoom = 1;
  this.toPerspective();
};
THREE.CombinedCamera.prototype = Object.create(THREE.Camera.prototype);
THREE.CombinedCamera.prototype.toPerspective = function () {
  this.near = this.cameraP.near;
  this.far = this.cameraP.far;
  this.cameraP.fov = this.fov / this.zoom;
  this.cameraP.updateProjectionMatrix();
  this.projectionMatrix = this.cameraP.projectionMatrix;
  this.inPerspectiveMode = !0;
  this.inOrthographicMode = !1;
};
THREE.CombinedCamera.prototype.toOrthographic = function () {
  var a = this.cameraP.aspect, b = (this.cameraP.near + this.cameraP.far) / 2, b = Math.tan(this.fov / 2) * b, a = 2 * b * a / 2, b = b / this.zoom, a = a / this.zoom;
  this.cameraO.left = -a;
  this.cameraO.right = a;
  this.cameraO.top = b;
  this.cameraO.bottom = -b;
  this.cameraO.updateProjectionMatrix();
  this.near = this.cameraO.near;
  this.far = this.cameraO.far;
  this.projectionMatrix = this.cameraO.projectionMatrix;
  this.inPerspectiveMode = !1;
  this.inOrthographicMode = !0;
};
THREE.CombinedCamera.prototype.setSize = function (a, b) {
  this.cameraP.aspect = a / b;
  this.left = -a / 2;
  this.right = a / 2;
  this.top = b / 2;
  this.bottom = -b / 2;
};
THREE.CombinedCamera.prototype.setFov = function (a) {
  this.fov = a;
  this.inPerspectiveMode ? this.toPerspective() : this.toOrthographic();
};
THREE.CombinedCamera.prototype.updateProjectionMatrix = function () {
  this.inPerspectiveMode ? this.toPerspective() : (this.toPerspective(), this.toOrthographic());
};
THREE.CombinedCamera.prototype.setLens = function (a, b) {
  void 0 === b && (b = 24);
  var c = 2 * THREE.Math.radToDeg(Math.atan(b / (2 * a)));
  this.setFov(c);
  return c;
};
THREE.CombinedCamera.prototype.setZoom = function (a) {
  this.zoom = a;
  this.inPerspectiveMode ? this.toPerspective() : this.toOrthographic();
};
THREE.CombinedCamera.prototype.toFrontView = function () {
  this.rotation.x = 0;
  this.rotation.y = 0;
  this.rotation.z = 0;
  this.rotationAutoUpdate = !1;
};
THREE.CombinedCamera.prototype.toBackView = function () {
  this.rotation.x = 0;
  this.rotation.y = Math.PI;
  this.rotation.z = 0;
  this.rotationAutoUpdate = !1;
};
THREE.CombinedCamera.prototype.toLeftView = function () {
  this.rotation.x = 0;
  this.rotation.y = -Math.PI / 2;
  this.rotation.z = 0;
  this.rotationAutoUpdate = !1;
};
THREE.CombinedCamera.prototype.toRightView = function () {
  this.rotation.x = 0;
  this.rotation.y = Math.PI / 2;
  this.rotation.z = 0;
  this.rotationAutoUpdate = !1;
};
THREE.CombinedCamera.prototype.toTopView = function () {
  this.rotation.x = -Math.PI / 2;
  this.rotation.y = 0;
  this.rotation.z = 0;
  this.rotationAutoUpdate = !1;
};
THREE.CombinedCamera.prototype.toBottomView = function () {
  this.rotation.x = Math.PI / 2;
  this.rotation.y = 0;
  this.rotation.z = 0;
  this.rotationAutoUpdate = !1;
};
THREE.BoxGeometry = function (a, b, c, d, e, f) {
  function g(a, b, c, d, e, f, g, r) {
    var v, w = h.widthSegments, u = h.heightSegments, y = e / 2, L = f / 2, x = h.vertices.length;
    if ('x' === a && 'y' === b || 'y' === a && 'x' === b)
      v = 'z';
    else if ('x' === a && 'z' === b || 'z' === a && 'x' === b)
      v = 'y', u = h.depthSegments;
    else if ('z' === a && 'y' === b || 'y' === a && 'z' === b)
      v = 'x', w = h.depthSegments;
    var N = w + 1, J = u + 1, B = e / w, K = f / u, A = new THREE.Vector3();
    A[v] = 0 < g ? 1 : -1;
    for (e = 0; e < J; e++)
      for (f = 0; f < N; f++) {
        var G = new THREE.Vector3();
        G[a] = (f * B - y) * c;
        G[b] = (e * K - L) * d;
        G[v] = g;
        h.vertices.push(G);
      }
    for (e = 0; e < u; e++)
      for (f = 0; f < w; f++)
        L = f + N * e, a = f + N * (e + 1), b = f + 1 + N * (e + 1), c = f + 1 + N * e, d = new THREE.Vector2(f / w, 1 - e / u), g = new THREE.Vector2(f / w, 1 - (e + 1) / u), v = new THREE.Vector2((f + 1) / w, 1 - (e + 1) / u), y = new THREE.Vector2((f + 1) / w, 1 - e / u), L = new THREE.Face3(L + x, a + x, c + x), L.normal.copy(A), L.vertexNormals.push(A.clone(), A.clone(), A.clone()), L.materialIndex = r, h.faces.push(L), h.faceVertexUvs[0].push([
          d,
          g,
          y
        ]), L = new THREE.Face3(a + x, b + x, c + x), L.normal.copy(A), L.vertexNormals.push(A.clone(), A.clone(), A.clone()), L.materialIndex = r, h.faces.push(L), h.faceVertexUvs[0].push([
          g.clone(),
          v,
          y.clone()
        ]);
  }
  THREE.Geometry.call(this);
  this.parameters = {
    width: a,
    height: b,
    depth: c,
    widthSegments: d,
    heightSegments: e,
    depthSegments: f
  };
  this.widthSegments = d || 1;
  this.heightSegments = e || 1;
  this.depthSegments = f || 1;
  var h = this;
  d = a / 2;
  e = b / 2;
  f = c / 2;
  g('z', 'y', -1, -1, c, b, d, 0);
  g('z', 'y', 1, -1, c, b, -d, 1);
  g('x', 'z', 1, 1, a, c, e, 2);
  g('x', 'z', 1, -1, a, c, -e, 3);
  g('x', 'y', 1, -1, a, b, f, 4);
  g('x', 'y', -1, -1, a, b, -f, 5);
  this.mergeVertices();
};
THREE.BoxGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.CircleGeometry = function (a, b, c, d) {
  THREE.Geometry.call(this);
  this.parameters = {
    radius: a,
    segments: b,
    thetaStart: c,
    thetaLength: d
  };
  a = a || 50;
  b = void 0 !== b ? Math.max(3, b) : 8;
  c = void 0 !== c ? c : 0;
  d = void 0 !== d ? d : 2 * Math.PI;
  var e, f = [];
  e = new THREE.Vector3();
  var g = new THREE.Vector2(0.5, 0.5);
  this.vertices.push(e);
  f.push(g);
  for (e = 0; e <= b; e++) {
    var h = new THREE.Vector3(), k = c + e / b * d;
    h.x = a * Math.cos(k);
    h.y = a * Math.sin(k);
    this.vertices.push(h);
    f.push(new THREE.Vector2((h.x / a + 1) / 2, (h.y / a + 1) / 2));
  }
  c = new THREE.Vector3(0, 0, 1);
  for (e = 1; e <= b; e++)
    this.faces.push(new THREE.Face3(e, e + 1, 0, [
      c.clone(),
      c.clone(),
      c.clone()
    ])), this.faceVertexUvs[0].push([
      f[e].clone(),
      f[e + 1].clone(),
      g.clone()
    ]);
  this.computeFaceNormals();
  this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), a);
};
THREE.CircleGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.CubeGeometry = function (a, b, c, d, e, f) {
  console.warn('DEPRECATED: THREE.CubeGeometry is deprecated. Use THREE.BoxGeometry instead.');
  return new THREE.BoxGeometry(a, b, c, d, e, f);
};
THREE.CylinderGeometry = function (a, b, c, d, e, f) {
  THREE.Geometry.call(this);
  this.parameters = {
    radiusTop: a,
    radiusBottom: b,
    height: c,
    radialSegments: d,
    heightSegments: e,
    openEnded: f
  };
  a = void 0 !== a ? a : 20;
  b = void 0 !== b ? b : 20;
  c = void 0 !== c ? c : 100;
  d = d || 8;
  e = e || 1;
  f = void 0 !== f ? f : !1;
  var g = c / 2, h, k, l = [], n = [];
  for (k = 0; k <= e; k++) {
    var q = [], p = [], s = k / e, t = s * (b - a) + a;
    for (h = 0; h <= d; h++) {
      var r = h / d, v = new THREE.Vector3();
      v.x = t * Math.sin(r * Math.PI * 2);
      v.y = -s * c + g;
      v.z = t * Math.cos(r * Math.PI * 2);
      this.vertices.push(v);
      q.push(this.vertices.length - 1);
      p.push(new THREE.Vector2(r, 1 - s));
    }
    l.push(q);
    n.push(p);
  }
  c = (b - a) / c;
  for (h = 0; h < d; h++)
    for (0 !== a ? (q = this.vertices[l[0][h]].clone(), p = this.vertices[l[0][h + 1]].clone()) : (q = this.vertices[l[1][h]].clone(), p = this.vertices[l[1][h + 1]].clone()), q.setY(Math.sqrt(q.x * q.x + q.z * q.z) * c).normalize(), p.setY(Math.sqrt(p.x * p.x + p.z * p.z) * c).normalize(), k = 0; k < e; k++) {
      var s = l[k][h], t = l[k + 1][h], r = l[k + 1][h + 1], v = l[k][h + 1], w = q.clone(), u = q.clone(), y = p.clone(), L = p.clone(), x = n[k][h].clone(), N = n[k + 1][h].clone(), J = n[k + 1][h + 1].clone(), B = n[k][h + 1].clone();
      this.faces.push(new THREE.Face3(s, t, v, [
        w,
        u,
        L
      ]));
      this.faceVertexUvs[0].push([
        x,
        N,
        B
      ]);
      this.faces.push(new THREE.Face3(t, r, v, [
        u.clone(),
        y,
        L.clone()
      ]));
      this.faceVertexUvs[0].push([
        N.clone(),
        J,
        B.clone()
      ]);
    }
  if (!1 === f && 0 < a)
    for (this.vertices.push(new THREE.Vector3(0, g, 0)), h = 0; h < d; h++)
      s = l[0][h], t = l[0][h + 1], r = this.vertices.length - 1, w = new THREE.Vector3(0, 1, 0), u = new THREE.Vector3(0, 1, 0), y = new THREE.Vector3(0, 1, 0), x = n[0][h].clone(), N = n[0][h + 1].clone(), J = new THREE.Vector2(N.x, 0), this.faces.push(new THREE.Face3(s, t, r, [
        w,
        u,
        y
      ])), this.faceVertexUvs[0].push([
        x,
        N,
        J
      ]);
  if (!1 === f && 0 < b)
    for (this.vertices.push(new THREE.Vector3(0, -g, 0)), h = 0; h < d; h++)
      s = l[k][h + 1], t = l[k][h], r = this.vertices.length - 1, w = new THREE.Vector3(0, -1, 0), u = new THREE.Vector3(0, -1, 0), y = new THREE.Vector3(0, -1, 0), x = n[k][h + 1].clone(), N = n[k][h].clone(), J = new THREE.Vector2(N.x, 1), this.faces.push(new THREE.Face3(s, t, r, [
        w,
        u,
        y
      ])), this.faceVertexUvs[0].push([
        x,
        N,
        J
      ]);
  this.computeFaceNormals();
};
THREE.CylinderGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.ExtrudeGeometry = function (a, b) {
  'undefined' !== typeof a && (THREE.Geometry.call(this), a = a instanceof Array ? a : [a], this.shapebb = a[a.length - 1].getBoundingBox(), this.addShapeList(a, b), this.computeFaceNormals());
};
THREE.ExtrudeGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.ExtrudeGeometry.prototype.addShapeList = function (a, b) {
  for (var c = a.length, d = 0; d < c; d++)
    this.addShape(a[d], b);
};
THREE.ExtrudeGeometry.prototype.addShape = function (a, b) {
  function c(a, b, c) {
    b || console.log('die');
    return b.clone().multiplyScalar(c).add(a);
  }
  function d(a, b, c) {
    var d = THREE.Math.sign, e = 1, e = a.x - b.x, f = a.y - b.y, g = c.x - a.x, h = c.y - a.y, k = e * e + f * f;
    if (1e-10 < Math.abs(e * h - f * g)) {
      var l = Math.sqrt(k), d = Math.sqrt(g * g + h * h), k = b.x - f / l;
      b = b.y + e / l;
      g = ((c.x - h / d - k) * h - (c.y + g / d - b) * g) / (e * h - f * g);
      c = k + e * g - a.x;
      a = b + f * g - a.y;
      e = c * c + a * a;
      if (2 >= e)
        return new THREE.Vector2(c, a);
      e = Math.sqrt(e / 2);
    } else
      a = !1, 1e-10 < e ? 1e-10 < g && (a = !0) : -1e-10 > e ? -1e-10 > g && (a = !0) : d(f) == d(h) && (a = !0), a ? (c = -f, a = e, e = Math.sqrt(k)) : (c = e, a = f, e = Math.sqrt(k / 2));
    return new THREE.Vector2(c / e, a / e);
  }
  function e(c, d) {
    var e, f;
    for (I = c.length; 0 <= --I;) {
      e = I;
      f = I - 1;
      0 > f && (f = c.length - 1);
      for (var g = 0, h = s + 2 * n, g = 0; g < h; g++) {
        var k = la * g, l = la * (g + 1), p = d + e + k, k = d + f + k, q = d + f + l, l = d + e + l, r = c, t = g, w = h, v = e, A = f, p = p + D, k = k + D, q = q + D, l = l + D;
        G.faces.push(new THREE.Face3(p, k, l, null, null, u));
        G.faces.push(new THREE.Face3(k, q, l, null, null, u));
        p = y.generateSideWallUV(G, a, r, b, p, k, q, l, t, w, v, A);
        G.faceVertexUvs[0].push([
          p[0],
          p[1],
          p[3]
        ]);
        G.faceVertexUvs[0].push([
          p[1],
          p[2],
          p[3]
        ]);
      }
    }
  }
  function f(a, b, c) {
    G.vertices.push(new THREE.Vector3(a, b, c));
  }
  function g(c, d, e, f) {
    c += D;
    d += D;
    e += D;
    G.faces.push(new THREE.Face3(c, d, e, null, null, w));
    c = f ? y.generateBottomUV(G, a, b, c, d, e) : y.generateTopUV(G, a, b, c, d, e);
    G.faceVertexUvs[0].push(c);
  }
  var h = void 0 !== b.amount ? b.amount : 100, k = void 0 !== b.bevelThickness ? b.bevelThickness : 6, l = void 0 !== b.bevelSize ? b.bevelSize : k - 2, n = void 0 !== b.bevelSegments ? b.bevelSegments : 3, q = void 0 !== b.bevelEnabled ? b.bevelEnabled : !0, p = void 0 !== b.curveSegments ? b.curveSegments : 12, s = void 0 !== b.steps ? b.steps : 1, t = b.extrudePath, r, v = !1, w = b.material, u = b.extrudeMaterial, y = void 0 !== b.UVGenerator ? b.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator, L, x, N, J;
  t && (r = t.getSpacedPoints(s), v = !0, q = !1, L = void 0 !== b.frames ? b.frames : new THREE.TubeGeometry.FrenetFrames(t, s, !1), x = new THREE.Vector3(), N = new THREE.Vector3(), J = new THREE.Vector3());
  q || (l = k = n = 0);
  var B, K, A, G = this, D = this.vertices.length, t = a.extractPoints(p), p = t.shape, C = t.holes;
  if (t = !THREE.Shape.Utils.isClockWise(p)) {
    p = p.reverse();
    K = 0;
    for (A = C.length; K < A; K++)
      B = C[K], THREE.Shape.Utils.isClockWise(B) && (C[K] = B.reverse());
    t = !1;
  }
  var F = THREE.Shape.Utils.triangulateShape(p, C), z = p;
  K = 0;
  for (A = C.length; K < A; K++)
    B = C[K], p = p.concat(B);
  var H, E, Q, Y, U, la = p.length, W, R = F.length, t = [], I = 0;
  Q = z.length;
  H = Q - 1;
  for (E = I + 1; I < Q; I++, H++, E++)
    H === Q && (H = 0), E === Q && (E = 0), t[I] = d(z[I], z[H], z[E]);
  var da = [], V, X = t.concat();
  K = 0;
  for (A = C.length; K < A; K++) {
    B = C[K];
    V = [];
    I = 0;
    Q = B.length;
    H = Q - 1;
    for (E = I + 1; I < Q; I++, H++, E++)
      H === Q && (H = 0), E === Q && (E = 0), V[I] = d(B[I], B[H], B[E]);
    da.push(V);
    X = X.concat(V);
  }
  for (H = 0; H < n; H++) {
    Q = H / n;
    Y = k * (1 - Q);
    E = l * Math.sin(Q * Math.PI / 2);
    I = 0;
    for (Q = z.length; I < Q; I++)
      U = c(z[I], t[I], E), f(U.x, U.y, -Y);
    K = 0;
    for (A = C.length; K < A; K++)
      for (B = C[K], V = da[K], I = 0, Q = B.length; I < Q; I++)
        U = c(B[I], V[I], E), f(U.x, U.y, -Y);
  }
  E = l;
  for (I = 0; I < la; I++)
    U = q ? c(p[I], X[I], E) : p[I], v ? (N.copy(L.normals[0]).multiplyScalar(U.x), x.copy(L.binormals[0]).multiplyScalar(U.y), J.copy(r[0]).add(N).add(x), f(J.x, J.y, J.z)) : f(U.x, U.y, 0);
  for (Q = 1; Q <= s; Q++)
    for (I = 0; I < la; I++)
      U = q ? c(p[I], X[I], E) : p[I], v ? (N.copy(L.normals[Q]).multiplyScalar(U.x), x.copy(L.binormals[Q]).multiplyScalar(U.y), J.copy(r[Q]).add(N).add(x), f(J.x, J.y, J.z)) : f(U.x, U.y, h / s * Q);
  for (H = n - 1; 0 <= H; H--) {
    Q = H / n;
    Y = k * (1 - Q);
    E = l * Math.sin(Q * Math.PI / 2);
    I = 0;
    for (Q = z.length; I < Q; I++)
      U = c(z[I], t[I], E), f(U.x, U.y, h + Y);
    K = 0;
    for (A = C.length; K < A; K++)
      for (B = C[K], V = da[K], I = 0, Q = B.length; I < Q; I++)
        U = c(B[I], V[I], E), v ? f(U.x, U.y + r[s - 1].y, r[s - 1].x + Y) : f(U.x, U.y, h + Y);
  }
  (function () {
    if (q) {
      var a;
      a = 0 * la;
      for (I = 0; I < R; I++)
        W = F[I], g(W[2] + a, W[1] + a, W[0] + a, !0);
      a = s + 2 * n;
      a *= la;
      for (I = 0; I < R; I++)
        W = F[I], g(W[0] + a, W[1] + a, W[2] + a, !1);
    } else {
      for (I = 0; I < R; I++)
        W = F[I], g(W[2], W[1], W[0], !0);
      for (I = 0; I < R; I++)
        W = F[I], g(W[0] + la * s, W[1] + la * s, W[2] + la * s, !1);
    }
  }());
  (function () {
    var a = 0;
    e(z, a);
    a += z.length;
    K = 0;
    for (A = C.length; K < A; K++)
      B = C[K], e(B, a), a += B.length;
  }());
};
THREE.ExtrudeGeometry.WorldUVGenerator = {
  generateTopUV: function (a, b, c, d, e, f) {
    b = a.vertices[e].x;
    e = a.vertices[e].y;
    c = a.vertices[f].x;
    f = a.vertices[f].y;
    return [
      new THREE.Vector2(a.vertices[d].x, a.vertices[d].y),
      new THREE.Vector2(b, e),
      new THREE.Vector2(c, f)
    ];
  },
  generateBottomUV: function (a, b, c, d, e, f) {
    return this.generateTopUV(a, b, c, d, e, f);
  },
  generateSideWallUV: function (a, b, c, d, e, f, g, h, k, l, n, q) {
    b = a.vertices[e].x;
    c = a.vertices[e].y;
    e = a.vertices[e].z;
    d = a.vertices[f].x;
    k = a.vertices[f].y;
    f = a.vertices[f].z;
    l = a.vertices[g].x;
    n = a.vertices[g].y;
    g = a.vertices[g].z;
    q = a.vertices[h].x;
    var p = a.vertices[h].y;
    a = a.vertices[h].z;
    return 0.01 > Math.abs(c - k) ? [
      new THREE.Vector2(b, 1 - e),
      new THREE.Vector2(d, 1 - f),
      new THREE.Vector2(l, 1 - g),
      new THREE.Vector2(q, 1 - a)
    ] : [
      new THREE.Vector2(c, 1 - e),
      new THREE.Vector2(k, 1 - f),
      new THREE.Vector2(n, 1 - g),
      new THREE.Vector2(p, 1 - a)
    ];
  }
};
THREE.ExtrudeGeometry.__v1 = new THREE.Vector2();
THREE.ExtrudeGeometry.__v2 = new THREE.Vector2();
THREE.ExtrudeGeometry.__v3 = new THREE.Vector2();
THREE.ExtrudeGeometry.__v4 = new THREE.Vector2();
THREE.ExtrudeGeometry.__v5 = new THREE.Vector2();
THREE.ExtrudeGeometry.__v6 = new THREE.Vector2();
THREE.ShapeGeometry = function (a, b) {
  THREE.Geometry.call(this);
  !1 === a instanceof Array && (a = [a]);
  this.shapebb = a[a.length - 1].getBoundingBox();
  this.addShapeList(a, b);
  this.computeFaceNormals();
};
THREE.ShapeGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.ShapeGeometry.prototype.addShapeList = function (a, b) {
  for (var c = 0, d = a.length; c < d; c++)
    this.addShape(a[c], b);
  return this;
};
THREE.ShapeGeometry.prototype.addShape = function (a, b) {
  void 0 === b && (b = {});
  var c = b.material, d = void 0 === b.UVGenerator ? THREE.ExtrudeGeometry.WorldUVGenerator : b.UVGenerator, e, f, g, h = this.vertices.length;
  e = a.extractPoints(void 0 !== b.curveSegments ? b.curveSegments : 12);
  var k = e.shape, l = e.holes;
  if (!THREE.Shape.Utils.isClockWise(k))
    for (k = k.reverse(), e = 0, f = l.length; e < f; e++)
      g = l[e], THREE.Shape.Utils.isClockWise(g) && (l[e] = g.reverse());
  var n = THREE.Shape.Utils.triangulateShape(k, l);
  e = 0;
  for (f = l.length; e < f; e++)
    g = l[e], k = k.concat(g);
  l = k.length;
  f = n.length;
  for (e = 0; e < l; e++)
    g = k[e], this.vertices.push(new THREE.Vector3(g.x, g.y, 0));
  for (e = 0; e < f; e++)
    l = n[e], k = l[0] + h, g = l[1] + h, l = l[2] + h, this.faces.push(new THREE.Face3(k, g, l, null, null, c)), this.faceVertexUvs[0].push(d.generateBottomUV(this, a, b, k, g, l));
};
THREE.LatheGeometry = function (a, b, c, d) {
  THREE.Geometry.call(this);
  b = b || 12;
  c = c || 0;
  d = d || 2 * Math.PI;
  for (var e = 1 / (a.length - 1), f = 1 / b, g = 0, h = b; g <= h; g++)
    for (var k = c + g * f * d, l = Math.cos(k), n = Math.sin(k), k = 0, q = a.length; k < q; k++) {
      var p = a[k], s = new THREE.Vector3();
      s.x = l * p.x - n * p.y;
      s.y = n * p.x + l * p.y;
      s.z = p.z;
      this.vertices.push(s);
    }
  c = a.length;
  g = 0;
  for (h = b; g < h; g++)
    for (k = 0, q = a.length - 1; k < q; k++) {
      b = n = k + c * g;
      d = n + c;
      var l = n + 1 + c, n = n + 1, p = g * f, s = k * e, t = p + f, r = s + e;
      this.faces.push(new THREE.Face3(b, d, n));
      this.faceVertexUvs[0].push([
        new THREE.Vector2(p, s),
        new THREE.Vector2(t, s),
        new THREE.Vector2(p, r)
      ]);
      this.faces.push(new THREE.Face3(d, l, n));
      this.faceVertexUvs[0].push([
        new THREE.Vector2(t, s),
        new THREE.Vector2(t, r),
        new THREE.Vector2(p, r)
      ]);
    }
  this.mergeVertices();
  this.computeFaceNormals();
  this.computeVertexNormals();
};
THREE.LatheGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.PlaneGeometry = function (a, b, c, d) {
  THREE.Geometry.call(this);
  this.parameters = {
    width: a,
    height: b,
    widthSegments: c,
    heightSegments: d
  };
  var e = a / 2, f = b / 2;
  c = c || 1;
  d = d || 1;
  var g = c + 1, h = d + 1, k = a / c, l = b / d, n = new THREE.Vector3(0, 0, 1);
  for (a = 0; a < h; a++) {
    var q = a * l - f;
    for (b = 0; b < g; b++)
      this.vertices.push(new THREE.Vector3(b * k - e, -q, 0));
  }
  for (a = 0; a < d; a++)
    for (b = 0; b < c; b++) {
      var p = b + g * a, e = b + g * (a + 1), f = b + 1 + g * (a + 1), h = b + 1 + g * a, k = new THREE.Vector2(b / c, 1 - a / d), l = new THREE.Vector2(b / c, 1 - (a + 1) / d), q = new THREE.Vector2((b + 1) / c, 1 - (a + 1) / d), s = new THREE.Vector2((b + 1) / c, 1 - a / d), p = new THREE.Face3(p, e, h);
      p.normal.copy(n);
      p.vertexNormals.push(n.clone(), n.clone(), n.clone());
      this.faces.push(p);
      this.faceVertexUvs[0].push([
        k,
        l,
        s
      ]);
      p = new THREE.Face3(e, f, h);
      p.normal.copy(n);
      p.vertexNormals.push(n.clone(), n.clone(), n.clone());
      this.faces.push(p);
      this.faceVertexUvs[0].push([
        l.clone(),
        q,
        s.clone()
      ]);
    }
};
THREE.PlaneGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.RingGeometry = function (a, b, c, d, e, f) {
  THREE.Geometry.call(this);
  a = a || 0;
  b = b || 50;
  e = void 0 !== e ? e : 0;
  f = void 0 !== f ? f : 2 * Math.PI;
  c = void 0 !== c ? Math.max(3, c) : 8;
  d = void 0 !== d ? Math.max(3, d) : 8;
  var g, h = [], k = a, l = (b - a) / d;
  for (a = 0; a <= d; a++) {
    for (g = 0; g <= c; g++) {
      var n = new THREE.Vector3(), q = e + g / c * f;
      n.x = k * Math.cos(q);
      n.y = k * Math.sin(q);
      this.vertices.push(n);
      h.push(new THREE.Vector2((n.x / b + 1) / 2, (n.y / b + 1) / 2));
    }
    k += l;
  }
  b = new THREE.Vector3(0, 0, 1);
  for (a = 0; a < d; a++)
    for (e = a * c, g = 0; g <= c; g++)
      q = g + e, f = q + a, l = q + c + a, n = q + c + 1 + a, this.faces.push(new THREE.Face3(f, l, n, [
        b.clone(),
        b.clone(),
        b.clone()
      ])), this.faceVertexUvs[0].push([
        h[f].clone(),
        h[l].clone(),
        h[n].clone()
      ]), f = q + a, l = q + c + 1 + a, n = q + 1 + a, this.faces.push(new THREE.Face3(f, l, n, [
        b.clone(),
        b.clone(),
        b.clone()
      ])), this.faceVertexUvs[0].push([
        h[f].clone(),
        h[l].clone(),
        h[n].clone()
      ]);
  this.computeFaceNormals();
  this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), k);
};
THREE.RingGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.SphereGeometry = function (a, b, c, d, e, f, g) {
  THREE.Geometry.call(this);
  this.parameters = {
    radius: a,
    widthSegments: b,
    heightSegments: c,
    phiStart: d,
    phiLength: e,
    thetaStart: f,
    thetaLength: g
  };
  a = a || 50;
  b = Math.max(3, Math.floor(b) || 8);
  c = Math.max(2, Math.floor(c) || 6);
  d = void 0 !== d ? d : 0;
  e = void 0 !== e ? e : 2 * Math.PI;
  f = void 0 !== f ? f : 0;
  g = void 0 !== g ? g : Math.PI;
  var h, k, l = [], n = [];
  for (k = 0; k <= c; k++) {
    var q = [], p = [];
    for (h = 0; h <= b; h++) {
      var s = h / b, t = k / c, r = new THREE.Vector3();
      r.x = -a * Math.cos(d + s * e) * Math.sin(f + t * g);
      r.y = a * Math.cos(f + t * g);
      r.z = a * Math.sin(d + s * e) * Math.sin(f + t * g);
      this.vertices.push(r);
      q.push(this.vertices.length - 1);
      p.push(new THREE.Vector2(s, 1 - t));
    }
    l.push(q);
    n.push(p);
  }
  for (k = 0; k < c; k++)
    for (h = 0; h < b; h++) {
      d = l[k][h + 1];
      e = l[k][h];
      f = l[k + 1][h];
      g = l[k + 1][h + 1];
      var q = this.vertices[d].clone().normalize(), p = this.vertices[e].clone().normalize(), s = this.vertices[f].clone().normalize(), t = this.vertices[g].clone().normalize(), r = n[k][h + 1].clone(), v = n[k][h].clone(), w = n[k + 1][h].clone(), u = n[k + 1][h + 1].clone();
      Math.abs(this.vertices[d].y) === a ? (r.x = (r.x + v.x) / 2, this.faces.push(new THREE.Face3(d, f, g, [
        q,
        s,
        t
      ])), this.faceVertexUvs[0].push([
        r,
        w,
        u
      ])) : Math.abs(this.vertices[f].y) === a ? (w.x = (w.x + u.x) / 2, this.faces.push(new THREE.Face3(d, e, f, [
        q,
        p,
        s
      ])), this.faceVertexUvs[0].push([
        r,
        v,
        w
      ])) : (this.faces.push(new THREE.Face3(d, e, g, [
        q,
        p,
        t
      ])), this.faceVertexUvs[0].push([
        r,
        v,
        u
      ]), this.faces.push(new THREE.Face3(e, f, g, [
        p.clone(),
        s,
        t.clone()
      ])), this.faceVertexUvs[0].push([
        v.clone(),
        w,
        u.clone()
      ]));
    }
  this.computeFaceNormals();
  this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), a);
};
THREE.SphereGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.TextGeometry = function (a, b) {
  b = b || {};
  var c = THREE.FontUtils.generateShapes(a, b);
  b.amount = void 0 !== b.height ? b.height : 50;
  void 0 === b.bevelThickness && (b.bevelThickness = 10);
  void 0 === b.bevelSize && (b.bevelSize = 8);
  void 0 === b.bevelEnabled && (b.bevelEnabled = !1);
  THREE.ExtrudeGeometry.call(this, c, b);
};
THREE.TextGeometry.prototype = Object.create(THREE.ExtrudeGeometry.prototype);
THREE.TorusGeometry = function (a, b, c, d, e) {
  THREE.Geometry.call(this);
  this.parameters = {
    radius: a,
    tube: b,
    radialSegments: c,
    tubularSegments: d,
    arc: e
  };
  a = a || 100;
  b = b || 40;
  c = c || 8;
  d = d || 6;
  e = e || 2 * Math.PI;
  for (var f = new THREE.Vector3(), g = [], h = [], k = 0; k <= c; k++)
    for (var l = 0; l <= d; l++) {
      var n = l / d * e, q = k / c * Math.PI * 2;
      f.x = a * Math.cos(n);
      f.y = a * Math.sin(n);
      var p = new THREE.Vector3();
      p.x = (a + b * Math.cos(q)) * Math.cos(n);
      p.y = (a + b * Math.cos(q)) * Math.sin(n);
      p.z = b * Math.sin(q);
      this.vertices.push(p);
      g.push(new THREE.Vector2(l / d, k / c));
      h.push(p.clone().sub(f).normalize());
    }
  for (k = 1; k <= c; k++)
    for (l = 1; l <= d; l++)
      a = (d + 1) * k + l - 1, b = (d + 1) * (k - 1) + l - 1, e = (d + 1) * (k - 1) + l, f = (d + 1) * k + l, n = new THREE.Face3(a, b, f, [
        h[a].clone(),
        h[b].clone(),
        h[f].clone()
      ]), this.faces.push(n), this.faceVertexUvs[0].push([
        g[a].clone(),
        g[b].clone(),
        g[f].clone()
      ]), n = new THREE.Face3(b, e, f, [
        h[b].clone(),
        h[e].clone(),
        h[f].clone()
      ]), this.faces.push(n), this.faceVertexUvs[0].push([
        g[b].clone(),
        g[e].clone(),
        g[f].clone()
      ]);
  this.computeFaceNormals();
};
THREE.TorusGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.TorusKnotGeometry = function (a, b, c, d, e, f, g) {
  function h(a, b, c, d, e) {
    var f = Math.cos(a), g = Math.sin(a);
    a *= b / c;
    b = Math.cos(a);
    f *= d * (2 + b) * 0.5;
    g = d * (2 + b) * g * 0.5;
    d = e * d * Math.sin(a) * 0.5;
    return new THREE.Vector3(f, g, d);
  }
  THREE.Geometry.call(this);
  this.parameters = {
    radius: a,
    tube: b,
    radialSegments: c,
    tubularSegments: d,
    p: e,
    q: f,
    heightScale: g
  };
  a = a || 100;
  b = b || 40;
  c = c || 64;
  d = d || 8;
  e = e || 2;
  f = f || 3;
  g = g || 1;
  for (var k = Array(c), l = new THREE.Vector3(), n = new THREE.Vector3(), q = new THREE.Vector3(), p = 0; p < c; ++p) {
    k[p] = Array(d);
    var s = p / c * 2 * e * Math.PI, t = h(s, f, e, a, g), s = h(s + 0.01, f, e, a, g);
    l.subVectors(s, t);
    n.addVectors(s, t);
    q.crossVectors(l, n);
    n.crossVectors(q, l);
    q.normalize();
    n.normalize();
    for (s = 0; s < d; ++s) {
      var r = s / d * 2 * Math.PI, v = -b * Math.cos(r), r = b * Math.sin(r), w = new THREE.Vector3();
      w.x = t.x + v * n.x + r * q.x;
      w.y = t.y + v * n.y + r * q.y;
      w.z = t.z + v * n.z + r * q.z;
      k[p][s] = this.vertices.push(w) - 1;
    }
  }
  for (p = 0; p < c; ++p)
    for (s = 0; s < d; ++s)
      e = (p + 1) % c, f = (s + 1) % d, a = k[p][s], b = k[e][s], e = k[e][f], f = k[p][f], g = new THREE.Vector2(p / c, s / d), l = new THREE.Vector2((p + 1) / c, s / d), n = new THREE.Vector2((p + 1) / c, (s + 1) / d), q = new THREE.Vector2(p / c, (s + 1) / d), this.faces.push(new THREE.Face3(a, b, f)), this.faceVertexUvs[0].push([
        g,
        l,
        q
      ]), this.faces.push(new THREE.Face3(b, e, f)), this.faceVertexUvs[0].push([
        l.clone(),
        n,
        q.clone()
      ]);
  this.computeFaceNormals();
  this.computeVertexNormals();
};
THREE.TorusKnotGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.TubeGeometry = function (a, b, c, d, e) {
  THREE.Geometry.call(this);
  this.parameters = {
    path: a,
    segments: b,
    radius: c,
    radialSegments: d,
    closed: e
  };
  b = b || 64;
  c = c || 1;
  d = d || 8;
  e = e || !1;
  var f = [], g, h, k = b + 1, l, n, q, p, s = new THREE.Vector3(), t, r, v;
  t = new THREE.TubeGeometry.FrenetFrames(a, b, e);
  r = t.normals;
  v = t.binormals;
  this.tangents = t.tangents;
  this.normals = r;
  this.binormals = v;
  for (t = 0; t < k; t++)
    for (f[t] = [], l = t / (k - 1), p = a.getPointAt(l), g = r[t], h = v[t], l = 0; l < d; l++)
      n = l / d * 2 * Math.PI, q = -c * Math.cos(n), n = c * Math.sin(n), s.copy(p), s.x += q * g.x + n * h.x, s.y += q * g.y + n * h.y, s.z += q * g.z + n * h.z, f[t][l] = this.vertices.push(new THREE.Vector3(s.x, s.y, s.z)) - 1;
  for (t = 0; t < b; t++)
    for (l = 0; l < d; l++)
      k = e ? (t + 1) % b : t + 1, s = (l + 1) % d, a = f[t][l], c = f[k][l], k = f[k][s], s = f[t][s], r = new THREE.Vector2(t / b, l / d), v = new THREE.Vector2((t + 1) / b, l / d), g = new THREE.Vector2((t + 1) / b, (l + 1) / d), h = new THREE.Vector2(t / b, (l + 1) / d), this.faces.push(new THREE.Face3(a, c, s)), this.faceVertexUvs[0].push([
        r,
        v,
        h
      ]), this.faces.push(new THREE.Face3(c, k, s)), this.faceVertexUvs[0].push([
        v.clone(),
        g,
        h.clone()
      ]);
  this.computeFaceNormals();
  this.computeVertexNormals();
};
THREE.TubeGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.TubeGeometry.FrenetFrames = function (a, b, c) {
  new THREE.Vector3();
  var d = new THREE.Vector3();
  new THREE.Vector3();
  var e = [], f = [], g = [], h = new THREE.Vector3(), k = new THREE.Matrix4();
  b += 1;
  var l, n, q;
  this.tangents = e;
  this.normals = f;
  this.binormals = g;
  for (l = 0; l < b; l++)
    n = l / (b - 1), e[l] = a.getTangentAt(n), e[l].normalize();
  f[0] = new THREE.Vector3();
  g[0] = new THREE.Vector3();
  a = Number.MAX_VALUE;
  l = Math.abs(e[0].x);
  n = Math.abs(e[0].y);
  q = Math.abs(e[0].z);
  l <= a && (a = l, d.set(1, 0, 0));
  n <= a && (a = n, d.set(0, 1, 0));
  q <= a && d.set(0, 0, 1);
  h.crossVectors(e[0], d).normalize();
  f[0].crossVectors(e[0], h);
  g[0].crossVectors(e[0], f[0]);
  for (l = 1; l < b; l++)
    f[l] = f[l - 1].clone(), g[l] = g[l - 1].clone(), h.crossVectors(e[l - 1], e[l]), 0.0001 < h.length() && (h.normalize(), d = Math.acos(THREE.Math.clamp(e[l - 1].dot(e[l]), -1, 1)), f[l].applyMatrix4(k.makeRotationAxis(h, d))), g[l].crossVectors(e[l], f[l]);
  if (c)
    for (d = Math.acos(THREE.Math.clamp(f[0].dot(f[b - 1]), -1, 1)), d /= b - 1, 0 < e[0].dot(h.crossVectors(f[0], f[b - 1])) && (d = -d), l = 1; l < b; l++)
      f[l].applyMatrix4(k.makeRotationAxis(e[l], d * l)), g[l].crossVectors(e[l], f[l]);
};
THREE.PolyhedronGeometry = function (a, b, c, d) {
  function e(a) {
    var b = a.normalize().clone();
    b.index = k.vertices.push(b) - 1;
    var c = Math.atan2(a.z, -a.x) / 2 / Math.PI + 0.5;
    a = Math.atan2(-a.y, Math.sqrt(a.x * a.x + a.z * a.z)) / Math.PI + 0.5;
    b.uv = new THREE.Vector2(c, 1 - a);
    return b;
  }
  function f(a, b, c) {
    var d = new THREE.Face3(a.index, b.index, c.index, [
        a.clone(),
        b.clone(),
        c.clone()
      ]);
    k.faces.push(d);
    v.copy(a).add(b).add(c).divideScalar(3);
    d = Math.atan2(v.z, -v.x);
    k.faceVertexUvs[0].push([
      h(a.uv, a, d),
      h(b.uv, b, d),
      h(c.uv, c, d)
    ]);
  }
  function g(a, b) {
    var c = Math.pow(2, b);
    Math.pow(4, b);
    for (var d = e(k.vertices[a.a]), g = e(k.vertices[a.b]), h = e(k.vertices[a.c]), l = [], n = 0; n <= c; n++) {
      l[n] = [];
      for (var p = e(d.clone().lerp(h, n / c)), q = e(g.clone().lerp(h, n / c)), r = c - n, s = 0; s <= r; s++)
        l[n][s] = 0 == s && n == c ? p : e(p.clone().lerp(q, s / r));
    }
    for (n = 0; n < c; n++)
      for (s = 0; s < 2 * (c - n) - 1; s++)
        d = Math.floor(s / 2), 0 == s % 2 ? f(l[n][d + 1], l[n + 1][d], l[n][d]) : f(l[n][d + 1], l[n + 1][d + 1], l[n + 1][d]);
  }
  function h(a, b, c) {
    0 > c && 1 === a.x && (a = new THREE.Vector2(a.x - 1, a.y));
    0 === b.x && 0 === b.z && (a = new THREE.Vector2(c / 2 / Math.PI + 0.5, a.y));
    return a.clone();
  }
  THREE.Geometry.call(this);
  c = c || 1;
  d = d || 0;
  for (var k = this, l = 0, n = a.length; l < n; l += 3)
    e(new THREE.Vector3(a[l], a[l + 1], a[l + 2]));
  a = this.vertices;
  for (var q = [], p = l = 0, n = b.length; l < n; l += 3, p++) {
    var s = a[b[l]], t = a[b[l + 1]], r = a[b[l + 2]];
    q[p] = new THREE.Face3(s.index, t.index, r.index, [
      s.clone(),
      t.clone(),
      r.clone()
    ]);
  }
  for (var v = new THREE.Vector3(), l = 0, n = q.length; l < n; l++)
    g(q[l], d);
  l = 0;
  for (n = this.faceVertexUvs[0].length; l < n; l++)
    b = this.faceVertexUvs[0][l], d = b[0].x, a = b[1].x, q = b[2].x, p = Math.max(d, Math.max(a, q)), s = Math.min(d, Math.min(a, q)), 0.9 < p && 0.1 > s && (0.2 > d && (b[0].x += 1), 0.2 > a && (b[1].x += 1), 0.2 > q && (b[2].x += 1));
  l = 0;
  for (n = this.vertices.length; l < n; l++)
    this.vertices[l].multiplyScalar(c);
  this.mergeVertices();
  this.computeFaceNormals();
  this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), c);
};
THREE.PolyhedronGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.IcosahedronGeometry = function (a, b) {
  this.parameters = {
    radius: a,
    detail: b
  };
  var c = (1 + Math.sqrt(5)) / 2;
  THREE.PolyhedronGeometry.call(this, [
    -1,
    c,
    0,
    1,
    c,
    0,
    -1,
    -c,
    0,
    1,
    -c,
    0,
    0,
    -1,
    c,
    0,
    1,
    c,
    0,
    -1,
    -c,
    0,
    1,
    -c,
    c,
    0,
    -1,
    c,
    0,
    1,
    -c,
    0,
    -1,
    -c,
    0,
    1
  ], [
    0,
    11,
    5,
    0,
    5,
    1,
    0,
    1,
    7,
    0,
    7,
    10,
    0,
    10,
    11,
    1,
    5,
    9,
    5,
    11,
    4,
    11,
    10,
    2,
    10,
    7,
    6,
    7,
    1,
    8,
    3,
    9,
    4,
    3,
    4,
    2,
    3,
    2,
    6,
    3,
    6,
    8,
    3,
    8,
    9,
    4,
    9,
    5,
    2,
    4,
    11,
    6,
    2,
    10,
    8,
    6,
    7,
    9,
    8,
    1
  ], a, b);
};
THREE.IcosahedronGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.OctahedronGeometry = function (a, b) {
  this.parameters = {
    radius: a,
    detail: b
  };
  THREE.PolyhedronGeometry.call(this, [
    1,
    0,
    0,
    -1,
    0,
    0,
    0,
    1,
    0,
    0,
    -1,
    0,
    0,
    0,
    1,
    0,
    0,
    -1
  ], [
    0,
    2,
    4,
    0,
    4,
    3,
    0,
    3,
    5,
    0,
    5,
    2,
    1,
    2,
    5,
    1,
    5,
    3,
    1,
    3,
    4,
    1,
    4,
    2
  ], a, b);
};
THREE.OctahedronGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.TetrahedronGeometry = function (a, b) {
  THREE.PolyhedronGeometry.call(this, [
    1,
    1,
    1,
    -1,
    -1,
    1,
    -1,
    1,
    -1,
    1,
    -1,
    -1
  ], [
    2,
    1,
    0,
    0,
    3,
    2,
    1,
    3,
    0,
    2,
    3,
    1
  ], a, b);
};
THREE.TetrahedronGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.ParametricGeometry = function (a, b, c) {
  THREE.Geometry.call(this);
  var d = this.vertices, e = this.faces, f = this.faceVertexUvs[0], g, h, k, l, n = b + 1;
  for (g = 0; g <= c; g++)
    for (l = g / c, h = 0; h <= b; h++)
      k = h / b, k = a(k, l), d.push(k);
  var q, p, s, t;
  for (g = 0; g < c; g++)
    for (h = 0; h < b; h++)
      a = g * n + h, d = g * n + h + 1, l = (g + 1) * n + h + 1, k = (g + 1) * n + h, q = new THREE.Vector2(h / b, g / c), p = new THREE.Vector2((h + 1) / b, g / c), s = new THREE.Vector2((h + 1) / b, (g + 1) / c), t = new THREE.Vector2(h / b, (g + 1) / c), e.push(new THREE.Face3(a, d, k)), f.push([
        q,
        p,
        t
      ]), e.push(new THREE.Face3(d, l, k)), f.push([
        p.clone(),
        s,
        t.clone()
      ]);
  this.computeFaceNormals();
  this.computeVertexNormals();
};
THREE.ParametricGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.AxisHelper = function (a) {
  a = a || 1;
  var b = new THREE.Geometry();
  b.vertices.push(new THREE.Vector3(), new THREE.Vector3(a, 0, 0), new THREE.Vector3(), new THREE.Vector3(0, a, 0), new THREE.Vector3(), new THREE.Vector3(0, 0, a));
  b.colors.push(new THREE.Color(16711680), new THREE.Color(16755200), new THREE.Color(65280), new THREE.Color(11206400), new THREE.Color(255), new THREE.Color(43775));
  a = new THREE.LineBasicMaterial({ vertexColors: THREE.VertexColors });
  THREE.Line.call(this, b, a, THREE.LinePieces);
};
THREE.AxisHelper.prototype = Object.create(THREE.Line.prototype);
THREE.ArrowHelper = function (a, b, c, d, e, f) {
  THREE.Object3D.call(this);
  void 0 === d && (d = 16776960);
  void 0 === c && (c = 1);
  void 0 === e && (e = 0.2 * c);
  void 0 === f && (f = 0.2 * e);
  this.position = b;
  b = new THREE.Geometry();
  b.vertices.push(new THREE.Vector3(0, 0, 0));
  b.vertices.push(new THREE.Vector3(0, 1, 0));
  this.line = new THREE.Line(b, new THREE.LineBasicMaterial({ color: d }));
  this.line.matrixAutoUpdate = !1;
  this.add(this.line);
  b = new THREE.CylinderGeometry(0, 0.5, 1, 5, 1);
  b.applyMatrix(new THREE.Matrix4().makeTranslation(0, -0.5, 0));
  this.cone = new THREE.Mesh(b, new THREE.MeshBasicMaterial({ color: d }));
  this.cone.matrixAutoUpdate = !1;
  this.add(this.cone);
  this.setDirection(a);
  this.setLength(c, e, f);
};
THREE.ArrowHelper.prototype = Object.create(THREE.Object3D.prototype);
THREE.ArrowHelper.prototype.setDirection = function () {
  var a = new THREE.Vector3(), b;
  return function (c) {
    0.99999 < c.y ? this.quaternion.set(0, 0, 0, 1) : -0.99999 > c.y ? this.quaternion.set(1, 0, 0, 0) : (a.set(c.z, 0, -c.x).normalize(), b = Math.acos(c.y), this.quaternion.setFromAxisAngle(a, b));
  };
}();
THREE.ArrowHelper.prototype.setLength = function (a, b, c) {
  void 0 === b && (b = 0.2 * a);
  void 0 === c && (c = 0.2 * b);
  this.line.scale.set(1, a, 1);
  this.line.updateMatrix();
  this.cone.scale.set(c, b, c);
  this.cone.position.y = a;
  this.cone.updateMatrix();
};
THREE.ArrowHelper.prototype.setColor = function (a) {
  this.line.material.color.set(a);
  this.cone.material.color.set(a);
};
THREE.BoxHelper = function (a) {
  var b = [
      new THREE.Vector3(1, 1, 1),
      new THREE.Vector3(-1, 1, 1),
      new THREE.Vector3(-1, -1, 1),
      new THREE.Vector3(1, -1, 1),
      new THREE.Vector3(1, 1, -1),
      new THREE.Vector3(-1, 1, -1),
      new THREE.Vector3(-1, -1, -1),
      new THREE.Vector3(1, -1, -1)
    ];
  this.vertices = b;
  var c = new THREE.Geometry();
  c.vertices.push(b[0], b[1], b[1], b[2], b[2], b[3], b[3], b[0], b[4], b[5], b[5], b[6], b[6], b[7], b[7], b[4], b[0], b[4], b[1], b[5], b[2], b[6], b[3], b[7]);
  THREE.Line.call(this, c, new THREE.LineBasicMaterial({ color: 16776960 }), THREE.LinePieces);
  void 0 !== a && this.update(a);
};
THREE.BoxHelper.prototype = Object.create(THREE.Line.prototype);
THREE.BoxHelper.prototype.update = function (a) {
  var b = a.geometry;
  null === b.boundingBox && b.computeBoundingBox();
  var c = b.boundingBox.min, b = b.boundingBox.max, d = this.vertices;
  d[0].set(b.x, b.y, b.z);
  d[1].set(c.x, b.y, b.z);
  d[2].set(c.x, c.y, b.z);
  d[3].set(b.x, c.y, b.z);
  d[4].set(b.x, b.y, c.z);
  d[5].set(c.x, b.y, c.z);
  d[6].set(c.x, c.y, c.z);
  d[7].set(b.x, c.y, c.z);
  this.geometry.computeBoundingSphere();
  this.geometry.verticesNeedUpdate = !0;
  this.matrixAutoUpdate = !1;
  this.matrixWorld = a.matrixWorld;
};
THREE.BoundingBoxHelper = function (a, b) {
  var c = void 0 !== b ? b : 8947848;
  this.object = a;
  this.box = new THREE.Box3();
  THREE.Mesh.call(this, new THREE.BoxGeometry(1, 1, 1), new THREE.MeshBasicMaterial({
    color: c,
    wireframe: !0
  }));
};
THREE.BoundingBoxHelper.prototype = Object.create(THREE.Mesh.prototype);
THREE.BoundingBoxHelper.prototype.update = function () {
  this.box.setFromObject(this.object);
  this.box.size(this.scale);
  this.box.center(this.position);
};
THREE.CameraHelper = function (a) {
  function b(a, b, d) {
    c(a, d);
    c(b, d);
  }
  function c(a, b) {
    d.vertices.push(new THREE.Vector3());
    d.colors.push(new THREE.Color(b));
    void 0 === f[a] && (f[a] = []);
    f[a].push(d.vertices.length - 1);
  }
  var d = new THREE.Geometry(), e = new THREE.LineBasicMaterial({
      color: 16777215,
      vertexColors: THREE.FaceColors
    }), f = {};
  b('n1', 'n2', 16755200);
  b('n2', 'n4', 16755200);
  b('n4', 'n3', 16755200);
  b('n3', 'n1', 16755200);
  b('f1', 'f2', 16755200);
  b('f2', 'f4', 16755200);
  b('f4', 'f3', 16755200);
  b('f3', 'f1', 16755200);
  b('n1', 'f1', 16755200);
  b('n2', 'f2', 16755200);
  b('n3', 'f3', 16755200);
  b('n4', 'f4', 16755200);
  b('p', 'n1', 16711680);
  b('p', 'n2', 16711680);
  b('p', 'n3', 16711680);
  b('p', 'n4', 16711680);
  b('u1', 'u2', 43775);
  b('u2', 'u3', 43775);
  b('u3', 'u1', 43775);
  b('c', 't', 16777215);
  b('p', 'c', 3355443);
  b('cn1', 'cn2', 3355443);
  b('cn3', 'cn4', 3355443);
  b('cf1', 'cf2', 3355443);
  b('cf3', 'cf4', 3355443);
  THREE.Line.call(this, d, e, THREE.LinePieces);
  this.camera = a;
  this.matrixWorld = a.matrixWorld;
  this.matrixAutoUpdate = !1;
  this.pointMap = f;
  this.update();
};
THREE.CameraHelper.prototype = Object.create(THREE.Line.prototype);
THREE.CameraHelper.prototype.update = function () {
  var a = new THREE.Vector3(), b = new THREE.Camera(), c = new THREE.Projector();
  return function () {
    function d(d, g, h, k) {
      a.set(g, h, k);
      c.unprojectVector(a, b);
      d = e.pointMap[d];
      if (void 0 !== d)
        for (g = 0, h = d.length; g < h; g++)
          e.geometry.vertices[d[g]].copy(a);
    }
    var e = this;
    b.projectionMatrix.copy(this.camera.projectionMatrix);
    d('c', 0, 0, -1);
    d('t', 0, 0, 1);
    d('n1', -1, -1, -1);
    d('n2', 1, -1, -1);
    d('n3', -1, 1, -1);
    d('n4', 1, 1, -1);
    d('f1', -1, -1, 1);
    d('f2', 1, -1, 1);
    d('f3', -1, 1, 1);
    d('f4', 1, 1, 1);
    d('u1', 0.7, 1.1, -1);
    d('u2', -0.7, 1.1, -1);
    d('u3', 0, 2, -1);
    d('cf1', -1, 0, 1);
    d('cf2', 1, 0, 1);
    d('cf3', 0, -1, 1);
    d('cf4', 0, 1, 1);
    d('cn1', -1, 0, -1);
    d('cn2', 1, 0, -1);
    d('cn3', 0, -1, -1);
    d('cn4', 0, 1, -1);
    this.geometry.verticesNeedUpdate = !0;
  };
}();
THREE.DirectionalLightHelper = function (a, b) {
  THREE.Object3D.call(this);
  this.light = a;
  this.light.updateMatrixWorld();
  this.matrixWorld = a.matrixWorld;
  this.matrixAutoUpdate = !1;
  b = b || 1;
  var c = new THREE.Geometry();
  c.vertices.push(new THREE.Vector3(-b, b, 0), new THREE.Vector3(b, b, 0), new THREE.Vector3(b, -b, 0), new THREE.Vector3(-b, -b, 0), new THREE.Vector3(-b, b, 0));
  var d = new THREE.LineBasicMaterial({ fog: !1 });
  d.color.copy(this.light.color).multiplyScalar(this.light.intensity);
  this.lightPlane = new THREE.Line(c, d);
  this.add(this.lightPlane);
  c = new THREE.Geometry();
  c.vertices.push(new THREE.Vector3(), new THREE.Vector3());
  d = new THREE.LineBasicMaterial({ fog: !1 });
  d.color.copy(this.light.color).multiplyScalar(this.light.intensity);
  this.targetLine = new THREE.Line(c, d);
  this.add(this.targetLine);
  this.update();
};
THREE.DirectionalLightHelper.prototype = Object.create(THREE.Object3D.prototype);
THREE.DirectionalLightHelper.prototype.dispose = function () {
  this.lightPlane.geometry.dispose();
  this.lightPlane.material.dispose();
  this.targetLine.geometry.dispose();
  this.targetLine.material.dispose();
};
THREE.DirectionalLightHelper.prototype.update = function () {
  var a = new THREE.Vector3(), b = new THREE.Vector3(), c = new THREE.Vector3();
  return function () {
    a.setFromMatrixPosition(this.light.matrixWorld);
    b.setFromMatrixPosition(this.light.target.matrixWorld);
    c.subVectors(b, a);
    this.lightPlane.lookAt(c);
    this.lightPlane.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
    this.targetLine.geometry.vertices[1].copy(c);
    this.targetLine.geometry.verticesNeedUpdate = !0;
    this.targetLine.material.color.copy(this.lightPlane.material.color);
  };
}();
THREE.EdgesHelper = function (a, b) {
  var c = void 0 !== b ? b : 16777215, d = [
      0,
      0
    ], e = {}, f = function (a, b) {
      return a - b;
    }, g = [
      'a',
      'b',
      'c'
    ], h = new THREE.BufferGeometry(), k = a.geometry.clone();
  k.mergeVertices();
  k.computeFaceNormals();
  for (var l = k.vertices, k = k.faces, n = 0, q = 0, p = k.length; q < p; q++)
    for (var s = k[q], t = 0; 3 > t; t++) {
      d[0] = s[g[t]];
      d[1] = s[g[(t + 1) % 3]];
      d.sort(f);
      var r = d.toString();
      void 0 === e[r] ? (e[r] = {
        vert1: d[0],
        vert2: d[1],
        face1: q,
        face2: void 0
      }, n++) : e[r].face2 = q;
    }
  h.addAttribute('position', new THREE.Float32Attribute(2 * n, 3));
  d = h.attributes.position.array;
  f = 0;
  for (r in e)
    if (g = e[r], void 0 === g.face2 || 0.9999 > k[g.face1].normal.dot(k[g.face2].normal))
      n = l[g.vert1], d[f++] = n.x, d[f++] = n.y, d[f++] = n.z, n = l[g.vert2], d[f++] = n.x, d[f++] = n.y, d[f++] = n.z;
  THREE.Line.call(this, h, new THREE.LineBasicMaterial({ color: c }), THREE.LinePieces);
  this.matrixAutoUpdate = !1;
  this.matrixWorld = a.matrixWorld;
};
THREE.EdgesHelper.prototype = Object.create(THREE.Line.prototype);
THREE.FaceNormalsHelper = function (a, b, c, d) {
  this.object = a;
  this.size = void 0 !== b ? b : 1;
  a = void 0 !== c ? c : 16776960;
  d = void 0 !== d ? d : 1;
  b = new THREE.Geometry();
  c = 0;
  for (var e = this.object.geometry.faces.length; c < e; c++)
    b.vertices.push(new THREE.Vector3(), new THREE.Vector3());
  THREE.Line.call(this, b, new THREE.LineBasicMaterial({
    color: a,
    linewidth: d
  }), THREE.LinePieces);
  this.matrixAutoUpdate = !1;
  this.normalMatrix = new THREE.Matrix3();
  this.update();
};
THREE.FaceNormalsHelper.prototype = Object.create(THREE.Line.prototype);
THREE.FaceNormalsHelper.prototype.update = function () {
  var a = this.geometry.vertices, b = this.object, c = b.geometry.vertices, d = b.geometry.faces, e = b.matrixWorld;
  b.updateMatrixWorld(!0);
  this.normalMatrix.getNormalMatrix(e);
  for (var f = b = 0, g = d.length; b < g; b++, f += 2) {
    var h = d[b];
    a[f].copy(c[h.a]).add(c[h.b]).add(c[h.c]).divideScalar(3).applyMatrix4(e);
    a[f + 1].copy(h.normal).applyMatrix3(this.normalMatrix).normalize().multiplyScalar(this.size).add(a[f]);
  }
  this.geometry.verticesNeedUpdate = !0;
  return this;
};
THREE.GridHelper = function (a, b) {
  var c = new THREE.Geometry(), d = new THREE.LineBasicMaterial({ vertexColors: THREE.VertexColors });
  this.color1 = new THREE.Color(4473924);
  this.color2 = new THREE.Color(8947848);
  for (var e = -a; e <= a; e += b) {
    c.vertices.push(new THREE.Vector3(-a, 0, e), new THREE.Vector3(a, 0, e), new THREE.Vector3(e, 0, -a), new THREE.Vector3(e, 0, a));
    var f = 0 === e ? this.color1 : this.color2;
    c.colors.push(f, f, f, f);
  }
  THREE.Line.call(this, c, d, THREE.LinePieces);
};
THREE.GridHelper.prototype = Object.create(THREE.Line.prototype);
THREE.GridHelper.prototype.setColors = function (a, b) {
  this.color1.set(a);
  this.color2.set(b);
  this.geometry.colorsNeedUpdate = !0;
};
THREE.HemisphereLightHelper = function (a, b, c, d) {
  THREE.Object3D.call(this);
  this.light = a;
  this.light.updateMatrixWorld();
  this.matrixWorld = a.matrixWorld;
  this.matrixAutoUpdate = !1;
  this.colors = [
    new THREE.Color(),
    new THREE.Color()
  ];
  a = new THREE.SphereGeometry(b, 4, 2);
  a.applyMatrix(new THREE.Matrix4().makeRotationX(-Math.PI / 2));
  for (b = 0; 8 > b; b++)
    a.faces[b].color = this.colors[4 > b ? 0 : 1];
  b = new THREE.MeshBasicMaterial({
    vertexColors: THREE.FaceColors,
    wireframe: !0
  });
  this.lightSphere = new THREE.Mesh(a, b);
  this.add(this.lightSphere);
  this.update();
};
THREE.HemisphereLightHelper.prototype = Object.create(THREE.Object3D.prototype);
THREE.HemisphereLightHelper.prototype.dispose = function () {
  this.lightSphere.geometry.dispose();
  this.lightSphere.material.dispose();
};
THREE.HemisphereLightHelper.prototype.update = function () {
  var a = new THREE.Vector3();
  return function () {
    this.colors[0].copy(this.light.color).multiplyScalar(this.light.intensity);
    this.colors[1].copy(this.light.groundColor).multiplyScalar(this.light.intensity);
    this.lightSphere.lookAt(a.setFromMatrixPosition(this.light.matrixWorld).negate());
    this.lightSphere.geometry.colorsNeedUpdate = !0;
  };
}();
THREE.PointLightHelper = function (a, b) {
  this.light = a;
  this.light.updateMatrixWorld();
  var c = new THREE.SphereGeometry(b, 4, 2), d = new THREE.MeshBasicMaterial({
      wireframe: !0,
      fog: !1
    });
  d.color.copy(this.light.color).multiplyScalar(this.light.intensity);
  THREE.Mesh.call(this, c, d);
  this.matrixWorld = this.light.matrixWorld;
  this.matrixAutoUpdate = !1;
};
THREE.PointLightHelper.prototype = Object.create(THREE.Mesh.prototype);
THREE.PointLightHelper.prototype.dispose = function () {
  this.geometry.dispose();
  this.material.dispose();
};
THREE.PointLightHelper.prototype.update = function () {
  this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
};
THREE.SkeletonHelper = function (a) {
  for (var b = a.skeleton, c = new THREE.Geometry(), d = 0; d < b.bones.length; d++)
    b.bones[d].parent instanceof THREE.Bone && (c.vertices.push(new THREE.Vector3()), c.vertices.push(new THREE.Vector3()), c.colors.push(new THREE.Color(0, 0, 1)), c.colors.push(new THREE.Color(0, 1, 0)));
  d = new THREE.LineBasicMaterial({
    vertexColors: !0,
    depthTest: !1,
    depthWrite: !1,
    transparent: !0
  });
  THREE.Line.call(this, c, d, THREE.LinePieces);
  this.skeleton = b;
  this.matrixWorld = a.matrixWorld;
  this.matrixAutoUpdate = !1;
  this.update();
};
THREE.SkeletonHelper.prototype = Object.create(THREE.Line.prototype);
THREE.SkeletonHelper.prototype.update = function () {
  for (var a = this.geometry, b = 0, c = 0; c < this.skeleton.bones.length; c++) {
    var d = this.skeleton.bones[c];
    d.parent instanceof THREE.Bone && (a.vertices[b].setFromMatrixPosition(d.skinMatrix), a.vertices[b + 1].setFromMatrixPosition(d.parent.skinMatrix), b += 2);
  }
  a.verticesNeedUpdate = !0;
  a.computeBoundingSphere();
};
THREE.SpotLightHelper = function (a) {
  THREE.Object3D.call(this);
  this.light = a;
  this.light.updateMatrixWorld();
  this.matrixWorld = a.matrixWorld;
  this.matrixAutoUpdate = !1;
  a = new THREE.CylinderGeometry(0, 1, 1, 8, 1, !0);
  a.applyMatrix(new THREE.Matrix4().makeTranslation(0, -0.5, 0));
  a.applyMatrix(new THREE.Matrix4().makeRotationX(-Math.PI / 2));
  var b = new THREE.MeshBasicMaterial({
      wireframe: !0,
      fog: !1
    });
  this.cone = new THREE.Mesh(a, b);
  this.add(this.cone);
  this.update();
};
THREE.SpotLightHelper.prototype = Object.create(THREE.Object3D.prototype);
THREE.SpotLightHelper.prototype.dispose = function () {
  this.cone.geometry.dispose();
  this.cone.material.dispose();
};
THREE.SpotLightHelper.prototype.update = function () {
  var a = new THREE.Vector3(), b = new THREE.Vector3();
  return function () {
    var c = this.light.distance ? this.light.distance : 10000, d = c * Math.tan(this.light.angle);
    this.cone.scale.set(d, d, c);
    a.setFromMatrixPosition(this.light.matrixWorld);
    b.setFromMatrixPosition(this.light.target.matrixWorld);
    this.cone.lookAt(b.sub(a));
    this.cone.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
  };
}();
THREE.VertexNormalsHelper = function (a, b, c, d) {
  this.object = a;
  this.size = void 0 !== b ? b : 1;
  b = void 0 !== c ? c : 16711680;
  d = void 0 !== d ? d : 1;
  c = new THREE.Geometry();
  a = a.geometry.faces;
  for (var e = 0, f = a.length; e < f; e++)
    for (var g = 0, h = a[e].vertexNormals.length; g < h; g++)
      c.vertices.push(new THREE.Vector3()), c.vertices.push(new THREE.Vector3());
  THREE.Line.call(this, c, new THREE.LineBasicMaterial({
    color: b,
    linewidth: d
  }), THREE.LinePieces);
  this.matrixAutoUpdate = !1;
  this.normalMatrix = new THREE.Matrix3();
  this.update();
};
THREE.VertexNormalsHelper.prototype = Object.create(THREE.Line.prototype);
THREE.VertexNormalsHelper.prototype.update = function (a) {
  var b = new THREE.Vector3();
  return function (a) {
    a = [
      'a',
      'b',
      'c',
      'd'
    ];
    this.object.updateMatrixWorld(!0);
    this.normalMatrix.getNormalMatrix(this.object.matrixWorld);
    for (var d = this.geometry.vertices, e = this.object.geometry.vertices, f = this.object.geometry.faces, g = this.object.matrixWorld, h = 0, k = 0, l = f.length; k < l; k++)
      for (var n = f[k], q = 0, p = n.vertexNormals.length; q < p; q++) {
        var s = n.vertexNormals[q];
        d[h].copy(e[n[a[q]]]).applyMatrix4(g);
        b.copy(s).applyMatrix3(this.normalMatrix).normalize().multiplyScalar(this.size);
        b.add(d[h]);
        h += 1;
        d[h].copy(b);
        h += 1;
      }
    this.geometry.verticesNeedUpdate = !0;
    return this;
  };
}();
THREE.VertexTangentsHelper = function (a, b, c, d) {
  this.object = a;
  this.size = void 0 !== b ? b : 1;
  b = void 0 !== c ? c : 255;
  d = void 0 !== d ? d : 1;
  c = new THREE.Geometry();
  a = a.geometry.faces;
  for (var e = 0, f = a.length; e < f; e++)
    for (var g = 0, h = a[e].vertexTangents.length; g < h; g++)
      c.vertices.push(new THREE.Vector3()), c.vertices.push(new THREE.Vector3());
  THREE.Line.call(this, c, new THREE.LineBasicMaterial({
    color: b,
    linewidth: d
  }), THREE.LinePieces);
  this.matrixAutoUpdate = !1;
  this.update();
};
THREE.VertexTangentsHelper.prototype = Object.create(THREE.Line.prototype);
THREE.VertexTangentsHelper.prototype.update = function (a) {
  var b = new THREE.Vector3();
  return function (a) {
    a = [
      'a',
      'b',
      'c',
      'd'
    ];
    this.object.updateMatrixWorld(!0);
    for (var d = this.geometry.vertices, e = this.object.geometry.vertices, f = this.object.geometry.faces, g = this.object.matrixWorld, h = 0, k = 0, l = f.length; k < l; k++)
      for (var n = f[k], q = 0, p = n.vertexTangents.length; q < p; q++) {
        var s = n.vertexTangents[q];
        d[h].copy(e[n[a[q]]]).applyMatrix4(g);
        b.copy(s).transformDirection(g).multiplyScalar(this.size);
        b.add(d[h]);
        h += 1;
        d[h].copy(b);
        h += 1;
      }
    this.geometry.verticesNeedUpdate = !0;
    return this;
  };
}();
THREE.WireframeHelper = function (a, b) {
  var c = void 0 !== b ? b : 16777215, d = [
      0,
      0
    ], e = {}, f = function (a, b) {
      return a - b;
    }, g = [
      'a',
      'b',
      'c'
    ], h = new THREE.BufferGeometry();
  if (a.geometry instanceof THREE.Geometry) {
    for (var k = a.geometry.vertices, l = a.geometry.faces, n = 0, q = new Uint32Array(6 * l.length), p = 0, s = l.length; p < s; p++)
      for (var t = l[p], r = 0; 3 > r; r++) {
        d[0] = t[g[r]];
        d[1] = t[g[(r + 1) % 3]];
        d.sort(f);
        var v = d.toString();
        void 0 === e[v] && (q[2 * n] = d[0], q[2 * n + 1] = d[1], e[v] = !0, n++);
      }
    h.addAttribute('position', new THREE.Float32Attribute(2 * n, 3));
    d = h.attributes.position.array;
    p = 0;
    for (s = n; p < s; p++)
      for (r = 0; 2 > r; r++)
        n = k[q[2 * p + r]], g = 6 * p + 3 * r, d[g + 0] = n.x, d[g + 1] = n.y, d[g + 2] = n.z;
  } else if (a.geometry instanceof THREE.BufferGeometry && void 0 !== a.geometry.attributes.index) {
    for (var k = a.geometry.attributes.position.array, s = a.geometry.attributes.index.array, l = a.geometry.offsets, n = 0, q = new Uint32Array(2 * s.length), t = 0, w = l.length; t < w; ++t)
      for (var r = l[t].start, v = l[t].count, g = l[t].index, p = r, u = r + v; p < u; p += 3)
        for (r = 0; 3 > r; r++)
          d[0] = g + s[p + r], d[1] = g + s[p + (r + 1) % 3], d.sort(f), v = d.toString(), void 0 === e[v] && (q[2 * n] = d[0], q[2 * n + 1] = d[1], e[v] = !0, n++);
    h.addAttribute('position', new THREE.Float32Attribute(2 * n, 3));
    d = h.attributes.position.array;
    p = 0;
    for (s = n; p < s; p++)
      for (r = 0; 2 > r; r++)
        g = 6 * p + 3 * r, n = 3 * q[2 * p + r], d[g + 0] = k[n], d[g + 1] = k[n + 1], d[g + 2] = k[n + 2];
  } else if (a.geometry instanceof THREE.BufferGeometry)
    for (k = a.geometry.attributes.position.array, n = k.length / 3, q = n / 3, h.addAttribute('position', new THREE.Float32Attribute(2 * n, 3)), d = h.attributes.position.array, p = 0, s = q; p < s; p++)
      for (r = 0; 3 > r; r++)
        g = 18 * p + 6 * r, q = 9 * p + 3 * r, d[g + 0] = k[q], d[g + 1] = k[q + 1], d[g + 2] = k[q + 2], n = 9 * p + (r + 1) % 3 * 3, d[g + 3] = k[n], d[g + 4] = k[n + 1], d[g + 5] = k[n + 2];
  THREE.Line.call(this, h, new THREE.LineBasicMaterial({ color: c }), THREE.LinePieces);
  this.matrixAutoUpdate = !1;
  this.matrixWorld = a.matrixWorld;
};
THREE.WireframeHelper.prototype = Object.create(THREE.Line.prototype);
THREE.ImmediateRenderObject = function () {
  THREE.Object3D.call(this);
  this.render = function (a) {
  };
};
THREE.ImmediateRenderObject.prototype = Object.create(THREE.Object3D.prototype);
THREE.LensFlare = function (a, b, c, d, e) {
  THREE.Object3D.call(this);
  this.lensFlares = [];
  this.positionScreen = new THREE.Vector3();
  this.customUpdateCallback = void 0;
  void 0 !== a && this.add(a, b, c, d, e);
};
THREE.LensFlare.prototype = Object.create(THREE.Object3D.prototype);
THREE.LensFlare.prototype.add = function (a, b, c, d, e, f) {
  void 0 === b && (b = -1);
  void 0 === c && (c = 0);
  void 0 === f && (f = 1);
  void 0 === e && (e = new THREE.Color(16777215));
  void 0 === d && (d = THREE.NormalBlending);
  c = Math.min(c, Math.max(0, c));
  this.lensFlares.push({
    texture: a,
    size: b,
    distance: c,
    x: 0,
    y: 0,
    z: 0,
    scale: 1,
    rotation: 1,
    opacity: f,
    color: e,
    blending: d
  });
};
THREE.LensFlare.prototype.updateLensFlares = function () {
  var a, b = this.lensFlares.length, c, d = 2 * -this.positionScreen.x, e = 2 * -this.positionScreen.y;
  for (a = 0; a < b; a++)
    c = this.lensFlares[a], c.x = this.positionScreen.x + d * c.distance, c.y = this.positionScreen.y + e * c.distance, c.wantedRotation = c.x * Math.PI * 0.25, c.rotation += 0.25 * (c.wantedRotation - c.rotation);
};
THREE.MorphBlendMesh = function (a, b) {
  THREE.Mesh.call(this, a, b);
  this.animationsMap = {};
  this.animationsList = [];
  var c = this.geometry.morphTargets.length;
  this.createAnimation('__default', 0, c - 1, c / 1);
  this.setAnimationWeight('__default', 1);
};
THREE.MorphBlendMesh.prototype = Object.create(THREE.Mesh.prototype);
THREE.MorphBlendMesh.prototype.createAnimation = function (a, b, c, d) {
  b = {
    startFrame: b,
    endFrame: c,
    length: c - b + 1,
    fps: d,
    duration: (c - b) / d,
    lastFrame: 0,
    currentFrame: 0,
    active: !1,
    time: 0,
    direction: 1,
    weight: 1,
    directionBackwards: !1,
    mirroredLoop: !1
  };
  this.animationsMap[a] = b;
  this.animationsList.push(b);
};
THREE.MorphBlendMesh.prototype.autoCreateAnimations = function (a) {
  for (var b = /([a-z]+)(\d+)/, c, d = {}, e = this.geometry, f = 0, g = e.morphTargets.length; f < g; f++) {
    var h = e.morphTargets[f].name.match(b);
    if (h && 1 < h.length) {
      var k = h[1];
      d[k] || (d[k] = {
        start: Infinity,
        end: -Infinity
      });
      h = d[k];
      f < h.start && (h.start = f);
      f > h.end && (h.end = f);
      c || (c = k);
    }
  }
  for (k in d)
    h = d[k], this.createAnimation(k, h.start, h.end, a);
  this.firstAnimation = c;
};
THREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function (a) {
  if (a = this.animationsMap[a])
    a.direction = 1, a.directionBackwards = !1;
};
THREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function (a) {
  if (a = this.animationsMap[a])
    a.direction = -1, a.directionBackwards = !0;
};
THREE.MorphBlendMesh.prototype.setAnimationFPS = function (a, b) {
  var c = this.animationsMap[a];
  c && (c.fps = b, c.duration = (c.end - c.start) / c.fps);
};
THREE.MorphBlendMesh.prototype.setAnimationDuration = function (a, b) {
  var c = this.animationsMap[a];
  c && (c.duration = b, c.fps = (c.end - c.start) / c.duration);
};
THREE.MorphBlendMesh.prototype.setAnimationWeight = function (a, b) {
  var c = this.animationsMap[a];
  c && (c.weight = b);
};
THREE.MorphBlendMesh.prototype.setAnimationTime = function (a, b) {
  var c = this.animationsMap[a];
  c && (c.time = b);
};
THREE.MorphBlendMesh.prototype.getAnimationTime = function (a) {
  var b = 0;
  if (a = this.animationsMap[a])
    b = a.time;
  return b;
};
THREE.MorphBlendMesh.prototype.getAnimationDuration = function (a) {
  var b = -1;
  if (a = this.animationsMap[a])
    b = a.duration;
  return b;
};
THREE.MorphBlendMesh.prototype.playAnimation = function (a) {
  var b = this.animationsMap[a];
  b ? (b.time = 0, b.active = !0) : console.warn('animation[' + a + '] undefined');
};
THREE.MorphBlendMesh.prototype.stopAnimation = function (a) {
  if (a = this.animationsMap[a])
    a.active = !1;
};
THREE.MorphBlendMesh.prototype.update = function (a) {
  for (var b = 0, c = this.animationsList.length; b < c; b++) {
    var d = this.animationsList[b];
    if (d.active) {
      var e = d.duration / d.length;
      d.time += d.direction * a;
      if (d.mirroredLoop) {
        if (d.time > d.duration || 0 > d.time)
          d.direction *= -1, d.time > d.duration && (d.time = d.duration, d.directionBackwards = !0), 0 > d.time && (d.time = 0, d.directionBackwards = !1);
      } else
        d.time %= d.duration, 0 > d.time && (d.time += d.duration);
      var f = d.startFrame + THREE.Math.clamp(Math.floor(d.time / e), 0, d.length - 1), g = d.weight;
      f !== d.currentFrame && (this.morphTargetInfluences[d.lastFrame] = 0, this.morphTargetInfluences[d.currentFrame] = 1 * g, this.morphTargetInfluences[f] = 0, d.lastFrame = d.currentFrame, d.currentFrame = f);
      e = d.time % e / e;
      d.directionBackwards && (e = 1 - e);
      this.morphTargetInfluences[d.currentFrame] = e * g;
      this.morphTargetInfluences[d.lastFrame] = (1 - e) * g;
    }
  }
};
THREE.LensFlarePlugin = function () {
  function a(a, c) {
    var d = b.createProgram(), e = b.createShader(b.FRAGMENT_SHADER), f = b.createShader(b.VERTEX_SHADER), g = 'precision ' + c + ' float;\n';
    b.shaderSource(e, g + a.fragmentShader);
    b.shaderSource(f, g + a.vertexShader);
    b.compileShader(e);
    b.compileShader(f);
    b.attachShader(d, e);
    b.attachShader(d, f);
    b.linkProgram(d);
    return d;
  }
  var b, c, d, e, f, g, h, k, l, n, q, p, s;
  this.init = function (t) {
    b = t.context;
    c = t;
    d = t.getPrecision();
    e = new Float32Array(16);
    f = new Uint16Array(6);
    t = 0;
    e[t++] = -1;
    e[t++] = -1;
    e[t++] = 0;
    e[t++] = 0;
    e[t++] = 1;
    e[t++] = -1;
    e[t++] = 1;
    e[t++] = 0;
    e[t++] = 1;
    e[t++] = 1;
    e[t++] = 1;
    e[t++] = 1;
    e[t++] = -1;
    e[t++] = 1;
    e[t++] = 0;
    e[t++] = 1;
    t = 0;
    f[t++] = 0;
    f[t++] = 1;
    f[t++] = 2;
    f[t++] = 0;
    f[t++] = 2;
    f[t++] = 3;
    g = b.createBuffer();
    h = b.createBuffer();
    b.bindBuffer(b.ARRAY_BUFFER, g);
    b.bufferData(b.ARRAY_BUFFER, e, b.STATIC_DRAW);
    b.bindBuffer(b.ELEMENT_ARRAY_BUFFER, h);
    b.bufferData(b.ELEMENT_ARRAY_BUFFER, f, b.STATIC_DRAW);
    k = b.createTexture();
    l = b.createTexture();
    b.bindTexture(b.TEXTURE_2D, k);
    b.texImage2D(b.TEXTURE_2D, 0, b.RGB, 16, 16, 0, b.RGB, b.UNSIGNED_BYTE, null);
    b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_S, b.CLAMP_TO_EDGE);
    b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_T, b.CLAMP_TO_EDGE);
    b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MAG_FILTER, b.NEAREST);
    b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MIN_FILTER, b.NEAREST);
    b.bindTexture(b.TEXTURE_2D, l);
    b.texImage2D(b.TEXTURE_2D, 0, b.RGBA, 16, 16, 0, b.RGBA, b.UNSIGNED_BYTE, null);
    b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_S, b.CLAMP_TO_EDGE);
    b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_T, b.CLAMP_TO_EDGE);
    b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MAG_FILTER, b.NEAREST);
    b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MIN_FILTER, b.NEAREST);
    0 >= b.getParameter(b.MAX_VERTEX_TEXTURE_IMAGE_UNITS) ? (n = !1, q = a(THREE.ShaderFlares.lensFlare, d)) : (n = !0, q = a(THREE.ShaderFlares.lensFlareVertexTexture, d));
    p = {};
    s = {};
    p.vertex = b.getAttribLocation(q, 'position');
    p.uv = b.getAttribLocation(q, 'uv');
    s.renderType = b.getUniformLocation(q, 'renderType');
    s.map = b.getUniformLocation(q, 'map');
    s.occlusionMap = b.getUniformLocation(q, 'occlusionMap');
    s.opacity = b.getUniformLocation(q, 'opacity');
    s.color = b.getUniformLocation(q, 'color');
    s.scale = b.getUniformLocation(q, 'scale');
    s.rotation = b.getUniformLocation(q, 'rotation');
    s.screenPosition = b.getUniformLocation(q, 'screenPosition');
  };
  this.render = function (a, d, e, f) {
    a = a.__webglFlares;
    var u = a.length;
    if (u) {
      var y = new THREE.Vector3(), L = f / e, x = 0.5 * e, N = 0.5 * f, J = 16 / f, B = new THREE.Vector2(J * L, J), K = new THREE.Vector3(1, 1, 0), A = new THREE.Vector2(1, 1), G = s, J = p;
      b.useProgram(q);
      b.enableVertexAttribArray(p.vertex);
      b.enableVertexAttribArray(p.uv);
      b.uniform1i(G.occlusionMap, 0);
      b.uniform1i(G.map, 1);
      b.bindBuffer(b.ARRAY_BUFFER, g);
      b.vertexAttribPointer(J.vertex, 2, b.FLOAT, !1, 16, 0);
      b.vertexAttribPointer(J.uv, 2, b.FLOAT, !1, 16, 8);
      b.bindBuffer(b.ELEMENT_ARRAY_BUFFER, h);
      b.disable(b.CULL_FACE);
      b.depthMask(!1);
      var D, C, F, z, H;
      for (D = 0; D < u; D++)
        if (J = 16 / f, B.set(J * L, J), z = a[D], y.set(z.matrixWorld.elements[12], z.matrixWorld.elements[13], z.matrixWorld.elements[14]), y.applyMatrix4(d.matrixWorldInverse), y.applyProjection(d.projectionMatrix), K.copy(y), A.x = K.x * x + x, A.y = K.y * N + N, n || 0 < A.x && A.x < e && 0 < A.y && A.y < f)
          for (b.activeTexture(b.TEXTURE1), b.bindTexture(b.TEXTURE_2D, k), b.copyTexImage2D(b.TEXTURE_2D, 0, b.RGB, A.x - 8, A.y - 8, 16, 16, 0), b.uniform1i(G.renderType, 0), b.uniform2f(G.scale, B.x, B.y), b.uniform3f(G.screenPosition, K.x, K.y, K.z), b.disable(b.BLEND), b.enable(b.DEPTH_TEST), b.drawElements(b.TRIANGLES, 6, b.UNSIGNED_SHORT, 0), b.activeTexture(b.TEXTURE0), b.bindTexture(b.TEXTURE_2D, l), b.copyTexImage2D(b.TEXTURE_2D, 0, b.RGBA, A.x - 8, A.y - 8, 16, 16, 0), b.uniform1i(G.renderType, 1), b.disable(b.DEPTH_TEST), b.activeTexture(b.TEXTURE1), b.bindTexture(b.TEXTURE_2D, k), b.drawElements(b.TRIANGLES, 6, b.UNSIGNED_SHORT, 0), z.positionScreen.copy(K), z.customUpdateCallback ? z.customUpdateCallback(z) : z.updateLensFlares(), b.uniform1i(G.renderType, 2), b.enable(b.BLEND), C = 0, F = z.lensFlares.length; C < F; C++)
            H = z.lensFlares[C], 0.001 < H.opacity && 0.001 < H.scale && (K.x = H.x, K.y = H.y, K.z = H.z, J = H.size * H.scale / f, B.x = J * L, B.y = J, b.uniform3f(G.screenPosition, K.x, K.y, K.z), b.uniform2f(G.scale, B.x, B.y), b.uniform1f(G.rotation, H.rotation), b.uniform1f(G.opacity, H.opacity), b.uniform3f(G.color, H.color.r, H.color.g, H.color.b), c.setBlending(H.blending, H.blendEquation, H.blendSrc, H.blendDst), c.setTexture(H.texture, 1), b.drawElements(b.TRIANGLES, 6, b.UNSIGNED_SHORT, 0));
      b.enable(b.CULL_FACE);
      b.enable(b.DEPTH_TEST);
      b.depthMask(!0);
    }
  };
};
THREE.ShadowMapPlugin = function () {
  var a, b, c, d, e, f, g = new THREE.Frustum(), h = new THREE.Matrix4(), k = new THREE.Vector3(), l = new THREE.Vector3(), n = new THREE.Vector3();
  this.init = function (g) {
    a = g.context;
    b = g;
    g = THREE.ShaderLib.depthRGBA;
    var h = THREE.UniformsUtils.clone(g.uniforms);
    c = new THREE.ShaderMaterial({
      fragmentShader: g.fragmentShader,
      vertexShader: g.vertexShader,
      uniforms: h
    });
    d = new THREE.ShaderMaterial({
      fragmentShader: g.fragmentShader,
      vertexShader: g.vertexShader,
      uniforms: h,
      morphTargets: !0
    });
    e = new THREE.ShaderMaterial({
      fragmentShader: g.fragmentShader,
      vertexShader: g.vertexShader,
      uniforms: h,
      skinning: !0
    });
    f = new THREE.ShaderMaterial({
      fragmentShader: g.fragmentShader,
      vertexShader: g.vertexShader,
      uniforms: h,
      morphTargets: !0,
      skinning: !0
    });
    c._shadowPass = !0;
    d._shadowPass = !0;
    e._shadowPass = !0;
    f._shadowPass = !0;
  };
  this.render = function (a, c) {
    b.shadowMapEnabled && b.shadowMapAutoUpdate && this.update(a, c);
  };
  this.update = function (q, p) {
    var s, t, r, v, w, u, y, L, x, N = [];
    v = 0;
    a.clearColor(1, 1, 1, 1);
    a.disable(a.BLEND);
    a.enable(a.CULL_FACE);
    a.frontFace(a.CCW);
    b.shadowMapCullFace === THREE.CullFaceFront ? a.cullFace(a.FRONT) : a.cullFace(a.BACK);
    b.setDepthTest(!0);
    s = 0;
    for (t = q.__lights.length; s < t; s++)
      if (r = q.__lights[s], r.castShadow)
        if (r instanceof THREE.DirectionalLight && r.shadowCascade)
          for (w = 0; w < r.shadowCascadeCount; w++) {
            var J;
            if (r.shadowCascadeArray[w])
              J = r.shadowCascadeArray[w];
            else {
              x = r;
              y = w;
              J = new THREE.DirectionalLight();
              J.isVirtual = !0;
              J.onlyShadow = !0;
              J.castShadow = !0;
              J.shadowCameraNear = x.shadowCameraNear;
              J.shadowCameraFar = x.shadowCameraFar;
              J.shadowCameraLeft = x.shadowCameraLeft;
              J.shadowCameraRight = x.shadowCameraRight;
              J.shadowCameraBottom = x.shadowCameraBottom;
              J.shadowCameraTop = x.shadowCameraTop;
              J.shadowCameraVisible = x.shadowCameraVisible;
              J.shadowDarkness = x.shadowDarkness;
              J.shadowBias = x.shadowCascadeBias[y];
              J.shadowMapWidth = x.shadowCascadeWidth[y];
              J.shadowMapHeight = x.shadowCascadeHeight[y];
              J.pointsWorld = [];
              J.pointsFrustum = [];
              var B = J.pointsWorld;
              u = J.pointsFrustum;
              for (L = 0; 8 > L; L++)
                B[L] = new THREE.Vector3(), u[L] = new THREE.Vector3();
              B = x.shadowCascadeNearZ[y];
              x = x.shadowCascadeFarZ[y];
              u[0].set(-1, -1, B);
              u[1].set(1, -1, B);
              u[2].set(-1, 1, B);
              u[3].set(1, 1, B);
              u[4].set(-1, -1, x);
              u[5].set(1, -1, x);
              u[6].set(-1, 1, x);
              u[7].set(1, 1, x);
              J.originalCamera = p;
              u = new THREE.Gyroscope();
              u.position.copy(r.shadowCascadeOffset);
              u.add(J);
              u.add(J.target);
              p.add(u);
              r.shadowCascadeArray[w] = J;
              console.log('Created virtualLight', J);
            }
            y = r;
            B = w;
            x = y.shadowCascadeArray[B];
            x.position.copy(y.position);
            x.target.position.copy(y.target.position);
            x.lookAt(x.target);
            x.shadowCameraVisible = y.shadowCameraVisible;
            x.shadowDarkness = y.shadowDarkness;
            x.shadowBias = y.shadowCascadeBias[B];
            u = y.shadowCascadeNearZ[B];
            y = y.shadowCascadeFarZ[B];
            x = x.pointsFrustum;
            x[0].z = u;
            x[1].z = u;
            x[2].z = u;
            x[3].z = u;
            x[4].z = y;
            x[5].z = y;
            x[6].z = y;
            x[7].z = y;
            N[v] = J;
            v++;
          }
        else
          N[v] = r, v++;
    s = 0;
    for (t = N.length; s < t; s++) {
      r = N[s];
      r.shadowMap || (w = THREE.LinearFilter, b.shadowMapType === THREE.PCFSoftShadowMap && (w = THREE.NearestFilter), r.shadowMap = new THREE.WebGLRenderTarget(r.shadowMapWidth, r.shadowMapHeight, {
        minFilter: w,
        magFilter: w,
        format: THREE.RGBAFormat
      }), r.shadowMapSize = new THREE.Vector2(r.shadowMapWidth, r.shadowMapHeight), r.shadowMatrix = new THREE.Matrix4());
      if (!r.shadowCamera) {
        if (r instanceof THREE.SpotLight)
          r.shadowCamera = new THREE.PerspectiveCamera(r.shadowCameraFov, r.shadowMapWidth / r.shadowMapHeight, r.shadowCameraNear, r.shadowCameraFar);
        else if (r instanceof THREE.DirectionalLight)
          r.shadowCamera = new THREE.OrthographicCamera(r.shadowCameraLeft, r.shadowCameraRight, r.shadowCameraTop, r.shadowCameraBottom, r.shadowCameraNear, r.shadowCameraFar);
        else {
          console.error('Unsupported light type for shadow');
          continue;
        }
        q.add(r.shadowCamera);
        !0 === q.autoUpdate && q.updateMatrixWorld();
      }
      r.shadowCameraVisible && !r.cameraHelper && (r.cameraHelper = new THREE.CameraHelper(r.shadowCamera), r.shadowCamera.add(r.cameraHelper));
      if (r.isVirtual && J.originalCamera == p) {
        w = p;
        v = r.shadowCamera;
        u = r.pointsFrustum;
        x = r.pointsWorld;
        k.set(Infinity, Infinity, Infinity);
        l.set(-Infinity, -Infinity, -Infinity);
        for (y = 0; 8 > y; y++)
          B = x[y], B.copy(u[y]), THREE.ShadowMapPlugin.__projector.unprojectVector(B, w), B.applyMatrix4(v.matrixWorldInverse), B.x < k.x && (k.x = B.x), B.x > l.x && (l.x = B.x), B.y < k.y && (k.y = B.y), B.y > l.y && (l.y = B.y), B.z < k.z && (k.z = B.z), B.z > l.z && (l.z = B.z);
        v.left = k.x;
        v.right = l.x;
        v.top = l.y;
        v.bottom = k.y;
        v.updateProjectionMatrix();
      }
      v = r.shadowMap;
      u = r.shadowMatrix;
      w = r.shadowCamera;
      w.position.setFromMatrixPosition(r.matrixWorld);
      n.setFromMatrixPosition(r.target.matrixWorld);
      w.lookAt(n);
      w.updateMatrixWorld();
      w.matrixWorldInverse.getInverse(w.matrixWorld);
      r.cameraHelper && (r.cameraHelper.visible = r.shadowCameraVisible);
      r.shadowCameraVisible && r.cameraHelper.update();
      u.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
      u.multiply(w.projectionMatrix);
      u.multiply(w.matrixWorldInverse);
      h.multiplyMatrices(w.projectionMatrix, w.matrixWorldInverse);
      g.setFromMatrix(h);
      b.setRenderTarget(v);
      b.clear();
      x = q.__webglObjects;
      r = 0;
      for (v = x.length; r < v; r++)
        y = x[r], u = y.object, y.render = !1, !u.visible || !u.castShadow || (u instanceof THREE.Mesh || u instanceof THREE.ParticleSystem) && u.frustumCulled && !g.intersectsObject(u) || (u._modelViewMatrix.multiplyMatrices(w.matrixWorldInverse, u.matrixWorld), y.render = !0);
      var K;
      r = 0;
      for (v = x.length; r < v; r++)
        y = x[r], y.render && (u = y.object, y = y.buffer, B = u.material instanceof THREE.MeshFaceMaterial ? u.material.materials[0] : u.material, L = void 0 !== u.geometry.morphTargets && 0 < u.geometry.morphTargets.length && B.morphTargets, K = u instanceof THREE.SkinnedMesh && B.skinning, L = u.customDepthMaterial ? u.customDepthMaterial : K ? L ? f : e : L ? d : c, b.setMaterialFaces(B), y instanceof THREE.BufferGeometry ? b.renderBufferDirect(w, q.__lights, null, L, y, u) : b.renderBuffer(w, q.__lights, null, L, y, u));
      x = q.__webglObjectsImmediate;
      r = 0;
      for (v = x.length; r < v; r++)
        y = x[r], u = y.object, u.visible && u.castShadow && (u._modelViewMatrix.multiplyMatrices(w.matrixWorldInverse, u.matrixWorld), b.renderImmediateObject(w, q.__lights, null, c, u));
    }
    s = b.getClearColor();
    t = b.getClearAlpha();
    a.clearColor(s.r, s.g, s.b, t);
    a.enable(a.BLEND);
    b.shadowMapCullFace === THREE.CullFaceFront && a.cullFace(a.BACK);
  };
};
THREE.ShadowMapPlugin.__projector = new THREE.Projector();
THREE.SpritePlugin = function () {
  var a, b, c, d, e, f, g, h, k, l, n, q, p, s, t, r, v;
  function w(a, b) {
    return a.z !== b.z ? b.z - a.z : b.id - a.id;
  }
  var u, y, L, x, N, J, B, K;
  this.init = function (w) {
    u = w.context;
    y = w;
    x = new Float32Array([
      -0.5,
      -0.5,
      0,
      0,
      0.5,
      -0.5,
      1,
      0,
      0.5,
      0.5,
      1,
      1,
      -0.5,
      0.5,
      0,
      1
    ]);
    N = new Uint16Array([
      0,
      1,
      2,
      0,
      2,
      3
    ]);
    J = u.createBuffer();
    B = u.createBuffer();
    u.bindBuffer(u.ARRAY_BUFFER, J);
    u.bufferData(u.ARRAY_BUFFER, x, u.STATIC_DRAW);
    u.bindBuffer(u.ELEMENT_ARRAY_BUFFER, B);
    u.bufferData(u.ELEMENT_ARRAY_BUFFER, N, u.STATIC_DRAW);
    w = u.createProgram();
    var G = u.createShader(u.VERTEX_SHADER), D = u.createShader(u.FRAGMENT_SHADER);
    u.shaderSource(G, [
      'precision ' + y.getPrecision() + ' float;',
      'uniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform float rotation;\nuniform vec2 scale;\nuniform vec2 uvOffset;\nuniform vec2 uvScale;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvoid main() {\nvUV = uvOffset + uv * uvScale;\nvec2 alignedPosition = position * scale;\nvec2 rotatedPosition;\nrotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\nrotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\nvec4 finalPosition;\nfinalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\nfinalPosition.xy += rotatedPosition;\nfinalPosition = projectionMatrix * finalPosition;\ngl_Position = finalPosition;\n}'
    ].join('\n'));
    u.shaderSource(D, [
      'precision ' + y.getPrecision() + ' float;',
      'uniform vec3 color;\nuniform sampler2D map;\nuniform float opacity;\nuniform int fogType;\nuniform vec3 fogColor;\nuniform float fogDensity;\nuniform float fogNear;\nuniform float fogFar;\nuniform float alphaTest;\nvarying vec2 vUV;\nvoid main() {\nvec4 texture = texture2D( map, vUV );\nif ( texture.a < alphaTest ) discard;\ngl_FragColor = vec4( color * texture.xyz, texture.a * opacity );\nif ( fogType > 0 ) {\nfloat depth = gl_FragCoord.z / gl_FragCoord.w;\nfloat fogFactor = 0.0;\nif ( fogType == 1 ) {\nfogFactor = smoothstep( fogNear, fogFar, depth );\n} else {\nconst float LOG2 = 1.442695;\nfloat fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\nfogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\n}\ngl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\n}\n}'
    ].join('\n'));
    u.compileShader(G);
    u.compileShader(D);
    u.attachShader(w, G);
    u.attachShader(w, D);
    u.linkProgram(w);
    K = w;
    r = u.getAttribLocation(K, 'position');
    v = u.getAttribLocation(K, 'uv');
    a = u.getUniformLocation(K, 'uvOffset');
    b = u.getUniformLocation(K, 'uvScale');
    c = u.getUniformLocation(K, 'rotation');
    d = u.getUniformLocation(K, 'scale');
    e = u.getUniformLocation(K, 'color');
    f = u.getUniformLocation(K, 'map');
    g = u.getUniformLocation(K, 'opacity');
    h = u.getUniformLocation(K, 'modelViewMatrix');
    k = u.getUniformLocation(K, 'projectionMatrix');
    l = u.getUniformLocation(K, 'fogType');
    n = u.getUniformLocation(K, 'fogDensity');
    q = u.getUniformLocation(K, 'fogNear');
    p = u.getUniformLocation(K, 'fogFar');
    s = u.getUniformLocation(K, 'fogColor');
    t = u.getUniformLocation(K, 'alphaTest');
    w = document.createElement('canvas');
    w.width = 8;
    w.height = 8;
    G = w.getContext('2d');
    G.fillStyle = '#ffffff';
    G.fillRect(0, 0, w.width, w.height);
    L = new THREE.Texture(w);
    L.needsUpdate = !0;
  };
  this.render = function (A, x, D, C) {
    D = A.__webglSprites;
    if (C = D.length) {
      u.useProgram(K);
      u.enableVertexAttribArray(r);
      u.enableVertexAttribArray(v);
      u.disable(u.CULL_FACE);
      u.enable(u.BLEND);
      u.bindBuffer(u.ARRAY_BUFFER, J);
      u.vertexAttribPointer(r, 2, u.FLOAT, !1, 16, 0);
      u.vertexAttribPointer(v, 2, u.FLOAT, !1, 16, 8);
      u.bindBuffer(u.ELEMENT_ARRAY_BUFFER, B);
      u.uniformMatrix4fv(k, !1, x.projectionMatrix.elements);
      u.activeTexture(u.TEXTURE0);
      u.uniform1i(f, 0);
      var F = 0, z = 0, H = A.fog;
      H ? (u.uniform3f(s, H.color.r, H.color.g, H.color.b), H instanceof THREE.Fog ? (u.uniform1f(q, H.near), u.uniform1f(p, H.far), u.uniform1i(l, 1), z = F = 1) : H instanceof THREE.FogExp2 && (u.uniform1f(n, H.density), u.uniform1i(l, 2), z = F = 2)) : (u.uniform1i(l, 0), z = F = 0);
      for (var E, N = [], H = 0; H < C; H++)
        E = D[H], !1 !== E.visible && (E._modelViewMatrix.multiplyMatrices(x.matrixWorldInverse, E.matrixWorld), E.z = -E._modelViewMatrix.elements[14]);
      D.sort(w);
      for (H = 0; H < C; H++)
        E = D[H], !1 !== E.visible && (x = E.material, u.uniform1f(t, x.alphaTest), u.uniformMatrix4fv(h, !1, E._modelViewMatrix.elements), N[0] = E.scale.x, N[1] = E.scale.y, E = A.fog && x.fog ? z : 0, F !== E && (u.uniform1i(l, E), F = E), null !== x.map ? (u.uniform2f(a, x.map.offset.x, x.map.offset.y), u.uniform2f(b, x.map.repeat.x, x.map.repeat.y)) : (u.uniform2f(a, 0, 0), u.uniform2f(b, 1, 1)), u.uniform1f(g, x.opacity), u.uniform3f(e, x.color.r, x.color.g, x.color.b), u.uniform1f(c, x.rotation), u.uniform2fv(d, N), y.setBlending(x.blending, x.blendEquation, x.blendSrc, x.blendDst), y.setDepthTest(x.depthTest), y.setDepthWrite(x.depthWrite), x.map && x.map.image && x.map.image.width ? y.setTexture(x.map, 0) : y.setTexture(L, 0), u.drawElements(u.TRIANGLES, 6, u.UNSIGNED_SHORT, 0));
      u.enable(u.CULL_FACE);
    }
  };
};
THREE.DepthPassPlugin = function () {
  this.enabled = !1;
  this.renderTarget = null;
  var a, b, c, d, e, f, g = new THREE.Frustum(), h = new THREE.Matrix4();
  this.init = function (g) {
    a = g.context;
    b = g;
    g = THREE.ShaderLib.depthRGBA;
    var h = THREE.UniformsUtils.clone(g.uniforms);
    c = new THREE.ShaderMaterial({
      fragmentShader: g.fragmentShader,
      vertexShader: g.vertexShader,
      uniforms: h
    });
    d = new THREE.ShaderMaterial({
      fragmentShader: g.fragmentShader,
      vertexShader: g.vertexShader,
      uniforms: h,
      morphTargets: !0
    });
    e = new THREE.ShaderMaterial({
      fragmentShader: g.fragmentShader,
      vertexShader: g.vertexShader,
      uniforms: h,
      skinning: !0
    });
    f = new THREE.ShaderMaterial({
      fragmentShader: g.fragmentShader,
      vertexShader: g.vertexShader,
      uniforms: h,
      morphTargets: !0,
      skinning: !0
    });
    c._shadowPass = !0;
    d._shadowPass = !0;
    e._shadowPass = !0;
    f._shadowPass = !0;
  };
  this.render = function (a, b) {
    this.enabled && this.update(a, b);
  };
  this.update = function (k, l) {
    var n, q, p, s, t, r;
    a.clearColor(1, 1, 1, 1);
    a.disable(a.BLEND);
    b.setDepthTest(!0);
    !0 === k.autoUpdate && k.updateMatrixWorld();
    l.matrixWorldInverse.getInverse(l.matrixWorld);
    h.multiplyMatrices(l.projectionMatrix, l.matrixWorldInverse);
    g.setFromMatrix(h);
    b.setRenderTarget(this.renderTarget);
    b.clear();
    r = k.__webglObjects;
    n = 0;
    for (q = r.length; n < q; n++)
      p = r[n], t = p.object, p.render = !1, !t.visible || (t instanceof THREE.Mesh || t instanceof THREE.ParticleSystem) && t.frustumCulled && !g.intersectsObject(t) || (t._modelViewMatrix.multiplyMatrices(l.matrixWorldInverse, t.matrixWorld), p.render = !0);
    var v;
    n = 0;
    for (q = r.length; n < q; n++)
      p = r[n], p.render && (t = p.object, p = p.buffer, t instanceof THREE.ParticleSystem && !t.customDepthMaterial || ((v = t.material instanceof THREE.MeshFaceMaterial ? t.material.materials[0] : t.material) && b.setMaterialFaces(t.material), s = void 0 !== t.geometry.morphTargets && 0 < t.geometry.morphTargets.length && v.morphTargets, v = t instanceof THREE.SkinnedMesh && v.skinning, s = t.customDepthMaterial ? t.customDepthMaterial : v ? s ? f : e : s ? d : c, p instanceof THREE.BufferGeometry ? b.renderBufferDirect(l, k.__lights, null, s, p, t) : b.renderBuffer(l, k.__lights, null, s, p, t)));
    r = k.__webglObjectsImmediate;
    n = 0;
    for (q = r.length; n < q; n++)
      p = r[n], t = p.object, t.visible && (t._modelViewMatrix.multiplyMatrices(l.matrixWorldInverse, t.matrixWorld), b.renderImmediateObject(l, k.__lights, null, c, t));
    n = b.getClearColor();
    q = b.getClearAlpha();
    a.clearColor(n.r, n.g, n.b, q);
    a.enable(a.BLEND);
  };
};
THREE.ShaderFlares = {
  lensFlareVertexTexture: {
    vertexShader: 'uniform lowp int renderType;\nuniform vec3 screenPosition;\nuniform vec2 scale;\nuniform float rotation;\nuniform sampler2D occlusionMap;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvarying float vVisibility;\nvoid main() {\nvUV = uv;\nvec2 pos = position;\nif( renderType == 2 ) {\nvec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\nvVisibility =        visibility.r / 9.0;\nvVisibility *= 1.0 - visibility.g / 9.0;\nvVisibility *=       visibility.b / 9.0;\nvVisibility *= 1.0 - visibility.a / 9.0;\npos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\npos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\n}\ngl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\n}',
    fragmentShader: 'uniform lowp int renderType;\nuniform sampler2D map;\nuniform float opacity;\nuniform vec3 color;\nvarying vec2 vUV;\nvarying float vVisibility;\nvoid main() {\nif( renderType == 0 ) {\ngl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );\n} else if( renderType == 1 ) {\ngl_FragColor = texture2D( map, vUV );\n} else {\nvec4 texture = texture2D( map, vUV );\ntexture.a *= opacity * vVisibility;\ngl_FragColor = texture;\ngl_FragColor.rgb *= color;\n}\n}'
  },
  lensFlare: {
    vertexShader: 'uniform lowp int renderType;\nuniform vec3 screenPosition;\nuniform vec2 scale;\nuniform float rotation;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvoid main() {\nvUV = uv;\nvec2 pos = position;\nif( renderType == 2 ) {\npos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\npos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\n}\ngl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\n}',
    fragmentShader: 'precision mediump float;\nuniform lowp int renderType;\nuniform sampler2D map;\nuniform sampler2D occlusionMap;\nuniform float opacity;\nuniform vec3 color;\nvarying vec2 vUV;\nvoid main() {\nif( renderType == 0 ) {\ngl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );\n} else if( renderType == 1 ) {\ngl_FragColor = texture2D( map, vUV );\n} else {\nfloat visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;\nvisibility = ( 1.0 - visibility / 4.0 );\nvec4 texture = texture2D( map, vUV );\ntexture.a *= opacity * visibility;\ngl_FragColor = texture;\ngl_FragColor.rgb *= color;\n}\n}'
  }
};
'use strict';
void 0 === Date.now && (Date.now = function () {
  return new Date().valueOf();
});
var TWEEN = TWEEN || function () {
    var a = [];
    return {
      REVISION: '13',
      getAll: function () {
        return a;
      },
      removeAll: function () {
        a = [];
      },
      add: function (c) {
        a.push(c);
      },
      remove: function (c) {
        c = a.indexOf(c);
        -1 !== c && a.splice(c, 1);
      },
      update: function (c) {
        if (0 === a.length)
          return !1;
        for (var b = 0, c = void 0 !== c ? c : 'undefined' !== typeof window && void 0 !== window.performance && void 0 !== window.performance.now ? window.performance.now() : Date.now(); b < a.length;)
          a[b].update(c) ? b++ : a.splice(b, 1);
        return !0;
      }
    };
  }();
TWEEN.Tween = function (a) {
  var c = {}, b = {}, d = {}, e = 1000, g = 0, h = !1, j = !1, q = 0, m = null, w = TWEEN.Easing.Linear.None, x = TWEEN.Interpolation.Linear, n = [], r = null, s = !1, t = null, u = null, k = null, v;
  for (v in a)
    c[v] = parseFloat(a[v], 10);
  this.to = function (a, c) {
    void 0 !== c && (e = c);
    b = a;
    return this;
  };
  this.start = function (e) {
    TWEEN.add(this);
    j = !0;
    s = !1;
    m = void 0 !== e ? e : 'undefined' !== typeof window && void 0 !== window.performance && void 0 !== window.performance.now ? window.performance.now() : Date.now();
    m += q;
    for (var f in b) {
      if (b[f] instanceof Array) {
        if (0 === b[f].length)
          continue;
        b[f] = [a[f]].concat(b[f]);
      }
      c[f] = a[f];
      !1 === c[f] instanceof Array && (c[f] *= 1);
      d[f] = c[f] || 0;
    }
    return this;
  };
  this.stop = function () {
    if (!j)
      return this;
    TWEEN.remove(this);
    j = !1;
    null !== k && k.call(a);
    this.stopChainedTweens();
    return this;
  };
  this.stopChainedTweens = function () {
    for (var a = 0, b = n.length; a < b; a++)
      n[a].stop();
  };
  this.delay = function (a) {
    q = a;
    return this;
  };
  this.repeat = function (a) {
    g = a;
    return this;
  };
  this.yoyo = function (a) {
    h = a;
    return this;
  };
  this.easing = function (a) {
    w = a;
    return this;
  };
  this.interpolation = function (a) {
    x = a;
    return this;
  };
  this.chain = function () {
    n = arguments;
    return this;
  };
  this.onStart = function (a) {
    r = a;
    return this;
  };
  this.onUpdate = function (a) {
    t = a;
    return this;
  };
  this.onComplete = function (a) {
    u = a;
    return this;
  };
  this.onStop = function (a) {
    k = a;
    return this;
  };
  this.update = function (p) {
    var f;
    if (p < m)
      return !0;
    !1 === s && (null !== r && r.call(a), s = !0);
    var i = (p - m) / e, i = 1 < i ? 1 : i, j = w(i);
    for (f in b) {
      var k = c[f] || 0, l = b[f];
      l instanceof Array ? a[f] = x(l, j) : ('string' === typeof l && (l = k + parseFloat(l, 10)), 'number' === typeof l && (a[f] = k + (l - k) * j));
    }
    null !== t && t.call(a, j);
    if (1 == i)
      if (0 < g) {
        isFinite(g) && g--;
        for (f in d)
          'string' === typeof b[f] && (d[f] += parseFloat(b[f], 10)), h && (i = d[f], d[f] = b[f], b[f] = i), c[f] = d[f];
        m = p + q;
      } else {
        null !== u && u.call(a);
        f = 0;
        for (i = n.length; f < i; f++)
          n[f].start(p);
        return !1;
      }
    return !0;
  };
};
TWEEN.Easing = {
  Linear: {
    None: function (a) {
      return a;
    }
  },
  Quadratic: {
    In: function (a) {
      return a * a;
    },
    Out: function (a) {
      return a * (2 - a);
    },
    InOut: function (a) {
      return 1 > (a *= 2) ? 0.5 * a * a : -0.5 * (--a * (a - 2) - 1);
    }
  },
  Cubic: {
    In: function (a) {
      return a * a * a;
    },
    Out: function (a) {
      return --a * a * a + 1;
    },
    InOut: function (a) {
      return 1 > (a *= 2) ? 0.5 * a * a * a : 0.5 * ((a -= 2) * a * a + 2);
    }
  },
  Quartic: {
    In: function (a) {
      return a * a * a * a;
    },
    Out: function (a) {
      return 1 - --a * a * a * a;
    },
    InOut: function (a) {
      return 1 > (a *= 2) ? 0.5 * a * a * a * a : -0.5 * ((a -= 2) * a * a * a - 2);
    }
  },
  Quintic: {
    In: function (a) {
      return a * a * a * a * a;
    },
    Out: function (a) {
      return --a * a * a * a * a + 1;
    },
    InOut: function (a) {
      return 1 > (a *= 2) ? 0.5 * a * a * a * a * a : 0.5 * ((a -= 2) * a * a * a * a + 2);
    }
  },
  Sinusoidal: {
    In: function (a) {
      return 1 - Math.cos(a * Math.PI / 2);
    },
    Out: function (a) {
      return Math.sin(a * Math.PI / 2);
    },
    InOut: function (a) {
      return 0.5 * (1 - Math.cos(Math.PI * a));
    }
  },
  Exponential: {
    In: function (a) {
      return 0 === a ? 0 : Math.pow(1024, a - 1);
    },
    Out: function (a) {
      return 1 === a ? 1 : 1 - Math.pow(2, -10 * a);
    },
    InOut: function (a) {
      return 0 === a ? 0 : 1 === a ? 1 : 1 > (a *= 2) ? 0.5 * Math.pow(1024, a - 1) : 0.5 * (-Math.pow(2, -10 * (a - 1)) + 2);
    }
  },
  Circular: {
    In: function (a) {
      return 1 - Math.sqrt(1 - a * a);
    },
    Out: function (a) {
      return Math.sqrt(1 - --a * a);
    },
    InOut: function (a) {
      return 1 > (a *= 2) ? -0.5 * (Math.sqrt(1 - a * a) - 1) : 0.5 * (Math.sqrt(1 - (a -= 2) * a) + 1);
    }
  },
  Elastic: {
    In: function (a) {
      var c, b = 0.1;
      if (0 === a)
        return 0;
      if (1 === a)
        return 1;
      !b || 1 > b ? (b = 1, c = 0.1) : c = 0.4 * Math.asin(1 / b) / (2 * Math.PI);
      return -(b * Math.pow(2, 10 * (a -= 1)) * Math.sin((a - c) * 2 * Math.PI / 0.4));
    },
    Out: function (a) {
      var c, b = 0.1;
      if (0 === a)
        return 0;
      if (1 === a)
        return 1;
      !b || 1 > b ? (b = 1, c = 0.1) : c = 0.4 * Math.asin(1 / b) / (2 * Math.PI);
      return b * Math.pow(2, -10 * a) * Math.sin((a - c) * 2 * Math.PI / 0.4) + 1;
    },
    InOut: function (a) {
      var c, b = 0.1;
      if (0 === a)
        return 0;
      if (1 === a)
        return 1;
      !b || 1 > b ? (b = 1, c = 0.1) : c = 0.4 * Math.asin(1 / b) / (2 * Math.PI);
      return 1 > (a *= 2) ? -0.5 * b * Math.pow(2, 10 * (a -= 1)) * Math.sin((a - c) * 2 * Math.PI / 0.4) : 0.5 * b * Math.pow(2, -10 * (a -= 1)) * Math.sin((a - c) * 2 * Math.PI / 0.4) + 1;
    }
  },
  Back: {
    In: function (a) {
      return a * a * (2.70158 * a - 1.70158);
    },
    Out: function (a) {
      return --a * a * (2.70158 * a + 1.70158) + 1;
    },
    InOut: function (a) {
      return 1 > (a *= 2) ? 0.5 * a * a * (3.5949095 * a - 2.5949095) : 0.5 * ((a -= 2) * a * (3.5949095 * a + 2.5949095) + 2);
    }
  },
  Bounce: {
    In: function (a) {
      return 1 - TWEEN.Easing.Bounce.Out(1 - a);
    },
    Out: function (a) {
      return a < 1 / 2.75 ? 7.5625 * a * a : a < 2 / 2.75 ? 7.5625 * (a -= 1.5 / 2.75) * a + 0.75 : a < 2.5 / 2.75 ? 7.5625 * (a -= 2.25 / 2.75) * a + 0.9375 : 7.5625 * (a -= 2.625 / 2.75) * a + 0.984375;
    },
    InOut: function (a) {
      return 0.5 > a ? 0.5 * TWEEN.Easing.Bounce.In(2 * a) : 0.5 * TWEEN.Easing.Bounce.Out(2 * a - 1) + 0.5;
    }
  }
};
TWEEN.Interpolation = {
  Linear: function (a, c) {
    var b = a.length - 1, d = b * c, e = Math.floor(d), g = TWEEN.Interpolation.Utils.Linear;
    return 0 > c ? g(a[0], a[1], d) : 1 < c ? g(a[b], a[b - 1], b - d) : g(a[e], a[e + 1 > b ? b : e + 1], d - e);
  },
  Bezier: function (a, c) {
    var b = 0, d = a.length - 1, e = Math.pow, g = TWEEN.Interpolation.Utils.Bernstein, h;
    for (h = 0; h <= d; h++)
      b += e(1 - c, d - h) * e(c, h) * a[h] * g(d, h);
    return b;
  },
  CatmullRom: function (a, c) {
    var b = a.length - 1, d = b * c, e = Math.floor(d), g = TWEEN.Interpolation.Utils.CatmullRom;
    return a[0] === a[b] ? (0 > c && (e = Math.floor(d = b * (1 + c))), g(a[(e - 1 + b) % b], a[e], a[(e + 1) % b], a[(e + 2) % b], d - e)) : 0 > c ? a[0] - (g(a[0], a[0], a[1], a[1], -d) - a[0]) : 1 < c ? a[b] - (g(a[b], a[b], a[b - 1], a[b - 1], d - b) - a[b]) : g(a[e ? e - 1 : 0], a[e], a[b < e + 1 ? b : e + 1], a[b < e + 2 ? b : e + 2], d - e);
  },
  Utils: {
    Linear: function (a, c, b) {
      return (c - a) * b + a;
    },
    Bernstein: function (a, c) {
      var b = TWEEN.Interpolation.Utils.Factorial;
      return b(a) / b(c) / b(a - c);
    },
    Factorial: function () {
      var a = [1];
      return function (c) {
        var b = 1, d;
        if (a[c])
          return a[c];
        for (d = c; 1 < d; d--)
          b *= d;
        return a[c] = b;
      };
    }(),
    CatmullRom: function (a, c, b, d, e) {
      var a = 0.5 * (b - a), d = 0.5 * (d - c), g = e * e;
      return (2 * c - 2 * b + a + d) * e * g + (-3 * c + 3 * b - 2 * a - d) * g + a * e + c;
    }
  }
};
(function ($window, $document, tagName, url, namespace, a, m) {
  $window['GoogleAnalyticsObject'] = namespace;
  $window[namespace] = $window[namespace] || function () {
    ($window[namespace].q = $window[namespace].q || []).push(arguments);
  }, $window[namespace].l = 1 * new Date();
  a = $document.createElement(tagName), m = $document.getElementsByTagName(tagName)[0];
  a.async = 1;
  a.src = url;
  m.parentNode.insertBefore(a, m);
}(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga'));
var Stats = function () {
  var startTime = Date.now(), prevTime = startTime;
  var ms = 0, msMin = Infinity, msMax = 0;
  var fps = 0, fpsMin = Infinity, fpsMax = 0;
  var frames = 0, mode = 0;
  var container = document.createElement('div');
  container.id = 'stats';
  container.addEventListener('mousedown', function (event) {
    event.preventDefault();
    setMode(++mode % 2);
  }, false);
  container.style.cssText = 'width:80px;opacity:0.9;cursor:pointer';
  var fpsDiv = document.createElement('div');
  fpsDiv.id = 'fps';
  fpsDiv.style.cssText = 'padding:0 0 3px 3px;text-align:left;background-color:#002';
  container.appendChild(fpsDiv);
  var fpsText = document.createElement('div');
  fpsText.id = 'fpsText';
  fpsText.style.cssText = 'color:#0ff;font-family:Helvetica,Arial,sans-serif;font-size:9px;font-weight:bold;line-height:15px';
  fpsText.innerHTML = 'FPS';
  fpsDiv.appendChild(fpsText);
  var fpsGraph = document.createElement('div');
  fpsGraph.id = 'fpsGraph';
  fpsGraph.style.cssText = 'position:relative;width:74px;height:30px;background-color:#0ff';
  fpsDiv.appendChild(fpsGraph);
  while (fpsGraph.children.length < 74) {
    var bar = document.createElement('span');
    bar.style.cssText = 'width:1px;height:30px;float:left;background-color:#113';
    fpsGraph.appendChild(bar);
  }
  var msDiv = document.createElement('div');
  msDiv.id = 'ms';
  msDiv.style.cssText = 'padding:0 0 3px 3px;text-align:left;background-color:#020;display:none';
  container.appendChild(msDiv);
  var msText = document.createElement('div');
  msText.id = 'msText';
  msText.style.cssText = 'color:#0f0;font-family:Helvetica,Arial,sans-serif;font-size:9px;font-weight:bold;line-height:15px';
  msText.innerHTML = 'MS';
  msDiv.appendChild(msText);
  var msGraph = document.createElement('div');
  msGraph.id = 'msGraph';
  msGraph.style.cssText = 'position:relative;width:74px;height:30px;background-color:#0f0';
  msDiv.appendChild(msGraph);
  while (msGraph.children.length < 74) {
    var bar = document.createElement('span');
    bar.style.cssText = 'width:1px;height:30px;float:left;background-color:#131';
    msGraph.appendChild(bar);
  }
  var setMode = function (value) {
    mode = value;
    switch (mode) {
    case 0:
      fpsDiv.style.display = 'block';
      msDiv.style.display = 'none';
      break;
    case 1:
      fpsDiv.style.display = 'none';
      msDiv.style.display = 'block';
      break;
    }
  };
  var updateGraph = function (dom, value) {
    var child = dom.appendChild(dom.firstChild);
    child.style.height = value + 'px';
  };
  return {
    REVISION: 11,
    domElement: container,
    setMode: setMode,
    begin: function () {
      startTime = Date.now();
    },
    end: function () {
      var time = Date.now();
      ms = time - startTime;
      msMin = Math.min(msMin, ms);
      msMax = Math.max(msMax, ms);
      msText.textContent = ms + ' MS (' + msMin + '-' + msMax + ')';
      updateGraph(msGraph, Math.min(30, 30 - ms / 200 * 30));
      frames++;
      if (time > prevTime + 1000) {
        fps = Math.round(frames * 1000 / (time - prevTime));
        fpsMin = Math.min(fpsMin, fps);
        fpsMax = Math.max(fpsMax, fps);
        fpsText.textContent = fps + ' FPS (' + fpsMin + '-' + fpsMax + ')';
        updateGraph(fpsGraph, Math.min(30, 30 - fps / 100 * 30));
        prevTime = time;
        frames = 0;
      }
      return time;
    },
    update: function () {
      startTime = this.end();
    }
  };
};
(function () {
  var app;
  app = angular.module('app', [
    'async',
    'jed',
    'jquery',
    'underscore'
  ]);
  app.run([
    '$rootScope',
    '$window',
    '$location',
    'cookie',
    'i18n',
    function ($rootScope, $window, $location, cookie, i18n) {
      var GITHUB_APPLICATION_CLIENT_ID_COOKIE_NAME, GITHUB_LOGIN_COOKIE_NAME, GITHUB_TOKEN_COOKIE_NAME, isMenuLocation;
      GITHUB_APPLICATION_CLIENT_ID_COOKIE_NAME = 'github-application-client-id';
      GITHUB_TOKEN_COOKIE_NAME = 'github-token';
      GITHUB_LOGIN_COOKIE_NAME = 'github-login';
      $rootScope.i18n = i18n;
      $rootScope.breadcrumbStrategy = { progressive: false };
      $rootScope.clientId = function () {
        return cookie.getItem(GITHUB_APPLICATION_CLIENT_ID_COOKIE_NAME);
      };
      $rootScope.log = function (thing) {
      };
      $rootScope.alert = function (thing) {
        return alert(thing);
      };
      $rootScope.isLoggedIn = function () {
        return cookie.hasItem(GITHUB_TOKEN_COOKIE_NAME);
      };
      $rootScope.loginEnabled = function () {
        return !cookie.hasItem(GITHUB_TOKEN_COOKIE_NAME);
      };
      $rootScope.logout = function () {
        cookie.removeItem(GITHUB_TOKEN_COOKIE_NAME);
        return cookie.removeItem(GITHUB_LOGIN_COOKIE_NAME);
      };
      $rootScope.login = function () {
        var clientId;
        clientId = cookie.getItem(GITHUB_APPLICATION_CLIENT_ID_COOKIE_NAME);
        return $window.location.href = 'https://github.com/login/oauth/authorize?client_id=' + clientId + '&amp;scope=repo,user,gist';
      };
      $rootScope.userLogin = function () {
        return cookie.getItem(GITHUB_LOGIN_COOKIE_NAME);
      };
      $rootScope.headerEnabled = function () {
        return true;
      };
      isMenuLocation = function () {
        if ($window.location && $window.location.href) {
          return !$window.location.href.match(new RegExp('/workbench$')) && !$window.location.href.match(new RegExp('/users/')) && !$window.location.href.match(new RegExp('/gists/'));
        } else {
          return false;
        }
      };
      $rootScope.isHomePage = function () {
        return true;
      };
      $rootScope.jumpIcon = function () {
        if (isMenuLocation()) {
          return 'icon-edit';
        } else {
          return 'icon-home';
        }
      };
      $rootScope.jumpText = function () {
        if (isMenuLocation()) {
          return 'Workbench';
        } else {
          return 'Home';
        }
      };
      return $rootScope.jumpHRef = function () {
        if (isMenuLocation()) {
          return '/workbench';
        } else {
          return '/';
        }
      };
    }
  ]);
}.call(this));
(function () {
  angular.module('app').controller('EmbedCtrl', [
    '$rootScope',
    '$scope',
    '$location',
    '$window',
    '$routeParams',
    '$',
    '_',
    'GitHub',
    'Base64',
    'cookie',
    'GitHubAuthManager',
    function ($rootScope, $scope, $location, $window, $routeParams, $, _, github, base64, cookie, authManager) {
      var EVENT_CATEGORY, GITHUB_TOKEN_COOKIE_NAME, editor, n, steps, token, _i;
      EVENT_CATEGORY = 'embed';
      ga('create', 'UA-41504069-1', 'geometryzen.org');
      ga('set', 'page', '/embed');
      ga('send', 'pageview');
      authManager.handleLoginCallback(function (err, token) {
        if (err) {
          return $window.alert(err.message);
        }
      });
      editor = ace.edit('editor');
      editor.setTheme('ace/theme/twilight');
      editor.getSession().setMode('ace/mode/python');
      editor.setShowInvisibles(true);
      editor.setFontSize(15);
      editor.setShowPrintMargin(false);
      GITHUB_TOKEN_COOKIE_NAME = 'github-token';
      token = cookie.getItem(GITHUB_TOKEN_COOKIE_NAME);
      $scope.messages = [];
      $scope.contextItem = {};
      $scope.contextGist = {};
      if ($routeParams.user && $routeParams.repo) {
        $scope.user = { login: $routeParams.user };
        $scope.repo = { name: $routeParams.repo };
        $scope.branch = { name: $routeParams.branch };
        steps = [];
        for (n = _i = 0; _i <= 6; n = ++_i) {
          if ($routeParams['step' + n]) {
            steps.push($routeParams['step' + n]);
          }
        }
        $scope.path = steps.join('/');
        $scope.contextItem.name = $routeParams.repo;
        $scope.contextItem.type = 'repo';
        github.getPathContents(token, $scope.user.login, $scope.repo.name, $scope.path, function (err, file) {
          var contextItem;
          if (!err) {
            contextItem = {
              name: file.name,
              path: file.path,
              sha: file.sha,
              type: file.type,
              parentItem: $scope.contextItem,
              childItems: []
            };
            $scope.contextItem = contextItem;
            if (file.encoding === 'base64') {
              editor.setValue(base64.decode(file.content));
              editor.focus();
              return editor.gotoLine(0, 0);
            } else {
              return alert('Unknown encoding: ' + file.encoding);
            }
          } else {
            console.log(err);
          }
        });
      } else if ($routeParams.gistId) {
        github.getGist(token, $routeParams.gistId, function (err, gist) {
          if (!err) {
            $scope.contextGist = gist;
            $scope.contextItem.name = 'main.py';
            editor.setValue(gist.files['main.py'].content);
            editor.focus();
            return editor.gotoLine(0, 0);
          } else {
            console.log(err);
          }
        });
      } else {
        $scope.contextItem.name = 'Untitled';
        $scope.contextItem.type = void 0;
      }
      $scope.run = function () {
        var e, message, name, prog, text;
        ga('send', 'event', EVENT_CATEGORY, 'run');
        $rootScope.$broadcast('reset');
        $scope.messages.length = 0;
        prog = editor.getValue();
        Sk.canvas = 'canvas';
        Sk.python3 = false;
        Sk.configure({
          'output': function (text) {
            return $rootScope.$broadcast('print', text);
          },
          'debugout': function (arg) {
            return console.log('' + JSON.stringify(arg, null, 2));
          },
          'read': function (searchPath) {
            if (Sk.builtinFiles === void 0 || Sk.builtinFiles['files'][searchPath] === void 0) {
              throw new Error('File not found: \'' + searchPath + '\'');
            } else {
              return Sk.builtinFiles['files'][searchPath];
            }
          }
        });
        if (prog.trim().length > 0) {
          try {
            return eval(Sk.importMainWithBody('<stdin>', false, prog.trim()));
          } catch (_error) {
            e = _error;
            if (typeof e !== 'undefined') {
              if (typeof e.toString === 'function') {
                message = e.toString();
                name = message.substring(0, message.indexOf(':'));
                text = message.substring(message.indexOf(':') + 1);
                return $scope.messages.push({
                  name: name,
                  text: text,
                  severity: 'error'
                });
              } else {
                return console.log(JSON.stringify(e, null, 2));
              }
            }
          }
        }
      };
      $scope.saveFile = function () {
        var content, data, description, files;
        ga('send', 'event', EVENT_CATEGORY, 'savePage');
        content = base64.encode(editor.getValue());
        if ($scope.user) {
          return github.putFile(token, $scope.user.login, $scope.repo.name, $scope.contextItem.path, 'Save file.', content, $scope.contextItem.sha, function (err, response, status, headers, config) {
            if (!err) {
              return $scope.contextItem.sha = response.content.sha;
            } else {
              return alert('Error saving file to repository. Cause: ' + err.message);
            }
          });
        } else {
          if ($scope.contextGist.id) {
            description = $scope.contextGist.description;
            files = { 'main.py': { content: editor.getValue() } };
            return github.patchGist(token, $scope.contextGist.id, {
              description: description,
              files: files
            }, function (err, response, status, headers, config) {
              if (!err) {
              } else {
                return alert('Error patching Gist. Cause: ' + err.message);
              }
            });
          } else {
            files = { 'main.py': { content: editor.getValue() } };
            data = {};
            data.description = 'Geometric Physics Gist';
            data['public'] = true;
            data.files = files;
            return github.postGist(token, data, function (err, response, status, headers, config) {
              if (!err) {
                return $location.path('/gists/' + response.id);
              } else {
                return alert('Error posting Gist. Cause: ' + err.message);
              }
            });
          }
        }
      };
      $scope.homeBreadcrumbClass = function () {
        if ($rootScope.breadcrumbStrategy.progressive) {
          return 'active';
        } else {
          return '';
        }
      };
      $scope.userBreadcrumbClass = function () {
        if ($rootScope.breadcrumbStrategy.progressive) {
          return 'active';
        } else {
          return '';
        }
      };
      $scope.repoBreadcrumbClass = function () {
        if ($rootScope.breadcrumbStrategy.progressive) {
          return 'active';
        } else {
          if ($scope.workEnabled()) {
            return '';
          } else {
            return 'active';
          }
        }
      };
      $scope.repoEnabled = function () {
        return $scope.repo && $scope.repo.name;
      };
      $scope.workEnabled = function () {
        return $scope.contextItem && $scope.contextItem.type === 'file' || !($scope.repo && $scope.repo.name);
      };
      $scope.saveEnabled = function () {
        if ($scope.user) {
          return $scope.isLoggedIn() && $scope.userLogin() === $scope.user.login && $scope.contextItem && $scope.contextItem.type === 'file';
        } else {
          return true;
        }
      };
      $scope.runEnabled = function () {
        return $scope.workEnabled();
      };
      $rootScope.headerEnabled = function () {
        return false;
      };
      $scope.iconFromItem = function (item) {
        switch (item.type) {
        case 'file':
          return 'icon-file';
        case 'dir':
          return 'icon-dir';
        default:
          return 'icon-question';
        }
      };
    }
  ]);
}.call(this));
(function () {
  angular.module('app').controller('HomeCtrl', [
    '$rootScope',
    '$scope',
    '$http',
    '$location',
    '$window',
    'GitHubAuthManager',
    function ($rootScope, $scope, $http, $location, $window, authManager) {
      var EVENT_CATEGORY;
      EVENT_CATEGORY = 'home';
      ga('create', 'UA-41504069-1', 'geometryzen.org');
      ga('set', 'page', '/home');
      ga('send', 'pageview');
      authManager.handleLoginCallback(function (err, token) {
        if (err) {
          return $window.alert(err.message);
        }
      });
      $scope.work = function () {
        ga('send', 'event', EVENT_CATEGORY, 'work');
        $location.path('/work');
      };
      $scope.browse = function () {
        ga('send', 'event', EVENT_CATEGORY, 'browse');
        $location.path('/browse');
      };
      return $scope.user = function () {
        var path;
        ga('send', 'event', EVENT_CATEGORY, 'user');
        path = '/users/' + $scope.userLogin();
        $location.path(path);
      };
    }
  ]);
}.call(this));
(function () {
  angular.module('app').controller('NewFileCtrl', [
    '$scope',
    'GitHub',
    'Base64',
    'cookie',
    '$',
    '_',
    function ($scope, github, base64, cookie, $, _) {
      var EVENT_CATEGORY, GITHUB_TOKEN_COOKIE_NAME, token;
      EVENT_CATEGORY = 'new-file';
      ga('create', 'UA-41504069-1', 'geometryzen.org');
      ga('set', 'page', '/new-file');
      ga('send', 'pageview');
      GITHUB_TOKEN_COOKIE_NAME = 'github-token';
      token = cookie.getItem(GITHUB_TOKEN_COOKIE_NAME);
      $('#new-file-dialog').on('show', function () {
        return $scope.file = {
          name: '',
          message: ''
        };
      });
      $('#new-file-dialog').on('shown', function () {
      });
      $('#new-file-dialog').on('hide', function () {
      });
      $('#new-file-dialog').on('hidden', function () {
      });
      return $scope.createFile = function () {
        var content, path;
        ga('send', 'event', EVENT_CATEGORY, 'createFile');
        content = base64.encode('# ' + $scope.file.name + '\n');
        path = $scope.path ? '' + $scope.path + '/' + $scope.file.name : $scope.file.name;
        return github.putFile(token, $scope.user.login, $scope.repo.name, path, $scope.file.message, content, void 0, function (err, response, status, headers, config) {
          var messages;
          if (!err) {
            $scope.$emit('createdFile', $scope.user, $scope.repo, response.content, response.commit);
            return $('#new-file-dialog').modal('hide');
          } else {
            messages = _.map(response.errors, function (error) {
              return error.message;
            }).join();
            return alert(messages);
          }
        });
      };
    }
  ]);
}.call(this));
(function () {
  angular.module('app').controller('NewGistCtrl', [
    '$scope',
    'GitHub',
    'cookie',
    '$',
    '_',
    function ($scope, github, cookie, $, _) {
      var EVENT_CATEGORY, GITHUB_TOKEN_COOKIE_NAME, token;
      EVENT_CATEGORY = 'new-gist';
      ga('create', 'UA-41504069-1', 'geometryzen.org');
      ga('set', 'page', '/new-gist');
      ga('send', 'pageview');
      GITHUB_TOKEN_COOKIE_NAME = 'github-token';
      token = cookie.getItem(GITHUB_TOKEN_COOKIE_NAME);
      $('#new-gist-dialog').on('show', function () {
        return $scope.gist = {
          path: '',
          description: '',
          'private': 'false',
          markdownReadme: true,
          pythonReadme: true
        };
      });
      $('#new-gist-dialog').on('shown', function () {
      });
      $('#new-gist-dialog').on('hide', function () {
      });
      $('#new-gist-dialog').on('hidden', function () {
      });
      return $scope.createGist = function () {
        var data;
        ga('send', 'event', EVENT_CATEGORY, 'createGist');
        data = {};
        data.description = $scope.gist.description;
        data['public'] = true;
        data.files = { 'main.py': { 'content': '# main.py' } };
        return github.postGist(token, data, function (err, response, status, headers, config) {
          var messages;
          if (!err) {
            $scope.$emit('createdGist', $scope.user, response);
            return $('#new-gist-dialog').modal('hide');
          } else {
            messages = _.map(response.errors, function (error) {
              return error.message;
            }).join();
            return alert(messages);
          }
        });
      };
    }
  ]);
}.call(this));
(function () {
  angular.module('app').controller('NewRepoCtrl', [
    '$scope',
    'GitHub',
    'cookie',
    '$',
    '_',
    function ($scope, github, cookie, $, _) {
      var EVENT_CATEGORY, GITHUB_TOKEN_COOKIE_NAME, token;
      EVENT_CATEGORY = 'new-repo';
      ga('create', 'UA-41504069-1', 'geometryzen.org');
      ga('set', 'page', '/new-repo');
      ga('send', 'pageview');
      GITHUB_TOKEN_COOKIE_NAME = 'github-token';
      token = cookie.getItem(GITHUB_TOKEN_COOKIE_NAME);
      $('#new-repo-dialog').on('show', function () {
        return $scope.repo = {
          path: '',
          description: '',
          'private': 'false',
          markdownReadme: true,
          pythonReadme: true
        };
      });
      $('#new-repo-dialog').on('shown', function () {
      });
      $('#new-repo-dialog').on('hide', function () {
      });
      $('#new-repo-dialog').on('hidden', function () {
      });
      return $scope.createRepo = function () {
        ga('send', 'event', EVENT_CATEGORY, 'createRepo');
        return github.postRepo(token, $scope.repo.name, $scope.repo.description, false, $scope.repo.markdownReadme, function (err, repo) {
          var messages;
          if (!err) {
            $scope.$emit('createdRepo', $scope.user, repo);
            return $('#new-repo-dialog').modal('hide');
          } else {
            messages = _.map(response.errors, function (error) {
              return error.message;
            }).join();
            return alert(messages);
          }
        });
      };
    }
  ]);
}.call(this));
(function () {
  angular.module('app').controller('PrinterCtrl', [
    '$scope',
    function ($scope) {
      var EVENT_CATEGORY, PRESERVE_ELEMENT_ID, escapeHtml;
      EVENT_CATEGORY = 'printer';
      ga('create', 'UA-41504069-1', 'geometryzen.org');
      ga('set', 'page', '/printer');
      ga('send', 'pageview');
      PRESERVE_ELEMENT_ID = 'a5f435e0-c92e-11e2-8b8b-0800200c9a66';
      escapeHtml = function (s) {
        return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#039;');
      };
      $scope.$on('reset', function (e) {
        var elem;
        elem = document.getElementById(PRESERVE_ELEMENT_ID);
        if (elem) {
          return elem.innerHTML = '';
        } else {
          return console.log('Unable to find element with Id ' + PRESERVE_ELEMENT_ID);
        }
      });
      return $scope.$on('print', function (e, text) {
        var elem;
        elem = document.getElementById(PRESERVE_ELEMENT_ID);
        if (elem) {
          return elem.innerHTML = elem.innerHTML + escapeHtml(text);
        } else {
          return console.log('Unable to find element with Id ' + PRESERVE_ELEMENT_ID);
        }
      });
    }
  ]);
}.call(this));
(function () {
  angular.module('app').controller('TreeCtrl', [
    '$rootScope',
    '$scope',
    '$location',
    '$window',
    '$routeParams',
    '$',
    '_',
    'GitHub',
    'Base64',
    'cookie',
    function ($rootScope, $scope, $location, $window, $routeParams, $, _, github, base64, cookie) {
      var EVENT_CATEGORY, GITHUB_TOKEN_COOKIE_NAME, n, steps, token, _i;
      EVENT_CATEGORY = 'tree';
      ga('create', 'UA-41504069-1', 'geometryzen.org');
      ga('set', 'page', '/tree');
      ga('send', 'pageview');
      GITHUB_TOKEN_COOKIE_NAME = 'github-token';
      token = cookie.getItem(GITHUB_TOKEN_COOKIE_NAME);
      $scope.messages = [];
      $('.carousel').carousel({ interval: false });
      $scope.contextItem = {};
      if ($routeParams.user && $routeParams.repo) {
        $scope.user = { login: $routeParams.user };
        $scope.repo = { name: $routeParams.repo };
        $scope.branch = { name: $routeParams.branch };
        steps = [];
        for (n = _i = 0; _i <= 6; n = ++_i) {
          if ($routeParams['step' + n]) {
            steps.push($routeParams['step' + n]);
          }
        }
        $scope.path = steps.join('/');
        $scope.contextItem.name = $scope.repo.name;
        $scope.contextItem.type = 'repo';
        github.getPathContents(token, $scope.user.login, $scope.repo.name, $scope.path, function (err, response, status, headers, config) {
          if (!err) {
            return $scope.contextItem.childItems = response;
          } else {
            console.log('err: ' + err + ', reponse: ' + response + ', status ' + status);
            return alert('' + err.message + '. Cause: ' + response.message + '.');
          }
        });
      } else {
        $scope.contextItem.name = '';
        $scope.contextItem.type = void 0;
      }
      $scope.isNewFileEnabled = function () {
        return $scope.isLoggedIn() && $scope.userLogin() === $scope.user.login;
      };
      $scope.newFile = function () {
        if ($scope.isNewFileEnabled()) {
          return $('#new-file-dialog').modal({
            show: true,
            backdrop: true
          });
        } else {
          return alert('Create a New File is not enabled.');
        }
      };
      $scope.$on('createdFile', function (event, user, repo, item, commit) {
        $scope.contextItem.childItems.push(item);
        return $location.path($scope.hrefFromItem(item));
      });
      $scope.isDeleteItemEnabled = function () {
        return $scope.isLoggedIn() && $scope.userLogin() === $scope.user.login;
      };
      $scope.deleteItem = function (idx) {
        var childItem;
        ga('send', 'event', EVENT_CATEGORY, 'deleteItem');
        childItem = $scope.contextItem.childItems[idx];
        return github.deleteFile(token, $scope.user.login, $scope.repo.name, childItem.path, 'Delete item.', childItem.sha, function (err, response, status, headers, config) {
          if (!err) {
            return $scope.contextItem.childItems.splice(idx, 1);
          } else {
            return alert('Error deleting item: ' + err);
          }
        });
      };
      $scope.homeBreadcrumbClass = function () {
        if ($rootScope.breadcrumbStrategy.progressive) {
          return 'active';
        } else {
          return '';
        }
      };
      $scope.userBreadcrumbClass = function () {
        if ($rootScope.breadcrumbStrategy.progressive) {
          return 'active';
        } else {
          return '';
        }
      };
      $scope.repoBreadcrumbClass = function () {
        return 'active';
      };
      $scope.hrefFromItem = function (item) {
        var collectionName;
        collectionName = item.type === 'file' ? 'blob' : item.type === 'dir' ? 'tree' : 'unknown';
        return '/users/' + $scope.user.login + '/repos/' + $scope.repo.name + '/' + collectionName + '/' + $scope.branch.name + '/' + item.path;
      };
      $scope.iconFromItem = function (item) {
        switch (item.type) {
        case 'file':
          return 'icon-file';
        case 'dir':
          return 'icon-dir';
        default:
          return 'icon-question';
        }
      };
    }
  ]);
}.call(this));
(function () {
  angular.module('app').controller('UserCtrl', [
    '$rootScope',
    '$scope',
    '$routeParams',
    'GitHub',
    'cookie',
    '$',
    '_',
    'async',
    function ($rootScope, $scope, $routeParams, github, cookie, $, _, async) {
      var EVENT_CATEGORY, GITHUB_TOKEN_COOKIE_NAME, findIndex, loadGists, loadRepos, token;
      EVENT_CATEGORY = 'user';
      ga('create', 'UA-41504069-1', 'geometryzen.org');
      ga('set', 'page', '/user');
      ga('send', 'pageview');
      GITHUB_TOKEN_COOKIE_NAME = 'github-token';
      token = cookie.getItem(GITHUB_TOKEN_COOKIE_NAME);
      loadGists = function (callback) {
        return github.getGists(token, function (err, gists) {
          if (!err) {
            $scope.gists = _.filter(_.map(gists, function (gist) {
              return {
                'id': gist.id,
                'description': gist.description,
                'html_url': gist.html_url
              };
            }), function (gist) {
              return true;
            });
          } else {
            alert('Error retrieving user Gists.');
          }
          return callback(err, gists);
        });
      };
      loadRepos = function (callback) {
        return github.getUserRepos(token, function (err, repos) {
          if (!err) {
            $scope.repos = repos;
          } else {
            alert('Error retrieving user Repositories.');
          }
          return callback(err, repos);
        });
      };
      async.parallel([
        function (callback) {
          return github.getUser(token, function (err, user) {
            if (!err) {
              $scope.user = user;
            } else {
              alert('Error retrieving user profile');
            }
            return callback(err, user);
          });
        },
        function (callback) {
          return loadRepos(callback);
        },
        function (callback) {
          return loadGists(callback);
        }
      ], function (err, results) {
      });
      $scope.homeBreadcrumbClass = function () {
        if ($rootScope.breadcrumbStrategy.progressive) {
          return 'active distance-1';
        } else {
          return '';
        }
      };
      $scope.userBreadcrumbClass = function () {
        if ($rootScope.breadcrumbStrategy.progressive) {
          return 'active distance-0';
        } else {
          return 'active distance-0';
        }
      };
      $scope.newGist = function () {
        return $('#new-gist-dialog').modal({
          show: true,
          backdrop: true
        });
      };
      findIndex = function (xs, match) {
        var i, length, x, _i, _ref;
        length = xs;
        for (i = _i = 0, _ref = length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
          x = xs[i];
          if (match(x)) {
            return x;
          }
        }
        return -1;
      };
      $scope.deleteGist = function (owner, id) {
        ga('send', 'event', EVENT_CATEGORY, 'deleteGist');
        return github.deleteGist(token, owner, id, function (err, response, status, headers, config) {
          var index;
          if (!err) {
            index = findIndex($scope.gists, function (gist) {
              return gist.id === id;
            });
            return $scope.gists.splice(index, 1);
          } else {
            return alert('Error deleting gist: ' + err);
          }
        });
      };
      $scope.$on('createdGist', function (e, user, gist) {
        return $scope.gists.push(gist);
      });
      $scope.newRepo = function (owner) {
        return $('#new-repo-dialog').modal({
          show: true,
          backdrop: true
        });
      };
      $scope.deleteRepo = function (owner, repo) {
        ga('send', 'event', EVENT_CATEGORY, 'deleteRepo');
        return github.deleteRepo(token, owner, repo, function (err, response, status, headers, config) {
          if (!err) {
          } else {
            return alert('Error deleting repo: ' + err);
          }
        });
      };
      return $scope.$on('createdRepo', function (e, user, repo) {
        return $scope.repos.push(repo);
      });
    }
  ]);
}.call(this));
(function () {
  angular.module('app').controller('WorkCtrl', [
    '$rootScope',
    '$scope',
    '$location',
    '$window',
    '$routeParams',
    '$',
    '_',
    'GitHub',
    'Base64',
    'cookie',
    'GitHubAuthManager',
    function ($rootScope, $scope, $location, $window, $routeParams, $, _, github, base64, cookie, authManager) {
      var EVENT_CATEGORY, GITHUB_TOKEN_COOKIE_NAME, editor, n, steps, token, _i;
      EVENT_CATEGORY = 'work';
      ga('create', 'UA-41504069-1', 'geometryzen.org');
      ga('set', 'page', '/work');
      ga('send', 'pageview');
      authManager.handleLoginCallback(function (err, token) {
        if (err) {
          return $window.alert(err.message);
        }
      });
      editor = ace.edit('editor');
      editor.setTheme('ace/theme/twilight');
      editor.getSession().setMode('ace/mode/python');
      editor.setShowInvisibles(true);
      editor.setFontSize(15);
      editor.setShowPrintMargin(false);
      GITHUB_TOKEN_COOKIE_NAME = 'github-token';
      token = cookie.getItem(GITHUB_TOKEN_COOKIE_NAME);
      $scope.messages = [];
      $scope.contextItem = {};
      $scope.contextGist = {};
      if ($routeParams.user && $routeParams.repo) {
        $scope.user = { login: $routeParams.user };
        $scope.repo = { name: $routeParams.repo };
        $scope.branch = { name: $routeParams.branch };
        steps = [];
        for (n = _i = 0; _i <= 6; n = ++_i) {
          if ($routeParams['step' + n]) {
            steps.push($routeParams['step' + n]);
          }
        }
        $scope.path = steps.join('/');
        $scope.contextItem.name = $routeParams.repo;
        $scope.contextItem.type = 'repo';
        github.getPathContents(token, $scope.user.login, $scope.repo.name, $scope.path, function (err, file) {
          var contextItem;
          if (!err) {
            contextItem = {
              name: file.name,
              path: file.path,
              sha: file.sha,
              type: file.type,
              parentItem: $scope.contextItem,
              childItems: []
            };
            $scope.contextItem = contextItem;
            if (file.encoding === 'base64') {
              editor.setValue(base64.decode(file.content));
              editor.focus();
              return editor.gotoLine(0, 0);
            } else {
              return alert('Unknown encoding: ' + file.encoding);
            }
          } else {
            console.log(err);
          }
        });
      } else if ($routeParams.gistId) {
        github.getGist(token, $routeParams.gistId, function (err, gist) {
          if (!err) {
            $scope.contextGist = gist;
            $scope.contextItem.name = 'main.py';
            editor.setValue(gist.files['main.py'].content);
            editor.focus();
            editor.gotoLine(0, 0);
          } else {
            console.log(err);
          }
        });
      } else {
        $scope.contextItem.name = 'Untitled';
        $scope.contextItem.type = void 0;
      }
      $scope.run = function () {
        var e, message, name, prog, text;
        ga('send', 'event', EVENT_CATEGORY, 'run');
        $rootScope.$broadcast('reset');
        $scope.messages.length = 0;
        prog = editor.getValue();
        Sk.canvas = 'canvas';
        Sk.python3 = false;
        Sk.configure({
          'output': function (text) {
            return $rootScope.$broadcast('print', text);
          },
          'debugout': function (arg) {
            return console.log('' + JSON.stringify(arg, null, 2));
          },
          'read': function (searchPath) {
            if (Sk.builtinFiles === void 0 || Sk.builtinFiles['files'][searchPath] === void 0) {
              throw new Error('File not found: \'' + searchPath + '\'');
            } else {
              return Sk.builtinFiles['files'][searchPath];
            }
          }
        });
        if (prog.trim().length > 0) {
          try {
            return eval(Sk.importMainWithBody('<stdin>', false, prog.trim()));
          } catch (_error) {
            e = _error;
            if (typeof e !== 'undefined') {
              if (typeof e.toString === 'function') {
                message = e.toString();
                name = message.substring(0, message.indexOf(':'));
                text = message.substring(message.indexOf(':') + 1);
                return $scope.messages.push({
                  name: name,
                  text: text,
                  severity: 'error'
                });
              } else {
                return console.log(JSON.stringify(e, null, 2));
              }
            }
          }
        }
      };
      $scope.saveFile = function () {
        var content, data, description, files;
        ga('send', 'event', EVENT_CATEGORY, 'savePage');
        content = base64.encode(editor.getValue());
        if ($scope.user) {
          return github.putFile(token, $scope.user.login, $scope.repo.name, $scope.contextItem.path, 'Save file.', content, $scope.contextItem.sha, function (err, response, status, headers, config) {
            if (!err) {
              return $scope.contextItem.sha = response.content.sha;
            } else {
              return alert('Error saving file to repository. Cause: ' + err.message);
            }
          });
        } else {
          if ($scope.contextGist.id) {
            description = $scope.contextGist.description;
            files = { 'main.py': { content: editor.getValue() } };
            return github.patchGist(token, $scope.contextGist.id, {
              description: description,
              files: files
            }, function (err, response, status, headers, config) {
              if (!err) {
              } else {
                return alert('Error patching Gist. Cause: ' + err.message);
              }
            });
          } else {
            files = { 'main.py': { content: editor.getValue() } };
            data = {};
            data.description = 'Geometric Physics Gist';
            data['public'] = true;
            data.files = files;
            return github.postGist(token, data, function (err, response, status, headers, config) {
              if (!err) {
                return $location.path('/gists/' + response.id);
              } else {
                return alert('Error posting Gist. Cause: ' + err.message);
              }
            });
          }
        }
      };
      $scope.homeBreadcrumbClass = function () {
        if ($rootScope.breadcrumbStrategy.progressive) {
          return 'active';
        } else {
          return '';
        }
      };
      $scope.userBreadcrumbClass = function () {
        if ($rootScope.breadcrumbStrategy.progressive) {
          return 'active';
        } else {
          return '';
        }
      };
      $scope.repoBreadcrumbClass = function () {
        if ($rootScope.breadcrumbStrategy.progressive) {
          return 'active';
        } else {
          if ($scope.workEnabled()) {
            return '';
          } else {
            return 'active';
          }
        }
      };
      $scope.repoEnabled = function () {
        return $scope.repo && $scope.repo.name;
      };
      $scope.workEnabled = function () {
        return $scope.contextItem && $scope.contextItem.type === 'file' || !($scope.repo && $scope.repo.name);
      };
      $scope.saveEnabled = function () {
        if ($scope.user) {
          return $scope.isLoggedIn() && $scope.userLogin() === $scope.user.login && $scope.contextItem && $scope.contextItem.type === 'file';
        } else {
          return true;
        }
      };
      $scope.runEnabled = function () {
        return $scope.workEnabled();
      };
      $rootScope.headerEnabled = function () {
        return true;
      };
      $scope.iconFromItem = function (item) {
        switch (item.type) {
        case 'file':
          return 'icon-file';
        case 'dir':
          return 'icon-dir';
        default:
          return 'icon-question';
        }
      };
    }
  ]);
}.call(this));
(function () {
  var module;
  module = angular.module('app');
  module.directive('aHome', function () {
    return {
      restrict: 'E',
      replace: true,
      templateUrl: 'angular/a-home.html'
    };
  });
}.call(this));
(function () {
  var module;
  module = angular.module('app');
  module.directive('embedLayout', function () {
    return {
      restrict: 'C',
      link: function (scope, elm, attrs) {
        return elm.layout({
          applyDefaultStyles: false,
          east__size: 0.3,
          south__size: 0.15
        });
      }
    };
  });
}.call(this));
(function () {
  angular.module('app').directive('githubAuthorize', function () {
    return {
      restrict: 'E',
      replace: true,
      templateUrl: 'angular/github-authorize.html'
    };
  });
}.call(this));
(function () {
  angular.module('app').directive('printer', function () {
    return {
      restrict: 'E',
      templateUrl: 'angular/printer.html'
    };
  });
}.call(this));
(function () {
  var module;
  module = angular.module('app');
  module.directive('userLinks', function () {
    return {
      restrict: 'E',
      replace: true,
      template: '<div class="user-links">\n  <a class="btn btn-secondary" ng-href="{{jumpHRef()}}">\n    <i class="{{jumpIcon()}}"/>\n    <span>{{jumpText()}}</span>\n  </a>\n  <button class="btn btn-secondary" ng-click="logout()" href="#" ng-show="isLoggedIn()">\n    <i class="icon-signout"></i>\n    <span>{{userLogin()}}</span>\n  </button>\n  <a class="btn btn-secondary" ng-hide="isLoggedIn()" ng-click="login()">\n    <i class="icon-signin"/>\n    <span>Sign in</span>\n  </a>\n</div>'
    };
  });
}.call(this));
(function () {
  var module;
  module = angular.module('app');
  module.directive('workLayout', function () {
    return {
      restrict: 'C',
      link: function (scope, elm, attrs) {
        return elm.layout({
          applyDefaultStyles: false,
          east__size: 0.3,
          south__size: 0.15
        });
      }
    };
  });
}.call(this));
(function () {
  var app;
  app = angular.module('app');
  app.config([
    '$routeProvider',
    '$locationProvider',
    function ($routeProvider, $locationProvider) {
      $routeProvider.when('/', {
        templateUrl: 'angular/home.html',
        controller: 'HomeCtrl'
      });
      $routeProvider.when('/workbench', {
        templateUrl: 'angular/work.html',
        controller: 'WorkCtrl'
      });
      $routeProvider.when('/gists/:gistId', {
        templateUrl: 'angular/work.html',
        controller: 'WorkCtrl'
      });
      $routeProvider.when('/embed/users/:user/repos/:repo/blob/:branch/:step0/:step1/:step2/:step3/:step4', {
        templateUrl: 'angular/embed.html',
        controller: 'EmbedCtrl'
      });
      $routeProvider.when('/embed/users/:user/repos/:repo/blob/:branch/:step0/:step1/:step2/:step3', {
        templateUrl: 'angular/embed.html',
        controller: 'EmbedCtrl'
      });
      $routeProvider.when('/embed/users/:user/repos/:repo/blob/:branch/:step0/:step1/:step2', {
        templateUrl: 'angular/embed.html',
        controller: 'EmbedCtrl'
      });
      $routeProvider.when('/embed/users/:user/repos/:repo/blob/:branch/:step0/:step1', {
        templateUrl: 'angular/embed.html',
        controller: 'EmbedCtrl'
      });
      $routeProvider.when('/embed/users/:user/repos/:repo/blob/:branch/:step0', {
        templateUrl: 'angular/embed.html',
        controller: 'EmbedCtrl'
      });
      $routeProvider.when('/users/:user/repos/:repo/blob/:branch/:step0/:step1/:step2/:step3/:step4', {
        templateUrl: 'angular/work.html',
        controller: 'WorkCtrl'
      });
      $routeProvider.when('/users/:user/repos/:repo/blob/:branch/:step0/:step1/:step2/:step3', {
        templateUrl: 'angular/work.html',
        controller: 'WorkCtrl'
      });
      $routeProvider.when('/users/:user/repos/:repo/blob/:branch/:step0/:step1/:step2', {
        templateUrl: 'angular/work.html',
        controller: 'WorkCtrl'
      });
      $routeProvider.when('/users/:user/repos/:repo/blob/:branch/:step0/:step1', {
        templateUrl: 'angular/work.html',
        controller: 'WorkCtrl'
      });
      $routeProvider.when('/users/:user/repos/:repo/blob/:branch/:step0', {
        templateUrl: 'angular/work.html',
        controller: 'WorkCtrl'
      });
      $routeProvider.when('/users/:user/repos/:repo/tree/:branch/:step0/:step1/:step2/:step3/:step4', {
        templateUrl: 'angular/tree.html',
        controller: 'TreeCtrl'
      });
      $routeProvider.when('/users/:user/repos/:repo/tree/:branch/:step0/:step1/:step2/:step3', {
        templateUrl: 'angular/tree.html',
        controller: 'TreeCtrl'
      });
      $routeProvider.when('/users/:user/repos/:repo/tree/:branch/:step0/:step1/:step2', {
        templateUrl: 'angular/tree.html',
        controller: 'TreeCtrl'
      });
      $routeProvider.when('/users/:user/repos/:repo/tree/:branch/:step0/:step1', {
        templateUrl: 'angular/tree.html',
        controller: 'TreeCtrl'
      });
      $routeProvider.when('/users/:user/repos/:repo/tree/:branch/:step0', {
        templateUrl: 'angular/tree.html',
        controller: 'TreeCtrl'
      });
      $routeProvider.when('/users/:user/repos/:repo/tree/:branch', {
        templateUrl: 'angular/tree.html',
        controller: 'TreeCtrl'
      });
      $routeProvider.when('/users/:user', {
        templateUrl: 'angular/user.html',
        controller: 'UserCtrl'
      });
      $routeProvider.otherwise({ redirectTo: '/' });
      return $locationProvider.html5Mode(true);
    }
  ]);
}.call(this));
(function () {
  var _keyStr, _utf8_decode, _utf8_encode;
  _keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
  _utf8_decode = function (utftext) {
    var c, c1, c2, c3, i, string;
    string = '';
    i = 0;
    c = c1 = c2 = 0;
    while (i < utftext.length) {
      c = utftext.charCodeAt(i);
      if (c < 128) {
        string += String.fromCharCode(c);
        i++;
      } else if (c > 191 && c < 224) {
        c2 = utftext.charCodeAt(i + 1);
        string += String.fromCharCode((c & 31) << 6 | c2 & 63);
        i += 2;
      } else {
        c2 = utftext.charCodeAt(i + 1);
        c3 = utftext.charCodeAt(i + 2);
        string += String.fromCharCode((c & 15) << 12 | (c2 & 63) << 6 | c3 & 63);
        i += 3;
      }
    }
    return string;
  };
  _utf8_encode = function (string) {
    var c, n, utftext, _i, _ref;
    string = string.replace(/\r\n/g, '\n');
    utftext = '';
    for (n = _i = 0, _ref = string.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; n = 0 <= _ref ? ++_i : --_i) {
      c = string.charCodeAt(n);
      if (c < 128) {
        utftext += String.fromCharCode(c);
      } else if (c > 127 && c < 2048) {
        utftext += String.fromCharCode(c >> 6 | 192);
        utftext += String.fromCharCode(c & 63 | 128);
      } else {
        utftext += String.fromCharCode(c >> 12 | 224);
        utftext += String.fromCharCode(c >> 6 & 63 | 128);
        utftext += String.fromCharCode(c & 63 | 128);
      }
    }
    return utftext;
  };
  angular.module('app').factory('Base64', [
    '$window',
    function ($window) {
      return {
        decode: function (input) {
          var chr1, chr2, chr3, enc1, enc2, enc3, enc4, i, output;
          output = '';
          i = 0;
          input = input.replace(/[^A-Za-z0-9\+\/\=]/g, '');
          while (i < input.length) {
            enc1 = _keyStr.indexOf(input.charAt(i++));
            enc2 = _keyStr.indexOf(input.charAt(i++));
            enc3 = _keyStr.indexOf(input.charAt(i++));
            enc4 = _keyStr.indexOf(input.charAt(i++));
            chr1 = enc1 << 2 | enc2 >> 4;
            chr2 = (enc2 & 15) << 4 | enc3 >> 2;
            chr3 = (enc3 & 3) << 6 | enc4;
            output = output + String.fromCharCode(chr1);
            if (enc3 !== 64) {
              output = output + String.fromCharCode(chr2);
            }
            if (enc4 !== 64) {
              output = output + String.fromCharCode(chr3);
            }
          }
          output = _utf8_decode(output);
          return output;
        },
        encode: function (input) {
          var chr1, chr2, chr3, enc1, enc2, enc3, enc4, i, output;
          output = '';
          i = 0;
          input = _utf8_encode(input);
          while (i < input.length) {
            chr1 = input.charCodeAt(i++);
            chr2 = input.charCodeAt(i++);
            chr3 = input.charCodeAt(i++);
            enc1 = chr1 >> 2;
            enc2 = (chr1 & 3) << 4 | chr2 >> 4;
            enc3 = (chr2 & 15) << 2 | chr3 >> 6;
            enc4 = chr3 & 63;
            if (isNaN(chr2)) {
              enc3 = enc4 = 64;
            } else if (isNaN(chr3)) {
              enc4 = 64;
            }
            output = output + _keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4);
          }
          return output;
        }
      };
    }
  ]);
}.call(this));
(function () {
  angular.module('app').factory('GitHub', [
    '$http',
    function ($http) {
      var GITHUB_DOMAIN, GITHUB_PROTOCOL, Gist, HTTP_METHOD_DELETE, HTTP_METHOD_GET, HTTP_METHOD_PATCH, HTTP_METHOD_POST, HTTP_METHOD_PUT, Repo, User;
      GITHUB_PROTOCOL = 'https';
      GITHUB_DOMAIN = 'api.github.com';
      HTTP_METHOD_DELETE = 'DELETE';
      HTTP_METHOD_GET = 'GET';
      HTTP_METHOD_PATCH = 'PATCH';
      HTTP_METHOD_POST = 'POST';
      HTTP_METHOD_PUT = 'PUT';
      User = function () {
        function User(name, login) {
          this.name = name;
          this.login = login;
        }
        return User;
      }();
      Gist = function () {
        function Gist(id, description, isPublic, files, html_url) {
          this.id = id;
          this.description = description;
          this['public'] = isPublic;
          this.files = files;
          this.html_url = html_url;
        }
        return Gist;
      }();
      Repo = function () {
        function Repo(name, description, language, html_url) {
          this.name = name;
          this.description = description;
          this.language = language;
          this.html_url = html_url;
        }
        return Repo;
      }();
      return {
        getUser: function (token, done) {
          var headers;
          headers = token ? { 'Authorization': 'token ' + token } : {};
          return $http({
            method: HTTP_METHOD_GET,
            url: '' + GITHUB_PROTOCOL + '://' + GITHUB_DOMAIN + '/user',
            headers: headers
          }).success(function (user, status, headers, config) {
            return done(null, new User(user.name, user.login), status, headers, config);
          }).error(function (response, status, headers, config) {
            return done(new Error(response.message), response, status, headers, config);
          });
        },
        getUserRepos: function (token, done) {
          var headers;
          headers = token ? { 'Authorization': 'token ' + token } : {};
          return $http({
            method: HTTP_METHOD_GET,
            url: '' + GITHUB_PROTOCOL + '://' + GITHUB_DOMAIN + '/user/repos',
            headers: headers
          }).success(function (repos, status, headers, config) {
            repos = _.map(repos, function (repo) {
              return new Repo(repo.name, repo.description, repo.language, repo.html_url);
            });
            return done(null, repos, status, headers, config);
          }).error(function (response, status, headers, config) {
            return done(new Error(response.message), response, status, headers, config);
          });
        },
        getRepoContents: function (token, user, repo, done) {
          var url;
          url = '' + GITHUB_PROTOCOL + '://' + GITHUB_DOMAIN + '/repos/' + user + '/' + repo + '/contents';
          return $http({
            'method': HTTP_METHOD_GET,
            'url': url,
            'headers': { Authorization: 'token ' + token }
          }).success(function (contents, status, headers, config) {
            return done(null, contents, status, headers, config);
          }).error(function (response, status, headers, config) {
            return done(new Error(response.message), response, status, headers, config);
          });
        },
        getPathContents: function (token, user, repo, path, done) {
          var headers, url;
          url = '' + GITHUB_PROTOCOL + '://' + GITHUB_DOMAIN + '/repos/' + user + '/' + repo + '/contents';
          if (path) {
            url = '' + url + '/' + path;
          }
          headers = token ? { 'Authorization': 'token ' + token } : {};
          return $http({
            'method': HTTP_METHOD_GET,
            'url': url,
            'headers': headers
          }).success(function (contents, status, headers, config) {
            return done(null, contents, status, headers, config);
          }).error(function (response, status, headers, config) {
            return done(new Error(response.message), response, status, headers, config);
          });
        },
        putFile: function (token, owner, repo, path, message, content, sha, done) {
          var data, headers, url;
          url = '' + GITHUB_PROTOCOL + '://' + GITHUB_DOMAIN + '/repos/' + owner + '/' + repo + '/contents/' + path;
          data = {
            message: message,
            content: content
          };
          if (sha) {
            data.sha = sha;
          }
          headers = token ? { 'Authorization': 'token ' + token } : {};
          return $http({
            method: HTTP_METHOD_PUT,
            url: url,
            data: data,
            headers: headers
          }).success(function (file, status, headers, config) {
            return done(null, file, status, headers, config);
          }).error(function (response, status, headers, config) {
            return done(new Error(response.message), response, status, headers, config);
          });
        },
        deleteFile: function (token, owner, repo, path, message, sha, done) {
          var data, url;
          url = '' + GITHUB_PROTOCOL + '://' + GITHUB_DOMAIN + '/repos/' + owner + '/' + repo + '/contents/' + path;
          data = {
            message: message,
            sha: sha
          };
          return $http({
            method: HTTP_METHOD_DELETE,
            url: url,
            data: data,
            headers: { Authorization: 'token ' + token }
          }).success(function (file, status, headers, config) {
            return done(null, file, status, headers, config);
          }).error(function (response, status, headers, config) {
            return done(new Error(response.message), response, status, headers, config);
          });
        },
        postRepo: function (token, name, description, priv, autoInit, done) {
          var data, headers, url;
          url = '' + GITHUB_PROTOCOL + '://' + GITHUB_DOMAIN + '/user/repos';
          data = {
            name: name,
            description: description,
            'private': priv,
            auto_init: autoInit
          };
          headers = token ? { 'Authorization': 'token ' + token } : {};
          return $http({
            method: HTTP_METHOD_POST,
            url: url,
            data: data,
            headers: headers
          }).success(function (repo, status, headers, config) {
            return done(null, repo, status, headers, config);
          }).error(function (response, status, headers, config) {
            return done(new Error(response.message), response, status, headers, config);
          });
        },
        deleteRepo: function (token, owner, repo, done) {
          var url;
          url = '' + GITHUB_PROTOCOL + '://' + GITHUB_DOMAIN + '/repos/' + owner + '/' + repo;
          return $http({
            method: HTTP_METHOD_DELETE,
            url: url,
            headers: { Authorization: 'token ' + token }
          }).success(function (repo, status, headers, config) {
            return done(null, repo, status, headers, config);
          }).error(function (response, status, headers, config) {
            return done(new Error(response.message), response, status, headers, config);
          });
        },
        getGist: function (token, id, done) {
          var headers, url;
          url = '' + GITHUB_PROTOCOL + '://' + GITHUB_DOMAIN + '/gists/' + id;
          headers = token ? { 'Authorization': 'token ' + token } : {};
          return $http({
            'method': HTTP_METHOD_GET,
            'url': url,
            'headers': headers
          }).success(function (contents, status, headers, config) {
            return done(null, contents, status, headers, config);
          }).error(function (response, status, headers, config) {
            return done(new Error(response.message), response, status, headers, config);
          });
        },
        patchGist: function (token, gistId, data, done) {
          var headers, url;
          url = '' + GITHUB_PROTOCOL + '://' + GITHUB_DOMAIN + '/gists/' + gistId;
          headers = token ? { 'Authorization': 'token ' + token } : {};
          return $http({
            method: HTTP_METHOD_PATCH,
            url: url,
            data: data,
            headers: headers
          }).success(function (file, status, headers, config) {
            return done(null, file, status, headers, config);
          }).error(function (response, status, headers, config) {
            return done(new Error(response.message), response, status, headers, config);
          });
        },
        postGist: function (token, data, done) {
          var headers, url;
          url = '' + GITHUB_PROTOCOL + '://' + GITHUB_DOMAIN + '/gists';
          headers = token ? { 'Authorization': 'token ' + token } : {};
          return $http({
            method: HTTP_METHOD_POST,
            url: url,
            data: data,
            headers: headers
          }).success(function (response, status, headers, config) {
            return done(null, response, status, headers, config);
          }).error(function (response, status, headers, config) {
            return done(new Error(response.message), response, status, headers, config);
          });
        },
        deleteGist: function (token, owner, id, done) {
          var url;
          url = '' + GITHUB_PROTOCOL + '://' + GITHUB_DOMAIN + '/gists/' + id;
          return $http({
            method: HTTP_METHOD_DELETE,
            url: url,
            headers: { Authorization: 'token ' + token }
          }).success(function (response, status, headers, config) {
            return done(null, response, status, headers, config);
          }).error(function (response, status, headers, config) {
            return done(new Error(response.message), response, status, headers, config);
          });
        },
        getUserGists: function (token, user, done) {
          var headers;
          headers = token ? { 'Authorization': 'token ' + token } : {};
          return $http({
            method: HTTP_METHOD_GET,
            url: '' + GITHUB_PROTOCOL + '://' + GITHUB_DOMAIN + '/users/' + user + '/gists',
            headers: headers
          }).success(function (gists, status, headers, config) {
            gists = _.map(gists, function (gist) {
              return gist;
            });
            return done(null, gists, status, headers, config);
          }).error(function (response, status, headers, config) {
            return done(new Error(response.message), response, status, headers, config);
          });
        },
        getGists: function (token, done) {
          var headers;
          headers = token ? { 'Authorization': 'token ' + token } : {};
          return $http({
            method: HTTP_METHOD_GET,
            url: '' + GITHUB_PROTOCOL + '://' + GITHUB_DOMAIN + '/gists',
            headers: headers
          }).success(function (gists, status, headers, config) {
            console.log;
            gists = _.map(gists, function (gist) {
              return new Gist(gist.id, gist.description, gist['public'], gist.files, gist.html_url);
            });
            return done(null, gists, status, headers, config);
          }).error(function (response, status, headers, config) {
            return done(new Error(response.message), response, status, headers, config);
          });
        }
      };
    }
  ]);
}.call(this));
(function () {
  var module;
  module = angular.module('app');
  module.service('GitHubAuthManager', [
    '$http',
    '$location',
    '$window',
    'cookie',
    'GitHub',
    function ($http, $location, $window, cookie, github) {
      return this.handleLoginCallback = function (done) {
        var GATEKEEPER_DOMAIN, GITHUB_LOGIN_COOKIE_NAME, GITHUB_TOKEN_COOKIE_NAME, code, match;
        GATEKEEPER_DOMAIN = '' + $location.protocol() + '://' + $location.host() + ':' + $location.port();
        GITHUB_TOKEN_COOKIE_NAME = 'github-token';
        GITHUB_LOGIN_COOKIE_NAME = 'github-login';
        match = $window.location.href.match(/\?code=([a-z0-9]*)/);
        if (match) {
          $location.search({});
          code = match[1];
          return $http.get('' + GATEKEEPER_DOMAIN + '/authenticate/' + code).success(function (data, status, headers, config) {
            var token;
            token = data.token;
            cookie.setItem(GITHUB_TOKEN_COOKIE_NAME, token);
            return github.getUser(token, function (error, user) {
              if (!error) {
                cookie.setItem(GITHUB_LOGIN_COOKIE_NAME, user.login);
                return done(null, token);
              } else {
                return done(new Error('Unable to retrieve your user information.'));
              }
            });
          }).error(function (data, status, headers, config) {
            return done(new Error('Unable to retrieve your authentication token.'));
          });
        } else if ($window.location.href.match(/\?error=access_denied/)) {
          return $location.search({});
        }
      };
    }
  ]);
}.call(this));
(function () {
  var module;
  module = angular.module('async', []);
  module.factory('async', [
    '$window',
    function ($window) {
      return $window.async;
    }
  ]);
}.call(this));
(function () {
  angular.module('app').factory('cookie', [function () {
      return {
        getItem: function (name) {
          var escapedName;
          escapedName = escape(name).replace(/[\-\.\+\*]/g, '\\$&');
          return unescape(document.cookie.replace(new RegExp('(?:(?:^|.*;)\\s*' + escapedName + '\\s*\\=\\s*([^;]*).*$)|^.*$'), '$1')) || null;
        },
        setItem: function (name, value, end, path, domain, secure) {
          var cookie, expires;
          if (!name || /^(?:expires|max\-age|path|domain|secure)$/i.test(name)) {
            throw new Error('Illegal name');
          }
          if (end) {
            switch (end.constructor) {
            case Number:
              expires = end === Infinity ? '; expires=Fri, 31 Dec 9999 23:59:59 GMT' : '; max-age=' + end;
              break;
            case String:
              expires = '; expires=' + end;
              break;
            case Date:
              expires = '; expires=' + end.toGMTString();
              break;
            default:
              expires = '';
            }
          } else {
            expires = '';
          }
          domain = domain ? '; domain=' + domain : '';
          path = path ? '; path=' + path : '';
          secure = secure ? '; secure' : '';
          cookie = '' + escape(name) + '=' + escape(value) + expires + domain + path + secure;
          document.cookie = cookie;
        },
        removeItem: function (name, path) {
          if (!name || !this.hasItem(name)) {
            return false;
          }
          return this.setItem(name, '', new Date(0), path);
        },
        hasItem: function (name) {
          return new RegExp('(?:^|;\\s*)' + escape(name).replace(/[\-\.\+\*]/g, '\\$&') + '\\s*\\=').test(document.cookie);
        }
      };
    }]);
}.call(this));
(function () {
  var locale_data_multi;
  locale_data_multi = {
    'messages_3': {
      '': {
        domain: 'messages_3',
        lang: 'en',
        'plural-forms': 'nplurals=2; plural=(n != 1);'
      },
      'test': [
        null,
        'test_1'
      ],
      'test singular': [
        'test plural',
        'test_1 singular',
        'test_1 plural'
      ],
      'context\x04test': [
        null,
        'test_1 context'
      ],
      'context\x04test singular': [
        'test context plural',
        'test_1 context singular',
        'test_1 context plural'
      ]
    },
    'messages_4': {
      '': {
        domain: 'messages_4',
        lang: 'en',
        'plural-forms': 'nplurals=2; plural=(n != 1);'
      },
      'test': [
        null,
        'test_2'
      ],
      'test singular': [
        'test plural',
        'test_2 singular',
        'test_2 plural'
      ],
      'context\x04test': [
        null,
        'test_2 context'
      ],
      'context\x04test singular': [
        'test context plural',
        'test_2 context singular',
        'test_2 context plural'
      ]
    }
  };
  angular.module('jed', []).factory('i18n', [
    '$window',
    function (w) {
      return new w.Jed({
        domain: 'the_domain',
        missing_key_callback: function (key) {
          return console.log(key);
        },
        locale_data: {
          'the_domain': {
            '': {
              domain: 'the_domain',
              lang: 'en',
              'plural-forms': 'nplurals=2; plural=(n != 1);'
            },
            'Create a New Gist': [
              null,
              'Create a New Gist'
            ],
            'Create gist': [
              null,
              'Create gist'
            ],
            'Gist': [
              null,
              'Gist',
              'Gists'
            ],
            'Gist name': [
              null,
              'Gist name'
            ],
            'My Gist': [
              null,
              'My Gist',
              'My Gists'
            ],
            'Great gist names are short and memorable.': [
              null,
              'Great gist names are short and memorable.'
            ],
            'Initialize this gist with a README.md': [
              null,
              'Initialize this gist with a README.md'
            ],
            'This will allow you to clone the gist immediately in GitHub.': [
              null,
              'This will allow you to clone the gist immediately in GitHub.'
            ],
            'Create a New Repo': [
              null,
              'Create a New Repository'
            ],
            'Create repo': [
              null,
              'Create repository'
            ],
            'Repo': [
              null,
              'Repository',
              'Repositories'
            ],
            'Repo name': [
              null,
              'Repository name'
            ],
            'My Repo': [
              null,
              'My Repository',
              'My Repository'
            ],
            'Great repo names are short and memorable.': [
              null,
              'Great repository names are short and memorable.'
            ],
            'Initialize this repo with a README.md': [
              null,
              'Initialize this repository with a README.md'
            ],
            'This will allow you to clone the repo immediately in GitHub.': [
              null,
              'This will allow you to clone the repository immediately in GitHub.'
            ],
            'Create a New File': [
              null,
              'Create a New File'
            ],
            'Create file': [
              null,
              'Create file'
            ],
            'File': [
              null,
              'File',
              'Files'
            ],
            'File name': [
              null,
              'File name'
            ],
            'Name your file': [
              null,
              'Name your file'
            ],
            'My Space': [
              null,
              'My Universe'
            ],
            'icon-gist': [
              null,
              'icon-briefcase'
            ],
            'icon-repo': [
              null,
              'icon-briefcase'
            ],
            'icon-dir': [
              null,
              'icon-book'
            ],
            'icon-file': [
              null,
              'icon-file-alt'
            ],
            'icon-question': [
              null,
              'icon-question'
            ]
          }
        }
      });
    }
  ]);
}.call(this));
(function () {
  angular.module('jquery', []).factory('$', [
    '$window',
    function ($window) {
      return $window.$;
    }
  ]);
}.call(this));
(function () {
  angular.module('underscore', []).factory('_', [
    '$window',
    function ($window) {
      return $window._;
    }
  ]);
}.call(this));
angular.module('app').run([
  '$templateCache',
  function ($templateCache) {
    $templateCache.put('angular/a-home.html', '<a href="/">\n' + '  <i class="icon-home"></i>\n' + '  <span>Home</span>\n' + '</a>\n');
    $templateCache.put('angular/embed.html', '<div id="embed-view">\n' + '  <div class="subnavbar" id="embed-subnavbar">\n' + '    <div class="subnavbar-inner">\n' + '      <div class="container">\n' + '        <a class="btn-subnavbar collapsed" data-toggle="collapse" data-target=".subnav-collapse">\n' + '          <i class="icon-reorder"></i>\n' + '        </a>\n' + '        <div class="subnav-collapse collapse">\n' + '          <ul class="mainnav">\n' + '            <!--\n' + '            <li ng-show="isLoggedIn()" class="{{userBreadcrumbClass()}}">\n' + '              <a ng-href="/users/{{user.name}}">\n' + '                <i class="icon-user"></i>\n' + '                <span>{{i18n.translate("My Space").fetch()}}</span>\n' + '              </a>\n' + '            </li>\n' + '            -->\n' + '            <!--\n' + '            <li class="active">\n' + '              <a ng-click="reload()" href="#">\n' + '                <i class="icon-edit"></i>\n' + '                <span>Workbench</span>\n' + '              </a>\n' + '            </li>\n' + '            -->\n' + '            <!--\n' + '            <li ng-show="saveEnabled()">\n' + '              <a ng-click="saveFile()" href="#">\n' + '                <i class="icon-save"></i>\n' + '                <span>Save</span>\n' + '              </a>\n' + '            </li>\n' + '            -->\n' + '            <li ng-show="runEnabled()">\n' + '              <a ng-click="run()" href="#">\n' + '                <i class="icon-cogs"></i>\n' + '                <span>Run</span>\n' + '              </a>\n' + '            </li>\n' + '            <li class="dropdown">\n' + '              <a href="javascript:;" class="dropdown-toggle" data-toggle="dropdown">\n' + '                <i class="icon-book"></i>\n' + '                <span>Help</span>\n' + '                <b class="caret"></b>\n' + '              </a>\n' + '              <ul class="dropdown-menu">\n' + '                <li><a href="https://docs.python.org/3.4/" target="_blank">Python documentation</a></li>\n' + '                <li><a href="http://docs.scipy.org/doc/" target="_blank">Numpy documentation</a></li>\n' + '                <li><a href="http://threejs.org/docs/" target="_blank">three.js documentation</a></li>\n' + '                <li><a href="http://jsxgraph.uni-bayreuth.de/wp/documentation/" target="_blank">JSXGraph documentation</a></li>\n' + '              </ul>\n' + '            </li>\n' + '          </ul>\n' + '        </div>\n' + '      </div>\n' + '    </div>\n' + '  </div>\n' + '  <div class="embed-layout">\n' + '    <div class="pane ui-layout-center ui-layout-code">\n' + '      <div id="editor"></div>\n' + '    </div>\n' + '    <div class="pane ui-layout-east ui-layout-printer">\n' + '      <div class="alert alert-block alert-{{message.severity}}" ng-repeat="message in messages" ng-show="messages.length &gt; 0">\n' + '        <button type="button" class="close" data-dismiss="alert">&times;</button>\n' + '        <h4>{{message.name}}</h4>\n' + '        {{message.text}}\n' + '      </div>\n' + '      <div id="printer-container">\n' + '        <printer></printer>\n' + '      </div>\n' + '      <div id="graph-container">\n' + '        <div id="box" class="jxgbox" style="width:600px; height:600px;"></div>\n' + '      </div>\n' + '      <div id="canvas-container">\n' + '      </div>\n' + '    </div>\n' + '  </div>\n' + '</div>');
    $templateCache.put('angular/github-authorize.html', '<li>\n' + '  <!-- When logged out, present the user with an OAuth link-->\n' + '  <a ng-hide="isLoggedIn()" ng-href="https://github.com/login/oauth/authorize?client_id={{clientId()}}&amp;scope=repo,user,gist">\n' + '    <i class="icon-signin"></i>\n' + '    <span>Log In</span>\n' + '  </a>\n' + '\n' + '  <!-- TODO: When logged in, we would like to have a dropdown menu-->\n' + '  <a ng-show="isLoggedIn()" ng-click="logout()" href="#">\n' + '    <i class="icon-signout icon-white"></i>\n' + '    <span>{{userLogin()}}</span>\n' + '  </a>\n' + '</li>');
    $templateCache.put('angular/home.html', '<div id="home-view">\n' + '  <div class="subnavbar">\n' + '    <div class="subnavbar-inner">\n' + '      <div class="container">\n' + '        <a class="btn-subnavbar collapsed" data-toggle="collapse" data-target=".subnav-collapse">\n' + '          <i class="icon-reorder"></i>\n' + '        </a>\n' + '        <div class="subnav-collapse collapse">\n' + '          <ul class="mainnav">\n' + '            <li class="active">\n' + '              <a-home></a-home>\n' + '            </li>\n' + '            <li ng-show="isLoggedIn()">\n' + '              <a ng-href="/users/{{userLogin()}}">\n' + '                <i class="icon-user"></i>\n' + '                <span>{{i18n.translate("My Space").fetch()}}</span>\n' + '              </a>\n' + '            </li>\n' + '            <li class="dropdown">\n' + '              <a href="javascript:;" class="dropdown-toggle" data-toggle="dropdown">\n' + '                <i class="icon-eye-open"></i>\n' + '                <span>Learn</span>\n' + '                <b class="caret"></b>\n' + '              </a>\n' + '              <ul class="dropdown-menu">\n' + '                <li><a href="http://geometryzen.github.io/mission/" target="_blank">Our Mission</a></li>\n' + '                <li><a href="/users/geometryzen/repos/demos/tree/master">Browse Examples</a></li>\n' + '                <li><a href="http://geometryzen.github.io/start/" target="_blank">Getting Started</a></li>\n' + '              </ul>\n' + '            </li>\n' + '            <li class="dropdown">\n' + '              <a href="javascript:;" class="dropdown-toggle" data-toggle="dropdown">\n' + '                <i class="icon-external-link"></i>\n' + '                <span>Discuss</span>\n' + '                <b class="caret"></b>\n' + '              </a>\n' + '              <ul class="dropdown-menu">\n' + '                <li><a href="http://groups.google.com/group/geometryzen?src=email&amp;hl=en" target="_blank">Mailing List</a></li>\n' + '                <li><a href="http://webchat.freenode.net/?channels=geometryzen&amp;uio=d4" target="_blank">Web Chat</a></li>\n' + '                <li class="divider"></li>\n' + '                <li><a href="https://twitter.com/#!/geometryzen" target="_blank">Twitter</a></li>\n' + '                <li><a href="https://plus.google.com/u/0/s/Geometry%20Zen/communities" target="_blank">Google+</a></li>\n' + '                <li class="divider"></li>\n' + '                <li class="dropdown-submenu">\n' + '                  <a href="#">Source Code</a>\n' + '                  <ul class="dropdown-menu">\n' + '                    <li><a href="https://github.com/david-geo-holmes/geometry-zen" target="_blank">Application Repository</a></li>\n' + '                    <li><a href="https://github.com/geometryzen/geometryzen.github.io" target="_blank">Documentation Repository</a></li>\n' + '                  </ul>\n' + '                </li>\n' + '                <li class="divider"></li>\n' + '                <li><a href="https://github.com/geometryzen/geometryzen/issues" target="_blank">Issue Tracker</a></li>\n' + '              </ul>\n' + '            </li>\n' + '            <li>\n' + '              <a href="http://geometryzen.github.io/faq/" target="_blank" style="text-decoration: none">\n' + '                <i class="icon-question-sign"></i>\n' + '                <span>FAQ</span>\n' + '              </a>\n' + '            </li>\n' + '            <li>\n' + '              <a href="http://geometryzen.github.io/" target="_blank" style="text-decoration: none">\n' + '                <i class="icon-book"></i>\n' + '                <span>Pages</span>\n' + '              </a>\n' + '            </li>\n' + '          </ul>\n' + '        </div>\n' + '      </div>\n' + '    </div>\n' + '  </div>\n' + '\n' + '  <div class="container-fluid">\n' + '    <div class="row-fluid">\n' + '      <div class="span12">\n' + '        <div class="widget">\n' + '          <div class="widget-content">\n' + '            <div class="text-center">\n' + '              <h1>\n' + '                <large>Geometric Physics</large>\n' + '              </h1>\n' + '              <h1>\n' + '                <small><em>Educational Computational Physics, Modeling and Geometry</em></small>\n' + '              </h1>\n' + '              <br/>\n' + '              <p><em>Geometric Physics</em> is a free, online, open-source, and collaborative tool for <em>Educational Computational Physics, Modeling and Geometry</em> combining the <em>Python</em> programming language, <em>3D visualization</em> (WebGL), <em>Physical Units</em>, and <em>Geometric Algebra</em>, the <em>Unified Mathematical Language for Physics and Engineering in the 21st Century</em>.</p>\n' + '              <p></p>\n' + '              <br/>\n' + '            </div>\n' + '            <div class="text-center">\n' + '              <a href="/users/geometryzen/repos/demos/tree/master" class="btn btn-primary">\n' + '                <i class="icon-th"></i>\n' + '                <span>Browse Examples</span>\n' + '              </a>\n' + '              <a href="{{jumpHRef()}}" class="btn btn-secondary">\n' + '                <i class="{{jumpIcon()}}"></i>\n' + '                <span>{{jumpText()}}</span>\n' + '              </a>\n' + '            </div>\n' + '            <hr/>\n' + '            <div class="text-center">\n' + '\n' + '              <h3>Example: Visualizing Geometric Algebra with WebGL</h3>\n' + '              <iframe width="1000" height="760" src="http://www.geometryzen.org/embed/users/geometryzen/repos/demos/blob/master/GA/musing.py" frameborder="0">\n' + '              </iframe>\n' + '              <hr/>\n' + '              <div class="text-right">\n' + '                <blockquote>\n' + '                  <p class="muted">..for geometry, you know, is the gate of science, and the gate is so low and small that one can only enter it as a little child</p>\n' + '                  <small>William Kingdon Clifford</small>\n' + '                </blockquote>\n' + '              </div>\n' + '              <hr/>\n' + '\n' + '              <h3>Example: Introduction to Functions with Units (units, numpy, JSXGraph)</h3>\n' + '              <iframe width="1000" height="760" src="http://www.geometryzen.org/embed/users/geometryzen/repos/demos/blob/master/Modeling/functions/intro.py" frameborder="0">\n' + '              </iframe>\n' + '              <hr/>\n' + '              <div class="text-right">\n' + '                <blockquote>\n' + '                  <p class="muted">Science is what we understand well enough to explain to a computer.<br/>Art is everything else we do.</p>\n' + '                  <small>Donald Knuth</small>\n' + '                </blockquote>\n' + '              </div>\n' + '              <hr/>\n' + '\n' + '              <h3>Example: Introduction to Vectors (e2ga, MathJax, JSXGraph) Press Esc to quit</h3>\n' + '              <iframe width="1000" height="760" src="http://www.geometryzen.org/embed/users/geometryzen/repos/demos/blob/master/Modeling/vectors/intro.py" frameborder="0">\n' + '              </iframe>\n' + '              <hr/>\n' + '              <div class="text-right">\n' + '                <blockquote>\n' + '                  <p class="muted">The purpose of computing is insight, not numbers!</p>\n' + '                  <small>Richard Wesley Hamming</small>\n' + '                </blockquote>\n' + '              </div>\n' + '              <hr/>\n' + '\n' + '              <h3>Example: Simple Harmonic Motion using Euler (e3ga, numpy, JSXGraph)</h3>\n' + '              <iframe width="1000" height="760" src="http://www.geometryzen.org/embed/users/geometryzen/repos/demos/blob/master/Modeling/ode/euler.py" frameborder="0">\n' + '              </iframe>\n' + '              <hr/>\n' + '              <div class="text-right">\n' + '                <blockquote>\n' + '                  <p class="muted">What I cannot create, I do not understand.</p>\n' + '                  <small>Richard Phillips Feynmann</small>\n' + '                </blockquote>\n' + '              </div>\n' + '              <hr/>\n' + '\n' + '              <h3>Example: Damped Simple Harmonic Motion using RK4 (e3ga, units, numpy, JSXGraph)</h3>\n' + '              <iframe width="1000" height="760" src="http://www.geometryzen.org/embed/users/geometryzen/repos/demos/blob/master/Modeling/ode/runge-kutta-4-with-units.py" frameborder="0">\n' + '              </iframe>\n' + '              <hr/>\n' + '              <div class="text-right">\n' + '                <blockquote>\n' + '                  <p class="muted">There is no science in this world like physics. Nothing comes close to the precision with which physics enables you to understand the world around you.</p>\n' + '                  <small>Neil deGrasse Tyson</small>\n' + '                </blockquote>\n' + '              </div>\n' + '              <hr/>\n' + '\n' + '              <h3>Example: Charged Particle near a Wire (e3ga, three) Press Esc to quit</h3>\n' + '              <iframe width="1000" height="760" src="http://www.geometryzen.org/embed/users/geometryzen/repos/demos/blob/master/Physics/charged-particle-wire-2.py" frameborder="0">\n' + '              </iframe>\n' + '              <hr/>\n' + '              <div class="text-right">\n' + '                <blockquote>\n' + '                  <p class="muted">If I have not seen as far as others, it is because \n' + '     giants were standing on my shoulders.</p>\n' + '                  <small>Hal Abelson</small>\n' + '                </blockquote>\n' + '              </div>\n' + '              <hr/>\n' + '\n' + '              <h3>Example: Mouse Tracking for fun (d3py) Press Esc to quit</h3>\n' + '              <iframe width="1000" height="760" src="http://www.geometryzen.org/embed/users/geometryzen/repos/demos/blob/master/D3/basic.py" frameborder="0">\n' + '              </iframe>\n' + '            </div>\n' + '            <div class="text-center">\n' + '              <a href="/users/geometryzen/repos/demos/tree/master" class="btn btn-primary">\n' + '                <i class="icon-th"></i>\n' + '                <span>More Examples</span>\n' + '              </a>\n' + '              <a href="{{jumpHRef()}}" class="btn btn-secondary">\n' + '                <i class="{{jumpIcon()}}"></i>\n' + '                <span>{{jumpText()}}</span>\n' + '              </a>\n' + '            </div>\n' + '          </div>\n' + '        </div>\n' + '      </div>\n' + '    </div>\n' + '  </div>\n' + '</div>\n');
    $templateCache.put('angular/printer.html', '<div ng-controller="PrinterCtrl" class="container-fluid">\n' + '  <div class="row-fluid">\n' + '    <div class="span12">\n' + '      <!-- Using anything other than a pre(serve) element is likely too be slow -->\n' + '      <!-- PRESERVE_ELEMENT_ID is defined in the printer controller -->\n' + '      <pre id="a5f435e0-c92e-11e2-8b8b-0800200c9a66" class="printer"></pre>\n' + '    </div>\n' + '  </div>\n' + '</div>\n' + '\n');
    $templateCache.put('angular/tree.html', '<div id="repo-view">\n' + '\n' + '  <div class="subnavbar">\n' + '    <div class="subnavbar-inner">\n' + '      <div class="container">\n' + '        <a class="btn-subnavbar collapsed" data-toggle="collapse" data-target=".subnav-collapse">\n' + '          <i class="icon-reorder"></i>\n' + '        </a>\n' + '        <div class="subnav-collapse collapse">\n' + '          <ul class="mainnav">\n' + '            <li ng-show="isLoggedIn()" class="{{userBreadcrumbClass()}}">\n' + '              <a ng-href="/users/{{user.login}}">\n' + '                <i class="icon-user"></i>\n' + '                <span>{{i18n.translate("My Space").fetch()}}</span>\n' + '              </a>\n' + '            </li>\n' + '            <li class="{{repoBreadcrumbClass()}}">\n' + '              <a ng-click="bookView()" href="#">\n' + '                <i class="{{i18n.translate(\'icon-repo\').fetch()}}"></i>\n' + '                <span>{{i18n.translate("Repo").fetch()}}</span>\n' + '              </a>\n' + '            </li>\n' + '          </ul>\n' + '        </div>\n' + '      </div>\n' + '    </div>\n' + '  </div>\n' + '  \n' + '  <div id="work-layout" class="container-fluid">\n' + '    <div class="row-fluid">\n' + '      <div class="widget">\n' + '        <div class="widget-header">\n' + '          <i class="{{i18n.translate(\'icon-repo\').fetch()}}"></i>\n' + '          <h3>{{repo.name}}</h3>\n' + '        </div>\n' + '        <div class="widget-content">\n' + '          <div>\n' + '            <!--\n' + '            <i class="icon-user muted"></i>\n' + '            <span><a ng-href="/users/{{user.login}}">{{user.login}}</a></span>\n' + '            -->\n' + '            <!--\n' + '            <a ng-href="https://github.com/{{user.login}}" target="_blank" class="muted">\n' + '              <i class="icon-github"></i>\n' + '            </a>\n' + '            -->\n' + '            <span>{{repo.description}}</span>\n' + '          </div>\n' + '          <ul class="nav nav-tabs" id="myTab">\n' + '            <li>\n' + '              <a data-target="#items" data-toggle="tab">{{i18n.translate(\'File\').ifPlural(2, \'Files\').fetch()}}</a>\n' + '            </li>\n' + '            <!--li><a data-target="#commits" data-toggle="tab">Commits</a></li-->\n' + '            <!--li><a data-target="#branches" data-toggle="tab">Branches</a></li-->\n' + '          </ul>\n' + '          <div class="tab-content">\n' + '            <div class="tab-pane" id="items">\n' + '              <div class ="row-fluid">\n' + '                <table class="table table-condensed">\n' + '                  <tbody>\n' + '                    <tr ng-show="isNewFileEnabled()">\n' + '                      <td nowrap=nowrap>\n' + '                        <!--input type="text" placeHolder="Filter..."></input-->\n' + '                      </td>\n' + '                      <td nowrap=nowrap>\n' + '                        <button ng-click="newFile()" ng-show="isNewFileEnabled()" class="btn btn-primary">\n' + '                          <i class="icon-plus-sign-alt"></i> <i class="{{i18n.translate(\'icon-file\').fetch()}}"></i>\n' + '                          <span>{{i18n.translate("Create a New File").fetch()}}</span>\n' + '                        </button>\n' + '                      </td>\n' + '                    </tr>\n' + '                    <!-- Reminder: An item is a book or a page -->\n' + '                    <tr ng-repeat="item in contextItem.childItems">\n' + '                      <td nowrap=nowrap>\n' + '                        <h3>\n' + '                          <i class="{{i18n.translate(iconFromItem(item)).fetch()}} muted"></i>\n' + '                          <a href="{{hrefFromItem(item)}}" class="btn btn-link">\n' + '                            <span>{{item.name}}</span>\n' + '                          </a>\n' + '                        </h3>\n' + '                      </td>\n' + '                      <td nowrap=nowrap>\n' + '                        <a href="{{item.html_url}}" target="_blank" class="btn btn-secondary">\n' + '                          <i class="icon-github"></i>\n' + '                          <span>GitHub</span>\n' + '                        </a>\n' + '                      </td>\n' + '                    </tr>\n' + '                  </tbody>\n' + '                </table>\n' + '              </div>\n' + '            </div>\n' + '            <div class="tab-pane" id="commits">\n' + '              <p>Under Construction: Commits</p>\n' + '            </div>\n' + '            <div class="tab-pane" id="branches">\n' + '              <p>Under Construction: Branches</p>\n' + '            </div>\n' + '          </div>\n' + '          <script>\n' + '            $(function () {\n' + '              $(\'#myTab a[data-target="#items"]\').tab(\'show\');\n' + '            })\n' + '          </script>\n' + '          <script>\n' + '            $(\'#myTab a[data-target="#items"]\').click(function(e) {\n' + '              e.preventDefault();\n' + '              $(this).tab(\'show\');\n' + '            });\n' + '          </script>\n' + '          <script>\n' + '            $(\'#myTab a[data-target="#commits"]\').click(function(e) {\n' + '              e.preventDefault();\n' + '              $(this).tab(\'show\');\n' + '            });\n' + '          </script>\n' + '          <script>\n' + '            $(\'#myTab a[data-target="#branches"]\').click(function(e) {\n' + '              e.preventDefault();\n' + '              $(this).tab(\'show\');\n' + '            });\n' + '          </script>\n' + '        </div> <!-- div.widget-content -->\n' + '      </div> <!-- div.widget -->\n' + '    </div> <!-- div.row-fluid -->\n' + '  </div> <!-- div.container-fluid -->\n' + '  <div id="new-file-dialog" class="modal hide fade" tabindex="-1" role="dialog" aria-labelledby="new-file-dialog-label" aria-hidden="true">\n' + '    <div class="modal-header">\n' + '      <button type="button" class="close" data-dismiss="modal" aria-hidden="true">&times;</button>\n' + '      <h3 id="new-file-dialog-label"><i class="icon-plus-sign-alt muted"></i> <i class="{{i18n.translate(\'icon-file\').fetch()}} muted"></i> {{i18n.translate("Create a New File").fetch()}}</h3>\n' + '    </div>\n' + '    <form ng-controller="NewFileCtrl">\n' + '      <fieldset>\n' + '        <div class="modal-body">\n' + '          <label>{{i18n.translate(\'File name\').fetch()}}:</label>\n' + '          <label class="control-label muted" for="id-file-name">{{path}}/</label>\n' + '          <input type="text" id="id-file-name" name="name" ng-model="file.name" placeholder="{{i18n.translate(\'Name your file\').fetch()}}...">\n' + '          </input>\n' + '          <span class="help-block">You may use forward slashes to create new folders. e.g., folder1/folder2/filename.py</span>\n' + '          <label>Commit message:</label>\n' + '          <input type="text" name="message" ng-model="file.message" placeholder="{{i18n.translate(\'Create file\').fetch()}}">\n' + '          </input>\n' + '        </div>\n' + '        <div class="modal-footer">\n' + '          <button id="btnCancel" class="btn" data-dismiss="modal" aria-hidden="true">Close</button>\n' + '          <button type="submit" ng-click="createFile()" id="btnOK" class="btn btn-primary">\n' + '            {{i18n.translate("Create file").fetch()}}\n' + '          </button>\n' + '        </div>\n' + '      </fieldset>\n' + '    </form>\n' + '  </div>\n' + '</div>\n');
    $templateCache.put('angular/user.html', '<div id="user-view">\n' + '  <div class="subnavbar">\n' + '    <div class="subnavbar-inner">\n' + '      <div class="container">\n' + '        <a class="btn-subnavbar collapsed" data-toggle="collapse" data-target=".subnav-collapse">\n' + '          <i class="icon-reorder"></i>\n' + '        </a>\n' + '        <div class="subnav-collapse collapse">\n' + '          <ul class="mainnav">\n' + '            <li class="{{userBreadcrumbClass()}}">\n' + '              <a ng-href="/users/{{user.login}}">\n' + '                <i class="icon-user"></i>\n' + '                <span>{{i18n.translate("My Space").fetch()}}</span>\n' + '              </a>\n' + '            </li>\n' + '            <li>\n' + '              <a ng-href="/workbench" href="#">\n' + '                <i class="icon-edit"></i>\n' + '                <span>Workbench</span>\n' + '              </a>\n' + '            </li>\n' + '          </ul>\n' + '        </div> <!-- /.subnav-collapse -->\n' + '      </div> <!-- /container -->\n' + '    </div> <!-- /subnavbar-inner -->\n' + '  </div> <!-- /subnavbar -->\n' + '\n' + '  <div class="container-fluid">\n' + '    <div class="row-fluid">\n' + '      <div class="span4">\n' + '        <div class="widget">\n' + '          <div class="widget-header">\n' + '              <i class="icon-user"></i>\n' + '              <h3>Profile</h3>\n' + '          </div>\n' + '          <div class="widget-content">\n' + '            <h3>\n' + '              <span>{{user.name}}</span>\n' + '            </h3>\n' + '            <h4>\n' + '              <span>{{user.login}}</span>\n' + '            </h4>\n' + '            <!-- HATEOAS GitHub link? -->\n' + '            <!--\n' + '            <a href="https://github.com/{{user.login}}?tab=repositories" target="_blank" class="btn btn-secondary">\n' + '              <i class="icon-github"></i>\n' + '              <span>GitHub</span>\n' + '            </a>\n' + '            -->\n' + '          </div>\n' + '        </div>\n' + '      </div>\n' + '      <div class="span8">\n' + '        <div class="widget stacked">\n' + '          <div class="widget-content">\n' + '            <ul class="nav nav-tabs" id="myTab">\n' + '              <li>\n' + '                <a data-target="#repos" data-toggle="tab">{{i18n.translate("Repo").ifPlural(2, "Repos").fetch()}}</a>\n' + '              </li>\n' + '              <li>\n' + '                <a data-target="#gists" data-toggle="tab">{{i18n.translate("Gist").ifPlural(2, "Gists").fetch()}}</a>\n' + '              </li>\n' + '            </ul>\n' + '            <div class="tab-content">\n' + '              <div class="tab-pane" id="repos">\n' + '                <div class ="row-fluid">\n' + '                  <table class="table table-condensed">\n' + '                    <tbody>\n' + '                      <tr>\n' + '                        <td nowrap=nowrap>\n' + '                          <!--input type="text" placeHolder="Filter..."></input-->\n' + '                        </td>\n' + '                        <td nowrap=nowrap>\n' + '                          <button ng-click="newRepo(user.login)" class="btn btn-primary">\n' + '                            <i class="icon-plus-sign-alt"></i> <i class="{{i18n.translate(\'icon-repo\').fetch()}}"></i>\n' + '                            <span>{{i18n.translate("Create a New Repo").fetch()}}</span>\n' + '                          </button>\n' + '                        </td>\n' + '                      </tr>\n' + '                      <tr ng-repeat="repo in repos">\n' + '                        <td nowrap=nowrap>\n' + '                          <h3>\n' + '                            <i class="{{i18n.translate(\'icon-repo\').fetch()}} muted"></i>\n' + '                            <a href="/users/{{user.login}}/repos/{{repo.name}}/tree/master" class="btn btn-link">\n' + '                              <span>{{repo.name}}</span>\n' + '                            </a>\n' + '                          </h3>\n' + '                          <p>{{repo.description}}</p>\n' + '                        </td>\n' + '                        <td nowrap=nowrap>\n' + '                          <a href="{{repo.html_url}}" target="_blank" class="btn btn-secondary">\n' + '                            <i class="icon-github"></i>\n' + '                            <span>GitHub</span>\n' + '                          </a>\n' + '                          <!--\n' + '                          <button ng-click="deleteRepo(user.login, repo.name)" class="btn btn-tertiary">\n' + '                            <i class="icon-minus-sign-alt"></i>\n' + '                            <span>Delete</span>\n' + '                          </button>\n' + '                          -->\n' + '                        </td>\n' + '                      </tr>\n' + '                    </tbody>\n' + '                  </table>\n' + '                </div>\n' + '              </div>\n' + '              <div class="tab-pane" id="gists">\n' + '                <div class ="row-fluid">\n' + '                  <table class="table table-condensed">\n' + '                    <tbody>\n' + '                      <tr>\n' + '                        <td nowrap=nowrap>\n' + '                          <!--input type="text" placeHolder="Filter..."></input-->\n' + '                        </td>\n' + '                        <td nowrap=nowrap>\n' + '                          <button ng-click="newGist()" class="btn btn-primary">\n' + '                            <i class="icon-plus-sign-alt"></i> <i class="{{i18n.translate(\'icon-gist\').fetch()}}"></i>\n' + '                            <span>{{i18n.translate("Create a New Gist").fetch()}}</span>\n' + '                          </button>\n' + '                        </td>\n' + '                      </tr>\n' + '                      <tr ng-repeat="gist in gists">\n' + '                        <td nowrap=nowrap>\n' + '                          <h3>\n' + '                            <i class="{{i18n.translate(\'icon-gist\').fetch()}} muted"></i>\n' + '                            <a href="/gists/{{gist.id}}" class="btn btn-link">\n' + '                              <span>{{gist.id}}</span>\n' + '                            </a>\n' + '                          </h3>\n' + '                          <p>{{gist.description}}</p>\n' + '                        </td>\n' + '                        <td nowrap=nowrap>\n' + '                          <a href="{{gist.html_url}}" target="_blank" class="btn btn-secondary">\n' + '                            <i class="icon-github"></i>\n' + '                            <span>GitHub</span>\n' + '                          </a>\n' + '                          <!--\n' + '                          <button ng-click="deleteGist(user.login, gist.id)" class="btn btn-tertiary">\n' + '                            <i class="icon-minus-sign-alt"></i>\n' + '                            <span>Delete</span>\n' + '                          </button>\n' + '                          -->\n' + '                        </td>\n' + '                      </tr>\n' + '                    </tbody>\n' + '                  </table>\n' + '                </div>\n' + '              </div>\n' + '            </div>\n' + '            <script>\n' + '              $(function () {\n' + '                $(\'#myTab a[data-target="#repos"]\').tab(\'show\');\n' + '              })\n' + '            </script>\n' + '            <script>\n' + '              $(\'#myTab a[data-target="#gists"]\').click(function(e) {\n' + '                e.preventDefault();\n' + '                $(this).tab(\'show\');\n' + '              });\n' + '            </script>\n' + '            <script>\n' + '              $(\'#myTab a[data-target="#repos"]\').click(function(e) {\n' + '                e.preventDefault();\n' + '                $(this).tab(\'show\');\n' + '              });\n' + '            </script>\n' + '          </div>\n' + '        </div>\n' + '\n' + '        <div id="new-gist-dialog" class="modal hide fade" tabindex="-1" role="dialog" aria-labelledby="new-gist-dialog-label" aria-hidden="true">\n' + '          <div class="modal-header">\n' + '            <button type="button" class="close" data-dismiss="modal" aria-hidden="true">&times;</button>\n' + '            <h3 id="new-gist-dialog-label"><i class="icon-plus-sign-alt muted"></i> <i class="{{i18n.translate(\'icon-gist\').fetch()}} muted"></i> {{i18n.translate("Create a New Gist").fetch()}}</h3>\n' + '          </div>\n' + '          <form ng-controller="NewGistCtrl">\n' + '            <fieldset>\n' + '              <div class="modal-body">\n' + '                <label>Description<span class="muted"> (optional)</span></label>\n' + '                <input type="text" name="description" ng-model="gist.description"></input>\n' + '              </div>\n' + '              <div class="modal-footer">\n' + '                <button id="btnCancel" class="btn" data-dismiss="modal" aria-hidden="true">Close</button>\n' + '                <button type="submit" ng-click="createGist()" id="btnOK" class="btn btn-primary">{{i18n.translate("Create gist").fetch()}}</button>\n' + '              </div>\n' + '            </fieldset>\n' + '          </form>\n' + '        </div>\n' + '\n' + '        <div id="new-repo-dialog" class="modal hide fade" tabindex="-1" role="dialog" aria-labelledby="new-repo-dialog-label" aria-hidden="true">\n' + '          <div class="modal-header">\n' + '            <button type="button" class="close" data-dismiss="modal" aria-hidden="true">&times;</button>\n' + '            <h3 id="new-repo-dialog-label"><i class="icon-plus-sign-alt muted"></i> <i class="{{i18n.translate(\'icon-repo\').fetch()}} muted"></i> {{i18n.translate("Create a New Repo").fetch()}}</h3>\n' + '          </div>\n' + '          <form ng-controller="NewRepoCtrl">\n' + '            <fieldset>\n' + '              <div class="modal-body">\n' + '                <label>{{i18n.translate("Repo name").fetch()}}</label>\n' + '                <input type="text" name="repo" ng-model="repo.name"></input>\n' + '                <span class="help-block">{{i18n.translate("Great repo names are short and memorable.").fetch()}}</span>\n' + '                <label>Description<span class="muted"> (optional)</span></label>\n' + '                <input type="text" name="description" ng-model="repo.description"></input>\n' + '                <!--\n' + '                <hr/>\n' + '                <input type="radio" ng-model="repo.private" value="false"> <i class="{{i18n.translate(\'icon-repo\').fetch()}} muted"></i> Public<br/>\n' + '                <span class="help-block">Anyone can see this repository. You choose who can commit.</span>\n' + '                <input type="radio" ng-model="repo.private" value="true"> Private <br/>\n' + '                <span class="help-block">You choose who can see and commit to this repository.</span>\n' + '                -->\n' + '                <hr/>\n' + '                <label class="checkbox">\n' + '                  <input type="checkbox" name="markdown-readme" ng-model="repo.markdownReadme"> {{i18n.translate("Initialize this repo with a README.md").fetch()}}</input>\n' + '                </label>\n' + '                <span class="help-block">{{i18n.translate("This will allow you to clone the repo immediately in GitHub.").fetch()}}</span>\n' + '                <!--\n' + '                <label class="checkbox">\n' + '                  <input type="checkbox" name="python-readme" ng-model="repo.pythonReadme"> Initialize this book with a README.py</input>\n' + '                </label>\n' + '                <span class="help-block">Having at least one Python file will ensure that the GitHub repository is visible to Geometric Physics.</span>\n' + '                -->\n' + '              </div>\n' + '              <div class="modal-footer">\n' + '                <button id="btnCancel" class="btn" data-dismiss="modal" aria-hidden="true">Close</button>\n' + '                <button type="submit" ng-click="createRepo()" id="btnOK" class="btn btn-primary">{{i18n.translate("Create repo").fetch()}}</button>\n' + '              </div>\n' + '            </fieldset>\n' + '          </form>\n' + '        </div>\n' + '\n' + '      </div>\n' + '    </div>\n' + '  </div>\n' + '</div>');
    $templateCache.put('angular/work.html', '<div id="work-view">\n' + '  <div class="subnavbar" id="work-subnavbar">\n' + '    <div class="subnavbar-inner">\n' + '      <div class="container">\n' + '        <a class="btn-subnavbar collapsed" data-toggle="collapse" data-target=".subnav-collapse">\n' + '          <i class="icon-reorder"></i>\n' + '        </a>\n' + '        <div class="subnav-collapse collapse">\n' + '          <ul class="mainnav">\n' + '            <li ng-show="isLoggedIn()" class="{{userBreadcrumbClass()}}">\n' + '              <a ng-href="/users/{{user.name}}">\n' + '                <i class="icon-user"></i>\n' + '                <span>{{i18n.translate("My Space").fetch()}}</span>\n' + '              </a>\n' + '            </li>\n' + '            <li class="active">\n' + '              <a ng-click="reload()" href="#">\n' + '                <i class="icon-edit"></i>\n' + '                <span>Workbench</span>\n' + '              </a>\n' + '            </li>\n' + '            <li ng-show="saveEnabled()">\n' + '              <a ng-click="saveFile()" href="#">\n' + '                <i class="icon-save"></i>\n' + '                <span>Save</span>\n' + '              </a>\n' + '            </li>\n' + '            <li ng-show="runEnabled()">\n' + '              <a ng-click="run()" href="#">\n' + '                <i class="icon-cogs"></i>\n' + '                <span>Run</span>\n' + '              </a>\n' + '            </li>\n' + '            <li class="dropdown">\n' + '              <a href="javascript:;" class="dropdown-toggle" data-toggle="dropdown">\n' + '                <i class="icon-book"></i>\n' + '                <span>Help</span>\n' + '                <b class="caret"></b>\n' + '              </a>\n' + '              <ul class="dropdown-menu">\n' + '                <li><a href="https://docs.python.org/3.4/" target="_blank">Python documentation</a></li>\n' + '                <li><a href="http://docs.scipy.org/doc/" target="_blank">Numpy documentation</a></li>\n' + '                <li><a href="http://threejs.org/docs/" target="_blank">three.js documentation</a></li>\n' + '                <li><a href="http://jsxgraph.uni-bayreuth.de/wp/documentation/" target="_blank">JSXGraph documentation</a></li>\n' + '              </ul>\n' + '            </li>\n' + '          </ul>\n' + '        </div>\n' + '      </div>\n' + '    </div>\n' + '  </div>\n' + '  <div class="work-layout">\n' + '    <div class="pane ui-layout-center ui-layout-code">\n' + '      <div id="editor"></div>\n' + '    </div>\n' + '    <div class="pane ui-layout-east ui-layout-printer">\n' + '      <div class="alert alert-block alert-{{message.severity}}" ng-repeat="message in messages" ng-show="messages.length &gt; 0">\n' + '        <button type="button" class="close" data-dismiss="alert">&times;</button>\n' + '        <h4>{{message.name}}</h4>\n' + '        {{message.text}}\n' + '      </div>\n' + '      <div id="printer-container">\n' + '        <printer></printer>\n' + '      </div>\n' + '      <div id="graph-container">\n' + '        <div id="box" class="jxgbox" style="width:600px; height:600px;"></div>\n' + '      </div>\n' + '      <div id="canvas-container">\n' + '      </div>\n' + '    </div>\n' + '  </div>\n' + '</div>');
  }
]);