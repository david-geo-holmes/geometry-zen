(function () {
  var async = {};
  var root, previous_async;
  root = this;
  if (root != null) {
    previous_async = root.async;
  }
  async.noConflict = function () {
    root.async = previous_async;
    return async;
  };
  function only_once(fn) {
    var called = false;
    return function () {
      if (called)
        throw new Error('Callback was already called.');
      called = true;
      fn.apply(root, arguments);
    };
  }
  var _each = function (arr, iterator) {
    if (arr.forEach) {
      return arr.forEach(iterator);
    }
    for (var i = 0; i < arr.length; i += 1) {
      iterator(arr[i], i, arr);
    }
  };
  var _map = function (arr, iterator) {
    if (arr.map) {
      return arr.map(iterator);
    }
    var results = [];
    _each(arr, function (x, i, a) {
      results.push(iterator(x, i, a));
    });
    return results;
  };
  var _reduce = function (arr, iterator, memo) {
    if (arr.reduce) {
      return arr.reduce(iterator, memo);
    }
    _each(arr, function (x, i, a) {
      memo = iterator(memo, x, i, a);
    });
    return memo;
  };
  var _keys = function (obj) {
    if (Object.keys) {
      return Object.keys(obj);
    }
    var keys = [];
    for (var k in obj) {
      if (obj.hasOwnProperty(k)) {
        keys.push(k);
      }
    }
    return keys;
  };
  if (typeof process === 'undefined' || !process.nextTick) {
    if (typeof setImmediate === 'function') {
      async.nextTick = function (fn) {
        setImmediate(fn);
      };
    } else {
      async.nextTick = function (fn) {
        setTimeout(fn, 0);
      };
    }
  } else {
    async.nextTick = process.nextTick;
  }
  async.each = function (arr, iterator, callback) {
    callback = callback || function () {
    };
    if (!arr.length) {
      return callback();
    }
    var completed = 0;
    _each(arr, function (x) {
      iterator(x, only_once(function (err) {
        if (err) {
          callback(err);
          callback = function () {
          };
        } else {
          completed += 1;
          if (completed >= arr.length) {
            callback(null);
          }
        }
      }));
    });
  };
  async.forEach = async.each;
  async.eachSeries = function (arr, iterator, callback) {
    callback = callback || function () {
    };
    if (!arr.length) {
      return callback();
    }
    var completed = 0;
    var iterate = function () {
      var sync = true;
      iterator(arr[completed], function (err) {
        if (err) {
          callback(err);
          callback = function () {
          };
        } else {
          completed += 1;
          if (completed >= arr.length) {
            callback(null);
          } else {
            if (sync) {
              async.nextTick(iterate);
            } else {
              iterate();
            }
          }
        }
      });
      sync = false;
    };
    iterate();
  };
  async.forEachSeries = async.eachSeries;
  async.eachLimit = function (arr, limit, iterator, callback) {
    var fn = _eachLimit(limit);
    fn.apply(null, [
      arr,
      iterator,
      callback
    ]);
  };
  async.forEachLimit = async.eachLimit;
  var _eachLimit = function (limit) {
    return function (arr, iterator, callback) {
      callback = callback || function () {
      };
      if (!arr.length || limit <= 0) {
        return callback();
      }
      var completed = 0;
      var started = 0;
      var running = 0;
      (function replenish() {
        if (completed >= arr.length) {
          return callback();
        }
        while (running < limit && started < arr.length) {
          started += 1;
          running += 1;
          iterator(arr[started - 1], function (err) {
            if (err) {
              callback(err);
              callback = function () {
              };
            } else {
              completed += 1;
              running -= 1;
              if (completed >= arr.length) {
                callback();
              } else {
                replenish();
              }
            }
          });
        }
      }());
    };
  };
  var doParallel = function (fn) {
    return function () {
      var args = Array.prototype.slice.call(arguments);
      return fn.apply(null, [async.each].concat(args));
    };
  };
  var doParallelLimit = function (limit, fn) {
    return function () {
      var args = Array.prototype.slice.call(arguments);
      return fn.apply(null, [_eachLimit(limit)].concat(args));
    };
  };
  var doSeries = function (fn) {
    return function () {
      var args = Array.prototype.slice.call(arguments);
      return fn.apply(null, [async.eachSeries].concat(args));
    };
  };
  var _asyncMap = function (eachfn, arr, iterator, callback) {
    var results = [];
    arr = _map(arr, function (x, i) {
      return {
        index: i,
        value: x
      };
    });
    eachfn(arr, function (x, callback) {
      iterator(x.value, function (err, v) {
        results[x.index] = v;
        callback(err);
      });
    }, function (err) {
      callback(err, results);
    });
  };
  async.map = doParallel(_asyncMap);
  async.mapSeries = doSeries(_asyncMap);
  async.mapLimit = function (arr, limit, iterator, callback) {
    return _mapLimit(limit)(arr, iterator, callback);
  };
  var _mapLimit = function (limit) {
    return doParallelLimit(limit, _asyncMap);
  };
  async.reduce = function (arr, memo, iterator, callback) {
    async.eachSeries(arr, function (x, callback) {
      iterator(memo, x, function (err, v) {
        memo = v;
        callback(err);
      });
    }, function (err) {
      callback(err, memo);
    });
  };
  async.inject = async.reduce;
  async.foldl = async.reduce;
  async.reduceRight = function (arr, memo, iterator, callback) {
    var reversed = _map(arr, function (x) {
        return x;
      }).reverse();
    async.reduce(reversed, memo, iterator, callback);
  };
  async.foldr = async.reduceRight;
  var _filter = function (eachfn, arr, iterator, callback) {
    var results = [];
    arr = _map(arr, function (x, i) {
      return {
        index: i,
        value: x
      };
    });
    eachfn(arr, function (x, callback) {
      iterator(x.value, function (v) {
        if (v) {
          results.push(x);
        }
        callback();
      });
    }, function (err) {
      callback(_map(results.sort(function (a, b) {
        return a.index - b.index;
      }), function (x) {
        return x.value;
      }));
    });
  };
  async.filter = doParallel(_filter);
  async.filterSeries = doSeries(_filter);
  async.select = async.filter;
  async.selectSeries = async.filterSeries;
  var _reject = function (eachfn, arr, iterator, callback) {
    var results = [];
    arr = _map(arr, function (x, i) {
      return {
        index: i,
        value: x
      };
    });
    eachfn(arr, function (x, callback) {
      iterator(x.value, function (v) {
        if (!v) {
          results.push(x);
        }
        callback();
      });
    }, function (err) {
      callback(_map(results.sort(function (a, b) {
        return a.index - b.index;
      }), function (x) {
        return x.value;
      }));
    });
  };
  async.reject = doParallel(_reject);
  async.rejectSeries = doSeries(_reject);
  var _detect = function (eachfn, arr, iterator, main_callback) {
    eachfn(arr, function (x, callback) {
      iterator(x, function (result) {
        if (result) {
          main_callback(x);
          main_callback = function () {
          };
        } else {
          callback();
        }
      });
    }, function (err) {
      main_callback();
    });
  };
  async.detect = doParallel(_detect);
  async.detectSeries = doSeries(_detect);
  async.some = function (arr, iterator, main_callback) {
    async.each(arr, function (x, callback) {
      iterator(x, function (v) {
        if (v) {
          main_callback(true);
          main_callback = function () {
          };
        }
        callback();
      });
    }, function (err) {
      main_callback(false);
    });
  };
  async.any = async.some;
  async.every = function (arr, iterator, main_callback) {
    async.each(arr, function (x, callback) {
      iterator(x, function (v) {
        if (!v) {
          main_callback(false);
          main_callback = function () {
          };
        }
        callback();
      });
    }, function (err) {
      main_callback(true);
    });
  };
  async.all = async.every;
  async.sortBy = function (arr, iterator, callback) {
    async.map(arr, function (x, callback) {
      iterator(x, function (err, criteria) {
        if (err) {
          callback(err);
        } else {
          callback(null, {
            value: x,
            criteria: criteria
          });
        }
      });
    }, function (err, results) {
      if (err) {
        return callback(err);
      } else {
        var fn = function (left, right) {
          var a = left.criteria, b = right.criteria;
          return a < b ? -1 : a > b ? 1 : 0;
        };
        callback(null, _map(results.sort(fn), function (x) {
          return x.value;
        }));
      }
    });
  };
  async.auto = function (tasks, callback) {
    callback = callback || function () {
    };
    var keys = _keys(tasks);
    if (!keys.length) {
      return callback(null);
    }
    var results = {};
    var listeners = [];
    var addListener = function (fn) {
      listeners.unshift(fn);
    };
    var removeListener = function (fn) {
      for (var i = 0; i < listeners.length; i += 1) {
        if (listeners[i] === fn) {
          listeners.splice(i, 1);
          return;
        }
      }
    };
    var taskComplete = function () {
      _each(listeners.slice(0), function (fn) {
        fn();
      });
    };
    addListener(function () {
      if (_keys(results).length === keys.length) {
        callback(null, results);
        callback = function () {
        };
      }
    });
    _each(keys, function (k) {
      var task = tasks[k] instanceof Function ? [tasks[k]] : tasks[k];
      var taskCallback = function (err) {
        if (err) {
          callback(err);
          callback = function () {
          };
        } else {
          var args = Array.prototype.slice.call(arguments, 1);
          if (args.length <= 1) {
            args = args[0];
          }
          results[k] = args;
          async.nextTick(taskComplete);
        }
      };
      var requires = task.slice(0, Math.abs(task.length - 1)) || [];
      var ready = function () {
        return _reduce(requires, function (a, x) {
          return a && results.hasOwnProperty(x);
        }, true) && !results.hasOwnProperty(k);
      };
      if (ready()) {
        task[task.length - 1](taskCallback, results);
      } else {
        var listener = function () {
          if (ready()) {
            removeListener(listener);
            task[task.length - 1](taskCallback, results);
          }
        };
        addListener(listener);
      }
    });
  };
  async.waterfall = function (tasks, callback) {
    callback = callback || function () {
    };
    if (!tasks.length) {
      return callback();
    }
    var wrapIterator = function (iterator) {
      return function (err) {
        if (err) {
          callback.apply(null, arguments);
          callback = function () {
          };
        } else {
          var args = Array.prototype.slice.call(arguments, 1);
          var next = iterator.next();
          if (next) {
            args.push(wrapIterator(next));
          } else {
            args.push(callback);
          }
          async.nextTick(function () {
            iterator.apply(null, args);
          });
        }
      };
    };
    wrapIterator(async.iterator(tasks))();
  };
  var _parallel = function (eachfn, tasks, callback) {
    callback = callback || function () {
    };
    if (tasks.constructor === Array) {
      eachfn.map(tasks, function (fn, callback) {
        if (fn) {
          fn(function (err) {
            var args = Array.prototype.slice.call(arguments, 1);
            if (args.length <= 1) {
              args = args[0];
            }
            callback.call(null, err, args);
          });
        }
      }, callback);
    } else {
      var results = {};
      eachfn.each(_keys(tasks), function (k, callback) {
        tasks[k](function (err) {
          var args = Array.prototype.slice.call(arguments, 1);
          if (args.length <= 1) {
            args = args[0];
          }
          results[k] = args;
          callback(err);
        });
      }, function (err) {
        callback(err, results);
      });
    }
  };
  async.parallel = function (tasks, callback) {
    _parallel({
      map: async.map,
      each: async.each
    }, tasks, callback);
  };
  async.parallelLimit = function (tasks, limit, callback) {
    _parallel({
      map: _mapLimit(limit),
      each: _eachLimit(limit)
    }, tasks, callback);
  };
  async.series = function (tasks, callback) {
    callback = callback || function () {
    };
    if (tasks.constructor === Array) {
      async.mapSeries(tasks, function (fn, callback) {
        if (fn) {
          fn(function (err) {
            var args = Array.prototype.slice.call(arguments, 1);
            if (args.length <= 1) {
              args = args[0];
            }
            callback.call(null, err, args);
          });
        }
      }, callback);
    } else {
      var results = {};
      async.eachSeries(_keys(tasks), function (k, callback) {
        tasks[k](function (err) {
          var args = Array.prototype.slice.call(arguments, 1);
          if (args.length <= 1) {
            args = args[0];
          }
          results[k] = args;
          callback(err);
        });
      }, function (err) {
        callback(err, results);
      });
    }
  };
  async.iterator = function (tasks) {
    var makeCallback = function (index) {
      var fn = function () {
        if (tasks.length) {
          tasks[index].apply(null, arguments);
        }
        return fn.next();
      };
      fn.next = function () {
        return index < tasks.length - 1 ? makeCallback(index + 1) : null;
      };
      return fn;
    };
    return makeCallback(0);
  };
  async.apply = function (fn) {
    var args = Array.prototype.slice.call(arguments, 1);
    return function () {
      return fn.apply(null, args.concat(Array.prototype.slice.call(arguments)));
    };
  };
  var _concat = function (eachfn, arr, fn, callback) {
    var r = [];
    eachfn(arr, function (x, cb) {
      fn(x, function (err, y) {
        r = r.concat(y || []);
        cb(err);
      });
    }, function (err) {
      callback(err, r);
    });
  };
  async.concat = doParallel(_concat);
  async.concatSeries = doSeries(_concat);
  async.whilst = function (test, iterator, callback) {
    if (test()) {
      var sync = true;
      iterator(function (err) {
        if (err) {
          return callback(err);
        }
        if (sync) {
          async.nextTick(function () {
            async.whilst(test, iterator, callback);
          });
        } else {
          async.whilst(test, iterator, callback);
        }
      });
      sync = false;
    } else {
      callback();
    }
  };
  async.doWhilst = function (iterator, test, callback) {
    var sync = true;
    iterator(function (err) {
      if (err) {
        return callback(err);
      }
      if (test()) {
        if (sync) {
          async.nextTick(function () {
            async.doWhilst(iterator, test, callback);
          });
        } else {
          async.doWhilst(iterator, test, callback);
        }
      } else {
        callback();
      }
    });
    sync = false;
  };
  async.until = function (test, iterator, callback) {
    if (!test()) {
      var sync = true;
      iterator(function (err) {
        if (err) {
          return callback(err);
        }
        if (sync) {
          async.nextTick(function () {
            async.until(test, iterator, callback);
          });
        } else {
          async.until(test, iterator, callback);
        }
      });
      sync = false;
    } else {
      callback();
    }
  };
  async.doUntil = function (iterator, test, callback) {
    var sync = true;
    iterator(function (err) {
      if (err) {
        return callback(err);
      }
      if (!test()) {
        if (sync) {
          async.nextTick(function () {
            async.doUntil(iterator, test, callback);
          });
        } else {
          async.doUntil(iterator, test, callback);
        }
      } else {
        callback();
      }
    });
    sync = false;
  };
  async.queue = function (worker, concurrency) {
    function _insert(q, data, pos, callback) {
      if (data.constructor !== Array) {
        data = [data];
      }
      _each(data, function (task) {
        var item = {
            data: task,
            callback: typeof callback === 'function' ? callback : null
          };
        if (pos) {
          q.tasks.unshift(item);
        } else {
          q.tasks.push(item);
        }
        if (q.saturated && q.tasks.length === concurrency) {
          q.saturated();
        }
        async.nextTick(q.process);
      });
    }
    var workers = 0;
    var q = {
        tasks: [],
        concurrency: concurrency,
        saturated: null,
        empty: null,
        drain: null,
        push: function (data, callback) {
          _insert(q, data, false, callback);
        },
        unshift: function (data, callback) {
          _insert(q, data, true, callback);
        },
        process: function () {
          if (workers < q.concurrency && q.tasks.length) {
            var task = q.tasks.shift();
            if (q.empty && q.tasks.length === 0) {
              q.empty();
            }
            workers += 1;
            var sync = true;
            var next = function () {
              workers -= 1;
              if (task.callback) {
                task.callback.apply(task, arguments);
              }
              if (q.drain && q.tasks.length + workers === 0) {
                q.drain();
              }
              q.process();
            };
            var cb = only_once(function () {
                var cbArgs = arguments;
                if (sync) {
                  async.nextTick(function () {
                    next.apply(null, cbArgs);
                  });
                } else {
                  next.apply(null, arguments);
                }
              });
            worker(task.data, cb);
            sync = false;
          }
        },
        length: function () {
          return q.tasks.length;
        },
        running: function () {
          return workers;
        }
      };
    return q;
  };
  async.cargo = function (worker, payload) {
    var working = false, tasks = [];
    var cargo = {
        tasks: tasks,
        payload: payload,
        saturated: null,
        empty: null,
        drain: null,
        push: function (data, callback) {
          if (data.constructor !== Array) {
            data = [data];
          }
          _each(data, function (task) {
            tasks.push({
              data: task,
              callback: typeof callback === 'function' ? callback : null
            });
            if (cargo.saturated && tasks.length === payload) {
              cargo.saturated();
            }
          });
          async.nextTick(cargo.process);
        },
        process: function process() {
          if (working)
            return;
          if (tasks.length === 0) {
            if (cargo.drain)
              cargo.drain();
            return;
          }
          var ts = typeof payload === 'number' ? tasks.splice(0, payload) : tasks.splice(0);
          var ds = _map(ts, function (task) {
              return task.data;
            });
          if (cargo.empty)
            cargo.empty();
          working = true;
          worker(ds, function () {
            working = false;
            var args = arguments;
            _each(ts, function (data) {
              if (data.callback) {
                data.callback.apply(null, args);
              }
            });
            process();
          });
        },
        length: function () {
          return tasks.length;
        },
        running: function () {
          return working;
        }
      };
    return cargo;
  };
  var _console_fn = function (name) {
    return function (fn) {
      var args = Array.prototype.slice.call(arguments, 1);
      fn.apply(null, args.concat([function (err) {
          var args = Array.prototype.slice.call(arguments, 1);
          if (typeof console !== 'undefined') {
            if (err) {
              if (console.error) {
                console.error(err);
              }
            } else if (console[name]) {
              _each(args, function (x) {
                console[name](x);
              });
            }
          }
        }]));
    };
  };
  async.log = _console_fn('log');
  async.dir = _console_fn('dir');
  async.memoize = function (fn, hasher) {
    var memo = {};
    var queues = {};
    hasher = hasher || function (x) {
      return x;
    };
    var memoized = function () {
      var args = Array.prototype.slice.call(arguments);
      var callback = args.pop();
      var key = hasher.apply(null, args);
      if (key in memo) {
        callback.apply(null, memo[key]);
      } else if (key in queues) {
        queues[key].push(callback);
      } else {
        queues[key] = [callback];
        fn.apply(null, args.concat([function () {
            memo[key] = arguments;
            var q = queues[key];
            delete queues[key];
            for (var i = 0, l = q.length; i < l; i++) {
              q[i].apply(null, arguments);
            }
          }]));
      }
    };
    memoized.memo = memo;
    memoized.unmemoized = fn;
    return memoized;
  };
  async.unmemoize = function (fn) {
    return function () {
      return (fn.unmemoized || fn).apply(null, arguments);
    };
  };
  async.times = function (count, iterator, callback) {
    var counter = [];
    for (var i = 0; i < count; i++) {
      counter.push(i);
    }
    return async.map(counter, iterator, callback);
  };
  async.timesSeries = function (count, iterator, callback) {
    var counter = [];
    for (var i = 0; i < count; i++) {
      counter.push(i);
    }
    return async.mapSeries(counter, iterator, callback);
  };
  async.compose = function () {
    var fns = Array.prototype.reverse.call(arguments);
    return function () {
      var that = this;
      var args = Array.prototype.slice.call(arguments);
      var callback = args.pop();
      async.reduce(fns, args, function (newargs, fn, cb) {
        fn.apply(that, newargs.concat([function () {
            var err = arguments[0];
            var nextargs = Array.prototype.slice.call(arguments, 1);
            cb(err, nextargs);
          }]));
      }, function (err, results) {
        callback.apply(that, [err].concat(results));
      });
    };
  };
  if (typeof define !== 'undefined' && define.amd) {
    define([], function () {
      return async;
    });
  } else if (typeof module !== 'undefined' && module.exports) {
    module.exports = async;
  } else {
    root.async = async;
  }
}());
(function (window, undefined) {
  var rootjQuery, readyList, core_strundefined = typeof undefined, location = window.location, document = window.document, docElem = document.documentElement, _jQuery = window.jQuery, _$ = window.$, class2type = {}, core_deletedIds = [], core_version = '2.0.3', core_concat = core_deletedIds.concat, core_push = core_deletedIds.push, core_slice = core_deletedIds.slice, core_indexOf = core_deletedIds.indexOf, core_toString = class2type.toString, core_hasOwn = class2type.hasOwnProperty, core_trim = core_version.trim, jQuery = function (selector, context) {
      return new jQuery.fn.init(selector, context, rootjQuery);
    }, core_pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source, core_rnotwhite = /\S+/g, rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/, rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>|)$/, rmsPrefix = /^-ms-/, rdashAlpha = /-([\da-z])/gi, fcamelCase = function (all, letter) {
      return letter.toUpperCase();
    }, completed = function () {
      document.removeEventListener('DOMContentLoaded', completed, false);
      window.removeEventListener('load', completed, false);
      jQuery.ready();
    };
  jQuery.fn = jQuery.prototype = {
    jquery: core_version,
    constructor: jQuery,
    init: function (selector, context, rootjQuery) {
      var match, elem;
      if (!selector) {
        return this;
      }
      if (typeof selector === 'string') {
        if (selector.charAt(0) === '<' && selector.charAt(selector.length - 1) === '>' && selector.length >= 3) {
          match = [
            null,
            selector,
            null
          ];
        } else {
          match = rquickExpr.exec(selector);
        }
        if (match && (match[1] || !context)) {
          if (match[1]) {
            context = context instanceof jQuery ? context[0] : context;
            jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true));
            if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
              for (match in context) {
                if (jQuery.isFunction(this[match])) {
                  this[match](context[match]);
                } else {
                  this.attr(match, context[match]);
                }
              }
            }
            return this;
          } else {
            elem = document.getElementById(match[2]);
            if (elem && elem.parentNode) {
              this.length = 1;
              this[0] = elem;
            }
            this.context = document;
            this.selector = selector;
            return this;
          }
        } else if (!context || context.jquery) {
          return (context || rootjQuery).find(selector);
        } else {
          return this.constructor(context).find(selector);
        }
      } else if (selector.nodeType) {
        this.context = this[0] = selector;
        this.length = 1;
        return this;
      } else if (jQuery.isFunction(selector)) {
        return rootjQuery.ready(selector);
      }
      if (selector.selector !== undefined) {
        this.selector = selector.selector;
        this.context = selector.context;
      }
      return jQuery.makeArray(selector, this);
    },
    selector: '',
    length: 0,
    toArray: function () {
      return core_slice.call(this);
    },
    get: function (num) {
      return num == null ? this.toArray() : num < 0 ? this[this.length + num] : this[num];
    },
    pushStack: function (elems) {
      var ret = jQuery.merge(this.constructor(), elems);
      ret.prevObject = this;
      ret.context = this.context;
      return ret;
    },
    each: function (callback, args) {
      return jQuery.each(this, callback, args);
    },
    ready: function (fn) {
      jQuery.ready.promise().done(fn);
      return this;
    },
    slice: function () {
      return this.pushStack(core_slice.apply(this, arguments));
    },
    first: function () {
      return this.eq(0);
    },
    last: function () {
      return this.eq(-1);
    },
    eq: function (i) {
      var len = this.length, j = +i + (i < 0 ? len : 0);
      return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
    },
    map: function (callback) {
      return this.pushStack(jQuery.map(this, function (elem, i) {
        return callback.call(elem, i, elem);
      }));
    },
    end: function () {
      return this.prevObject || this.constructor(null);
    },
    push: core_push,
    sort: [].sort,
    splice: [].splice
  };
  jQuery.fn.init.prototype = jQuery.fn;
  jQuery.extend = jQuery.fn.extend = function () {
    var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false;
    if (typeof target === 'boolean') {
      deep = target;
      target = arguments[1] || {};
      i = 2;
    }
    if (typeof target !== 'object' && !jQuery.isFunction(target)) {
      target = {};
    }
    if (length === i) {
      target = this;
      --i;
    }
    for (; i < length; i++) {
      if ((options = arguments[i]) != null) {
        for (name in options) {
          src = target[name];
          copy = options[name];
          if (target === copy) {
            continue;
          }
          if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {
            if (copyIsArray) {
              copyIsArray = false;
              clone = src && jQuery.isArray(src) ? src : [];
            } else {
              clone = src && jQuery.isPlainObject(src) ? src : {};
            }
            target[name] = jQuery.extend(deep, clone, copy);
          } else if (copy !== undefined) {
            target[name] = copy;
          }
        }
      }
    }
    return target;
  };
  jQuery.extend({
    expando: 'jQuery' + (core_version + Math.random()).replace(/\D/g, ''),
    noConflict: function (deep) {
      if (window.$ === jQuery) {
        window.$ = _$;
      }
      if (deep && window.jQuery === jQuery) {
        window.jQuery = _jQuery;
      }
      return jQuery;
    },
    isReady: false,
    readyWait: 1,
    holdReady: function (hold) {
      if (hold) {
        jQuery.readyWait++;
      } else {
        jQuery.ready(true);
      }
    },
    ready: function (wait) {
      if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
        return;
      }
      jQuery.isReady = true;
      if (wait !== true && --jQuery.readyWait > 0) {
        return;
      }
      readyList.resolveWith(document, [jQuery]);
      if (jQuery.fn.trigger) {
        jQuery(document).trigger('ready').off('ready');
      }
    },
    isFunction: function (obj) {
      return jQuery.type(obj) === 'function';
    },
    isArray: Array.isArray,
    isWindow: function (obj) {
      return obj != null && obj === obj.window;
    },
    isNumeric: function (obj) {
      return !isNaN(parseFloat(obj)) && isFinite(obj);
    },
    type: function (obj) {
      if (obj == null) {
        return String(obj);
      }
      return typeof obj === 'object' || typeof obj === 'function' ? class2type[core_toString.call(obj)] || 'object' : typeof obj;
    },
    isPlainObject: function (obj) {
      if (jQuery.type(obj) !== 'object' || obj.nodeType || jQuery.isWindow(obj)) {
        return false;
      }
      try {
        if (obj.constructor && !core_hasOwn.call(obj.constructor.prototype, 'isPrototypeOf')) {
          return false;
        }
      } catch (e) {
        return false;
      }
      return true;
    },
    isEmptyObject: function (obj) {
      var name;
      for (name in obj) {
        return false;
      }
      return true;
    },
    error: function (msg) {
      throw new Error(msg);
    },
    parseHTML: function (data, context, keepScripts) {
      if (!data || typeof data !== 'string') {
        return null;
      }
      if (typeof context === 'boolean') {
        keepScripts = context;
        context = false;
      }
      context = context || document;
      var parsed = rsingleTag.exec(data), scripts = !keepScripts && [];
      if (parsed) {
        return [context.createElement(parsed[1])];
      }
      parsed = jQuery.buildFragment([data], context, scripts);
      if (scripts) {
        jQuery(scripts).remove();
      }
      return jQuery.merge([], parsed.childNodes);
    },
    parseJSON: JSON.parse,
    parseXML: function (data) {
      var xml, tmp;
      if (!data || typeof data !== 'string') {
        return null;
      }
      try {
        tmp = new DOMParser();
        xml = tmp.parseFromString(data, 'text/xml');
      } catch (e) {
        xml = undefined;
      }
      if (!xml || xml.getElementsByTagName('parsererror').length) {
        jQuery.error('Invalid XML: ' + data);
      }
      return xml;
    },
    noop: function () {
    },
    globalEval: function (code) {
      var script, indirect = eval;
      code = jQuery.trim(code);
      if (code) {
        if (code.indexOf('use strict') === 1) {
          script = document.createElement('script');
          script.text = code;
          document.head.appendChild(script).parentNode.removeChild(script);
        } else {
          indirect(code);
        }
      }
    },
    camelCase: function (string) {
      return string.replace(rmsPrefix, 'ms-').replace(rdashAlpha, fcamelCase);
    },
    nodeName: function (elem, name) {
      return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
    },
    each: function (obj, callback, args) {
      var value, i = 0, length = obj.length, isArray = isArraylike(obj);
      if (args) {
        if (isArray) {
          for (; i < length; i++) {
            value = callback.apply(obj[i], args);
            if (value === false) {
              break;
            }
          }
        } else {
          for (i in obj) {
            value = callback.apply(obj[i], args);
            if (value === false) {
              break;
            }
          }
        }
      } else {
        if (isArray) {
          for (; i < length; i++) {
            value = callback.call(obj[i], i, obj[i]);
            if (value === false) {
              break;
            }
          }
        } else {
          for (i in obj) {
            value = callback.call(obj[i], i, obj[i]);
            if (value === false) {
              break;
            }
          }
        }
      }
      return obj;
    },
    trim: function (text) {
      return text == null ? '' : core_trim.call(text);
    },
    makeArray: function (arr, results) {
      var ret = results || [];
      if (arr != null) {
        if (isArraylike(Object(arr))) {
          jQuery.merge(ret, typeof arr === 'string' ? [arr] : arr);
        } else {
          core_push.call(ret, arr);
        }
      }
      return ret;
    },
    inArray: function (elem, arr, i) {
      return arr == null ? -1 : core_indexOf.call(arr, elem, i);
    },
    merge: function (first, second) {
      var l = second.length, i = first.length, j = 0;
      if (typeof l === 'number') {
        for (; j < l; j++) {
          first[i++] = second[j];
        }
      } else {
        while (second[j] !== undefined) {
          first[i++] = second[j++];
        }
      }
      first.length = i;
      return first;
    },
    grep: function (elems, callback, inv) {
      var retVal, ret = [], i = 0, length = elems.length;
      inv = !!inv;
      for (; i < length; i++) {
        retVal = !!callback(elems[i], i);
        if (inv !== retVal) {
          ret.push(elems[i]);
        }
      }
      return ret;
    },
    map: function (elems, callback, arg) {
      var value, i = 0, length = elems.length, isArray = isArraylike(elems), ret = [];
      if (isArray) {
        for (; i < length; i++) {
          value = callback(elems[i], i, arg);
          if (value != null) {
            ret[ret.length] = value;
          }
        }
      } else {
        for (i in elems) {
          value = callback(elems[i], i, arg);
          if (value != null) {
            ret[ret.length] = value;
          }
        }
      }
      return core_concat.apply([], ret);
    },
    guid: 1,
    proxy: function (fn, context) {
      var tmp, args, proxy;
      if (typeof context === 'string') {
        tmp = fn[context];
        context = fn;
        fn = tmp;
      }
      if (!jQuery.isFunction(fn)) {
        return undefined;
      }
      args = core_slice.call(arguments, 2);
      proxy = function () {
        return fn.apply(context || this, args.concat(core_slice.call(arguments)));
      };
      proxy.guid = fn.guid = fn.guid || jQuery.guid++;
      return proxy;
    },
    access: function (elems, fn, key, value, chainable, emptyGet, raw) {
      var i = 0, length = elems.length, bulk = key == null;
      if (jQuery.type(key) === 'object') {
        chainable = true;
        for (i in key) {
          jQuery.access(elems, fn, i, key[i], true, emptyGet, raw);
        }
      } else if (value !== undefined) {
        chainable = true;
        if (!jQuery.isFunction(value)) {
          raw = true;
        }
        if (bulk) {
          if (raw) {
            fn.call(elems, value);
            fn = null;
          } else {
            bulk = fn;
            fn = function (elem, key, value) {
              return bulk.call(jQuery(elem), value);
            };
          }
        }
        if (fn) {
          for (; i < length; i++) {
            fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
          }
        }
      }
      return chainable ? elems : bulk ? fn.call(elems) : length ? fn(elems[0], key) : emptyGet;
    },
    now: Date.now,
    swap: function (elem, options, callback, args) {
      var ret, name, old = {};
      for (name in options) {
        old[name] = elem.style[name];
        elem.style[name] = options[name];
      }
      ret = callback.apply(elem, args || []);
      for (name in options) {
        elem.style[name] = old[name];
      }
      return ret;
    }
  });
  jQuery.ready.promise = function (obj) {
    if (!readyList) {
      readyList = jQuery.Deferred();
      if (document.readyState === 'complete') {
        setTimeout(jQuery.ready);
      } else {
        document.addEventListener('DOMContentLoaded', completed, false);
        window.addEventListener('load', completed, false);
      }
    }
    return readyList.promise(obj);
  };
  jQuery.each('Boolean Number String Function Array Date RegExp Object Error'.split(' '), function (i, name) {
    class2type['[object ' + name + ']'] = name.toLowerCase();
  });
  function isArraylike(obj) {
    var length = obj.length, type = jQuery.type(obj);
    if (jQuery.isWindow(obj)) {
      return false;
    }
    if (obj.nodeType === 1 && length) {
      return true;
    }
    return type === 'array' || type !== 'function' && (length === 0 || typeof length === 'number' && length > 0 && length - 1 in obj);
  }
  rootjQuery = jQuery(document);
  (function (window, undefined) {
    var i, support, cachedruns, Expr, getText, isXML, compile, outermostContext, sortInput, setDocument, document, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains, expando = 'sizzle' + -new Date(), preferredDoc = window.document, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), hasDuplicate = false, sortOrder = function (a, b) {
        if (a === b) {
          hasDuplicate = true;
          return 0;
        }
        return 0;
      }, strundefined = typeof undefined, MAX_NEGATIVE = 1 << 31, hasOwn = {}.hasOwnProperty, arr = [], pop = arr.pop, push_native = arr.push, push = arr.push, slice = arr.slice, indexOf = arr.indexOf || function (elem) {
        var i = 0, len = this.length;
        for (; i < len; i++) {
          if (this[i] === elem) {
            return i;
          }
        }
        return -1;
      }, booleans = 'checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped', whitespace = '[\\x20\\t\\r\\n\\f]', characterEncoding = '(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+', identifier = characterEncoding.replace('w', 'w#'), attributes = '\\[' + whitespace + '*(' + characterEncoding + ')' + whitespace + '*(?:([*^$|!~]?=)' + whitespace + '*(?:([\'"])((?:\\\\.|[^\\\\])*?)\\3|(' + identifier + ')|)|)' + whitespace + '*\\]', pseudos = ':(' + characterEncoding + ')(?:\\((([\'"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|' + attributes.replace(3, 8) + ')*)|.*)\\)|)', rtrim = new RegExp('^' + whitespace + '+|((?:^|[^\\\\])(?:\\\\.)*)' + whitespace + '+$', 'g'), rcomma = new RegExp('^' + whitespace + '*,' + whitespace + '*'), rcombinators = new RegExp('^' + whitespace + '*([>+~]|' + whitespace + ')' + whitespace + '*'), rsibling = new RegExp(whitespace + '*[+~]'), rattributeQuotes = new RegExp('=' + whitespace + '*([^\\]\'"]*)' + whitespace + '*\\]', 'g'), rpseudo = new RegExp(pseudos), ridentifier = new RegExp('^' + identifier + '$'), matchExpr = {
        'ID': new RegExp('^#(' + characterEncoding + ')'),
        'CLASS': new RegExp('^\\.(' + characterEncoding + ')'),
        'TAG': new RegExp('^(' + characterEncoding.replace('w', 'w*') + ')'),
        'ATTR': new RegExp('^' + attributes),
        'PSEUDO': new RegExp('^' + pseudos),
        'CHILD': new RegExp('^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(' + whitespace + '*(even|odd|(([+-]|)(\\d*)n|)' + whitespace + '*(?:([+-]|)' + whitespace + '*(\\d+)|))' + whitespace + '*\\)|)', 'i'),
        'bool': new RegExp('^(?:' + booleans + ')$', 'i'),
        'needsContext': new RegExp('^' + whitespace + '*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(' + whitespace + '*((?:-\\d)?\\d*)' + whitespace + '*\\)|)(?=[^-]|$)', 'i')
      }, rnative = /^[^{]+\{\s*\[native \w/, rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rescape = /'|\\/g, runescape = new RegExp('\\\\([\\da-f]{1,6}' + whitespace + '?|(' + whitespace + ')|.)', 'ig'), funescape = function (_, escaped, escapedWhitespace) {
        var high = '0x' + escaped - 65536;
        return high !== high || escapedWhitespace ? escaped : high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320);
      };
    try {
      push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes);
      arr[preferredDoc.childNodes.length].nodeType;
    } catch (e) {
      push = {
        apply: arr.length ? function (target, els) {
          push_native.apply(target, slice.call(els));
        } : function (target, els) {
          var j = target.length, i = 0;
          while (target[j++] = els[i++]) {
          }
          target.length = j - 1;
        }
      };
    }
    function Sizzle(selector, context, results, seed) {
      var match, elem, m, nodeType, i, groups, old, nid, newContext, newSelector;
      if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
        setDocument(context);
      }
      context = context || document;
      results = results || [];
      if (!selector || typeof selector !== 'string') {
        return results;
      }
      if ((nodeType = context.nodeType) !== 1 && nodeType !== 9) {
        return [];
      }
      if (documentIsHTML && !seed) {
        if (match = rquickExpr.exec(selector)) {
          if (m = match[1]) {
            if (nodeType === 9) {
              elem = context.getElementById(m);
              if (elem && elem.parentNode) {
                if (elem.id === m) {
                  results.push(elem);
                  return results;
                }
              } else {
                return results;
              }
            } else {
              if (context.ownerDocument && (elem = context.ownerDocument.getElementById(m)) && contains(context, elem) && elem.id === m) {
                results.push(elem);
                return results;
              }
            }
          } else if (match[2]) {
            push.apply(results, context.getElementsByTagName(selector));
            return results;
          } else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {
            push.apply(results, context.getElementsByClassName(m));
            return results;
          }
        }
        if (support.qsa && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
          nid = old = expando;
          newContext = context;
          newSelector = nodeType === 9 && selector;
          if (nodeType === 1 && context.nodeName.toLowerCase() !== 'object') {
            groups = tokenize(selector);
            if (old = context.getAttribute('id')) {
              nid = old.replace(rescape, '\\$&');
            } else {
              context.setAttribute('id', nid);
            }
            nid = '[id=\'' + nid + '\'] ';
            i = groups.length;
            while (i--) {
              groups[i] = nid + toSelector(groups[i]);
            }
            newContext = rsibling.test(selector) && context.parentNode || context;
            newSelector = groups.join(',');
          }
          if (newSelector) {
            try {
              push.apply(results, newContext.querySelectorAll(newSelector));
              return results;
            } catch (qsaError) {
            } finally {
              if (!old) {
                context.removeAttribute('id');
              }
            }
          }
        }
      }
      return select(selector.replace(rtrim, '$1'), context, results, seed);
    }
    function createCache() {
      var keys = [];
      function cache(key, value) {
        if (keys.push(key += ' ') > Expr.cacheLength) {
          delete cache[keys.shift()];
        }
        return cache[key] = value;
      }
      return cache;
    }
    function markFunction(fn) {
      fn[expando] = true;
      return fn;
    }
    function assert(fn) {
      var div = document.createElement('div');
      try {
        return !!fn(div);
      } catch (e) {
        return false;
      } finally {
        if (div.parentNode) {
          div.parentNode.removeChild(div);
        }
        div = null;
      }
    }
    function addHandle(attrs, handler) {
      var arr = attrs.split('|'), i = attrs.length;
      while (i--) {
        Expr.attrHandle[arr[i]] = handler;
      }
    }
    function siblingCheck(a, b) {
      var cur = b && a, diff = cur && a.nodeType === 1 && b.nodeType === 1 && (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE);
      if (diff) {
        return diff;
      }
      if (cur) {
        while (cur = cur.nextSibling) {
          if (cur === b) {
            return -1;
          }
        }
      }
      return a ? 1 : -1;
    }
    function createInputPseudo(type) {
      return function (elem) {
        var name = elem.nodeName.toLowerCase();
        return name === 'input' && elem.type === type;
      };
    }
    function createButtonPseudo(type) {
      return function (elem) {
        var name = elem.nodeName.toLowerCase();
        return (name === 'input' || name === 'button') && elem.type === type;
      };
    }
    function createPositionalPseudo(fn) {
      return markFunction(function (argument) {
        argument = +argument;
        return markFunction(function (seed, matches) {
          var j, matchIndexes = fn([], seed.length, argument), i = matchIndexes.length;
          while (i--) {
            if (seed[j = matchIndexes[i]]) {
              seed[j] = !(matches[j] = seed[j]);
            }
          }
        });
      });
    }
    isXML = Sizzle.isXML = function (elem) {
      var documentElement = elem && (elem.ownerDocument || elem).documentElement;
      return documentElement ? documentElement.nodeName !== 'HTML' : false;
    };
    support = Sizzle.support = {};
    setDocument = Sizzle.setDocument = function (node) {
      var doc = node ? node.ownerDocument || node : preferredDoc, parent = doc.defaultView;
      if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
        return document;
      }
      document = doc;
      docElem = doc.documentElement;
      documentIsHTML = !isXML(doc);
      if (parent && parent.attachEvent && parent !== parent.top) {
        parent.attachEvent('onbeforeunload', function () {
          setDocument();
        });
      }
      support.attributes = assert(function (div) {
        div.className = 'i';
        return !div.getAttribute('className');
      });
      support.getElementsByTagName = assert(function (div) {
        div.appendChild(doc.createComment(''));
        return !div.getElementsByTagName('*').length;
      });
      support.getElementsByClassName = assert(function (div) {
        div.innerHTML = '<div class=\'a\'></div><div class=\'a i\'></div>';
        div.firstChild.className = 'i';
        return div.getElementsByClassName('i').length === 2;
      });
      support.getById = assert(function (div) {
        docElem.appendChild(div).id = expando;
        return !doc.getElementsByName || !doc.getElementsByName(expando).length;
      });
      if (support.getById) {
        Expr.find['ID'] = function (id, context) {
          if (typeof context.getElementById !== strundefined && documentIsHTML) {
            var m = context.getElementById(id);
            return m && m.parentNode ? [m] : [];
          }
        };
        Expr.filter['ID'] = function (id) {
          var attrId = id.replace(runescape, funescape);
          return function (elem) {
            return elem.getAttribute('id') === attrId;
          };
        };
      } else {
        delete Expr.find['ID'];
        Expr.filter['ID'] = function (id) {
          var attrId = id.replace(runescape, funescape);
          return function (elem) {
            var node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode('id');
            return node && node.value === attrId;
          };
        };
      }
      Expr.find['TAG'] = support.getElementsByTagName ? function (tag, context) {
        if (typeof context.getElementsByTagName !== strundefined) {
          return context.getElementsByTagName(tag);
        }
      } : function (tag, context) {
        var elem, tmp = [], i = 0, results = context.getElementsByTagName(tag);
        if (tag === '*') {
          while (elem = results[i++]) {
            if (elem.nodeType === 1) {
              tmp.push(elem);
            }
          }
          return tmp;
        }
        return results;
      };
      Expr.find['CLASS'] = support.getElementsByClassName && function (className, context) {
        if (typeof context.getElementsByClassName !== strundefined && documentIsHTML) {
          return context.getElementsByClassName(className);
        }
      };
      rbuggyMatches = [];
      rbuggyQSA = [];
      if (support.qsa = rnative.test(doc.querySelectorAll)) {
        assert(function (div) {
          div.innerHTML = '<select><option selected=\'\'></option></select>';
          if (!div.querySelectorAll('[selected]').length) {
            rbuggyQSA.push('\\[' + whitespace + '*(?:value|' + booleans + ')');
          }
          if (!div.querySelectorAll(':checked').length) {
            rbuggyQSA.push(':checked');
          }
        });
        assert(function (div) {
          var input = doc.createElement('input');
          input.setAttribute('type', 'hidden');
          div.appendChild(input).setAttribute('t', '');
          if (div.querySelectorAll('[t^=\'\']').length) {
            rbuggyQSA.push('[*^$]=' + whitespace + '*(?:\'\'|"")');
          }
          if (!div.querySelectorAll(':enabled').length) {
            rbuggyQSA.push(':enabled', ':disabled');
          }
          div.querySelectorAll('*,:x');
          rbuggyQSA.push(',.*:');
        });
      }
      if (support.matchesSelector = rnative.test(matches = docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {
        assert(function (div) {
          support.disconnectedMatch = matches.call(div, 'div');
          matches.call(div, '[s!=\'\']:x');
          rbuggyMatches.push('!=', pseudos);
        });
      }
      rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join('|'));
      rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join('|'));
      contains = rnative.test(docElem.contains) || docElem.compareDocumentPosition ? function (a, b) {
        var adown = a.nodeType === 9 ? a.documentElement : a, bup = b && b.parentNode;
        return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
      } : function (a, b) {
        if (b) {
          while (b = b.parentNode) {
            if (b === a) {
              return true;
            }
          }
        }
        return false;
      };
      sortOrder = docElem.compareDocumentPosition ? function (a, b) {
        if (a === b) {
          hasDuplicate = true;
          return 0;
        }
        var compare = b.compareDocumentPosition && a.compareDocumentPosition && a.compareDocumentPosition(b);
        if (compare) {
          if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {
            if (a === doc || contains(preferredDoc, a)) {
              return -1;
            }
            if (b === doc || contains(preferredDoc, b)) {
              return 1;
            }
            return sortInput ? indexOf.call(sortInput, a) - indexOf.call(sortInput, b) : 0;
          }
          return compare & 4 ? -1 : 1;
        }
        return a.compareDocumentPosition ? -1 : 1;
      } : function (a, b) {
        var cur, i = 0, aup = a.parentNode, bup = b.parentNode, ap = [a], bp = [b];
        if (a === b) {
          hasDuplicate = true;
          return 0;
        } else if (!aup || !bup) {
          return a === doc ? -1 : b === doc ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf.call(sortInput, a) - indexOf.call(sortInput, b) : 0;
        } else if (aup === bup) {
          return siblingCheck(a, b);
        }
        cur = a;
        while (cur = cur.parentNode) {
          ap.unshift(cur);
        }
        cur = b;
        while (cur = cur.parentNode) {
          bp.unshift(cur);
        }
        while (ap[i] === bp[i]) {
          i++;
        }
        return i ? siblingCheck(ap[i], bp[i]) : ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
      };
      return doc;
    };
    Sizzle.matches = function (expr, elements) {
      return Sizzle(expr, null, null, elements);
    };
    Sizzle.matchesSelector = function (elem, expr) {
      if ((elem.ownerDocument || elem) !== document) {
        setDocument(elem);
      }
      expr = expr.replace(rattributeQuotes, '=\'$1\']');
      if (support.matchesSelector && documentIsHTML && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
        try {
          var ret = matches.call(elem, expr);
          if (ret || support.disconnectedMatch || elem.document && elem.document.nodeType !== 11) {
            return ret;
          }
        } catch (e) {
        }
      }
      return Sizzle(expr, document, null, [elem]).length > 0;
    };
    Sizzle.contains = function (context, elem) {
      if ((context.ownerDocument || context) !== document) {
        setDocument(context);
      }
      return contains(context, elem);
    };
    Sizzle.attr = function (elem, name) {
      if ((elem.ownerDocument || elem) !== document) {
        setDocument(elem);
      }
      var fn = Expr.attrHandle[name.toLowerCase()], val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
      return val === undefined ? support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null : val;
    };
    Sizzle.error = function (msg) {
      throw new Error('Syntax error, unrecognized expression: ' + msg);
    };
    Sizzle.uniqueSort = function (results) {
      var elem, duplicates = [], j = 0, i = 0;
      hasDuplicate = !support.detectDuplicates;
      sortInput = !support.sortStable && results.slice(0);
      results.sort(sortOrder);
      if (hasDuplicate) {
        while (elem = results[i++]) {
          if (elem === results[i]) {
            j = duplicates.push(i);
          }
        }
        while (j--) {
          results.splice(duplicates[j], 1);
        }
      }
      return results;
    };
    getText = Sizzle.getText = function (elem) {
      var node, ret = '', i = 0, nodeType = elem.nodeType;
      if (!nodeType) {
        for (; node = elem[i]; i++) {
          ret += getText(node);
        }
      } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
        if (typeof elem.textContent === 'string') {
          return elem.textContent;
        } else {
          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
            ret += getText(elem);
          }
        }
      } else if (nodeType === 3 || nodeType === 4) {
        return elem.nodeValue;
      }
      return ret;
    };
    Expr = Sizzle.selectors = {
      cacheLength: 50,
      createPseudo: markFunction,
      match: matchExpr,
      attrHandle: {},
      find: {},
      relative: {
        '>': {
          dir: 'parentNode',
          first: true
        },
        ' ': { dir: 'parentNode' },
        '+': {
          dir: 'previousSibling',
          first: true
        },
        '~': { dir: 'previousSibling' }
      },
      preFilter: {
        'ATTR': function (match) {
          match[1] = match[1].replace(runescape, funescape);
          match[3] = (match[4] || match[5] || '').replace(runescape, funescape);
          if (match[2] === '~=') {
            match[3] = ' ' + match[3] + ' ';
          }
          return match.slice(0, 4);
        },
        'CHILD': function (match) {
          match[1] = match[1].toLowerCase();
          if (match[1].slice(0, 3) === 'nth') {
            if (!match[3]) {
              Sizzle.error(match[0]);
            }
            match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === 'even' || match[3] === 'odd'));
            match[5] = +(match[7] + match[8] || match[3] === 'odd');
          } else if (match[3]) {
            Sizzle.error(match[0]);
          }
          return match;
        },
        'PSEUDO': function (match) {
          var excess, unquoted = !match[5] && match[2];
          if (matchExpr['CHILD'].test(match[0])) {
            return null;
          }
          if (match[3] && match[4] !== undefined) {
            match[2] = match[4];
          } else if (unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, true)) && (excess = unquoted.indexOf(')', unquoted.length - excess) - unquoted.length)) {
            match[0] = match[0].slice(0, excess);
            match[2] = unquoted.slice(0, excess);
          }
          return match.slice(0, 3);
        }
      },
      filter: {
        'TAG': function (nodeNameSelector) {
          var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
          return nodeNameSelector === '*' ? function () {
            return true;
          } : function (elem) {
            return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
          };
        },
        'CLASS': function (className) {
          var pattern = classCache[className + ' '];
          return pattern || (pattern = new RegExp('(^|' + whitespace + ')' + className + '(' + whitespace + '|$)')) && classCache(className, function (elem) {
            return pattern.test(typeof elem.className === 'string' && elem.className || typeof elem.getAttribute !== strundefined && elem.getAttribute('class') || '');
          });
        },
        'ATTR': function (name, operator, check) {
          return function (elem) {
            var result = Sizzle.attr(elem, name);
            if (result == null) {
              return operator === '!=';
            }
            if (!operator) {
              return true;
            }
            result += '';
            return operator === '=' ? result === check : operator === '!=' ? result !== check : operator === '^=' ? check && result.indexOf(check) === 0 : operator === '*=' ? check && result.indexOf(check) > -1 : operator === '$=' ? check && result.slice(-check.length) === check : operator === '~=' ? (' ' + result + ' ').indexOf(check) > -1 : operator === '|=' ? result === check || result.slice(0, check.length + 1) === check + '-' : false;
          };
        },
        'CHILD': function (type, what, argument, first, last) {
          var simple = type.slice(0, 3) !== 'nth', forward = type.slice(-4) !== 'last', ofType = what === 'of-type';
          return first === 1 && last === 0 ? function (elem) {
            return !!elem.parentNode;
          } : function (elem, context, xml) {
            var cache, outerCache, node, diff, nodeIndex, start, dir = simple !== forward ? 'nextSibling' : 'previousSibling', parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType;
            if (parent) {
              if (simple) {
                while (dir) {
                  node = elem;
                  while (node = node[dir]) {
                    if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                      return false;
                    }
                  }
                  start = dir = type === 'only' && !start && 'nextSibling';
                }
                return true;
              }
              start = [forward ? parent.firstChild : parent.lastChild];
              if (forward && useCache) {
                outerCache = parent[expando] || (parent[expando] = {});
                cache = outerCache[type] || [];
                nodeIndex = cache[0] === dirruns && cache[1];
                diff = cache[0] === dirruns && cache[2];
                node = nodeIndex && parent.childNodes[nodeIndex];
                while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                  if (node.nodeType === 1 && ++diff && node === elem) {
                    outerCache[type] = [
                      dirruns,
                      nodeIndex,
                      diff
                    ];
                    break;
                  }
                }
              } else if (useCache && (cache = (elem[expando] || (elem[expando] = {}))[type]) && cache[0] === dirruns) {
                diff = cache[1];
              } else {
                while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                  if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                    if (useCache) {
                      (node[expando] || (node[expando] = {}))[type] = [
                        dirruns,
                        diff
                      ];
                    }
                    if (node === elem) {
                      break;
                    }
                  }
                }
              }
              diff -= last;
              return diff === first || diff % first === 0 && diff / first >= 0;
            }
          };
        },
        'PSEUDO': function (pseudo, argument) {
          var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error('unsupported pseudo: ' + pseudo);
          if (fn[expando]) {
            return fn(argument);
          }
          if (fn.length > 1) {
            args = [
              pseudo,
              pseudo,
              '',
              argument
            ];
            return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {
              var idx, matched = fn(seed, argument), i = matched.length;
              while (i--) {
                idx = indexOf.call(seed, matched[i]);
                seed[idx] = !(matches[idx] = matched[i]);
              }
            }) : function (elem) {
              return fn(elem, 0, args);
            };
          }
          return fn;
        }
      },
      pseudos: {
        'not': markFunction(function (selector) {
          var input = [], results = [], matcher = compile(selector.replace(rtrim, '$1'));
          return matcher[expando] ? markFunction(function (seed, matches, context, xml) {
            var elem, unmatched = matcher(seed, null, xml, []), i = seed.length;
            while (i--) {
              if (elem = unmatched[i]) {
                seed[i] = !(matches[i] = elem);
              }
            }
          }) : function (elem, context, xml) {
            input[0] = elem;
            matcher(input, null, xml, results);
            return !results.pop();
          };
        }),
        'has': markFunction(function (selector) {
          return function (elem) {
            return Sizzle(selector, elem).length > 0;
          };
        }),
        'contains': markFunction(function (text) {
          return function (elem) {
            return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
          };
        }),
        'lang': markFunction(function (lang) {
          if (!ridentifier.test(lang || '')) {
            Sizzle.error('unsupported lang: ' + lang);
          }
          lang = lang.replace(runescape, funescape).toLowerCase();
          return function (elem) {
            var elemLang;
            do {
              if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute('xml:lang') || elem.getAttribute('lang')) {
                elemLang = elemLang.toLowerCase();
                return elemLang === lang || elemLang.indexOf(lang + '-') === 0;
              }
            } while ((elem = elem.parentNode) && elem.nodeType === 1);
            return false;
          };
        }),
        'target': function (elem) {
          var hash = window.location && window.location.hash;
          return hash && hash.slice(1) === elem.id;
        },
        'root': function (elem) {
          return elem === docElem;
        },
        'focus': function (elem) {
          return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
        },
        'enabled': function (elem) {
          return elem.disabled === false;
        },
        'disabled': function (elem) {
          return elem.disabled === true;
        },
        'checked': function (elem) {
          var nodeName = elem.nodeName.toLowerCase();
          return nodeName === 'input' && !!elem.checked || nodeName === 'option' && !!elem.selected;
        },
        'selected': function (elem) {
          if (elem.parentNode) {
            elem.parentNode.selectedIndex;
          }
          return elem.selected === true;
        },
        'empty': function (elem) {
          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
            if (elem.nodeName > '@' || elem.nodeType === 3 || elem.nodeType === 4) {
              return false;
            }
          }
          return true;
        },
        'parent': function (elem) {
          return !Expr.pseudos['empty'](elem);
        },
        'header': function (elem) {
          return rheader.test(elem.nodeName);
        },
        'input': function (elem) {
          return rinputs.test(elem.nodeName);
        },
        'button': function (elem) {
          var name = elem.nodeName.toLowerCase();
          return name === 'input' && elem.type === 'button' || name === 'button';
        },
        'text': function (elem) {
          var attr;
          return elem.nodeName.toLowerCase() === 'input' && elem.type === 'text' && ((attr = elem.getAttribute('type')) == null || attr.toLowerCase() === elem.type);
        },
        'first': createPositionalPseudo(function () {
          return [0];
        }),
        'last': createPositionalPseudo(function (matchIndexes, length) {
          return [length - 1];
        }),
        'eq': createPositionalPseudo(function (matchIndexes, length, argument) {
          return [argument < 0 ? argument + length : argument];
        }),
        'even': createPositionalPseudo(function (matchIndexes, length) {
          var i = 0;
          for (; i < length; i += 2) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        }),
        'odd': createPositionalPseudo(function (matchIndexes, length) {
          var i = 1;
          for (; i < length; i += 2) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        }),
        'lt': createPositionalPseudo(function (matchIndexes, length, argument) {
          var i = argument < 0 ? argument + length : argument;
          for (; --i >= 0;) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        }),
        'gt': createPositionalPseudo(function (matchIndexes, length, argument) {
          var i = argument < 0 ? argument + length : argument;
          for (; ++i < length;) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        })
      }
    };
    Expr.pseudos['nth'] = Expr.pseudos['eq'];
    for (i in {
        radio: true,
        checkbox: true,
        file: true,
        password: true,
        image: true
      }) {
      Expr.pseudos[i] = createInputPseudo(i);
    }
    for (i in {
        submit: true,
        reset: true
      }) {
      Expr.pseudos[i] = createButtonPseudo(i);
    }
    function setFilters() {
    }
    setFilters.prototype = Expr.filters = Expr.pseudos;
    Expr.setFilters = new setFilters();
    function tokenize(selector, parseOnly) {
      var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + ' '];
      if (cached) {
        return parseOnly ? 0 : cached.slice(0);
      }
      soFar = selector;
      groups = [];
      preFilters = Expr.preFilter;
      while (soFar) {
        if (!matched || (match = rcomma.exec(soFar))) {
          if (match) {
            soFar = soFar.slice(match[0].length) || soFar;
          }
          groups.push(tokens = []);
        }
        matched = false;
        if (match = rcombinators.exec(soFar)) {
          matched = match.shift();
          tokens.push({
            value: matched,
            type: match[0].replace(rtrim, ' ')
          });
          soFar = soFar.slice(matched.length);
        }
        for (type in Expr.filter) {
          if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
            matched = match.shift();
            tokens.push({
              value: matched,
              type: type,
              matches: match
            });
            soFar = soFar.slice(matched.length);
          }
        }
        if (!matched) {
          break;
        }
      }
      return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : tokenCache(selector, groups).slice(0);
    }
    function toSelector(tokens) {
      var i = 0, len = tokens.length, selector = '';
      for (; i < len; i++) {
        selector += tokens[i].value;
      }
      return selector;
    }
    function addCombinator(matcher, combinator, base) {
      var dir = combinator.dir, checkNonElements = base && dir === 'parentNode', doneName = done++;
      return combinator.first ? function (elem, context, xml) {
        while (elem = elem[dir]) {
          if (elem.nodeType === 1 || checkNonElements) {
            return matcher(elem, context, xml);
          }
        }
      } : function (elem, context, xml) {
        var data, cache, outerCache, dirkey = dirruns + ' ' + doneName;
        if (xml) {
          while (elem = elem[dir]) {
            if (elem.nodeType === 1 || checkNonElements) {
              if (matcher(elem, context, xml)) {
                return true;
              }
            }
          }
        } else {
          while (elem = elem[dir]) {
            if (elem.nodeType === 1 || checkNonElements) {
              outerCache = elem[expando] || (elem[expando] = {});
              if ((cache = outerCache[dir]) && cache[0] === dirkey) {
                if ((data = cache[1]) === true || data === cachedruns) {
                  return data === true;
                }
              } else {
                cache = outerCache[dir] = [dirkey];
                cache[1] = matcher(elem, context, xml) || cachedruns;
                if (cache[1] === true) {
                  return true;
                }
              }
            }
          }
        }
      };
    }
    function elementMatcher(matchers) {
      return matchers.length > 1 ? function (elem, context, xml) {
        var i = matchers.length;
        while (i--) {
          if (!matchers[i](elem, context, xml)) {
            return false;
          }
        }
        return true;
      } : matchers[0];
    }
    function condense(unmatched, map, filter, context, xml) {
      var elem, newUnmatched = [], i = 0, len = unmatched.length, mapped = map != null;
      for (; i < len; i++) {
        if (elem = unmatched[i]) {
          if (!filter || filter(elem, context, xml)) {
            newUnmatched.push(elem);
            if (mapped) {
              map.push(i);
            }
          }
        }
      }
      return newUnmatched;
    }
    function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
      if (postFilter && !postFilter[expando]) {
        postFilter = setMatcher(postFilter);
      }
      if (postFinder && !postFinder[expando]) {
        postFinder = setMatcher(postFinder, postSelector);
      }
      return markFunction(function (seed, results, context, xml) {
        var temp, i, elem, preMap = [], postMap = [], preexisting = results.length, elems = seed || multipleContexts(selector || '*', context.nodeType ? [context] : context, []), matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems, matcherOut = matcher ? postFinder || (seed ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;
        if (matcher) {
          matcher(matcherIn, matcherOut, context, xml);
        }
        if (postFilter) {
          temp = condense(matcherOut, postMap);
          postFilter(temp, [], context, xml);
          i = temp.length;
          while (i--) {
            if (elem = temp[i]) {
              matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
            }
          }
        }
        if (seed) {
          if (postFinder || preFilter) {
            if (postFinder) {
              temp = [];
              i = matcherOut.length;
              while (i--) {
                if (elem = matcherOut[i]) {
                  temp.push(matcherIn[i] = elem);
                }
              }
              postFinder(null, matcherOut = [], temp, xml);
            }
            i = matcherOut.length;
            while (i--) {
              if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf.call(seed, elem) : preMap[i]) > -1) {
                seed[temp] = !(results[temp] = elem);
              }
            }
          }
        } else {
          matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
          if (postFinder) {
            postFinder(null, results, matcherOut, xml);
          } else {
            push.apply(results, matcherOut);
          }
        }
      });
    }
    function matcherFromTokens(tokens) {
      var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[' '], i = leadingRelative ? 1 : 0, matchContext = addCombinator(function (elem) {
          return elem === checkContext;
        }, implicitRelative, true), matchAnyContext = addCombinator(function (elem) {
          return indexOf.call(checkContext, elem) > -1;
        }, implicitRelative, true), matchers = [function (elem, context, xml) {
            return !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
          }];
      for (; i < len; i++) {
        if (matcher = Expr.relative[tokens[i].type]) {
          matchers = [addCombinator(elementMatcher(matchers), matcher)];
        } else {
          matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);
          if (matcher[expando]) {
            j = ++i;
            for (; j < len; j++) {
              if (Expr.relative[tokens[j].type]) {
                break;
              }
            }
            return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(tokens.slice(0, i - 1).concat({ value: tokens[i - 2].type === ' ' ? '*' : '' })).replace(rtrim, '$1'), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
          }
          matchers.push(matcher);
        }
      }
      return elementMatcher(matchers);
    }
    function matcherFromGroupMatchers(elementMatchers, setMatchers) {
      var matcherCachedRuns = 0, bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function (seed, context, xml, results, expandContext) {
          var elem, j, matcher, setMatched = [], matchedCount = 0, i = '0', unmatched = seed && [], outermost = expandContext != null, contextBackup = outermostContext, elems = seed || byElement && Expr.find['TAG']('*', expandContext && context.parentNode || context), dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1;
          if (outermost) {
            outermostContext = context !== document && context;
            cachedruns = matcherCachedRuns;
          }
          for (; (elem = elems[i]) != null; i++) {
            if (byElement && elem) {
              j = 0;
              while (matcher = elementMatchers[j++]) {
                if (matcher(elem, context, xml)) {
                  results.push(elem);
                  break;
                }
              }
              if (outermost) {
                dirruns = dirrunsUnique;
                cachedruns = ++matcherCachedRuns;
              }
            }
            if (bySet) {
              if (elem = !matcher && elem) {
                matchedCount--;
              }
              if (seed) {
                unmatched.push(elem);
              }
            }
          }
          matchedCount += i;
          if (bySet && i !== matchedCount) {
            j = 0;
            while (matcher = setMatchers[j++]) {
              matcher(unmatched, setMatched, context, xml);
            }
            if (seed) {
              if (matchedCount > 0) {
                while (i--) {
                  if (!(unmatched[i] || setMatched[i])) {
                    setMatched[i] = pop.call(results);
                  }
                }
              }
              setMatched = condense(setMatched);
            }
            push.apply(results, setMatched);
            if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
              Sizzle.uniqueSort(results);
            }
          }
          if (outermost) {
            dirruns = dirrunsUnique;
            outermostContext = contextBackup;
          }
          return unmatched;
        };
      return bySet ? markFunction(superMatcher) : superMatcher;
    }
    compile = Sizzle.compile = function (selector, group) {
      var i, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + ' '];
      if (!cached) {
        if (!group) {
          group = tokenize(selector);
        }
        i = group.length;
        while (i--) {
          cached = matcherFromTokens(group[i]);
          if (cached[expando]) {
            setMatchers.push(cached);
          } else {
            elementMatchers.push(cached);
          }
        }
        cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
      }
      return cached;
    };
    function multipleContexts(selector, contexts, results) {
      var i = 0, len = contexts.length;
      for (; i < len; i++) {
        Sizzle(selector, contexts[i], results);
      }
      return results;
    }
    function select(selector, context, results, seed) {
      var i, tokens, token, type, find, match = tokenize(selector);
      if (!seed) {
        if (match.length === 1) {
          tokens = match[0] = match[0].slice(0);
          if (tokens.length > 2 && (token = tokens[0]).type === 'ID' && support.getById && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
            context = (Expr.find['ID'](token.matches[0].replace(runescape, funescape), context) || [])[0];
            if (!context) {
              return results;
            }
            selector = selector.slice(tokens.shift().value.length);
          }
          i = matchExpr['needsContext'].test(selector) ? 0 : tokens.length;
          while (i--) {
            token = tokens[i];
            if (Expr.relative[type = token.type]) {
              break;
            }
            if (find = Expr.find[type]) {
              if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && context.parentNode || context)) {
                tokens.splice(i, 1);
                selector = seed.length && toSelector(tokens);
                if (!selector) {
                  push.apply(results, seed);
                  return results;
                }
                break;
              }
            }
          }
        }
      }
      compile(selector, match)(seed, context, !documentIsHTML, results, rsibling.test(selector));
      return results;
    }
    support.sortStable = expando.split('').sort(sortOrder).join('') === expando;
    support.detectDuplicates = hasDuplicate;
    setDocument();
    support.sortDetached = assert(function (div1) {
      return div1.compareDocumentPosition(document.createElement('div')) & 1;
    });
    if (!assert(function (div) {
        div.innerHTML = '<a href=\'#\'></a>';
        return div.firstChild.getAttribute('href') === '#';
      })) {
      addHandle('type|href|height|width', function (elem, name, isXML) {
        if (!isXML) {
          return elem.getAttribute(name, name.toLowerCase() === 'type' ? 1 : 2);
        }
      });
    }
    if (!support.attributes || !assert(function (div) {
        div.innerHTML = '<input/>';
        div.firstChild.setAttribute('value', '');
        return div.firstChild.getAttribute('value') === '';
      })) {
      addHandle('value', function (elem, name, isXML) {
        if (!isXML && elem.nodeName.toLowerCase() === 'input') {
          return elem.defaultValue;
        }
      });
    }
    if (!assert(function (div) {
        return div.getAttribute('disabled') == null;
      })) {
      addHandle(booleans, function (elem, name, isXML) {
        var val;
        if (!isXML) {
          return (val = elem.getAttributeNode(name)) && val.specified ? val.value : elem[name] === true ? name.toLowerCase() : null;
        }
      });
    }
    jQuery.find = Sizzle;
    jQuery.expr = Sizzle.selectors;
    jQuery.expr[':'] = jQuery.expr.pseudos;
    jQuery.unique = Sizzle.uniqueSort;
    jQuery.text = Sizzle.getText;
    jQuery.isXMLDoc = Sizzle.isXML;
    jQuery.contains = Sizzle.contains;
  }(window));
  var optionsCache = {};
  function createOptions(options) {
    var object = optionsCache[options] = {};
    jQuery.each(options.match(core_rnotwhite) || [], function (_, flag) {
      object[flag] = true;
    });
    return object;
  }
  jQuery.Callbacks = function (options) {
    options = typeof options === 'string' ? optionsCache[options] || createOptions(options) : jQuery.extend({}, options);
    var memory, fired, firing, firingStart, firingLength, firingIndex, list = [], stack = !options.once && [], fire = function (data) {
        memory = options.memory && data;
        fired = true;
        firingIndex = firingStart || 0;
        firingStart = 0;
        firingLength = list.length;
        firing = true;
        for (; list && firingIndex < firingLength; firingIndex++) {
          if (list[firingIndex].apply(data[0], data[1]) === false && options.stopOnFalse) {
            memory = false;
            break;
          }
        }
        firing = false;
        if (list) {
          if (stack) {
            if (stack.length) {
              fire(stack.shift());
            }
          } else if (memory) {
            list = [];
          } else {
            self.disable();
          }
        }
      }, self = {
        add: function () {
          if (list) {
            var start = list.length;
            (function add(args) {
              jQuery.each(args, function (_, arg) {
                var type = jQuery.type(arg);
                if (type === 'function') {
                  if (!options.unique || !self.has(arg)) {
                    list.push(arg);
                  }
                } else if (arg && arg.length && type !== 'string') {
                  add(arg);
                }
              });
            }(arguments));
            if (firing) {
              firingLength = list.length;
            } else if (memory) {
              firingStart = start;
              fire(memory);
            }
          }
          return this;
        },
        remove: function () {
          if (list) {
            jQuery.each(arguments, function (_, arg) {
              var index;
              while ((index = jQuery.inArray(arg, list, index)) > -1) {
                list.splice(index, 1);
                if (firing) {
                  if (index <= firingLength) {
                    firingLength--;
                  }
                  if (index <= firingIndex) {
                    firingIndex--;
                  }
                }
              }
            });
          }
          return this;
        },
        has: function (fn) {
          return fn ? jQuery.inArray(fn, list) > -1 : !!(list && list.length);
        },
        empty: function () {
          list = [];
          firingLength = 0;
          return this;
        },
        disable: function () {
          list = stack = memory = undefined;
          return this;
        },
        disabled: function () {
          return !list;
        },
        lock: function () {
          stack = undefined;
          if (!memory) {
            self.disable();
          }
          return this;
        },
        locked: function () {
          return !stack;
        },
        fireWith: function (context, args) {
          if (list && (!fired || stack)) {
            args = args || [];
            args = [
              context,
              args.slice ? args.slice() : args
            ];
            if (firing) {
              stack.push(args);
            } else {
              fire(args);
            }
          }
          return this;
        },
        fire: function () {
          self.fireWith(this, arguments);
          return this;
        },
        fired: function () {
          return !!fired;
        }
      };
    return self;
  };
  jQuery.extend({
    Deferred: function (func) {
      var tuples = [
          [
            'resolve',
            'done',
            jQuery.Callbacks('once memory'),
            'resolved'
          ],
          [
            'reject',
            'fail',
            jQuery.Callbacks('once memory'),
            'rejected'
          ],
          [
            'notify',
            'progress',
            jQuery.Callbacks('memory')
          ]
        ], state = 'pending', promise = {
          state: function () {
            return state;
          },
          always: function () {
            deferred.done(arguments).fail(arguments);
            return this;
          },
          then: function () {
            var fns = arguments;
            return jQuery.Deferred(function (newDefer) {
              jQuery.each(tuples, function (i, tuple) {
                var action = tuple[0], fn = jQuery.isFunction(fns[i]) && fns[i];
                deferred[tuple[1]](function () {
                  var returned = fn && fn.apply(this, arguments);
                  if (returned && jQuery.isFunction(returned.promise)) {
                    returned.promise().done(newDefer.resolve).fail(newDefer.reject).progress(newDefer.notify);
                  } else {
                    newDefer[action + 'With'](this === promise ? newDefer.promise() : this, fn ? [returned] : arguments);
                  }
                });
              });
              fns = null;
            }).promise();
          },
          promise: function (obj) {
            return obj != null ? jQuery.extend(obj, promise) : promise;
          }
        }, deferred = {};
      promise.pipe = promise.then;
      jQuery.each(tuples, function (i, tuple) {
        var list = tuple[2], stateString = tuple[3];
        promise[tuple[1]] = list.add;
        if (stateString) {
          list.add(function () {
            state = stateString;
          }, tuples[i ^ 1][2].disable, tuples[2][2].lock);
        }
        deferred[tuple[0]] = function () {
          deferred[tuple[0] + 'With'](this === deferred ? promise : this, arguments);
          return this;
        };
        deferred[tuple[0] + 'With'] = list.fireWith;
      });
      promise.promise(deferred);
      if (func) {
        func.call(deferred, deferred);
      }
      return deferred;
    },
    when: function (subordinate) {
      var i = 0, resolveValues = core_slice.call(arguments), length = resolveValues.length, remaining = length !== 1 || subordinate && jQuery.isFunction(subordinate.promise) ? length : 0, deferred = remaining === 1 ? subordinate : jQuery.Deferred(), updateFunc = function (i, contexts, values) {
          return function (value) {
            contexts[i] = this;
            values[i] = arguments.length > 1 ? core_slice.call(arguments) : value;
            if (values === progressValues) {
              deferred.notifyWith(contexts, values);
            } else if (!--remaining) {
              deferred.resolveWith(contexts, values);
            }
          };
        }, progressValues, progressContexts, resolveContexts;
      if (length > 1) {
        progressValues = new Array(length);
        progressContexts = new Array(length);
        resolveContexts = new Array(length);
        for (; i < length; i++) {
          if (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {
            resolveValues[i].promise().done(updateFunc(i, resolveContexts, resolveValues)).fail(deferred.reject).progress(updateFunc(i, progressContexts, progressValues));
          } else {
            --remaining;
          }
        }
      }
      if (!remaining) {
        deferred.resolveWith(resolveContexts, resolveValues);
      }
      return deferred.promise();
    }
  });
  jQuery.support = function (support) {
    var input = document.createElement('input'), fragment = document.createDocumentFragment(), div = document.createElement('div'), select = document.createElement('select'), opt = select.appendChild(document.createElement('option'));
    if (!input.type) {
      return support;
    }
    input.type = 'checkbox';
    support.checkOn = input.value !== '';
    support.optSelected = opt.selected;
    support.reliableMarginRight = true;
    support.boxSizingReliable = true;
    support.pixelPosition = false;
    input.checked = true;
    support.noCloneChecked = input.cloneNode(true).checked;
    select.disabled = true;
    support.optDisabled = !opt.disabled;
    input = document.createElement('input');
    input.value = 't';
    input.type = 'radio';
    support.radioValue = input.value === 't';
    input.setAttribute('checked', 't');
    input.setAttribute('name', 't');
    fragment.appendChild(input);
    support.checkClone = fragment.cloneNode(true).cloneNode(true).lastChild.checked;
    support.focusinBubbles = 'onfocusin' in window;
    div.style.backgroundClip = 'content-box';
    div.cloneNode(true).style.backgroundClip = '';
    support.clearCloneStyle = div.style.backgroundClip === 'content-box';
    jQuery(function () {
      var container, marginDiv, divReset = 'padding:0;margin:0;border:0;display:block;-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box', body = document.getElementsByTagName('body')[0];
      if (!body) {
        return;
      }
      container = document.createElement('div');
      container.style.cssText = 'border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px';
      body.appendChild(container).appendChild(div);
      div.innerHTML = '';
      div.style.cssText = '-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%';
      jQuery.swap(body, body.style.zoom != null ? { zoom: 1 } : {}, function () {
        support.boxSizing = div.offsetWidth === 4;
      });
      if (window.getComputedStyle) {
        support.pixelPosition = (window.getComputedStyle(div, null) || {}).top !== '1%';
        support.boxSizingReliable = (window.getComputedStyle(div, null) || { width: '4px' }).width === '4px';
        marginDiv = div.appendChild(document.createElement('div'));
        marginDiv.style.cssText = div.style.cssText = divReset;
        marginDiv.style.marginRight = marginDiv.style.width = '0';
        div.style.width = '1px';
        support.reliableMarginRight = !parseFloat((window.getComputedStyle(marginDiv, null) || {}).marginRight);
      }
      body.removeChild(container);
    });
    return support;
  }({});
  var data_user, data_priv, rbrace = /(?:\{[\s\S]*\}|\[[\s\S]*\])$/, rmultiDash = /([A-Z])/g;
  function Data() {
    Object.defineProperty(this.cache = {}, 0, {
      get: function () {
        return {};
      }
    });
    this.expando = jQuery.expando + Math.random();
  }
  Data.uid = 1;
  Data.accepts = function (owner) {
    return owner.nodeType ? owner.nodeType === 1 || owner.nodeType === 9 : true;
  };
  Data.prototype = {
    key: function (owner) {
      if (!Data.accepts(owner)) {
        return 0;
      }
      var descriptor = {}, unlock = owner[this.expando];
      if (!unlock) {
        unlock = Data.uid++;
        try {
          descriptor[this.expando] = { value: unlock };
          Object.defineProperties(owner, descriptor);
        } catch (e) {
          descriptor[this.expando] = unlock;
          jQuery.extend(owner, descriptor);
        }
      }
      if (!this.cache[unlock]) {
        this.cache[unlock] = {};
      }
      return unlock;
    },
    set: function (owner, data, value) {
      var prop, unlock = this.key(owner), cache = this.cache[unlock];
      if (typeof data === 'string') {
        cache[data] = value;
      } else {
        if (jQuery.isEmptyObject(cache)) {
          jQuery.extend(this.cache[unlock], data);
        } else {
          for (prop in data) {
            cache[prop] = data[prop];
          }
        }
      }
      return cache;
    },
    get: function (owner, key) {
      var cache = this.cache[this.key(owner)];
      return key === undefined ? cache : cache[key];
    },
    access: function (owner, key, value) {
      var stored;
      if (key === undefined || key && typeof key === 'string' && value === undefined) {
        stored = this.get(owner, key);
        return stored !== undefined ? stored : this.get(owner, jQuery.camelCase(key));
      }
      this.set(owner, key, value);
      return value !== undefined ? value : key;
    },
    remove: function (owner, key) {
      var i, name, camel, unlock = this.key(owner), cache = this.cache[unlock];
      if (key === undefined) {
        this.cache[unlock] = {};
      } else {
        if (jQuery.isArray(key)) {
          name = key.concat(key.map(jQuery.camelCase));
        } else {
          camel = jQuery.camelCase(key);
          if (key in cache) {
            name = [
              key,
              camel
            ];
          } else {
            name = camel;
            name = name in cache ? [name] : name.match(core_rnotwhite) || [];
          }
        }
        i = name.length;
        while (i--) {
          delete cache[name[i]];
        }
      }
    },
    hasData: function (owner) {
      return !jQuery.isEmptyObject(this.cache[owner[this.expando]] || {});
    },
    discard: function (owner) {
      if (owner[this.expando]) {
        delete this.cache[owner[this.expando]];
      }
    }
  };
  data_user = new Data();
  data_priv = new Data();
  jQuery.extend({
    acceptData: Data.accepts,
    hasData: function (elem) {
      return data_user.hasData(elem) || data_priv.hasData(elem);
    },
    data: function (elem, name, data) {
      return data_user.access(elem, name, data);
    },
    removeData: function (elem, name) {
      data_user.remove(elem, name);
    },
    _data: function (elem, name, data) {
      return data_priv.access(elem, name, data);
    },
    _removeData: function (elem, name) {
      data_priv.remove(elem, name);
    }
  });
  jQuery.fn.extend({
    data: function (key, value) {
      var attrs, name, elem = this[0], i = 0, data = null;
      if (key === undefined) {
        if (this.length) {
          data = data_user.get(elem);
          if (elem.nodeType === 1 && !data_priv.get(elem, 'hasDataAttrs')) {
            attrs = elem.attributes;
            for (; i < attrs.length; i++) {
              name = attrs[i].name;
              if (name.indexOf('data-') === 0) {
                name = jQuery.camelCase(name.slice(5));
                dataAttr(elem, name, data[name]);
              }
            }
            data_priv.set(elem, 'hasDataAttrs', true);
          }
        }
        return data;
      }
      if (typeof key === 'object') {
        return this.each(function () {
          data_user.set(this, key);
        });
      }
      return jQuery.access(this, function (value) {
        var data, camelKey = jQuery.camelCase(key);
        if (elem && value === undefined) {
          data = data_user.get(elem, key);
          if (data !== undefined) {
            return data;
          }
          data = data_user.get(elem, camelKey);
          if (data !== undefined) {
            return data;
          }
          data = dataAttr(elem, camelKey, undefined);
          if (data !== undefined) {
            return data;
          }
          return;
        }
        this.each(function () {
          var data = data_user.get(this, camelKey);
          data_user.set(this, camelKey, value);
          if (key.indexOf('-') !== -1 && data !== undefined) {
            data_user.set(this, key, value);
          }
        });
      }, null, value, arguments.length > 1, null, true);
    },
    removeData: function (key) {
      return this.each(function () {
        data_user.remove(this, key);
      });
    }
  });
  function dataAttr(elem, key, data) {
    var name;
    if (data === undefined && elem.nodeType === 1) {
      name = 'data-' + key.replace(rmultiDash, '-$1').toLowerCase();
      data = elem.getAttribute(name);
      if (typeof data === 'string') {
        try {
          data = data === 'true' ? true : data === 'false' ? false : data === 'null' ? null : +data + '' === data ? +data : rbrace.test(data) ? JSON.parse(data) : data;
        } catch (e) {
        }
        data_user.set(elem, key, data);
      } else {
        data = undefined;
      }
    }
    return data;
  }
  jQuery.extend({
    queue: function (elem, type, data) {
      var queue;
      if (elem) {
        type = (type || 'fx') + 'queue';
        queue = data_priv.get(elem, type);
        if (data) {
          if (!queue || jQuery.isArray(data)) {
            queue = data_priv.access(elem, type, jQuery.makeArray(data));
          } else {
            queue.push(data);
          }
        }
        return queue || [];
      }
    },
    dequeue: function (elem, type) {
      type = type || 'fx';
      var queue = jQuery.queue(elem, type), startLength = queue.length, fn = queue.shift(), hooks = jQuery._queueHooks(elem, type), next = function () {
          jQuery.dequeue(elem, type);
        };
      if (fn === 'inprogress') {
        fn = queue.shift();
        startLength--;
      }
      if (fn) {
        if (type === 'fx') {
          queue.unshift('inprogress');
        }
        delete hooks.stop;
        fn.call(elem, next, hooks);
      }
      if (!startLength && hooks) {
        hooks.empty.fire();
      }
    },
    _queueHooks: function (elem, type) {
      var key = type + 'queueHooks';
      return data_priv.get(elem, key) || data_priv.access(elem, key, {
        empty: jQuery.Callbacks('once memory').add(function () {
          data_priv.remove(elem, [
            type + 'queue',
            key
          ]);
        })
      });
    }
  });
  jQuery.fn.extend({
    queue: function (type, data) {
      var setter = 2;
      if (typeof type !== 'string') {
        data = type;
        type = 'fx';
        setter--;
      }
      if (arguments.length < setter) {
        return jQuery.queue(this[0], type);
      }
      return data === undefined ? this : this.each(function () {
        var queue = jQuery.queue(this, type, data);
        jQuery._queueHooks(this, type);
        if (type === 'fx' && queue[0] !== 'inprogress') {
          jQuery.dequeue(this, type);
        }
      });
    },
    dequeue: function (type) {
      return this.each(function () {
        jQuery.dequeue(this, type);
      });
    },
    delay: function (time, type) {
      time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
      type = type || 'fx';
      return this.queue(type, function (next, hooks) {
        var timeout = setTimeout(next, time);
        hooks.stop = function () {
          clearTimeout(timeout);
        };
      });
    },
    clearQueue: function (type) {
      return this.queue(type || 'fx', []);
    },
    promise: function (type, obj) {
      var tmp, count = 1, defer = jQuery.Deferred(), elements = this, i = this.length, resolve = function () {
          if (!--count) {
            defer.resolveWith(elements, [elements]);
          }
        };
      if (typeof type !== 'string') {
        obj = type;
        type = undefined;
      }
      type = type || 'fx';
      while (i--) {
        tmp = data_priv.get(elements[i], type + 'queueHooks');
        if (tmp && tmp.empty) {
          count++;
          tmp.empty.add(resolve);
        }
      }
      resolve();
      return defer.promise(obj);
    }
  });
  var nodeHook, boolHook, rclass = /[\t\r\n\f]/g, rreturn = /\r/g, rfocusable = /^(?:input|select|textarea|button)$/i;
  jQuery.fn.extend({
    attr: function (name, value) {
      return jQuery.access(this, jQuery.attr, name, value, arguments.length > 1);
    },
    removeAttr: function (name) {
      return this.each(function () {
        jQuery.removeAttr(this, name);
      });
    },
    prop: function (name, value) {
      return jQuery.access(this, jQuery.prop, name, value, arguments.length > 1);
    },
    removeProp: function (name) {
      return this.each(function () {
        delete this[jQuery.propFix[name] || name];
      });
    },
    addClass: function (value) {
      var classes, elem, cur, clazz, j, i = 0, len = this.length, proceed = typeof value === 'string' && value;
      if (jQuery.isFunction(value)) {
        return this.each(function (j) {
          jQuery(this).addClass(value.call(this, j, this.className));
        });
      }
      if (proceed) {
        classes = (value || '').match(core_rnotwhite) || [];
        for (; i < len; i++) {
          elem = this[i];
          cur = elem.nodeType === 1 && (elem.className ? (' ' + elem.className + ' ').replace(rclass, ' ') : ' ');
          if (cur) {
            j = 0;
            while (clazz = classes[j++]) {
              if (cur.indexOf(' ' + clazz + ' ') < 0) {
                cur += clazz + ' ';
              }
            }
            elem.className = jQuery.trim(cur);
          }
        }
      }
      return this;
    },
    removeClass: function (value) {
      var classes, elem, cur, clazz, j, i = 0, len = this.length, proceed = arguments.length === 0 || typeof value === 'string' && value;
      if (jQuery.isFunction(value)) {
        return this.each(function (j) {
          jQuery(this).removeClass(value.call(this, j, this.className));
        });
      }
      if (proceed) {
        classes = (value || '').match(core_rnotwhite) || [];
        for (; i < len; i++) {
          elem = this[i];
          cur = elem.nodeType === 1 && (elem.className ? (' ' + elem.className + ' ').replace(rclass, ' ') : '');
          if (cur) {
            j = 0;
            while (clazz = classes[j++]) {
              while (cur.indexOf(' ' + clazz + ' ') >= 0) {
                cur = cur.replace(' ' + clazz + ' ', ' ');
              }
            }
            elem.className = value ? jQuery.trim(cur) : '';
          }
        }
      }
      return this;
    },
    toggleClass: function (value, stateVal) {
      var type = typeof value;
      if (typeof stateVal === 'boolean' && type === 'string') {
        return stateVal ? this.addClass(value) : this.removeClass(value);
      }
      if (jQuery.isFunction(value)) {
        return this.each(function (i) {
          jQuery(this).toggleClass(value.call(this, i, this.className, stateVal), stateVal);
        });
      }
      return this.each(function () {
        if (type === 'string') {
          var className, i = 0, self = jQuery(this), classNames = value.match(core_rnotwhite) || [];
          while (className = classNames[i++]) {
            if (self.hasClass(className)) {
              self.removeClass(className);
            } else {
              self.addClass(className);
            }
          }
        } else if (type === core_strundefined || type === 'boolean') {
          if (this.className) {
            data_priv.set(this, '__className__', this.className);
          }
          this.className = this.className || value === false ? '' : data_priv.get(this, '__className__') || '';
        }
      });
    },
    hasClass: function (selector) {
      var className = ' ' + selector + ' ', i = 0, l = this.length;
      for (; i < l; i++) {
        if (this[i].nodeType === 1 && (' ' + this[i].className + ' ').replace(rclass, ' ').indexOf(className) >= 0) {
          return true;
        }
      }
      return false;
    },
    val: function (value) {
      var hooks, ret, isFunction, elem = this[0];
      if (!arguments.length) {
        if (elem) {
          hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];
          if (hooks && 'get' in hooks && (ret = hooks.get(elem, 'value')) !== undefined) {
            return ret;
          }
          ret = elem.value;
          return typeof ret === 'string' ? ret.replace(rreturn, '') : ret == null ? '' : ret;
        }
        return;
      }
      isFunction = jQuery.isFunction(value);
      return this.each(function (i) {
        var val;
        if (this.nodeType !== 1) {
          return;
        }
        if (isFunction) {
          val = value.call(this, i, jQuery(this).val());
        } else {
          val = value;
        }
        if (val == null) {
          val = '';
        } else if (typeof val === 'number') {
          val += '';
        } else if (jQuery.isArray(val)) {
          val = jQuery.map(val, function (value) {
            return value == null ? '' : value + '';
          });
        }
        hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];
        if (!hooks || !('set' in hooks) || hooks.set(this, val, 'value') === undefined) {
          this.value = val;
        }
      });
    }
  });
  jQuery.extend({
    valHooks: {
      option: {
        get: function (elem) {
          var val = elem.attributes.value;
          return !val || val.specified ? elem.value : elem.text;
        }
      },
      select: {
        get: function (elem) {
          var value, option, options = elem.options, index = elem.selectedIndex, one = elem.type === 'select-one' || index < 0, values = one ? null : [], max = one ? index + 1 : options.length, i = index < 0 ? max : one ? index : 0;
          for (; i < max; i++) {
            option = options[i];
            if ((option.selected || i === index) && (jQuery.support.optDisabled ? !option.disabled : option.getAttribute('disabled') === null) && (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, 'optgroup'))) {
              value = jQuery(option).val();
              if (one) {
                return value;
              }
              values.push(value);
            }
          }
          return values;
        },
        set: function (elem, value) {
          var optionSet, option, options = elem.options, values = jQuery.makeArray(value), i = options.length;
          while (i--) {
            option = options[i];
            if (option.selected = jQuery.inArray(jQuery(option).val(), values) >= 0) {
              optionSet = true;
            }
          }
          if (!optionSet) {
            elem.selectedIndex = -1;
          }
          return values;
        }
      }
    },
    attr: function (elem, name, value) {
      var hooks, ret, nType = elem.nodeType;
      if (!elem || nType === 3 || nType === 8 || nType === 2) {
        return;
      }
      if (typeof elem.getAttribute === core_strundefined) {
        return jQuery.prop(elem, name, value);
      }
      if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
        name = name.toLowerCase();
        hooks = jQuery.attrHooks[name] || (jQuery.expr.match.bool.test(name) ? boolHook : nodeHook);
      }
      if (value !== undefined) {
        if (value === null) {
          jQuery.removeAttr(elem, name);
        } else if (hooks && 'set' in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
          return ret;
        } else {
          elem.setAttribute(name, value + '');
          return value;
        }
      } else if (hooks && 'get' in hooks && (ret = hooks.get(elem, name)) !== null) {
        return ret;
      } else {
        ret = jQuery.find.attr(elem, name);
        return ret == null ? undefined : ret;
      }
    },
    removeAttr: function (elem, value) {
      var name, propName, i = 0, attrNames = value && value.match(core_rnotwhite);
      if (attrNames && elem.nodeType === 1) {
        while (name = attrNames[i++]) {
          propName = jQuery.propFix[name] || name;
          if (jQuery.expr.match.bool.test(name)) {
            elem[propName] = false;
          }
          elem.removeAttribute(name);
        }
      }
    },
    attrHooks: {
      type: {
        set: function (elem, value) {
          if (!jQuery.support.radioValue && value === 'radio' && jQuery.nodeName(elem, 'input')) {
            var val = elem.value;
            elem.setAttribute('type', value);
            if (val) {
              elem.value = val;
            }
            return value;
          }
        }
      }
    },
    propFix: {
      'for': 'htmlFor',
      'class': 'className'
    },
    prop: function (elem, name, value) {
      var ret, hooks, notxml, nType = elem.nodeType;
      if (!elem || nType === 3 || nType === 8 || nType === 2) {
        return;
      }
      notxml = nType !== 1 || !jQuery.isXMLDoc(elem);
      if (notxml) {
        name = jQuery.propFix[name] || name;
        hooks = jQuery.propHooks[name];
      }
      if (value !== undefined) {
        return hooks && 'set' in hooks && (ret = hooks.set(elem, value, name)) !== undefined ? ret : elem[name] = value;
      } else {
        return hooks && 'get' in hooks && (ret = hooks.get(elem, name)) !== null ? ret : elem[name];
      }
    },
    propHooks: {
      tabIndex: {
        get: function (elem) {
          return elem.hasAttribute('tabindex') || rfocusable.test(elem.nodeName) || elem.href ? elem.tabIndex : -1;
        }
      }
    }
  });
  boolHook = {
    set: function (elem, value, name) {
      if (value === false) {
        jQuery.removeAttr(elem, name);
      } else {
        elem.setAttribute(name, name);
      }
      return name;
    }
  };
  jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function (i, name) {
    var getter = jQuery.expr.attrHandle[name] || jQuery.find.attr;
    jQuery.expr.attrHandle[name] = function (elem, name, isXML) {
      var fn = jQuery.expr.attrHandle[name], ret = isXML ? undefined : (jQuery.expr.attrHandle[name] = undefined) != getter(elem, name, isXML) ? name.toLowerCase() : null;
      jQuery.expr.attrHandle[name] = fn;
      return ret;
    };
  });
  if (!jQuery.support.optSelected) {
    jQuery.propHooks.selected = {
      get: function (elem) {
        var parent = elem.parentNode;
        if (parent && parent.parentNode) {
          parent.parentNode.selectedIndex;
        }
        return null;
      }
    };
  }
  jQuery.each([
    'tabIndex',
    'readOnly',
    'maxLength',
    'cellSpacing',
    'cellPadding',
    'rowSpan',
    'colSpan',
    'useMap',
    'frameBorder',
    'contentEditable'
  ], function () {
    jQuery.propFix[this.toLowerCase()] = this;
  });
  jQuery.each([
    'radio',
    'checkbox'
  ], function () {
    jQuery.valHooks[this] = {
      set: function (elem, value) {
        if (jQuery.isArray(value)) {
          return elem.checked = jQuery.inArray(jQuery(elem).val(), value) >= 0;
        }
      }
    };
    if (!jQuery.support.checkOn) {
      jQuery.valHooks[this].get = function (elem) {
        return elem.getAttribute('value') === null ? 'on' : elem.value;
      };
    }
  });
  var rkeyEvent = /^key/, rmouseEvent = /^(?:mouse|contextmenu)|click/, rfocusMorph = /^(?:focusinfocus|focusoutblur)$/, rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;
  function returnTrue() {
    return true;
  }
  function returnFalse() {
    return false;
  }
  function safeActiveElement() {
    try {
      return document.activeElement;
    } catch (err) {
    }
  }
  jQuery.event = {
    global: {},
    add: function (elem, types, handler, data, selector) {
      var handleObjIn, eventHandle, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = data_priv.get(elem);
      if (!elemData) {
        return;
      }
      if (handler.handler) {
        handleObjIn = handler;
        handler = handleObjIn.handler;
        selector = handleObjIn.selector;
      }
      if (!handler.guid) {
        handler.guid = jQuery.guid++;
      }
      if (!(events = elemData.events)) {
        events = elemData.events = {};
      }
      if (!(eventHandle = elemData.handle)) {
        eventHandle = elemData.handle = function (e) {
          return typeof jQuery !== core_strundefined && (!e || jQuery.event.triggered !== e.type) ? jQuery.event.dispatch.apply(eventHandle.elem, arguments) : undefined;
        };
        eventHandle.elem = elem;
      }
      types = (types || '').match(core_rnotwhite) || [''];
      t = types.length;
      while (t--) {
        tmp = rtypenamespace.exec(types[t]) || [];
        type = origType = tmp[1];
        namespaces = (tmp[2] || '').split('.').sort();
        if (!type) {
          continue;
        }
        special = jQuery.event.special[type] || {};
        type = (selector ? special.delegateType : special.bindType) || type;
        special = jQuery.event.special[type] || {};
        handleObj = jQuery.extend({
          type: type,
          origType: origType,
          data: data,
          handler: handler,
          guid: handler.guid,
          selector: selector,
          needsContext: selector && jQuery.expr.match.needsContext.test(selector),
          namespace: namespaces.join('.')
        }, handleObjIn);
        if (!(handlers = events[type])) {
          handlers = events[type] = [];
          handlers.delegateCount = 0;
          if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
            if (elem.addEventListener) {
              elem.addEventListener(type, eventHandle, false);
            }
          }
        }
        if (special.add) {
          special.add.call(elem, handleObj);
          if (!handleObj.handler.guid) {
            handleObj.handler.guid = handler.guid;
          }
        }
        if (selector) {
          handlers.splice(handlers.delegateCount++, 0, handleObj);
        } else {
          handlers.push(handleObj);
        }
        jQuery.event.global[type] = true;
      }
      elem = null;
    },
    remove: function (elem, types, handler, selector, mappedTypes) {
      var j, origCount, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = data_priv.hasData(elem) && data_priv.get(elem);
      if (!elemData || !(events = elemData.events)) {
        return;
      }
      types = (types || '').match(core_rnotwhite) || [''];
      t = types.length;
      while (t--) {
        tmp = rtypenamespace.exec(types[t]) || [];
        type = origType = tmp[1];
        namespaces = (tmp[2] || '').split('.').sort();
        if (!type) {
          for (type in events) {
            jQuery.event.remove(elem, type + types[t], handler, selector, true);
          }
          continue;
        }
        special = jQuery.event.special[type] || {};
        type = (selector ? special.delegateType : special.bindType) || type;
        handlers = events[type] || [];
        tmp = tmp[2] && new RegExp('(^|\\.)' + namespaces.join('\\.(?:.*\\.|)') + '(\\.|$)');
        origCount = j = handlers.length;
        while (j--) {
          handleObj = handlers[j];
          if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === '**' && handleObj.selector)) {
            handlers.splice(j, 1);
            if (handleObj.selector) {
              handlers.delegateCount--;
            }
            if (special.remove) {
              special.remove.call(elem, handleObj);
            }
          }
        }
        if (origCount && !handlers.length) {
          if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
            jQuery.removeEvent(elem, type, elemData.handle);
          }
          delete events[type];
        }
      }
      if (jQuery.isEmptyObject(events)) {
        delete elemData.handle;
        data_priv.remove(elem, 'events');
      }
    },
    trigger: function (event, data, elem, onlyHandlers) {
      var i, cur, tmp, bubbleType, ontype, handle, special, eventPath = [elem || document], type = core_hasOwn.call(event, 'type') ? event.type : event, namespaces = core_hasOwn.call(event, 'namespace') ? event.namespace.split('.') : [];
      cur = tmp = elem = elem || document;
      if (elem.nodeType === 3 || elem.nodeType === 8) {
        return;
      }
      if (rfocusMorph.test(type + jQuery.event.triggered)) {
        return;
      }
      if (type.indexOf('.') >= 0) {
        namespaces = type.split('.');
        type = namespaces.shift();
        namespaces.sort();
      }
      ontype = type.indexOf(':') < 0 && 'on' + type;
      event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === 'object' && event);
      event.isTrigger = onlyHandlers ? 2 : 3;
      event.namespace = namespaces.join('.');
      event.namespace_re = event.namespace ? new RegExp('(^|\\.)' + namespaces.join('\\.(?:.*\\.|)') + '(\\.|$)') : null;
      event.result = undefined;
      if (!event.target) {
        event.target = elem;
      }
      data = data == null ? [event] : jQuery.makeArray(data, [event]);
      special = jQuery.event.special[type] || {};
      if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
        return;
      }
      if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {
        bubbleType = special.delegateType || type;
        if (!rfocusMorph.test(bubbleType + type)) {
          cur = cur.parentNode;
        }
        for (; cur; cur = cur.parentNode) {
          eventPath.push(cur);
          tmp = cur;
        }
        if (tmp === (elem.ownerDocument || document)) {
          eventPath.push(tmp.defaultView || tmp.parentWindow || window);
        }
      }
      i = 0;
      while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
        event.type = i > 1 ? bubbleType : special.bindType || type;
        handle = (data_priv.get(cur, 'events') || {})[event.type] && data_priv.get(cur, 'handle');
        if (handle) {
          handle.apply(cur, data);
        }
        handle = ontype && cur[ontype];
        if (handle && jQuery.acceptData(cur) && handle.apply && handle.apply(cur, data) === false) {
          event.preventDefault();
        }
      }
      event.type = type;
      if (!onlyHandlers && !event.isDefaultPrevented()) {
        if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && jQuery.acceptData(elem)) {
          if (ontype && jQuery.isFunction(elem[type]) && !jQuery.isWindow(elem)) {
            tmp = elem[ontype];
            if (tmp) {
              elem[ontype] = null;
            }
            jQuery.event.triggered = type;
            elem[type]();
            jQuery.event.triggered = undefined;
            if (tmp) {
              elem[ontype] = tmp;
            }
          }
        }
      }
      return event.result;
    },
    dispatch: function (event) {
      event = jQuery.event.fix(event);
      var i, j, ret, matched, handleObj, handlerQueue = [], args = core_slice.call(arguments), handlers = (data_priv.get(this, 'events') || {})[event.type] || [], special = jQuery.event.special[event.type] || {};
      args[0] = event;
      event.delegateTarget = this;
      if (special.preDispatch && special.preDispatch.call(this, event) === false) {
        return;
      }
      handlerQueue = jQuery.event.handlers.call(this, event, handlers);
      i = 0;
      while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
        event.currentTarget = matched.elem;
        j = 0;
        while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
          if (!event.namespace_re || event.namespace_re.test(handleObj.namespace)) {
            event.handleObj = handleObj;
            event.data = handleObj.data;
            ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
            if (ret !== undefined) {
              if ((event.result = ret) === false) {
                event.preventDefault();
                event.stopPropagation();
              }
            }
          }
        }
      }
      if (special.postDispatch) {
        special.postDispatch.call(this, event);
      }
      return event.result;
    },
    handlers: function (event, handlers) {
      var i, matches, sel, handleObj, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event.target;
      if (delegateCount && cur.nodeType && (!event.button || event.type !== 'click')) {
        for (; cur !== this; cur = cur.parentNode || this) {
          if (cur.disabled !== true || event.type !== 'click') {
            matches = [];
            for (i = 0; i < delegateCount; i++) {
              handleObj = handlers[i];
              sel = handleObj.selector + ' ';
              if (matches[sel] === undefined) {
                matches[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) >= 0 : jQuery.find(sel, this, null, [cur]).length;
              }
              if (matches[sel]) {
                matches.push(handleObj);
              }
            }
            if (matches.length) {
              handlerQueue.push({
                elem: cur,
                handlers: matches
              });
            }
          }
        }
      }
      if (delegateCount < handlers.length) {
        handlerQueue.push({
          elem: this,
          handlers: handlers.slice(delegateCount)
        });
      }
      return handlerQueue;
    },
    props: 'altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which'.split(' '),
    fixHooks: {},
    keyHooks: {
      props: 'char charCode key keyCode'.split(' '),
      filter: function (event, original) {
        if (event.which == null) {
          event.which = original.charCode != null ? original.charCode : original.keyCode;
        }
        return event;
      }
    },
    mouseHooks: {
      props: 'button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement'.split(' '),
      filter: function (event, original) {
        var eventDoc, doc, body, button = original.button;
        if (event.pageX == null && original.clientX != null) {
          eventDoc = event.target.ownerDocument || document;
          doc = eventDoc.documentElement;
          body = eventDoc.body;
          event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
          event.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
        }
        if (!event.which && button !== undefined) {
          event.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;
        }
        return event;
      }
    },
    fix: function (event) {
      if (event[jQuery.expando]) {
        return event;
      }
      var i, prop, copy, type = event.type, originalEvent = event, fixHook = this.fixHooks[type];
      if (!fixHook) {
        this.fixHooks[type] = fixHook = rmouseEvent.test(type) ? this.mouseHooks : rkeyEvent.test(type) ? this.keyHooks : {};
      }
      copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;
      event = new jQuery.Event(originalEvent);
      i = copy.length;
      while (i--) {
        prop = copy[i];
        event[prop] = originalEvent[prop];
      }
      if (!event.target) {
        event.target = document;
      }
      if (event.target.nodeType === 3) {
        event.target = event.target.parentNode;
      }
      return fixHook.filter ? fixHook.filter(event, originalEvent) : event;
    },
    special: {
      load: { noBubble: true },
      focus: {
        trigger: function () {
          if (this !== safeActiveElement() && this.focus) {
            this.focus();
            return false;
          }
        },
        delegateType: 'focusin'
      },
      blur: {
        trigger: function () {
          if (this === safeActiveElement() && this.blur) {
            this.blur();
            return false;
          }
        },
        delegateType: 'focusout'
      },
      click: {
        trigger: function () {
          if (this.type === 'checkbox' && this.click && jQuery.nodeName(this, 'input')) {
            this.click();
            return false;
          }
        },
        _default: function (event) {
          return jQuery.nodeName(event.target, 'a');
        }
      },
      beforeunload: {
        postDispatch: function (event) {
          if (event.result !== undefined) {
            event.originalEvent.returnValue = event.result;
          }
        }
      }
    },
    simulate: function (type, elem, event, bubble) {
      var e = jQuery.extend(new jQuery.Event(), event, {
          type: type,
          isSimulated: true,
          originalEvent: {}
        });
      if (bubble) {
        jQuery.event.trigger(e, null, elem);
      } else {
        jQuery.event.dispatch.call(elem, e);
      }
      if (e.isDefaultPrevented()) {
        event.preventDefault();
      }
    }
  };
  jQuery.removeEvent = function (elem, type, handle) {
    if (elem.removeEventListener) {
      elem.removeEventListener(type, handle, false);
    }
  };
  jQuery.Event = function (src, props) {
    if (!(this instanceof jQuery.Event)) {
      return new jQuery.Event(src, props);
    }
    if (src && src.type) {
      this.originalEvent = src;
      this.type = src.type;
      this.isDefaultPrevented = src.defaultPrevented || src.getPreventDefault && src.getPreventDefault() ? returnTrue : returnFalse;
    } else {
      this.type = src;
    }
    if (props) {
      jQuery.extend(this, props);
    }
    this.timeStamp = src && src.timeStamp || jQuery.now();
    this[jQuery.expando] = true;
  };
  jQuery.Event.prototype = {
    isDefaultPrevented: returnFalse,
    isPropagationStopped: returnFalse,
    isImmediatePropagationStopped: returnFalse,
    preventDefault: function () {
      var e = this.originalEvent;
      this.isDefaultPrevented = returnTrue;
      if (e && e.preventDefault) {
        e.preventDefault();
      }
    },
    stopPropagation: function () {
      var e = this.originalEvent;
      this.isPropagationStopped = returnTrue;
      if (e && e.stopPropagation) {
        e.stopPropagation();
      }
    },
    stopImmediatePropagation: function () {
      this.isImmediatePropagationStopped = returnTrue;
      this.stopPropagation();
    }
  };
  jQuery.each({
    mouseenter: 'mouseover',
    mouseleave: 'mouseout'
  }, function (orig, fix) {
    jQuery.event.special[orig] = {
      delegateType: fix,
      bindType: fix,
      handle: function (event) {
        var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj;
        if (!related || related !== target && !jQuery.contains(target, related)) {
          event.type = handleObj.origType;
          ret = handleObj.handler.apply(this, arguments);
          event.type = fix;
        }
        return ret;
      }
    };
  });
  if (!jQuery.support.focusinBubbles) {
    jQuery.each({
      focus: 'focusin',
      blur: 'focusout'
    }, function (orig, fix) {
      var attaches = 0, handler = function (event) {
          jQuery.event.simulate(fix, event.target, jQuery.event.fix(event), true);
        };
      jQuery.event.special[fix] = {
        setup: function () {
          if (attaches++ === 0) {
            document.addEventListener(orig, handler, true);
          }
        },
        teardown: function () {
          if (--attaches === 0) {
            document.removeEventListener(orig, handler, true);
          }
        }
      };
    });
  }
  jQuery.fn.extend({
    on: function (types, selector, data, fn, one) {
      var origFn, type;
      if (typeof types === 'object') {
        if (typeof selector !== 'string') {
          data = data || selector;
          selector = undefined;
        }
        for (type in types) {
          this.on(type, selector, data, types[type], one);
        }
        return this;
      }
      if (data == null && fn == null) {
        fn = selector;
        data = selector = undefined;
      } else if (fn == null) {
        if (typeof selector === 'string') {
          fn = data;
          data = undefined;
        } else {
          fn = data;
          data = selector;
          selector = undefined;
        }
      }
      if (fn === false) {
        fn = returnFalse;
      } else if (!fn) {
        return this;
      }
      if (one === 1) {
        origFn = fn;
        fn = function (event) {
          jQuery().off(event);
          return origFn.apply(this, arguments);
        };
        fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
      }
      return this.each(function () {
        jQuery.event.add(this, types, fn, data, selector);
      });
    },
    one: function (types, selector, data, fn) {
      return this.on(types, selector, data, fn, 1);
    },
    off: function (types, selector, fn) {
      var handleObj, type;
      if (types && types.preventDefault && types.handleObj) {
        handleObj = types.handleObj;
        jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + '.' + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
        return this;
      }
      if (typeof types === 'object') {
        for (type in types) {
          this.off(type, selector, types[type]);
        }
        return this;
      }
      if (selector === false || typeof selector === 'function') {
        fn = selector;
        selector = undefined;
      }
      if (fn === false) {
        fn = returnFalse;
      }
      return this.each(function () {
        jQuery.event.remove(this, types, fn, selector);
      });
    },
    trigger: function (type, data) {
      return this.each(function () {
        jQuery.event.trigger(type, data, this);
      });
    },
    triggerHandler: function (type, data) {
      var elem = this[0];
      if (elem) {
        return jQuery.event.trigger(type, data, elem, true);
      }
    }
  });
  var isSimple = /^.[^:#\[\.,]*$/, rparentsprev = /^(?:parents|prev(?:Until|All))/, rneedsContext = jQuery.expr.match.needsContext, guaranteedUnique = {
      children: true,
      contents: true,
      next: true,
      prev: true
    };
  jQuery.fn.extend({
    find: function (selector) {
      var i, ret = [], self = this, len = self.length;
      if (typeof selector !== 'string') {
        return this.pushStack(jQuery(selector).filter(function () {
          for (i = 0; i < len; i++) {
            if (jQuery.contains(self[i], this)) {
              return true;
            }
          }
        }));
      }
      for (i = 0; i < len; i++) {
        jQuery.find(selector, self[i], ret);
      }
      ret = this.pushStack(len > 1 ? jQuery.unique(ret) : ret);
      ret.selector = this.selector ? this.selector + ' ' + selector : selector;
      return ret;
    },
    has: function (target) {
      var targets = jQuery(target, this), l = targets.length;
      return this.filter(function () {
        var i = 0;
        for (; i < l; i++) {
          if (jQuery.contains(this, targets[i])) {
            return true;
          }
        }
      });
    },
    not: function (selector) {
      return this.pushStack(winnow(this, selector || [], true));
    },
    filter: function (selector) {
      return this.pushStack(winnow(this, selector || [], false));
    },
    is: function (selector) {
      return !!winnow(this, typeof selector === 'string' && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
    },
    closest: function (selectors, context) {
      var cur, i = 0, l = this.length, matched = [], pos = rneedsContext.test(selectors) || typeof selectors !== 'string' ? jQuery(selectors, context || this.context) : 0;
      for (; i < l; i++) {
        for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
          if (cur.nodeType < 11 && (pos ? pos.index(cur) > -1 : cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {
            cur = matched.push(cur);
            break;
          }
        }
      }
      return this.pushStack(matched.length > 1 ? jQuery.unique(matched) : matched);
    },
    index: function (elem) {
      if (!elem) {
        return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
      }
      if (typeof elem === 'string') {
        return core_indexOf.call(jQuery(elem), this[0]);
      }
      return core_indexOf.call(this, elem.jquery ? elem[0] : elem);
    },
    add: function (selector, context) {
      var set = typeof selector === 'string' ? jQuery(selector, context) : jQuery.makeArray(selector && selector.nodeType ? [selector] : selector), all = jQuery.merge(this.get(), set);
      return this.pushStack(jQuery.unique(all));
    },
    addBack: function (selector) {
      return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
    }
  });
  function sibling(cur, dir) {
    while ((cur = cur[dir]) && cur.nodeType !== 1) {
    }
    return cur;
  }
  jQuery.each({
    parent: function (elem) {
      var parent = elem.parentNode;
      return parent && parent.nodeType !== 11 ? parent : null;
    },
    parents: function (elem) {
      return jQuery.dir(elem, 'parentNode');
    },
    parentsUntil: function (elem, i, until) {
      return jQuery.dir(elem, 'parentNode', until);
    },
    next: function (elem) {
      return sibling(elem, 'nextSibling');
    },
    prev: function (elem) {
      return sibling(elem, 'previousSibling');
    },
    nextAll: function (elem) {
      return jQuery.dir(elem, 'nextSibling');
    },
    prevAll: function (elem) {
      return jQuery.dir(elem, 'previousSibling');
    },
    nextUntil: function (elem, i, until) {
      return jQuery.dir(elem, 'nextSibling', until);
    },
    prevUntil: function (elem, i, until) {
      return jQuery.dir(elem, 'previousSibling', until);
    },
    siblings: function (elem) {
      return jQuery.sibling((elem.parentNode || {}).firstChild, elem);
    },
    children: function (elem) {
      return jQuery.sibling(elem.firstChild);
    },
    contents: function (elem) {
      return elem.contentDocument || jQuery.merge([], elem.childNodes);
    }
  }, function (name, fn) {
    jQuery.fn[name] = function (until, selector) {
      var matched = jQuery.map(this, fn, until);
      if (name.slice(-5) !== 'Until') {
        selector = until;
      }
      if (selector && typeof selector === 'string') {
        matched = jQuery.filter(selector, matched);
      }
      if (this.length > 1) {
        if (!guaranteedUnique[name]) {
          jQuery.unique(matched);
        }
        if (rparentsprev.test(name)) {
          matched.reverse();
        }
      }
      return this.pushStack(matched);
    };
  });
  jQuery.extend({
    filter: function (expr, elems, not) {
      var elem = elems[0];
      if (not) {
        expr = ':not(' + expr + ')';
      }
      return elems.length === 1 && elem.nodeType === 1 ? jQuery.find.matchesSelector(elem, expr) ? [elem] : [] : jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {
        return elem.nodeType === 1;
      }));
    },
    dir: function (elem, dir, until) {
      var matched = [], truncate = until !== undefined;
      while ((elem = elem[dir]) && elem.nodeType !== 9) {
        if (elem.nodeType === 1) {
          if (truncate && jQuery(elem).is(until)) {
            break;
          }
          matched.push(elem);
        }
      }
      return matched;
    },
    sibling: function (n, elem) {
      var matched = [];
      for (; n; n = n.nextSibling) {
        if (n.nodeType === 1 && n !== elem) {
          matched.push(n);
        }
      }
      return matched;
    }
  });
  function winnow(elements, qualifier, not) {
    if (jQuery.isFunction(qualifier)) {
      return jQuery.grep(elements, function (elem, i) {
        return !!qualifier.call(elem, i, elem) !== not;
      });
    }
    if (qualifier.nodeType) {
      return jQuery.grep(elements, function (elem) {
        return elem === qualifier !== not;
      });
    }
    if (typeof qualifier === 'string') {
      if (isSimple.test(qualifier)) {
        return jQuery.filter(qualifier, elements, not);
      }
      qualifier = jQuery.filter(qualifier, elements);
    }
    return jQuery.grep(elements, function (elem) {
      return core_indexOf.call(qualifier, elem) >= 0 !== not;
    });
  }
  var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi, rtagName = /<([\w:]+)/, rhtml = /<|&#?\w+;/, rnoInnerhtml = /<(?:script|style|link)/i, manipulation_rcheckableType = /^(?:checkbox|radio)$/i, rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i, rscriptType = /^$|\/(?:java|ecma)script/i, rscriptTypeMasked = /^true\/(.*)/, rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g, wrapMap = {
      option: [
        1,
        '<select multiple=\'multiple\'>',
        '</select>'
      ],
      thead: [
        1,
        '<table>',
        '</table>'
      ],
      col: [
        2,
        '<table><colgroup>',
        '</colgroup></table>'
      ],
      tr: [
        2,
        '<table><tbody>',
        '</tbody></table>'
      ],
      td: [
        3,
        '<table><tbody><tr>',
        '</tr></tbody></table>'
      ],
      _default: [
        0,
        '',
        ''
      ]
    };
  wrapMap.optgroup = wrapMap.option;
  wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
  wrapMap.th = wrapMap.td;
  jQuery.fn.extend({
    text: function (value) {
      return jQuery.access(this, function (value) {
        return value === undefined ? jQuery.text(this) : this.empty().append((this[0] && this[0].ownerDocument || document).createTextNode(value));
      }, null, value, arguments.length);
    },
    append: function () {
      return this.domManip(arguments, function (elem) {
        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
          var target = manipulationTarget(this, elem);
          target.appendChild(elem);
        }
      });
    },
    prepend: function () {
      return this.domManip(arguments, function (elem) {
        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
          var target = manipulationTarget(this, elem);
          target.insertBefore(elem, target.firstChild);
        }
      });
    },
    before: function () {
      return this.domManip(arguments, function (elem) {
        if (this.parentNode) {
          this.parentNode.insertBefore(elem, this);
        }
      });
    },
    after: function () {
      return this.domManip(arguments, function (elem) {
        if (this.parentNode) {
          this.parentNode.insertBefore(elem, this.nextSibling);
        }
      });
    },
    remove: function (selector, keepData) {
      var elem, elems = selector ? jQuery.filter(selector, this) : this, i = 0;
      for (; (elem = elems[i]) != null; i++) {
        if (!keepData && elem.nodeType === 1) {
          jQuery.cleanData(getAll(elem));
        }
        if (elem.parentNode) {
          if (keepData && jQuery.contains(elem.ownerDocument, elem)) {
            setGlobalEval(getAll(elem, 'script'));
          }
          elem.parentNode.removeChild(elem);
        }
      }
      return this;
    },
    empty: function () {
      var elem, i = 0;
      for (; (elem = this[i]) != null; i++) {
        if (elem.nodeType === 1) {
          jQuery.cleanData(getAll(elem, false));
          elem.textContent = '';
        }
      }
      return this;
    },
    clone: function (dataAndEvents, deepDataAndEvents) {
      dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
      deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
      return this.map(function () {
        return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
      });
    },
    html: function (value) {
      return jQuery.access(this, function (value) {
        var elem = this[0] || {}, i = 0, l = this.length;
        if (value === undefined && elem.nodeType === 1) {
          return elem.innerHTML;
        }
        if (typeof value === 'string' && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || [
            '',
            ''
          ])[1].toLowerCase()]) {
          value = value.replace(rxhtmlTag, '<$1></$2>');
          try {
            for (; i < l; i++) {
              elem = this[i] || {};
              if (elem.nodeType === 1) {
                jQuery.cleanData(getAll(elem, false));
                elem.innerHTML = value;
              }
            }
            elem = 0;
          } catch (e) {
          }
        }
        if (elem) {
          this.empty().append(value);
        }
      }, null, value, arguments.length);
    },
    replaceWith: function () {
      var args = jQuery.map(this, function (elem) {
          return [
            elem.nextSibling,
            elem.parentNode
          ];
        }), i = 0;
      this.domManip(arguments, function (elem) {
        var next = args[i++], parent = args[i++];
        if (parent) {
          if (next && next.parentNode !== parent) {
            next = this.nextSibling;
          }
          jQuery(this).remove();
          parent.insertBefore(elem, next);
        }
      }, true);
      return i ? this : this.remove();
    },
    detach: function (selector) {
      return this.remove(selector, true);
    },
    domManip: function (args, callback, allowIntersection) {
      args = core_concat.apply([], args);
      var fragment, first, scripts, hasScripts, node, doc, i = 0, l = this.length, set = this, iNoClone = l - 1, value = args[0], isFunction = jQuery.isFunction(value);
      if (isFunction || !(l <= 1 || typeof value !== 'string' || jQuery.support.checkClone || !rchecked.test(value))) {
        return this.each(function (index) {
          var self = set.eq(index);
          if (isFunction) {
            args[0] = value.call(this, index, self.html());
          }
          self.domManip(args, callback, allowIntersection);
        });
      }
      if (l) {
        fragment = jQuery.buildFragment(args, this[0].ownerDocument, false, !allowIntersection && this);
        first = fragment.firstChild;
        if (fragment.childNodes.length === 1) {
          fragment = first;
        }
        if (first) {
          scripts = jQuery.map(getAll(fragment, 'script'), disableScript);
          hasScripts = scripts.length;
          for (; i < l; i++) {
            node = fragment;
            if (i !== iNoClone) {
              node = jQuery.clone(node, true, true);
              if (hasScripts) {
                jQuery.merge(scripts, getAll(node, 'script'));
              }
            }
            callback.call(this[i], node, i);
          }
          if (hasScripts) {
            doc = scripts[scripts.length - 1].ownerDocument;
            jQuery.map(scripts, restoreScript);
            for (i = 0; i < hasScripts; i++) {
              node = scripts[i];
              if (rscriptType.test(node.type || '') && !data_priv.access(node, 'globalEval') && jQuery.contains(doc, node)) {
                if (node.src) {
                  jQuery._evalUrl(node.src);
                } else {
                  jQuery.globalEval(node.textContent.replace(rcleanScript, ''));
                }
              }
            }
          }
        }
      }
      return this;
    }
  });
  jQuery.each({
    appendTo: 'append',
    prependTo: 'prepend',
    insertBefore: 'before',
    insertAfter: 'after',
    replaceAll: 'replaceWith'
  }, function (name, original) {
    jQuery.fn[name] = function (selector) {
      var elems, ret = [], insert = jQuery(selector), last = insert.length - 1, i = 0;
      for (; i <= last; i++) {
        elems = i === last ? this : this.clone(true);
        jQuery(insert[i])[original](elems);
        core_push.apply(ret, elems.get());
      }
      return this.pushStack(ret);
    };
  });
  jQuery.extend({
    clone: function (elem, dataAndEvents, deepDataAndEvents) {
      var i, l, srcElements, destElements, clone = elem.cloneNode(true), inPage = jQuery.contains(elem.ownerDocument, elem);
      if (!jQuery.support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
        destElements = getAll(clone);
        srcElements = getAll(elem);
        for (i = 0, l = srcElements.length; i < l; i++) {
          fixInput(srcElements[i], destElements[i]);
        }
      }
      if (dataAndEvents) {
        if (deepDataAndEvents) {
          srcElements = srcElements || getAll(elem);
          destElements = destElements || getAll(clone);
          for (i = 0, l = srcElements.length; i < l; i++) {
            cloneCopyEvent(srcElements[i], destElements[i]);
          }
        } else {
          cloneCopyEvent(elem, clone);
        }
      }
      destElements = getAll(clone, 'script');
      if (destElements.length > 0) {
        setGlobalEval(destElements, !inPage && getAll(elem, 'script'));
      }
      return clone;
    },
    buildFragment: function (elems, context, scripts, selection) {
      var elem, tmp, tag, wrap, contains, j, i = 0, l = elems.length, fragment = context.createDocumentFragment(), nodes = [];
      for (; i < l; i++) {
        elem = elems[i];
        if (elem || elem === 0) {
          if (jQuery.type(elem) === 'object') {
            jQuery.merge(nodes, elem.nodeType ? [elem] : elem);
          } else if (!rhtml.test(elem)) {
            nodes.push(context.createTextNode(elem));
          } else {
            tmp = tmp || fragment.appendChild(context.createElement('div'));
            tag = (rtagName.exec(elem) || [
              '',
              ''
            ])[1].toLowerCase();
            wrap = wrapMap[tag] || wrapMap._default;
            tmp.innerHTML = wrap[1] + elem.replace(rxhtmlTag, '<$1></$2>') + wrap[2];
            j = wrap[0];
            while (j--) {
              tmp = tmp.lastChild;
            }
            jQuery.merge(nodes, tmp.childNodes);
            tmp = fragment.firstChild;
            tmp.textContent = '';
          }
        }
      }
      fragment.textContent = '';
      i = 0;
      while (elem = nodes[i++]) {
        if (selection && jQuery.inArray(elem, selection) !== -1) {
          continue;
        }
        contains = jQuery.contains(elem.ownerDocument, elem);
        tmp = getAll(fragment.appendChild(elem), 'script');
        if (contains) {
          setGlobalEval(tmp);
        }
        if (scripts) {
          j = 0;
          while (elem = tmp[j++]) {
            if (rscriptType.test(elem.type || '')) {
              scripts.push(elem);
            }
          }
        }
      }
      return fragment;
    },
    cleanData: function (elems) {
      var data, elem, events, type, key, j, special = jQuery.event.special, i = 0;
      for (; (elem = elems[i]) !== undefined; i++) {
        if (Data.accepts(elem)) {
          key = elem[data_priv.expando];
          if (key && (data = data_priv.cache[key])) {
            events = Object.keys(data.events || {});
            if (events.length) {
              for (j = 0; (type = events[j]) !== undefined; j++) {
                if (special[type]) {
                  jQuery.event.remove(elem, type);
                } else {
                  jQuery.removeEvent(elem, type, data.handle);
                }
              }
            }
            if (data_priv.cache[key]) {
              delete data_priv.cache[key];
            }
          }
        }
        delete data_user.cache[elem[data_user.expando]];
      }
    },
    _evalUrl: function (url) {
      return jQuery.ajax({
        url: url,
        type: 'GET',
        dataType: 'script',
        async: false,
        global: false,
        'throws': true
      });
    }
  });
  function manipulationTarget(elem, content) {
    return jQuery.nodeName(elem, 'table') && jQuery.nodeName(content.nodeType === 1 ? content : content.firstChild, 'tr') ? elem.getElementsByTagName('tbody')[0] || elem.appendChild(elem.ownerDocument.createElement('tbody')) : elem;
  }
  function disableScript(elem) {
    elem.type = (elem.getAttribute('type') !== null) + '/' + elem.type;
    return elem;
  }
  function restoreScript(elem) {
    var match = rscriptTypeMasked.exec(elem.type);
    if (match) {
      elem.type = match[1];
    } else {
      elem.removeAttribute('type');
    }
    return elem;
  }
  function setGlobalEval(elems, refElements) {
    var l = elems.length, i = 0;
    for (; i < l; i++) {
      data_priv.set(elems[i], 'globalEval', !refElements || data_priv.get(refElements[i], 'globalEval'));
    }
  }
  function cloneCopyEvent(src, dest) {
    var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;
    if (dest.nodeType !== 1) {
      return;
    }
    if (data_priv.hasData(src)) {
      pdataOld = data_priv.access(src);
      pdataCur = data_priv.set(dest, pdataOld);
      events = pdataOld.events;
      if (events) {
        delete pdataCur.handle;
        pdataCur.events = {};
        for (type in events) {
          for (i = 0, l = events[type].length; i < l; i++) {
            jQuery.event.add(dest, type, events[type][i]);
          }
        }
      }
    }
    if (data_user.hasData(src)) {
      udataOld = data_user.access(src);
      udataCur = jQuery.extend({}, udataOld);
      data_user.set(dest, udataCur);
    }
  }
  function getAll(context, tag) {
    var ret = context.getElementsByTagName ? context.getElementsByTagName(tag || '*') : context.querySelectorAll ? context.querySelectorAll(tag || '*') : [];
    return tag === undefined || tag && jQuery.nodeName(context, tag) ? jQuery.merge([context], ret) : ret;
  }
  function fixInput(src, dest) {
    var nodeName = dest.nodeName.toLowerCase();
    if (nodeName === 'input' && manipulation_rcheckableType.test(src.type)) {
      dest.checked = src.checked;
    } else if (nodeName === 'input' || nodeName === 'textarea') {
      dest.defaultValue = src.defaultValue;
    }
  }
  jQuery.fn.extend({
    wrapAll: function (html) {
      var wrap;
      if (jQuery.isFunction(html)) {
        return this.each(function (i) {
          jQuery(this).wrapAll(html.call(this, i));
        });
      }
      if (this[0]) {
        wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);
        if (this[0].parentNode) {
          wrap.insertBefore(this[0]);
        }
        wrap.map(function () {
          var elem = this;
          while (elem.firstElementChild) {
            elem = elem.firstElementChild;
          }
          return elem;
        }).append(this);
      }
      return this;
    },
    wrapInner: function (html) {
      if (jQuery.isFunction(html)) {
        return this.each(function (i) {
          jQuery(this).wrapInner(html.call(this, i));
        });
      }
      return this.each(function () {
        var self = jQuery(this), contents = self.contents();
        if (contents.length) {
          contents.wrapAll(html);
        } else {
          self.append(html);
        }
      });
    },
    wrap: function (html) {
      var isFunction = jQuery.isFunction(html);
      return this.each(function (i) {
        jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
      });
    },
    unwrap: function () {
      return this.parent().each(function () {
        if (!jQuery.nodeName(this, 'body')) {
          jQuery(this).replaceWith(this.childNodes);
        }
      }).end();
    }
  });
  var curCSS, iframe, rdisplayswap = /^(none|table(?!-c[ea]).+)/, rmargin = /^margin/, rnumsplit = new RegExp('^(' + core_pnum + ')(.*)$', 'i'), rnumnonpx = new RegExp('^(' + core_pnum + ')(?!px)[a-z%]+$', 'i'), rrelNum = new RegExp('^([+-])=(' + core_pnum + ')', 'i'), elemdisplay = { BODY: 'block' }, cssShow = {
      position: 'absolute',
      visibility: 'hidden',
      display: 'block'
    }, cssNormalTransform = {
      letterSpacing: 0,
      fontWeight: 400
    }, cssExpand = [
      'Top',
      'Right',
      'Bottom',
      'Left'
    ], cssPrefixes = [
      'Webkit',
      'O',
      'Moz',
      'ms'
    ];
  function vendorPropName(style, name) {
    if (name in style) {
      return name;
    }
    var capName = name.charAt(0).toUpperCase() + name.slice(1), origName = name, i = cssPrefixes.length;
    while (i--) {
      name = cssPrefixes[i] + capName;
      if (name in style) {
        return name;
      }
    }
    return origName;
  }
  function isHidden(elem, el) {
    elem = el || elem;
    return jQuery.css(elem, 'display') === 'none' || !jQuery.contains(elem.ownerDocument, elem);
  }
  function getStyles(elem) {
    return window.getComputedStyle(elem, null);
  }
  function showHide(elements, show) {
    var display, elem, hidden, values = [], index = 0, length = elements.length;
    for (; index < length; index++) {
      elem = elements[index];
      if (!elem.style) {
        continue;
      }
      values[index] = data_priv.get(elem, 'olddisplay');
      display = elem.style.display;
      if (show) {
        if (!values[index] && display === 'none') {
          elem.style.display = '';
        }
        if (elem.style.display === '' && isHidden(elem)) {
          values[index] = data_priv.access(elem, 'olddisplay', css_defaultDisplay(elem.nodeName));
        }
      } else {
        if (!values[index]) {
          hidden = isHidden(elem);
          if (display && display !== 'none' || !hidden) {
            data_priv.set(elem, 'olddisplay', hidden ? display : jQuery.css(elem, 'display'));
          }
        }
      }
    }
    for (index = 0; index < length; index++) {
      elem = elements[index];
      if (!elem.style) {
        continue;
      }
      if (!show || elem.style.display === 'none' || elem.style.display === '') {
        elem.style.display = show ? values[index] || '' : 'none';
      }
    }
    return elements;
  }
  jQuery.fn.extend({
    css: function (name, value) {
      return jQuery.access(this, function (elem, name, value) {
        var styles, len, map = {}, i = 0;
        if (jQuery.isArray(name)) {
          styles = getStyles(elem);
          len = name.length;
          for (; i < len; i++) {
            map[name[i]] = jQuery.css(elem, name[i], false, styles);
          }
          return map;
        }
        return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
      }, name, value, arguments.length > 1);
    },
    show: function () {
      return showHide(this, true);
    },
    hide: function () {
      return showHide(this);
    },
    toggle: function (state) {
      if (typeof state === 'boolean') {
        return state ? this.show() : this.hide();
      }
      return this.each(function () {
        if (isHidden(this)) {
          jQuery(this).show();
        } else {
          jQuery(this).hide();
        }
      });
    }
  });
  jQuery.extend({
    cssHooks: {
      opacity: {
        get: function (elem, computed) {
          if (computed) {
            var ret = curCSS(elem, 'opacity');
            return ret === '' ? '1' : ret;
          }
        }
      }
    },
    cssNumber: {
      'columnCount': true,
      'fillOpacity': true,
      'fontWeight': true,
      'lineHeight': true,
      'opacity': true,
      'order': true,
      'orphans': true,
      'widows': true,
      'zIndex': true,
      'zoom': true
    },
    cssProps: { 'float': 'cssFloat' },
    style: function (elem, name, value, extra) {
      if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
        return;
      }
      var ret, type, hooks, origName = jQuery.camelCase(name), style = elem.style;
      name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(style, origName));
      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
      if (value !== undefined) {
        type = typeof value;
        if (type === 'string' && (ret = rrelNum.exec(value))) {
          value = (ret[1] + 1) * ret[2] + parseFloat(jQuery.css(elem, name));
          type = 'number';
        }
        if (value == null || type === 'number' && isNaN(value)) {
          return;
        }
        if (type === 'number' && !jQuery.cssNumber[origName]) {
          value += 'px';
        }
        if (!jQuery.support.clearCloneStyle && value === '' && name.indexOf('background') === 0) {
          style[name] = 'inherit';
        }
        if (!hooks || !('set' in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
          style[name] = value;
        }
      } else {
        if (hooks && 'get' in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
          return ret;
        }
        return style[name];
      }
    },
    css: function (elem, name, extra, styles) {
      var val, num, hooks, origName = jQuery.camelCase(name);
      name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(elem.style, origName));
      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
      if (hooks && 'get' in hooks) {
        val = hooks.get(elem, true, extra);
      }
      if (val === undefined) {
        val = curCSS(elem, name, styles);
      }
      if (val === 'normal' && name in cssNormalTransform) {
        val = cssNormalTransform[name];
      }
      if (extra === '' || extra) {
        num = parseFloat(val);
        return extra === true || jQuery.isNumeric(num) ? num || 0 : val;
      }
      return val;
    }
  });
  curCSS = function (elem, name, _computed) {
    var width, minWidth, maxWidth, computed = _computed || getStyles(elem), ret = computed ? computed.getPropertyValue(name) || computed[name] : undefined, style = elem.style;
    if (computed) {
      if (ret === '' && !jQuery.contains(elem.ownerDocument, elem)) {
        ret = jQuery.style(elem, name);
      }
      if (rnumnonpx.test(ret) && rmargin.test(name)) {
        width = style.width;
        minWidth = style.minWidth;
        maxWidth = style.maxWidth;
        style.minWidth = style.maxWidth = style.width = ret;
        ret = computed.width;
        style.width = width;
        style.minWidth = minWidth;
        style.maxWidth = maxWidth;
      }
    }
    return ret;
  };
  function setPositiveNumber(elem, value, subtract) {
    var matches = rnumsplit.exec(value);
    return matches ? Math.max(0, matches[1] - (subtract || 0)) + (matches[2] || 'px') : value;
  }
  function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
    var i = extra === (isBorderBox ? 'border' : 'content') ? 4 : name === 'width' ? 1 : 0, val = 0;
    for (; i < 4; i += 2) {
      if (extra === 'margin') {
        val += jQuery.css(elem, extra + cssExpand[i], true, styles);
      }
      if (isBorderBox) {
        if (extra === 'content') {
          val -= jQuery.css(elem, 'padding' + cssExpand[i], true, styles);
        }
        if (extra !== 'margin') {
          val -= jQuery.css(elem, 'border' + cssExpand[i] + 'Width', true, styles);
        }
      } else {
        val += jQuery.css(elem, 'padding' + cssExpand[i], true, styles);
        if (extra !== 'padding') {
          val += jQuery.css(elem, 'border' + cssExpand[i] + 'Width', true, styles);
        }
      }
    }
    return val;
  }
  function getWidthOrHeight(elem, name, extra) {
    var valueIsBorderBox = true, val = name === 'width' ? elem.offsetWidth : elem.offsetHeight, styles = getStyles(elem), isBorderBox = jQuery.support.boxSizing && jQuery.css(elem, 'boxSizing', false, styles) === 'border-box';
    if (val <= 0 || val == null) {
      val = curCSS(elem, name, styles);
      if (val < 0 || val == null) {
        val = elem.style[name];
      }
      if (rnumnonpx.test(val)) {
        return val;
      }
      valueIsBorderBox = isBorderBox && (jQuery.support.boxSizingReliable || val === elem.style[name]);
      val = parseFloat(val) || 0;
    }
    return val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? 'border' : 'content'), valueIsBorderBox, styles) + 'px';
  }
  function css_defaultDisplay(nodeName) {
    var doc = document, display = elemdisplay[nodeName];
    if (!display) {
      display = actualDisplay(nodeName, doc);
      if (display === 'none' || !display) {
        iframe = (iframe || jQuery('<iframe frameborder=\'0\' width=\'0\' height=\'0\'/>').css('cssText', 'display:block !important')).appendTo(doc.documentElement);
        doc = (iframe[0].contentWindow || iframe[0].contentDocument).document;
        doc.write('<!doctype html><html><body>');
        doc.close();
        display = actualDisplay(nodeName, doc);
        iframe.detach();
      }
      elemdisplay[nodeName] = display;
    }
    return display;
  }
  function actualDisplay(name, doc) {
    var elem = jQuery(doc.createElement(name)).appendTo(doc.body), display = jQuery.css(elem[0], 'display');
    elem.remove();
    return display;
  }
  jQuery.each([
    'height',
    'width'
  ], function (i, name) {
    jQuery.cssHooks[name] = {
      get: function (elem, computed, extra) {
        if (computed) {
          return elem.offsetWidth === 0 && rdisplayswap.test(jQuery.css(elem, 'display')) ? jQuery.swap(elem, cssShow, function () {
            return getWidthOrHeight(elem, name, extra);
          }) : getWidthOrHeight(elem, name, extra);
        }
      },
      set: function (elem, value, extra) {
        var styles = extra && getStyles(elem);
        return setPositiveNumber(elem, value, extra ? augmentWidthOrHeight(elem, name, extra, jQuery.support.boxSizing && jQuery.css(elem, 'boxSizing', false, styles) === 'border-box', styles) : 0);
      }
    };
  });
  jQuery(function () {
    if (!jQuery.support.reliableMarginRight) {
      jQuery.cssHooks.marginRight = {
        get: function (elem, computed) {
          if (computed) {
            return jQuery.swap(elem, { 'display': 'inline-block' }, curCSS, [
              elem,
              'marginRight'
            ]);
          }
        }
      };
    }
    if (!jQuery.support.pixelPosition && jQuery.fn.position) {
      jQuery.each([
        'top',
        'left'
      ], function (i, prop) {
        jQuery.cssHooks[prop] = {
          get: function (elem, computed) {
            if (computed) {
              computed = curCSS(elem, prop);
              return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + 'px' : computed;
            }
          }
        };
      });
    }
  });
  if (jQuery.expr && jQuery.expr.filters) {
    jQuery.expr.filters.hidden = function (elem) {
      return elem.offsetWidth <= 0 && elem.offsetHeight <= 0;
    };
    jQuery.expr.filters.visible = function (elem) {
      return !jQuery.expr.filters.hidden(elem);
    };
  }
  jQuery.each({
    margin: '',
    padding: '',
    border: 'Width'
  }, function (prefix, suffix) {
    jQuery.cssHooks[prefix + suffix] = {
      expand: function (value) {
        var i = 0, expanded = {}, parts = typeof value === 'string' ? value.split(' ') : [value];
        for (; i < 4; i++) {
          expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
        }
        return expanded;
      }
    };
    if (!rmargin.test(prefix)) {
      jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
    }
  });
  var r20 = /%20/g, rbracket = /\[\]$/, rCRLF = /\r?\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i, rsubmittable = /^(?:input|select|textarea|keygen)/i;
  jQuery.fn.extend({
    serialize: function () {
      return jQuery.param(this.serializeArray());
    },
    serializeArray: function () {
      return this.map(function () {
        var elements = jQuery.prop(this, 'elements');
        return elements ? jQuery.makeArray(elements) : this;
      }).filter(function () {
        var type = this.type;
        return this.name && !jQuery(this).is(':disabled') && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !manipulation_rcheckableType.test(type));
      }).map(function (i, elem) {
        var val = jQuery(this).val();
        return val == null ? null : jQuery.isArray(val) ? jQuery.map(val, function (val) {
          return {
            name: elem.name,
            value: val.replace(rCRLF, '\r\n')
          };
        }) : {
          name: elem.name,
          value: val.replace(rCRLF, '\r\n')
        };
      }).get();
    }
  });
  jQuery.param = function (a, traditional) {
    var prefix, s = [], add = function (key, value) {
        value = jQuery.isFunction(value) ? value() : value == null ? '' : value;
        s[s.length] = encodeURIComponent(key) + '=' + encodeURIComponent(value);
      };
    if (traditional === undefined) {
      traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
    }
    if (jQuery.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {
      jQuery.each(a, function () {
        add(this.name, this.value);
      });
    } else {
      for (prefix in a) {
        buildParams(prefix, a[prefix], traditional, add);
      }
    }
    return s.join('&').replace(r20, '+');
  };
  function buildParams(prefix, obj, traditional, add) {
    var name;
    if (jQuery.isArray(obj)) {
      jQuery.each(obj, function (i, v) {
        if (traditional || rbracket.test(prefix)) {
          add(prefix, v);
        } else {
          buildParams(prefix + '[' + (typeof v === 'object' ? i : '') + ']', v, traditional, add);
        }
      });
    } else if (!traditional && jQuery.type(obj) === 'object') {
      for (name in obj) {
        buildParams(prefix + '[' + name + ']', obj[name], traditional, add);
      }
    } else {
      add(prefix, obj);
    }
  }
  jQuery.each(('blur focus focusin focusout load resize scroll unload click dblclick ' + 'mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave ' + 'change select submit keydown keypress keyup error contextmenu').split(' '), function (i, name) {
    jQuery.fn[name] = function (data, fn) {
      return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
    };
  });
  jQuery.fn.extend({
    hover: function (fnOver, fnOut) {
      return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
    },
    bind: function (types, data, fn) {
      return this.on(types, null, data, fn);
    },
    unbind: function (types, fn) {
      return this.off(types, null, fn);
    },
    delegate: function (selector, types, data, fn) {
      return this.on(types, selector, data, fn);
    },
    undelegate: function (selector, types, fn) {
      return arguments.length === 1 ? this.off(selector, '**') : this.off(types, selector || '**', fn);
    }
  });
  var ajaxLocParts, ajaxLocation, ajax_nonce = jQuery.now(), ajax_rquery = /\?/, rhash = /#.*$/, rts = /([?&])_=[^&]*/, rheaders = /^(.*?):[ \t]*([^\r\n]*)$/gm, rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/, rprotocol = /^\/\//, rurl = /^([\w.+-]+:)(?:\/\/([^\/?#:]*)(?::(\d+)|)|)/, _load = jQuery.fn.load, prefilters = {}, transports = {}, allTypes = '*/'.concat('*');
  try {
    ajaxLocation = location.href;
  } catch (e) {
    ajaxLocation = document.createElement('a');
    ajaxLocation.href = '';
    ajaxLocation = ajaxLocation.href;
  }
  ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [];
  function addToPrefiltersOrTransports(structure) {
    return function (dataTypeExpression, func) {
      if (typeof dataTypeExpression !== 'string') {
        func = dataTypeExpression;
        dataTypeExpression = '*';
      }
      var dataType, i = 0, dataTypes = dataTypeExpression.toLowerCase().match(core_rnotwhite) || [];
      if (jQuery.isFunction(func)) {
        while (dataType = dataTypes[i++]) {
          if (dataType[0] === '+') {
            dataType = dataType.slice(1) || '*';
            (structure[dataType] = structure[dataType] || []).unshift(func);
          } else {
            (structure[dataType] = structure[dataType] || []).push(func);
          }
        }
      }
    };
  }
  function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
    var inspected = {}, seekingTransport = structure === transports;
    function inspect(dataType) {
      var selected;
      inspected[dataType] = true;
      jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {
        var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
        if (typeof dataTypeOrTransport === 'string' && !seekingTransport && !inspected[dataTypeOrTransport]) {
          options.dataTypes.unshift(dataTypeOrTransport);
          inspect(dataTypeOrTransport);
          return false;
        } else if (seekingTransport) {
          return !(selected = dataTypeOrTransport);
        }
      });
      return selected;
    }
    return inspect(options.dataTypes[0]) || !inspected['*'] && inspect('*');
  }
  function ajaxExtend(target, src) {
    var key, deep, flatOptions = jQuery.ajaxSettings.flatOptions || {};
    for (key in src) {
      if (src[key] !== undefined) {
        (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
      }
    }
    if (deep) {
      jQuery.extend(true, target, deep);
    }
    return target;
  }
  jQuery.fn.load = function (url, params, callback) {
    if (typeof url !== 'string' && _load) {
      return _load.apply(this, arguments);
    }
    var selector, type, response, self = this, off = url.indexOf(' ');
    if (off >= 0) {
      selector = url.slice(off);
      url = url.slice(0, off);
    }
    if (jQuery.isFunction(params)) {
      callback = params;
      params = undefined;
    } else if (params && typeof params === 'object') {
      type = 'POST';
    }
    if (self.length > 0) {
      jQuery.ajax({
        url: url,
        type: type,
        dataType: 'html',
        data: params
      }).done(function (responseText) {
        response = arguments;
        self.html(selector ? jQuery('<div>').append(jQuery.parseHTML(responseText)).find(selector) : responseText);
      }).complete(callback && function (jqXHR, status) {
        self.each(callback, response || [
          jqXHR.responseText,
          status,
          jqXHR
        ]);
      });
    }
    return this;
  };
  jQuery.each([
    'ajaxStart',
    'ajaxStop',
    'ajaxComplete',
    'ajaxError',
    'ajaxSuccess',
    'ajaxSend'
  ], function (i, type) {
    jQuery.fn[type] = function (fn) {
      return this.on(type, fn);
    };
  });
  jQuery.extend({
    active: 0,
    lastModified: {},
    etag: {},
    ajaxSettings: {
      url: ajaxLocation,
      type: 'GET',
      isLocal: rlocalProtocol.test(ajaxLocParts[1]),
      global: true,
      processData: true,
      async: true,
      contentType: 'application/x-www-form-urlencoded; charset=UTF-8',
      accepts: {
        '*': allTypes,
        text: 'text/plain',
        html: 'text/html',
        xml: 'application/xml, text/xml',
        json: 'application/json, text/javascript'
      },
      contents: {
        xml: /xml/,
        html: /html/,
        json: /json/
      },
      responseFields: {
        xml: 'responseXML',
        text: 'responseText',
        json: 'responseJSON'
      },
      converters: {
        '* text': String,
        'text html': true,
        'text json': jQuery.parseJSON,
        'text xml': jQuery.parseXML
      },
      flatOptions: {
        url: true,
        context: true
      }
    },
    ajaxSetup: function (target, settings) {
      return settings ? ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : ajaxExtend(jQuery.ajaxSettings, target);
    },
    ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
    ajaxTransport: addToPrefiltersOrTransports(transports),
    ajax: function (url, options) {
      if (typeof url === 'object') {
        options = url;
        url = undefined;
      }
      options = options || {};
      var transport, cacheURL, responseHeadersString, responseHeaders, timeoutTimer, parts, fireGlobals, i, s = jQuery.ajaxSetup({}, options), callbackContext = s.context || s, globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event, deferred = jQuery.Deferred(), completeDeferred = jQuery.Callbacks('once memory'), statusCode = s.statusCode || {}, requestHeaders = {}, requestHeadersNames = {}, state = 0, strAbort = 'canceled', jqXHR = {
          readyState: 0,
          getResponseHeader: function (key) {
            var match;
            if (state === 2) {
              if (!responseHeaders) {
                responseHeaders = {};
                while (match = rheaders.exec(responseHeadersString)) {
                  responseHeaders[match[1].toLowerCase()] = match[2];
                }
              }
              match = responseHeaders[key.toLowerCase()];
            }
            return match == null ? null : match;
          },
          getAllResponseHeaders: function () {
            return state === 2 ? responseHeadersString : null;
          },
          setRequestHeader: function (name, value) {
            var lname = name.toLowerCase();
            if (!state) {
              name = requestHeadersNames[lname] = requestHeadersNames[lname] || name;
              requestHeaders[name] = value;
            }
            return this;
          },
          overrideMimeType: function (type) {
            if (!state) {
              s.mimeType = type;
            }
            return this;
          },
          statusCode: function (map) {
            var code;
            if (map) {
              if (state < 2) {
                for (code in map) {
                  statusCode[code] = [
                    statusCode[code],
                    map[code]
                  ];
                }
              } else {
                jqXHR.always(map[jqXHR.status]);
              }
            }
            return this;
          },
          abort: function (statusText) {
            var finalText = statusText || strAbort;
            if (transport) {
              transport.abort(finalText);
            }
            done(0, finalText);
            return this;
          }
        };
      deferred.promise(jqXHR).complete = completeDeferred.add;
      jqXHR.success = jqXHR.done;
      jqXHR.error = jqXHR.fail;
      s.url = ((url || s.url || ajaxLocation) + '').replace(rhash, '').replace(rprotocol, ajaxLocParts[1] + '//');
      s.type = options.method || options.type || s.method || s.type;
      s.dataTypes = jQuery.trim(s.dataType || '*').toLowerCase().match(core_rnotwhite) || [''];
      if (s.crossDomain == null) {
        parts = rurl.exec(s.url.toLowerCase());
        s.crossDomain = !!(parts && (parts[1] !== ajaxLocParts[1] || parts[2] !== ajaxLocParts[2] || (parts[3] || (parts[1] === 'http:' ? '80' : '443')) !== (ajaxLocParts[3] || (ajaxLocParts[1] === 'http:' ? '80' : '443'))));
      }
      if (s.data && s.processData && typeof s.data !== 'string') {
        s.data = jQuery.param(s.data, s.traditional);
      }
      inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);
      if (state === 2) {
        return jqXHR;
      }
      fireGlobals = s.global;
      if (fireGlobals && jQuery.active++ === 0) {
        jQuery.event.trigger('ajaxStart');
      }
      s.type = s.type.toUpperCase();
      s.hasContent = !rnoContent.test(s.type);
      cacheURL = s.url;
      if (!s.hasContent) {
        if (s.data) {
          cacheURL = s.url += (ajax_rquery.test(cacheURL) ? '&' : '?') + s.data;
          delete s.data;
        }
        if (s.cache === false) {
          s.url = rts.test(cacheURL) ? cacheURL.replace(rts, '$1_=' + ajax_nonce++) : cacheURL + (ajax_rquery.test(cacheURL) ? '&' : '?') + '_=' + ajax_nonce++;
        }
      }
      if (s.ifModified) {
        if (jQuery.lastModified[cacheURL]) {
          jqXHR.setRequestHeader('If-Modified-Since', jQuery.lastModified[cacheURL]);
        }
        if (jQuery.etag[cacheURL]) {
          jqXHR.setRequestHeader('If-None-Match', jQuery.etag[cacheURL]);
        }
      }
      if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
        jqXHR.setRequestHeader('Content-Type', s.contentType);
      }
      jqXHR.setRequestHeader('Accept', s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== '*' ? ', ' + allTypes + '; q=0.01' : '') : s.accepts['*']);
      for (i in s.headers) {
        jqXHR.setRequestHeader(i, s.headers[i]);
      }
      if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {
        return jqXHR.abort();
      }
      strAbort = 'abort';
      for (i in {
          success: 1,
          error: 1,
          complete: 1
        }) {
        jqXHR[i](s[i]);
      }
      transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);
      if (!transport) {
        done(-1, 'No Transport');
      } else {
        jqXHR.readyState = 1;
        if (fireGlobals) {
          globalEventContext.trigger('ajaxSend', [
            jqXHR,
            s
          ]);
        }
        if (s.async && s.timeout > 0) {
          timeoutTimer = setTimeout(function () {
            jqXHR.abort('timeout');
          }, s.timeout);
        }
        try {
          state = 1;
          transport.send(requestHeaders, done);
        } catch (e) {
          if (state < 2) {
            done(-1, e);
          } else {
            throw e;
          }
        }
      }
      function done(status, nativeStatusText, responses, headers) {
        var isSuccess, success, error, response, modified, statusText = nativeStatusText;
        if (state === 2) {
          return;
        }
        state = 2;
        if (timeoutTimer) {
          clearTimeout(timeoutTimer);
        }
        transport = undefined;
        responseHeadersString = headers || '';
        jqXHR.readyState = status > 0 ? 4 : 0;
        isSuccess = status >= 200 && status < 300 || status === 304;
        if (responses) {
          response = ajaxHandleResponses(s, jqXHR, responses);
        }
        response = ajaxConvert(s, response, jqXHR, isSuccess);
        if (isSuccess) {
          if (s.ifModified) {
            modified = jqXHR.getResponseHeader('Last-Modified');
            if (modified) {
              jQuery.lastModified[cacheURL] = modified;
            }
            modified = jqXHR.getResponseHeader('etag');
            if (modified) {
              jQuery.etag[cacheURL] = modified;
            }
          }
          if (status === 204 || s.type === 'HEAD') {
            statusText = 'nocontent';
          } else if (status === 304) {
            statusText = 'notmodified';
          } else {
            statusText = response.state;
            success = response.data;
            error = response.error;
            isSuccess = !error;
          }
        } else {
          error = statusText;
          if (status || !statusText) {
            statusText = 'error';
            if (status < 0) {
              status = 0;
            }
          }
        }
        jqXHR.status = status;
        jqXHR.statusText = (nativeStatusText || statusText) + '';
        if (isSuccess) {
          deferred.resolveWith(callbackContext, [
            success,
            statusText,
            jqXHR
          ]);
        } else {
          deferred.rejectWith(callbackContext, [
            jqXHR,
            statusText,
            error
          ]);
        }
        jqXHR.statusCode(statusCode);
        statusCode = undefined;
        if (fireGlobals) {
          globalEventContext.trigger(isSuccess ? 'ajaxSuccess' : 'ajaxError', [
            jqXHR,
            s,
            isSuccess ? success : error
          ]);
        }
        completeDeferred.fireWith(callbackContext, [
          jqXHR,
          statusText
        ]);
        if (fireGlobals) {
          globalEventContext.trigger('ajaxComplete', [
            jqXHR,
            s
          ]);
          if (!--jQuery.active) {
            jQuery.event.trigger('ajaxStop');
          }
        }
      }
      return jqXHR;
    },
    getJSON: function (url, data, callback) {
      return jQuery.get(url, data, callback, 'json');
    },
    getScript: function (url, callback) {
      return jQuery.get(url, undefined, callback, 'script');
    }
  });
  jQuery.each([
    'get',
    'post'
  ], function (i, method) {
    jQuery[method] = function (url, data, callback, type) {
      if (jQuery.isFunction(data)) {
        type = type || callback;
        callback = data;
        data = undefined;
      }
      return jQuery.ajax({
        url: url,
        type: method,
        dataType: type,
        data: data,
        success: callback
      });
    };
  });
  function ajaxHandleResponses(s, jqXHR, responses) {
    var ct, type, finalDataType, firstDataType, contents = s.contents, dataTypes = s.dataTypes;
    while (dataTypes[0] === '*') {
      dataTypes.shift();
      if (ct === undefined) {
        ct = s.mimeType || jqXHR.getResponseHeader('Content-Type');
      }
    }
    if (ct) {
      for (type in contents) {
        if (contents[type] && contents[type].test(ct)) {
          dataTypes.unshift(type);
          break;
        }
      }
    }
    if (dataTypes[0] in responses) {
      finalDataType = dataTypes[0];
    } else {
      for (type in responses) {
        if (!dataTypes[0] || s.converters[type + ' ' + dataTypes[0]]) {
          finalDataType = type;
          break;
        }
        if (!firstDataType) {
          firstDataType = type;
        }
      }
      finalDataType = finalDataType || firstDataType;
    }
    if (finalDataType) {
      if (finalDataType !== dataTypes[0]) {
        dataTypes.unshift(finalDataType);
      }
      return responses[finalDataType];
    }
  }
  function ajaxConvert(s, response, jqXHR, isSuccess) {
    var conv2, current, conv, tmp, prev, converters = {}, dataTypes = s.dataTypes.slice();
    if (dataTypes[1]) {
      for (conv in s.converters) {
        converters[conv.toLowerCase()] = s.converters[conv];
      }
    }
    current = dataTypes.shift();
    while (current) {
      if (s.responseFields[current]) {
        jqXHR[s.responseFields[current]] = response;
      }
      if (!prev && isSuccess && s.dataFilter) {
        response = s.dataFilter(response, s.dataType);
      }
      prev = current;
      current = dataTypes.shift();
      if (current) {
        if (current === '*') {
          current = prev;
        } else if (prev !== '*' && prev !== current) {
          conv = converters[prev + ' ' + current] || converters['* ' + current];
          if (!conv) {
            for (conv2 in converters) {
              tmp = conv2.split(' ');
              if (tmp[1] === current) {
                conv = converters[prev + ' ' + tmp[0]] || converters['* ' + tmp[0]];
                if (conv) {
                  if (conv === true) {
                    conv = converters[conv2];
                  } else if (converters[conv2] !== true) {
                    current = tmp[0];
                    dataTypes.unshift(tmp[1]);
                  }
                  break;
                }
              }
            }
          }
          if (conv !== true) {
            if (conv && s['throws']) {
              response = conv(response);
            } else {
              try {
                response = conv(response);
              } catch (e) {
                return {
                  state: 'parsererror',
                  error: conv ? e : 'No conversion from ' + prev + ' to ' + current
                };
              }
            }
          }
        }
      }
    }
    return {
      state: 'success',
      data: response
    };
  }
  jQuery.ajaxSetup({
    accepts: { script: 'text/javascript, application/javascript, application/ecmascript, application/x-ecmascript' },
    contents: { script: /(?:java|ecma)script/ },
    converters: {
      'text script': function (text) {
        jQuery.globalEval(text);
        return text;
      }
    }
  });
  jQuery.ajaxPrefilter('script', function (s) {
    if (s.cache === undefined) {
      s.cache = false;
    }
    if (s.crossDomain) {
      s.type = 'GET';
    }
  });
  jQuery.ajaxTransport('script', function (s) {
    if (s.crossDomain) {
      var script, callback;
      return {
        send: function (_, complete) {
          script = jQuery('<script>').prop({
            async: true,
            charset: s.scriptCharset,
            src: s.url
          }).on('load error', callback = function (evt) {
            script.remove();
            callback = null;
            if (evt) {
              complete(evt.type === 'error' ? 404 : 200, evt.type);
            }
          });
          document.head.appendChild(script[0]);
        },
        abort: function () {
          if (callback) {
            callback();
          }
        }
      };
    }
  });
  var oldCallbacks = [], rjsonp = /(=)\?(?=&|$)|\?\?/;
  jQuery.ajaxSetup({
    jsonp: 'callback',
    jsonpCallback: function () {
      var callback = oldCallbacks.pop() || jQuery.expando + '_' + ajax_nonce++;
      this[callback] = true;
      return callback;
    }
  });
  jQuery.ajaxPrefilter('json jsonp', function (s, originalSettings, jqXHR) {
    var callbackName, overwritten, responseContainer, jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? 'url' : typeof s.data === 'string' && !(s.contentType || '').indexOf('application/x-www-form-urlencoded') && rjsonp.test(s.data) && 'data');
    if (jsonProp || s.dataTypes[0] === 'jsonp') {
      callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;
      if (jsonProp) {
        s[jsonProp] = s[jsonProp].replace(rjsonp, '$1' + callbackName);
      } else if (s.jsonp !== false) {
        s.url += (ajax_rquery.test(s.url) ? '&' : '?') + s.jsonp + '=' + callbackName;
      }
      s.converters['script json'] = function () {
        if (!responseContainer) {
          jQuery.error(callbackName + ' was not called');
        }
        return responseContainer[0];
      };
      s.dataTypes[0] = 'json';
      overwritten = window[callbackName];
      window[callbackName] = function () {
        responseContainer = arguments;
      };
      jqXHR.always(function () {
        window[callbackName] = overwritten;
        if (s[callbackName]) {
          s.jsonpCallback = originalSettings.jsonpCallback;
          oldCallbacks.push(callbackName);
        }
        if (responseContainer && jQuery.isFunction(overwritten)) {
          overwritten(responseContainer[0]);
        }
        responseContainer = overwritten = undefined;
      });
      return 'script';
    }
  });
  jQuery.ajaxSettings.xhr = function () {
    try {
      return new XMLHttpRequest();
    } catch (e) {
    }
  };
  var xhrSupported = jQuery.ajaxSettings.xhr(), xhrSuccessStatus = {
      0: 200,
      1223: 204
    }, xhrId = 0, xhrCallbacks = {};
  if (window.ActiveXObject) {
    jQuery(window).on('unload', function () {
      for (var key in xhrCallbacks) {
        xhrCallbacks[key]();
      }
      xhrCallbacks = undefined;
    });
  }
  jQuery.support.cors = !!xhrSupported && 'withCredentials' in xhrSupported;
  jQuery.support.ajax = xhrSupported = !!xhrSupported;
  jQuery.ajaxTransport(function (options) {
    var callback;
    if (jQuery.support.cors || xhrSupported && !options.crossDomain) {
      return {
        send: function (headers, complete) {
          var i, id, xhr = options.xhr();
          xhr.open(options.type, options.url, options.async, options.username, options.password);
          if (options.xhrFields) {
            for (i in options.xhrFields) {
              xhr[i] = options.xhrFields[i];
            }
          }
          if (options.mimeType && xhr.overrideMimeType) {
            xhr.overrideMimeType(options.mimeType);
          }
          if (!options.crossDomain && !headers['X-Requested-With']) {
            headers['X-Requested-With'] = 'XMLHttpRequest';
          }
          for (i in headers) {
            xhr.setRequestHeader(i, headers[i]);
          }
          callback = function (type) {
            return function () {
              if (callback) {
                delete xhrCallbacks[id];
                callback = xhr.onload = xhr.onerror = null;
                if (type === 'abort') {
                  xhr.abort();
                } else if (type === 'error') {
                  complete(xhr.status || 404, xhr.statusText);
                } else {
                  complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, typeof xhr.responseText === 'string' ? { text: xhr.responseText } : undefined, xhr.getAllResponseHeaders());
                }
              }
            };
          };
          xhr.onload = callback();
          xhr.onerror = callback('error');
          callback = xhrCallbacks[id = xhrId++] = callback('abort');
          xhr.send(options.hasContent && options.data || null);
        },
        abort: function () {
          if (callback) {
            callback();
          }
        }
      };
    }
  });
  var fxNow, timerId, rfxtypes = /^(?:toggle|show|hide)$/, rfxnum = new RegExp('^(?:([+-])=|)(' + core_pnum + ')([a-z%]*)$', 'i'), rrun = /queueHooks$/, animationPrefilters = [defaultPrefilter], tweeners = {
      '*': [function (prop, value) {
          var tween = this.createTween(prop, value), target = tween.cur(), parts = rfxnum.exec(value), unit = parts && parts[3] || (jQuery.cssNumber[prop] ? '' : 'px'), start = (jQuery.cssNumber[prop] || unit !== 'px' && +target) && rfxnum.exec(jQuery.css(tween.elem, prop)), scale = 1, maxIterations = 20;
          if (start && start[3] !== unit) {
            unit = unit || start[3];
            parts = parts || [];
            start = +target || 1;
            do {
              scale = scale || '.5';
              start = start / scale;
              jQuery.style(tween.elem, prop, start + unit);
            } while (scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations);
          }
          if (parts) {
            start = tween.start = +start || +target || 0;
            tween.unit = unit;
            tween.end = parts[1] ? start + (parts[1] + 1) * parts[2] : +parts[2];
          }
          return tween;
        }]
    };
  function createFxNow() {
    setTimeout(function () {
      fxNow = undefined;
    });
    return fxNow = jQuery.now();
  }
  function createTween(value, prop, animation) {
    var tween, collection = (tweeners[prop] || []).concat(tweeners['*']), index = 0, length = collection.length;
    for (; index < length; index++) {
      if (tween = collection[index].call(animation, prop, value)) {
        return tween;
      }
    }
  }
  function Animation(elem, properties, options) {
    var result, stopped, index = 0, length = animationPrefilters.length, deferred = jQuery.Deferred().always(function () {
        delete tick.elem;
      }), tick = function () {
        if (stopped) {
          return false;
        }
        var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), temp = remaining / animation.duration || 0, percent = 1 - temp, index = 0, length = animation.tweens.length;
        for (; index < length; index++) {
          animation.tweens[index].run(percent);
        }
        deferred.notifyWith(elem, [
          animation,
          percent,
          remaining
        ]);
        if (percent < 1 && length) {
          return remaining;
        } else {
          deferred.resolveWith(elem, [animation]);
          return false;
        }
      }, animation = deferred.promise({
        elem: elem,
        props: jQuery.extend({}, properties),
        opts: jQuery.extend(true, { specialEasing: {} }, options),
        originalProperties: properties,
        originalOptions: options,
        startTime: fxNow || createFxNow(),
        duration: options.duration,
        tweens: [],
        createTween: function (prop, end) {
          var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
          animation.tweens.push(tween);
          return tween;
        },
        stop: function (gotoEnd) {
          var index = 0, length = gotoEnd ? animation.tweens.length : 0;
          if (stopped) {
            return this;
          }
          stopped = true;
          for (; index < length; index++) {
            animation.tweens[index].run(1);
          }
          if (gotoEnd) {
            deferred.resolveWith(elem, [
              animation,
              gotoEnd
            ]);
          } else {
            deferred.rejectWith(elem, [
              animation,
              gotoEnd
            ]);
          }
          return this;
        }
      }), props = animation.props;
    propFilter(props, animation.opts.specialEasing);
    for (; index < length; index++) {
      result = animationPrefilters[index].call(animation, elem, props, animation.opts);
      if (result) {
        return result;
      }
    }
    jQuery.map(props, createTween, animation);
    if (jQuery.isFunction(animation.opts.start)) {
      animation.opts.start.call(elem, animation);
    }
    jQuery.fx.timer(jQuery.extend(tick, {
      elem: elem,
      anim: animation,
      queue: animation.opts.queue
    }));
    return animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
  }
  function propFilter(props, specialEasing) {
    var index, name, easing, value, hooks;
    for (index in props) {
      name = jQuery.camelCase(index);
      easing = specialEasing[name];
      value = props[index];
      if (jQuery.isArray(value)) {
        easing = value[1];
        value = props[index] = value[0];
      }
      if (index !== name) {
        props[name] = value;
        delete props[index];
      }
      hooks = jQuery.cssHooks[name];
      if (hooks && 'expand' in hooks) {
        value = hooks.expand(value);
        delete props[name];
        for (index in value) {
          if (!(index in props)) {
            props[index] = value[index];
            specialEasing[index] = easing;
          }
        }
      } else {
        specialEasing[name] = easing;
      }
    }
  }
  jQuery.Animation = jQuery.extend(Animation, {
    tweener: function (props, callback) {
      if (jQuery.isFunction(props)) {
        callback = props;
        props = ['*'];
      } else {
        props = props.split(' ');
      }
      var prop, index = 0, length = props.length;
      for (; index < length; index++) {
        prop = props[index];
        tweeners[prop] = tweeners[prop] || [];
        tweeners[prop].unshift(callback);
      }
    },
    prefilter: function (callback, prepend) {
      if (prepend) {
        animationPrefilters.unshift(callback);
      } else {
        animationPrefilters.push(callback);
      }
    }
  });
  function defaultPrefilter(elem, props, opts) {
    var prop, value, toggle, tween, hooks, oldfire, anim = this, orig = {}, style = elem.style, hidden = elem.nodeType && isHidden(elem), dataShow = data_priv.get(elem, 'fxshow');
    if (!opts.queue) {
      hooks = jQuery._queueHooks(elem, 'fx');
      if (hooks.unqueued == null) {
        hooks.unqueued = 0;
        oldfire = hooks.empty.fire;
        hooks.empty.fire = function () {
          if (!hooks.unqueued) {
            oldfire();
          }
        };
      }
      hooks.unqueued++;
      anim.always(function () {
        anim.always(function () {
          hooks.unqueued--;
          if (!jQuery.queue(elem, 'fx').length) {
            hooks.empty.fire();
          }
        });
      });
    }
    if (elem.nodeType === 1 && ('height' in props || 'width' in props)) {
      opts.overflow = [
        style.overflow,
        style.overflowX,
        style.overflowY
      ];
      if (jQuery.css(elem, 'display') === 'inline' && jQuery.css(elem, 'float') === 'none') {
        style.display = 'inline-block';
      }
    }
    if (opts.overflow) {
      style.overflow = 'hidden';
      anim.always(function () {
        style.overflow = opts.overflow[0];
        style.overflowX = opts.overflow[1];
        style.overflowY = opts.overflow[2];
      });
    }
    for (prop in props) {
      value = props[prop];
      if (rfxtypes.exec(value)) {
        delete props[prop];
        toggle = toggle || value === 'toggle';
        if (value === (hidden ? 'hide' : 'show')) {
          if (value === 'show' && dataShow && dataShow[prop] !== undefined) {
            hidden = true;
          } else {
            continue;
          }
        }
        orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
      }
    }
    if (!jQuery.isEmptyObject(orig)) {
      if (dataShow) {
        if ('hidden' in dataShow) {
          hidden = dataShow.hidden;
        }
      } else {
        dataShow = data_priv.access(elem, 'fxshow', {});
      }
      if (toggle) {
        dataShow.hidden = !hidden;
      }
      if (hidden) {
        jQuery(elem).show();
      } else {
        anim.done(function () {
          jQuery(elem).hide();
        });
      }
      anim.done(function () {
        var prop;
        data_priv.remove(elem, 'fxshow');
        for (prop in orig) {
          jQuery.style(elem, prop, orig[prop]);
        }
      });
      for (prop in orig) {
        tween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
        if (!(prop in dataShow)) {
          dataShow[prop] = tween.start;
          if (hidden) {
            tween.end = tween.start;
            tween.start = prop === 'width' || prop === 'height' ? 1 : 0;
          }
        }
      }
    }
  }
  function Tween(elem, options, prop, end, easing) {
    return new Tween.prototype.init(elem, options, prop, end, easing);
  }
  jQuery.Tween = Tween;
  Tween.prototype = {
    constructor: Tween,
    init: function (elem, options, prop, end, easing, unit) {
      this.elem = elem;
      this.prop = prop;
      this.easing = easing || 'swing';
      this.options = options;
      this.start = this.now = this.cur();
      this.end = end;
      this.unit = unit || (jQuery.cssNumber[prop] ? '' : 'px');
    },
    cur: function () {
      var hooks = Tween.propHooks[this.prop];
      return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
    },
    run: function (percent) {
      var eased, hooks = Tween.propHooks[this.prop];
      if (this.options.duration) {
        this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
      } else {
        this.pos = eased = percent;
      }
      this.now = (this.end - this.start) * eased + this.start;
      if (this.options.step) {
        this.options.step.call(this.elem, this.now, this);
      }
      if (hooks && hooks.set) {
        hooks.set(this);
      } else {
        Tween.propHooks._default.set(this);
      }
      return this;
    }
  };
  Tween.prototype.init.prototype = Tween.prototype;
  Tween.propHooks = {
    _default: {
      get: function (tween) {
        var result;
        if (tween.elem[tween.prop] != null && (!tween.elem.style || tween.elem.style[tween.prop] == null)) {
          return tween.elem[tween.prop];
        }
        result = jQuery.css(tween.elem, tween.prop, '');
        return !result || result === 'auto' ? 0 : result;
      },
      set: function (tween) {
        if (jQuery.fx.step[tween.prop]) {
          jQuery.fx.step[tween.prop](tween);
        } else if (tween.elem.style && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {
          jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
        } else {
          tween.elem[tween.prop] = tween.now;
        }
      }
    }
  };
  Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
    set: function (tween) {
      if (tween.elem.nodeType && tween.elem.parentNode) {
        tween.elem[tween.prop] = tween.now;
      }
    }
  };
  jQuery.each([
    'toggle',
    'show',
    'hide'
  ], function (i, name) {
    var cssFn = jQuery.fn[name];
    jQuery.fn[name] = function (speed, easing, callback) {
      return speed == null || typeof speed === 'boolean' ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
    };
  });
  jQuery.fn.extend({
    fadeTo: function (speed, to, easing, callback) {
      return this.filter(isHidden).css('opacity', 0).show().end().animate({ opacity: to }, speed, easing, callback);
    },
    animate: function (prop, speed, easing, callback) {
      var empty = jQuery.isEmptyObject(prop), optall = jQuery.speed(speed, easing, callback), doAnimation = function () {
          var anim = Animation(this, jQuery.extend({}, prop), optall);
          if (empty || data_priv.get(this, 'finish')) {
            anim.stop(true);
          }
        };
      doAnimation.finish = doAnimation;
      return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
    },
    stop: function (type, clearQueue, gotoEnd) {
      var stopQueue = function (hooks) {
        var stop = hooks.stop;
        delete hooks.stop;
        stop(gotoEnd);
      };
      if (typeof type !== 'string') {
        gotoEnd = clearQueue;
        clearQueue = type;
        type = undefined;
      }
      if (clearQueue && type !== false) {
        this.queue(type || 'fx', []);
      }
      return this.each(function () {
        var dequeue = true, index = type != null && type + 'queueHooks', timers = jQuery.timers, data = data_priv.get(this);
        if (index) {
          if (data[index] && data[index].stop) {
            stopQueue(data[index]);
          }
        } else {
          for (index in data) {
            if (data[index] && data[index].stop && rrun.test(index)) {
              stopQueue(data[index]);
            }
          }
        }
        for (index = timers.length; index--;) {
          if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
            timers[index].anim.stop(gotoEnd);
            dequeue = false;
            timers.splice(index, 1);
          }
        }
        if (dequeue || !gotoEnd) {
          jQuery.dequeue(this, type);
        }
      });
    },
    finish: function (type) {
      if (type !== false) {
        type = type || 'fx';
      }
      return this.each(function () {
        var index, data = data_priv.get(this), queue = data[type + 'queue'], hooks = data[type + 'queueHooks'], timers = jQuery.timers, length = queue ? queue.length : 0;
        data.finish = true;
        jQuery.queue(this, type, []);
        if (hooks && hooks.stop) {
          hooks.stop.call(this, true);
        }
        for (index = timers.length; index--;) {
          if (timers[index].elem === this && timers[index].queue === type) {
            timers[index].anim.stop(true);
            timers.splice(index, 1);
          }
        }
        for (index = 0; index < length; index++) {
          if (queue[index] && queue[index].finish) {
            queue[index].finish.call(this);
          }
        }
        delete data.finish;
      });
    }
  });
  function genFx(type, includeWidth) {
    var which, attrs = { height: type }, i = 0;
    includeWidth = includeWidth ? 1 : 0;
    for (; i < 4; i += 2 - includeWidth) {
      which = cssExpand[i];
      attrs['margin' + which] = attrs['padding' + which] = type;
    }
    if (includeWidth) {
      attrs.opacity = attrs.width = type;
    }
    return attrs;
  }
  jQuery.each({
    slideDown: genFx('show'),
    slideUp: genFx('hide'),
    slideToggle: genFx('toggle'),
    fadeIn: { opacity: 'show' },
    fadeOut: { opacity: 'hide' },
    fadeToggle: { opacity: 'toggle' }
  }, function (name, props) {
    jQuery.fn[name] = function (speed, easing, callback) {
      return this.animate(props, speed, easing, callback);
    };
  });
  jQuery.speed = function (speed, easing, fn) {
    var opt = speed && typeof speed === 'object' ? jQuery.extend({}, speed) : {
        complete: fn || !fn && easing || jQuery.isFunction(speed) && speed,
        duration: speed,
        easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
      };
    opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === 'number' ? opt.duration : opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default;
    if (opt.queue == null || opt.queue === true) {
      opt.queue = 'fx';
    }
    opt.old = opt.complete;
    opt.complete = function () {
      if (jQuery.isFunction(opt.old)) {
        opt.old.call(this);
      }
      if (opt.queue) {
        jQuery.dequeue(this, opt.queue);
      }
    };
    return opt;
  };
  jQuery.easing = {
    linear: function (p) {
      return p;
    },
    swing: function (p) {
      return 0.5 - Math.cos(p * Math.PI) / 2;
    }
  };
  jQuery.timers = [];
  jQuery.fx = Tween.prototype.init;
  jQuery.fx.tick = function () {
    var timer, timers = jQuery.timers, i = 0;
    fxNow = jQuery.now();
    for (; i < timers.length; i++) {
      timer = timers[i];
      if (!timer() && timers[i] === timer) {
        timers.splice(i--, 1);
      }
    }
    if (!timers.length) {
      jQuery.fx.stop();
    }
    fxNow = undefined;
  };
  jQuery.fx.timer = function (timer) {
    if (timer() && jQuery.timers.push(timer)) {
      jQuery.fx.start();
    }
  };
  jQuery.fx.interval = 13;
  jQuery.fx.start = function () {
    if (!timerId) {
      timerId = setInterval(jQuery.fx.tick, jQuery.fx.interval);
    }
  };
  jQuery.fx.stop = function () {
    clearInterval(timerId);
    timerId = null;
  };
  jQuery.fx.speeds = {
    slow: 600,
    fast: 200,
    _default: 400
  };
  jQuery.fx.step = {};
  if (jQuery.expr && jQuery.expr.filters) {
    jQuery.expr.filters.animated = function (elem) {
      return jQuery.grep(jQuery.timers, function (fn) {
        return elem === fn.elem;
      }).length;
    };
  }
  jQuery.fn.offset = function (options) {
    if (arguments.length) {
      return options === undefined ? this : this.each(function (i) {
        jQuery.offset.setOffset(this, options, i);
      });
    }
    var docElem, win, elem = this[0], box = {
        top: 0,
        left: 0
      }, doc = elem && elem.ownerDocument;
    if (!doc) {
      return;
    }
    docElem = doc.documentElement;
    if (!jQuery.contains(docElem, elem)) {
      return box;
    }
    if (typeof elem.getBoundingClientRect !== core_strundefined) {
      box = elem.getBoundingClientRect();
    }
    win = getWindow(doc);
    return {
      top: box.top + win.pageYOffset - docElem.clientTop,
      left: box.left + win.pageXOffset - docElem.clientLeft
    };
  };
  jQuery.offset = {
    setOffset: function (elem, options, i) {
      var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery.css(elem, 'position'), curElem = jQuery(elem), props = {};
      if (position === 'static') {
        elem.style.position = 'relative';
      }
      curOffset = curElem.offset();
      curCSSTop = jQuery.css(elem, 'top');
      curCSSLeft = jQuery.css(elem, 'left');
      calculatePosition = (position === 'absolute' || position === 'fixed') && (curCSSTop + curCSSLeft).indexOf('auto') > -1;
      if (calculatePosition) {
        curPosition = curElem.position();
        curTop = curPosition.top;
        curLeft = curPosition.left;
      } else {
        curTop = parseFloat(curCSSTop) || 0;
        curLeft = parseFloat(curCSSLeft) || 0;
      }
      if (jQuery.isFunction(options)) {
        options = options.call(elem, i, curOffset);
      }
      if (options.top != null) {
        props.top = options.top - curOffset.top + curTop;
      }
      if (options.left != null) {
        props.left = options.left - curOffset.left + curLeft;
      }
      if ('using' in options) {
        options.using.call(elem, props);
      } else {
        curElem.css(props);
      }
    }
  };
  jQuery.fn.extend({
    position: function () {
      if (!this[0]) {
        return;
      }
      var offsetParent, offset, elem = this[0], parentOffset = {
          top: 0,
          left: 0
        };
      if (jQuery.css(elem, 'position') === 'fixed') {
        offset = elem.getBoundingClientRect();
      } else {
        offsetParent = this.offsetParent();
        offset = this.offset();
        if (!jQuery.nodeName(offsetParent[0], 'html')) {
          parentOffset = offsetParent.offset();
        }
        parentOffset.top += jQuery.css(offsetParent[0], 'borderTopWidth', true);
        parentOffset.left += jQuery.css(offsetParent[0], 'borderLeftWidth', true);
      }
      return {
        top: offset.top - parentOffset.top - jQuery.css(elem, 'marginTop', true),
        left: offset.left - parentOffset.left - jQuery.css(elem, 'marginLeft', true)
      };
    },
    offsetParent: function () {
      return this.map(function () {
        var offsetParent = this.offsetParent || docElem;
        while (offsetParent && (!jQuery.nodeName(offsetParent, 'html') && jQuery.css(offsetParent, 'position') === 'static')) {
          offsetParent = offsetParent.offsetParent;
        }
        return offsetParent || docElem;
      });
    }
  });
  jQuery.each({
    scrollLeft: 'pageXOffset',
    scrollTop: 'pageYOffset'
  }, function (method, prop) {
    var top = 'pageYOffset' === prop;
    jQuery.fn[method] = function (val) {
      return jQuery.access(this, function (elem, method, val) {
        var win = getWindow(elem);
        if (val === undefined) {
          return win ? win[prop] : elem[method];
        }
        if (win) {
          win.scrollTo(!top ? val : window.pageXOffset, top ? val : window.pageYOffset);
        } else {
          elem[method] = val;
        }
      }, method, val, arguments.length, null);
    };
  });
  function getWindow(elem) {
    return jQuery.isWindow(elem) ? elem : elem.nodeType === 9 && elem.defaultView;
  }
  jQuery.each({
    Height: 'height',
    Width: 'width'
  }, function (name, type) {
    jQuery.each({
      padding: 'inner' + name,
      content: type,
      '': 'outer' + name
    }, function (defaultExtra, funcName) {
      jQuery.fn[funcName] = function (margin, value) {
        var chainable = arguments.length && (defaultExtra || typeof margin !== 'boolean'), extra = defaultExtra || (margin === true || value === true ? 'margin' : 'border');
        return jQuery.access(this, function (elem, type, value) {
          var doc;
          if (jQuery.isWindow(elem)) {
            return elem.document.documentElement['client' + name];
          }
          if (elem.nodeType === 9) {
            doc = elem.documentElement;
            return Math.max(elem.body['scroll' + name], doc['scroll' + name], elem.body['offset' + name], doc['offset' + name], doc['client' + name]);
          }
          return value === undefined ? jQuery.css(elem, type, extra) : jQuery.style(elem, type, value, extra);
        }, type, chainable ? margin : undefined, chainable, null);
      };
    });
  });
  jQuery.fn.size = function () {
    return this.length;
  };
  jQuery.fn.andSelf = jQuery.fn.addBack;
  if (typeof module === 'object' && module && typeof module.exports === 'object') {
    module.exports = jQuery;
  } else {
    if (typeof define === 'function' && define.amd) {
      define('jquery', [], function () {
        return jQuery;
      });
    }
  }
  if (typeof window === 'object' && typeof window.document === 'object') {
    window.jQuery = window.$ = jQuery;
  }
}(window));
var COMPILED = false;
var goog = goog || {};
goog.global = this;
goog.global.CLOSURE_DEFINES;
goog.exportPath_ = function (name, opt_object, opt_objectToExportTo) {
  var parts = name.split('.');
  var cur = opt_objectToExportTo || goog.global;
  if (!(parts[0] in cur) && cur.execScript) {
    cur.execScript('var ' + parts[0]);
  }
  for (var part; parts.length && (part = parts.shift());) {
    if (!parts.length && opt_object !== undefined) {
      cur[part] = opt_object;
    } else if (cur[part]) {
      cur = cur[part];
    } else {
      cur = cur[part] = {};
    }
  }
};
goog.define = function (name, defaultValue) {
  var value = defaultValue;
  if (!COMPILED) {
    if (goog.global.CLOSURE_DEFINES && Object.prototype.hasOwnProperty.call(goog.global.CLOSURE_DEFINES, name)) {
      value = goog.global.CLOSURE_DEFINES[name];
    }
  }
  goog.exportPath_(name, value);
};
goog.DEBUG = true;
goog.define('goog.LOCALE', 'en');
goog.define('goog.TRUSTED_SITE', true);
goog.provide = function (name) {
  if (!COMPILED) {
    if (goog.isProvided_(name)) {
      throw Error('Namespace "' + name + '" already declared.');
    }
    delete goog.implicitNamespaces_[name];
    var namespace = name;
    while (namespace = namespace.substring(0, namespace.lastIndexOf('.'))) {
      if (goog.getObjectByName(namespace)) {
        break;
      }
      goog.implicitNamespaces_[namespace] = true;
    }
  }
  goog.exportPath_(name);
};
goog.setTestOnly = function (opt_message) {
  if (COMPILED && !goog.DEBUG) {
    opt_message = opt_message || '';
    throw Error('Importing test-only code into non-debug environment' + opt_message ? ': ' + opt_message : '.');
  }
};
if (!COMPILED) {
  goog.isProvided_ = function (name) {
    return !goog.implicitNamespaces_[name] && !!goog.getObjectByName(name);
  };
  goog.implicitNamespaces_ = {};
}
goog.getObjectByName = function (name, opt_obj) {
  var parts = name.split('.');
  var cur = opt_obj || goog.global;
  for (var part; part = parts.shift();) {
    if (goog.isDefAndNotNull(cur[part])) {
      cur = cur[part];
    } else {
      return null;
    }
  }
  return cur;
};
goog.globalize = function (obj, opt_global) {
  var global = opt_global || goog.global;
  for (var x in obj) {
    global[x] = obj[x];
  }
};
goog.addDependency = function (relPath, provides, requires) {
  if (goog.DEPENDENCIES_ENABLED) {
    var provide, require;
    var path = relPath.replace(/\\/g, '/');
    var deps = goog.dependencies_;
    for (var i = 0; provide = provides[i]; i++) {
      deps.nameToPath[provide] = path;
      if (!(path in deps.pathToNames)) {
        deps.pathToNames[path] = {};
      }
      deps.pathToNames[path][provide] = true;
    }
    for (var j = 0; require = requires[j]; j++) {
      if (!(path in deps.requires)) {
        deps.requires[path] = {};
      }
      deps.requires[path][require] = true;
    }
  }
};
goog.define('goog.ENABLE_DEBUG_LOADER', true);
goog.require = function (name) {
  if (!COMPILED) {
    if (goog.isProvided_(name)) {
      return;
    }
    if (goog.ENABLE_DEBUG_LOADER) {
      var path = goog.getPathFromDeps_(name);
      if (path) {
        goog.included_[path] = true;
        goog.writeScripts_();
        return;
      }
    }
    var errorMessage = 'goog.require could not find: ' + name;
    if (goog.global.console) {
      goog.global.console['error'](errorMessage);
    }
    throw Error(errorMessage);
  }
};
goog.basePath = '';
goog.global.CLOSURE_BASE_PATH;
goog.global.CLOSURE_NO_DEPS;
goog.global.CLOSURE_IMPORT_SCRIPT;
goog.nullFunction = function () {
};
goog.identityFunction = function (opt_returnValue, var_args) {
  return opt_returnValue;
};
goog.abstractMethod = function () {
  throw Error('unimplemented abstract method');
};
goog.addSingletonGetter = function (ctor) {
  ctor.getInstance = function () {
    if (ctor.instance_) {
      return ctor.instance_;
    }
    if (goog.DEBUG) {
      goog.instantiatedSingletons_[goog.instantiatedSingletons_.length] = ctor;
    }
    return ctor.instance_ = new ctor();
  };
};
goog.instantiatedSingletons_ = [];
goog.DEPENDENCIES_ENABLED = !COMPILED && goog.ENABLE_DEBUG_LOADER;
if (goog.DEPENDENCIES_ENABLED) {
  goog.included_ = {};
  goog.dependencies_ = {
    pathToNames: {},
    nameToPath: {},
    requires: {},
    visited: {},
    written: {}
  };
  goog.inHtmlDocument_ = function () {
    var doc = goog.global.document;
    return typeof doc != 'undefined' && 'write' in doc;
  };
  goog.findBasePath_ = function () {
    if (goog.global.CLOSURE_BASE_PATH) {
      goog.basePath = goog.global.CLOSURE_BASE_PATH;
      return;
    } else if (!goog.inHtmlDocument_()) {
      return;
    }
    var doc = goog.global.document;
    var scripts = doc.getElementsByTagName('script');
    for (var i = scripts.length - 1; i >= 0; --i) {
      var src = scripts[i].src;
      var qmark = src.lastIndexOf('?');
      var l = qmark == -1 ? src.length : qmark;
      if (src.substr(l - 7, 7) == 'base.js') {
        goog.basePath = src.substr(0, l - 7);
        return;
      }
    }
  };
  goog.importScript_ = function (src) {
    var importScript = goog.global.CLOSURE_IMPORT_SCRIPT || goog.writeScriptTag_;
    if (!goog.dependencies_.written[src] && importScript(src)) {
      goog.dependencies_.written[src] = true;
    }
  };
  goog.writeScriptTag_ = function (src) {
    if (goog.inHtmlDocument_()) {
      var doc = goog.global.document;
      if (doc.readyState == 'complete') {
        var isDeps = /\bdeps.js$/.test(src);
        if (isDeps) {
          return false;
        } else {
          throw Error('Cannot write "' + src + '" after document load');
        }
      }
      doc.write('<script type="text/javascript" src="' + src + '"></' + 'script>');
      return true;
    } else {
      return false;
    }
  };
  goog.writeScripts_ = function () {
    var scripts = [];
    var seenScript = {};
    var deps = goog.dependencies_;
    function visitNode(path) {
      if (path in deps.written) {
        return;
      }
      if (path in deps.visited) {
        if (!(path in seenScript)) {
          seenScript[path] = true;
          scripts.push(path);
        }
        return;
      }
      deps.visited[path] = true;
      if (path in deps.requires) {
        for (var requireName in deps.requires[path]) {
          if (!goog.isProvided_(requireName)) {
            if (requireName in deps.nameToPath) {
              visitNode(deps.nameToPath[requireName]);
            } else {
              throw Error('Undefined nameToPath for ' + requireName);
            }
          }
        }
      }
      if (!(path in seenScript)) {
        seenScript[path] = true;
        scripts.push(path);
      }
    }
    for (var path in goog.included_) {
      if (!deps.written[path]) {
        visitNode(path);
      }
    }
    for (var i = 0; i < scripts.length; i++) {
      if (scripts[i]) {
        goog.importScript_(goog.basePath + scripts[i]);
      } else {
        throw Error('Undefined script input');
      }
    }
  };
  goog.getPathFromDeps_ = function (rule) {
    if (rule in goog.dependencies_.nameToPath) {
      return goog.dependencies_.nameToPath[rule];
    } else {
      return null;
    }
  };
  goog.findBasePath_();
  if (!goog.global.CLOSURE_NO_DEPS) {
    goog.importScript_(goog.basePath + 'deps.js');
  }
}
goog.typeOf = function (value) {
  var s = typeof value;
  if (s == 'object') {
    if (value) {
      if (value instanceof Array) {
        return 'array';
      } else if (value instanceof Object) {
        return s;
      }
      var className = Object.prototype.toString.call(value);
      if (className == '[object Window]') {
        return 'object';
      }
      if (className == '[object Array]' || typeof value.length == 'number' && typeof value.splice != 'undefined' && typeof value.propertyIsEnumerable != 'undefined' && !value.propertyIsEnumerable('splice')) {
        return 'array';
      }
      if (className == '[object Function]' || typeof value.call != 'undefined' && typeof value.propertyIsEnumerable != 'undefined' && !value.propertyIsEnumerable('call')) {
        return 'function';
      }
    } else {
      return 'null';
    }
  } else if (s == 'function' && typeof value.call == 'undefined') {
    return 'object';
  }
  return s;
};
goog.isDef = function (val) {
  return val !== undefined;
};
goog.isNull = function (val) {
  return val === null;
};
goog.isDefAndNotNull = function (val) {
  return val != null;
};
goog.isArray = function (val) {
  return goog.typeOf(val) == 'array';
};
goog.isArrayLike = function (val) {
  var type = goog.typeOf(val);
  return type == 'array' || type == 'object' && typeof val.length == 'number';
};
goog.isDateLike = function (val) {
  return goog.isObject(val) && typeof val.getFullYear == 'function';
};
goog.isString = function (val) {
  return typeof val == 'string';
};
goog.isBoolean = function (val) {
  return typeof val == 'boolean';
};
goog.isNumber = function (val) {
  return typeof val == 'number';
};
goog.isFunction = function (val) {
  return goog.typeOf(val) == 'function';
};
goog.isObject = function (val) {
  var type = typeof val;
  return type == 'object' && val != null || type == 'function';
};
goog.getUid = function (obj) {
  return obj[goog.UID_PROPERTY_] || (obj[goog.UID_PROPERTY_] = ++goog.uidCounter_);
};
goog.removeUid = function (obj) {
  if ('removeAttribute' in obj) {
    obj.removeAttribute(goog.UID_PROPERTY_);
  }
  try {
    delete obj[goog.UID_PROPERTY_];
  } catch (ex) {
  }
};
goog.UID_PROPERTY_ = 'closure_uid_' + (Math.random() * 1000000000 >>> 0);
goog.uidCounter_ = 0;
goog.getHashCode = goog.getUid;
goog.removeHashCode = goog.removeUid;
goog.cloneObject = function (obj) {
  var type = goog.typeOf(obj);
  if (type == 'object' || type == 'array') {
    if (obj.clone) {
      return obj.clone();
    }
    var clone = type == 'array' ? [] : {};
    for (var key in obj) {
      clone[key] = goog.cloneObject(obj[key]);
    }
    return clone;
  }
  return obj;
};
goog.bindNative_ = function (fn, selfObj, var_args) {
  return fn.call.apply(fn.bind, arguments);
};
goog.bindJs_ = function (fn, selfObj, var_args) {
  if (!fn) {
    throw new Error();
  }
  if (arguments.length > 2) {
    var boundArgs = Array.prototype.slice.call(arguments, 2);
    return function () {
      var newArgs = Array.prototype.slice.call(arguments);
      Array.prototype.unshift.apply(newArgs, boundArgs);
      return fn.apply(selfObj, newArgs);
    };
  } else {
    return function () {
      return fn.apply(selfObj, arguments);
    };
  }
};
goog.bind = function (fn, selfObj, var_args) {
  if (Function.prototype.bind && Function.prototype.bind.toString().indexOf('native code') != -1) {
    goog.bind = goog.bindNative_;
  } else {
    goog.bind = goog.bindJs_;
  }
  return goog.bind.apply(null, arguments);
};
goog.partial = function (fn, var_args) {
  var args = Array.prototype.slice.call(arguments, 1);
  return function () {
    var newArgs = Array.prototype.slice.call(arguments);
    newArgs.unshift.apply(newArgs, args);
    return fn.apply(this, newArgs);
  };
};
goog.mixin = function (target, source) {
  for (var x in source) {
    target[x] = source[x];
  }
};
goog.now = goog.TRUSTED_SITE && Date.now || function () {
  return +new Date();
};
goog.globalEval = function (script) {
  if (goog.global.execScript) {
    goog.global.execScript(script, 'JavaScript');
  } else if (goog.global.eval) {
    if (goog.evalWorksForGlobals_ == null) {
      goog.global.eval('var _et_ = 1;');
      if (typeof goog.global['_et_'] != 'undefined') {
        delete goog.global['_et_'];
        goog.evalWorksForGlobals_ = true;
      } else {
        goog.evalWorksForGlobals_ = false;
      }
    }
    if (goog.evalWorksForGlobals_) {
      goog.global.eval(script);
    } else {
      var doc = goog.global.document;
      var scriptElt = doc.createElement('script');
      scriptElt.type = 'text/javascript';
      scriptElt.defer = false;
      scriptElt.appendChild(doc.createTextNode(script));
      doc.body.appendChild(scriptElt);
      doc.body.removeChild(scriptElt);
    }
  } else {
    throw Error('goog.globalEval not available');
  }
};
goog.evalWorksForGlobals_ = null;
goog.cssNameMapping_;
goog.cssNameMappingStyle_;
goog.getCssName = function (className, opt_modifier) {
  var getMapping = function (cssName) {
    return goog.cssNameMapping_[cssName] || cssName;
  };
  var renameByParts = function (cssName) {
    var parts = cssName.split('-');
    var mapped = [];
    for (var i = 0; i < parts.length; i++) {
      mapped.push(getMapping(parts[i]));
    }
    return mapped.join('-');
  };
  var rename;
  if (goog.cssNameMapping_) {
    rename = goog.cssNameMappingStyle_ == 'BY_WHOLE' ? getMapping : renameByParts;
  } else {
    rename = function (a) {
      return a;
    };
  }
  if (opt_modifier) {
    return className + '-' + rename(opt_modifier);
  } else {
    return rename(className);
  }
};
goog.setCssNameMapping = function (mapping, opt_style) {
  goog.cssNameMapping_ = mapping;
  goog.cssNameMappingStyle_ = opt_style;
};
goog.global.CLOSURE_CSS_NAME_MAPPING;
if (!COMPILED && goog.global.CLOSURE_CSS_NAME_MAPPING) {
  goog.cssNameMapping_ = goog.global.CLOSURE_CSS_NAME_MAPPING;
}
goog.getMsg = function (str, opt_values) {
  var values = opt_values || {};
  for (var key in values) {
    var value = ('' + values[key]).replace(/\$/g, '$$$$');
    str = str.replace(new RegExp('\\{\\$' + key + '\\}', 'gi'), value);
  }
  return str;
};
goog.getMsgWithFallback = function (a, b) {
  return a;
};
goog.exportSymbol = function (publicPath, object, opt_objectToExportTo) {
  goog.exportPath_(publicPath, object, opt_objectToExportTo);
};
goog.exportProperty = function (object, publicName, symbol) {
  object[publicName] = symbol;
};
goog.inherits = function (childCtor, parentCtor) {
  function tempCtor() {
  }
  ;
  tempCtor.prototype = parentCtor.prototype;
  childCtor.superClass_ = parentCtor.prototype;
  childCtor.prototype = new tempCtor();
  childCtor.prototype.constructor = childCtor;
};
goog.base = function (me, opt_methodName, var_args) {
  var caller = arguments.callee.caller;
  if (goog.DEBUG) {
    if (!caller) {
      throw Error('arguments.caller not defined.  goog.base() expects not ' + 'to be running in strict mode. See ' + 'http://www.ecma-international.org/ecma-262/5.1/#sec-C');
    }
  }
  if (caller.superClass_) {
    return caller.superClass_.constructor.apply(me, Array.prototype.slice.call(arguments, 1));
  }
  var args = Array.prototype.slice.call(arguments, 2);
  var foundCaller = false;
  for (var ctor = me.constructor; ctor; ctor = ctor.superClass_ && ctor.superClass_.constructor) {
    if (ctor.prototype[opt_methodName] === caller) {
      foundCaller = true;
    } else if (foundCaller) {
      return ctor.prototype[opt_methodName].apply(me, args);
    }
  }
  if (me[opt_methodName] === caller) {
    return me.constructor.prototype[opt_methodName].apply(me, args);
  } else {
    throw Error('goog.base called from a method of one name ' + 'to a method of a different name');
  }
};
goog.scope = function (fn) {
  fn.call(goog.global);
};
goog.addDependency('../../third_party/closure/goog/caja/string/html/htmlparser.js', [
  'goog.string.html.HtmlParser',
  'goog.string.html.HtmlParser.EFlags',
  'goog.string.html.HtmlParser.Elements',
  'goog.string.html.HtmlParser.Entities',
  'goog.string.html.HtmlSaxHandler'
], []);
goog.addDependency('../../third_party/closure/goog/caja/string/html/htmlsanitizer.js', [
  'goog.string.html.HtmlSanitizer',
  'goog.string.html.HtmlSanitizer.AttributeType',
  'goog.string.html.HtmlSanitizer.Attributes',
  'goog.string.html.htmlSanitize'
], [
  'goog.string.StringBuffer',
  'goog.string.html.HtmlParser',
  'goog.string.html.HtmlParser.EFlags',
  'goog.string.html.HtmlParser.Elements',
  'goog.string.html.HtmlSaxHandler'
]);
goog.addDependency('../../third_party/closure/goog/dojo/dom/query.js', ['goog.dom.query'], [
  'goog.array',
  'goog.dom',
  'goog.functions',
  'goog.string',
  'goog.userAgent'
]);
goog.addDependency('../../third_party/closure/goog/jpeg_encoder/jpeg_encoder_basic.js', ['goog.crypt.JpegEncoder'], ['goog.crypt.base64']);
goog.addDependency('../../third_party/closure/goog/loremipsum/text/loremipsum.js', ['goog.text.LoremIpsum'], [
  'goog.array',
  'goog.math',
  'goog.string',
  'goog.structs.Map',
  'goog.structs.Set'
]);
goog.addDependency('../../third_party/closure/goog/mochikit/async/deferred.js', [
  'goog.async.Deferred',
  'goog.async.Deferred.AlreadyCalledError',
  'goog.async.Deferred.CanceledError'
], [
  'goog.array',
  'goog.asserts',
  'goog.debug.Error',
  'goog.functions'
]);
goog.addDependency('../../third_party/closure/goog/mochikit/async/deferredlist.js', ['goog.async.DeferredList'], ['goog.async.Deferred']);
goog.addDependency('../../third_party/closure/goog/osapi/osapi.js', ['goog.osapi'], []);
goog.addDependency('a11y/aria/announcer.js', ['goog.a11y.aria.Announcer'], [
  'goog.Disposable',
  'goog.a11y.aria',
  'goog.a11y.aria.LivePriority',
  'goog.a11y.aria.State',
  'goog.dom',
  'goog.object'
]);
goog.addDependency('a11y/aria/aria.js', ['goog.a11y.aria'], [
  'goog.a11y.aria.Role',
  'goog.a11y.aria.State',
  'goog.a11y.aria.datatables',
  'goog.array',
  'goog.asserts',
  'goog.dom',
  'goog.dom.TagName',
  'goog.object',
  'goog.string'
]);
goog.addDependency('a11y/aria/attributes.js', [
  'goog.a11y.aria.AutoCompleteValues',
  'goog.a11y.aria.CheckedValues',
  'goog.a11y.aria.DropEffectValues',
  'goog.a11y.aria.ExpandedValues',
  'goog.a11y.aria.GrabbedValues',
  'goog.a11y.aria.InvalidValues',
  'goog.a11y.aria.LivePriority',
  'goog.a11y.aria.OrientationValues',
  'goog.a11y.aria.PressedValues',
  'goog.a11y.aria.RelevantValues',
  'goog.a11y.aria.SelectedValues',
  'goog.a11y.aria.SortValues',
  'goog.a11y.aria.State'
], []);
goog.addDependency('a11y/aria/datatables.js', ['goog.a11y.aria.datatables'], [
  'goog.a11y.aria.State',
  'goog.object'
]);
goog.addDependency('a11y/aria/roles.js', ['goog.a11y.aria.Role'], []);
goog.addDependency('array/array.js', [
  'goog.array',
  'goog.array.ArrayLike'
], ['goog.asserts']);
goog.addDependency('asserts/asserts.js', [
  'goog.asserts',
  'goog.asserts.AssertionError'
], [
  'goog.debug.Error',
  'goog.string'
]);
goog.addDependency('async/animationdelay.js', ['goog.async.AnimationDelay'], [
  'goog.Disposable',
  'goog.events',
  'goog.functions'
]);
goog.addDependency('async/conditionaldelay.js', ['goog.async.ConditionalDelay'], [
  'goog.Disposable',
  'goog.async.Delay'
]);
goog.addDependency('async/delay.js', [
  'goog.Delay',
  'goog.async.Delay'
], [
  'goog.Disposable',
  'goog.Timer'
]);
goog.addDependency('async/nexttick.js', ['goog.async.nextTick'], [
  'goog.debug.entryPointRegistry',
  'goog.functions'
]);
goog.addDependency('async/throttle.js', [
  'goog.Throttle',
  'goog.async.Throttle'
], [
  'goog.Disposable',
  'goog.Timer'
]);
goog.addDependency('base.js', ['goog'], []);
goog.addDependency('color/alpha.js', ['goog.color.alpha'], ['goog.color']);
goog.addDependency('color/color.js', ['goog.color'], [
  'goog.color.names',
  'goog.math'
]);
goog.addDependency('color/names.js', ['goog.color.names'], []);
goog.addDependency('crypt/aes.js', ['goog.crypt.Aes'], [
  'goog.asserts',
  'goog.crypt.BlockCipher'
]);
goog.addDependency('crypt/arc4.js', ['goog.crypt.Arc4'], ['goog.asserts']);
goog.addDependency('crypt/base64.js', ['goog.crypt.base64'], [
  'goog.crypt',
  'goog.userAgent'
]);
goog.addDependency('crypt/basen.js', ['goog.crypt.baseN'], []);
goog.addDependency('crypt/blobhasher.js', [
  'goog.crypt.BlobHasher',
  'goog.crypt.BlobHasher.EventType'
], [
  'goog.asserts',
  'goog.crypt',
  'goog.crypt.Hash',
  'goog.events.EventTarget',
  'goog.fs',
  'goog.log'
]);
goog.addDependency('crypt/blockcipher.js', ['goog.crypt.BlockCipher'], []);
goog.addDependency('crypt/cbc.js', ['goog.crypt.Cbc'], [
  'goog.array',
  'goog.crypt'
]);
goog.addDependency('crypt/cbc_test.js', ['goog.crypt.CbcTest'], [
  'goog.crypt',
  'goog.crypt.Aes',
  'goog.crypt.Cbc',
  'goog.testing.jsunit'
]);
goog.addDependency('crypt/crypt.js', ['goog.crypt'], ['goog.array']);
goog.addDependency('crypt/hash.js', ['goog.crypt.Hash'], []);
goog.addDependency('crypt/hash32.js', ['goog.crypt.hash32'], ['goog.crypt']);
goog.addDependency('crypt/hashtester.js', ['goog.crypt.hashTester'], [
  'goog.array',
  'goog.crypt',
  'goog.testing.PerformanceTable',
  'goog.testing.PseudoRandom',
  'goog.testing.asserts'
]);
goog.addDependency('crypt/hmac.js', ['goog.crypt.Hmac'], [
  'goog.asserts',
  'goog.crypt.Hash'
]);
goog.addDependency('crypt/md5.js', ['goog.crypt.Md5'], ['goog.crypt.Hash']);
goog.addDependency('crypt/pbkdf2.js', ['goog.crypt.pbkdf2'], [
  'goog.asserts',
  'goog.crypt',
  'goog.crypt.Hmac',
  'goog.crypt.Sha1'
]);
goog.addDependency('crypt/sha1.js', ['goog.crypt.Sha1'], ['goog.crypt.Hash']);
goog.addDependency('crypt/sha2.js', ['goog.crypt.Sha2'], [
  'goog.array',
  'goog.asserts',
  'goog.crypt.Hash'
]);
goog.addDependency('crypt/sha224.js', ['goog.crypt.Sha224'], ['goog.crypt.Sha2']);
goog.addDependency('crypt/sha256.js', ['goog.crypt.Sha256'], ['goog.crypt.Sha2']);
goog.addDependency('cssom/cssom.js', [
  'goog.cssom',
  'goog.cssom.CssRuleType'
], [
  'goog.array',
  'goog.dom'
]);
goog.addDependency('cssom/iframe/style.js', ['goog.cssom.iframe.style'], [
  'goog.cssom',
  'goog.dom',
  'goog.dom.NodeType',
  'goog.dom.TagName',
  'goog.dom.classes',
  'goog.string',
  'goog.style',
  'goog.userAgent'
]);
goog.addDependency('datasource/datamanager.js', ['goog.ds.DataManager'], [
  'goog.ds.BasicNodeList',
  'goog.ds.DataNode',
  'goog.ds.Expr',
  'goog.string',
  'goog.structs',
  'goog.structs.Map'
]);
goog.addDependency('datasource/datasource.js', [
  'goog.ds.BaseDataNode',
  'goog.ds.BasicNodeList',
  'goog.ds.DataNode',
  'goog.ds.DataNodeList',
  'goog.ds.EmptyNodeList',
  'goog.ds.LoadState',
  'goog.ds.SortedNodeList',
  'goog.ds.Util',
  'goog.ds.logger'
], [
  'goog.array',
  'goog.log'
]);
goog.addDependency('datasource/expr.js', ['goog.ds.Expr'], [
  'goog.ds.BasicNodeList',
  'goog.ds.EmptyNodeList',
  'goog.string'
]);
goog.addDependency('datasource/fastdatanode.js', [
  'goog.ds.AbstractFastDataNode',
  'goog.ds.FastDataNode',
  'goog.ds.FastListNode',
  'goog.ds.PrimitiveFastDataNode'
], [
  'goog.ds.DataManager',
  'goog.ds.EmptyNodeList',
  'goog.string'
]);
goog.addDependency('datasource/jsdatasource.js', [
  'goog.ds.JsDataSource',
  'goog.ds.JsPropertyDataSource'
], [
  'goog.ds.BaseDataNode',
  'goog.ds.BasicNodeList',
  'goog.ds.DataManager',
  'goog.ds.EmptyNodeList',
  'goog.ds.LoadState'
]);
goog.addDependency('datasource/jsondatasource.js', ['goog.ds.JsonDataSource'], [
  'goog.Uri',
  'goog.dom',
  'goog.ds.DataManager',
  'goog.ds.JsDataSource',
  'goog.ds.LoadState',
  'goog.ds.logger'
]);
goog.addDependency('datasource/jsxmlhttpdatasource.js', ['goog.ds.JsXmlHttpDataSource'], [
  'goog.Uri',
  'goog.ds.DataManager',
  'goog.ds.FastDataNode',
  'goog.ds.LoadState',
  'goog.ds.logger',
  'goog.events',
  'goog.log',
  'goog.net.EventType',
  'goog.net.XhrIo'
]);
goog.addDependency('datasource/xmldatasource.js', [
  'goog.ds.XmlDataSource',
  'goog.ds.XmlHttpDataSource'
], [
  'goog.Uri',
  'goog.dom.NodeType',
  'goog.dom.xml',
  'goog.ds.BasicNodeList',
  'goog.ds.DataManager',
  'goog.ds.LoadState',
  'goog.ds.logger',
  'goog.net.XhrIo',
  'goog.string'
]);
goog.addDependency('date/date.js', [
  'goog.date',
  'goog.date.Date',
  'goog.date.DateTime',
  'goog.date.Interval',
  'goog.date.month',
  'goog.date.weekDay'
], [
  'goog.asserts',
  'goog.date.DateLike',
  'goog.i18n.DateTimeSymbols',
  'goog.string'
]);
goog.addDependency('date/datelike.js', ['goog.date.DateLike'], []);
goog.addDependency('date/daterange.js', [
  'goog.date.DateRange',
  'goog.date.DateRange.Iterator',
  'goog.date.DateRange.StandardDateRangeKeys'
], [
  'goog.date.Date',
  'goog.date.Interval',
  'goog.iter.Iterator',
  'goog.iter.StopIteration'
]);
goog.addDependency('date/relative.js', ['goog.date.relative'], ['goog.i18n.DateTimeFormat']);
goog.addDependency('date/utcdatetime.js', ['goog.date.UtcDateTime'], [
  'goog.date',
  'goog.date.Date',
  'goog.date.DateTime',
  'goog.date.Interval'
]);
goog.addDependency('db/cursor.js', ['goog.db.Cursor'], [
  'goog.async.Deferred',
  'goog.db.Error',
  'goog.debug',
  'goog.events.EventTarget'
]);
goog.addDependency('db/db.js', ['goog.db'], [
  'goog.async.Deferred',
  'goog.db.Error',
  'goog.db.IndexedDb',
  'goog.db.Transaction'
]);
goog.addDependency('db/error.js', [
  'goog.db.Error',
  'goog.db.Error.ErrorCode',
  'goog.db.Error.ErrorName',
  'goog.db.Error.VersionChangeBlockedError'
], ['goog.debug.Error']);
goog.addDependency('db/index.js', ['goog.db.Index'], [
  'goog.async.Deferred',
  'goog.db.Cursor',
  'goog.db.Error',
  'goog.debug'
]);
goog.addDependency('db/indexeddb.js', ['goog.db.IndexedDb'], [
  'goog.async.Deferred',
  'goog.db.Error',
  'goog.db.Error.VersionChangeBlockedError',
  'goog.db.ObjectStore',
  'goog.db.Transaction',
  'goog.db.Transaction.TransactionMode',
  'goog.events.Event',
  'goog.events.EventHandler',
  'goog.events.EventTarget'
]);
goog.addDependency('db/keyrange.js', ['goog.db.KeyRange'], []);
goog.addDependency('db/objectstore.js', ['goog.db.ObjectStore'], [
  'goog.async.Deferred',
  'goog.db.Cursor',
  'goog.db.Error',
  'goog.db.Index',
  'goog.debug',
  'goog.events'
]);
goog.addDependency('db/transaction.js', [
  'goog.db.Transaction',
  'goog.db.Transaction.TransactionMode'
], [
  'goog.async.Deferred',
  'goog.db.Error',
  'goog.db.ObjectStore',
  'goog.events.EventHandler',
  'goog.events.EventTarget'
]);
goog.addDependency('debug/console.js', ['goog.debug.Console'], [
  'goog.debug.LogManager',
  'goog.debug.Logger.Level',
  'goog.debug.TextFormatter'
]);
goog.addDependency('debug/debug.js', ['goog.debug'], [
  'goog.array',
  'goog.string',
  'goog.structs.Set',
  'goog.userAgent'
]);
goog.addDependency('debug/debugwindow.js', ['goog.debug.DebugWindow'], [
  'goog.debug.HtmlFormatter',
  'goog.debug.LogManager',
  'goog.debug.Logger',
  'goog.structs.CircularBuffer',
  'goog.userAgent'
]);
goog.addDependency('debug/devcss/devcss.js', [
  'goog.debug.DevCss',
  'goog.debug.DevCss.UserAgent'
], [
  'goog.cssom',
  'goog.dom.classes',
  'goog.events',
  'goog.events.EventType',
  'goog.string',
  'goog.userAgent'
]);
goog.addDependency('debug/devcss/devcssrunner.js', ['goog.debug.devCssRunner'], ['goog.debug.DevCss']);
goog.addDependency('debug/divconsole.js', ['goog.debug.DivConsole'], [
  'goog.debug.HtmlFormatter',
  'goog.debug.LogManager',
  'goog.style'
]);
goog.addDependency('debug/entrypointregistry.js', [
  'goog.debug.EntryPointMonitor',
  'goog.debug.entryPointRegistry'
], ['goog.asserts']);
goog.addDependency('debug/error.js', ['goog.debug.Error'], []);
goog.addDependency('debug/errorhandler.js', [
  'goog.debug.ErrorHandler',
  'goog.debug.ErrorHandler.ProtectedFunctionError'
], [
  'goog.asserts',
  'goog.debug',
  'goog.debug.EntryPointMonitor',
  'goog.debug.Trace'
]);
goog.addDependency('debug/errorhandlerweakdep.js', ['goog.debug.errorHandlerWeakDep'], []);
goog.addDependency('debug/errorreporter.js', [
  'goog.debug.ErrorReporter',
  'goog.debug.ErrorReporter.ExceptionEvent'
], [
  'goog.asserts',
  'goog.debug',
  'goog.debug.ErrorHandler',
  'goog.debug.entryPointRegistry',
  'goog.events',
  'goog.events.Event',
  'goog.events.EventTarget',
  'goog.log',
  'goog.net.XhrIo',
  'goog.object',
  'goog.string',
  'goog.uri.utils',
  'goog.userAgent'
]);
goog.addDependency('debug/fancywindow.js', ['goog.debug.FancyWindow'], [
  'goog.debug.DebugWindow',
  'goog.debug.LogManager',
  'goog.debug.Logger',
  'goog.dom.DomHelper',
  'goog.object',
  'goog.string',
  'goog.userAgent'
]);
goog.addDependency('debug/formatter.js', [
  'goog.debug.Formatter',
  'goog.debug.HtmlFormatter',
  'goog.debug.TextFormatter'
], [
  'goog.debug.RelativeTimeProvider',
  'goog.string'
]);
goog.addDependency('debug/fpsdisplay.js', ['goog.debug.FpsDisplay'], [
  'goog.asserts',
  'goog.async.AnimationDelay',
  'goog.ui.Component'
]);
goog.addDependency('debug/gcdiagnostics.js', ['goog.debug.GcDiagnostics'], [
  'goog.debug.Trace',
  'goog.log',
  'goog.userAgent'
]);
goog.addDependency('debug/logbuffer.js', ['goog.debug.LogBuffer'], [
  'goog.asserts',
  'goog.debug.LogRecord'
]);
goog.addDependency('debug/logger.js', [
  'goog.debug.LogManager',
  'goog.debug.Logger',
  'goog.debug.Logger.Level'
], [
  'goog.array',
  'goog.asserts',
  'goog.debug',
  'goog.debug.LogBuffer',
  'goog.debug.LogRecord'
]);
goog.addDependency('debug/logrecord.js', ['goog.debug.LogRecord'], []);
goog.addDependency('debug/logrecordserializer.js', ['goog.debug.logRecordSerializer'], [
  'goog.debug.LogRecord',
  'goog.debug.Logger.Level',
  'goog.json',
  'goog.object'
]);
goog.addDependency('debug/reflect.js', ['goog.debug.reflect'], []);
goog.addDependency('debug/relativetimeprovider.js', ['goog.debug.RelativeTimeProvider'], []);
goog.addDependency('debug/tracer.js', ['goog.debug.Trace'], [
  'goog.array',
  'goog.iter',
  'goog.log',
  'goog.structs.Map',
  'goog.structs.SimplePool'
]);
goog.addDependency('disposable/disposable.js', [
  'goog.Disposable',
  'goog.dispose'
], ['goog.disposable.IDisposable']);
goog.addDependency('disposable/idisposable.js', ['goog.disposable.IDisposable'], []);
goog.addDependency('dom/a11y.js', [
  'goog.dom.a11y',
  'goog.dom.a11y.Announcer',
  'goog.dom.a11y.LivePriority',
  'goog.dom.a11y.Role',
  'goog.dom.a11y.State'
], [
  'goog.a11y.aria',
  'goog.a11y.aria.Announcer',
  'goog.a11y.aria.LivePriority',
  'goog.a11y.aria.Role',
  'goog.a11y.aria.State'
]);
goog.addDependency('dom/abstractmultirange.js', ['goog.dom.AbstractMultiRange'], [
  'goog.array',
  'goog.dom',
  'goog.dom.AbstractRange'
]);
goog.addDependency('dom/abstractrange.js', [
  'goog.dom.AbstractRange',
  'goog.dom.RangeIterator',
  'goog.dom.RangeType'
], [
  'goog.dom',
  'goog.dom.NodeType',
  'goog.dom.SavedCaretRange',
  'goog.dom.TagIterator',
  'goog.userAgent'
]);
goog.addDependency('dom/annotate.js', ['goog.dom.annotate'], [
  'goog.array',
  'goog.dom',
  'goog.dom.NodeType',
  'goog.string'
]);
goog.addDependency('dom/browserfeature.js', ['goog.dom.BrowserFeature'], ['goog.userAgent']);
goog.addDependency('dom/browserrange/abstractrange.js', ['goog.dom.browserrange.AbstractRange'], [
  'goog.array',
  'goog.asserts',
  'goog.dom',
  'goog.dom.NodeType',
  'goog.dom.RangeEndpoint',
  'goog.dom.TagName',
  'goog.dom.TextRangeIterator',
  'goog.iter',
  'goog.math.Coordinate',
  'goog.string',
  'goog.string.StringBuffer',
  'goog.userAgent'
]);
goog.addDependency('dom/browserrange/browserrange.js', [
  'goog.dom.browserrange',
  'goog.dom.browserrange.Error'
], [
  'goog.dom',
  'goog.dom.NodeType',
  'goog.dom.browserrange.GeckoRange',
  'goog.dom.browserrange.IeRange',
  'goog.dom.browserrange.OperaRange',
  'goog.dom.browserrange.W3cRange',
  'goog.dom.browserrange.WebKitRange',
  'goog.userAgent'
]);
goog.addDependency('dom/browserrange/geckorange.js', ['goog.dom.browserrange.GeckoRange'], ['goog.dom.browserrange.W3cRange']);
goog.addDependency('dom/browserrange/ierange.js', ['goog.dom.browserrange.IeRange'], [
  'goog.array',
  'goog.dom',
  'goog.dom.NodeType',
  'goog.dom.RangeEndpoint',
  'goog.dom.TagName',
  'goog.dom.browserrange.AbstractRange',
  'goog.log',
  'goog.string'
]);
goog.addDependency('dom/browserrange/operarange.js', ['goog.dom.browserrange.OperaRange'], ['goog.dom.browserrange.W3cRange']);
goog.addDependency('dom/browserrange/w3crange.js', ['goog.dom.browserrange.W3cRange'], [
  'goog.dom',
  'goog.dom.NodeType',
  'goog.dom.RangeEndpoint',
  'goog.dom.browserrange.AbstractRange',
  'goog.string'
]);
goog.addDependency('dom/browserrange/webkitrange.js', ['goog.dom.browserrange.WebKitRange'], [
  'goog.dom.RangeEndpoint',
  'goog.dom.browserrange.W3cRange',
  'goog.userAgent'
]);
goog.addDependency('dom/bufferedviewportsizemonitor.js', ['goog.dom.BufferedViewportSizeMonitor'], [
  'goog.asserts',
  'goog.async.Delay',
  'goog.events',
  'goog.events.EventTarget',
  'goog.events.EventType'
]);
goog.addDependency('dom/bufferedviewportsizemonitor_test.js', ['goog.dom.BufferedViewportSizeMonitorTest'], [
  'goog.dom.BufferedViewportSizeMonitor',
  'goog.dom.ViewportSizeMonitor',
  'goog.events',
  'goog.events.EventType',
  'goog.math.Size',
  'goog.testing.MockClock',
  'goog.testing.events',
  'goog.testing.events.Event',
  'goog.testing.jsunit'
]);
goog.addDependency('dom/classes.js', ['goog.dom.classes'], ['goog.array']);
goog.addDependency('dom/classes_test.js', ['goog.dom.classes_test'], [
  'goog.dom',
  'goog.dom.classes',
  'goog.testing.jsunit'
]);
goog.addDependency('dom/classlist.js', ['goog.dom.classlist'], [
  'goog.array',
  'goog.asserts'
]);
goog.addDependency('dom/classlist_test.js', ['goog.dom.classlist_test'], [
  'goog.dom',
  'goog.dom.classlist',
  'goog.testing.jsunit'
]);
goog.addDependency('dom/controlrange.js', [
  'goog.dom.ControlRange',
  'goog.dom.ControlRangeIterator'
], [
  'goog.array',
  'goog.dom',
  'goog.dom.AbstractMultiRange',
  'goog.dom.AbstractRange',
  'goog.dom.RangeIterator',
  'goog.dom.RangeType',
  'goog.dom.SavedRange',
  'goog.dom.TagWalkType',
  'goog.dom.TextRange',
  'goog.iter.StopIteration',
  'goog.userAgent'
]);
goog.addDependency('dom/dataset.js', ['goog.dom.dataset'], ['goog.string']);
goog.addDependency('dom/dom.js', [
  'goog.dom',
  'goog.dom.Appendable',
  'goog.dom.DomHelper',
  'goog.dom.NodeType'
], [
  'goog.array',
  'goog.dom.BrowserFeature',
  'goog.dom.TagName',
  'goog.dom.classes',
  'goog.math.Coordinate',
  'goog.math.Size',
  'goog.object',
  'goog.string',
  'goog.userAgent'
]);
goog.addDependency('dom/dom_test.js', ['goog.dom.dom_test'], [
  'goog.dom',
  'goog.dom.BrowserFeature',
  'goog.dom.DomHelper',
  'goog.dom.NodeType',
  'goog.dom.TagName',
  'goog.object',
  'goog.string.Unicode',
  'goog.testing.asserts',
  'goog.userAgent',
  'goog.userAgent.product',
  'goog.userAgent.product.isVersion'
]);
goog.addDependency('dom/fontsizemonitor.js', [
  'goog.dom.FontSizeMonitor',
  'goog.dom.FontSizeMonitor.EventType'
], [
  'goog.dom',
  'goog.events',
  'goog.events.EventTarget',
  'goog.events.EventType',
  'goog.userAgent'
]);
goog.addDependency('dom/forms.js', ['goog.dom.forms'], ['goog.structs.Map']);
goog.addDependency('dom/fullscreen.js', [
  'goog.dom.fullscreen',
  'goog.dom.fullscreen.EventType'
], [
  'goog.dom',
  'goog.userAgent',
  'goog.userAgent.product'
]);
goog.addDependency('dom/iframe.js', ['goog.dom.iframe'], [
  'goog.dom',
  'goog.userAgent'
]);
goog.addDependency('dom/iter.js', [
  'goog.dom.iter.AncestorIterator',
  'goog.dom.iter.ChildIterator',
  'goog.dom.iter.SiblingIterator'
], [
  'goog.iter.Iterator',
  'goog.iter.StopIteration'
]);
goog.addDependency('dom/multirange.js', [
  'goog.dom.MultiRange',
  'goog.dom.MultiRangeIterator'
], [
  'goog.array',
  'goog.dom.AbstractMultiRange',
  'goog.dom.AbstractRange',
  'goog.dom.RangeIterator',
  'goog.dom.RangeType',
  'goog.dom.SavedRange',
  'goog.dom.TextRange',
  'goog.iter.StopIteration',
  'goog.log'
]);
goog.addDependency('dom/nodeiterator.js', ['goog.dom.NodeIterator'], ['goog.dom.TagIterator']);
goog.addDependency('dom/nodeoffset.js', ['goog.dom.NodeOffset'], [
  'goog.Disposable',
  'goog.dom.TagName'
]);
goog.addDependency('dom/pattern/abstractpattern.js', ['goog.dom.pattern.AbstractPattern'], ['goog.dom.pattern.MatchType']);
goog.addDependency('dom/pattern/allchildren.js', ['goog.dom.pattern.AllChildren'], [
  'goog.dom.pattern.AbstractPattern',
  'goog.dom.pattern.MatchType'
]);
goog.addDependency('dom/pattern/callback/callback.js', ['goog.dom.pattern.callback'], [
  'goog.dom',
  'goog.dom.TagWalkType',
  'goog.iter'
]);
goog.addDependency('dom/pattern/callback/counter.js', ['goog.dom.pattern.callback.Counter'], []);
goog.addDependency('dom/pattern/callback/test.js', ['goog.dom.pattern.callback.Test'], ['goog.iter.StopIteration']);
goog.addDependency('dom/pattern/childmatches.js', ['goog.dom.pattern.ChildMatches'], [
  'goog.dom.pattern.AllChildren',
  'goog.dom.pattern.MatchType'
]);
goog.addDependency('dom/pattern/endtag.js', ['goog.dom.pattern.EndTag'], [
  'goog.dom.TagWalkType',
  'goog.dom.pattern.Tag'
]);
goog.addDependency('dom/pattern/fulltag.js', ['goog.dom.pattern.FullTag'], [
  'goog.dom.pattern.MatchType',
  'goog.dom.pattern.StartTag',
  'goog.dom.pattern.Tag'
]);
goog.addDependency('dom/pattern/matcher.js', ['goog.dom.pattern.Matcher'], [
  'goog.dom.TagIterator',
  'goog.dom.pattern.MatchType',
  'goog.iter'
]);
goog.addDependency('dom/pattern/nodetype.js', ['goog.dom.pattern.NodeType'], [
  'goog.dom.pattern.AbstractPattern',
  'goog.dom.pattern.MatchType'
]);
goog.addDependency('dom/pattern/pattern.js', [
  'goog.dom.pattern',
  'goog.dom.pattern.MatchType'
], []);
goog.addDependency('dom/pattern/repeat.js', ['goog.dom.pattern.Repeat'], [
  'goog.dom.NodeType',
  'goog.dom.pattern.AbstractPattern',
  'goog.dom.pattern.MatchType'
]);
goog.addDependency('dom/pattern/sequence.js', ['goog.dom.pattern.Sequence'], [
  'goog.dom.NodeType',
  'goog.dom.pattern.AbstractPattern',
  'goog.dom.pattern.MatchType'
]);
goog.addDependency('dom/pattern/starttag.js', ['goog.dom.pattern.StartTag'], [
  'goog.dom.TagWalkType',
  'goog.dom.pattern.Tag'
]);
goog.addDependency('dom/pattern/tag.js', ['goog.dom.pattern.Tag'], [
  'goog.dom.pattern',
  'goog.dom.pattern.AbstractPattern',
  'goog.dom.pattern.MatchType',
  'goog.object'
]);
goog.addDependency('dom/pattern/text.js', ['goog.dom.pattern.Text'], [
  'goog.dom.NodeType',
  'goog.dom.pattern',
  'goog.dom.pattern.AbstractPattern',
  'goog.dom.pattern.MatchType'
]);
goog.addDependency('dom/range.js', ['goog.dom.Range'], [
  'goog.dom',
  'goog.dom.AbstractRange',
  'goog.dom.ControlRange',
  'goog.dom.MultiRange',
  'goog.dom.NodeType',
  'goog.dom.TextRange',
  'goog.userAgent'
]);
goog.addDependency('dom/rangeendpoint.js', ['goog.dom.RangeEndpoint'], []);
goog.addDependency('dom/savedcaretrange.js', ['goog.dom.SavedCaretRange'], [
  'goog.array',
  'goog.dom',
  'goog.dom.SavedRange',
  'goog.dom.TagName',
  'goog.string'
]);
goog.addDependency('dom/savedrange.js', ['goog.dom.SavedRange'], [
  'goog.Disposable',
  'goog.log'
]);
goog.addDependency('dom/selection.js', ['goog.dom.selection'], [
  'goog.string',
  'goog.userAgent'
]);
goog.addDependency('dom/tagiterator.js', [
  'goog.dom.TagIterator',
  'goog.dom.TagWalkType'
], [
  'goog.dom.NodeType',
  'goog.iter.Iterator',
  'goog.iter.StopIteration'
]);
goog.addDependency('dom/tagname.js', ['goog.dom.TagName'], []);
goog.addDependency('dom/textrange.js', ['goog.dom.TextRange'], [
  'goog.array',
  'goog.dom',
  'goog.dom.AbstractRange',
  'goog.dom.RangeType',
  'goog.dom.SavedRange',
  'goog.dom.TagName',
  'goog.dom.TextRangeIterator',
  'goog.dom.browserrange',
  'goog.string',
  'goog.userAgent'
]);
goog.addDependency('dom/textrangeiterator.js', ['goog.dom.TextRangeIterator'], [
  'goog.array',
  'goog.dom.NodeType',
  'goog.dom.RangeIterator',
  'goog.dom.TagName',
  'goog.iter.StopIteration'
]);
goog.addDependency('dom/vendor.js', ['goog.dom.vendor'], ['goog.userAgent']);
goog.addDependency('dom/viewportsizemonitor.js', ['goog.dom.ViewportSizeMonitor'], [
  'goog.dom',
  'goog.events',
  'goog.events.EventTarget',
  'goog.events.EventType',
  'goog.math.Size'
]);
goog.addDependency('dom/xml.js', ['goog.dom.xml'], [
  'goog.dom',
  'goog.dom.NodeType'
]);
goog.addDependency('editor/browserfeature.js', ['goog.editor.BrowserFeature'], [
  'goog.editor.defines',
  'goog.userAgent',
  'goog.userAgent.product',
  'goog.userAgent.product.isVersion'
]);
goog.addDependency('editor/clicktoeditwrapper.js', ['goog.editor.ClickToEditWrapper'], [
  'goog.Disposable',
  'goog.asserts',
  'goog.dom',
  'goog.dom.Range',
  'goog.dom.TagName',
  'goog.editor.BrowserFeature',
  'goog.editor.Command',
  'goog.editor.Field.EventType',
  'goog.editor.range',
  'goog.events.BrowserEvent.MouseButton',
  'goog.events.EventHandler',
  'goog.events.EventType',
  'goog.log'
]);
goog.addDependency('editor/command.js', ['goog.editor.Command'], []);
goog.addDependency('editor/contenteditablefield.js', ['goog.editor.ContentEditableField'], [
  'goog.asserts',
  'goog.editor.Field',
  'goog.log'
]);
goog.addDependency('editor/defines.js', ['goog.editor.defines'], []);
goog.addDependency('editor/field.js', [
  'goog.editor.Field',
  'goog.editor.Field.EventType'
], [
  'goog.a11y.aria',
  'goog.a11y.aria.Role',
  'goog.array',
  'goog.asserts',
  'goog.async.Delay',
  'goog.dom',
  'goog.dom.Range',
  'goog.dom.TagName',
  'goog.editor.BrowserFeature',
  'goog.editor.Command',
  'goog.editor.Plugin',
  'goog.editor.icontent',
  'goog.editor.icontent.FieldFormatInfo',
  'goog.editor.icontent.FieldStyleInfo',
  'goog.editor.node',
  'goog.editor.range',
  'goog.events',
  'goog.events.EventHandler',
  'goog.events.EventTarget',
  'goog.events.EventType',
  'goog.events.KeyCodes',
  'goog.functions',
  'goog.log',
  'goog.string',
  'goog.string.Unicode',
  'goog.style',
  'goog.userAgent',
  'goog.userAgent.product'
]);
goog.addDependency('editor/field_test.js', ['goog.editor.field_test'], [
  'goog.dom',
  'goog.dom.Range',
  'goog.editor.BrowserFeature',
  'goog.editor.Field',
  'goog.editor.Plugin',
  'goog.editor.range',
  'goog.events',
  'goog.events.BrowserEvent',
  'goog.events.KeyCodes',
  'goog.functions',
  'goog.testing.LooseMock',
  'goog.testing.MockClock',
  'goog.testing.dom',
  'goog.testing.events',
  'goog.testing.events.Event',
  'goog.testing.recordFunction',
  'goog.userAgent'
]);
goog.addDependency('editor/focus.js', ['goog.editor.focus'], ['goog.dom.selection']);
goog.addDependency('editor/icontent.js', [
  'goog.editor.icontent',
  'goog.editor.icontent.FieldFormatInfo',
  'goog.editor.icontent.FieldStyleInfo'
], [
  'goog.editor.BrowserFeature',
  'goog.style',
  'goog.userAgent'
]);
goog.addDependency('editor/link.js', ['goog.editor.Link'], [
  'goog.array',
  'goog.dom',
  'goog.dom.NodeType',
  'goog.dom.Range',
  'goog.editor.BrowserFeature',
  'goog.editor.Command',
  'goog.editor.node',
  'goog.editor.range',
  'goog.string',
  'goog.string.Unicode',
  'goog.uri.utils',
  'goog.uri.utils.ComponentIndex'
]);
goog.addDependency('editor/node.js', ['goog.editor.node'], [
  'goog.dom',
  'goog.dom.NodeType',
  'goog.dom.TagName',
  'goog.dom.iter.ChildIterator',
  'goog.dom.iter.SiblingIterator',
  'goog.iter',
  'goog.object',
  'goog.string',
  'goog.string.Unicode',
  'goog.userAgent'
]);
goog.addDependency('editor/plugin.js', ['goog.editor.Plugin'], [
  'goog.editor.Command',
  'goog.events.EventTarget',
  'goog.functions',
  'goog.log',
  'goog.object',
  'goog.reflect'
]);
goog.addDependency('editor/plugins/abstractbubbleplugin.js', ['goog.editor.plugins.AbstractBubblePlugin'], [
  'goog.dom',
  'goog.dom.NodeType',
  'goog.dom.Range',
  'goog.dom.TagName',
  'goog.editor.Plugin',
  'goog.editor.style',
  'goog.events',
  'goog.events.EventHandler',
  'goog.events.EventType',
  'goog.events.KeyCodes',
  'goog.events.actionEventWrapper',
  'goog.functions',
  'goog.string.Unicode',
  'goog.ui.Component.EventType',
  'goog.ui.editor.Bubble',
  'goog.userAgent'
]);
goog.addDependency('editor/plugins/abstractdialogplugin.js', [
  'goog.editor.plugins.AbstractDialogPlugin',
  'goog.editor.plugins.AbstractDialogPlugin.EventType'
], [
  'goog.dom',
  'goog.dom.Range',
  'goog.editor.Field.EventType',
  'goog.editor.Plugin',
  'goog.editor.range',
  'goog.events',
  'goog.ui.editor.AbstractDialog.EventType'
]);
goog.addDependency('editor/plugins/abstracttabhandler.js', ['goog.editor.plugins.AbstractTabHandler'], [
  'goog.editor.Plugin',
  'goog.events.KeyCodes'
]);
goog.addDependency('editor/plugins/basictextformatter.js', [
  'goog.editor.plugins.BasicTextFormatter',
  'goog.editor.plugins.BasicTextFormatter.COMMAND'
], [
  'goog.array',
  'goog.dom',
  'goog.dom.NodeType',
  'goog.dom.Range',
  'goog.dom.TagName',
  'goog.editor.BrowserFeature',
  'goog.editor.Command',
  'goog.editor.Link',
  'goog.editor.Plugin',
  'goog.editor.node',
  'goog.editor.range',
  'goog.editor.style',
  'goog.iter',
  'goog.iter.StopIteration',
  'goog.log',
  'goog.object',
  'goog.string',
  'goog.string.Unicode',
  'goog.style',
  'goog.ui.editor.messages',
  'goog.userAgent'
]);
goog.addDependency('editor/plugins/blockquote.js', ['goog.editor.plugins.Blockquote'], [
  'goog.dom',
  'goog.dom.NodeType',
  'goog.dom.TagName',
  'goog.dom.classes',
  'goog.editor.BrowserFeature',
  'goog.editor.Command',
  'goog.editor.Plugin',
  'goog.editor.node',
  'goog.functions',
  'goog.log'
]);
goog.addDependency('editor/plugins/emoticons.js', ['goog.editor.plugins.Emoticons'], [
  'goog.dom.TagName',
  'goog.editor.Plugin',
  'goog.editor.range',
  'goog.functions',
  'goog.ui.emoji.Emoji',
  'goog.userAgent'
]);
goog.addDependency('editor/plugins/enterhandler.js', ['goog.editor.plugins.EnterHandler'], [
  'goog.dom',
  'goog.dom.NodeOffset',
  'goog.dom.NodeType',
  'goog.dom.Range',
  'goog.dom.TagName',
  'goog.editor.BrowserFeature',
  'goog.editor.Plugin',
  'goog.editor.node',
  'goog.editor.plugins.Blockquote',
  'goog.editor.range',
  'goog.editor.style',
  'goog.events.KeyCodes',
  'goog.functions',
  'goog.object',
  'goog.string',
  'goog.userAgent'
]);
goog.addDependency('editor/plugins/equationeditorbubble.js', ['goog.editor.plugins.equation.EquationBubble'], [
  'goog.dom',
  'goog.dom.TagName',
  'goog.editor.Command',
  'goog.editor.plugins.AbstractBubblePlugin',
  'goog.string.Unicode',
  'goog.ui.editor.Bubble',
  'goog.ui.equation.ImageRenderer'
]);
goog.addDependency('editor/plugins/equationeditorplugin.js', ['goog.editor.plugins.EquationEditorPlugin'], [
  'goog.dom',
  'goog.editor.Command',
  'goog.editor.plugins.AbstractDialogPlugin',
  'goog.editor.range',
  'goog.events',
  'goog.events.EventType',
  'goog.functions',
  'goog.log',
  'goog.ui.editor.AbstractDialog',
  'goog.ui.editor.EquationEditorDialog',
  'goog.ui.equation.ImageRenderer',
  'goog.ui.equation.PaletteManager'
]);
goog.addDependency('editor/plugins/firststrong.js', ['goog.editor.plugins.FirstStrong'], [
  'goog.dom.NodeType',
  'goog.dom.TagIterator',
  'goog.dom.TagName',
  'goog.editor.Command',
  'goog.editor.Plugin',
  'goog.editor.node',
  'goog.editor.range',
  'goog.i18n.bidi',
  'goog.i18n.uChar',
  'goog.iter',
  'goog.userAgent'
]);
goog.addDependency('editor/plugins/headerformatter.js', ['goog.editor.plugins.HeaderFormatter'], [
  'goog.editor.Command',
  'goog.editor.Plugin',
  'goog.userAgent'
]);
goog.addDependency('editor/plugins/linkbubble.js', [
  'goog.editor.plugins.LinkBubble',
  'goog.editor.plugins.LinkBubble.Action'
], [
  'goog.array',
  'goog.dom',
  'goog.editor.BrowserFeature',
  'goog.editor.Command',
  'goog.editor.Link',
  'goog.editor.plugins.AbstractBubblePlugin',
  'goog.editor.range',
  'goog.string',
  'goog.style',
  'goog.ui.editor.messages',
  'goog.uri.utils',
  'goog.window'
]);
goog.addDependency('editor/plugins/linkdialogplugin.js', ['goog.editor.plugins.LinkDialogPlugin'], [
  'goog.array',
  'goog.dom',
  'goog.editor.Command',
  'goog.editor.plugins.AbstractDialogPlugin',
  'goog.events.EventHandler',
  'goog.functions',
  'goog.ui.editor.AbstractDialog.EventType',
  'goog.ui.editor.LinkDialog',
  'goog.ui.editor.LinkDialog.EventType',
  'goog.ui.editor.LinkDialog.OkEvent',
  'goog.uri.utils'
]);
goog.addDependency('editor/plugins/linkshortcutplugin.js', ['goog.editor.plugins.LinkShortcutPlugin'], [
  'goog.editor.Command',
  'goog.editor.Link',
  'goog.editor.Plugin',
  'goog.string'
]);
goog.addDependency('editor/plugins/listtabhandler.js', ['goog.editor.plugins.ListTabHandler'], [
  'goog.dom.TagName',
  'goog.editor.Command',
  'goog.editor.plugins.AbstractTabHandler'
]);
goog.addDependency('editor/plugins/loremipsum.js', ['goog.editor.plugins.LoremIpsum'], [
  'goog.asserts',
  'goog.dom',
  'goog.editor.Command',
  'goog.editor.Plugin',
  'goog.editor.node',
  'goog.functions'
]);
goog.addDependency('editor/plugins/removeformatting.js', ['goog.editor.plugins.RemoveFormatting'], [
  'goog.dom',
  'goog.dom.NodeType',
  'goog.dom.Range',
  'goog.dom.TagName',
  'goog.editor.BrowserFeature',
  'goog.editor.Plugin',
  'goog.editor.node',
  'goog.editor.range',
  'goog.string',
  'goog.userAgent'
]);
goog.addDependency('editor/plugins/spacestabhandler.js', ['goog.editor.plugins.SpacesTabHandler'], [
  'goog.dom',
  'goog.dom.TagName',
  'goog.editor.plugins.AbstractTabHandler',
  'goog.editor.range'
]);
goog.addDependency('editor/plugins/tableeditor.js', ['goog.editor.plugins.TableEditor'], [
  'goog.array',
  'goog.dom',
  'goog.dom.TagName',
  'goog.editor.Plugin',
  'goog.editor.Table',
  'goog.editor.node',
  'goog.editor.range',
  'goog.object'
]);
goog.addDependency('editor/plugins/tagonenterhandler.js', ['goog.editor.plugins.TagOnEnterHandler'], [
  'goog.dom',
  'goog.dom.NodeType',
  'goog.dom.Range',
  'goog.dom.TagName',
  'goog.editor.Command',
  'goog.editor.node',
  'goog.editor.plugins.EnterHandler',
  'goog.editor.range',
  'goog.editor.style',
  'goog.events.KeyCodes',
  'goog.string',
  'goog.style',
  'goog.userAgent'
]);
goog.addDependency('editor/plugins/undoredo.js', ['goog.editor.plugins.UndoRedo'], [
  'goog.dom',
  'goog.dom.NodeOffset',
  'goog.dom.Range',
  'goog.editor.BrowserFeature',
  'goog.editor.Command',
  'goog.editor.Field.EventType',
  'goog.editor.Plugin',
  'goog.editor.node',
  'goog.editor.plugins.UndoRedoManager',
  'goog.editor.plugins.UndoRedoState',
  'goog.events',
  'goog.events.EventHandler',
  'goog.log'
]);
goog.addDependency('editor/plugins/undoredomanager.js', [
  'goog.editor.plugins.UndoRedoManager',
  'goog.editor.plugins.UndoRedoManager.EventType'
], [
  'goog.editor.plugins.UndoRedoState',
  'goog.events.EventTarget'
]);
goog.addDependency('editor/plugins/undoredostate.js', ['goog.editor.plugins.UndoRedoState'], ['goog.events.EventTarget']);
goog.addDependency('editor/range.js', [
  'goog.editor.range',
  'goog.editor.range.Point'
], [
  'goog.array',
  'goog.dom',
  'goog.dom.NodeType',
  'goog.dom.Range',
  'goog.dom.RangeEndpoint',
  'goog.dom.SavedCaretRange',
  'goog.editor.node',
  'goog.editor.style',
  'goog.iter',
  'goog.userAgent'
]);
goog.addDependency('editor/seamlessfield.js', ['goog.editor.SeamlessField'], [
  'goog.cssom.iframe.style',
  'goog.dom',
  'goog.dom.Range',
  'goog.dom.TagName',
  'goog.editor.BrowserFeature',
  'goog.editor.Field',
  'goog.editor.icontent',
  'goog.editor.icontent.FieldFormatInfo',
  'goog.editor.icontent.FieldStyleInfo',
  'goog.editor.node',
  'goog.events',
  'goog.events.EventType',
  'goog.log',
  'goog.style'
]);
goog.addDependency('editor/seamlessfield_test.js', ['goog.editor.seamlessfield_test'], [
  'goog.dom',
  'goog.dom.DomHelper',
  'goog.dom.Range',
  'goog.editor.BrowserFeature',
  'goog.editor.Field',
  'goog.editor.SeamlessField',
  'goog.events',
  'goog.functions',
  'goog.style',
  'goog.testing.MockClock',
  'goog.testing.MockRange',
  'goog.testing.jsunit'
]);
goog.addDependency('editor/style.js', ['goog.editor.style'], [
  'goog.dom',
  'goog.dom.NodeType',
  'goog.editor.BrowserFeature',
  'goog.events.EventType',
  'goog.object',
  'goog.style',
  'goog.userAgent'
]);
goog.addDependency('editor/table.js', [
  'goog.editor.Table',
  'goog.editor.TableCell',
  'goog.editor.TableRow'
], [
  'goog.dom',
  'goog.dom.DomHelper',
  'goog.dom.NodeType',
  'goog.dom.TagName',
  'goog.log',
  'goog.string.Unicode',
  'goog.style'
]);
goog.addDependency('events/actioneventwrapper.js', ['goog.events.actionEventWrapper'], [
  'goog.events',
  'goog.events.EventHandler',
  'goog.events.EventType',
  'goog.events.EventWrapper',
  'goog.events.KeyCodes'
]);
goog.addDependency('events/actionhandler.js', [
  'goog.events.ActionEvent',
  'goog.events.ActionHandler',
  'goog.events.ActionHandler.EventType',
  'goog.events.BeforeActionEvent'
], [
  'goog.events',
  'goog.events.BrowserEvent',
  'goog.events.EventTarget',
  'goog.events.EventType',
  'goog.events.KeyCodes',
  'goog.userAgent'
]);
goog.addDependency('events/browserevent.js', [
  'goog.events.BrowserEvent',
  'goog.events.BrowserEvent.MouseButton'
], [
  'goog.events.BrowserFeature',
  'goog.events.Event',
  'goog.events.EventType',
  'goog.reflect',
  'goog.userAgent'
]);
goog.addDependency('events/browserfeature.js', ['goog.events.BrowserFeature'], ['goog.userAgent']);
goog.addDependency('events/event.js', [
  'goog.events.Event',
  'goog.events.EventLike'
], ['goog.Disposable']);
goog.addDependency('events/eventhandler.js', ['goog.events.EventHandler'], [
  'goog.Disposable',
  'goog.events',
  'goog.object'
]);
goog.addDependency('events/events.js', [
  'goog.events',
  'goog.events.Key',
  'goog.events.ListenableType'
], [
  'goog.array',
  'goog.asserts',
  'goog.debug.entryPointRegistry',
  'goog.events.BrowserEvent',
  'goog.events.BrowserFeature',
  'goog.events.Listenable',
  'goog.events.Listener',
  'goog.object'
]);
goog.addDependency('events/eventtarget.js', ['goog.events.EventTarget'], [
  'goog.Disposable',
  'goog.array',
  'goog.asserts',
  'goog.events',
  'goog.events.Event',
  'goog.events.Listenable',
  'goog.events.ListenerMap',
  'goog.object'
]);
goog.addDependency('events/eventtargettester.js', [
  'goog.events.eventTargetTester',
  'goog.events.eventTargetTester.KeyType',
  'goog.events.eventTargetTester.UnlistenReturnType'
], [
  'goog.array',
  'goog.events',
  'goog.events.Event',
  'goog.events.EventTarget',
  'goog.testing.asserts',
  'goog.testing.recordFunction'
]);
goog.addDependency('events/eventtype.js', ['goog.events.EventType'], ['goog.userAgent']);
goog.addDependency('events/eventwrapper.js', ['goog.events.EventWrapper'], []);
goog.addDependency('events/filedrophandler.js', [
  'goog.events.FileDropHandler',
  'goog.events.FileDropHandler.EventType'
], [
  'goog.array',
  'goog.dom',
  'goog.events',
  'goog.events.BrowserEvent',
  'goog.events.EventHandler',
  'goog.events.EventTarget',
  'goog.events.EventType',
  'goog.log'
]);
goog.addDependency('events/focushandler.js', [
  'goog.events.FocusHandler',
  'goog.events.FocusHandler.EventType'
], [
  'goog.events',
  'goog.events.BrowserEvent',
  'goog.events.EventTarget',
  'goog.userAgent'
]);
goog.addDependency('events/imehandler.js', [
  'goog.events.ImeHandler',
  'goog.events.ImeHandler.Event',
  'goog.events.ImeHandler.EventType'
], [
  'goog.events.Event',
  'goog.events.EventHandler',
  'goog.events.EventTarget',
  'goog.events.EventType',
  'goog.events.KeyCodes',
  'goog.userAgent'
]);
goog.addDependency('events/inputhandler.js', [
  'goog.events.InputHandler',
  'goog.events.InputHandler.EventType'
], [
  'goog.Timer',
  'goog.dom',
  'goog.events.BrowserEvent',
  'goog.events.EventHandler',
  'goog.events.EventTarget',
  'goog.events.KeyCodes',
  'goog.userAgent'
]);
goog.addDependency('events/keycodes.js', ['goog.events.KeyCodes'], ['goog.userAgent']);
goog.addDependency('events/keyhandler.js', [
  'goog.events.KeyEvent',
  'goog.events.KeyHandler',
  'goog.events.KeyHandler.EventType'
], [
  'goog.events',
  'goog.events.BrowserEvent',
  'goog.events.EventTarget',
  'goog.events.EventType',
  'goog.events.KeyCodes',
  'goog.userAgent'
]);
goog.addDependency('events/keynames.js', ['goog.events.KeyNames'], []);
goog.addDependency('events/listenable.js', [
  'goog.events.Listenable',
  'goog.events.ListenableKey'
], []);
goog.addDependency('events/listener.js', ['goog.events.Listener'], ['goog.events.ListenableKey']);
goog.addDependency('events/listenermap.js', ['goog.events.ListenerMap'], [
  'goog.array',
  'goog.events.Listener',
  'goog.object'
]);
goog.addDependency('events/listenermap_test.js', ['goog.events.ListenerMapTest'], [
  'goog.dispose',
  'goog.events.EventTarget',
  'goog.events.ListenerMap',
  'goog.testing.jsunit'
]);
goog.addDependency('events/mousewheelhandler.js', [
  'goog.events.MouseWheelEvent',
  'goog.events.MouseWheelHandler',
  'goog.events.MouseWheelHandler.EventType'
], [
  'goog.dom',
  'goog.events',
  'goog.events.BrowserEvent',
  'goog.events.EventTarget',
  'goog.math',
  'goog.style',
  'goog.userAgent'
]);
goog.addDependency('events/onlinehandler.js', [
  'goog.events.OnlineHandler',
  'goog.events.OnlineHandler.EventType'
], [
  'goog.Timer',
  'goog.events.BrowserFeature',
  'goog.events.EventHandler',
  'goog.events.EventTarget',
  'goog.events.EventType',
  'goog.net.NetworkStatusMonitor',
  'goog.userAgent'
]);
goog.addDependency('events/pastehandler.js', [
  'goog.events.PasteHandler',
  'goog.events.PasteHandler.EventType',
  'goog.events.PasteHandler.State'
], [
  'goog.Timer',
  'goog.async.ConditionalDelay',
  'goog.events.BrowserEvent',
  'goog.events.EventHandler',
  'goog.events.EventTarget',
  'goog.events.EventType',
  'goog.events.KeyCodes',
  'goog.log',
  'goog.userAgent'
]);
goog.addDependency('format/emailaddress.js', ['goog.format.EmailAddress'], ['goog.string']);
goog.addDependency('format/format.js', ['goog.format'], [
  'goog.i18n.GraphemeBreak',
  'goog.string',
  'goog.userAgent'
]);
goog.addDependency('format/htmlprettyprinter.js', [
  'goog.format.HtmlPrettyPrinter',
  'goog.format.HtmlPrettyPrinter.Buffer'
], [
  'goog.object',
  'goog.string.StringBuffer'
]);
goog.addDependency('format/jsonprettyprinter.js', [
  'goog.format.JsonPrettyPrinter',
  'goog.format.JsonPrettyPrinter.HtmlDelimiters',
  'goog.format.JsonPrettyPrinter.TextDelimiters'
], [
  'goog.json',
  'goog.json.Serializer',
  'goog.string',
  'goog.string.StringBuffer',
  'goog.string.format'
]);
goog.addDependency('fs/entry.js', [
  'goog.fs.DirectoryEntry',
  'goog.fs.DirectoryEntry.Behavior',
  'goog.fs.Entry',
  'goog.fs.FileEntry'
], []);
goog.addDependency('fs/entryimpl.js', [
  'goog.fs.DirectoryEntryImpl',
  'goog.fs.EntryImpl',
  'goog.fs.FileEntryImpl'
], [
  'goog.array',
  'goog.async.Deferred',
  'goog.fs.DirectoryEntry',
  'goog.fs.Entry',
  'goog.fs.Error',
  'goog.fs.FileEntry',
  'goog.fs.FileWriter',
  'goog.functions',
  'goog.string'
]);
goog.addDependency('fs/error.js', [
  'goog.fs.Error',
  'goog.fs.Error.ErrorCode'
], [
  'goog.debug.Error',
  'goog.string'
]);
goog.addDependency('fs/filereader.js', [
  'goog.fs.FileReader',
  'goog.fs.FileReader.EventType',
  'goog.fs.FileReader.ReadyState'
], [
  'goog.async.Deferred',
  'goog.events.Event',
  'goog.events.EventTarget',
  'goog.fs.Error',
  'goog.fs.ProgressEvent'
]);
goog.addDependency('fs/filesaver.js', [
  'goog.fs.FileSaver',
  'goog.fs.FileSaver.EventType',
  'goog.fs.FileSaver.ProgressEvent',
  'goog.fs.FileSaver.ReadyState'
], [
  'goog.events.Event',
  'goog.events.EventTarget',
  'goog.fs.Error',
  'goog.fs.ProgressEvent'
]);
goog.addDependency('fs/filesystem.js', ['goog.fs.FileSystem'], []);
goog.addDependency('fs/filesystemimpl.js', ['goog.fs.FileSystemImpl'], [
  'goog.fs.DirectoryEntryImpl',
  'goog.fs.FileSystem'
]);
goog.addDependency('fs/filewriter.js', ['goog.fs.FileWriter'], [
  'goog.fs.Error',
  'goog.fs.FileSaver'
]);
goog.addDependency('fs/fs.js', ['goog.fs'], [
  'goog.array',
  'goog.async.Deferred',
  'goog.fs.Error',
  'goog.fs.FileReader',
  'goog.fs.FileSystemImpl',
  'goog.userAgent'
]);
goog.addDependency('fs/progressevent.js', ['goog.fs.ProgressEvent'], ['goog.events.Event']);
goog.addDependency('functions/functions.js', ['goog.functions'], []);
goog.addDependency('fx/abstractdragdrop.js', [
  'goog.fx.AbstractDragDrop',
  'goog.fx.AbstractDragDrop.EventType',
  'goog.fx.DragDropEvent',
  'goog.fx.DragDropItem'
], [
  'goog.dom',
  'goog.dom.classes',
  'goog.events',
  'goog.events.Event',
  'goog.events.EventHandler',
  'goog.events.EventTarget',
  'goog.events.EventType',
  'goog.fx.Dragger',
  'goog.fx.Dragger.EventType',
  'goog.math.Box',
  'goog.math.Coordinate',
  'goog.style'
]);
goog.addDependency('fx/anim/anim.js', [
  'goog.fx.anim',
  'goog.fx.anim.Animated'
], [
  'goog.async.AnimationDelay',
  'goog.async.Delay',
  'goog.object'
]);
goog.addDependency('fx/animation.js', [
  'goog.fx.Animation',
  'goog.fx.Animation.EventType',
  'goog.fx.Animation.State',
  'goog.fx.AnimationEvent'
], [
  'goog.array',
  'goog.events.Event',
  'goog.fx.Transition',
  'goog.fx.Transition.EventType',
  'goog.fx.TransitionBase.State',
  'goog.fx.anim',
  'goog.fx.anim.Animated'
]);
goog.addDependency('fx/animationqueue.js', [
  'goog.fx.AnimationParallelQueue',
  'goog.fx.AnimationQueue',
  'goog.fx.AnimationSerialQueue'
], [
  'goog.array',
  'goog.asserts',
  'goog.events.EventHandler',
  'goog.fx.Transition.EventType',
  'goog.fx.TransitionBase',
  'goog.fx.TransitionBase.State'
]);
goog.addDependency('fx/css3/fx.js', ['goog.fx.css3'], ['goog.fx.css3.Transition']);
goog.addDependency('fx/css3/transition.js', ['goog.fx.css3.Transition'], [
  'goog.Timer',
  'goog.fx.TransitionBase',
  'goog.style',
  'goog.style.transition'
]);
goog.addDependency('fx/cssspriteanimation.js', ['goog.fx.CssSpriteAnimation'], ['goog.fx.Animation']);
goog.addDependency('fx/dom.js', [
  'goog.fx.dom',
  'goog.fx.dom.BgColorTransform',
  'goog.fx.dom.ColorTransform',
  'goog.fx.dom.Fade',
  'goog.fx.dom.FadeIn',
  'goog.fx.dom.FadeInAndShow',
  'goog.fx.dom.FadeOut',
  'goog.fx.dom.FadeOutAndHide',
  'goog.fx.dom.PredefinedEffect',
  'goog.fx.dom.Resize',
  'goog.fx.dom.ResizeHeight',
  'goog.fx.dom.ResizeWidth',
  'goog.fx.dom.Scroll',
  'goog.fx.dom.Slide',
  'goog.fx.dom.SlideFrom',
  'goog.fx.dom.Swipe'
], [
  'goog.color',
  'goog.events',
  'goog.fx.Animation',
  'goog.fx.Transition.EventType',
  'goog.style',
  'goog.style.bidi'
]);
goog.addDependency('fx/dragdrop.js', ['goog.fx.DragDrop'], [
  'goog.fx.AbstractDragDrop',
  'goog.fx.DragDropItem'
]);
goog.addDependency('fx/dragdropgroup.js', ['goog.fx.DragDropGroup'], [
  'goog.dom',
  'goog.fx.AbstractDragDrop',
  'goog.fx.DragDropItem'
]);
goog.addDependency('fx/dragger.js', [
  'goog.fx.DragEvent',
  'goog.fx.Dragger',
  'goog.fx.Dragger.EventType'
], [
  'goog.dom',
  'goog.events',
  'goog.events.Event',
  'goog.events.EventHandler',
  'goog.events.EventTarget',
  'goog.events.EventType',
  'goog.math.Coordinate',
  'goog.math.Rect',
  'goog.style',
  'goog.style.bidi',
  'goog.userAgent'
]);
goog.addDependency('fx/draglistgroup.js', [
  'goog.fx.DragListDirection',
  'goog.fx.DragListGroup',
  'goog.fx.DragListGroup.EventType',
  'goog.fx.DragListGroupEvent'
], [
  'goog.asserts',
  'goog.dom',
  'goog.dom.NodeType',
  'goog.dom.classes',
  'goog.events.Event',
  'goog.events.EventHandler',
  'goog.events.EventTarget',
  'goog.events.EventType',
  'goog.fx.Dragger',
  'goog.fx.Dragger.EventType',
  'goog.math.Coordinate',
  'goog.style'
]);
goog.addDependency('fx/dragscrollsupport.js', ['goog.fx.DragScrollSupport'], [
  'goog.Disposable',
  'goog.Timer',
  'goog.dom',
  'goog.events.EventHandler',
  'goog.events.EventType',
  'goog.math.Coordinate',
  'goog.style'
]);
goog.addDependency('fx/easing.js', ['goog.fx.easing'], []);
goog.addDependency('fx/fx.js', ['goog.fx'], [
  'goog.asserts',
  'goog.fx.Animation',
  'goog.fx.Animation.EventType',
  'goog.fx.Animation.State',
  'goog.fx.AnimationEvent',
  'goog.fx.Transition.EventType',
  'goog.fx.easing'
]);
goog.addDependency('fx/transition.js', [
  'goog.fx.Transition',
  'goog.fx.Transition.EventType'
], []);
goog.addDependency('fx/transitionbase.js', [
  'goog.fx.TransitionBase',
  'goog.fx.TransitionBase.State'
], [
  'goog.events.EventTarget',
  'goog.fx.Transition',
  'goog.fx.Transition.EventType'
]);
goog.addDependency('gears/basestore.js', [
  'goog.gears.BaseStore',
  'goog.gears.BaseStore.SchemaType'
], ['goog.Disposable']);
goog.addDependency('gears/database.js', [
  'goog.gears.Database',
  'goog.gears.Database.EventType',
  'goog.gears.Database.TransactionEvent'
], [
  'goog.array',
  'goog.debug',
  'goog.events.Event',
  'goog.events.EventTarget',
  'goog.gears',
  'goog.json',
  'goog.log'
]);
goog.addDependency('gears/gears.js', ['goog.gears'], ['goog.string']);
goog.addDependency('gears/httprequest.js', ['goog.gears.HttpRequest'], [
  'goog.Timer',
  'goog.gears',
  'goog.net.WrapperXmlHttpFactory',
  'goog.net.XmlHttp'
]);
goog.addDependency('gears/loggerclient.js', ['goog.gears.LoggerClient'], [
  'goog.Disposable',
  'goog.debug',
  'goog.debug.Logger'
]);
goog.addDependency('gears/loggerserver.js', ['goog.gears.LoggerServer'], [
  'goog.Disposable',
  'goog.gears.Worker.EventType',
  'goog.log',
  'goog.log.Level'
]);
goog.addDependency('gears/logstore.js', [
  'goog.gears.LogStore',
  'goog.gears.LogStore.Query'
], [
  'goog.async.Delay',
  'goog.debug.LogManager',
  'goog.gears.BaseStore',
  'goog.gears.BaseStore.SchemaType',
  'goog.json',
  'goog.log',
  'goog.log.Level',
  'goog.log.LogRecord'
]);
goog.addDependency('gears/managedresourcestore.js', [
  'goog.gears.ManagedResourceStore',
  'goog.gears.ManagedResourceStore.EventType',
  'goog.gears.ManagedResourceStore.UpdateStatus',
  'goog.gears.ManagedResourceStoreEvent'
], [
  'goog.events.Event',
  'goog.events.EventTarget',
  'goog.gears',
  'goog.log',
  'goog.string'
]);
goog.addDependency('gears/multipartformdata.js', ['goog.gears.MultipartFormData'], [
  'goog.asserts',
  'goog.gears',
  'goog.string'
]);
goog.addDependency('gears/statustype.js', ['goog.gears.StatusType'], []);
goog.addDependency('gears/urlcapture.js', [
  'goog.gears.UrlCapture',
  'goog.gears.UrlCapture.Event',
  'goog.gears.UrlCapture.EventType'
], [
  'goog.Uri',
  'goog.events.Event',
  'goog.events.EventTarget',
  'goog.gears',
  'goog.log'
]);
goog.addDependency('gears/worker.js', [
  'goog.gears.Worker',
  'goog.gears.Worker.EventType',
  'goog.gears.WorkerEvent'
], [
  'goog.events.Event',
  'goog.events.EventTarget'
]);
goog.addDependency('gears/workerchannel.js', ['goog.gears.WorkerChannel'], [
  'goog.Disposable',
  'goog.debug',
  'goog.events',
  'goog.gears.Worker',
  'goog.gears.Worker.EventType',
  'goog.gears.WorkerEvent',
  'goog.json',
  'goog.log',
  'goog.messaging.AbstractChannel'
]);
goog.addDependency('gears/workerpool.js', [
  'goog.gears.WorkerPool',
  'goog.gears.WorkerPool.Event',
  'goog.gears.WorkerPool.EventType'
], [
  'goog.events.Event',
  'goog.events.EventTarget',
  'goog.gears',
  'goog.gears.Worker'
]);
goog.addDependency('graphics/abstractgraphics.js', ['goog.graphics.AbstractGraphics'], [
  'goog.dom',
  'goog.graphics.Path',
  'goog.math.Coordinate',
  'goog.math.Size',
  'goog.style',
  'goog.ui.Component'
]);
goog.addDependency('graphics/affinetransform.js', ['goog.graphics.AffineTransform'], ['goog.math']);
goog.addDependency('graphics/canvaselement.js', [
  'goog.graphics.CanvasEllipseElement',
  'goog.graphics.CanvasGroupElement',
  'goog.graphics.CanvasImageElement',
  'goog.graphics.CanvasPathElement',
  'goog.graphics.CanvasRectElement',
  'goog.graphics.CanvasTextElement'
], [
  'goog.array',
  'goog.dom',
  'goog.dom.TagName',
  'goog.graphics.EllipseElement',
  'goog.graphics.GroupElement',
  'goog.graphics.ImageElement',
  'goog.graphics.Path',
  'goog.graphics.PathElement',
  'goog.graphics.RectElement',
  'goog.graphics.TextElement',
  'goog.math',
  'goog.string'
]);
goog.addDependency('graphics/canvasgraphics.js', ['goog.graphics.CanvasGraphics'], [
  'goog.events.EventType',
  'goog.graphics.AbstractGraphics',
  'goog.graphics.CanvasEllipseElement',
  'goog.graphics.CanvasGroupElement',
  'goog.graphics.CanvasImageElement',
  'goog.graphics.CanvasPathElement',
  'goog.graphics.CanvasRectElement',
  'goog.graphics.CanvasTextElement',
  'goog.graphics.SolidFill',
  'goog.math.Size',
  'goog.style'
]);
goog.addDependency('graphics/element.js', ['goog.graphics.Element'], [
  'goog.events',
  'goog.events.EventTarget',
  'goog.events.Listenable',
  'goog.graphics.AffineTransform',
  'goog.math'
]);
goog.addDependency('graphics/ellipseelement.js', ['goog.graphics.EllipseElement'], ['goog.graphics.StrokeAndFillElement']);
goog.addDependency('graphics/ext/coordinates.js', ['goog.graphics.ext.coordinates'], ['goog.string']);
goog.addDependency('graphics/ext/element.js', ['goog.graphics.ext.Element'], [
  'goog.events',
  'goog.events.EventTarget',
  'goog.functions',
  'goog.graphics',
  'goog.graphics.ext.coordinates'
]);
goog.addDependency('graphics/ext/ellipse.js', ['goog.graphics.ext.Ellipse'], ['goog.graphics.ext.StrokeAndFillElement']);
goog.addDependency('graphics/ext/ext.js', ['goog.graphics.ext'], [
  'goog.graphics.ext.Ellipse',
  'goog.graphics.ext.Graphics',
  'goog.graphics.ext.Group',
  'goog.graphics.ext.Image',
  'goog.graphics.ext.Rectangle',
  'goog.graphics.ext.Shape',
  'goog.graphics.ext.coordinates'
]);
goog.addDependency('graphics/ext/graphics.js', ['goog.graphics.ext.Graphics'], [
  'goog.events.EventType',
  'goog.graphics.ext.Group'
]);
goog.addDependency('graphics/ext/group.js', ['goog.graphics.ext.Group'], ['goog.graphics.ext.Element']);
goog.addDependency('graphics/ext/image.js', ['goog.graphics.ext.Image'], ['goog.graphics.ext.Element']);
goog.addDependency('graphics/ext/path.js', ['goog.graphics.ext.Path'], [
  'goog.graphics.AffineTransform',
  'goog.graphics.Path',
  'goog.math',
  'goog.math.Rect'
]);
goog.addDependency('graphics/ext/rectangle.js', ['goog.graphics.ext.Rectangle'], ['goog.graphics.ext.StrokeAndFillElement']);
goog.addDependency('graphics/ext/shape.js', ['goog.graphics.ext.Shape'], [
  'goog.graphics.ext.Path',
  'goog.graphics.ext.StrokeAndFillElement',
  'goog.math.Rect'
]);
goog.addDependency('graphics/ext/strokeandfillelement.js', ['goog.graphics.ext.StrokeAndFillElement'], ['goog.graphics.ext.Element']);
goog.addDependency('graphics/fill.js', ['goog.graphics.Fill'], []);
goog.addDependency('graphics/font.js', ['goog.graphics.Font'], []);
goog.addDependency('graphics/graphics.js', ['goog.graphics'], [
  'goog.graphics.CanvasGraphics',
  'goog.graphics.SvgGraphics',
  'goog.graphics.VmlGraphics',
  'goog.userAgent'
]);
goog.addDependency('graphics/groupelement.js', ['goog.graphics.GroupElement'], ['goog.graphics.Element']);
goog.addDependency('graphics/imageelement.js', ['goog.graphics.ImageElement'], ['goog.graphics.Element']);
goog.addDependency('graphics/lineargradient.js', ['goog.graphics.LinearGradient'], [
  'goog.asserts',
  'goog.graphics.Fill'
]);
goog.addDependency('graphics/path.js', [
  'goog.graphics.Path',
  'goog.graphics.Path.Segment'
], [
  'goog.array',
  'goog.math'
]);
goog.addDependency('graphics/pathelement.js', ['goog.graphics.PathElement'], ['goog.graphics.StrokeAndFillElement']);
goog.addDependency('graphics/paths.js', ['goog.graphics.paths'], [
  'goog.graphics.Path',
  'goog.math.Coordinate'
]);
goog.addDependency('graphics/rectelement.js', ['goog.graphics.RectElement'], ['goog.graphics.StrokeAndFillElement']);
goog.addDependency('graphics/solidfill.js', ['goog.graphics.SolidFill'], ['goog.graphics.Fill']);
goog.addDependency('graphics/stroke.js', ['goog.graphics.Stroke'], []);
goog.addDependency('graphics/strokeandfillelement.js', ['goog.graphics.StrokeAndFillElement'], ['goog.graphics.Element']);
goog.addDependency('graphics/svgelement.js', [
  'goog.graphics.SvgEllipseElement',
  'goog.graphics.SvgGroupElement',
  'goog.graphics.SvgImageElement',
  'goog.graphics.SvgPathElement',
  'goog.graphics.SvgRectElement',
  'goog.graphics.SvgTextElement'
], [
  'goog.dom',
  'goog.graphics.EllipseElement',
  'goog.graphics.GroupElement',
  'goog.graphics.ImageElement',
  'goog.graphics.PathElement',
  'goog.graphics.RectElement',
  'goog.graphics.TextElement'
]);
goog.addDependency('graphics/svggraphics.js', ['goog.graphics.SvgGraphics'], [
  'goog.Timer',
  'goog.dom',
  'goog.events.EventHandler',
  'goog.events.EventType',
  'goog.graphics.AbstractGraphics',
  'goog.graphics.LinearGradient',
  'goog.graphics.Path',
  'goog.graphics.SolidFill',
  'goog.graphics.Stroke',
  'goog.graphics.SvgEllipseElement',
  'goog.graphics.SvgGroupElement',
  'goog.graphics.SvgImageElement',
  'goog.graphics.SvgPathElement',
  'goog.graphics.SvgRectElement',
  'goog.graphics.SvgTextElement',
  'goog.math',
  'goog.math.Size',
  'goog.style',
  'goog.userAgent'
]);
goog.addDependency('graphics/textelement.js', ['goog.graphics.TextElement'], ['goog.graphics.StrokeAndFillElement']);
goog.addDependency('graphics/vmlelement.js', [
  'goog.graphics.VmlEllipseElement',
  'goog.graphics.VmlGroupElement',
  'goog.graphics.VmlImageElement',
  'goog.graphics.VmlPathElement',
  'goog.graphics.VmlRectElement',
  'goog.graphics.VmlTextElement'
], [
  'goog.dom',
  'goog.graphics.EllipseElement',
  'goog.graphics.GroupElement',
  'goog.graphics.ImageElement',
  'goog.graphics.PathElement',
  'goog.graphics.RectElement',
  'goog.graphics.TextElement'
]);
goog.addDependency('graphics/vmlgraphics.js', ['goog.graphics.VmlGraphics'], [
  'goog.array',
  'goog.events',
  'goog.events.EventHandler',
  'goog.events.EventType',
  'goog.graphics.AbstractGraphics',
  'goog.graphics.LinearGradient',
  'goog.graphics.Path',
  'goog.graphics.SolidFill',
  'goog.graphics.VmlEllipseElement',
  'goog.graphics.VmlGroupElement',
  'goog.graphics.VmlImageElement',
  'goog.graphics.VmlPathElement',
  'goog.graphics.VmlRectElement',
  'goog.graphics.VmlTextElement',
  'goog.math',
  'goog.math.Size',
  'goog.string',
  'goog.style'
]);
goog.addDependency('history/event.js', ['goog.history.Event'], [
  'goog.events.Event',
  'goog.history.EventType'
]);
goog.addDependency('history/eventtype.js', ['goog.history.EventType'], []);
goog.addDependency('history/history.js', [
  'goog.History',
  'goog.History.Event',
  'goog.History.EventType'
], [
  'goog.Timer',
  'goog.dom',
  'goog.events.EventHandler',
  'goog.events.EventTarget',
  'goog.events.EventType',
  'goog.history.Event',
  'goog.history.EventType',
  'goog.memoize',
  'goog.string',
  'goog.userAgent'
]);
goog.addDependency('history/history_test.js', ['goog.HistoryTest'], [
  'goog.History',
  'goog.testing.jsunit',
  'goog.userAgent'
]);
goog.addDependency('history/html5history.js', [
  'goog.history.Html5History',
  'goog.history.Html5History.TokenTransformer'
], [
  'goog.asserts',
  'goog.events',
  'goog.events.EventTarget',
  'goog.events.EventType',
  'goog.history.Event',
  'goog.history.EventType'
]);
goog.addDependency('i18n/bidi.js', ['goog.i18n.bidi'], []);
goog.addDependency('i18n/bidiformatter.js', ['goog.i18n.BidiFormatter'], [
  'goog.i18n.bidi',
  'goog.string'
]);
goog.addDependency('i18n/charlistdecompressor.js', ['goog.i18n.CharListDecompressor'], [
  'goog.array',
  'goog.i18n.uChar'
]);
goog.addDependency('i18n/charpickerdata.js', ['goog.i18n.CharPickerData'], []);
goog.addDependency('i18n/collation.js', ['goog.i18n.collation'], []);
goog.addDependency('i18n/compactnumberformatsymbols.js', [
  'goog.i18n.CompactNumberFormatSymbols',
  'goog.i18n.CompactNumberFormatSymbols_af',
  'goog.i18n.CompactNumberFormatSymbols_af_ZA',
  'goog.i18n.CompactNumberFormatSymbols_am',
  'goog.i18n.CompactNumberFormatSymbols_am_ET',
  'goog.i18n.CompactNumberFormatSymbols_ar',
  'goog.i18n.CompactNumberFormatSymbols_ar_001',
  'goog.i18n.CompactNumberFormatSymbols_ar_EG',
  'goog.i18n.CompactNumberFormatSymbols_bg',
  'goog.i18n.CompactNumberFormatSymbols_bg_BG',
  'goog.i18n.CompactNumberFormatSymbols_bn',
  'goog.i18n.CompactNumberFormatSymbols_bn_BD',
  'goog.i18n.CompactNumberFormatSymbols_br',
  'goog.i18n.CompactNumberFormatSymbols_br_FR',
  'goog.i18n.CompactNumberFormatSymbols_ca',
  'goog.i18n.CompactNumberFormatSymbols_ca_AD',
  'goog.i18n.CompactNumberFormatSymbols_ca_ES',
  'goog.i18n.CompactNumberFormatSymbols_chr',
  'goog.i18n.CompactNumberFormatSymbols_chr_US',
  'goog.i18n.CompactNumberFormatSymbols_cs',
  'goog.i18n.CompactNumberFormatSymbols_cs_CZ',
  'goog.i18n.CompactNumberFormatSymbols_cy',
  'goog.i18n.CompactNumberFormatSymbols_cy_GB',
  'goog.i18n.CompactNumberFormatSymbols_da',
  'goog.i18n.CompactNumberFormatSymbols_da_DK',
  'goog.i18n.CompactNumberFormatSymbols_de',
  'goog.i18n.CompactNumberFormatSymbols_de_AT',
  'goog.i18n.CompactNumberFormatSymbols_de_BE',
  'goog.i18n.CompactNumberFormatSymbols_de_CH',
  'goog.i18n.CompactNumberFormatSymbols_de_DE',
  'goog.i18n.CompactNumberFormatSymbols_de_LU',
  'goog.i18n.CompactNumberFormatSymbols_el',
  'goog.i18n.CompactNumberFormatSymbols_el_GR',
  'goog.i18n.CompactNumberFormatSymbols_en',
  'goog.i18n.CompactNumberFormatSymbols_en_AS',
  'goog.i18n.CompactNumberFormatSymbols_en_AU',
  'goog.i18n.CompactNumberFormatSymbols_en_Dsrt_US',
  'goog.i18n.CompactNumberFormatSymbols_en_FM',
  'goog.i18n.CompactNumberFormatSymbols_en_GB',
  'goog.i18n.CompactNumberFormatSymbols_en_GU',
  'goog.i18n.CompactNumberFormatSymbols_en_IE',
  'goog.i18n.CompactNumberFormatSymbols_en_IN',
  'goog.i18n.CompactNumberFormatSymbols_en_MH',
  'goog.i18n.CompactNumberFormatSymbols_en_MP',
  'goog.i18n.CompactNumberFormatSymbols_en_PR',
  'goog.i18n.CompactNumberFormatSymbols_en_PW',
  'goog.i18n.CompactNumberFormatSymbols_en_SG',
  'goog.i18n.CompactNumberFormatSymbols_en_TC',
  'goog.i18n.CompactNumberFormatSymbols_en_UM',
  'goog.i18n.CompactNumberFormatSymbols_en_US',
  'goog.i18n.CompactNumberFormatSymbols_en_VG',
  'goog.i18n.CompactNumberFormatSymbols_en_VI',
  'goog.i18n.CompactNumberFormatSymbols_en_ZA',
  'goog.i18n.CompactNumberFormatSymbols_es',
  'goog.i18n.CompactNumberFormatSymbols_es_419',
  'goog.i18n.CompactNumberFormatSymbols_es_EA',
  'goog.i18n.CompactNumberFormatSymbols_es_ES',
  'goog.i18n.CompactNumberFormatSymbols_es_IC',
  'goog.i18n.CompactNumberFormatSymbols_et',
  'goog.i18n.CompactNumberFormatSymbols_et_EE',
  'goog.i18n.CompactNumberFormatSymbols_eu',
  'goog.i18n.CompactNumberFormatSymbols_eu_ES',
  'goog.i18n.CompactNumberFormatSymbols_fa',
  'goog.i18n.CompactNumberFormatSymbols_fa_IR',
  'goog.i18n.CompactNumberFormatSymbols_fi',
  'goog.i18n.CompactNumberFormatSymbols_fi_FI',
  'goog.i18n.CompactNumberFormatSymbols_fil',
  'goog.i18n.CompactNumberFormatSymbols_fil_PH',
  'goog.i18n.CompactNumberFormatSymbols_fr',
  'goog.i18n.CompactNumberFormatSymbols_fr_BL',
  'goog.i18n.CompactNumberFormatSymbols_fr_CA',
  'goog.i18n.CompactNumberFormatSymbols_fr_FR',
  'goog.i18n.CompactNumberFormatSymbols_fr_GF',
  'goog.i18n.CompactNumberFormatSymbols_fr_GP',
  'goog.i18n.CompactNumberFormatSymbols_fr_MC',
  'goog.i18n.CompactNumberFormatSymbols_fr_MF',
  'goog.i18n.CompactNumberFormatSymbols_fr_MQ',
  'goog.i18n.CompactNumberFormatSymbols_fr_RE',
  'goog.i18n.CompactNumberFormatSymbols_fr_YT',
  'goog.i18n.CompactNumberFormatSymbols_gl',
  'goog.i18n.CompactNumberFormatSymbols_gl_ES',
  'goog.i18n.CompactNumberFormatSymbols_gsw',
  'goog.i18n.CompactNumberFormatSymbols_gsw_CH',
  'goog.i18n.CompactNumberFormatSymbols_gu',
  'goog.i18n.CompactNumberFormatSymbols_gu_IN',
  'goog.i18n.CompactNumberFormatSymbols_haw',
  'goog.i18n.CompactNumberFormatSymbols_haw_US',
  'goog.i18n.CompactNumberFormatSymbols_he',
  'goog.i18n.CompactNumberFormatSymbols_he_IL',
  'goog.i18n.CompactNumberFormatSymbols_hi',
  'goog.i18n.CompactNumberFormatSymbols_hi_IN',
  'goog.i18n.CompactNumberFormatSymbols_hr',
  'goog.i18n.CompactNumberFormatSymbols_hr_HR',
  'goog.i18n.CompactNumberFormatSymbols_hu',
  'goog.i18n.CompactNumberFormatSymbols_hu_HU',
  'goog.i18n.CompactNumberFormatSymbols_id',
  'goog.i18n.CompactNumberFormatSymbols_id_ID',
  'goog.i18n.CompactNumberFormatSymbols_in',
  'goog.i18n.CompactNumberFormatSymbols_is',
  'goog.i18n.CompactNumberFormatSymbols_is_IS',
  'goog.i18n.CompactNumberFormatSymbols_it',
  'goog.i18n.CompactNumberFormatSymbols_it_IT',
  'goog.i18n.CompactNumberFormatSymbols_it_SM',
  'goog.i18n.CompactNumberFormatSymbols_iw',
  'goog.i18n.CompactNumberFormatSymbols_ja',
  'goog.i18n.CompactNumberFormatSymbols_ja_JP',
  'goog.i18n.CompactNumberFormatSymbols_kn',
  'goog.i18n.CompactNumberFormatSymbols_kn_IN',
  'goog.i18n.CompactNumberFormatSymbols_ko',
  'goog.i18n.CompactNumberFormatSymbols_ko_KR',
  'goog.i18n.CompactNumberFormatSymbols_ln',
  'goog.i18n.CompactNumberFormatSymbols_ln_CD',
  'goog.i18n.CompactNumberFormatSymbols_lt',
  'goog.i18n.CompactNumberFormatSymbols_lt_LT',
  'goog.i18n.CompactNumberFormatSymbols_lv',
  'goog.i18n.CompactNumberFormatSymbols_lv_LV',
  'goog.i18n.CompactNumberFormatSymbols_ml',
  'goog.i18n.CompactNumberFormatSymbols_ml_IN',
  'goog.i18n.CompactNumberFormatSymbols_mr',
  'goog.i18n.CompactNumberFormatSymbols_mr_IN',
  'goog.i18n.CompactNumberFormatSymbols_ms',
  'goog.i18n.CompactNumberFormatSymbols_ms_Latn_MY',
  'goog.i18n.CompactNumberFormatSymbols_mt',
  'goog.i18n.CompactNumberFormatSymbols_mt_MT',
  'goog.i18n.CompactNumberFormatSymbols_nb',
  'goog.i18n.CompactNumberFormatSymbols_nb_NO',
  'goog.i18n.CompactNumberFormatSymbols_nl',
  'goog.i18n.CompactNumberFormatSymbols_nl_NL',
  'goog.i18n.CompactNumberFormatSymbols_no',
  'goog.i18n.CompactNumberFormatSymbols_or',
  'goog.i18n.CompactNumberFormatSymbols_or_IN',
  'goog.i18n.CompactNumberFormatSymbols_pl',
  'goog.i18n.CompactNumberFormatSymbols_pl_PL',
  'goog.i18n.CompactNumberFormatSymbols_pt',
  'goog.i18n.CompactNumberFormatSymbols_pt_BR',
  'goog.i18n.CompactNumberFormatSymbols_pt_PT',
  'goog.i18n.CompactNumberFormatSymbols_ro',
  'goog.i18n.CompactNumberFormatSymbols_ro_RO',
  'goog.i18n.CompactNumberFormatSymbols_ru',
  'goog.i18n.CompactNumberFormatSymbols_ru_RU',
  'goog.i18n.CompactNumberFormatSymbols_sk',
  'goog.i18n.CompactNumberFormatSymbols_sk_SK',
  'goog.i18n.CompactNumberFormatSymbols_sl',
  'goog.i18n.CompactNumberFormatSymbols_sl_SI',
  'goog.i18n.CompactNumberFormatSymbols_sq',
  'goog.i18n.CompactNumberFormatSymbols_sq_AL',
  'goog.i18n.CompactNumberFormatSymbols_sr',
  'goog.i18n.CompactNumberFormatSymbols_sr_Cyrl_RS',
  'goog.i18n.CompactNumberFormatSymbols_sv',
  'goog.i18n.CompactNumberFormatSymbols_sv_SE',
  'goog.i18n.CompactNumberFormatSymbols_sw',
  'goog.i18n.CompactNumberFormatSymbols_sw_TZ',
  'goog.i18n.CompactNumberFormatSymbols_ta',
  'goog.i18n.CompactNumberFormatSymbols_ta_IN',
  'goog.i18n.CompactNumberFormatSymbols_te',
  'goog.i18n.CompactNumberFormatSymbols_te_IN',
  'goog.i18n.CompactNumberFormatSymbols_th',
  'goog.i18n.CompactNumberFormatSymbols_th_TH',
  'goog.i18n.CompactNumberFormatSymbols_tl',
  'goog.i18n.CompactNumberFormatSymbols_tr',
  'goog.i18n.CompactNumberFormatSymbols_tr_TR',
  'goog.i18n.CompactNumberFormatSymbols_uk',
  'goog.i18n.CompactNumberFormatSymbols_uk_UA',
  'goog.i18n.CompactNumberFormatSymbols_ur',
  'goog.i18n.CompactNumberFormatSymbols_ur_PK',
  'goog.i18n.CompactNumberFormatSymbols_vi',
  'goog.i18n.CompactNumberFormatSymbols_vi_VN',
  'goog.i18n.CompactNumberFormatSymbols_zh',
  'goog.i18n.CompactNumberFormatSymbols_zh_CN',
  'goog.i18n.CompactNumberFormatSymbols_zh_HK',
  'goog.i18n.CompactNumberFormatSymbols_zh_Hans_CN',
  'goog.i18n.CompactNumberFormatSymbols_zh_TW',
  'goog.i18n.CompactNumberFormatSymbols_zu',
  'goog.i18n.CompactNumberFormatSymbols_zu_ZA'
], []);
goog.addDependency('i18n/compactnumberformatsymbols_ext.js', [
  'goog.i18n.CompactNumberFormatSymbolsExt',
  'goog.i18n.CompactNumberFormatSymbols_aa',
  'goog.i18n.CompactNumberFormatSymbols_aa_DJ',
  'goog.i18n.CompactNumberFormatSymbols_aa_ER',
  'goog.i18n.CompactNumberFormatSymbols_aa_ET',
  'goog.i18n.CompactNumberFormatSymbols_af_NA',
  'goog.i18n.CompactNumberFormatSymbols_agq',
  'goog.i18n.CompactNumberFormatSymbols_agq_CM',
  'goog.i18n.CompactNumberFormatSymbols_ak',
  'goog.i18n.CompactNumberFormatSymbols_ak_GH',
  'goog.i18n.CompactNumberFormatSymbols_ar_AE',
  'goog.i18n.CompactNumberFormatSymbols_ar_BH',
  'goog.i18n.CompactNumberFormatSymbols_ar_DJ',
  'goog.i18n.CompactNumberFormatSymbols_ar_DZ',
  'goog.i18n.CompactNumberFormatSymbols_ar_EH',
  'goog.i18n.CompactNumberFormatSymbols_ar_ER',
  'goog.i18n.CompactNumberFormatSymbols_ar_IL',
  'goog.i18n.CompactNumberFormatSymbols_ar_IQ',
  'goog.i18n.CompactNumberFormatSymbols_ar_JO',
  'goog.i18n.CompactNumberFormatSymbols_ar_KM',
  'goog.i18n.CompactNumberFormatSymbols_ar_KW',
  'goog.i18n.CompactNumberFormatSymbols_ar_LB',
  'goog.i18n.CompactNumberFormatSymbols_ar_LY',
  'goog.i18n.CompactNumberFormatSymbols_ar_MA',
  'goog.i18n.CompactNumberFormatSymbols_ar_MR',
  'goog.i18n.CompactNumberFormatSymbols_ar_OM',
  'goog.i18n.CompactNumberFormatSymbols_ar_PS',
  'goog.i18n.CompactNumberFormatSymbols_ar_QA',
  'goog.i18n.CompactNumberFormatSymbols_ar_SA',
  'goog.i18n.CompactNumberFormatSymbols_ar_SD',
  'goog.i18n.CompactNumberFormatSymbols_ar_SO',
  'goog.i18n.CompactNumberFormatSymbols_ar_SY',
  'goog.i18n.CompactNumberFormatSymbols_ar_TD',
  'goog.i18n.CompactNumberFormatSymbols_ar_TN',
  'goog.i18n.CompactNumberFormatSymbols_ar_YE',
  'goog.i18n.CompactNumberFormatSymbols_as',
  'goog.i18n.CompactNumberFormatSymbols_as_IN',
  'goog.i18n.CompactNumberFormatSymbols_asa',
  'goog.i18n.CompactNumberFormatSymbols_asa_TZ',
  'goog.i18n.CompactNumberFormatSymbols_ast',
  'goog.i18n.CompactNumberFormatSymbols_ast_ES',
  'goog.i18n.CompactNumberFormatSymbols_az',
  'goog.i18n.CompactNumberFormatSymbols_az_Cyrl',
  'goog.i18n.CompactNumberFormatSymbols_az_Cyrl_AZ',
  'goog.i18n.CompactNumberFormatSymbols_az_Latn',
  'goog.i18n.CompactNumberFormatSymbols_az_Latn_AZ',
  'goog.i18n.CompactNumberFormatSymbols_bas',
  'goog.i18n.CompactNumberFormatSymbols_bas_CM',
  'goog.i18n.CompactNumberFormatSymbols_be',
  'goog.i18n.CompactNumberFormatSymbols_be_BY',
  'goog.i18n.CompactNumberFormatSymbols_bem',
  'goog.i18n.CompactNumberFormatSymbols_bem_ZM',
  'goog.i18n.CompactNumberFormatSymbols_bez',
  'goog.i18n.CompactNumberFormatSymbols_bez_TZ',
  'goog.i18n.CompactNumberFormatSymbols_bm',
  'goog.i18n.CompactNumberFormatSymbols_bm_ML',
  'goog.i18n.CompactNumberFormatSymbols_bn_IN',
  'goog.i18n.CompactNumberFormatSymbols_bo',
  'goog.i18n.CompactNumberFormatSymbols_bo_CN',
  'goog.i18n.CompactNumberFormatSymbols_bo_IN',
  'goog.i18n.CompactNumberFormatSymbols_brx',
  'goog.i18n.CompactNumberFormatSymbols_brx_IN',
  'goog.i18n.CompactNumberFormatSymbols_bs',
  'goog.i18n.CompactNumberFormatSymbols_bs_Cyrl',
  'goog.i18n.CompactNumberFormatSymbols_bs_Cyrl_BA',
  'goog.i18n.CompactNumberFormatSymbols_bs_Latn',
  'goog.i18n.CompactNumberFormatSymbols_bs_Latn_BA',
  'goog.i18n.CompactNumberFormatSymbols_byn',
  'goog.i18n.CompactNumberFormatSymbols_byn_ER',
  'goog.i18n.CompactNumberFormatSymbols_cgg',
  'goog.i18n.CompactNumberFormatSymbols_cgg_UG',
  'goog.i18n.CompactNumberFormatSymbols_ckb',
  'goog.i18n.CompactNumberFormatSymbols_ckb_Arab',
  'goog.i18n.CompactNumberFormatSymbols_ckb_Arab_IQ',
  'goog.i18n.CompactNumberFormatSymbols_ckb_Arab_IR',
  'goog.i18n.CompactNumberFormatSymbols_ckb_IQ',
  'goog.i18n.CompactNumberFormatSymbols_ckb_IR',
  'goog.i18n.CompactNumberFormatSymbols_ckb_Latn',
  'goog.i18n.CompactNumberFormatSymbols_ckb_Latn_IQ',
  'goog.i18n.CompactNumberFormatSymbols_dav',
  'goog.i18n.CompactNumberFormatSymbols_dav_KE',
  'goog.i18n.CompactNumberFormatSymbols_de_LI',
  'goog.i18n.CompactNumberFormatSymbols_dje',
  'goog.i18n.CompactNumberFormatSymbols_dje_NE',
  'goog.i18n.CompactNumberFormatSymbols_dua',
  'goog.i18n.CompactNumberFormatSymbols_dua_CM',
  'goog.i18n.CompactNumberFormatSymbols_dyo',
  'goog.i18n.CompactNumberFormatSymbols_dyo_SN',
  'goog.i18n.CompactNumberFormatSymbols_dz',
  'goog.i18n.CompactNumberFormatSymbols_dz_BT',
  'goog.i18n.CompactNumberFormatSymbols_ebu',
  'goog.i18n.CompactNumberFormatSymbols_ebu_KE',
  'goog.i18n.CompactNumberFormatSymbols_ee',
  'goog.i18n.CompactNumberFormatSymbols_ee_GH',
  'goog.i18n.CompactNumberFormatSymbols_ee_TG',
  'goog.i18n.CompactNumberFormatSymbols_el_CY',
  'goog.i18n.CompactNumberFormatSymbols_en_150',
  'goog.i18n.CompactNumberFormatSymbols_en_AG',
  'goog.i18n.CompactNumberFormatSymbols_en_BB',
  'goog.i18n.CompactNumberFormatSymbols_en_BE',
  'goog.i18n.CompactNumberFormatSymbols_en_BM',
  'goog.i18n.CompactNumberFormatSymbols_en_BS',
  'goog.i18n.CompactNumberFormatSymbols_en_BW',
  'goog.i18n.CompactNumberFormatSymbols_en_BZ',
  'goog.i18n.CompactNumberFormatSymbols_en_CA',
  'goog.i18n.CompactNumberFormatSymbols_en_CM',
  'goog.i18n.CompactNumberFormatSymbols_en_DM',
  'goog.i18n.CompactNumberFormatSymbols_en_Dsrt',
  'goog.i18n.CompactNumberFormatSymbols_en_FJ',
  'goog.i18n.CompactNumberFormatSymbols_en_GD',
  'goog.i18n.CompactNumberFormatSymbols_en_GG',
  'goog.i18n.CompactNumberFormatSymbols_en_GH',
  'goog.i18n.CompactNumberFormatSymbols_en_GI',
  'goog.i18n.CompactNumberFormatSymbols_en_GM',
  'goog.i18n.CompactNumberFormatSymbols_en_GY',
  'goog.i18n.CompactNumberFormatSymbols_en_HK',
  'goog.i18n.CompactNumberFormatSymbols_en_IM',
  'goog.i18n.CompactNumberFormatSymbols_en_JE',
  'goog.i18n.CompactNumberFormatSymbols_en_JM',
  'goog.i18n.CompactNumberFormatSymbols_en_KE',
  'goog.i18n.CompactNumberFormatSymbols_en_KI',
  'goog.i18n.CompactNumberFormatSymbols_en_KN',
  'goog.i18n.CompactNumberFormatSymbols_en_KY',
  'goog.i18n.CompactNumberFormatSymbols_en_LC',
  'goog.i18n.CompactNumberFormatSymbols_en_LR',
  'goog.i18n.CompactNumberFormatSymbols_en_LS',
  'goog.i18n.CompactNumberFormatSymbols_en_MG',
  'goog.i18n.CompactNumberFormatSymbols_en_MT',
  'goog.i18n.CompactNumberFormatSymbols_en_MU',
  'goog.i18n.CompactNumberFormatSymbols_en_MW',
  'goog.i18n.CompactNumberFormatSymbols_en_NA',
  'goog.i18n.CompactNumberFormatSymbols_en_NG',
  'goog.i18n.CompactNumberFormatSymbols_en_NZ',
  'goog.i18n.CompactNumberFormatSymbols_en_PG',
  'goog.i18n.CompactNumberFormatSymbols_en_PH',
  'goog.i18n.CompactNumberFormatSymbols_en_PK',
  'goog.i18n.CompactNumberFormatSymbols_en_SB',
  'goog.i18n.CompactNumberFormatSymbols_en_SC',
  'goog.i18n.CompactNumberFormatSymbols_en_SL',
  'goog.i18n.CompactNumberFormatSymbols_en_SS',
  'goog.i18n.CompactNumberFormatSymbols_en_SZ',
  'goog.i18n.CompactNumberFormatSymbols_en_TO',
  'goog.i18n.CompactNumberFormatSymbols_en_TT',
  'goog.i18n.CompactNumberFormatSymbols_en_TZ',
  'goog.i18n.CompactNumberFormatSymbols_en_UG',
  'goog.i18n.CompactNumberFormatSymbols_en_VC',
  'goog.i18n.CompactNumberFormatSymbols_en_VU',
  'goog.i18n.CompactNumberFormatSymbols_en_WS',
  'goog.i18n.CompactNumberFormatSymbols_en_ZM',
  'goog.i18n.CompactNumberFormatSymbols_en_ZW',
  'goog.i18n.CompactNumberFormatSymbols_eo',
  'goog.i18n.CompactNumberFormatSymbols_es_AR',
  'goog.i18n.CompactNumberFormatSymbols_es_BO',
  'goog.i18n.CompactNumberFormatSymbols_es_CL',
  'goog.i18n.CompactNumberFormatSymbols_es_CO',
  'goog.i18n.CompactNumberFormatSymbols_es_CR',
  'goog.i18n.CompactNumberFormatSymbols_es_CU',
  'goog.i18n.CompactNumberFormatSymbols_es_DO',
  'goog.i18n.CompactNumberFormatSymbols_es_EC',
  'goog.i18n.CompactNumberFormatSymbols_es_GQ',
  'goog.i18n.CompactNumberFormatSymbols_es_GT',
  'goog.i18n.CompactNumberFormatSymbols_es_HN',
  'goog.i18n.CompactNumberFormatSymbols_es_MX',
  'goog.i18n.CompactNumberFormatSymbols_es_NI',
  'goog.i18n.CompactNumberFormatSymbols_es_PA',
  'goog.i18n.CompactNumberFormatSymbols_es_PE',
  'goog.i18n.CompactNumberFormatSymbols_es_PH',
  'goog.i18n.CompactNumberFormatSymbols_es_PR',
  'goog.i18n.CompactNumberFormatSymbols_es_PY',
  'goog.i18n.CompactNumberFormatSymbols_es_SV',
  'goog.i18n.CompactNumberFormatSymbols_es_US',
  'goog.i18n.CompactNumberFormatSymbols_es_UY',
  'goog.i18n.CompactNumberFormatSymbols_es_VE',
  'goog.i18n.CompactNumberFormatSymbols_ewo',
  'goog.i18n.CompactNumberFormatSymbols_ewo_CM',
  'goog.i18n.CompactNumberFormatSymbols_fa_AF',
  'goog.i18n.CompactNumberFormatSymbols_ff',
  'goog.i18n.CompactNumberFormatSymbols_ff_SN',
  'goog.i18n.CompactNumberFormatSymbols_fo',
  'goog.i18n.CompactNumberFormatSymbols_fo_FO',
  'goog.i18n.CompactNumberFormatSymbols_fr_BE',
  'goog.i18n.CompactNumberFormatSymbols_fr_BF',
  'goog.i18n.CompactNumberFormatSymbols_fr_BI',
  'goog.i18n.CompactNumberFormatSymbols_fr_BJ',
  'goog.i18n.CompactNumberFormatSymbols_fr_CD',
  'goog.i18n.CompactNumberFormatSymbols_fr_CF',
  'goog.i18n.CompactNumberFormatSymbols_fr_CG',
  'goog.i18n.CompactNumberFormatSymbols_fr_CH',
  'goog.i18n.CompactNumberFormatSymbols_fr_CI',
  'goog.i18n.CompactNumberFormatSymbols_fr_CM',
  'goog.i18n.CompactNumberFormatSymbols_fr_DJ',
  'goog.i18n.CompactNumberFormatSymbols_fr_DZ',
  'goog.i18n.CompactNumberFormatSymbols_fr_GA',
  'goog.i18n.CompactNumberFormatSymbols_fr_GN',
  'goog.i18n.CompactNumberFormatSymbols_fr_GQ',
  'goog.i18n.CompactNumberFormatSymbols_fr_HT',
  'goog.i18n.CompactNumberFormatSymbols_fr_KM',
  'goog.i18n.CompactNumberFormatSymbols_fr_LU',
  'goog.i18n.CompactNumberFormatSymbols_fr_MA',
  'goog.i18n.CompactNumberFormatSymbols_fr_MG',
  'goog.i18n.CompactNumberFormatSymbols_fr_ML',
  'goog.i18n.CompactNumberFormatSymbols_fr_MR',
  'goog.i18n.CompactNumberFormatSymbols_fr_MU',
  'goog.i18n.CompactNumberFormatSymbols_fr_NC',
  'goog.i18n.CompactNumberFormatSymbols_fr_NE',
  'goog.i18n.CompactNumberFormatSymbols_fr_PF',
  'goog.i18n.CompactNumberFormatSymbols_fr_RW',
  'goog.i18n.CompactNumberFormatSymbols_fr_SC',
  'goog.i18n.CompactNumberFormatSymbols_fr_SN',
  'goog.i18n.CompactNumberFormatSymbols_fr_SY',
  'goog.i18n.CompactNumberFormatSymbols_fr_TD',
  'goog.i18n.CompactNumberFormatSymbols_fr_TG',
  'goog.i18n.CompactNumberFormatSymbols_fr_TN',
  'goog.i18n.CompactNumberFormatSymbols_fr_VU',
  'goog.i18n.CompactNumberFormatSymbols_fur',
  'goog.i18n.CompactNumberFormatSymbols_fur_IT',
  'goog.i18n.CompactNumberFormatSymbols_ga',
  'goog.i18n.CompactNumberFormatSymbols_ga_IE',
  'goog.i18n.CompactNumberFormatSymbols_gd',
  'goog.i18n.CompactNumberFormatSymbols_gd_GB',
  'goog.i18n.CompactNumberFormatSymbols_guz',
  'goog.i18n.CompactNumberFormatSymbols_guz_KE',
  'goog.i18n.CompactNumberFormatSymbols_gv',
  'goog.i18n.CompactNumberFormatSymbols_gv_GB',
  'goog.i18n.CompactNumberFormatSymbols_ha',
  'goog.i18n.CompactNumberFormatSymbols_ha_Latn',
  'goog.i18n.CompactNumberFormatSymbols_ha_Latn_GH',
  'goog.i18n.CompactNumberFormatSymbols_ha_Latn_NE',
  'goog.i18n.CompactNumberFormatSymbols_ha_Latn_NG',
  'goog.i18n.CompactNumberFormatSymbols_hr_BA',
  'goog.i18n.CompactNumberFormatSymbols_hy',
  'goog.i18n.CompactNumberFormatSymbols_hy_AM',
  'goog.i18n.CompactNumberFormatSymbols_ia',
  'goog.i18n.CompactNumberFormatSymbols_ia_FR',
  'goog.i18n.CompactNumberFormatSymbols_ig',
  'goog.i18n.CompactNumberFormatSymbols_ig_NG',
  'goog.i18n.CompactNumberFormatSymbols_ii',
  'goog.i18n.CompactNumberFormatSymbols_ii_CN',
  'goog.i18n.CompactNumberFormatSymbols_it_CH',
  'goog.i18n.CompactNumberFormatSymbols_jgo',
  'goog.i18n.CompactNumberFormatSymbols_jgo_CM',
  'goog.i18n.CompactNumberFormatSymbols_jmc',
  'goog.i18n.CompactNumberFormatSymbols_jmc_TZ',
  'goog.i18n.CompactNumberFormatSymbols_ka',
  'goog.i18n.CompactNumberFormatSymbols_ka_GE',
  'goog.i18n.CompactNumberFormatSymbols_kab',
  'goog.i18n.CompactNumberFormatSymbols_kab_DZ',
  'goog.i18n.CompactNumberFormatSymbols_kam',
  'goog.i18n.CompactNumberFormatSymbols_kam_KE',
  'goog.i18n.CompactNumberFormatSymbols_kde',
  'goog.i18n.CompactNumberFormatSymbols_kde_TZ',
  'goog.i18n.CompactNumberFormatSymbols_kea',
  'goog.i18n.CompactNumberFormatSymbols_kea_CV',
  'goog.i18n.CompactNumberFormatSymbols_khq',
  'goog.i18n.CompactNumberFormatSymbols_khq_ML',
  'goog.i18n.CompactNumberFormatSymbols_ki',
  'goog.i18n.CompactNumberFormatSymbols_ki_KE',
  'goog.i18n.CompactNumberFormatSymbols_kk',
  'goog.i18n.CompactNumberFormatSymbols_kk_Cyrl',
  'goog.i18n.CompactNumberFormatSymbols_kk_Cyrl_KZ',
  'goog.i18n.CompactNumberFormatSymbols_kkj',
  'goog.i18n.CompactNumberFormatSymbols_kkj_CM',
  'goog.i18n.CompactNumberFormatSymbols_kl',
  'goog.i18n.CompactNumberFormatSymbols_kl_GL',
  'goog.i18n.CompactNumberFormatSymbols_kln',
  'goog.i18n.CompactNumberFormatSymbols_kln_KE',
  'goog.i18n.CompactNumberFormatSymbols_km',
  'goog.i18n.CompactNumberFormatSymbols_km_KH',
  'goog.i18n.CompactNumberFormatSymbols_ko_KP',
  'goog.i18n.CompactNumberFormatSymbols_kok',
  'goog.i18n.CompactNumberFormatSymbols_kok_IN',
  'goog.i18n.CompactNumberFormatSymbols_ks',
  'goog.i18n.CompactNumberFormatSymbols_ks_Arab',
  'goog.i18n.CompactNumberFormatSymbols_ks_Arab_IN',
  'goog.i18n.CompactNumberFormatSymbols_ksb',
  'goog.i18n.CompactNumberFormatSymbols_ksb_TZ',
  'goog.i18n.CompactNumberFormatSymbols_ksf',
  'goog.i18n.CompactNumberFormatSymbols_ksf_CM',
  'goog.i18n.CompactNumberFormatSymbols_ksh',
  'goog.i18n.CompactNumberFormatSymbols_ksh_DE',
  'goog.i18n.CompactNumberFormatSymbols_kw',
  'goog.i18n.CompactNumberFormatSymbols_kw_GB',
  'goog.i18n.CompactNumberFormatSymbols_ky',
  'goog.i18n.CompactNumberFormatSymbols_ky_KG',
  'goog.i18n.CompactNumberFormatSymbols_lag',
  'goog.i18n.CompactNumberFormatSymbols_lag_TZ',
  'goog.i18n.CompactNumberFormatSymbols_lg',
  'goog.i18n.CompactNumberFormatSymbols_lg_UG',
  'goog.i18n.CompactNumberFormatSymbols_ln_AO',
  'goog.i18n.CompactNumberFormatSymbols_ln_CF',
  'goog.i18n.CompactNumberFormatSymbols_ln_CG',
  'goog.i18n.CompactNumberFormatSymbols_lo',
  'goog.i18n.CompactNumberFormatSymbols_lo_LA',
  'goog.i18n.CompactNumberFormatSymbols_lu',
  'goog.i18n.CompactNumberFormatSymbols_lu_CD',
  'goog.i18n.CompactNumberFormatSymbols_luo',
  'goog.i18n.CompactNumberFormatSymbols_luo_KE',
  'goog.i18n.CompactNumberFormatSymbols_luy',
  'goog.i18n.CompactNumberFormatSymbols_luy_KE',
  'goog.i18n.CompactNumberFormatSymbols_mas',
  'goog.i18n.CompactNumberFormatSymbols_mas_KE',
  'goog.i18n.CompactNumberFormatSymbols_mas_TZ',
  'goog.i18n.CompactNumberFormatSymbols_mer',
  'goog.i18n.CompactNumberFormatSymbols_mer_KE',
  'goog.i18n.CompactNumberFormatSymbols_mfe',
  'goog.i18n.CompactNumberFormatSymbols_mfe_MU',
  'goog.i18n.CompactNumberFormatSymbols_mg',
  'goog.i18n.CompactNumberFormatSymbols_mg_MG',
  'goog.i18n.CompactNumberFormatSymbols_mgh',
  'goog.i18n.CompactNumberFormatSymbols_mgh_MZ',
  'goog.i18n.CompactNumberFormatSymbols_mgo',
  'goog.i18n.CompactNumberFormatSymbols_mgo_CM',
  'goog.i18n.CompactNumberFormatSymbols_mk',
  'goog.i18n.CompactNumberFormatSymbols_mk_MK',
  'goog.i18n.CompactNumberFormatSymbols_mn',
  'goog.i18n.CompactNumberFormatSymbols_mn_Cyrl',
  'goog.i18n.CompactNumberFormatSymbols_mn_Cyrl_MN',
  'goog.i18n.CompactNumberFormatSymbols_ms_Latn',
  'goog.i18n.CompactNumberFormatSymbols_ms_Latn_BN',
  'goog.i18n.CompactNumberFormatSymbols_ms_Latn_SG',
  'goog.i18n.CompactNumberFormatSymbols_mua',
  'goog.i18n.CompactNumberFormatSymbols_mua_CM',
  'goog.i18n.CompactNumberFormatSymbols_my',
  'goog.i18n.CompactNumberFormatSymbols_my_MM',
  'goog.i18n.CompactNumberFormatSymbols_naq',
  'goog.i18n.CompactNumberFormatSymbols_naq_NA',
  'goog.i18n.CompactNumberFormatSymbols_nd',
  'goog.i18n.CompactNumberFormatSymbols_nd_ZW',
  'goog.i18n.CompactNumberFormatSymbols_ne',
  'goog.i18n.CompactNumberFormatSymbols_ne_IN',
  'goog.i18n.CompactNumberFormatSymbols_ne_NP',
  'goog.i18n.CompactNumberFormatSymbols_nl_AW',
  'goog.i18n.CompactNumberFormatSymbols_nl_BE',
  'goog.i18n.CompactNumberFormatSymbols_nl_CW',
  'goog.i18n.CompactNumberFormatSymbols_nl_SR',
  'goog.i18n.CompactNumberFormatSymbols_nl_SX',
  'goog.i18n.CompactNumberFormatSymbols_nmg',
  'goog.i18n.CompactNumberFormatSymbols_nmg_CM',
  'goog.i18n.CompactNumberFormatSymbols_nn',
  'goog.i18n.CompactNumberFormatSymbols_nn_NO',
  'goog.i18n.CompactNumberFormatSymbols_nnh',
  'goog.i18n.CompactNumberFormatSymbols_nnh_CM',
  'goog.i18n.CompactNumberFormatSymbols_nr',
  'goog.i18n.CompactNumberFormatSymbols_nr_ZA',
  'goog.i18n.CompactNumberFormatSymbols_nso',
  'goog.i18n.CompactNumberFormatSymbols_nso_ZA',
  'goog.i18n.CompactNumberFormatSymbols_nus',
  'goog.i18n.CompactNumberFormatSymbols_nus_SD',
  'goog.i18n.CompactNumberFormatSymbols_nyn',
  'goog.i18n.CompactNumberFormatSymbols_nyn_UG',
  'goog.i18n.CompactNumberFormatSymbols_om',
  'goog.i18n.CompactNumberFormatSymbols_om_ET',
  'goog.i18n.CompactNumberFormatSymbols_om_KE',
  'goog.i18n.CompactNumberFormatSymbols_os',
  'goog.i18n.CompactNumberFormatSymbols_os_GE',
  'goog.i18n.CompactNumberFormatSymbols_os_RU',
  'goog.i18n.CompactNumberFormatSymbols_pa',
  'goog.i18n.CompactNumberFormatSymbols_pa_Arab',
  'goog.i18n.CompactNumberFormatSymbols_pa_Arab_PK',
  'goog.i18n.CompactNumberFormatSymbols_pa_Guru',
  'goog.i18n.CompactNumberFormatSymbols_pa_Guru_IN',
  'goog.i18n.CompactNumberFormatSymbols_ps',
  'goog.i18n.CompactNumberFormatSymbols_ps_AF',
  'goog.i18n.CompactNumberFormatSymbols_pt_AO',
  'goog.i18n.CompactNumberFormatSymbols_pt_CV',
  'goog.i18n.CompactNumberFormatSymbols_pt_GW',
  'goog.i18n.CompactNumberFormatSymbols_pt_MO',
  'goog.i18n.CompactNumberFormatSymbols_pt_MZ',
  'goog.i18n.CompactNumberFormatSymbols_pt_ST',
  'goog.i18n.CompactNumberFormatSymbols_pt_TL',
  'goog.i18n.CompactNumberFormatSymbols_rm',
  'goog.i18n.CompactNumberFormatSymbols_rm_CH',
  'goog.i18n.CompactNumberFormatSymbols_rn',
  'goog.i18n.CompactNumberFormatSymbols_rn_BI',
  'goog.i18n.CompactNumberFormatSymbols_ro_MD',
  'goog.i18n.CompactNumberFormatSymbols_rof',
  'goog.i18n.CompactNumberFormatSymbols_rof_TZ',
  'goog.i18n.CompactNumberFormatSymbols_ru_BY',
  'goog.i18n.CompactNumberFormatSymbols_ru_KG',
  'goog.i18n.CompactNumberFormatSymbols_ru_KZ',
  'goog.i18n.CompactNumberFormatSymbols_ru_MD',
  'goog.i18n.CompactNumberFormatSymbols_ru_UA',
  'goog.i18n.CompactNumberFormatSymbols_rw',
  'goog.i18n.CompactNumberFormatSymbols_rw_RW',
  'goog.i18n.CompactNumberFormatSymbols_rwk',
  'goog.i18n.CompactNumberFormatSymbols_rwk_TZ',
  'goog.i18n.CompactNumberFormatSymbols_sah',
  'goog.i18n.CompactNumberFormatSymbols_sah_RU',
  'goog.i18n.CompactNumberFormatSymbols_saq',
  'goog.i18n.CompactNumberFormatSymbols_saq_KE',
  'goog.i18n.CompactNumberFormatSymbols_sbp',
  'goog.i18n.CompactNumberFormatSymbols_sbp_TZ',
  'goog.i18n.CompactNumberFormatSymbols_se',
  'goog.i18n.CompactNumberFormatSymbols_se_FI',
  'goog.i18n.CompactNumberFormatSymbols_se_NO',
  'goog.i18n.CompactNumberFormatSymbols_seh',
  'goog.i18n.CompactNumberFormatSymbols_seh_MZ',
  'goog.i18n.CompactNumberFormatSymbols_ses',
  'goog.i18n.CompactNumberFormatSymbols_ses_ML',
  'goog.i18n.CompactNumberFormatSymbols_sg',
  'goog.i18n.CompactNumberFormatSymbols_sg_CF',
  'goog.i18n.CompactNumberFormatSymbols_shi',
  'goog.i18n.CompactNumberFormatSymbols_shi_Latn',
  'goog.i18n.CompactNumberFormatSymbols_shi_Latn_MA',
  'goog.i18n.CompactNumberFormatSymbols_shi_Tfng',
  'goog.i18n.CompactNumberFormatSymbols_shi_Tfng_MA',
  'goog.i18n.CompactNumberFormatSymbols_si',
  'goog.i18n.CompactNumberFormatSymbols_si_LK',
  'goog.i18n.CompactNumberFormatSymbols_sn',
  'goog.i18n.CompactNumberFormatSymbols_sn_ZW',
  'goog.i18n.CompactNumberFormatSymbols_so',
  'goog.i18n.CompactNumberFormatSymbols_so_DJ',
  'goog.i18n.CompactNumberFormatSymbols_so_ET',
  'goog.i18n.CompactNumberFormatSymbols_so_KE',
  'goog.i18n.CompactNumberFormatSymbols_so_SO',
  'goog.i18n.CompactNumberFormatSymbols_sq_MK',
  'goog.i18n.CompactNumberFormatSymbols_sq_XK',
  'goog.i18n.CompactNumberFormatSymbols_sr_Cyrl',
  'goog.i18n.CompactNumberFormatSymbols_sr_Cyrl_BA',
  'goog.i18n.CompactNumberFormatSymbols_sr_Cyrl_ME',
  'goog.i18n.CompactNumberFormatSymbols_sr_Cyrl_XK',
  'goog.i18n.CompactNumberFormatSymbols_sr_Latn',
  'goog.i18n.CompactNumberFormatSymbols_sr_Latn_BA',
  'goog.i18n.CompactNumberFormatSymbols_sr_Latn_ME',
  'goog.i18n.CompactNumberFormatSymbols_sr_Latn_RS',
  'goog.i18n.CompactNumberFormatSymbols_sr_Latn_XK',
  'goog.i18n.CompactNumberFormatSymbols_ss',
  'goog.i18n.CompactNumberFormatSymbols_ss_SZ',
  'goog.i18n.CompactNumberFormatSymbols_ss_ZA',
  'goog.i18n.CompactNumberFormatSymbols_ssy',
  'goog.i18n.CompactNumberFormatSymbols_ssy_ER',
  'goog.i18n.CompactNumberFormatSymbols_st',
  'goog.i18n.CompactNumberFormatSymbols_st_LS',
  'goog.i18n.CompactNumberFormatSymbols_st_ZA',
  'goog.i18n.CompactNumberFormatSymbols_sv_AX',
  'goog.i18n.CompactNumberFormatSymbols_sv_FI',
  'goog.i18n.CompactNumberFormatSymbols_sw_KE',
  'goog.i18n.CompactNumberFormatSymbols_sw_UG',
  'goog.i18n.CompactNumberFormatSymbols_swc',
  'goog.i18n.CompactNumberFormatSymbols_swc_CD',
  'goog.i18n.CompactNumberFormatSymbols_ta_LK',
  'goog.i18n.CompactNumberFormatSymbols_ta_MY',
  'goog.i18n.CompactNumberFormatSymbols_ta_SG',
  'goog.i18n.CompactNumberFormatSymbols_teo',
  'goog.i18n.CompactNumberFormatSymbols_teo_KE',
  'goog.i18n.CompactNumberFormatSymbols_teo_UG',
  'goog.i18n.CompactNumberFormatSymbols_tg',
  'goog.i18n.CompactNumberFormatSymbols_tg_Cyrl',
  'goog.i18n.CompactNumberFormatSymbols_tg_Cyrl_TJ',
  'goog.i18n.CompactNumberFormatSymbols_ti',
  'goog.i18n.CompactNumberFormatSymbols_ti_ER',
  'goog.i18n.CompactNumberFormatSymbols_ti_ET',
  'goog.i18n.CompactNumberFormatSymbols_tig',
  'goog.i18n.CompactNumberFormatSymbols_tig_ER',
  'goog.i18n.CompactNumberFormatSymbols_tn',
  'goog.i18n.CompactNumberFormatSymbols_tn_BW',
  'goog.i18n.CompactNumberFormatSymbols_tn_ZA',
  'goog.i18n.CompactNumberFormatSymbols_to',
  'goog.i18n.CompactNumberFormatSymbols_to_TO',
  'goog.i18n.CompactNumberFormatSymbols_tr_CY',
  'goog.i18n.CompactNumberFormatSymbols_ts',
  'goog.i18n.CompactNumberFormatSymbols_ts_ZA',
  'goog.i18n.CompactNumberFormatSymbols_twq',
  'goog.i18n.CompactNumberFormatSymbols_twq_NE',
  'goog.i18n.CompactNumberFormatSymbols_tzm',
  'goog.i18n.CompactNumberFormatSymbols_tzm_Latn',
  'goog.i18n.CompactNumberFormatSymbols_tzm_Latn_MA',
  'goog.i18n.CompactNumberFormatSymbols_ur_IN',
  'goog.i18n.CompactNumberFormatSymbols_uz',
  'goog.i18n.CompactNumberFormatSymbols_uz_Arab',
  'goog.i18n.CompactNumberFormatSymbols_uz_Arab_AF',
  'goog.i18n.CompactNumberFormatSymbols_uz_Cyrl',
  'goog.i18n.CompactNumberFormatSymbols_uz_Cyrl_UZ',
  'goog.i18n.CompactNumberFormatSymbols_uz_Latn',
  'goog.i18n.CompactNumberFormatSymbols_uz_Latn_UZ',
  'goog.i18n.CompactNumberFormatSymbols_vai',
  'goog.i18n.CompactNumberFormatSymbols_vai_Latn',
  'goog.i18n.CompactNumberFormatSymbols_vai_Latn_LR',
  'goog.i18n.CompactNumberFormatSymbols_vai_Vaii',
  'goog.i18n.CompactNumberFormatSymbols_vai_Vaii_LR',
  'goog.i18n.CompactNumberFormatSymbols_ve',
  'goog.i18n.CompactNumberFormatSymbols_ve_ZA',
  'goog.i18n.CompactNumberFormatSymbols_vo',
  'goog.i18n.CompactNumberFormatSymbols_vun',
  'goog.i18n.CompactNumberFormatSymbols_vun_TZ',
  'goog.i18n.CompactNumberFormatSymbols_wae',
  'goog.i18n.CompactNumberFormatSymbols_wae_CH',
  'goog.i18n.CompactNumberFormatSymbols_wal',
  'goog.i18n.CompactNumberFormatSymbols_wal_ET',
  'goog.i18n.CompactNumberFormatSymbols_xh',
  'goog.i18n.CompactNumberFormatSymbols_xh_ZA',
  'goog.i18n.CompactNumberFormatSymbols_xog',
  'goog.i18n.CompactNumberFormatSymbols_xog_UG',
  'goog.i18n.CompactNumberFormatSymbols_yav',
  'goog.i18n.CompactNumberFormatSymbols_yav_CM',
  'goog.i18n.CompactNumberFormatSymbols_yo',
  'goog.i18n.CompactNumberFormatSymbols_yo_NG',
  'goog.i18n.CompactNumberFormatSymbols_zh_Hans',
  'goog.i18n.CompactNumberFormatSymbols_zh_Hans_HK',
  'goog.i18n.CompactNumberFormatSymbols_zh_Hans_MO',
  'goog.i18n.CompactNumberFormatSymbols_zh_Hans_SG',
  'goog.i18n.CompactNumberFormatSymbols_zh_Hant',
  'goog.i18n.CompactNumberFormatSymbols_zh_Hant_HK',
  'goog.i18n.CompactNumberFormatSymbols_zh_Hant_MO',
  'goog.i18n.CompactNumberFormatSymbols_zh_Hant_TW'
], []);
goog.addDependency('i18n/currency.js', [
  'goog.i18n.currency',
  'goog.i18n.currency.CurrencyInfo',
  'goog.i18n.currency.CurrencyInfoTier2'
], []);
goog.addDependency('i18n/currencycodemap.js', [
  'goog.i18n.currencyCodeMap',
  'goog.i18n.currencyCodeMapTier2'
], []);
goog.addDependency('i18n/datetimeformat.js', [
  'goog.i18n.DateTimeFormat',
  'goog.i18n.DateTimeFormat.Format'
], [
  'goog.asserts',
  'goog.i18n.DateTimeSymbols',
  'goog.i18n.TimeZone',
  'goog.string'
]);
goog.addDependency('i18n/datetimeparse.js', ['goog.i18n.DateTimeParse'], [
  'goog.i18n.DateTimeFormat',
  'goog.i18n.DateTimeSymbols'
]);
goog.addDependency('i18n/datetimepatterns.js', [
  'goog.i18n.DateTimePatterns',
  'goog.i18n.DateTimePatterns_af',
  'goog.i18n.DateTimePatterns_am',
  'goog.i18n.DateTimePatterns_ar',
  'goog.i18n.DateTimePatterns_bg',
  'goog.i18n.DateTimePatterns_bn',
  'goog.i18n.DateTimePatterns_br',
  'goog.i18n.DateTimePatterns_ca',
  'goog.i18n.DateTimePatterns_chr',
  'goog.i18n.DateTimePatterns_cs',
  'goog.i18n.DateTimePatterns_cy',
  'goog.i18n.DateTimePatterns_da',
  'goog.i18n.DateTimePatterns_de',
  'goog.i18n.DateTimePatterns_de_AT',
  'goog.i18n.DateTimePatterns_de_CH',
  'goog.i18n.DateTimePatterns_el',
  'goog.i18n.DateTimePatterns_en',
  'goog.i18n.DateTimePatterns_en_AU',
  'goog.i18n.DateTimePatterns_en_GB',
  'goog.i18n.DateTimePatterns_en_IE',
  'goog.i18n.DateTimePatterns_en_IN',
  'goog.i18n.DateTimePatterns_en_SG',
  'goog.i18n.DateTimePatterns_en_US',
  'goog.i18n.DateTimePatterns_en_ZA',
  'goog.i18n.DateTimePatterns_es',
  'goog.i18n.DateTimePatterns_es_419',
  'goog.i18n.DateTimePatterns_es_ES',
  'goog.i18n.DateTimePatterns_et',
  'goog.i18n.DateTimePatterns_eu',
  'goog.i18n.DateTimePatterns_fa',
  'goog.i18n.DateTimePatterns_fi',
  'goog.i18n.DateTimePatterns_fil',
  'goog.i18n.DateTimePatterns_fr',
  'goog.i18n.DateTimePatterns_fr_CA',
  'goog.i18n.DateTimePatterns_gl',
  'goog.i18n.DateTimePatterns_gsw',
  'goog.i18n.DateTimePatterns_gu',
  'goog.i18n.DateTimePatterns_haw',
  'goog.i18n.DateTimePatterns_he',
  'goog.i18n.DateTimePatterns_hi',
  'goog.i18n.DateTimePatterns_hr',
  'goog.i18n.DateTimePatterns_hu',
  'goog.i18n.DateTimePatterns_id',
  'goog.i18n.DateTimePatterns_in',
  'goog.i18n.DateTimePatterns_is',
  'goog.i18n.DateTimePatterns_it',
  'goog.i18n.DateTimePatterns_iw',
  'goog.i18n.DateTimePatterns_ja',
  'goog.i18n.DateTimePatterns_kn',
  'goog.i18n.DateTimePatterns_ko',
  'goog.i18n.DateTimePatterns_ln',
  'goog.i18n.DateTimePatterns_lt',
  'goog.i18n.DateTimePatterns_lv',
  'goog.i18n.DateTimePatterns_ml',
  'goog.i18n.DateTimePatterns_mo',
  'goog.i18n.DateTimePatterns_mr',
  'goog.i18n.DateTimePatterns_ms',
  'goog.i18n.DateTimePatterns_mt',
  'goog.i18n.DateTimePatterns_nb',
  'goog.i18n.DateTimePatterns_nl',
  'goog.i18n.DateTimePatterns_no',
  'goog.i18n.DateTimePatterns_or',
  'goog.i18n.DateTimePatterns_pl',
  'goog.i18n.DateTimePatterns_pt',
  'goog.i18n.DateTimePatterns_pt_BR',
  'goog.i18n.DateTimePatterns_pt_PT',
  'goog.i18n.DateTimePatterns_ro',
  'goog.i18n.DateTimePatterns_ru',
  'goog.i18n.DateTimePatterns_sk',
  'goog.i18n.DateTimePatterns_sl',
  'goog.i18n.DateTimePatterns_sq',
  'goog.i18n.DateTimePatterns_sr',
  'goog.i18n.DateTimePatterns_sv',
  'goog.i18n.DateTimePatterns_sw',
  'goog.i18n.DateTimePatterns_ta',
  'goog.i18n.DateTimePatterns_te',
  'goog.i18n.DateTimePatterns_th',
  'goog.i18n.DateTimePatterns_tl',
  'goog.i18n.DateTimePatterns_tr',
  'goog.i18n.DateTimePatterns_uk',
  'goog.i18n.DateTimePatterns_ur',
  'goog.i18n.DateTimePatterns_vi',
  'goog.i18n.DateTimePatterns_zh',
  'goog.i18n.DateTimePatterns_zh_CN',
  'goog.i18n.DateTimePatterns_zh_HK',
  'goog.i18n.DateTimePatterns_zh_TW',
  'goog.i18n.DateTimePatterns_zu'
], []);
goog.addDependency('i18n/datetimepatternsext.js', [
  'goog.i18n.DateTimePatternsExt',
  'goog.i18n.DateTimePatterns_af_NA',
  'goog.i18n.DateTimePatterns_af_ZA',
  'goog.i18n.DateTimePatterns_agq',
  'goog.i18n.DateTimePatterns_agq_CM',
  'goog.i18n.DateTimePatterns_ak',
  'goog.i18n.DateTimePatterns_ak_GH',
  'goog.i18n.DateTimePatterns_am_ET',
  'goog.i18n.DateTimePatterns_ar_001',
  'goog.i18n.DateTimePatterns_ar_AE',
  'goog.i18n.DateTimePatterns_ar_BH',
  'goog.i18n.DateTimePatterns_ar_DJ',
  'goog.i18n.DateTimePatterns_ar_DZ',
  'goog.i18n.DateTimePatterns_ar_EG',
  'goog.i18n.DateTimePatterns_ar_EH',
  'goog.i18n.DateTimePatterns_ar_ER',
  'goog.i18n.DateTimePatterns_ar_IL',
  'goog.i18n.DateTimePatterns_ar_IQ',
  'goog.i18n.DateTimePatterns_ar_JO',
  'goog.i18n.DateTimePatterns_ar_KM',
  'goog.i18n.DateTimePatterns_ar_KW',
  'goog.i18n.DateTimePatterns_ar_LB',
  'goog.i18n.DateTimePatterns_ar_LY',
  'goog.i18n.DateTimePatterns_ar_MA',
  'goog.i18n.DateTimePatterns_ar_MR',
  'goog.i18n.DateTimePatterns_ar_OM',
  'goog.i18n.DateTimePatterns_ar_PS',
  'goog.i18n.DateTimePatterns_ar_QA',
  'goog.i18n.DateTimePatterns_ar_SA',
  'goog.i18n.DateTimePatterns_ar_SD',
  'goog.i18n.DateTimePatterns_ar_SO',
  'goog.i18n.DateTimePatterns_ar_SY',
  'goog.i18n.DateTimePatterns_ar_TD',
  'goog.i18n.DateTimePatterns_ar_TN',
  'goog.i18n.DateTimePatterns_ar_YE',
  'goog.i18n.DateTimePatterns_as',
  'goog.i18n.DateTimePatterns_as_IN',
  'goog.i18n.DateTimePatterns_asa',
  'goog.i18n.DateTimePatterns_asa_TZ',
  'goog.i18n.DateTimePatterns_az',
  'goog.i18n.DateTimePatterns_az_Cyrl',
  'goog.i18n.DateTimePatterns_az_Cyrl_AZ',
  'goog.i18n.DateTimePatterns_az_Latn',
  'goog.i18n.DateTimePatterns_az_Latn_AZ',
  'goog.i18n.DateTimePatterns_bas',
  'goog.i18n.DateTimePatterns_bas_CM',
  'goog.i18n.DateTimePatterns_be',
  'goog.i18n.DateTimePatterns_be_BY',
  'goog.i18n.DateTimePatterns_bem',
  'goog.i18n.DateTimePatterns_bem_ZM',
  'goog.i18n.DateTimePatterns_bez',
  'goog.i18n.DateTimePatterns_bez_TZ',
  'goog.i18n.DateTimePatterns_bg_BG',
  'goog.i18n.DateTimePatterns_bm',
  'goog.i18n.DateTimePatterns_bm_ML',
  'goog.i18n.DateTimePatterns_bn_BD',
  'goog.i18n.DateTimePatterns_bn_IN',
  'goog.i18n.DateTimePatterns_bo',
  'goog.i18n.DateTimePatterns_bo_CN',
  'goog.i18n.DateTimePatterns_bo_IN',
  'goog.i18n.DateTimePatterns_br_FR',
  'goog.i18n.DateTimePatterns_brx',
  'goog.i18n.DateTimePatterns_brx_IN',
  'goog.i18n.DateTimePatterns_bs',
  'goog.i18n.DateTimePatterns_bs_Cyrl',
  'goog.i18n.DateTimePatterns_bs_Cyrl_BA',
  'goog.i18n.DateTimePatterns_bs_Latn',
  'goog.i18n.DateTimePatterns_bs_Latn_BA',
  'goog.i18n.DateTimePatterns_ca_AD',
  'goog.i18n.DateTimePatterns_ca_ES',
  'goog.i18n.DateTimePatterns_cgg',
  'goog.i18n.DateTimePatterns_cgg_UG',
  'goog.i18n.DateTimePatterns_chr_US',
  'goog.i18n.DateTimePatterns_cs_CZ',
  'goog.i18n.DateTimePatterns_cy_GB',
  'goog.i18n.DateTimePatterns_da_DK',
  'goog.i18n.DateTimePatterns_dav',
  'goog.i18n.DateTimePatterns_dav_KE',
  'goog.i18n.DateTimePatterns_de_BE',
  'goog.i18n.DateTimePatterns_de_DE',
  'goog.i18n.DateTimePatterns_de_LI',
  'goog.i18n.DateTimePatterns_de_LU',
  'goog.i18n.DateTimePatterns_dje',
  'goog.i18n.DateTimePatterns_dje_NE',
  'goog.i18n.DateTimePatterns_dua',
  'goog.i18n.DateTimePatterns_dua_CM',
  'goog.i18n.DateTimePatterns_dyo',
  'goog.i18n.DateTimePatterns_dyo_SN',
  'goog.i18n.DateTimePatterns_dz',
  'goog.i18n.DateTimePatterns_dz_BT',
  'goog.i18n.DateTimePatterns_ebu',
  'goog.i18n.DateTimePatterns_ebu_KE',
  'goog.i18n.DateTimePatterns_ee',
  'goog.i18n.DateTimePatterns_ee_GH',
  'goog.i18n.DateTimePatterns_ee_TG',
  'goog.i18n.DateTimePatterns_el_CY',
  'goog.i18n.DateTimePatterns_el_GR',
  'goog.i18n.DateTimePatterns_en_150',
  'goog.i18n.DateTimePatterns_en_AG',
  'goog.i18n.DateTimePatterns_en_AS',
  'goog.i18n.DateTimePatterns_en_BB',
  'goog.i18n.DateTimePatterns_en_BE',
  'goog.i18n.DateTimePatterns_en_BM',
  'goog.i18n.DateTimePatterns_en_BS',
  'goog.i18n.DateTimePatterns_en_BW',
  'goog.i18n.DateTimePatterns_en_BZ',
  'goog.i18n.DateTimePatterns_en_CA',
  'goog.i18n.DateTimePatterns_en_CM',
  'goog.i18n.DateTimePatterns_en_DM',
  'goog.i18n.DateTimePatterns_en_FJ',
  'goog.i18n.DateTimePatterns_en_FM',
  'goog.i18n.DateTimePatterns_en_GD',
  'goog.i18n.DateTimePatterns_en_GG',
  'goog.i18n.DateTimePatterns_en_GH',
  'goog.i18n.DateTimePatterns_en_GI',
  'goog.i18n.DateTimePatterns_en_GM',
  'goog.i18n.DateTimePatterns_en_GU',
  'goog.i18n.DateTimePatterns_en_GY',
  'goog.i18n.DateTimePatterns_en_HK',
  'goog.i18n.DateTimePatterns_en_IM',
  'goog.i18n.DateTimePatterns_en_JE',
  'goog.i18n.DateTimePatterns_en_JM',
  'goog.i18n.DateTimePatterns_en_KE',
  'goog.i18n.DateTimePatterns_en_KI',
  'goog.i18n.DateTimePatterns_en_KN',
  'goog.i18n.DateTimePatterns_en_KY',
  'goog.i18n.DateTimePatterns_en_LC',
  'goog.i18n.DateTimePatterns_en_LR',
  'goog.i18n.DateTimePatterns_en_LS',
  'goog.i18n.DateTimePatterns_en_MG',
  'goog.i18n.DateTimePatterns_en_MH',
  'goog.i18n.DateTimePatterns_en_MP',
  'goog.i18n.DateTimePatterns_en_MT',
  'goog.i18n.DateTimePatterns_en_MU',
  'goog.i18n.DateTimePatterns_en_MW',
  'goog.i18n.DateTimePatterns_en_NA',
  'goog.i18n.DateTimePatterns_en_NG',
  'goog.i18n.DateTimePatterns_en_NZ',
  'goog.i18n.DateTimePatterns_en_PG',
  'goog.i18n.DateTimePatterns_en_PH',
  'goog.i18n.DateTimePatterns_en_PK',
  'goog.i18n.DateTimePatterns_en_PR',
  'goog.i18n.DateTimePatterns_en_PW',
  'goog.i18n.DateTimePatterns_en_SB',
  'goog.i18n.DateTimePatterns_en_SC',
  'goog.i18n.DateTimePatterns_en_SL',
  'goog.i18n.DateTimePatterns_en_SS',
  'goog.i18n.DateTimePatterns_en_SZ',
  'goog.i18n.DateTimePatterns_en_TC',
  'goog.i18n.DateTimePatterns_en_TO',
  'goog.i18n.DateTimePatterns_en_TT',
  'goog.i18n.DateTimePatterns_en_TZ',
  'goog.i18n.DateTimePatterns_en_UG',
  'goog.i18n.DateTimePatterns_en_UM',
  'goog.i18n.DateTimePatterns_en_US_POSIX',
  'goog.i18n.DateTimePatterns_en_VC',
  'goog.i18n.DateTimePatterns_en_VG',
  'goog.i18n.DateTimePatterns_en_VI',
  'goog.i18n.DateTimePatterns_en_VU',
  'goog.i18n.DateTimePatterns_en_WS',
  'goog.i18n.DateTimePatterns_en_ZM',
  'goog.i18n.DateTimePatterns_en_ZW',
  'goog.i18n.DateTimePatterns_eo',
  'goog.i18n.DateTimePatterns_es_AR',
  'goog.i18n.DateTimePatterns_es_BO',
  'goog.i18n.DateTimePatterns_es_CL',
  'goog.i18n.DateTimePatterns_es_CO',
  'goog.i18n.DateTimePatterns_es_CR',
  'goog.i18n.DateTimePatterns_es_CU',
  'goog.i18n.DateTimePatterns_es_DO',
  'goog.i18n.DateTimePatterns_es_EA',
  'goog.i18n.DateTimePatterns_es_EC',
  'goog.i18n.DateTimePatterns_es_GQ',
  'goog.i18n.DateTimePatterns_es_GT',
  'goog.i18n.DateTimePatterns_es_HN',
  'goog.i18n.DateTimePatterns_es_IC',
  'goog.i18n.DateTimePatterns_es_MX',
  'goog.i18n.DateTimePatterns_es_NI',
  'goog.i18n.DateTimePatterns_es_PA',
  'goog.i18n.DateTimePatterns_es_PE',
  'goog.i18n.DateTimePatterns_es_PH',
  'goog.i18n.DateTimePatterns_es_PR',
  'goog.i18n.DateTimePatterns_es_PY',
  'goog.i18n.DateTimePatterns_es_SV',
  'goog.i18n.DateTimePatterns_es_US',
  'goog.i18n.DateTimePatterns_es_UY',
  'goog.i18n.DateTimePatterns_es_VE',
  'goog.i18n.DateTimePatterns_et_EE',
  'goog.i18n.DateTimePatterns_eu_ES',
  'goog.i18n.DateTimePatterns_ewo',
  'goog.i18n.DateTimePatterns_ewo_CM',
  'goog.i18n.DateTimePatterns_fa_AF',
  'goog.i18n.DateTimePatterns_fa_IR',
  'goog.i18n.DateTimePatterns_ff',
  'goog.i18n.DateTimePatterns_ff_SN',
  'goog.i18n.DateTimePatterns_fi_FI',
  'goog.i18n.DateTimePatterns_fil_PH',
  'goog.i18n.DateTimePatterns_fo',
  'goog.i18n.DateTimePatterns_fo_FO',
  'goog.i18n.DateTimePatterns_fr_BE',
  'goog.i18n.DateTimePatterns_fr_BF',
  'goog.i18n.DateTimePatterns_fr_BI',
  'goog.i18n.DateTimePatterns_fr_BJ',
  'goog.i18n.DateTimePatterns_fr_BL',
  'goog.i18n.DateTimePatterns_fr_CD',
  'goog.i18n.DateTimePatterns_fr_CF',
  'goog.i18n.DateTimePatterns_fr_CG',
  'goog.i18n.DateTimePatterns_fr_CH',
  'goog.i18n.DateTimePatterns_fr_CI',
  'goog.i18n.DateTimePatterns_fr_CM',
  'goog.i18n.DateTimePatterns_fr_DJ',
  'goog.i18n.DateTimePatterns_fr_DZ',
  'goog.i18n.DateTimePatterns_fr_FR',
  'goog.i18n.DateTimePatterns_fr_GA',
  'goog.i18n.DateTimePatterns_fr_GF',
  'goog.i18n.DateTimePatterns_fr_GN',
  'goog.i18n.DateTimePatterns_fr_GP',
  'goog.i18n.DateTimePatterns_fr_GQ',
  'goog.i18n.DateTimePatterns_fr_HT',
  'goog.i18n.DateTimePatterns_fr_KM',
  'goog.i18n.DateTimePatterns_fr_LU',
  'goog.i18n.DateTimePatterns_fr_MA',
  'goog.i18n.DateTimePatterns_fr_MC',
  'goog.i18n.DateTimePatterns_fr_MF',
  'goog.i18n.DateTimePatterns_fr_MG',
  'goog.i18n.DateTimePatterns_fr_ML',
  'goog.i18n.DateTimePatterns_fr_MQ',
  'goog.i18n.DateTimePatterns_fr_MR',
  'goog.i18n.DateTimePatterns_fr_MU',
  'goog.i18n.DateTimePatterns_fr_NC',
  'goog.i18n.DateTimePatterns_fr_NE',
  'goog.i18n.DateTimePatterns_fr_PF',
  'goog.i18n.DateTimePatterns_fr_RE',
  'goog.i18n.DateTimePatterns_fr_RW',
  'goog.i18n.DateTimePatterns_fr_SC',
  'goog.i18n.DateTimePatterns_fr_SN',
  'goog.i18n.DateTimePatterns_fr_SY',
  'goog.i18n.DateTimePatterns_fr_TD',
  'goog.i18n.DateTimePatterns_fr_TG',
  'goog.i18n.DateTimePatterns_fr_TN',
  'goog.i18n.DateTimePatterns_fr_VU',
  'goog.i18n.DateTimePatterns_fr_YT',
  'goog.i18n.DateTimePatterns_ga',
  'goog.i18n.DateTimePatterns_ga_IE',
  'goog.i18n.DateTimePatterns_gl_ES',
  'goog.i18n.DateTimePatterns_gsw_CH',
  'goog.i18n.DateTimePatterns_gu_IN',
  'goog.i18n.DateTimePatterns_guz',
  'goog.i18n.DateTimePatterns_guz_KE',
  'goog.i18n.DateTimePatterns_gv',
  'goog.i18n.DateTimePatterns_gv_GB',
  'goog.i18n.DateTimePatterns_ha',
  'goog.i18n.DateTimePatterns_ha_Latn',
  'goog.i18n.DateTimePatterns_ha_Latn_GH',
  'goog.i18n.DateTimePatterns_ha_Latn_NE',
  'goog.i18n.DateTimePatterns_ha_Latn_NG',
  'goog.i18n.DateTimePatterns_haw_US',
  'goog.i18n.DateTimePatterns_he_IL',
  'goog.i18n.DateTimePatterns_hi_IN',
  'goog.i18n.DateTimePatterns_hr_BA',
  'goog.i18n.DateTimePatterns_hr_HR',
  'goog.i18n.DateTimePatterns_hu_HU',
  'goog.i18n.DateTimePatterns_hy',
  'goog.i18n.DateTimePatterns_hy_AM',
  'goog.i18n.DateTimePatterns_id_ID',
  'goog.i18n.DateTimePatterns_ig',
  'goog.i18n.DateTimePatterns_ig_NG',
  'goog.i18n.DateTimePatterns_ii',
  'goog.i18n.DateTimePatterns_ii_CN',
  'goog.i18n.DateTimePatterns_is_IS',
  'goog.i18n.DateTimePatterns_it_CH',
  'goog.i18n.DateTimePatterns_it_IT',
  'goog.i18n.DateTimePatterns_it_SM',
  'goog.i18n.DateTimePatterns_ja_JP',
  'goog.i18n.DateTimePatterns_jgo',
  'goog.i18n.DateTimePatterns_jgo_CM',
  'goog.i18n.DateTimePatterns_jmc',
  'goog.i18n.DateTimePatterns_jmc_TZ',
  'goog.i18n.DateTimePatterns_ka',
  'goog.i18n.DateTimePatterns_ka_GE',
  'goog.i18n.DateTimePatterns_kab',
  'goog.i18n.DateTimePatterns_kab_DZ',
  'goog.i18n.DateTimePatterns_kam',
  'goog.i18n.DateTimePatterns_kam_KE',
  'goog.i18n.DateTimePatterns_kde',
  'goog.i18n.DateTimePatterns_kde_TZ',
  'goog.i18n.DateTimePatterns_kea',
  'goog.i18n.DateTimePatterns_kea_CV',
  'goog.i18n.DateTimePatterns_khq',
  'goog.i18n.DateTimePatterns_khq_ML',
  'goog.i18n.DateTimePatterns_ki',
  'goog.i18n.DateTimePatterns_ki_KE',
  'goog.i18n.DateTimePatterns_kk',
  'goog.i18n.DateTimePatterns_kk_Cyrl',
  'goog.i18n.DateTimePatterns_kk_Cyrl_KZ',
  'goog.i18n.DateTimePatterns_kl',
  'goog.i18n.DateTimePatterns_kl_GL',
  'goog.i18n.DateTimePatterns_kln',
  'goog.i18n.DateTimePatterns_kln_KE',
  'goog.i18n.DateTimePatterns_km',
  'goog.i18n.DateTimePatterns_km_KH',
  'goog.i18n.DateTimePatterns_kn_IN',
  'goog.i18n.DateTimePatterns_ko_KP',
  'goog.i18n.DateTimePatterns_ko_KR',
  'goog.i18n.DateTimePatterns_kok',
  'goog.i18n.DateTimePatterns_kok_IN',
  'goog.i18n.DateTimePatterns_ks',
  'goog.i18n.DateTimePatterns_ks_Arab',
  'goog.i18n.DateTimePatterns_ks_Arab_IN',
  'goog.i18n.DateTimePatterns_ksb',
  'goog.i18n.DateTimePatterns_ksb_TZ',
  'goog.i18n.DateTimePatterns_ksf',
  'goog.i18n.DateTimePatterns_ksf_CM',
  'goog.i18n.DateTimePatterns_kw',
  'goog.i18n.DateTimePatterns_kw_GB',
  'goog.i18n.DateTimePatterns_lag',
  'goog.i18n.DateTimePatterns_lag_TZ',
  'goog.i18n.DateTimePatterns_lg',
  'goog.i18n.DateTimePatterns_lg_UG',
  'goog.i18n.DateTimePatterns_ln_AO',
  'goog.i18n.DateTimePatterns_ln_CD',
  'goog.i18n.DateTimePatterns_ln_CF',
  'goog.i18n.DateTimePatterns_ln_CG',
  'goog.i18n.DateTimePatterns_lo',
  'goog.i18n.DateTimePatterns_lo_LA',
  'goog.i18n.DateTimePatterns_lt_LT',
  'goog.i18n.DateTimePatterns_lu',
  'goog.i18n.DateTimePatterns_lu_CD',
  'goog.i18n.DateTimePatterns_luo',
  'goog.i18n.DateTimePatterns_luo_KE',
  'goog.i18n.DateTimePatterns_luy',
  'goog.i18n.DateTimePatterns_luy_KE',
  'goog.i18n.DateTimePatterns_lv_LV',
  'goog.i18n.DateTimePatterns_mas',
  'goog.i18n.DateTimePatterns_mas_KE',
  'goog.i18n.DateTimePatterns_mas_TZ',
  'goog.i18n.DateTimePatterns_mer',
  'goog.i18n.DateTimePatterns_mer_KE',
  'goog.i18n.DateTimePatterns_mfe',
  'goog.i18n.DateTimePatterns_mfe_MU',
  'goog.i18n.DateTimePatterns_mg',
  'goog.i18n.DateTimePatterns_mg_MG',
  'goog.i18n.DateTimePatterns_mgh',
  'goog.i18n.DateTimePatterns_mgh_MZ',
  'goog.i18n.DateTimePatterns_mgo',
  'goog.i18n.DateTimePatterns_mgo_CM',
  'goog.i18n.DateTimePatterns_mk',
  'goog.i18n.DateTimePatterns_mk_MK',
  'goog.i18n.DateTimePatterns_ml_IN',
  'goog.i18n.DateTimePatterns_mn',
  'goog.i18n.DateTimePatterns_mn_Cyrl',
  'goog.i18n.DateTimePatterns_mn_Cyrl_MN',
  'goog.i18n.DateTimePatterns_mr_IN',
  'goog.i18n.DateTimePatterns_ms_Latn',
  'goog.i18n.DateTimePatterns_ms_Latn_BN',
  'goog.i18n.DateTimePatterns_ms_Latn_MY',
  'goog.i18n.DateTimePatterns_ms_Latn_SG',
  'goog.i18n.DateTimePatterns_mt_MT',
  'goog.i18n.DateTimePatterns_mua',
  'goog.i18n.DateTimePatterns_mua_CM',
  'goog.i18n.DateTimePatterns_my',
  'goog.i18n.DateTimePatterns_my_MM',
  'goog.i18n.DateTimePatterns_naq',
  'goog.i18n.DateTimePatterns_naq_NA',
  'goog.i18n.DateTimePatterns_nb_NO',
  'goog.i18n.DateTimePatterns_nd',
  'goog.i18n.DateTimePatterns_nd_ZW',
  'goog.i18n.DateTimePatterns_ne',
  'goog.i18n.DateTimePatterns_ne_IN',
  'goog.i18n.DateTimePatterns_ne_NP',
  'goog.i18n.DateTimePatterns_nl_AW',
  'goog.i18n.DateTimePatterns_nl_BE',
  'goog.i18n.DateTimePatterns_nl_CW',
  'goog.i18n.DateTimePatterns_nl_NL',
  'goog.i18n.DateTimePatterns_nl_SR',
  'goog.i18n.DateTimePatterns_nl_SX',
  'goog.i18n.DateTimePatterns_nmg',
  'goog.i18n.DateTimePatterns_nmg_CM',
  'goog.i18n.DateTimePatterns_nn',
  'goog.i18n.DateTimePatterns_nn_NO',
  'goog.i18n.DateTimePatterns_nus',
  'goog.i18n.DateTimePatterns_nus_SD',
  'goog.i18n.DateTimePatterns_nyn',
  'goog.i18n.DateTimePatterns_nyn_UG',
  'goog.i18n.DateTimePatterns_om',
  'goog.i18n.DateTimePatterns_om_ET',
  'goog.i18n.DateTimePatterns_om_KE',
  'goog.i18n.DateTimePatterns_or_IN',
  'goog.i18n.DateTimePatterns_pa',
  'goog.i18n.DateTimePatterns_pa_Arab',
  'goog.i18n.DateTimePatterns_pa_Arab_PK',
  'goog.i18n.DateTimePatterns_pa_Guru',
  'goog.i18n.DateTimePatterns_pa_Guru_IN',
  'goog.i18n.DateTimePatterns_pl_PL',
  'goog.i18n.DateTimePatterns_ps',
  'goog.i18n.DateTimePatterns_ps_AF',
  'goog.i18n.DateTimePatterns_pt_AO',
  'goog.i18n.DateTimePatterns_pt_CV',
  'goog.i18n.DateTimePatterns_pt_GW',
  'goog.i18n.DateTimePatterns_pt_MO',
  'goog.i18n.DateTimePatterns_pt_MZ',
  'goog.i18n.DateTimePatterns_pt_ST',
  'goog.i18n.DateTimePatterns_pt_TL',
  'goog.i18n.DateTimePatterns_rm',
  'goog.i18n.DateTimePatterns_rm_CH',
  'goog.i18n.DateTimePatterns_rn',
  'goog.i18n.DateTimePatterns_rn_BI',
  'goog.i18n.DateTimePatterns_ro_MD',
  'goog.i18n.DateTimePatterns_ro_RO',
  'goog.i18n.DateTimePatterns_rof',
  'goog.i18n.DateTimePatterns_rof_TZ',
  'goog.i18n.DateTimePatterns_ru_BY',
  'goog.i18n.DateTimePatterns_ru_KG',
  'goog.i18n.DateTimePatterns_ru_KZ',
  'goog.i18n.DateTimePatterns_ru_MD',
  'goog.i18n.DateTimePatterns_ru_RU',
  'goog.i18n.DateTimePatterns_ru_UA',
  'goog.i18n.DateTimePatterns_rw',
  'goog.i18n.DateTimePatterns_rw_RW',
  'goog.i18n.DateTimePatterns_rwk',
  'goog.i18n.DateTimePatterns_rwk_TZ',
  'goog.i18n.DateTimePatterns_saq',
  'goog.i18n.DateTimePatterns_saq_KE',
  'goog.i18n.DateTimePatterns_sbp',
  'goog.i18n.DateTimePatterns_sbp_TZ',
  'goog.i18n.DateTimePatterns_seh',
  'goog.i18n.DateTimePatterns_seh_MZ',
  'goog.i18n.DateTimePatterns_ses',
  'goog.i18n.DateTimePatterns_ses_ML',
  'goog.i18n.DateTimePatterns_sg',
  'goog.i18n.DateTimePatterns_sg_CF',
  'goog.i18n.DateTimePatterns_shi',
  'goog.i18n.DateTimePatterns_shi_Latn',
  'goog.i18n.DateTimePatterns_shi_Latn_MA',
  'goog.i18n.DateTimePatterns_shi_Tfng',
  'goog.i18n.DateTimePatterns_shi_Tfng_MA',
  'goog.i18n.DateTimePatterns_si',
  'goog.i18n.DateTimePatterns_si_LK',
  'goog.i18n.DateTimePatterns_sk_SK',
  'goog.i18n.DateTimePatterns_sl_SI',
  'goog.i18n.DateTimePatterns_sn',
  'goog.i18n.DateTimePatterns_sn_ZW',
  'goog.i18n.DateTimePatterns_so',
  'goog.i18n.DateTimePatterns_so_DJ',
  'goog.i18n.DateTimePatterns_so_ET',
  'goog.i18n.DateTimePatterns_so_KE',
  'goog.i18n.DateTimePatterns_so_SO',
  'goog.i18n.DateTimePatterns_sq_AL',
  'goog.i18n.DateTimePatterns_sq_MK',
  'goog.i18n.DateTimePatterns_sr_Cyrl',
  'goog.i18n.DateTimePatterns_sr_Cyrl_BA',
  'goog.i18n.DateTimePatterns_sr_Cyrl_ME',
  'goog.i18n.DateTimePatterns_sr_Cyrl_RS',
  'goog.i18n.DateTimePatterns_sr_Latn',
  'goog.i18n.DateTimePatterns_sr_Latn_BA',
  'goog.i18n.DateTimePatterns_sr_Latn_ME',
  'goog.i18n.DateTimePatterns_sr_Latn_RS',
  'goog.i18n.DateTimePatterns_sv_AX',
  'goog.i18n.DateTimePatterns_sv_FI',
  'goog.i18n.DateTimePatterns_sv_SE',
  'goog.i18n.DateTimePatterns_sw_KE',
  'goog.i18n.DateTimePatterns_sw_TZ',
  'goog.i18n.DateTimePatterns_sw_UG',
  'goog.i18n.DateTimePatterns_swc',
  'goog.i18n.DateTimePatterns_swc_CD',
  'goog.i18n.DateTimePatterns_ta_IN',
  'goog.i18n.DateTimePatterns_ta_LK',
  'goog.i18n.DateTimePatterns_ta_MY',
  'goog.i18n.DateTimePatterns_ta_SG',
  'goog.i18n.DateTimePatterns_te_IN',
  'goog.i18n.DateTimePatterns_teo',
  'goog.i18n.DateTimePatterns_teo_KE',
  'goog.i18n.DateTimePatterns_teo_UG',
  'goog.i18n.DateTimePatterns_th_TH',
  'goog.i18n.DateTimePatterns_ti',
  'goog.i18n.DateTimePatterns_ti_ER',
  'goog.i18n.DateTimePatterns_ti_ET',
  'goog.i18n.DateTimePatterns_to',
  'goog.i18n.DateTimePatterns_to_TO',
  'goog.i18n.DateTimePatterns_tr_CY',
  'goog.i18n.DateTimePatterns_tr_TR',
  'goog.i18n.DateTimePatterns_twq',
  'goog.i18n.DateTimePatterns_twq_NE',
  'goog.i18n.DateTimePatterns_tzm',
  'goog.i18n.DateTimePatterns_tzm_Latn',
  'goog.i18n.DateTimePatterns_tzm_Latn_MA',
  'goog.i18n.DateTimePatterns_uk_UA',
  'goog.i18n.DateTimePatterns_ur_IN',
  'goog.i18n.DateTimePatterns_ur_PK',
  'goog.i18n.DateTimePatterns_uz',
  'goog.i18n.DateTimePatterns_uz_Arab',
  'goog.i18n.DateTimePatterns_uz_Arab_AF',
  'goog.i18n.DateTimePatterns_uz_Cyrl',
  'goog.i18n.DateTimePatterns_uz_Cyrl_UZ',
  'goog.i18n.DateTimePatterns_uz_Latn',
  'goog.i18n.DateTimePatterns_uz_Latn_UZ',
  'goog.i18n.DateTimePatterns_vai',
  'goog.i18n.DateTimePatterns_vai_Latn',
  'goog.i18n.DateTimePatterns_vai_Latn_LR',
  'goog.i18n.DateTimePatterns_vai_Vaii',
  'goog.i18n.DateTimePatterns_vai_Vaii_LR',
  'goog.i18n.DateTimePatterns_vi_VN',
  'goog.i18n.DateTimePatterns_vun',
  'goog.i18n.DateTimePatterns_vun_TZ',
  'goog.i18n.DateTimePatterns_xog',
  'goog.i18n.DateTimePatterns_xog_UG',
  'goog.i18n.DateTimePatterns_yav',
  'goog.i18n.DateTimePatterns_yav_CM',
  'goog.i18n.DateTimePatterns_yo',
  'goog.i18n.DateTimePatterns_yo_NG',
  'goog.i18n.DateTimePatterns_zh_Hans',
  'goog.i18n.DateTimePatterns_zh_Hans_CN',
  'goog.i18n.DateTimePatterns_zh_Hans_HK',
  'goog.i18n.DateTimePatterns_zh_Hans_MO',
  'goog.i18n.DateTimePatterns_zh_Hans_SG',
  'goog.i18n.DateTimePatterns_zh_Hant',
  'goog.i18n.DateTimePatterns_zh_Hant_HK',
  'goog.i18n.DateTimePatterns_zh_Hant_MO',
  'goog.i18n.DateTimePatterns_zh_Hant_TW',
  'goog.i18n.DateTimePatterns_zu_ZA'
], ['goog.i18n.DateTimePatterns']);
goog.addDependency('i18n/datetimesymbols.js', [
  'goog.i18n.DateTimeSymbols',
  'goog.i18n.DateTimeSymbols_af',
  'goog.i18n.DateTimeSymbols_am',
  'goog.i18n.DateTimeSymbols_ar',
  'goog.i18n.DateTimeSymbols_bg',
  'goog.i18n.DateTimeSymbols_bn',
  'goog.i18n.DateTimeSymbols_br',
  'goog.i18n.DateTimeSymbols_ca',
  'goog.i18n.DateTimeSymbols_chr',
  'goog.i18n.DateTimeSymbols_cs',
  'goog.i18n.DateTimeSymbols_cy',
  'goog.i18n.DateTimeSymbols_da',
  'goog.i18n.DateTimeSymbols_de',
  'goog.i18n.DateTimeSymbols_de_AT',
  'goog.i18n.DateTimeSymbols_de_CH',
  'goog.i18n.DateTimeSymbols_el',
  'goog.i18n.DateTimeSymbols_en',
  'goog.i18n.DateTimeSymbols_en_AU',
  'goog.i18n.DateTimeSymbols_en_GB',
  'goog.i18n.DateTimeSymbols_en_IE',
  'goog.i18n.DateTimeSymbols_en_IN',
  'goog.i18n.DateTimeSymbols_en_ISO',
  'goog.i18n.DateTimeSymbols_en_SG',
  'goog.i18n.DateTimeSymbols_en_US',
  'goog.i18n.DateTimeSymbols_en_ZA',
  'goog.i18n.DateTimeSymbols_es',
  'goog.i18n.DateTimeSymbols_es_419',
  'goog.i18n.DateTimeSymbols_es_ES',
  'goog.i18n.DateTimeSymbols_et',
  'goog.i18n.DateTimeSymbols_eu',
  'goog.i18n.DateTimeSymbols_fa',
  'goog.i18n.DateTimeSymbols_fi',
  'goog.i18n.DateTimeSymbols_fil',
  'goog.i18n.DateTimeSymbols_fr',
  'goog.i18n.DateTimeSymbols_fr_CA',
  'goog.i18n.DateTimeSymbols_gl',
  'goog.i18n.DateTimeSymbols_gsw',
  'goog.i18n.DateTimeSymbols_gu',
  'goog.i18n.DateTimeSymbols_haw',
  'goog.i18n.DateTimeSymbols_he',
  'goog.i18n.DateTimeSymbols_hi',
  'goog.i18n.DateTimeSymbols_hr',
  'goog.i18n.DateTimeSymbols_hu',
  'goog.i18n.DateTimeSymbols_id',
  'goog.i18n.DateTimeSymbols_in',
  'goog.i18n.DateTimeSymbols_is',
  'goog.i18n.DateTimeSymbols_it',
  'goog.i18n.DateTimeSymbols_iw',
  'goog.i18n.DateTimeSymbols_ja',
  'goog.i18n.DateTimeSymbols_kn',
  'goog.i18n.DateTimeSymbols_ko',
  'goog.i18n.DateTimeSymbols_ln',
  'goog.i18n.DateTimeSymbols_lt',
  'goog.i18n.DateTimeSymbols_lv',
  'goog.i18n.DateTimeSymbols_ml',
  'goog.i18n.DateTimeSymbols_mr',
  'goog.i18n.DateTimeSymbols_ms',
  'goog.i18n.DateTimeSymbols_mt',
  'goog.i18n.DateTimeSymbols_nb',
  'goog.i18n.DateTimeSymbols_nl',
  'goog.i18n.DateTimeSymbols_no',
  'goog.i18n.DateTimeSymbols_or',
  'goog.i18n.DateTimeSymbols_pl',
  'goog.i18n.DateTimeSymbols_pt',
  'goog.i18n.DateTimeSymbols_pt_BR',
  'goog.i18n.DateTimeSymbols_pt_PT',
  'goog.i18n.DateTimeSymbols_ro',
  'goog.i18n.DateTimeSymbols_ru',
  'goog.i18n.DateTimeSymbols_sk',
  'goog.i18n.DateTimeSymbols_sl',
  'goog.i18n.DateTimeSymbols_sq',
  'goog.i18n.DateTimeSymbols_sr',
  'goog.i18n.DateTimeSymbols_sv',
  'goog.i18n.DateTimeSymbols_sw',
  'goog.i18n.DateTimeSymbols_ta',
  'goog.i18n.DateTimeSymbols_te',
  'goog.i18n.DateTimeSymbols_th',
  'goog.i18n.DateTimeSymbols_tl',
  'goog.i18n.DateTimeSymbols_tr',
  'goog.i18n.DateTimeSymbols_uk',
  'goog.i18n.DateTimeSymbols_ur',
  'goog.i18n.DateTimeSymbols_vi',
  'goog.i18n.DateTimeSymbols_zh',
  'goog.i18n.DateTimeSymbols_zh_CN',
  'goog.i18n.DateTimeSymbols_zh_HK',
  'goog.i18n.DateTimeSymbols_zh_TW',
  'goog.i18n.DateTimeSymbols_zu'
], []);
goog.addDependency('i18n/datetimesymbolsext.js', [
  'goog.i18n.DateTimeSymbolsExt',
  'goog.i18n.DateTimeSymbols_aa',
  'goog.i18n.DateTimeSymbols_aa_DJ',
  'goog.i18n.DateTimeSymbols_aa_ER',
  'goog.i18n.DateTimeSymbols_aa_ET',
  'goog.i18n.DateTimeSymbols_af_NA',
  'goog.i18n.DateTimeSymbols_af_ZA',
  'goog.i18n.DateTimeSymbols_agq',
  'goog.i18n.DateTimeSymbols_agq_CM',
  'goog.i18n.DateTimeSymbols_ak',
  'goog.i18n.DateTimeSymbols_ak_GH',
  'goog.i18n.DateTimeSymbols_am_ET',
  'goog.i18n.DateTimeSymbols_ar_001',
  'goog.i18n.DateTimeSymbols_ar_AE',
  'goog.i18n.DateTimeSymbols_ar_BH',
  'goog.i18n.DateTimeSymbols_ar_DJ',
  'goog.i18n.DateTimeSymbols_ar_DZ',
  'goog.i18n.DateTimeSymbols_ar_EG',
  'goog.i18n.DateTimeSymbols_ar_EH',
  'goog.i18n.DateTimeSymbols_ar_ER',
  'goog.i18n.DateTimeSymbols_ar_IL',
  'goog.i18n.DateTimeSymbols_ar_IQ',
  'goog.i18n.DateTimeSymbols_ar_JO',
  'goog.i18n.DateTimeSymbols_ar_KM',
  'goog.i18n.DateTimeSymbols_ar_KW',
  'goog.i18n.DateTimeSymbols_ar_LB',
  'goog.i18n.DateTimeSymbols_ar_LY',
  'goog.i18n.DateTimeSymbols_ar_MA',
  'goog.i18n.DateTimeSymbols_ar_MR',
  'goog.i18n.DateTimeSymbols_ar_OM',
  'goog.i18n.DateTimeSymbols_ar_PS',
  'goog.i18n.DateTimeSymbols_ar_QA',
  'goog.i18n.DateTimeSymbols_ar_SA',
  'goog.i18n.DateTimeSymbols_ar_SD',
  'goog.i18n.DateTimeSymbols_ar_SO',
  'goog.i18n.DateTimeSymbols_ar_SY',
  'goog.i18n.DateTimeSymbols_ar_TD',
  'goog.i18n.DateTimeSymbols_ar_TN',
  'goog.i18n.DateTimeSymbols_ar_YE',
  'goog.i18n.DateTimeSymbols_as',
  'goog.i18n.DateTimeSymbols_as_IN',
  'goog.i18n.DateTimeSymbols_asa',
  'goog.i18n.DateTimeSymbols_asa_TZ',
  'goog.i18n.DateTimeSymbols_ast',
  'goog.i18n.DateTimeSymbols_ast_ES',
  'goog.i18n.DateTimeSymbols_az',
  'goog.i18n.DateTimeSymbols_az_Cyrl',
  'goog.i18n.DateTimeSymbols_az_Cyrl_AZ',
  'goog.i18n.DateTimeSymbols_az_Latn',
  'goog.i18n.DateTimeSymbols_az_Latn_AZ',
  'goog.i18n.DateTimeSymbols_bas',
  'goog.i18n.DateTimeSymbols_bas_CM',
  'goog.i18n.DateTimeSymbols_be',
  'goog.i18n.DateTimeSymbols_be_BY',
  'goog.i18n.DateTimeSymbols_bem',
  'goog.i18n.DateTimeSymbols_bem_ZM',
  'goog.i18n.DateTimeSymbols_bez',
  'goog.i18n.DateTimeSymbols_bez_TZ',
  'goog.i18n.DateTimeSymbols_bg_BG',
  'goog.i18n.DateTimeSymbols_bm',
  'goog.i18n.DateTimeSymbols_bm_ML',
  'goog.i18n.DateTimeSymbols_bn_BD',
  'goog.i18n.DateTimeSymbols_bn_IN',
  'goog.i18n.DateTimeSymbols_bo',
  'goog.i18n.DateTimeSymbols_bo_CN',
  'goog.i18n.DateTimeSymbols_bo_IN',
  'goog.i18n.DateTimeSymbols_br_FR',
  'goog.i18n.DateTimeSymbols_brx',
  'goog.i18n.DateTimeSymbols_brx_IN',
  'goog.i18n.DateTimeSymbols_bs',
  'goog.i18n.DateTimeSymbols_bs_Cyrl',
  'goog.i18n.DateTimeSymbols_bs_Cyrl_BA',
  'goog.i18n.DateTimeSymbols_bs_Latn',
  'goog.i18n.DateTimeSymbols_bs_Latn_BA',
  'goog.i18n.DateTimeSymbols_byn',
  'goog.i18n.DateTimeSymbols_byn_ER',
  'goog.i18n.DateTimeSymbols_ca_AD',
  'goog.i18n.DateTimeSymbols_ca_ES',
  'goog.i18n.DateTimeSymbols_cgg',
  'goog.i18n.DateTimeSymbols_cgg_UG',
  'goog.i18n.DateTimeSymbols_chr_US',
  'goog.i18n.DateTimeSymbols_ckb',
  'goog.i18n.DateTimeSymbols_ckb_Arab',
  'goog.i18n.DateTimeSymbols_ckb_Arab_IQ',
  'goog.i18n.DateTimeSymbols_ckb_Arab_IR',
  'goog.i18n.DateTimeSymbols_ckb_IQ',
  'goog.i18n.DateTimeSymbols_ckb_IR',
  'goog.i18n.DateTimeSymbols_ckb_Latn',
  'goog.i18n.DateTimeSymbols_ckb_Latn_IQ',
  'goog.i18n.DateTimeSymbols_cs_CZ',
  'goog.i18n.DateTimeSymbols_cy_GB',
  'goog.i18n.DateTimeSymbols_da_DK',
  'goog.i18n.DateTimeSymbols_dav',
  'goog.i18n.DateTimeSymbols_dav_KE',
  'goog.i18n.DateTimeSymbols_de_BE',
  'goog.i18n.DateTimeSymbols_de_DE',
  'goog.i18n.DateTimeSymbols_de_LI',
  'goog.i18n.DateTimeSymbols_de_LU',
  'goog.i18n.DateTimeSymbols_dje',
  'goog.i18n.DateTimeSymbols_dje_NE',
  'goog.i18n.DateTimeSymbols_dua',
  'goog.i18n.DateTimeSymbols_dua_CM',
  'goog.i18n.DateTimeSymbols_dyo',
  'goog.i18n.DateTimeSymbols_dyo_SN',
  'goog.i18n.DateTimeSymbols_dz',
  'goog.i18n.DateTimeSymbols_dz_BT',
  'goog.i18n.DateTimeSymbols_ebu',
  'goog.i18n.DateTimeSymbols_ebu_KE',
  'goog.i18n.DateTimeSymbols_ee',
  'goog.i18n.DateTimeSymbols_ee_GH',
  'goog.i18n.DateTimeSymbols_ee_TG',
  'goog.i18n.DateTimeSymbols_el_CY',
  'goog.i18n.DateTimeSymbols_el_GR',
  'goog.i18n.DateTimeSymbols_en_150',
  'goog.i18n.DateTimeSymbols_en_AG',
  'goog.i18n.DateTimeSymbols_en_AS',
  'goog.i18n.DateTimeSymbols_en_BB',
  'goog.i18n.DateTimeSymbols_en_BE',
  'goog.i18n.DateTimeSymbols_en_BM',
  'goog.i18n.DateTimeSymbols_en_BS',
  'goog.i18n.DateTimeSymbols_en_BW',
  'goog.i18n.DateTimeSymbols_en_BZ',
  'goog.i18n.DateTimeSymbols_en_CA',
  'goog.i18n.DateTimeSymbols_en_CM',
  'goog.i18n.DateTimeSymbols_en_DM',
  'goog.i18n.DateTimeSymbols_en_Dsrt',
  'goog.i18n.DateTimeSymbols_en_Dsrt_US',
  'goog.i18n.DateTimeSymbols_en_FJ',
  'goog.i18n.DateTimeSymbols_en_FM',
  'goog.i18n.DateTimeSymbols_en_GD',
  'goog.i18n.DateTimeSymbols_en_GG',
  'goog.i18n.DateTimeSymbols_en_GH',
  'goog.i18n.DateTimeSymbols_en_GI',
  'goog.i18n.DateTimeSymbols_en_GM',
  'goog.i18n.DateTimeSymbols_en_GU',
  'goog.i18n.DateTimeSymbols_en_GY',
  'goog.i18n.DateTimeSymbols_en_HK',
  'goog.i18n.DateTimeSymbols_en_IM',
  'goog.i18n.DateTimeSymbols_en_JE',
  'goog.i18n.DateTimeSymbols_en_JM',
  'goog.i18n.DateTimeSymbols_en_KE',
  'goog.i18n.DateTimeSymbols_en_KI',
  'goog.i18n.DateTimeSymbols_en_KN',
  'goog.i18n.DateTimeSymbols_en_KY',
  'goog.i18n.DateTimeSymbols_en_LC',
  'goog.i18n.DateTimeSymbols_en_LR',
  'goog.i18n.DateTimeSymbols_en_LS',
  'goog.i18n.DateTimeSymbols_en_MG',
  'goog.i18n.DateTimeSymbols_en_MH',
  'goog.i18n.DateTimeSymbols_en_MP',
  'goog.i18n.DateTimeSymbols_en_MT',
  'goog.i18n.DateTimeSymbols_en_MU',
  'goog.i18n.DateTimeSymbols_en_MW',
  'goog.i18n.DateTimeSymbols_en_NA',
  'goog.i18n.DateTimeSymbols_en_NG',
  'goog.i18n.DateTimeSymbols_en_NZ',
  'goog.i18n.DateTimeSymbols_en_PG',
  'goog.i18n.DateTimeSymbols_en_PH',
  'goog.i18n.DateTimeSymbols_en_PK',
  'goog.i18n.DateTimeSymbols_en_PR',
  'goog.i18n.DateTimeSymbols_en_PW',
  'goog.i18n.DateTimeSymbols_en_SB',
  'goog.i18n.DateTimeSymbols_en_SC',
  'goog.i18n.DateTimeSymbols_en_SL',
  'goog.i18n.DateTimeSymbols_en_SS',
  'goog.i18n.DateTimeSymbols_en_SZ',
  'goog.i18n.DateTimeSymbols_en_TC',
  'goog.i18n.DateTimeSymbols_en_TO',
  'goog.i18n.DateTimeSymbols_en_TT',
  'goog.i18n.DateTimeSymbols_en_TZ',
  'goog.i18n.DateTimeSymbols_en_UG',
  'goog.i18n.DateTimeSymbols_en_UM',
  'goog.i18n.DateTimeSymbols_en_VC',
  'goog.i18n.DateTimeSymbols_en_VG',
  'goog.i18n.DateTimeSymbols_en_VI',
  'goog.i18n.DateTimeSymbols_en_VU',
  'goog.i18n.DateTimeSymbols_en_WS',
  'goog.i18n.DateTimeSymbols_en_ZM',
  'goog.i18n.DateTimeSymbols_en_ZW',
  'goog.i18n.DateTimeSymbols_eo',
  'goog.i18n.DateTimeSymbols_es_AR',
  'goog.i18n.DateTimeSymbols_es_BO',
  'goog.i18n.DateTimeSymbols_es_CL',
  'goog.i18n.DateTimeSymbols_es_CO',
  'goog.i18n.DateTimeSymbols_es_CR',
  'goog.i18n.DateTimeSymbols_es_CU',
  'goog.i18n.DateTimeSymbols_es_DO',
  'goog.i18n.DateTimeSymbols_es_EA',
  'goog.i18n.DateTimeSymbols_es_EC',
  'goog.i18n.DateTimeSymbols_es_GQ',
  'goog.i18n.DateTimeSymbols_es_GT',
  'goog.i18n.DateTimeSymbols_es_HN',
  'goog.i18n.DateTimeSymbols_es_IC',
  'goog.i18n.DateTimeSymbols_es_MX',
  'goog.i18n.DateTimeSymbols_es_NI',
  'goog.i18n.DateTimeSymbols_es_PA',
  'goog.i18n.DateTimeSymbols_es_PE',
  'goog.i18n.DateTimeSymbols_es_PH',
  'goog.i18n.DateTimeSymbols_es_PR',
  'goog.i18n.DateTimeSymbols_es_PY',
  'goog.i18n.DateTimeSymbols_es_SV',
  'goog.i18n.DateTimeSymbols_es_US',
  'goog.i18n.DateTimeSymbols_es_UY',
  'goog.i18n.DateTimeSymbols_es_VE',
  'goog.i18n.DateTimeSymbols_et_EE',
  'goog.i18n.DateTimeSymbols_eu_ES',
  'goog.i18n.DateTimeSymbols_ewo',
  'goog.i18n.DateTimeSymbols_ewo_CM',
  'goog.i18n.DateTimeSymbols_fa_AF',
  'goog.i18n.DateTimeSymbols_fa_IR',
  'goog.i18n.DateTimeSymbols_ff',
  'goog.i18n.DateTimeSymbols_ff_SN',
  'goog.i18n.DateTimeSymbols_fi_FI',
  'goog.i18n.DateTimeSymbols_fil_PH',
  'goog.i18n.DateTimeSymbols_fo',
  'goog.i18n.DateTimeSymbols_fo_FO',
  'goog.i18n.DateTimeSymbols_fr_BE',
  'goog.i18n.DateTimeSymbols_fr_BF',
  'goog.i18n.DateTimeSymbols_fr_BI',
  'goog.i18n.DateTimeSymbols_fr_BJ',
  'goog.i18n.DateTimeSymbols_fr_BL',
  'goog.i18n.DateTimeSymbols_fr_CD',
  'goog.i18n.DateTimeSymbols_fr_CF',
  'goog.i18n.DateTimeSymbols_fr_CG',
  'goog.i18n.DateTimeSymbols_fr_CH',
  'goog.i18n.DateTimeSymbols_fr_CI',
  'goog.i18n.DateTimeSymbols_fr_CM',
  'goog.i18n.DateTimeSymbols_fr_DJ',
  'goog.i18n.DateTimeSymbols_fr_DZ',
  'goog.i18n.DateTimeSymbols_fr_FR',
  'goog.i18n.DateTimeSymbols_fr_GA',
  'goog.i18n.DateTimeSymbols_fr_GF',
  'goog.i18n.DateTimeSymbols_fr_GN',
  'goog.i18n.DateTimeSymbols_fr_GP',
  'goog.i18n.DateTimeSymbols_fr_GQ',
  'goog.i18n.DateTimeSymbols_fr_HT',
  'goog.i18n.DateTimeSymbols_fr_KM',
  'goog.i18n.DateTimeSymbols_fr_LU',
  'goog.i18n.DateTimeSymbols_fr_MA',
  'goog.i18n.DateTimeSymbols_fr_MC',
  'goog.i18n.DateTimeSymbols_fr_MF',
  'goog.i18n.DateTimeSymbols_fr_MG',
  'goog.i18n.DateTimeSymbols_fr_ML',
  'goog.i18n.DateTimeSymbols_fr_MQ',
  'goog.i18n.DateTimeSymbols_fr_MR',
  'goog.i18n.DateTimeSymbols_fr_MU',
  'goog.i18n.DateTimeSymbols_fr_NC',
  'goog.i18n.DateTimeSymbols_fr_NE',
  'goog.i18n.DateTimeSymbols_fr_PF',
  'goog.i18n.DateTimeSymbols_fr_RE',
  'goog.i18n.DateTimeSymbols_fr_RW',
  'goog.i18n.DateTimeSymbols_fr_SC',
  'goog.i18n.DateTimeSymbols_fr_SN',
  'goog.i18n.DateTimeSymbols_fr_SY',
  'goog.i18n.DateTimeSymbols_fr_TD',
  'goog.i18n.DateTimeSymbols_fr_TG',
  'goog.i18n.DateTimeSymbols_fr_TN',
  'goog.i18n.DateTimeSymbols_fr_VU',
  'goog.i18n.DateTimeSymbols_fr_YT',
  'goog.i18n.DateTimeSymbols_fur',
  'goog.i18n.DateTimeSymbols_fur_IT',
  'goog.i18n.DateTimeSymbols_ga',
  'goog.i18n.DateTimeSymbols_ga_IE',
  'goog.i18n.DateTimeSymbols_gd',
  'goog.i18n.DateTimeSymbols_gd_GB',
  'goog.i18n.DateTimeSymbols_gl_ES',
  'goog.i18n.DateTimeSymbols_gsw_CH',
  'goog.i18n.DateTimeSymbols_gu_IN',
  'goog.i18n.DateTimeSymbols_guz',
  'goog.i18n.DateTimeSymbols_guz_KE',
  'goog.i18n.DateTimeSymbols_gv',
  'goog.i18n.DateTimeSymbols_gv_GB',
  'goog.i18n.DateTimeSymbols_ha',
  'goog.i18n.DateTimeSymbols_ha_Latn',
  'goog.i18n.DateTimeSymbols_ha_Latn_GH',
  'goog.i18n.DateTimeSymbols_ha_Latn_NE',
  'goog.i18n.DateTimeSymbols_ha_Latn_NG',
  'goog.i18n.DateTimeSymbols_haw_US',
  'goog.i18n.DateTimeSymbols_he_IL',
  'goog.i18n.DateTimeSymbols_hi_IN',
  'goog.i18n.DateTimeSymbols_hr_BA',
  'goog.i18n.DateTimeSymbols_hr_HR',
  'goog.i18n.DateTimeSymbols_hu_HU',
  'goog.i18n.DateTimeSymbols_hy',
  'goog.i18n.DateTimeSymbols_hy_AM',
  'goog.i18n.DateTimeSymbols_ia',
  'goog.i18n.DateTimeSymbols_ia_FR',
  'goog.i18n.DateTimeSymbols_id_ID',
  'goog.i18n.DateTimeSymbols_ig',
  'goog.i18n.DateTimeSymbols_ig_NG',
  'goog.i18n.DateTimeSymbols_ii',
  'goog.i18n.DateTimeSymbols_ii_CN',
  'goog.i18n.DateTimeSymbols_is_IS',
  'goog.i18n.DateTimeSymbols_it_CH',
  'goog.i18n.DateTimeSymbols_it_IT',
  'goog.i18n.DateTimeSymbols_it_SM',
  'goog.i18n.DateTimeSymbols_ja_JP',
  'goog.i18n.DateTimeSymbols_jgo',
  'goog.i18n.DateTimeSymbols_jgo_CM',
  'goog.i18n.DateTimeSymbols_jmc',
  'goog.i18n.DateTimeSymbols_jmc_TZ',
  'goog.i18n.DateTimeSymbols_ka',
  'goog.i18n.DateTimeSymbols_ka_GE',
  'goog.i18n.DateTimeSymbols_kab',
  'goog.i18n.DateTimeSymbols_kab_DZ',
  'goog.i18n.DateTimeSymbols_kam',
  'goog.i18n.DateTimeSymbols_kam_KE',
  'goog.i18n.DateTimeSymbols_kde',
  'goog.i18n.DateTimeSymbols_kde_TZ',
  'goog.i18n.DateTimeSymbols_kea',
  'goog.i18n.DateTimeSymbols_kea_CV',
  'goog.i18n.DateTimeSymbols_khq',
  'goog.i18n.DateTimeSymbols_khq_ML',
  'goog.i18n.DateTimeSymbols_ki',
  'goog.i18n.DateTimeSymbols_ki_KE',
  'goog.i18n.DateTimeSymbols_kk',
  'goog.i18n.DateTimeSymbols_kk_Cyrl',
  'goog.i18n.DateTimeSymbols_kk_Cyrl_KZ',
  'goog.i18n.DateTimeSymbols_kkj',
  'goog.i18n.DateTimeSymbols_kkj_CM',
  'goog.i18n.DateTimeSymbols_kl',
  'goog.i18n.DateTimeSymbols_kl_GL',
  'goog.i18n.DateTimeSymbols_kln',
  'goog.i18n.DateTimeSymbols_kln_KE',
  'goog.i18n.DateTimeSymbols_km',
  'goog.i18n.DateTimeSymbols_km_KH',
  'goog.i18n.DateTimeSymbols_kn_IN',
  'goog.i18n.DateTimeSymbols_ko_KP',
  'goog.i18n.DateTimeSymbols_ko_KR',
  'goog.i18n.DateTimeSymbols_kok',
  'goog.i18n.DateTimeSymbols_kok_IN',
  'goog.i18n.DateTimeSymbols_ks',
  'goog.i18n.DateTimeSymbols_ks_Arab',
  'goog.i18n.DateTimeSymbols_ks_Arab_IN',
  'goog.i18n.DateTimeSymbols_ksb',
  'goog.i18n.DateTimeSymbols_ksb_TZ',
  'goog.i18n.DateTimeSymbols_ksf',
  'goog.i18n.DateTimeSymbols_ksf_CM',
  'goog.i18n.DateTimeSymbols_ksh',
  'goog.i18n.DateTimeSymbols_ksh_DE',
  'goog.i18n.DateTimeSymbols_kw',
  'goog.i18n.DateTimeSymbols_kw_GB',
  'goog.i18n.DateTimeSymbols_ky',
  'goog.i18n.DateTimeSymbols_ky_KG',
  'goog.i18n.DateTimeSymbols_lag',
  'goog.i18n.DateTimeSymbols_lag_TZ',
  'goog.i18n.DateTimeSymbols_lg',
  'goog.i18n.DateTimeSymbols_lg_UG',
  'goog.i18n.DateTimeSymbols_ln_AO',
  'goog.i18n.DateTimeSymbols_ln_CD',
  'goog.i18n.DateTimeSymbols_ln_CF',
  'goog.i18n.DateTimeSymbols_ln_CG',
  'goog.i18n.DateTimeSymbols_lo',
  'goog.i18n.DateTimeSymbols_lo_LA',
  'goog.i18n.DateTimeSymbols_lt_LT',
  'goog.i18n.DateTimeSymbols_lu',
  'goog.i18n.DateTimeSymbols_lu_CD',
  'goog.i18n.DateTimeSymbols_luo',
  'goog.i18n.DateTimeSymbols_luo_KE',
  'goog.i18n.DateTimeSymbols_luy',
  'goog.i18n.DateTimeSymbols_luy_KE',
  'goog.i18n.DateTimeSymbols_lv_LV',
  'goog.i18n.DateTimeSymbols_mas',
  'goog.i18n.DateTimeSymbols_mas_KE',
  'goog.i18n.DateTimeSymbols_mas_TZ',
  'goog.i18n.DateTimeSymbols_mer',
  'goog.i18n.DateTimeSymbols_mer_KE',
  'goog.i18n.DateTimeSymbols_mfe',
  'goog.i18n.DateTimeSymbols_mfe_MU',
  'goog.i18n.DateTimeSymbols_mg',
  'goog.i18n.DateTimeSymbols_mg_MG',
  'goog.i18n.DateTimeSymbols_mgh',
  'goog.i18n.DateTimeSymbols_mgh_MZ',
  'goog.i18n.DateTimeSymbols_mgo',
  'goog.i18n.DateTimeSymbols_mgo_CM',
  'goog.i18n.DateTimeSymbols_mk',
  'goog.i18n.DateTimeSymbols_mk_MK',
  'goog.i18n.DateTimeSymbols_ml_IN',
  'goog.i18n.DateTimeSymbols_mn',
  'goog.i18n.DateTimeSymbols_mn_Cyrl',
  'goog.i18n.DateTimeSymbols_mn_Cyrl_MN',
  'goog.i18n.DateTimeSymbols_mr_IN',
  'goog.i18n.DateTimeSymbols_ms_Latn',
  'goog.i18n.DateTimeSymbols_ms_Latn_BN',
  'goog.i18n.DateTimeSymbols_ms_Latn_MY',
  'goog.i18n.DateTimeSymbols_ms_Latn_SG',
  'goog.i18n.DateTimeSymbols_mt_MT',
  'goog.i18n.DateTimeSymbols_mua',
  'goog.i18n.DateTimeSymbols_mua_CM',
  'goog.i18n.DateTimeSymbols_my',
  'goog.i18n.DateTimeSymbols_my_MM',
  'goog.i18n.DateTimeSymbols_naq',
  'goog.i18n.DateTimeSymbols_naq_NA',
  'goog.i18n.DateTimeSymbols_nb_NO',
  'goog.i18n.DateTimeSymbols_nd',
  'goog.i18n.DateTimeSymbols_nd_ZW',
  'goog.i18n.DateTimeSymbols_ne',
  'goog.i18n.DateTimeSymbols_ne_IN',
  'goog.i18n.DateTimeSymbols_ne_NP',
  'goog.i18n.DateTimeSymbols_nl_AW',
  'goog.i18n.DateTimeSymbols_nl_BE',
  'goog.i18n.DateTimeSymbols_nl_CW',
  'goog.i18n.DateTimeSymbols_nl_NL',
  'goog.i18n.DateTimeSymbols_nl_SR',
  'goog.i18n.DateTimeSymbols_nl_SX',
  'goog.i18n.DateTimeSymbols_nmg',
  'goog.i18n.DateTimeSymbols_nmg_CM',
  'goog.i18n.DateTimeSymbols_nn',
  'goog.i18n.DateTimeSymbols_nn_NO',
  'goog.i18n.DateTimeSymbols_nnh',
  'goog.i18n.DateTimeSymbols_nnh_CM',
  'goog.i18n.DateTimeSymbols_nr',
  'goog.i18n.DateTimeSymbols_nr_ZA',
  'goog.i18n.DateTimeSymbols_nso',
  'goog.i18n.DateTimeSymbols_nso_ZA',
  'goog.i18n.DateTimeSymbols_nus',
  'goog.i18n.DateTimeSymbols_nus_SD',
  'goog.i18n.DateTimeSymbols_nyn',
  'goog.i18n.DateTimeSymbols_nyn_UG',
  'goog.i18n.DateTimeSymbols_om',
  'goog.i18n.DateTimeSymbols_om_ET',
  'goog.i18n.DateTimeSymbols_om_KE',
  'goog.i18n.DateTimeSymbols_or_IN',
  'goog.i18n.DateTimeSymbols_os',
  'goog.i18n.DateTimeSymbols_os_GE',
  'goog.i18n.DateTimeSymbols_os_RU',
  'goog.i18n.DateTimeSymbols_pa',
  'goog.i18n.DateTimeSymbols_pa_Arab',
  'goog.i18n.DateTimeSymbols_pa_Arab_PK',
  'goog.i18n.DateTimeSymbols_pa_Guru',
  'goog.i18n.DateTimeSymbols_pa_Guru_IN',
  'goog.i18n.DateTimeSymbols_pl_PL',
  'goog.i18n.DateTimeSymbols_ps',
  'goog.i18n.DateTimeSymbols_ps_AF',
  'goog.i18n.DateTimeSymbols_pt_AO',
  'goog.i18n.DateTimeSymbols_pt_CV',
  'goog.i18n.DateTimeSymbols_pt_GW',
  'goog.i18n.DateTimeSymbols_pt_MO',
  'goog.i18n.DateTimeSymbols_pt_MZ',
  'goog.i18n.DateTimeSymbols_pt_ST',
  'goog.i18n.DateTimeSymbols_pt_TL',
  'goog.i18n.DateTimeSymbols_rm',
  'goog.i18n.DateTimeSymbols_rm_CH',
  'goog.i18n.DateTimeSymbols_rn',
  'goog.i18n.DateTimeSymbols_rn_BI',
  'goog.i18n.DateTimeSymbols_ro_MD',
  'goog.i18n.DateTimeSymbols_ro_RO',
  'goog.i18n.DateTimeSymbols_rof',
  'goog.i18n.DateTimeSymbols_rof_TZ',
  'goog.i18n.DateTimeSymbols_ru_BY',
  'goog.i18n.DateTimeSymbols_ru_KG',
  'goog.i18n.DateTimeSymbols_ru_KZ',
  'goog.i18n.DateTimeSymbols_ru_MD',
  'goog.i18n.DateTimeSymbols_ru_RU',
  'goog.i18n.DateTimeSymbols_ru_UA',
  'goog.i18n.DateTimeSymbols_rw',
  'goog.i18n.DateTimeSymbols_rw_RW',
  'goog.i18n.DateTimeSymbols_rwk',
  'goog.i18n.DateTimeSymbols_rwk_TZ',
  'goog.i18n.DateTimeSymbols_sah',
  'goog.i18n.DateTimeSymbols_sah_RU',
  'goog.i18n.DateTimeSymbols_saq',
  'goog.i18n.DateTimeSymbols_saq_KE',
  'goog.i18n.DateTimeSymbols_sbp',
  'goog.i18n.DateTimeSymbols_sbp_TZ',
  'goog.i18n.DateTimeSymbols_se',
  'goog.i18n.DateTimeSymbols_se_FI',
  'goog.i18n.DateTimeSymbols_se_NO',
  'goog.i18n.DateTimeSymbols_seh',
  'goog.i18n.DateTimeSymbols_seh_MZ',
  'goog.i18n.DateTimeSymbols_ses',
  'goog.i18n.DateTimeSymbols_ses_ML',
  'goog.i18n.DateTimeSymbols_sg',
  'goog.i18n.DateTimeSymbols_sg_CF',
  'goog.i18n.DateTimeSymbols_shi',
  'goog.i18n.DateTimeSymbols_shi_Latn',
  'goog.i18n.DateTimeSymbols_shi_Latn_MA',
  'goog.i18n.DateTimeSymbols_shi_Tfng',
  'goog.i18n.DateTimeSymbols_shi_Tfng_MA',
  'goog.i18n.DateTimeSymbols_si',
  'goog.i18n.DateTimeSymbols_si_LK',
  'goog.i18n.DateTimeSymbols_sk_SK',
  'goog.i18n.DateTimeSymbols_sl_SI',
  'goog.i18n.DateTimeSymbols_sn',
  'goog.i18n.DateTimeSymbols_sn_ZW',
  'goog.i18n.DateTimeSymbols_so',
  'goog.i18n.DateTimeSymbols_so_DJ',
  'goog.i18n.DateTimeSymbols_so_ET',
  'goog.i18n.DateTimeSymbols_so_KE',
  'goog.i18n.DateTimeSymbols_so_SO',
  'goog.i18n.DateTimeSymbols_sq_AL',
  'goog.i18n.DateTimeSymbols_sq_MK',
  'goog.i18n.DateTimeSymbols_sq_XK',
  'goog.i18n.DateTimeSymbols_sr_Cyrl',
  'goog.i18n.DateTimeSymbols_sr_Cyrl_BA',
  'goog.i18n.DateTimeSymbols_sr_Cyrl_ME',
  'goog.i18n.DateTimeSymbols_sr_Cyrl_RS',
  'goog.i18n.DateTimeSymbols_sr_Cyrl_XK',
  'goog.i18n.DateTimeSymbols_sr_Latn',
  'goog.i18n.DateTimeSymbols_sr_Latn_BA',
  'goog.i18n.DateTimeSymbols_sr_Latn_ME',
  'goog.i18n.DateTimeSymbols_sr_Latn_RS',
  'goog.i18n.DateTimeSymbols_sr_Latn_XK',
  'goog.i18n.DateTimeSymbols_ss',
  'goog.i18n.DateTimeSymbols_ss_SZ',
  'goog.i18n.DateTimeSymbols_ss_ZA',
  'goog.i18n.DateTimeSymbols_ssy',
  'goog.i18n.DateTimeSymbols_ssy_ER',
  'goog.i18n.DateTimeSymbols_st',
  'goog.i18n.DateTimeSymbols_st_LS',
  'goog.i18n.DateTimeSymbols_st_ZA',
  'goog.i18n.DateTimeSymbols_sv_AX',
  'goog.i18n.DateTimeSymbols_sv_FI',
  'goog.i18n.DateTimeSymbols_sv_SE',
  'goog.i18n.DateTimeSymbols_sw_KE',
  'goog.i18n.DateTimeSymbols_sw_TZ',
  'goog.i18n.DateTimeSymbols_sw_UG',
  'goog.i18n.DateTimeSymbols_swc',
  'goog.i18n.DateTimeSymbols_swc_CD',
  'goog.i18n.DateTimeSymbols_ta_IN',
  'goog.i18n.DateTimeSymbols_ta_LK',
  'goog.i18n.DateTimeSymbols_ta_MY',
  'goog.i18n.DateTimeSymbols_ta_SG',
  'goog.i18n.DateTimeSymbols_te_IN',
  'goog.i18n.DateTimeSymbols_teo',
  'goog.i18n.DateTimeSymbols_teo_KE',
  'goog.i18n.DateTimeSymbols_teo_UG',
  'goog.i18n.DateTimeSymbols_tg',
  'goog.i18n.DateTimeSymbols_tg_Cyrl',
  'goog.i18n.DateTimeSymbols_tg_Cyrl_TJ',
  'goog.i18n.DateTimeSymbols_th_TH',
  'goog.i18n.DateTimeSymbols_ti',
  'goog.i18n.DateTimeSymbols_ti_ER',
  'goog.i18n.DateTimeSymbols_ti_ET',
  'goog.i18n.DateTimeSymbols_tig',
  'goog.i18n.DateTimeSymbols_tig_ER',
  'goog.i18n.DateTimeSymbols_tn',
  'goog.i18n.DateTimeSymbols_tn_BW',
  'goog.i18n.DateTimeSymbols_tn_ZA',
  'goog.i18n.DateTimeSymbols_to',
  'goog.i18n.DateTimeSymbols_to_TO',
  'goog.i18n.DateTimeSymbols_tr_CY',
  'goog.i18n.DateTimeSymbols_tr_TR',
  'goog.i18n.DateTimeSymbols_ts',
  'goog.i18n.DateTimeSymbols_ts_ZA',
  'goog.i18n.DateTimeSymbols_twq',
  'goog.i18n.DateTimeSymbols_twq_NE',
  'goog.i18n.DateTimeSymbols_tzm',
  'goog.i18n.DateTimeSymbols_tzm_Latn',
  'goog.i18n.DateTimeSymbols_tzm_Latn_MA',
  'goog.i18n.DateTimeSymbols_uk_UA',
  'goog.i18n.DateTimeSymbols_ur_IN',
  'goog.i18n.DateTimeSymbols_ur_PK',
  'goog.i18n.DateTimeSymbols_uz',
  'goog.i18n.DateTimeSymbols_uz_Arab',
  'goog.i18n.DateTimeSymbols_uz_Arab_AF',
  'goog.i18n.DateTimeSymbols_uz_Cyrl',
  'goog.i18n.DateTimeSymbols_uz_Cyrl_UZ',
  'goog.i18n.DateTimeSymbols_uz_Latn',
  'goog.i18n.DateTimeSymbols_uz_Latn_UZ',
  'goog.i18n.DateTimeSymbols_vai',
  'goog.i18n.DateTimeSymbols_vai_Latn',
  'goog.i18n.DateTimeSymbols_vai_Latn_LR',
  'goog.i18n.DateTimeSymbols_vai_Vaii',
  'goog.i18n.DateTimeSymbols_vai_Vaii_LR',
  'goog.i18n.DateTimeSymbols_ve',
  'goog.i18n.DateTimeSymbols_ve_ZA',
  'goog.i18n.DateTimeSymbols_vi_VN',
  'goog.i18n.DateTimeSymbols_vo',
  'goog.i18n.DateTimeSymbols_vun',
  'goog.i18n.DateTimeSymbols_vun_TZ',
  'goog.i18n.DateTimeSymbols_wae',
  'goog.i18n.DateTimeSymbols_wae_CH',
  'goog.i18n.DateTimeSymbols_wal',
  'goog.i18n.DateTimeSymbols_wal_ET',
  'goog.i18n.DateTimeSymbols_xh',
  'goog.i18n.DateTimeSymbols_xh_ZA',
  'goog.i18n.DateTimeSymbols_xog',
  'goog.i18n.DateTimeSymbols_xog_UG',
  'goog.i18n.DateTimeSymbols_yav',
  'goog.i18n.DateTimeSymbols_yav_CM',
  'goog.i18n.DateTimeSymbols_yo',
  'goog.i18n.DateTimeSymbols_yo_NG',
  'goog.i18n.DateTimeSymbols_zh_Hans',
  'goog.i18n.DateTimeSymbols_zh_Hans_CN',
  'goog.i18n.DateTimeSymbols_zh_Hans_HK',
  'goog.i18n.DateTimeSymbols_zh_Hans_MO',
  'goog.i18n.DateTimeSymbols_zh_Hans_SG',
  'goog.i18n.DateTimeSymbols_zh_Hant',
  'goog.i18n.DateTimeSymbols_zh_Hant_HK',
  'goog.i18n.DateTimeSymbols_zh_Hant_MO',
  'goog.i18n.DateTimeSymbols_zh_Hant_TW',
  'goog.i18n.DateTimeSymbols_zu_ZA'
], ['goog.i18n.DateTimeSymbols']);
goog.addDependency('i18n/graphemebreak.js', ['goog.i18n.GraphemeBreak'], ['goog.structs.InversionMap']);
goog.addDependency('i18n/messageformat.js', ['goog.i18n.MessageFormat'], [
  'goog.asserts',
  'goog.i18n.NumberFormat',
  'goog.i18n.ordinalRules',
  'goog.i18n.pluralRules'
]);
goog.addDependency('i18n/mime.js', [
  'goog.i18n.mime',
  'goog.i18n.mime.encode'
], ['goog.array']);
goog.addDependency('i18n/numberformat.js', [
  'goog.i18n.NumberFormat',
  'goog.i18n.NumberFormat.CurrencyStyle',
  'goog.i18n.NumberFormat.Format'
], [
  'goog.asserts',
  'goog.i18n.CompactNumberFormatSymbols',
  'goog.i18n.NumberFormatSymbols',
  'goog.i18n.currency',
  'goog.math'
]);
goog.addDependency('i18n/numberformatsymbols.js', [
  'goog.i18n.NumberFormatSymbols',
  'goog.i18n.NumberFormatSymbols_af',
  'goog.i18n.NumberFormatSymbols_af_ZA',
  'goog.i18n.NumberFormatSymbols_am',
  'goog.i18n.NumberFormatSymbols_am_ET',
  'goog.i18n.NumberFormatSymbols_ar',
  'goog.i18n.NumberFormatSymbols_ar_001',
  'goog.i18n.NumberFormatSymbols_ar_EG',
  'goog.i18n.NumberFormatSymbols_bg',
  'goog.i18n.NumberFormatSymbols_bg_BG',
  'goog.i18n.NumberFormatSymbols_bn',
  'goog.i18n.NumberFormatSymbols_bn_BD',
  'goog.i18n.NumberFormatSymbols_br',
  'goog.i18n.NumberFormatSymbols_br_FR',
  'goog.i18n.NumberFormatSymbols_ca',
  'goog.i18n.NumberFormatSymbols_ca_AD',
  'goog.i18n.NumberFormatSymbols_ca_ES',
  'goog.i18n.NumberFormatSymbols_chr',
  'goog.i18n.NumberFormatSymbols_chr_US',
  'goog.i18n.NumberFormatSymbols_cs',
  'goog.i18n.NumberFormatSymbols_cs_CZ',
  'goog.i18n.NumberFormatSymbols_cy',
  'goog.i18n.NumberFormatSymbols_cy_GB',
  'goog.i18n.NumberFormatSymbols_da',
  'goog.i18n.NumberFormatSymbols_da_DK',
  'goog.i18n.NumberFormatSymbols_de',
  'goog.i18n.NumberFormatSymbols_de_AT',
  'goog.i18n.NumberFormatSymbols_de_BE',
  'goog.i18n.NumberFormatSymbols_de_CH',
  'goog.i18n.NumberFormatSymbols_de_DE',
  'goog.i18n.NumberFormatSymbols_de_LU',
  'goog.i18n.NumberFormatSymbols_el',
  'goog.i18n.NumberFormatSymbols_el_GR',
  'goog.i18n.NumberFormatSymbols_en',
  'goog.i18n.NumberFormatSymbols_en_AS',
  'goog.i18n.NumberFormatSymbols_en_AU',
  'goog.i18n.NumberFormatSymbols_en_Dsrt_US',
  'goog.i18n.NumberFormatSymbols_en_FM',
  'goog.i18n.NumberFormatSymbols_en_GB',
  'goog.i18n.NumberFormatSymbols_en_GU',
  'goog.i18n.NumberFormatSymbols_en_IE',
  'goog.i18n.NumberFormatSymbols_en_IN',
  'goog.i18n.NumberFormatSymbols_en_MH',
  'goog.i18n.NumberFormatSymbols_en_MP',
  'goog.i18n.NumberFormatSymbols_en_PR',
  'goog.i18n.NumberFormatSymbols_en_PW',
  'goog.i18n.NumberFormatSymbols_en_SG',
  'goog.i18n.NumberFormatSymbols_en_TC',
  'goog.i18n.NumberFormatSymbols_en_UM',
  'goog.i18n.NumberFormatSymbols_en_US',
  'goog.i18n.NumberFormatSymbols_en_VG',
  'goog.i18n.NumberFormatSymbols_en_VI',
  'goog.i18n.NumberFormatSymbols_en_ZA',
  'goog.i18n.NumberFormatSymbols_es',
  'goog.i18n.NumberFormatSymbols_es_419',
  'goog.i18n.NumberFormatSymbols_es_EA',
  'goog.i18n.NumberFormatSymbols_es_ES',
  'goog.i18n.NumberFormatSymbols_es_IC',
  'goog.i18n.NumberFormatSymbols_et',
  'goog.i18n.NumberFormatSymbols_et_EE',
  'goog.i18n.NumberFormatSymbols_eu',
  'goog.i18n.NumberFormatSymbols_eu_ES',
  'goog.i18n.NumberFormatSymbols_fa',
  'goog.i18n.NumberFormatSymbols_fa_IR',
  'goog.i18n.NumberFormatSymbols_fi',
  'goog.i18n.NumberFormatSymbols_fi_FI',
  'goog.i18n.NumberFormatSymbols_fil',
  'goog.i18n.NumberFormatSymbols_fil_PH',
  'goog.i18n.NumberFormatSymbols_fr',
  'goog.i18n.NumberFormatSymbols_fr_BL',
  'goog.i18n.NumberFormatSymbols_fr_CA',
  'goog.i18n.NumberFormatSymbols_fr_FR',
  'goog.i18n.NumberFormatSymbols_fr_GF',
  'goog.i18n.NumberFormatSymbols_fr_GP',
  'goog.i18n.NumberFormatSymbols_fr_MC',
  'goog.i18n.NumberFormatSymbols_fr_MF',
  'goog.i18n.NumberFormatSymbols_fr_MQ',
  'goog.i18n.NumberFormatSymbols_fr_RE',
  'goog.i18n.NumberFormatSymbols_fr_YT',
  'goog.i18n.NumberFormatSymbols_gl',
  'goog.i18n.NumberFormatSymbols_gl_ES',
  'goog.i18n.NumberFormatSymbols_gsw',
  'goog.i18n.NumberFormatSymbols_gsw_CH',
  'goog.i18n.NumberFormatSymbols_gu',
  'goog.i18n.NumberFormatSymbols_gu_IN',
  'goog.i18n.NumberFormatSymbols_haw',
  'goog.i18n.NumberFormatSymbols_haw_US',
  'goog.i18n.NumberFormatSymbols_he',
  'goog.i18n.NumberFormatSymbols_he_IL',
  'goog.i18n.NumberFormatSymbols_hi',
  'goog.i18n.NumberFormatSymbols_hi_IN',
  'goog.i18n.NumberFormatSymbols_hr',
  'goog.i18n.NumberFormatSymbols_hr_HR',
  'goog.i18n.NumberFormatSymbols_hu',
  'goog.i18n.NumberFormatSymbols_hu_HU',
  'goog.i18n.NumberFormatSymbols_id',
  'goog.i18n.NumberFormatSymbols_id_ID',
  'goog.i18n.NumberFormatSymbols_in',
  'goog.i18n.NumberFormatSymbols_is',
  'goog.i18n.NumberFormatSymbols_is_IS',
  'goog.i18n.NumberFormatSymbols_it',
  'goog.i18n.NumberFormatSymbols_it_IT',
  'goog.i18n.NumberFormatSymbols_it_SM',
  'goog.i18n.NumberFormatSymbols_iw',
  'goog.i18n.NumberFormatSymbols_ja',
  'goog.i18n.NumberFormatSymbols_ja_JP',
  'goog.i18n.NumberFormatSymbols_kn',
  'goog.i18n.NumberFormatSymbols_kn_IN',
  'goog.i18n.NumberFormatSymbols_ko',
  'goog.i18n.NumberFormatSymbols_ko_KR',
  'goog.i18n.NumberFormatSymbols_ln',
  'goog.i18n.NumberFormatSymbols_ln_CD',
  'goog.i18n.NumberFormatSymbols_lt',
  'goog.i18n.NumberFormatSymbols_lt_LT',
  'goog.i18n.NumberFormatSymbols_lv',
  'goog.i18n.NumberFormatSymbols_lv_LV',
  'goog.i18n.NumberFormatSymbols_ml',
  'goog.i18n.NumberFormatSymbols_ml_IN',
  'goog.i18n.NumberFormatSymbols_mr',
  'goog.i18n.NumberFormatSymbols_mr_IN',
  'goog.i18n.NumberFormatSymbols_ms',
  'goog.i18n.NumberFormatSymbols_ms_Latn_MY',
  'goog.i18n.NumberFormatSymbols_mt',
  'goog.i18n.NumberFormatSymbols_mt_MT',
  'goog.i18n.NumberFormatSymbols_nb',
  'goog.i18n.NumberFormatSymbols_nb_NO',
  'goog.i18n.NumberFormatSymbols_nl',
  'goog.i18n.NumberFormatSymbols_nl_NL',
  'goog.i18n.NumberFormatSymbols_no',
  'goog.i18n.NumberFormatSymbols_or',
  'goog.i18n.NumberFormatSymbols_or_IN',
  'goog.i18n.NumberFormatSymbols_pl',
  'goog.i18n.NumberFormatSymbols_pl_PL',
  'goog.i18n.NumberFormatSymbols_pt',
  'goog.i18n.NumberFormatSymbols_pt_BR',
  'goog.i18n.NumberFormatSymbols_pt_PT',
  'goog.i18n.NumberFormatSymbols_ro',
  'goog.i18n.NumberFormatSymbols_ro_RO',
  'goog.i18n.NumberFormatSymbols_ru',
  'goog.i18n.NumberFormatSymbols_ru_RU',
  'goog.i18n.NumberFormatSymbols_sk',
  'goog.i18n.NumberFormatSymbols_sk_SK',
  'goog.i18n.NumberFormatSymbols_sl',
  'goog.i18n.NumberFormatSymbols_sl_SI',
  'goog.i18n.NumberFormatSymbols_sq',
  'goog.i18n.NumberFormatSymbols_sq_AL',
  'goog.i18n.NumberFormatSymbols_sr',
  'goog.i18n.NumberFormatSymbols_sr_Cyrl_RS',
  'goog.i18n.NumberFormatSymbols_sv',
  'goog.i18n.NumberFormatSymbols_sv_SE',
  'goog.i18n.NumberFormatSymbols_sw',
  'goog.i18n.NumberFormatSymbols_sw_TZ',
  'goog.i18n.NumberFormatSymbols_ta',
  'goog.i18n.NumberFormatSymbols_ta_IN',
  'goog.i18n.NumberFormatSymbols_te',
  'goog.i18n.NumberFormatSymbols_te_IN',
  'goog.i18n.NumberFormatSymbols_th',
  'goog.i18n.NumberFormatSymbols_th_TH',
  'goog.i18n.NumberFormatSymbols_tl',
  'goog.i18n.NumberFormatSymbols_tr',
  'goog.i18n.NumberFormatSymbols_tr_TR',
  'goog.i18n.NumberFormatSymbols_uk',
  'goog.i18n.NumberFormatSymbols_uk_UA',
  'goog.i18n.NumberFormatSymbols_ur',
  'goog.i18n.NumberFormatSymbols_ur_PK',
  'goog.i18n.NumberFormatSymbols_vi',
  'goog.i18n.NumberFormatSymbols_vi_VN',
  'goog.i18n.NumberFormatSymbols_zh',
  'goog.i18n.NumberFormatSymbols_zh_CN',
  'goog.i18n.NumberFormatSymbols_zh_HK',
  'goog.i18n.NumberFormatSymbols_zh_Hans_CN',
  'goog.i18n.NumberFormatSymbols_zh_TW',
  'goog.i18n.NumberFormatSymbols_zu',
  'goog.i18n.NumberFormatSymbols_zu_ZA'
], []);
goog.addDependency('i18n/numberformatsymbolsext.js', [
  'goog.i18n.NumberFormatSymbolsExt',
  'goog.i18n.NumberFormatSymbols_aa',
  'goog.i18n.NumberFormatSymbols_aa_DJ',
  'goog.i18n.NumberFormatSymbols_aa_ER',
  'goog.i18n.NumberFormatSymbols_aa_ET',
  'goog.i18n.NumberFormatSymbols_af_NA',
  'goog.i18n.NumberFormatSymbols_agq',
  'goog.i18n.NumberFormatSymbols_agq_CM',
  'goog.i18n.NumberFormatSymbols_ak',
  'goog.i18n.NumberFormatSymbols_ak_GH',
  'goog.i18n.NumberFormatSymbols_ar_AE',
  'goog.i18n.NumberFormatSymbols_ar_BH',
  'goog.i18n.NumberFormatSymbols_ar_DJ',
  'goog.i18n.NumberFormatSymbols_ar_DZ',
  'goog.i18n.NumberFormatSymbols_ar_EH',
  'goog.i18n.NumberFormatSymbols_ar_ER',
  'goog.i18n.NumberFormatSymbols_ar_IL',
  'goog.i18n.NumberFormatSymbols_ar_IQ',
  'goog.i18n.NumberFormatSymbols_ar_JO',
  'goog.i18n.NumberFormatSymbols_ar_KM',
  'goog.i18n.NumberFormatSymbols_ar_KW',
  'goog.i18n.NumberFormatSymbols_ar_LB',
  'goog.i18n.NumberFormatSymbols_ar_LY',
  'goog.i18n.NumberFormatSymbols_ar_MA',
  'goog.i18n.NumberFormatSymbols_ar_MR',
  'goog.i18n.NumberFormatSymbols_ar_OM',
  'goog.i18n.NumberFormatSymbols_ar_PS',
  'goog.i18n.NumberFormatSymbols_ar_QA',
  'goog.i18n.NumberFormatSymbols_ar_SA',
  'goog.i18n.NumberFormatSymbols_ar_SD',
  'goog.i18n.NumberFormatSymbols_ar_SO',
  'goog.i18n.NumberFormatSymbols_ar_SY',
  'goog.i18n.NumberFormatSymbols_ar_TD',
  'goog.i18n.NumberFormatSymbols_ar_TN',
  'goog.i18n.NumberFormatSymbols_ar_YE',
  'goog.i18n.NumberFormatSymbols_as',
  'goog.i18n.NumberFormatSymbols_as_IN',
  'goog.i18n.NumberFormatSymbols_asa',
  'goog.i18n.NumberFormatSymbols_asa_TZ',
  'goog.i18n.NumberFormatSymbols_ast',
  'goog.i18n.NumberFormatSymbols_ast_ES',
  'goog.i18n.NumberFormatSymbols_az',
  'goog.i18n.NumberFormatSymbols_az_Cyrl',
  'goog.i18n.NumberFormatSymbols_az_Cyrl_AZ',
  'goog.i18n.NumberFormatSymbols_az_Latn',
  'goog.i18n.NumberFormatSymbols_az_Latn_AZ',
  'goog.i18n.NumberFormatSymbols_bas',
  'goog.i18n.NumberFormatSymbols_bas_CM',
  'goog.i18n.NumberFormatSymbols_be',
  'goog.i18n.NumberFormatSymbols_be_BY',
  'goog.i18n.NumberFormatSymbols_bem',
  'goog.i18n.NumberFormatSymbols_bem_ZM',
  'goog.i18n.NumberFormatSymbols_bez',
  'goog.i18n.NumberFormatSymbols_bez_TZ',
  'goog.i18n.NumberFormatSymbols_bm',
  'goog.i18n.NumberFormatSymbols_bm_ML',
  'goog.i18n.NumberFormatSymbols_bn_IN',
  'goog.i18n.NumberFormatSymbols_bo',
  'goog.i18n.NumberFormatSymbols_bo_CN',
  'goog.i18n.NumberFormatSymbols_bo_IN',
  'goog.i18n.NumberFormatSymbols_brx',
  'goog.i18n.NumberFormatSymbols_brx_IN',
  'goog.i18n.NumberFormatSymbols_bs',
  'goog.i18n.NumberFormatSymbols_bs_Cyrl',
  'goog.i18n.NumberFormatSymbols_bs_Cyrl_BA',
  'goog.i18n.NumberFormatSymbols_bs_Latn',
  'goog.i18n.NumberFormatSymbols_bs_Latn_BA',
  'goog.i18n.NumberFormatSymbols_byn',
  'goog.i18n.NumberFormatSymbols_byn_ER',
  'goog.i18n.NumberFormatSymbols_cgg',
  'goog.i18n.NumberFormatSymbols_cgg_UG',
  'goog.i18n.NumberFormatSymbols_ckb',
  'goog.i18n.NumberFormatSymbols_ckb_Arab',
  'goog.i18n.NumberFormatSymbols_ckb_Arab_IQ',
  'goog.i18n.NumberFormatSymbols_ckb_Arab_IR',
  'goog.i18n.NumberFormatSymbols_ckb_IQ',
  'goog.i18n.NumberFormatSymbols_ckb_IR',
  'goog.i18n.NumberFormatSymbols_ckb_Latn',
  'goog.i18n.NumberFormatSymbols_ckb_Latn_IQ',
  'goog.i18n.NumberFormatSymbols_dav',
  'goog.i18n.NumberFormatSymbols_dav_KE',
  'goog.i18n.NumberFormatSymbols_de_LI',
  'goog.i18n.NumberFormatSymbols_dje',
  'goog.i18n.NumberFormatSymbols_dje_NE',
  'goog.i18n.NumberFormatSymbols_dua',
  'goog.i18n.NumberFormatSymbols_dua_CM',
  'goog.i18n.NumberFormatSymbols_dyo',
  'goog.i18n.NumberFormatSymbols_dyo_SN',
  'goog.i18n.NumberFormatSymbols_dz',
  'goog.i18n.NumberFormatSymbols_dz_BT',
  'goog.i18n.NumberFormatSymbols_ebu',
  'goog.i18n.NumberFormatSymbols_ebu_KE',
  'goog.i18n.NumberFormatSymbols_ee',
  'goog.i18n.NumberFormatSymbols_ee_GH',
  'goog.i18n.NumberFormatSymbols_ee_TG',
  'goog.i18n.NumberFormatSymbols_el_CY',
  'goog.i18n.NumberFormatSymbols_en_150',
  'goog.i18n.NumberFormatSymbols_en_AG',
  'goog.i18n.NumberFormatSymbols_en_BB',
  'goog.i18n.NumberFormatSymbols_en_BE',
  'goog.i18n.NumberFormatSymbols_en_BM',
  'goog.i18n.NumberFormatSymbols_en_BS',
  'goog.i18n.NumberFormatSymbols_en_BW',
  'goog.i18n.NumberFormatSymbols_en_BZ',
  'goog.i18n.NumberFormatSymbols_en_CA',
  'goog.i18n.NumberFormatSymbols_en_CM',
  'goog.i18n.NumberFormatSymbols_en_DM',
  'goog.i18n.NumberFormatSymbols_en_Dsrt',
  'goog.i18n.NumberFormatSymbols_en_FJ',
  'goog.i18n.NumberFormatSymbols_en_GD',
  'goog.i18n.NumberFormatSymbols_en_GG',
  'goog.i18n.NumberFormatSymbols_en_GH',
  'goog.i18n.NumberFormatSymbols_en_GI',
  'goog.i18n.NumberFormatSymbols_en_GM',
  'goog.i18n.NumberFormatSymbols_en_GY',
  'goog.i18n.NumberFormatSymbols_en_HK',
  'goog.i18n.NumberFormatSymbols_en_IM',
  'goog.i18n.NumberFormatSymbols_en_JE',
  'goog.i18n.NumberFormatSymbols_en_JM',
  'goog.i18n.NumberFormatSymbols_en_KE',
  'goog.i18n.NumberFormatSymbols_en_KI',
  'goog.i18n.NumberFormatSymbols_en_KN',
  'goog.i18n.NumberFormatSymbols_en_KY',
  'goog.i18n.NumberFormatSymbols_en_LC',
  'goog.i18n.NumberFormatSymbols_en_LR',
  'goog.i18n.NumberFormatSymbols_en_LS',
  'goog.i18n.NumberFormatSymbols_en_MG',
  'goog.i18n.NumberFormatSymbols_en_MT',
  'goog.i18n.NumberFormatSymbols_en_MU',
  'goog.i18n.NumberFormatSymbols_en_MW',
  'goog.i18n.NumberFormatSymbols_en_NA',
  'goog.i18n.NumberFormatSymbols_en_NG',
  'goog.i18n.NumberFormatSymbols_en_NZ',
  'goog.i18n.NumberFormatSymbols_en_PG',
  'goog.i18n.NumberFormatSymbols_en_PH',
  'goog.i18n.NumberFormatSymbols_en_PK',
  'goog.i18n.NumberFormatSymbols_en_SB',
  'goog.i18n.NumberFormatSymbols_en_SC',
  'goog.i18n.NumberFormatSymbols_en_SL',
  'goog.i18n.NumberFormatSymbols_en_SS',
  'goog.i18n.NumberFormatSymbols_en_SZ',
  'goog.i18n.NumberFormatSymbols_en_TO',
  'goog.i18n.NumberFormatSymbols_en_TT',
  'goog.i18n.NumberFormatSymbols_en_TZ',
  'goog.i18n.NumberFormatSymbols_en_UG',
  'goog.i18n.NumberFormatSymbols_en_VC',
  'goog.i18n.NumberFormatSymbols_en_VU',
  'goog.i18n.NumberFormatSymbols_en_WS',
  'goog.i18n.NumberFormatSymbols_en_ZM',
  'goog.i18n.NumberFormatSymbols_en_ZW',
  'goog.i18n.NumberFormatSymbols_eo',
  'goog.i18n.NumberFormatSymbols_es_AR',
  'goog.i18n.NumberFormatSymbols_es_BO',
  'goog.i18n.NumberFormatSymbols_es_CL',
  'goog.i18n.NumberFormatSymbols_es_CO',
  'goog.i18n.NumberFormatSymbols_es_CR',
  'goog.i18n.NumberFormatSymbols_es_CU',
  'goog.i18n.NumberFormatSymbols_es_DO',
  'goog.i18n.NumberFormatSymbols_es_EC',
  'goog.i18n.NumberFormatSymbols_es_GQ',
  'goog.i18n.NumberFormatSymbols_es_GT',
  'goog.i18n.NumberFormatSymbols_es_HN',
  'goog.i18n.NumberFormatSymbols_es_MX',
  'goog.i18n.NumberFormatSymbols_es_NI',
  'goog.i18n.NumberFormatSymbols_es_PA',
  'goog.i18n.NumberFormatSymbols_es_PE',
  'goog.i18n.NumberFormatSymbols_es_PH',
  'goog.i18n.NumberFormatSymbols_es_PR',
  'goog.i18n.NumberFormatSymbols_es_PY',
  'goog.i18n.NumberFormatSymbols_es_SV',
  'goog.i18n.NumberFormatSymbols_es_US',
  'goog.i18n.NumberFormatSymbols_es_UY',
  'goog.i18n.NumberFormatSymbols_es_VE',
  'goog.i18n.NumberFormatSymbols_ewo',
  'goog.i18n.NumberFormatSymbols_ewo_CM',
  'goog.i18n.NumberFormatSymbols_fa_AF',
  'goog.i18n.NumberFormatSymbols_ff',
  'goog.i18n.NumberFormatSymbols_ff_SN',
  'goog.i18n.NumberFormatSymbols_fo',
  'goog.i18n.NumberFormatSymbols_fo_FO',
  'goog.i18n.NumberFormatSymbols_fr_BE',
  'goog.i18n.NumberFormatSymbols_fr_BF',
  'goog.i18n.NumberFormatSymbols_fr_BI',
  'goog.i18n.NumberFormatSymbols_fr_BJ',
  'goog.i18n.NumberFormatSymbols_fr_CD',
  'goog.i18n.NumberFormatSymbols_fr_CF',
  'goog.i18n.NumberFormatSymbols_fr_CG',
  'goog.i18n.NumberFormatSymbols_fr_CH',
  'goog.i18n.NumberFormatSymbols_fr_CI',
  'goog.i18n.NumberFormatSymbols_fr_CM',
  'goog.i18n.NumberFormatSymbols_fr_DJ',
  'goog.i18n.NumberFormatSymbols_fr_DZ',
  'goog.i18n.NumberFormatSymbols_fr_GA',
  'goog.i18n.NumberFormatSymbols_fr_GN',
  'goog.i18n.NumberFormatSymbols_fr_GQ',
  'goog.i18n.NumberFormatSymbols_fr_HT',
  'goog.i18n.NumberFormatSymbols_fr_KM',
  'goog.i18n.NumberFormatSymbols_fr_LU',
  'goog.i18n.NumberFormatSymbols_fr_MA',
  'goog.i18n.NumberFormatSymbols_fr_MG',
  'goog.i18n.NumberFormatSymbols_fr_ML',
  'goog.i18n.NumberFormatSymbols_fr_MR',
  'goog.i18n.NumberFormatSymbols_fr_MU',
  'goog.i18n.NumberFormatSymbols_fr_NC',
  'goog.i18n.NumberFormatSymbols_fr_NE',
  'goog.i18n.NumberFormatSymbols_fr_PF',
  'goog.i18n.NumberFormatSymbols_fr_RW',
  'goog.i18n.NumberFormatSymbols_fr_SC',
  'goog.i18n.NumberFormatSymbols_fr_SN',
  'goog.i18n.NumberFormatSymbols_fr_SY',
  'goog.i18n.NumberFormatSymbols_fr_TD',
  'goog.i18n.NumberFormatSymbols_fr_TG',
  'goog.i18n.NumberFormatSymbols_fr_TN',
  'goog.i18n.NumberFormatSymbols_fr_VU',
  'goog.i18n.NumberFormatSymbols_fur',
  'goog.i18n.NumberFormatSymbols_fur_IT',
  'goog.i18n.NumberFormatSymbols_ga',
  'goog.i18n.NumberFormatSymbols_ga_IE',
  'goog.i18n.NumberFormatSymbols_gd',
  'goog.i18n.NumberFormatSymbols_gd_GB',
  'goog.i18n.NumberFormatSymbols_guz',
  'goog.i18n.NumberFormatSymbols_guz_KE',
  'goog.i18n.NumberFormatSymbols_gv',
  'goog.i18n.NumberFormatSymbols_gv_GB',
  'goog.i18n.NumberFormatSymbols_ha',
  'goog.i18n.NumberFormatSymbols_ha_Latn',
  'goog.i18n.NumberFormatSymbols_ha_Latn_GH',
  'goog.i18n.NumberFormatSymbols_ha_Latn_NE',
  'goog.i18n.NumberFormatSymbols_ha_Latn_NG',
  'goog.i18n.NumberFormatSymbols_hr_BA',
  'goog.i18n.NumberFormatSymbols_hy',
  'goog.i18n.NumberFormatSymbols_hy_AM',
  'goog.i18n.NumberFormatSymbols_ia',
  'goog.i18n.NumberFormatSymbols_ia_FR',
  'goog.i18n.NumberFormatSymbols_ig',
  'goog.i18n.NumberFormatSymbols_ig_NG',
  'goog.i18n.NumberFormatSymbols_ii',
  'goog.i18n.NumberFormatSymbols_ii_CN',
  'goog.i18n.NumberFormatSymbols_it_CH',
  'goog.i18n.NumberFormatSymbols_jgo',
  'goog.i18n.NumberFormatSymbols_jgo_CM',
  'goog.i18n.NumberFormatSymbols_jmc',
  'goog.i18n.NumberFormatSymbols_jmc_TZ',
  'goog.i18n.NumberFormatSymbols_ka',
  'goog.i18n.NumberFormatSymbols_ka_GE',
  'goog.i18n.NumberFormatSymbols_kab',
  'goog.i18n.NumberFormatSymbols_kab_DZ',
  'goog.i18n.NumberFormatSymbols_kam',
  'goog.i18n.NumberFormatSymbols_kam_KE',
  'goog.i18n.NumberFormatSymbols_kde',
  'goog.i18n.NumberFormatSymbols_kde_TZ',
  'goog.i18n.NumberFormatSymbols_kea',
  'goog.i18n.NumberFormatSymbols_kea_CV',
  'goog.i18n.NumberFormatSymbols_khq',
  'goog.i18n.NumberFormatSymbols_khq_ML',
  'goog.i18n.NumberFormatSymbols_ki',
  'goog.i18n.NumberFormatSymbols_ki_KE',
  'goog.i18n.NumberFormatSymbols_kk',
  'goog.i18n.NumberFormatSymbols_kk_Cyrl',
  'goog.i18n.NumberFormatSymbols_kk_Cyrl_KZ',
  'goog.i18n.NumberFormatSymbols_kkj',
  'goog.i18n.NumberFormatSymbols_kkj_CM',
  'goog.i18n.NumberFormatSymbols_kl',
  'goog.i18n.NumberFormatSymbols_kl_GL',
  'goog.i18n.NumberFormatSymbols_kln',
  'goog.i18n.NumberFormatSymbols_kln_KE',
  'goog.i18n.NumberFormatSymbols_km',
  'goog.i18n.NumberFormatSymbols_km_KH',
  'goog.i18n.NumberFormatSymbols_ko_KP',
  'goog.i18n.NumberFormatSymbols_kok',
  'goog.i18n.NumberFormatSymbols_kok_IN',
  'goog.i18n.NumberFormatSymbols_ks',
  'goog.i18n.NumberFormatSymbols_ks_Arab',
  'goog.i18n.NumberFormatSymbols_ks_Arab_IN',
  'goog.i18n.NumberFormatSymbols_ksb',
  'goog.i18n.NumberFormatSymbols_ksb_TZ',
  'goog.i18n.NumberFormatSymbols_ksf',
  'goog.i18n.NumberFormatSymbols_ksf_CM',
  'goog.i18n.NumberFormatSymbols_ksh',
  'goog.i18n.NumberFormatSymbols_ksh_DE',
  'goog.i18n.NumberFormatSymbols_kw',
  'goog.i18n.NumberFormatSymbols_kw_GB',
  'goog.i18n.NumberFormatSymbols_ky',
  'goog.i18n.NumberFormatSymbols_ky_KG',
  'goog.i18n.NumberFormatSymbols_lag',
  'goog.i18n.NumberFormatSymbols_lag_TZ',
  'goog.i18n.NumberFormatSymbols_lg',
  'goog.i18n.NumberFormatSymbols_lg_UG',
  'goog.i18n.NumberFormatSymbols_ln_AO',
  'goog.i18n.NumberFormatSymbols_ln_CF',
  'goog.i18n.NumberFormatSymbols_ln_CG',
  'goog.i18n.NumberFormatSymbols_lo',
  'goog.i18n.NumberFormatSymbols_lo_LA',
  'goog.i18n.NumberFormatSymbols_lu',
  'goog.i18n.NumberFormatSymbols_lu_CD',
  'goog.i18n.NumberFormatSymbols_luo',
  'goog.i18n.NumberFormatSymbols_luo_KE',
  'goog.i18n.NumberFormatSymbols_luy',
  'goog.i18n.NumberFormatSymbols_luy_KE',
  'goog.i18n.NumberFormatSymbols_mas',
  'goog.i18n.NumberFormatSymbols_mas_KE',
  'goog.i18n.NumberFormatSymbols_mas_TZ',
  'goog.i18n.NumberFormatSymbols_mer',
  'goog.i18n.NumberFormatSymbols_mer_KE',
  'goog.i18n.NumberFormatSymbols_mfe',
  'goog.i18n.NumberFormatSymbols_mfe_MU',
  'goog.i18n.NumberFormatSymbols_mg',
  'goog.i18n.NumberFormatSymbols_mg_MG',
  'goog.i18n.NumberFormatSymbols_mgh',
  'goog.i18n.NumberFormatSymbols_mgh_MZ',
  'goog.i18n.NumberFormatSymbols_mgo',
  'goog.i18n.NumberFormatSymbols_mgo_CM',
  'goog.i18n.NumberFormatSymbols_mk',
  'goog.i18n.NumberFormatSymbols_mk_MK',
  'goog.i18n.NumberFormatSymbols_mn',
  'goog.i18n.NumberFormatSymbols_mn_Cyrl',
  'goog.i18n.NumberFormatSymbols_mn_Cyrl_MN',
  'goog.i18n.NumberFormatSymbols_ms_Latn',
  'goog.i18n.NumberFormatSymbols_ms_Latn_BN',
  'goog.i18n.NumberFormatSymbols_ms_Latn_SG',
  'goog.i18n.NumberFormatSymbols_mua',
  'goog.i18n.NumberFormatSymbols_mua_CM',
  'goog.i18n.NumberFormatSymbols_my',
  'goog.i18n.NumberFormatSymbols_my_MM',
  'goog.i18n.NumberFormatSymbols_naq',
  'goog.i18n.NumberFormatSymbols_naq_NA',
  'goog.i18n.NumberFormatSymbols_nd',
  'goog.i18n.NumberFormatSymbols_nd_ZW',
  'goog.i18n.NumberFormatSymbols_ne',
  'goog.i18n.NumberFormatSymbols_ne_IN',
  'goog.i18n.NumberFormatSymbols_ne_NP',
  'goog.i18n.NumberFormatSymbols_nl_AW',
  'goog.i18n.NumberFormatSymbols_nl_BE',
  'goog.i18n.NumberFormatSymbols_nl_CW',
  'goog.i18n.NumberFormatSymbols_nl_SR',
  'goog.i18n.NumberFormatSymbols_nl_SX',
  'goog.i18n.NumberFormatSymbols_nmg',
  'goog.i18n.NumberFormatSymbols_nmg_CM',
  'goog.i18n.NumberFormatSymbols_nn',
  'goog.i18n.NumberFormatSymbols_nn_NO',
  'goog.i18n.NumberFormatSymbols_nnh',
  'goog.i18n.NumberFormatSymbols_nnh_CM',
  'goog.i18n.NumberFormatSymbols_nr',
  'goog.i18n.NumberFormatSymbols_nr_ZA',
  'goog.i18n.NumberFormatSymbols_nso',
  'goog.i18n.NumberFormatSymbols_nso_ZA',
  'goog.i18n.NumberFormatSymbols_nus',
  'goog.i18n.NumberFormatSymbols_nus_SD',
  'goog.i18n.NumberFormatSymbols_nyn',
  'goog.i18n.NumberFormatSymbols_nyn_UG',
  'goog.i18n.NumberFormatSymbols_om',
  'goog.i18n.NumberFormatSymbols_om_ET',
  'goog.i18n.NumberFormatSymbols_om_KE',
  'goog.i18n.NumberFormatSymbols_os',
  'goog.i18n.NumberFormatSymbols_os_GE',
  'goog.i18n.NumberFormatSymbols_os_RU',
  'goog.i18n.NumberFormatSymbols_pa',
  'goog.i18n.NumberFormatSymbols_pa_Arab',
  'goog.i18n.NumberFormatSymbols_pa_Arab_PK',
  'goog.i18n.NumberFormatSymbols_pa_Guru',
  'goog.i18n.NumberFormatSymbols_pa_Guru_IN',
  'goog.i18n.NumberFormatSymbols_ps',
  'goog.i18n.NumberFormatSymbols_ps_AF',
  'goog.i18n.NumberFormatSymbols_pt_AO',
  'goog.i18n.NumberFormatSymbols_pt_CV',
  'goog.i18n.NumberFormatSymbols_pt_GW',
  'goog.i18n.NumberFormatSymbols_pt_MO',
  'goog.i18n.NumberFormatSymbols_pt_MZ',
  'goog.i18n.NumberFormatSymbols_pt_ST',
  'goog.i18n.NumberFormatSymbols_pt_TL',
  'goog.i18n.NumberFormatSymbols_rm',
  'goog.i18n.NumberFormatSymbols_rm_CH',
  'goog.i18n.NumberFormatSymbols_rn',
  'goog.i18n.NumberFormatSymbols_rn_BI',
  'goog.i18n.NumberFormatSymbols_ro_MD',
  'goog.i18n.NumberFormatSymbols_rof',
  'goog.i18n.NumberFormatSymbols_rof_TZ',
  'goog.i18n.NumberFormatSymbols_ru_BY',
  'goog.i18n.NumberFormatSymbols_ru_KG',
  'goog.i18n.NumberFormatSymbols_ru_KZ',
  'goog.i18n.NumberFormatSymbols_ru_MD',
  'goog.i18n.NumberFormatSymbols_ru_UA',
  'goog.i18n.NumberFormatSymbols_rw',
  'goog.i18n.NumberFormatSymbols_rw_RW',
  'goog.i18n.NumberFormatSymbols_rwk',
  'goog.i18n.NumberFormatSymbols_rwk_TZ',
  'goog.i18n.NumberFormatSymbols_sah',
  'goog.i18n.NumberFormatSymbols_sah_RU',
  'goog.i18n.NumberFormatSymbols_saq',
  'goog.i18n.NumberFormatSymbols_saq_KE',
  'goog.i18n.NumberFormatSymbols_sbp',
  'goog.i18n.NumberFormatSymbols_sbp_TZ',
  'goog.i18n.NumberFormatSymbols_se',
  'goog.i18n.NumberFormatSymbols_se_FI',
  'goog.i18n.NumberFormatSymbols_se_NO',
  'goog.i18n.NumberFormatSymbols_seh',
  'goog.i18n.NumberFormatSymbols_seh_MZ',
  'goog.i18n.NumberFormatSymbols_ses',
  'goog.i18n.NumberFormatSymbols_ses_ML',
  'goog.i18n.NumberFormatSymbols_sg',
  'goog.i18n.NumberFormatSymbols_sg_CF',
  'goog.i18n.NumberFormatSymbols_shi',
  'goog.i18n.NumberFormatSymbols_shi_Latn',
  'goog.i18n.NumberFormatSymbols_shi_Latn_MA',
  'goog.i18n.NumberFormatSymbols_shi_Tfng',
  'goog.i18n.NumberFormatSymbols_shi_Tfng_MA',
  'goog.i18n.NumberFormatSymbols_si',
  'goog.i18n.NumberFormatSymbols_si_LK',
  'goog.i18n.NumberFormatSymbols_sn',
  'goog.i18n.NumberFormatSymbols_sn_ZW',
  'goog.i18n.NumberFormatSymbols_so',
  'goog.i18n.NumberFormatSymbols_so_DJ',
  'goog.i18n.NumberFormatSymbols_so_ET',
  'goog.i18n.NumberFormatSymbols_so_KE',
  'goog.i18n.NumberFormatSymbols_so_SO',
  'goog.i18n.NumberFormatSymbols_sq_MK',
  'goog.i18n.NumberFormatSymbols_sq_XK',
  'goog.i18n.NumberFormatSymbols_sr_Cyrl',
  'goog.i18n.NumberFormatSymbols_sr_Cyrl_BA',
  'goog.i18n.NumberFormatSymbols_sr_Cyrl_ME',
  'goog.i18n.NumberFormatSymbols_sr_Cyrl_XK',
  'goog.i18n.NumberFormatSymbols_sr_Latn',
  'goog.i18n.NumberFormatSymbols_sr_Latn_BA',
  'goog.i18n.NumberFormatSymbols_sr_Latn_ME',
  'goog.i18n.NumberFormatSymbols_sr_Latn_RS',
  'goog.i18n.NumberFormatSymbols_sr_Latn_XK',
  'goog.i18n.NumberFormatSymbols_ss',
  'goog.i18n.NumberFormatSymbols_ss_SZ',
  'goog.i18n.NumberFormatSymbols_ss_ZA',
  'goog.i18n.NumberFormatSymbols_ssy',
  'goog.i18n.NumberFormatSymbols_ssy_ER',
  'goog.i18n.NumberFormatSymbols_st',
  'goog.i18n.NumberFormatSymbols_st_LS',
  'goog.i18n.NumberFormatSymbols_st_ZA',
  'goog.i18n.NumberFormatSymbols_sv_AX',
  'goog.i18n.NumberFormatSymbols_sv_FI',
  'goog.i18n.NumberFormatSymbols_sw_KE',
  'goog.i18n.NumberFormatSymbols_sw_UG',
  'goog.i18n.NumberFormatSymbols_swc',
  'goog.i18n.NumberFormatSymbols_swc_CD',
  'goog.i18n.NumberFormatSymbols_ta_LK',
  'goog.i18n.NumberFormatSymbols_ta_MY',
  'goog.i18n.NumberFormatSymbols_ta_SG',
  'goog.i18n.NumberFormatSymbols_teo',
  'goog.i18n.NumberFormatSymbols_teo_KE',
  'goog.i18n.NumberFormatSymbols_teo_UG',
  'goog.i18n.NumberFormatSymbols_tg',
  'goog.i18n.NumberFormatSymbols_tg_Cyrl',
  'goog.i18n.NumberFormatSymbols_tg_Cyrl_TJ',
  'goog.i18n.NumberFormatSymbols_ti',
  'goog.i18n.NumberFormatSymbols_ti_ER',
  'goog.i18n.NumberFormatSymbols_ti_ET',
  'goog.i18n.NumberFormatSymbols_tig',
  'goog.i18n.NumberFormatSymbols_tig_ER',
  'goog.i18n.NumberFormatSymbols_tn',
  'goog.i18n.NumberFormatSymbols_tn_BW',
  'goog.i18n.NumberFormatSymbols_tn_ZA',
  'goog.i18n.NumberFormatSymbols_to',
  'goog.i18n.NumberFormatSymbols_to_TO',
  'goog.i18n.NumberFormatSymbols_tr_CY',
  'goog.i18n.NumberFormatSymbols_ts',
  'goog.i18n.NumberFormatSymbols_ts_ZA',
  'goog.i18n.NumberFormatSymbols_twq',
  'goog.i18n.NumberFormatSymbols_twq_NE',
  'goog.i18n.NumberFormatSymbols_tzm',
  'goog.i18n.NumberFormatSymbols_tzm_Latn',
  'goog.i18n.NumberFormatSymbols_tzm_Latn_MA',
  'goog.i18n.NumberFormatSymbols_ur_IN',
  'goog.i18n.NumberFormatSymbols_uz',
  'goog.i18n.NumberFormatSymbols_uz_Arab',
  'goog.i18n.NumberFormatSymbols_uz_Arab_AF',
  'goog.i18n.NumberFormatSymbols_uz_Cyrl',
  'goog.i18n.NumberFormatSymbols_uz_Cyrl_UZ',
  'goog.i18n.NumberFormatSymbols_uz_Latn',
  'goog.i18n.NumberFormatSymbols_uz_Latn_UZ',
  'goog.i18n.NumberFormatSymbols_vai',
  'goog.i18n.NumberFormatSymbols_vai_Latn',
  'goog.i18n.NumberFormatSymbols_vai_Latn_LR',
  'goog.i18n.NumberFormatSymbols_vai_Vaii',
  'goog.i18n.NumberFormatSymbols_vai_Vaii_LR',
  'goog.i18n.NumberFormatSymbols_ve',
  'goog.i18n.NumberFormatSymbols_ve_ZA',
  'goog.i18n.NumberFormatSymbols_vo',
  'goog.i18n.NumberFormatSymbols_vun',
  'goog.i18n.NumberFormatSymbols_vun_TZ',
  'goog.i18n.NumberFormatSymbols_wae',
  'goog.i18n.NumberFormatSymbols_wae_CH',
  'goog.i18n.NumberFormatSymbols_wal',
  'goog.i18n.NumberFormatSymbols_wal_ET',
  'goog.i18n.NumberFormatSymbols_xh',
  'goog.i18n.NumberFormatSymbols_xh_ZA',
  'goog.i18n.NumberFormatSymbols_xog',
  'goog.i18n.NumberFormatSymbols_xog_UG',
  'goog.i18n.NumberFormatSymbols_yav',
  'goog.i18n.NumberFormatSymbols_yav_CM',
  'goog.i18n.NumberFormatSymbols_yo',
  'goog.i18n.NumberFormatSymbols_yo_NG',
  'goog.i18n.NumberFormatSymbols_zh_Hans',
  'goog.i18n.NumberFormatSymbols_zh_Hans_HK',
  'goog.i18n.NumberFormatSymbols_zh_Hans_MO',
  'goog.i18n.NumberFormatSymbols_zh_Hans_SG',
  'goog.i18n.NumberFormatSymbols_zh_Hant',
  'goog.i18n.NumberFormatSymbols_zh_Hant_HK',
  'goog.i18n.NumberFormatSymbols_zh_Hant_MO',
  'goog.i18n.NumberFormatSymbols_zh_Hant_TW'
], ['goog.i18n.NumberFormatSymbols']);
goog.addDependency('i18n/ordinalrules.js', ['goog.i18n.ordinalRules'], []);
goog.addDependency('i18n/pluralrules.js', ['goog.i18n.pluralRules'], []);
goog.addDependency('i18n/timezone.js', ['goog.i18n.TimeZone'], [
  'goog.array',
  'goog.date.DateLike',
  'goog.string'
]);
goog.addDependency('i18n/uchar.js', ['goog.i18n.uChar'], []);
goog.addDependency('i18n/uchar/localnamefetcher.js', ['goog.i18n.uChar.LocalNameFetcher'], [
  'goog.i18n.uChar',
  'goog.i18n.uChar.NameFetcher',
  'goog.log'
]);
goog.addDependency('i18n/uchar/namefetcher.js', ['goog.i18n.uChar.NameFetcher'], []);
goog.addDependency('i18n/uchar/remotenamefetcher.js', ['goog.i18n.uChar.RemoteNameFetcher'], [
  'goog.Disposable',
  'goog.Uri',
  'goog.i18n.uChar',
  'goog.i18n.uChar.NameFetcher',
  'goog.log',
  'goog.net.XhrIo',
  'goog.structs.Map'
]);
goog.addDependency('iter/iter.js', [
  'goog.iter',
  'goog.iter.Iterator',
  'goog.iter.StopIteration'
], [
  'goog.array',
  'goog.asserts'
]);
goog.addDependency('json/evaljsonprocessor.js', ['goog.json.EvalJsonProcessor'], [
  'goog.json',
  'goog.json.Processor',
  'goog.json.Serializer'
]);
goog.addDependency('json/json.js', [
  'goog.json',
  'goog.json.Serializer'
], []);
goog.addDependency('json/nativejsonprocessor.js', ['goog.json.NativeJsonProcessor'], [
  'goog.asserts',
  'goog.json',
  'goog.json.Processor'
]);
goog.addDependency('json/processor.js', ['goog.json.Processor'], [
  'goog.string.Parser',
  'goog.string.Stringifier'
]);
goog.addDependency('labs/classdef/classdef.js', ['goog.labs.classdef'], []);
goog.addDependency('labs/events/touch.js', [
  'goog.labs.events.touch',
  'goog.labs.events.touch.TouchData'
], [
  'goog.array',
  'goog.asserts',
  'goog.events.EventType',
  'goog.string'
]);
goog.addDependency('labs/events/touch_test.js', ['goog.labs.events.touchTest'], [
  'goog.labs.events.touch',
  'goog.testing.jsunit'
]);
goog.addDependency('labs/format/csv.js', [
  'goog.labs.format.csv',
  'goog.labs.format.csv.ParseError',
  'goog.labs.format.csv.Token'
], [
  'goog.array',
  'goog.asserts',
  'goog.debug.Error',
  'goog.object',
  'goog.string',
  'goog.string.newlines'
]);
goog.addDependency('labs/format/csv_test.js', ['goog.labs.format.csvTest'], [
  'goog.labs.format.csv',
  'goog.labs.format.csv.ParseError',
  'goog.object',
  'goog.testing.asserts',
  'goog.testing.jsunit'
]);
goog.addDependency('labs/mock/mock.js', ['goog.labs.mock'], [
  'goog.array',
  'goog.debug',
  'goog.debug.Error',
  'goog.functions',
  'goog.json'
]);
goog.addDependency('labs/net/image.js', ['goog.labs.net.image'], [
  'goog.events.EventHandler',
  'goog.events.EventType',
  'goog.net.EventType',
  'goog.result.SimpleResult',
  'goog.userAgent'
]);
goog.addDependency('labs/net/image_test.js', ['goog.labs.net.imageTest'], [
  'goog.events',
  'goog.labs.net.image',
  'goog.result',
  'goog.result.Result',
  'goog.string',
  'goog.testing.AsyncTestCase',
  'goog.testing.jsunit',
  'goog.testing.recordFunction'
]);
goog.addDependency('labs/net/webchannel.js', ['goog.net.WebChannel'], [
  'goog.events',
  'goog.events.Event'
]);
goog.addDependency('labs/net/webchannel/basetestchannel.js', ['goog.labs.net.webChannel.BaseTestChannel'], [
  'goog.json.EvalJsonProcessor',
  'goog.labs.net.webChannel.Channel',
  'goog.labs.net.webChannel.WebChannelRequest',
  'goog.labs.net.webChannel.requestStats',
  'goog.labs.net.webChannel.requestStats.ServerReachability',
  'goog.labs.net.webChannel.requestStats.Stat',
  'goog.net.tmpnetwork'
]);
goog.addDependency('labs/net/webchannel/channel.js', ['goog.labs.net.webChannel.Channel'], []);
goog.addDependency('labs/net/webchannel/requeststats.js', [
  'goog.labs.net.webChannel.requestStats',
  'goog.labs.net.webChannel.requestStats.Event',
  'goog.labs.net.webChannel.requestStats.ServerReachability',
  'goog.labs.net.webChannel.requestStats.ServerReachabilityEvent',
  'goog.labs.net.webChannel.requestStats.Stat',
  'goog.labs.net.webChannel.requestStats.StatEvent',
  'goog.labs.net.webChannel.requestStats.TimingEvent'
], [
  'goog.events.Event',
  'goog.events.EventTarget'
]);
goog.addDependency('labs/net/webchannel/webchannelbase.js', ['goog.labs.net.webChannel.WebChannelBase'], [
  'goog.Uri',
  'goog.array',
  'goog.asserts',
  'goog.debug.TextFormatter',
  'goog.json',
  'goog.json.EvalJsonProcessor',
  'goog.labs.net.webChannel.BaseTestChannel',
  'goog.labs.net.webChannel.Channel',
  'goog.labs.net.webChannel.WebChannelDebug',
  'goog.labs.net.webChannel.WebChannelRequest',
  'goog.labs.net.webChannel.requestStats',
  'goog.labs.net.webChannel.requestStats.Stat',
  'goog.log',
  'goog.net.XhrIo',
  'goog.net.tmpnetwork',
  'goog.string',
  'goog.structs',
  'goog.structs.CircularBuffer'
]);
goog.addDependency('labs/net/webchannel/webchannelbase_test.js', ['goog.labs.net.webChannel.webChannelBaseTest'], [
  'goog.Timer',
  'goog.array',
  'goog.dom',
  'goog.functions',
  'goog.json',
  'goog.labs.net.webChannel.WebChannelBase',
  'goog.labs.net.webChannel.WebChannelDebug',
  'goog.labs.net.webChannel.WebChannelRequest',
  'goog.labs.net.webChannel.requestStats',
  'goog.labs.net.webChannel.requestStats.Stat',
  'goog.net.tmpnetwork',
  'goog.structs.Map',
  'goog.testing.MockClock',
  'goog.testing.PropertyReplacer',
  'goog.testing.asserts',
  'goog.testing.jsunit',
  'goog.testing.recordFunction'
]);
goog.addDependency('labs/net/webchannel/webchannelbasetransport.js', ['goog.labs.net.webChannel.WebChannelBaseTransport'], [
  'goog.asserts',
  'goog.events.EventTarget',
  'goog.labs.net.webChannel.WebChannelBase',
  'goog.log',
  'goog.net.WebChannel',
  'goog.net.WebChannelTransport',
  'goog.string.path'
]);
goog.addDependency('labs/net/webchannel/webchanneldebug.js', ['goog.labs.net.webChannel.WebChannelDebug'], [
  'goog.json',
  'goog.log'
]);
goog.addDependency('labs/net/webchannel/webchannelrequest.js', ['goog.labs.net.webChannel.WebChannelRequest'], [
  'goog.Timer',
  'goog.async.Throttle',
  'goog.events.EventHandler',
  'goog.labs.net.webChannel.requestStats',
  'goog.labs.net.webChannel.requestStats.ServerReachability',
  'goog.labs.net.webChannel.requestStats.Stat',
  'goog.net.ErrorCode',
  'goog.net.EventType',
  'goog.net.XmlHttp',
  'goog.object',
  'goog.userAgent'
]);
goog.addDependency('labs/net/webchanneltransport.js', ['goog.net.WebChannelTransport'], []);
goog.addDependency('labs/net/webchanneltransportfactory.js', ['goog.net.createWebChannelTransport'], [
  'goog.functions',
  'goog.labs.net.webChannel.WebChannelBaseTransport'
]);
goog.addDependency('labs/net/xhr.js', [
  'goog.labs.net.xhr',
  'goog.labs.net.xhr.Error',
  'goog.labs.net.xhr.HttpError',
  'goog.labs.net.xhr.TimeoutError'
], [
  'goog.debug.Error',
  'goog.json',
  'goog.net.HttpStatus',
  'goog.net.XmlHttp',
  'goog.result',
  'goog.result.SimpleResult',
  'goog.string',
  'goog.uri.utils'
]);
goog.addDependency('labs/object/object.js', ['goog.labs.object'], []);
goog.addDependency('labs/observe/notice.js', ['goog.labs.observe.Notice'], []);
goog.addDependency('labs/observe/observable.js', ['goog.labs.observe.Observable'], ['goog.disposable.IDisposable']);
goog.addDependency('labs/observe/observableset.js', ['goog.labs.observe.ObservableSet'], [
  'goog.array',
  'goog.labs.observe.Observer'
]);
goog.addDependency('labs/observe/observationset.js', ['goog.labs.observe.ObservationSet'], [
  'goog.array',
  'goog.labs.observe.Observer'
]);
goog.addDependency('labs/observe/observer.js', ['goog.labs.observe.Observer'], []);
goog.addDependency('labs/observe/simpleobservable.js', ['goog.labs.observe.SimpleObservable'], [
  'goog.Disposable',
  'goog.array',
  'goog.asserts',
  'goog.labs.observe.Notice',
  'goog.labs.observe.Observable',
  'goog.labs.observe.Observer',
  'goog.object'
]);
goog.addDependency('labs/structs/map.js', ['goog.labs.structs.Map'], [
  'goog.array',
  'goog.asserts',
  'goog.labs.object',
  'goog.object'
]);
goog.addDependency('labs/structs/map_perf.js', ['goog.labs.structs.mapPerf'], [
  'goog.dom',
  'goog.labs.structs.Map',
  'goog.structs.Map',
  'goog.testing.PerformanceTable',
  'goog.testing.jsunit'
]);
goog.addDependency('labs/structs/multimap.js', ['goog.labs.structs.Multimap'], [
  'goog.array',
  'goog.labs.object',
  'goog.labs.structs.Map'
]);
goog.addDependency('labs/style/pixeldensitymonitor.js', [
  'goog.labs.style.PixelDensityMonitor',
  'goog.labs.style.PixelDensityMonitor.Density',
  'goog.labs.style.PixelDensityMonitor.EventType'
], [
  'goog.events',
  'goog.events.EventTarget'
]);
goog.addDependency('labs/style/pixeldensitymonitor_test.js', ['goog.labs.style.PixelDensityMonitorTest'], [
  'goog.array',
  'goog.dom.DomHelper',
  'goog.events',
  'goog.labs.style.PixelDensityMonitor',
  'goog.testing.MockControl',
  'goog.testing.jsunit',
  'goog.testing.recordFunction'
]);
goog.addDependency('labs/testing/assertthat.js', [
  'goog.labs.testing.MatcherError',
  'goog.labs.testing.assertThat'
], [
  'goog.asserts',
  'goog.debug.Error',
  'goog.labs.testing.Matcher'
]);
goog.addDependency('labs/testing/decoratormatcher.js', ['goog.labs.testing.AnythingMatcher'], ['goog.labs.testing.Matcher']);
goog.addDependency('labs/testing/dictionarymatcher.js', [
  'goog.labs.testing.HasEntriesMatcher',
  'goog.labs.testing.HasEntryMatcher',
  'goog.labs.testing.HasKeyMatcher',
  'goog.labs.testing.HasValueMatcher'
], [
  'goog.array',
  'goog.asserts',
  'goog.labs.testing.Matcher',
  'goog.string'
]);
goog.addDependency('labs/testing/logicmatcher.js', [
  'goog.labs.testing.AllOfMatcher',
  'goog.labs.testing.AnyOfMatcher',
  'goog.labs.testing.IsNotMatcher'
], [
  'goog.array',
  'goog.labs.testing.Matcher'
]);
goog.addDependency('labs/testing/matcher.js', ['goog.labs.testing.Matcher'], []);
goog.addDependency('labs/testing/numbermatcher.js', [
  'goog.labs.testing.CloseToMatcher',
  'goog.labs.testing.EqualToMatcher',
  'goog.labs.testing.GreaterThanEqualToMatcher',
  'goog.labs.testing.GreaterThanMatcher',
  'goog.labs.testing.LessThanEqualToMatcher',
  'goog.labs.testing.LessThanMatcher'
], [
  'goog.asserts',
  'goog.labs.testing.Matcher'
]);
goog.addDependency('labs/testing/objectmatcher.js', [
  'goog.labs.testing.HasPropertyMatcher',
  'goog.labs.testing.InstanceOfMatcher',
  'goog.labs.testing.IsNullMatcher',
  'goog.labs.testing.IsNullOrUndefinedMatcher',
  'goog.labs.testing.IsUndefinedMatcher',
  'goog.labs.testing.ObjectEqualsMatcher'
], [
  'goog.labs.testing.Matcher',
  'goog.string'
]);
goog.addDependency('labs/testing/stringmatcher.js', [
  'goog.labs.testing.ContainsStringMatcher',
  'goog.labs.testing.EndsWithMatcher',
  'goog.labs.testing.EqualToIgnoringCaseMatcher',
  'goog.labs.testing.EqualToIgnoringWhitespaceMatcher',
  'goog.labs.testing.EqualsMatcher',
  'goog.labs.testing.RegexMatcher',
  'goog.labs.testing.StartsWithMatcher',
  'goog.labs.testing.StringContainsInOrderMatcher'
], [
  'goog.asserts',
  'goog.labs.testing.Matcher',
  'goog.string'
]);
goog.addDependency('labs/useragent/browser.js', ['goog.labs.userAgent.browser'], [
  'goog.asserts',
  'goog.labs.userAgent.util',
  'goog.memoize',
  'goog.string'
]);
goog.addDependency('labs/useragent/browser_test.js', ['goog.labs.userAgent.browserTest'], [
  'goog.labs.userAgent.browser',
  'goog.labs.userAgent.testAgents',
  'goog.testing.PropertyReplacer',
  'goog.testing.jsunit'
]);
goog.addDependency('labs/useragent/device.js', ['goog.labs.userAgent.device'], ['goog.labs.userAgent.util']);
goog.addDependency('labs/useragent/device_test.js', ['goog.labs.userAgent.deviceTest'], [
  'goog.labs.userAgent.device',
  'goog.labs.userAgent.testAgents',
  'goog.testing.PropertyReplacer',
  'goog.testing.jsunit'
]);
goog.addDependency('labs/useragent/engine.js', ['goog.labs.userAgent.engine'], [
  'goog.array',
  'goog.labs.userAgent.util',
  'goog.memoize',
  'goog.string'
]);
goog.addDependency('labs/useragent/engine_test.js', ['goog.labs.userAgent.engineTest'], [
  'goog.labs.userAgent.engine',
  'goog.labs.userAgent.testAgents',
  'goog.testing.PropertyReplacer',
  'goog.testing.jsunit'
]);
goog.addDependency('labs/useragent/platform.js', ['goog.labs.userAgent.platform'], [
  'goog.labs.userAgent.util',
  'goog.memoize',
  'goog.string'
]);
goog.addDependency('labs/useragent/platform_test.js', ['goog.labs.userAgent.platformTest'], [
  'goog.labs.userAgent.platform',
  'goog.labs.userAgent.testAgents',
  'goog.testing.PropertyReplacer',
  'goog.testing.jsunit'
]);
goog.addDependency('labs/useragent/test_agents.js', ['goog.labs.userAgent.testAgents'], []);
goog.addDependency('labs/useragent/util.js', ['goog.labs.userAgent.util'], [
  'goog.memoize',
  'goog.string'
]);
goog.addDependency('labs/useragent/util_test.js', ['goog.labs.userAgent.utilTest'], [
  'goog.labs.userAgent.testAgents',
  'goog.labs.userAgent.util',
  'goog.testing.jsunit'
]);
goog.addDependency('locale/countries.js', ['goog.locale.countries'], []);
goog.addDependency('locale/defaultlocalenameconstants.js', ['goog.locale.defaultLocaleNameConstants'], []);
goog.addDependency('locale/genericfontnames.js', ['goog.locale.genericFontNames'], []);
goog.addDependency('locale/genericfontnamesdata.js', ['goog.locale.genericFontNamesData'], []);
goog.addDependency('locale/locale.js', ['goog.locale'], ['goog.locale.nativeNameConstants']);
goog.addDependency('locale/nativenameconstants.js', ['goog.locale.nativeNameConstants'], []);
goog.addDependency('locale/scriptToLanguages.js', ['goog.locale.scriptToLanguages'], ['goog.locale']);
goog.addDependency('locale/timezonedetection.js', ['goog.locale.timeZoneDetection'], [
  'goog.locale',
  'goog.locale.TimeZoneFingerprint'
]);
goog.addDependency('locale/timezonefingerprint.js', ['goog.locale.TimeZoneFingerprint'], []);
goog.addDependency('locale/timezonelist.js', ['goog.locale.TimeZoneList'], ['goog.locale']);
goog.addDependency('log/log.js', [
  'goog.log',
  'goog.log.Level',
  'goog.log.LogRecord',
  'goog.log.Logger'
], [
  'goog.debug',
  'goog.debug.LogRecord',
  'goog.debug.Logger'
]);
goog.addDependency('log/log_test.js', ['goog.logTest'], [
  'goog.debug.LogManager',
  'goog.log',
  'goog.log.Level',
  'goog.testing.jsunit'
]);
goog.addDependency('math/bezier.js', ['goog.math.Bezier'], [
  'goog.math',
  'goog.math.Coordinate'
]);
goog.addDependency('math/box.js', ['goog.math.Box'], ['goog.math.Coordinate']);
goog.addDependency('math/coordinate.js', ['goog.math.Coordinate'], ['goog.math']);
goog.addDependency('math/coordinate3.js', ['goog.math.Coordinate3'], []);
goog.addDependency('math/exponentialbackoff.js', ['goog.math.ExponentialBackoff'], ['goog.asserts']);
goog.addDependency('math/integer.js', ['goog.math.Integer'], []);
goog.addDependency('math/interpolator/interpolator1.js', ['goog.math.interpolator.Interpolator1'], []);
goog.addDependency('math/interpolator/linear1.js', ['goog.math.interpolator.Linear1'], [
  'goog.array',
  'goog.math',
  'goog.math.interpolator.Interpolator1'
]);
goog.addDependency('math/interpolator/pchip1.js', ['goog.math.interpolator.Pchip1'], [
  'goog.math',
  'goog.math.interpolator.Spline1'
]);
goog.addDependency('math/interpolator/spline1.js', ['goog.math.interpolator.Spline1'], [
  'goog.array',
  'goog.math',
  'goog.math.interpolator.Interpolator1',
  'goog.math.tdma'
]);
goog.addDependency('math/line.js', ['goog.math.Line'], [
  'goog.math',
  'goog.math.Coordinate'
]);
goog.addDependency('math/long.js', ['goog.math.Long'], []);
goog.addDependency('math/math.js', ['goog.math'], [
  'goog.array',
  'goog.asserts'
]);
goog.addDependency('math/matrix.js', ['goog.math.Matrix'], [
  'goog.array',
  'goog.math',
  'goog.math.Size',
  'goog.string'
]);
goog.addDependency('math/range.js', ['goog.math.Range'], []);
goog.addDependency('math/rangeset.js', ['goog.math.RangeSet'], [
  'goog.array',
  'goog.iter.Iterator',
  'goog.iter.StopIteration',
  'goog.math.Range'
]);
goog.addDependency('math/rect.js', ['goog.math.Rect'], [
  'goog.math.Box',
  'goog.math.Coordinate',
  'goog.math.Size'
]);
goog.addDependency('math/size.js', ['goog.math.Size'], []);
goog.addDependency('math/tdma.js', ['goog.math.tdma'], []);
goog.addDependency('math/vec2.js', ['goog.math.Vec2'], [
  'goog.math',
  'goog.math.Coordinate'
]);
goog.addDependency('math/vec3.js', ['goog.math.Vec3'], [
  'goog.math',
  'goog.math.Coordinate3'
]);
goog.addDependency('memoize/memoize.js', ['goog.memoize'], []);
goog.addDependency('messaging/abstractchannel.js', ['goog.messaging.AbstractChannel'], [
  'goog.Disposable',
  'goog.debug',
  'goog.json',
  'goog.log',
  'goog.messaging.MessageChannel'
]);
goog.addDependency('messaging/bufferedchannel.js', ['goog.messaging.BufferedChannel'], [
  'goog.Timer',
  'goog.Uri',
  'goog.debug.Error',
  'goog.events',
  'goog.log',
  'goog.messaging.MessageChannel',
  'goog.messaging.MultiChannel'
]);
goog.addDependency('messaging/deferredchannel.js', ['goog.messaging.DeferredChannel'], [
  'goog.Disposable',
  'goog.async.Deferred',
  'goog.messaging.MessageChannel'
]);
goog.addDependency('messaging/loggerclient.js', ['goog.messaging.LoggerClient'], [
  'goog.Disposable',
  'goog.debug',
  'goog.debug.LogManager',
  'goog.debug.Logger'
]);
goog.addDependency('messaging/loggerserver.js', ['goog.messaging.LoggerServer'], [
  'goog.Disposable',
  'goog.log'
]);
goog.addDependency('messaging/messagechannel.js', ['goog.messaging.MessageChannel'], []);
goog.addDependency('messaging/messaging.js', ['goog.messaging'], ['goog.messaging.MessageChannel']);
goog.addDependency('messaging/multichannel.js', [
  'goog.messaging.MultiChannel',
  'goog.messaging.MultiChannel.VirtualChannel'
], [
  'goog.Disposable',
  'goog.events.EventHandler',
  'goog.log',
  'goog.messaging.MessageChannel',
  'goog.object'
]);
goog.addDependency('messaging/portcaller.js', ['goog.messaging.PortCaller'], [
  'goog.Disposable',
  'goog.async.Deferred',
  'goog.messaging.DeferredChannel',
  'goog.messaging.PortChannel',
  'goog.messaging.PortNetwork',
  'goog.object'
]);
goog.addDependency('messaging/portchannel.js', ['goog.messaging.PortChannel'], [
  'goog.Timer',
  'goog.array',
  'goog.async.Deferred',
  'goog.debug',
  'goog.dom',
  'goog.dom.DomHelper',
  'goog.events',
  'goog.events.EventType',
  'goog.json',
  'goog.log',
  'goog.messaging.AbstractChannel',
  'goog.messaging.DeferredChannel',
  'goog.object',
  'goog.string'
]);
goog.addDependency('messaging/portnetwork.js', ['goog.messaging.PortNetwork'], []);
goog.addDependency('messaging/portoperator.js', ['goog.messaging.PortOperator'], [
  'goog.Disposable',
  'goog.asserts',
  'goog.log',
  'goog.messaging.PortChannel',
  'goog.messaging.PortNetwork',
  'goog.object'
]);
goog.addDependency('messaging/respondingchannel.js', ['goog.messaging.RespondingChannel'], [
  'goog.Disposable',
  'goog.log',
  'goog.messaging.MessageChannel',
  'goog.messaging.MultiChannel',
  'goog.messaging.MultiChannel.VirtualChannel'
]);
goog.addDependency('messaging/testdata/portchannel_worker.js', ['goog.messaging.testdata.portchannel_worker'], ['goog.messaging.PortChannel']);
goog.addDependency('messaging/testdata/portnetwork_worker1.js', ['goog.messaging.testdata.portnetwork_worker1'], [
  'goog.messaging.PortCaller',
  'goog.messaging.PortChannel'
]);
goog.addDependency('messaging/testdata/portnetwork_worker2.js', ['goog.messaging.testdata.portnetwork_worker2'], [
  'goog.messaging.PortCaller',
  'goog.messaging.PortChannel'
]);
goog.addDependency('module/abstractmoduleloader.js', ['goog.module.AbstractModuleLoader'], []);
goog.addDependency('module/basemodule.js', ['goog.module.BaseModule'], ['goog.Disposable']);
goog.addDependency('module/loader.js', ['goog.module.Loader'], [
  'goog.Timer',
  'goog.array',
  'goog.dom',
  'goog.object'
]);
goog.addDependency('module/module.js', ['goog.module'], [
  'goog.array',
  'goog.module.Loader'
]);
goog.addDependency('module/moduleinfo.js', ['goog.module.ModuleInfo'], [
  'goog.Disposable',
  'goog.functions',
  'goog.module.BaseModule',
  'goog.module.ModuleLoadCallback'
]);
goog.addDependency('module/moduleloadcallback.js', ['goog.module.ModuleLoadCallback'], [
  'goog.debug.entryPointRegistry',
  'goog.debug.errorHandlerWeakDep'
]);
goog.addDependency('module/moduleloader.js', ['goog.module.ModuleLoader'], [
  'goog.Timer',
  'goog.array',
  'goog.events',
  'goog.events.Event',
  'goog.events.EventHandler',
  'goog.events.EventTarget',
  'goog.log',
  'goog.module.AbstractModuleLoader',
  'goog.net.BulkLoader',
  'goog.net.EventType',
  'goog.net.jsloader',
  'goog.userAgent.product'
]);
goog.addDependency('module/moduleloader_test.js', ['goog.module.ModuleLoaderTest'], [
  'goog.array',
  'goog.dom',
  'goog.functions',
  'goog.module.ModuleLoader',
  'goog.module.ModuleManager',
  'goog.module.ModuleManager.CallbackType',
  'goog.object',
  'goog.testing.AsyncTestCase',
  'goog.testing.PropertyReplacer',
  'goog.testing.events.EventObserver',
  'goog.testing.jsunit',
  'goog.testing.recordFunction',
  'goog.userAgent.product'
]);
goog.addDependency('module/modulemanager.js', [
  'goog.module.ModuleManager',
  'goog.module.ModuleManager.CallbackType',
  'goog.module.ModuleManager.FailureType'
], [
  'goog.Disposable',
  'goog.array',
  'goog.asserts',
  'goog.async.Deferred',
  'goog.debug.Trace',
  'goog.dispose',
  'goog.log',
  'goog.module.ModuleInfo',
  'goog.module.ModuleLoadCallback',
  'goog.object'
]);
goog.addDependency('module/testdata/modA_1.js', ['goog.module.testdata.modA_1'], []);
goog.addDependency('module/testdata/modA_2.js', ['goog.module.testdata.modA_2'], ['goog.module.ModuleManager']);
goog.addDependency('module/testdata/modB_1.js', ['goog.module.testdata.modB_1'], ['goog.module.ModuleManager']);
goog.addDependency('net/browserchannel.js', [
  'goog.net.BrowserChannel',
  'goog.net.BrowserChannel.Error',
  'goog.net.BrowserChannel.Event',
  'goog.net.BrowserChannel.Handler',
  'goog.net.BrowserChannel.LogSaver',
  'goog.net.BrowserChannel.QueuedMap',
  'goog.net.BrowserChannel.ServerReachability',
  'goog.net.BrowserChannel.ServerReachabilityEvent',
  'goog.net.BrowserChannel.Stat',
  'goog.net.BrowserChannel.StatEvent',
  'goog.net.BrowserChannel.State',
  'goog.net.BrowserChannel.TimingEvent'
], [
  'goog.Uri',
  'goog.array',
  'goog.asserts',
  'goog.debug.TextFormatter',
  'goog.events.Event',
  'goog.events.EventTarget',
  'goog.json',
  'goog.json.EvalJsonProcessor',
  'goog.log',
  'goog.net.BrowserTestChannel',
  'goog.net.ChannelDebug',
  'goog.net.ChannelRequest',
  'goog.net.XhrIo',
  'goog.net.tmpnetwork',
  'goog.string',
  'goog.structs',
  'goog.structs.CircularBuffer'
]);
goog.addDependency('net/browsertestchannel.js', ['goog.net.BrowserTestChannel'], [
  'goog.json.EvalJsonProcessor',
  'goog.net.ChannelRequest',
  'goog.net.ChannelRequest.Error',
  'goog.net.tmpnetwork',
  'goog.string.Parser',
  'goog.userAgent'
]);
goog.addDependency('net/bulkloader.js', ['goog.net.BulkLoader'], [
  'goog.events.EventHandler',
  'goog.events.EventTarget',
  'goog.log',
  'goog.net.BulkLoaderHelper',
  'goog.net.EventType',
  'goog.net.XhrIo'
]);
goog.addDependency('net/bulkloaderhelper.js', ['goog.net.BulkLoaderHelper'], [
  'goog.Disposable',
  'goog.log'
]);
goog.addDependency('net/channeldebug.js', ['goog.net.ChannelDebug'], [
  'goog.json',
  'goog.log'
]);
goog.addDependency('net/channelrequest.js', [
  'goog.net.ChannelRequest',
  'goog.net.ChannelRequest.Error'
], [
  'goog.Timer',
  'goog.async.Throttle',
  'goog.events.EventHandler',
  'goog.net.ErrorCode',
  'goog.net.EventType',
  'goog.net.XmlHttp',
  'goog.object',
  'goog.userAgent'
]);
goog.addDependency('net/cookies.js', [
  'goog.net.Cookies',
  'goog.net.cookies'
], []);
goog.addDependency('net/crossdomainrpc.js', ['goog.net.CrossDomainRpc'], [
  'goog.Uri',
  'goog.dom',
  'goog.events',
  'goog.events.EventTarget',
  'goog.events.EventType',
  'goog.json',
  'goog.log',
  'goog.net.EventType',
  'goog.net.HttpStatus',
  'goog.string',
  'goog.userAgent'
]);
goog.addDependency('net/errorcode.js', ['goog.net.ErrorCode'], []);
goog.addDependency('net/eventtype.js', ['goog.net.EventType'], []);
goog.addDependency('net/filedownloader.js', [
  'goog.net.FileDownloader',
  'goog.net.FileDownloader.Error'
], [
  'goog.Disposable',
  'goog.asserts',
  'goog.async.Deferred',
  'goog.crypt.hash32',
  'goog.debug.Error',
  'goog.events',
  'goog.events.EventHandler',
  'goog.fs',
  'goog.fs.DirectoryEntry',
  'goog.fs.Error',
  'goog.fs.FileSaver',
  'goog.net.EventType',
  'goog.net.XhrIo',
  'goog.net.XhrIoPool',
  'goog.object'
]);
goog.addDependency('net/httpstatus.js', ['goog.net.HttpStatus'], []);
goog.addDependency('net/iframeio.js', [
  'goog.net.IframeIo',
  'goog.net.IframeIo.IncrementalDataEvent'
], [
  'goog.Timer',
  'goog.Uri',
  'goog.debug',
  'goog.dom',
  'goog.events',
  'goog.events.Event',
  'goog.events.EventTarget',
  'goog.events.EventType',
  'goog.json',
  'goog.log',
  'goog.net.ErrorCode',
  'goog.net.EventType',
  'goog.reflect',
  'goog.string',
  'goog.structs',
  'goog.userAgent'
]);
goog.addDependency('net/iframeloadmonitor.js', ['goog.net.IframeLoadMonitor'], [
  'goog.dom',
  'goog.events',
  'goog.events.EventTarget',
  'goog.events.EventType',
  'goog.userAgent'
]);
goog.addDependency('net/imageloader.js', ['goog.net.ImageLoader'], [
  'goog.array',
  'goog.dom',
  'goog.events.EventHandler',
  'goog.events.EventTarget',
  'goog.events.EventType',
  'goog.net.EventType',
  'goog.object',
  'goog.userAgent'
]);
goog.addDependency('net/ipaddress.js', [
  'goog.net.IpAddress',
  'goog.net.Ipv4Address',
  'goog.net.Ipv6Address'
], [
  'goog.array',
  'goog.math.Integer',
  'goog.object',
  'goog.string'
]);
goog.addDependency('net/jsloader.js', [
  'goog.net.jsloader',
  'goog.net.jsloader.Error',
  'goog.net.jsloader.ErrorCode',
  'goog.net.jsloader.Options'
], [
  'goog.array',
  'goog.async.Deferred',
  'goog.debug.Error',
  'goog.dom',
  'goog.dom.TagName'
]);
goog.addDependency('net/jsonp.js', ['goog.net.Jsonp'], [
  'goog.Uri',
  'goog.net.jsloader'
]);
goog.addDependency('net/mockiframeio.js', ['goog.net.MockIFrameIo'], [
  'goog.events.EventTarget',
  'goog.json',
  'goog.net.ErrorCode',
  'goog.net.EventType',
  'goog.net.IframeIo'
]);
goog.addDependency('net/multiiframeloadmonitor.js', ['goog.net.MultiIframeLoadMonitor'], [
  'goog.events',
  'goog.net.IframeLoadMonitor'
]);
goog.addDependency('net/networkstatusmonitor.js', ['goog.net.NetworkStatusMonitor'], ['goog.events.Listenable']);
goog.addDependency('net/networktester.js', ['goog.net.NetworkTester'], [
  'goog.Timer',
  'goog.Uri',
  'goog.log'
]);
goog.addDependency('net/testdata/jsloader_test1.js', ['goog.net.testdata.jsloader_test1'], []);
goog.addDependency('net/testdata/jsloader_test2.js', ['goog.net.testdata.jsloader_test2'], []);
goog.addDependency('net/testdata/jsloader_test3.js', ['goog.net.testdata.jsloader_test3'], []);
goog.addDependency('net/testdata/jsloader_test4.js', ['goog.net.testdata.jsloader_test4'], []);
goog.addDependency('net/tmpnetwork.js', ['goog.net.tmpnetwork'], [
  'goog.Uri',
  'goog.net.ChannelDebug'
]);
goog.addDependency('net/websocket.js', [
  'goog.net.WebSocket',
  'goog.net.WebSocket.ErrorEvent',
  'goog.net.WebSocket.EventType',
  'goog.net.WebSocket.MessageEvent'
], [
  'goog.Timer',
  'goog.asserts',
  'goog.debug.entryPointRegistry',
  'goog.events',
  'goog.events.Event',
  'goog.events.EventTarget',
  'goog.log'
]);
goog.addDependency('net/wrapperxmlhttpfactory.js', ['goog.net.WrapperXmlHttpFactory'], ['goog.net.XmlHttpFactory']);
goog.addDependency('net/xhrio.js', [
  'goog.net.XhrIo',
  'goog.net.XhrIo.ResponseType'
], [
  'goog.Timer',
  'goog.array',
  'goog.debug.entryPointRegistry',
  'goog.events.EventTarget',
  'goog.json',
  'goog.log',
  'goog.net.ErrorCode',
  'goog.net.EventType',
  'goog.net.HttpStatus',
  'goog.net.XmlHttp',
  'goog.object',
  'goog.string',
  'goog.structs',
  'goog.structs.Map',
  'goog.uri.utils',
  'goog.userAgent'
]);
goog.addDependency('net/xhriopool.js', ['goog.net.XhrIoPool'], [
  'goog.net.XhrIo',
  'goog.structs',
  'goog.structs.PriorityPool'
]);
goog.addDependency('net/xhrmanager.js', [
  'goog.net.XhrManager',
  'goog.net.XhrManager.Event',
  'goog.net.XhrManager.Request'
], [
  'goog.Disposable',
  'goog.events',
  'goog.events.Event',
  'goog.events.EventHandler',
  'goog.events.EventTarget',
  'goog.net.ErrorCode',
  'goog.net.EventType',
  'goog.net.XhrIo',
  'goog.net.XhrIoPool',
  'goog.structs',
  'goog.structs.Map'
]);
goog.addDependency('net/xmlhttp.js', [
  'goog.net.DefaultXmlHttpFactory',
  'goog.net.XmlHttp',
  'goog.net.XmlHttp.OptionType',
  'goog.net.XmlHttp.ReadyState'
], [
  'goog.net.WrapperXmlHttpFactory',
  'goog.net.XmlHttpFactory'
]);
goog.addDependency('net/xmlhttpfactory.js', ['goog.net.XmlHttpFactory'], []);
goog.addDependency('net/xpc/crosspagechannel.js', ['goog.net.xpc.CrossPageChannel'], [
  'goog.Disposable',
  'goog.Uri',
  'goog.async.Deferred',
  'goog.async.Delay',
  'goog.dom',
  'goog.events',
  'goog.events.EventHandler',
  'goog.json',
  'goog.messaging.AbstractChannel',
  'goog.net.xpc',
  'goog.net.xpc.CrossPageChannelRole',
  'goog.net.xpc.FrameElementMethodTransport',
  'goog.net.xpc.IframePollingTransport',
  'goog.net.xpc.IframeRelayTransport',
  'goog.net.xpc.NativeMessagingTransport',
  'goog.net.xpc.NixTransport',
  'goog.net.xpc.Transport',
  'goog.userAgent'
]);
goog.addDependency('net/xpc/crosspagechannelrole.js', ['goog.net.xpc.CrossPageChannelRole'], []);
goog.addDependency('net/xpc/frameelementmethodtransport.js', ['goog.net.xpc.FrameElementMethodTransport'], [
  'goog.net.xpc',
  'goog.net.xpc.CrossPageChannelRole',
  'goog.net.xpc.Transport'
]);
goog.addDependency('net/xpc/iframepollingtransport.js', [
  'goog.net.xpc.IframePollingTransport',
  'goog.net.xpc.IframePollingTransport.Receiver',
  'goog.net.xpc.IframePollingTransport.Sender'
], [
  'goog.array',
  'goog.dom',
  'goog.net.xpc',
  'goog.net.xpc.CrossPageChannelRole',
  'goog.net.xpc.Transport',
  'goog.userAgent'
]);
goog.addDependency('net/xpc/iframerelaytransport.js', ['goog.net.xpc.IframeRelayTransport'], [
  'goog.dom',
  'goog.events',
  'goog.net.xpc',
  'goog.net.xpc.Transport',
  'goog.userAgent'
]);
goog.addDependency('net/xpc/nativemessagingtransport.js', ['goog.net.xpc.NativeMessagingTransport'], [
  'goog.Timer',
  'goog.asserts',
  'goog.async.Deferred',
  'goog.events',
  'goog.events.EventHandler',
  'goog.net.xpc',
  'goog.net.xpc.CrossPageChannelRole',
  'goog.net.xpc.Transport'
]);
goog.addDependency('net/xpc/nixtransport.js', ['goog.net.xpc.NixTransport'], [
  'goog.net.xpc',
  'goog.net.xpc.CrossPageChannelRole',
  'goog.net.xpc.Transport',
  'goog.reflect'
]);
goog.addDependency('net/xpc/relay.js', ['goog.net.xpc.relay'], []);
goog.addDependency('net/xpc/transport.js', ['goog.net.xpc.Transport'], [
  'goog.Disposable',
  'goog.dom',
  'goog.net.xpc'
]);
goog.addDependency('net/xpc/xpc.js', [
  'goog.net.xpc',
  'goog.net.xpc.CfgFields',
  'goog.net.xpc.ChannelStates',
  'goog.net.xpc.TransportNames',
  'goog.net.xpc.TransportTypes',
  'goog.net.xpc.UriCfgFields'
], ['goog.log']);
goog.addDependency('object/object.js', ['goog.object'], []);
goog.addDependency('positioning/absoluteposition.js', ['goog.positioning.AbsolutePosition'], [
  'goog.math.Box',
  'goog.math.Coordinate',
  'goog.math.Size',
  'goog.positioning',
  'goog.positioning.AbstractPosition'
]);
goog.addDependency('positioning/abstractposition.js', ['goog.positioning.AbstractPosition'], [
  'goog.math.Box',
  'goog.math.Size',
  'goog.positioning.Corner'
]);
goog.addDependency('positioning/anchoredposition.js', ['goog.positioning.AnchoredPosition'], [
  'goog.math.Box',
  'goog.positioning',
  'goog.positioning.AbstractPosition'
]);
goog.addDependency('positioning/anchoredviewportposition.js', ['goog.positioning.AnchoredViewportPosition'], [
  'goog.math.Box',
  'goog.positioning',
  'goog.positioning.AnchoredPosition',
  'goog.positioning.Corner',
  'goog.positioning.Overflow',
  'goog.positioning.OverflowStatus'
]);
goog.addDependency('positioning/clientposition.js', ['goog.positioning.ClientPosition'], [
  'goog.asserts',
  'goog.math.Box',
  'goog.math.Coordinate',
  'goog.math.Size',
  'goog.positioning',
  'goog.positioning.AbstractPosition',
  'goog.style'
]);
goog.addDependency('positioning/clientposition_test.js', ['goog.positioning.clientPositionTest'], [
  'goog.dom',
  'goog.positioning.ClientPosition',
  'goog.style',
  'goog.testing.jsunit'
]);
goog.addDependency('positioning/menuanchoredposition.js', ['goog.positioning.MenuAnchoredPosition'], [
  'goog.math.Box',
  'goog.math.Size',
  'goog.positioning',
  'goog.positioning.AnchoredViewportPosition',
  'goog.positioning.Corner',
  'goog.positioning.Overflow'
]);
goog.addDependency('positioning/positioning.js', [
  'goog.positioning',
  'goog.positioning.Corner',
  'goog.positioning.CornerBit',
  'goog.positioning.Overflow',
  'goog.positioning.OverflowStatus'
], [
  'goog.asserts',
  'goog.dom',
  'goog.dom.TagName',
  'goog.math.Box',
  'goog.math.Coordinate',
  'goog.math.Size',
  'goog.style',
  'goog.style.bidi'
]);
goog.addDependency('positioning/positioning_test.js', ['goog.positioningTest'], [
  'goog.dom',
  'goog.dom.DomHelper',
  'goog.math.Box',
  'goog.math.Coordinate',
  'goog.math.Rect',
  'goog.math.Size',
  'goog.positioning',
  'goog.positioning.Corner',
  'goog.positioning.Overflow',
  'goog.positioning.OverflowStatus',
  'goog.style',
  'goog.testing.ExpectedFailures',
  'goog.testing.jsunit',
  'goog.userAgent',
  'goog.userAgent.product'
]);
goog.addDependency('positioning/viewportclientposition.js', ['goog.positioning.ViewportClientPosition'], [
  'goog.math.Box',
  'goog.math.Coordinate',
  'goog.math.Size',
  'goog.positioning.ClientPosition'
]);
goog.addDependency('positioning/viewportposition.js', ['goog.positioning.ViewportPosition'], [
  'goog.math.Box',
  'goog.math.Coordinate',
  'goog.math.Size',
  'goog.positioning.AbstractPosition'
]);
goog.addDependency('proto/proto.js', ['goog.proto'], ['goog.proto.Serializer']);
goog.addDependency('proto/serializer.js', ['goog.proto.Serializer'], [
  'goog.json.Serializer',
  'goog.string'
]);
goog.addDependency('proto2/descriptor.js', [
  'goog.proto2.Descriptor',
  'goog.proto2.Metadata'
], [
  'goog.array',
  'goog.object',
  'goog.proto2.Util'
]);
goog.addDependency('proto2/fielddescriptor.js', ['goog.proto2.FieldDescriptor'], [
  'goog.proto2.Util',
  'goog.string'
]);
goog.addDependency('proto2/lazydeserializer.js', ['goog.proto2.LazyDeserializer'], [
  'goog.proto2.Message',
  'goog.proto2.Serializer',
  'goog.proto2.Util'
]);
goog.addDependency('proto2/message.js', ['goog.proto2.Message'], [
  'goog.proto2.Descriptor',
  'goog.proto2.FieldDescriptor',
  'goog.proto2.Util',
  'goog.string'
]);
goog.addDependency('proto2/objectserializer.js', ['goog.proto2.ObjectSerializer'], [
  'goog.proto2.Serializer',
  'goog.proto2.Util',
  'goog.string'
]);
goog.addDependency('proto2/package_test.pb.js', ['someprotopackage.TestPackageTypes'], [
  'goog.proto2.Message',
  'proto2.TestAllTypes'
]);
goog.addDependency('proto2/pbliteserializer.js', ['goog.proto2.PbLiteSerializer'], [
  'goog.proto2.LazyDeserializer',
  'goog.proto2.Util'
]);
goog.addDependency('proto2/serializer.js', ['goog.proto2.Serializer'], [
  'goog.proto2.Descriptor',
  'goog.proto2.FieldDescriptor',
  'goog.proto2.Message',
  'goog.proto2.Util'
]);
goog.addDependency('proto2/test.pb.js', [
  'proto2.TestAllTypes',
  'proto2.TestAllTypes.NestedEnum',
  'proto2.TestAllTypes.NestedMessage',
  'proto2.TestAllTypes.OptionalGroup',
  'proto2.TestAllTypes.RepeatedGroup'
], ['goog.proto2.Message']);
goog.addDependency('proto2/textformatserializer.js', [
  'goog.proto2.TextFormatSerializer',
  'goog.proto2.TextFormatSerializer.Parser'
], [
  'goog.array',
  'goog.asserts',
  'goog.json',
  'goog.proto2.Serializer',
  'goog.proto2.Util',
  'goog.string'
]);
goog.addDependency('proto2/textformatserializer_test.js', ['goog.proto2.TextFormatSerializerTest'], [
  'goog.proto2.TextFormatSerializer',
  'goog.testing.jsunit',
  'proto2.TestAllTypes'
]);
goog.addDependency('proto2/util.js', ['goog.proto2.Util'], ['goog.asserts']);
goog.addDependency('pubsub/pubsub.js', ['goog.pubsub.PubSub'], [
  'goog.Disposable',
  'goog.array'
]);
goog.addDependency('reflect/reflect.js', ['goog.reflect'], []);
goog.addDependency('result/deferredadaptor.js', ['goog.result.DeferredAdaptor'], [
  'goog.async.Deferred',
  'goog.result',
  'goog.result.Result'
]);
goog.addDependency('result/dependentresult.js', ['goog.result.DependentResult'], ['goog.result.Result']);
goog.addDependency('result/result_interface.js', ['goog.result.Result'], []);
goog.addDependency('result/resultutil.js', ['goog.result'], [
  'goog.array',
  'goog.result.DependentResult',
  'goog.result.Result',
  'goog.result.SimpleResult'
]);
goog.addDependency('result/simpleresult.js', [
  'goog.result.SimpleResult',
  'goog.result.SimpleResult.StateError'
], [
  'goog.debug.Error',
  'goog.result.Result'
]);
goog.addDependency('soy/data.js', [
  'goog.soy.data',
  'goog.soy.data.SanitizedContent',
  'goog.soy.data.SanitizedContentKind'
], []);
goog.addDependency('soy/renderer.js', [
  'goog.soy.InjectedDataSupplier',
  'goog.soy.Renderer'
], [
  'goog.asserts',
  'goog.dom',
  'goog.soy',
  'goog.soy.data.SanitizedContent',
  'goog.soy.data.SanitizedContentKind'
]);
goog.addDependency('soy/soy.js', ['goog.soy'], [
  'goog.asserts',
  'goog.dom',
  'goog.dom.NodeType',
  'goog.dom.TagName',
  'goog.soy.data',
  'goog.string'
]);
goog.addDependency('soy/soy_test.js', ['goog.soy.testHelper'], [
  'goog.dom',
  'goog.dom.TagName',
  'goog.soy.data.SanitizedContent',
  'goog.soy.data.SanitizedContentKind',
  'goog.string',
  'goog.userAgent'
]);
goog.addDependency('spell/spellcheck.js', [
  'goog.spell.SpellCheck',
  'goog.spell.SpellCheck.WordChangedEvent'
], [
  'goog.Timer',
  'goog.events.EventTarget',
  'goog.structs.Set'
]);
goog.addDependency('stats/basicstat.js', ['goog.stats.BasicStat'], [
  'goog.array',
  'goog.iter',
  'goog.log',
  'goog.object',
  'goog.string.format',
  'goog.structs.CircularBuffer'
]);
goog.addDependency('storage/collectablestorage.js', ['goog.storage.CollectableStorage'], [
  'goog.array',
  'goog.asserts',
  'goog.iter',
  'goog.storage.ErrorCode',
  'goog.storage.ExpiringStorage',
  'goog.storage.RichStorage.Wrapper',
  'goog.storage.mechanism.IterableMechanism'
]);
goog.addDependency('storage/encryptedstorage.js', ['goog.storage.EncryptedStorage'], [
  'goog.crypt',
  'goog.crypt.Arc4',
  'goog.crypt.Sha1',
  'goog.crypt.base64',
  'goog.json',
  'goog.json.Serializer',
  'goog.storage.CollectableStorage',
  'goog.storage.ErrorCode',
  'goog.storage.RichStorage',
  'goog.storage.RichStorage.Wrapper',
  'goog.storage.mechanism.IterableMechanism'
]);
goog.addDependency('storage/errorcode.js', ['goog.storage.ErrorCode'], []);
goog.addDependency('storage/expiringstorage.js', ['goog.storage.ExpiringStorage'], [
  'goog.storage.RichStorage',
  'goog.storage.RichStorage.Wrapper',
  'goog.storage.mechanism.Mechanism'
]);
goog.addDependency('storage/mechanism/errorcode.js', ['goog.storage.mechanism.ErrorCode'], []);
goog.addDependency('storage/mechanism/errorhandlingmechanism.js', ['goog.storage.mechanism.ErrorHandlingMechanism'], ['goog.storage.mechanism.Mechanism']);
goog.addDependency('storage/mechanism/html5localstorage.js', ['goog.storage.mechanism.HTML5LocalStorage'], ['goog.storage.mechanism.HTML5WebStorage']);
goog.addDependency('storage/mechanism/html5sessionstorage.js', ['goog.storage.mechanism.HTML5SessionStorage'], ['goog.storage.mechanism.HTML5WebStorage']);
goog.addDependency('storage/mechanism/html5webstorage.js', ['goog.storage.mechanism.HTML5WebStorage'], [
  'goog.asserts',
  'goog.iter.Iterator',
  'goog.iter.StopIteration',
  'goog.storage.mechanism.ErrorCode',
  'goog.storage.mechanism.IterableMechanism'
]);
goog.addDependency('storage/mechanism/ieuserdata.js', ['goog.storage.mechanism.IEUserData'], [
  'goog.asserts',
  'goog.iter.Iterator',
  'goog.iter.StopIteration',
  'goog.storage.mechanism.ErrorCode',
  'goog.storage.mechanism.IterableMechanism',
  'goog.structs.Map',
  'goog.userAgent'
]);
goog.addDependency('storage/mechanism/iterablemechanism.js', ['goog.storage.mechanism.IterableMechanism'], [
  'goog.array',
  'goog.asserts',
  'goog.iter',
  'goog.iter.Iterator',
  'goog.storage.mechanism.Mechanism'
]);
goog.addDependency('storage/mechanism/iterablemechanismtester.js', ['goog.storage.mechanism.iterableMechanismTester'], [
  'goog.iter.Iterator',
  'goog.storage.mechanism.IterableMechanism',
  'goog.testing.asserts'
]);
goog.addDependency('storage/mechanism/mechanism.js', ['goog.storage.mechanism.Mechanism'], []);
goog.addDependency('storage/mechanism/mechanismfactory.js', ['goog.storage.mechanism.mechanismfactory'], [
  'goog.storage.mechanism.HTML5LocalStorage',
  'goog.storage.mechanism.HTML5SessionStorage',
  'goog.storage.mechanism.IEUserData',
  'goog.storage.mechanism.IterableMechanism',
  'goog.storage.mechanism.PrefixedMechanism'
]);
goog.addDependency('storage/mechanism/mechanismseparationtester.js', ['goog.storage.mechanism.mechanismSeparationTester'], [
  'goog.iter.Iterator',
  'goog.storage.mechanism.IterableMechanism',
  'goog.testing.asserts'
]);
goog.addDependency('storage/mechanism/mechanismsharingtester.js', ['goog.storage.mechanism.mechanismSharingTester'], [
  'goog.iter.Iterator',
  'goog.storage.mechanism.IterableMechanism',
  'goog.testing.asserts'
]);
goog.addDependency('storage/mechanism/mechanismtester.js', ['goog.storage.mechanism.mechanismTester'], [
  'goog.storage.mechanism.ErrorCode',
  'goog.storage.mechanism.HTML5LocalStorage',
  'goog.storage.mechanism.Mechanism',
  'goog.testing.asserts',
  'goog.userAgent.product',
  'goog.userAgent.product.isVersion'
]);
goog.addDependency('storage/mechanism/prefixedmechanism.js', ['goog.storage.mechanism.PrefixedMechanism'], [
  'goog.iter.Iterator',
  'goog.storage.mechanism.IterableMechanism'
]);
goog.addDependency('storage/richstorage.js', [
  'goog.storage.RichStorage',
  'goog.storage.RichStorage.Wrapper'
], [
  'goog.storage.ErrorCode',
  'goog.storage.Storage',
  'goog.storage.mechanism.Mechanism'
]);
goog.addDependency('storage/storage.js', ['goog.storage.Storage'], [
  'goog.json',
  'goog.json.Serializer',
  'goog.storage.ErrorCode'
]);
goog.addDependency('storage/storage_test.js', ['goog.storage.storage_test'], [
  'goog.storage.Storage',
  'goog.structs.Map',
  'goog.testing.asserts'
]);
goog.addDependency('string/linkify.js', ['goog.string.linkify'], ['goog.string']);
goog.addDependency('string/newlines.js', [
  'goog.string.newlines',
  'goog.string.newlines.Line'
], ['goog.array']);
goog.addDependency('string/newlines_test.js', ['goog.string.newlinesTest'], [
  'goog.string.newlines',
  'goog.testing.jsunit'
]);
goog.addDependency('string/parser.js', ['goog.string.Parser'], []);
goog.addDependency('string/path.js', ['goog.string.path'], [
  'goog.array',
  'goog.string'
]);
goog.addDependency('string/string.js', [
  'goog.string',
  'goog.string.Unicode'
], []);
goog.addDependency('string/string_test.js', ['goog.stringTest'], [
  'goog.functions',
  'goog.object',
  'goog.string',
  'goog.testing.PropertyReplacer',
  'goog.testing.jsunit'
]);
goog.addDependency('string/stringbuffer.js', ['goog.string.StringBuffer'], []);
goog.addDependency('string/stringformat.js', ['goog.string.format'], ['goog.string']);
goog.addDependency('string/stringifier.js', ['goog.string.Stringifier'], []);
goog.addDependency('structs/avltree.js', [
  'goog.structs.AvlTree',
  'goog.structs.AvlTree.Node'
], ['goog.structs.Collection']);
goog.addDependency('structs/circularbuffer.js', ['goog.structs.CircularBuffer'], []);
goog.addDependency('structs/collection.js', ['goog.structs.Collection'], []);
goog.addDependency('structs/heap.js', ['goog.structs.Heap'], [
  'goog.array',
  'goog.object',
  'goog.structs.Node'
]);
goog.addDependency('structs/inversionmap.js', ['goog.structs.InversionMap'], ['goog.array']);
goog.addDependency('structs/linkedmap.js', ['goog.structs.LinkedMap'], ['goog.structs.Map']);
goog.addDependency('structs/map.js', ['goog.structs.Map'], [
  'goog.iter.Iterator',
  'goog.iter.StopIteration',
  'goog.object'
]);
goog.addDependency('structs/node.js', ['goog.structs.Node'], []);
goog.addDependency('structs/pool.js', ['goog.structs.Pool'], [
  'goog.Disposable',
  'goog.structs.Queue',
  'goog.structs.Set'
]);
goog.addDependency('structs/prioritypool.js', ['goog.structs.PriorityPool'], [
  'goog.structs.Pool',
  'goog.structs.PriorityQueue'
]);
goog.addDependency('structs/priorityqueue.js', ['goog.structs.PriorityQueue'], ['goog.structs.Heap']);
goog.addDependency('structs/quadtree.js', [
  'goog.structs.QuadTree',
  'goog.structs.QuadTree.Node',
  'goog.structs.QuadTree.Point'
], ['goog.math.Coordinate']);
goog.addDependency('structs/queue.js', ['goog.structs.Queue'], ['goog.array']);
goog.addDependency('structs/set.js', ['goog.structs.Set'], [
  'goog.structs',
  'goog.structs.Collection',
  'goog.structs.Map'
]);
goog.addDependency('structs/simplepool.js', ['goog.structs.SimplePool'], ['goog.Disposable']);
goog.addDependency('structs/stringset.js', ['goog.structs.StringSet'], [
  'goog.asserts',
  'goog.iter'
]);
goog.addDependency('structs/structs.js', ['goog.structs'], [
  'goog.array',
  'goog.object'
]);
goog.addDependency('structs/treenode.js', ['goog.structs.TreeNode'], [
  'goog.array',
  'goog.asserts',
  'goog.structs.Node'
]);
goog.addDependency('structs/trie.js', ['goog.structs.Trie'], [
  'goog.object',
  'goog.structs'
]);
goog.addDependency('style/bidi.js', ['goog.style.bidi'], [
  'goog.dom',
  'goog.style',
  'goog.userAgent'
]);
goog.addDependency('style/cursor.js', ['goog.style.cursor'], ['goog.userAgent']);
goog.addDependency('style/style.js', ['goog.style'], [
  'goog.array',
  'goog.asserts',
  'goog.dom',
  'goog.dom.NodeType',
  'goog.dom.vendor',
  'goog.math.Box',
  'goog.math.Coordinate',
  'goog.math.Rect',
  'goog.math.Size',
  'goog.object',
  'goog.string',
  'goog.userAgent'
]);
goog.addDependency('style/style_test.js', ['goog.style_test'], [
  'goog.array',
  'goog.color',
  'goog.dom',
  'goog.events.BrowserEvent',
  'goog.math.Box',
  'goog.math.Coordinate',
  'goog.math.Rect',
  'goog.math.Size',
  'goog.object',
  'goog.string',
  'goog.style',
  'goog.testing.ExpectedFailures',
  'goog.testing.PropertyReplacer',
  'goog.testing.asserts',
  'goog.testing.jsunit',
  'goog.userAgent',
  'goog.userAgent.product',
  'goog.userAgent.product.isVersion'
]);
goog.addDependency('style/stylescrollbartester.js', ['goog.styleScrollbarTester'], [
  'goog.dom',
  'goog.style',
  'goog.testing.asserts'
]);
goog.addDependency('style/transition.js', [
  'goog.style.transition',
  'goog.style.transition.Css3Property'
], [
  'goog.array',
  'goog.asserts',
  'goog.dom.vendor',
  'goog.style',
  'goog.userAgent'
]);
goog.addDependency('testing/asserts.js', [
  'goog.testing.JsUnitException',
  'goog.testing.asserts'
], ['goog.testing.stacktrace']);
goog.addDependency('testing/async/mockcontrol.js', ['goog.testing.async.MockControl'], [
  'goog.asserts',
  'goog.async.Deferred',
  'goog.debug',
  'goog.testing.asserts',
  'goog.testing.mockmatchers.IgnoreArgument'
]);
goog.addDependency('testing/asynctestcase.js', [
  'goog.testing.AsyncTestCase',
  'goog.testing.AsyncTestCase.ControlBreakingException'
], [
  'goog.testing.TestCase',
  'goog.testing.TestCase.Test',
  'goog.testing.asserts'
]);
goog.addDependency('testing/benchmark.js', ['goog.testing.benchmark'], [
  'goog.dom',
  'goog.dom.TagName',
  'goog.testing.PerformanceTable',
  'goog.testing.PerformanceTimer',
  'goog.testing.TestCase'
]);
goog.addDependency('testing/continuationtestcase.js', [
  'goog.testing.ContinuationTestCase',
  'goog.testing.ContinuationTestCase.Step',
  'goog.testing.ContinuationTestCase.Test'
], [
  'goog.array',
  'goog.events.EventHandler',
  'goog.testing.TestCase',
  'goog.testing.TestCase.Test',
  'goog.testing.asserts'
]);
goog.addDependency('testing/deferredtestcase.js', ['goog.testing.DeferredTestCase'], [
  'goog.async.Deferred',
  'goog.testing.AsyncTestCase',
  'goog.testing.TestCase'
]);
goog.addDependency('testing/dom.js', ['goog.testing.dom'], [
  'goog.dom',
  'goog.dom.NodeIterator',
  'goog.dom.NodeType',
  'goog.dom.TagIterator',
  'goog.dom.TagName',
  'goog.dom.classes',
  'goog.iter',
  'goog.object',
  'goog.string',
  'goog.style',
  'goog.testing.asserts',
  'goog.userAgent'
]);
goog.addDependency('testing/editor/dom.js', ['goog.testing.editor.dom'], [
  'goog.dom.NodeType',
  'goog.dom.TagIterator',
  'goog.dom.TagWalkType',
  'goog.iter',
  'goog.string',
  'goog.testing.asserts'
]);
goog.addDependency('testing/editor/fieldmock.js', ['goog.testing.editor.FieldMock'], [
  'goog.dom',
  'goog.dom.Range',
  'goog.editor.Field',
  'goog.testing.LooseMock',
  'goog.testing.mockmatchers'
]);
goog.addDependency('testing/editor/testhelper.js', ['goog.testing.editor.TestHelper'], [
  'goog.Disposable',
  'goog.dom',
  'goog.dom.Range',
  'goog.editor.BrowserFeature',
  'goog.editor.node',
  'goog.editor.plugins.AbstractBubblePlugin',
  'goog.testing.dom'
]);
goog.addDependency('testing/events/eventobserver.js', ['goog.testing.events.EventObserver'], ['goog.array']);
goog.addDependency('testing/events/events.js', [
  'goog.testing.events',
  'goog.testing.events.Event'
], [
  'goog.Disposable',
  'goog.asserts',
  'goog.dom.NodeType',
  'goog.events',
  'goog.events.BrowserEvent',
  'goog.events.BrowserFeature',
  'goog.events.EventTarget',
  'goog.events.EventType',
  'goog.events.KeyCodes',
  'goog.object',
  'goog.style',
  'goog.userAgent'
]);
goog.addDependency('testing/events/matchers.js', ['goog.testing.events.EventMatcher'], [
  'goog.events.Event',
  'goog.testing.mockmatchers.ArgumentMatcher'
]);
goog.addDependency('testing/events/onlinehandler.js', ['goog.testing.events.OnlineHandler'], [
  'goog.events.EventTarget',
  'goog.net.NetworkStatusMonitor'
]);
goog.addDependency('testing/expectedfailures.js', ['goog.testing.ExpectedFailures'], [
  'goog.debug.DivConsole',
  'goog.dom',
  'goog.dom.TagName',
  'goog.events',
  'goog.events.EventType',
  'goog.log',
  'goog.style',
  'goog.testing.JsUnitException',
  'goog.testing.TestCase',
  'goog.testing.asserts'
]);
goog.addDependency('testing/fs/blob.js', ['goog.testing.fs.Blob'], ['goog.crypt.base64']);
goog.addDependency('testing/fs/entry.js', [
  'goog.testing.fs.DirectoryEntry',
  'goog.testing.fs.Entry',
  'goog.testing.fs.FileEntry'
], [
  'goog.Timer',
  'goog.array',
  'goog.asserts',
  'goog.async.Deferred',
  'goog.fs.DirectoryEntry',
  'goog.fs.DirectoryEntryImpl',
  'goog.fs.Entry',
  'goog.fs.Error',
  'goog.fs.FileEntry',
  'goog.functions',
  'goog.object',
  'goog.string',
  'goog.testing.fs.File',
  'goog.testing.fs.FileWriter'
]);
goog.addDependency('testing/fs/file.js', ['goog.testing.fs.File'], ['goog.testing.fs.Blob']);
goog.addDependency('testing/fs/filereader.js', ['goog.testing.fs.FileReader'], [
  'goog.Timer',
  'goog.events.EventTarget',
  'goog.fs.Error',
  'goog.fs.FileReader.EventType',
  'goog.fs.FileReader.ReadyState',
  'goog.testing.fs.File',
  'goog.testing.fs.ProgressEvent'
]);
goog.addDependency('testing/fs/filesystem.js', ['goog.testing.fs.FileSystem'], [
  'goog.fs.FileSystem',
  'goog.testing.fs.DirectoryEntry'
]);
goog.addDependency('testing/fs/filewriter.js', ['goog.testing.fs.FileWriter'], [
  'goog.Timer',
  'goog.events.Event',
  'goog.events.EventTarget',
  'goog.fs.Error',
  'goog.fs.FileSaver.EventType',
  'goog.fs.FileSaver.ReadyState',
  'goog.string',
  'goog.testing.fs.File',
  'goog.testing.fs.ProgressEvent'
]);
goog.addDependency('testing/fs/fs.js', ['goog.testing.fs'], [
  'goog.Timer',
  'goog.array',
  'goog.async.Deferred',
  'goog.fs',
  'goog.testing.fs.Blob',
  'goog.testing.fs.FileSystem'
]);
goog.addDependency('testing/fs/progressevent.js', ['goog.testing.fs.ProgressEvent'], ['goog.events.Event']);
goog.addDependency('testing/functionmock.js', [
  'goog.testing',
  'goog.testing.FunctionMock',
  'goog.testing.GlobalFunctionMock',
  'goog.testing.MethodMock'
], [
  'goog.object',
  'goog.testing.LooseMock',
  'goog.testing.Mock',
  'goog.testing.MockInterface',
  'goog.testing.PropertyReplacer',
  'goog.testing.StrictMock'
]);
goog.addDependency('testing/graphics.js', ['goog.testing.graphics'], [
  'goog.graphics.Path.Segment',
  'goog.testing.asserts'
]);
goog.addDependency('testing/i18n/asserts.js', ['goog.testing.i18n.asserts'], ['goog.testing.jsunit']);
goog.addDependency('testing/i18n/asserts_test.js', ['goog.testing.i18n.assertsTest'], [
  'goog.testing.ExpectedFailures',
  'goog.testing.i18n.asserts'
]);
goog.addDependency('testing/jsunit.js', ['goog.testing.jsunit'], [
  'goog.testing.TestCase',
  'goog.testing.TestRunner'
]);
goog.addDependency('testing/loosemock.js', [
  'goog.testing.LooseExpectationCollection',
  'goog.testing.LooseMock'
], [
  'goog.array',
  'goog.structs.Map',
  'goog.testing.Mock'
]);
goog.addDependency('testing/messaging/mockmessagechannel.js', ['goog.testing.messaging.MockMessageChannel'], [
  'goog.messaging.AbstractChannel',
  'goog.testing.asserts'
]);
goog.addDependency('testing/messaging/mockmessageevent.js', ['goog.testing.messaging.MockMessageEvent'], [
  'goog.events.BrowserEvent',
  'goog.events.EventType',
  'goog.testing.events'
]);
goog.addDependency('testing/messaging/mockmessageport.js', ['goog.testing.messaging.MockMessagePort'], ['goog.events.EventTarget']);
goog.addDependency('testing/messaging/mockportnetwork.js', ['goog.testing.messaging.MockPortNetwork'], [
  'goog.messaging.PortNetwork',
  'goog.testing.messaging.MockMessageChannel'
]);
goog.addDependency('testing/mock.js', [
  'goog.testing.Mock',
  'goog.testing.MockExpectation'
], [
  'goog.array',
  'goog.object',
  'goog.testing.JsUnitException',
  'goog.testing.MockInterface',
  'goog.testing.mockmatchers'
]);
goog.addDependency('testing/mockclassfactory.js', [
  'goog.testing.MockClassFactory',
  'goog.testing.MockClassRecord'
], [
  'goog.array',
  'goog.object',
  'goog.testing.LooseMock',
  'goog.testing.StrictMock',
  'goog.testing.TestCase',
  'goog.testing.mockmatchers'
]);
goog.addDependency('testing/mockclock.js', ['goog.testing.MockClock'], [
  'goog.Disposable',
  'goog.testing.PropertyReplacer',
  'goog.testing.events',
  'goog.testing.events.Event'
]);
goog.addDependency('testing/mockcontrol.js', ['goog.testing.MockControl'], [
  'goog.array',
  'goog.testing',
  'goog.testing.LooseMock',
  'goog.testing.MockInterface',
  'goog.testing.StrictMock'
]);
goog.addDependency('testing/mockinterface.js', ['goog.testing.MockInterface'], []);
goog.addDependency('testing/mockmatchers.js', [
  'goog.testing.mockmatchers',
  'goog.testing.mockmatchers.ArgumentMatcher',
  'goog.testing.mockmatchers.IgnoreArgument',
  'goog.testing.mockmatchers.InstanceOf',
  'goog.testing.mockmatchers.ObjectEquals',
  'goog.testing.mockmatchers.RegexpMatch',
  'goog.testing.mockmatchers.SaveArgument',
  'goog.testing.mockmatchers.TypeOf'
], [
  'goog.array',
  'goog.dom',
  'goog.testing.asserts'
]);
goog.addDependency('testing/mockrandom.js', ['goog.testing.MockRandom'], ['goog.Disposable']);
goog.addDependency('testing/mockrange.js', ['goog.testing.MockRange'], [
  'goog.dom.AbstractRange',
  'goog.testing.LooseMock'
]);
goog.addDependency('testing/mockstorage.js', ['goog.testing.MockStorage'], ['goog.structs.Map']);
goog.addDependency('testing/mockuseragent.js', ['goog.testing.MockUserAgent'], [
  'goog.Disposable',
  'goog.userAgent'
]);
goog.addDependency('testing/multitestrunner.js', [
  'goog.testing.MultiTestRunner',
  'goog.testing.MultiTestRunner.TestFrame'
], [
  'goog.Timer',
  'goog.array',
  'goog.dom',
  'goog.dom.classes',
  'goog.events.EventHandler',
  'goog.functions',
  'goog.string',
  'goog.ui.Component',
  'goog.ui.ServerChart',
  'goog.ui.TableSorter'
]);
goog.addDependency('testing/net/xhrio.js', ['goog.testing.net.XhrIo'], [
  'goog.array',
  'goog.dom.xml',
  'goog.events',
  'goog.events.EventTarget',
  'goog.json',
  'goog.net.ErrorCode',
  'goog.net.EventType',
  'goog.net.HttpStatus',
  'goog.net.XhrIo',
  'goog.net.XmlHttp',
  'goog.object',
  'goog.structs.Map'
]);
goog.addDependency('testing/net/xhriopool.js', ['goog.testing.net.XhrIoPool'], [
  'goog.net.XhrIoPool',
  'goog.testing.net.XhrIo'
]);
goog.addDependency('testing/objectpropertystring.js', ['goog.testing.ObjectPropertyString'], []);
goog.addDependency('testing/performancetable.js', ['goog.testing.PerformanceTable'], [
  'goog.dom',
  'goog.testing.PerformanceTimer'
]);
goog.addDependency('testing/performancetimer.js', [
  'goog.testing.PerformanceTimer',
  'goog.testing.PerformanceTimer.Task'
], [
  'goog.array',
  'goog.async.Deferred',
  'goog.math'
]);
goog.addDependency('testing/propertyreplacer.js', ['goog.testing.PropertyReplacer'], ['goog.userAgent']);
goog.addDependency('testing/proto2/proto2.js', ['goog.testing.proto2'], [
  'goog.proto2.Message',
  'goog.testing.asserts'
]);
goog.addDependency('testing/pseudorandom.js', ['goog.testing.PseudoRandom'], ['goog.Disposable']);
goog.addDependency('testing/recordfunction.js', [
  'goog.testing.FunctionCall',
  'goog.testing.recordConstructor',
  'goog.testing.recordFunction'
], []);
goog.addDependency('testing/shardingtestcase.js', ['goog.testing.ShardingTestCase'], [
  'goog.asserts',
  'goog.testing.TestCase'
]);
goog.addDependency('testing/singleton.js', ['goog.testing.singleton'], []);
goog.addDependency('testing/stacktrace.js', [
  'goog.testing.stacktrace',
  'goog.testing.stacktrace.Frame'
], []);
goog.addDependency('testing/storage/fakemechanism.js', ['goog.testing.storage.FakeMechanism'], [
  'goog.storage.mechanism.IterableMechanism',
  'goog.structs.Map'
]);
goog.addDependency('testing/strictmock.js', ['goog.testing.StrictMock'], [
  'goog.array',
  'goog.testing.Mock'
]);
goog.addDependency('testing/style/layoutasserts.js', ['goog.testing.style.layoutasserts'], [
  'goog.style',
  'goog.testing.asserts',
  'goog.testing.style'
]);
goog.addDependency('testing/style/style.js', ['goog.testing.style'], [
  'goog.dom',
  'goog.math.Rect',
  'goog.style'
]);
goog.addDependency('testing/testcase.js', [
  'goog.testing.TestCase',
  'goog.testing.TestCase.Error',
  'goog.testing.TestCase.Order',
  'goog.testing.TestCase.Result',
  'goog.testing.TestCase.Test'
], [
  'goog.object',
  'goog.testing.asserts',
  'goog.testing.stacktrace'
]);
goog.addDependency('testing/testqueue.js', ['goog.testing.TestQueue'], []);
goog.addDependency('testing/testrunner.js', ['goog.testing.TestRunner'], ['goog.testing.TestCase']);
goog.addDependency('testing/ui/rendererasserts.js', ['goog.testing.ui.rendererasserts'], ['goog.testing.asserts']);
goog.addDependency('testing/ui/rendererharness.js', ['goog.testing.ui.RendererHarness'], [
  'goog.Disposable',
  'goog.dom.NodeType',
  'goog.testing.asserts',
  'goog.testing.dom'
]);
goog.addDependency('testing/ui/style.js', ['goog.testing.ui.style'], [
  'goog.array',
  'goog.dom',
  'goog.dom.classes',
  'goog.testing.asserts'
]);
goog.addDependency('timer/timer.js', ['goog.Timer'], ['goog.events.EventTarget']);
goog.addDependency('tweak/entries.js', [
  'goog.tweak.BaseEntry',
  'goog.tweak.BasePrimitiveSetting',
  'goog.tweak.BaseSetting',
  'goog.tweak.BooleanGroup',
  'goog.tweak.BooleanInGroupSetting',
  'goog.tweak.BooleanSetting',
  'goog.tweak.ButtonAction',
  'goog.tweak.NumericSetting',
  'goog.tweak.StringSetting'
], [
  'goog.array',
  'goog.asserts',
  'goog.log',
  'goog.object'
]);
goog.addDependency('tweak/registry.js', ['goog.tweak.Registry'], [
  'goog.asserts',
  'goog.log',
  'goog.object',
  'goog.string',
  'goog.tweak.BaseEntry',
  'goog.uri.utils'
]);
goog.addDependency('tweak/testhelpers.js', ['goog.tweak.testhelpers'], [
  'goog.tweak',
  'goog.tweak.BooleanGroup',
  'goog.tweak.BooleanInGroupSetting',
  'goog.tweak.BooleanSetting',
  'goog.tweak.ButtonAction',
  'goog.tweak.NumericSetting',
  'goog.tweak.Registry',
  'goog.tweak.StringSetting'
]);
goog.addDependency('tweak/tweak.js', [
  'goog.tweak',
  'goog.tweak.ConfigParams'
], [
  'goog.asserts',
  'goog.tweak.BaseSetting',
  'goog.tweak.BooleanGroup',
  'goog.tweak.BooleanInGroupSetting',
  'goog.tweak.BooleanSetting',
  'goog.tweak.ButtonAction',
  'goog.tweak.NumericSetting',
  'goog.tweak.Registry',
  'goog.tweak.StringSetting'
]);
goog.addDependency('tweak/tweakui.js', [
  'goog.tweak.EntriesPanel',
  'goog.tweak.TweakUi'
], [
  'goog.array',
  'goog.asserts',
  'goog.dom.DomHelper',
  'goog.object',
  'goog.style',
  'goog.tweak',
  'goog.ui.Zippy',
  'goog.userAgent'
]);
goog.addDependency('ui/abstractspellchecker.js', [
  'goog.ui.AbstractSpellChecker',
  'goog.ui.AbstractSpellChecker.AsyncResult'
], [
  'goog.a11y.aria',
  'goog.array',
  'goog.asserts',
  'goog.dom',
  'goog.dom.NodeType',
  'goog.dom.classes',
  'goog.dom.selection',
  'goog.events',
  'goog.events.Event',
  'goog.events.EventType',
  'goog.math.Coordinate',
  'goog.spell.SpellCheck',
  'goog.structs.Set',
  'goog.style',
  'goog.ui.Component',
  'goog.ui.MenuItem',
  'goog.ui.MenuSeparator',
  'goog.ui.PopupMenu'
]);
goog.addDependency('ui/ac/ac.js', ['goog.ui.ac'], [
  'goog.ui.ac.ArrayMatcher',
  'goog.ui.ac.AutoComplete',
  'goog.ui.ac.InputHandler',
  'goog.ui.ac.Renderer'
]);
goog.addDependency('ui/ac/arraymatcher.js', ['goog.ui.ac.ArrayMatcher'], ['goog.string']);
goog.addDependency('ui/ac/autocomplete.js', [
  'goog.ui.ac.AutoComplete',
  'goog.ui.ac.AutoComplete.EventType'
], [
  'goog.array',
  'goog.asserts',
  'goog.events',
  'goog.events.EventTarget',
  'goog.object'
]);
goog.addDependency('ui/ac/inputhandler.js', ['goog.ui.ac.InputHandler'], [
  'goog.Disposable',
  'goog.Timer',
  'goog.a11y.aria',
  'goog.dom',
  'goog.dom.selection',
  'goog.events.EventHandler',
  'goog.events.EventType',
  'goog.events.KeyCodes',
  'goog.events.KeyHandler',
  'goog.string',
  'goog.userAgent',
  'goog.userAgent.product'
]);
goog.addDependency('ui/ac/remote.js', ['goog.ui.ac.Remote'], [
  'goog.ui.ac.AutoComplete',
  'goog.ui.ac.InputHandler',
  'goog.ui.ac.RemoteArrayMatcher',
  'goog.ui.ac.Renderer'
]);
goog.addDependency('ui/ac/remotearraymatcher.js', ['goog.ui.ac.RemoteArrayMatcher'], [
  'goog.Disposable',
  'goog.Uri',
  'goog.events',
  'goog.json',
  'goog.net.EventType',
  'goog.net.XhrIo'
]);
goog.addDependency('ui/ac/renderer.js', [
  'goog.ui.ac.Renderer',
  'goog.ui.ac.Renderer.CustomRenderer'
], [
  'goog.a11y.aria',
  'goog.a11y.aria.Role',
  'goog.a11y.aria.State',
  'goog.array',
  'goog.dispose',
  'goog.dom',
  'goog.dom.NodeType',
  'goog.dom.classes',
  'goog.events',
  'goog.events.EventTarget',
  'goog.events.EventType',
  'goog.fx.dom.FadeInAndShow',
  'goog.fx.dom.FadeOutAndHide',
  'goog.positioning',
  'goog.positioning.Corner',
  'goog.positioning.Overflow',
  'goog.string',
  'goog.style',
  'goog.ui.IdGenerator',
  'goog.ui.ac.AutoComplete'
]);
goog.addDependency('ui/ac/renderoptions.js', ['goog.ui.ac.RenderOptions'], []);
goog.addDependency('ui/ac/richinputhandler.js', ['goog.ui.ac.RichInputHandler'], ['goog.ui.ac.InputHandler']);
goog.addDependency('ui/ac/richremote.js', ['goog.ui.ac.RichRemote'], [
  'goog.ui.ac.AutoComplete',
  'goog.ui.ac.Remote',
  'goog.ui.ac.Renderer',
  'goog.ui.ac.RichInputHandler',
  'goog.ui.ac.RichRemoteArrayMatcher'
]);
goog.addDependency('ui/ac/richremotearraymatcher.js', ['goog.ui.ac.RichRemoteArrayMatcher'], [
  'goog.json',
  'goog.ui.ac.RemoteArrayMatcher'
]);
goog.addDependency('ui/activitymonitor.js', ['goog.ui.ActivityMonitor'], [
  'goog.array',
  'goog.asserts',
  'goog.dom',
  'goog.events.EventHandler',
  'goog.events.EventTarget',
  'goog.events.EventType'
]);
goog.addDependency('ui/advancedtooltip.js', ['goog.ui.AdvancedTooltip'], [
  'goog.events',
  'goog.events.EventType',
  'goog.math.Box',
  'goog.math.Coordinate',
  'goog.style',
  'goog.ui.Tooltip',
  'goog.userAgent'
]);
goog.addDependency('ui/animatedzippy.js', ['goog.ui.AnimatedZippy'], [
  'goog.dom',
  'goog.events',
  'goog.fx.Animation',
  'goog.fx.Transition',
  'goog.fx.easing',
  'goog.ui.Zippy',
  'goog.ui.ZippyEvent'
]);
goog.addDependency('ui/attachablemenu.js', ['goog.ui.AttachableMenu'], [
  'goog.a11y.aria',
  'goog.a11y.aria.State',
  'goog.array',
  'goog.asserts',
  'goog.dom',
  'goog.dom.classes',
  'goog.events.Event',
  'goog.events.KeyCodes',
  'goog.string',
  'goog.style',
  'goog.ui.ItemEvent',
  'goog.ui.MenuBase',
  'goog.ui.PopupBase',
  'goog.userAgent'
]);
goog.addDependency('ui/bidiinput.js', ['goog.ui.BidiInput'], [
  'goog.dom',
  'goog.events',
  'goog.events.InputHandler',
  'goog.i18n.bidi',
  'goog.ui.Component'
]);
goog.addDependency('ui/bubble.js', ['goog.ui.Bubble'], [
  'goog.Timer',
  'goog.events',
  'goog.events.EventType',
  'goog.math.Box',
  'goog.positioning',
  'goog.positioning.AbsolutePosition',
  'goog.positioning.AnchoredPosition',
  'goog.positioning.Corner',
  'goog.positioning.CornerBit',
  'goog.style',
  'goog.ui.Component',
  'goog.ui.Popup'
]);
goog.addDependency('ui/button.js', [
  'goog.ui.Button',
  'goog.ui.Button.Side'
], [
  'goog.events.EventType',
  'goog.events.KeyCodes',
  'goog.events.KeyHandler',
  'goog.ui.ButtonRenderer',
  'goog.ui.ButtonSide',
  'goog.ui.Component',
  'goog.ui.Control',
  'goog.ui.NativeButtonRenderer',
  'goog.ui.registry'
]);
goog.addDependency('ui/buttonrenderer.js', ['goog.ui.ButtonRenderer'], [
  'goog.a11y.aria',
  'goog.a11y.aria.Role',
  'goog.a11y.aria.State',
  'goog.asserts',
  'goog.ui.ButtonSide',
  'goog.ui.Component',
  'goog.ui.ControlRenderer'
]);
goog.addDependency('ui/buttonside.js', ['goog.ui.ButtonSide'], []);
goog.addDependency('ui/charcounter.js', [
  'goog.ui.CharCounter',
  'goog.ui.CharCounter.Display'
], [
  'goog.dom',
  'goog.events',
  'goog.events.EventTarget',
  'goog.events.InputHandler'
]);
goog.addDependency('ui/charpicker.js', ['goog.ui.CharPicker'], [
  'goog.a11y.aria',
  'goog.a11y.aria.State',
  'goog.array',
  'goog.asserts',
  'goog.dom.classes',
  'goog.events',
  'goog.events.Event',
  'goog.events.EventHandler',
  'goog.events.EventType',
  'goog.events.InputHandler',
  'goog.events.KeyCodes',
  'goog.events.KeyHandler',
  'goog.i18n.CharListDecompressor',
  'goog.i18n.uChar',
  'goog.structs.Set',
  'goog.style',
  'goog.ui.Button',
  'goog.ui.Component',
  'goog.ui.ContainerScroller',
  'goog.ui.FlatButtonRenderer',
  'goog.ui.HoverCard',
  'goog.ui.LabelInput',
  'goog.ui.Menu',
  'goog.ui.MenuButton',
  'goog.ui.MenuItem',
  'goog.ui.Tooltip'
]);
goog.addDependency('ui/checkbox.js', [
  'goog.ui.Checkbox',
  'goog.ui.Checkbox.State'
], [
  'goog.a11y.aria',
  'goog.a11y.aria.State',
  'goog.asserts',
  'goog.events.EventType',
  'goog.events.KeyCodes',
  'goog.ui.CheckboxRenderer',
  'goog.ui.Component.EventType',
  'goog.ui.Component.State',
  'goog.ui.Control',
  'goog.ui.registry'
]);
goog.addDependency('ui/checkboxmenuitem.js', ['goog.ui.CheckBoxMenuItem'], [
  'goog.ui.MenuItem',
  'goog.ui.registry'
]);
goog.addDependency('ui/checkboxrenderer.js', ['goog.ui.CheckboxRenderer'], [
  'goog.a11y.aria',
  'goog.a11y.aria.Role',
  'goog.a11y.aria.State',
  'goog.array',
  'goog.asserts',
  'goog.dom.classes',
  'goog.object',
  'goog.ui.ControlRenderer'
]);
goog.addDependency('ui/colorbutton.js', ['goog.ui.ColorButton'], [
  'goog.ui.Button',
  'goog.ui.ColorButtonRenderer',
  'goog.ui.registry'
]);
goog.addDependency('ui/colorbuttonrenderer.js', ['goog.ui.ColorButtonRenderer'], [
  'goog.dom.classes',
  'goog.functions',
  'goog.ui.ColorMenuButtonRenderer'
]);
goog.addDependency('ui/colormenubutton.js', ['goog.ui.ColorMenuButton'], [
  'goog.array',
  'goog.object',
  'goog.ui.ColorMenuButtonRenderer',
  'goog.ui.ColorPalette',
  'goog.ui.Component',
  'goog.ui.Menu',
  'goog.ui.MenuButton',
  'goog.ui.registry'
]);
goog.addDependency('ui/colormenubuttonrenderer.js', ['goog.ui.ColorMenuButtonRenderer'], [
  'goog.color',
  'goog.dom.classes',
  'goog.ui.MenuButtonRenderer',
  'goog.userAgent'
]);
goog.addDependency('ui/colorpalette.js', ['goog.ui.ColorPalette'], [
  'goog.array',
  'goog.color',
  'goog.style',
  'goog.ui.Palette',
  'goog.ui.PaletteRenderer'
]);
goog.addDependency('ui/colorpicker.js', [
  'goog.ui.ColorPicker',
  'goog.ui.ColorPicker.EventType'
], [
  'goog.ui.ColorPalette',
  'goog.ui.Component'
]);
goog.addDependency('ui/colorsplitbehavior.js', ['goog.ui.ColorSplitBehavior'], [
  'goog.ui.ColorMenuButton',
  'goog.ui.SplitBehavior'
]);
goog.addDependency('ui/combobox.js', [
  'goog.ui.ComboBox',
  'goog.ui.ComboBoxItem'
], [
  'goog.Timer',
  'goog.dom',
  'goog.dom.classlist',
  'goog.events.EventType',
  'goog.events.InputHandler',
  'goog.events.KeyCodes',
  'goog.events.KeyHandler',
  'goog.log',
  'goog.positioning.Corner',
  'goog.positioning.MenuAnchoredPosition',
  'goog.string',
  'goog.style',
  'goog.ui.Component',
  'goog.ui.ItemEvent',
  'goog.ui.LabelInput',
  'goog.ui.Menu',
  'goog.ui.MenuItem',
  'goog.ui.MenuSeparator',
  'goog.ui.registry',
  'goog.userAgent'
]);
goog.addDependency('ui/component.js', [
  'goog.ui.Component',
  'goog.ui.Component.Error',
  'goog.ui.Component.EventType',
  'goog.ui.Component.State'
], [
  'goog.array',
  'goog.asserts',
  'goog.dom',
  'goog.dom.NodeType',
  'goog.events.EventHandler',
  'goog.events.EventTarget',
  'goog.object',
  'goog.style',
  'goog.ui.IdGenerator'
]);
goog.addDependency('ui/container.js', [
  'goog.ui.Container',
  'goog.ui.Container.EventType',
  'goog.ui.Container.Orientation'
], [
  'goog.a11y.aria',
  'goog.a11y.aria.State',
  'goog.asserts',
  'goog.dom',
  'goog.events.EventType',
  'goog.events.KeyCodes',
  'goog.events.KeyHandler',
  'goog.object',
  'goog.style',
  'goog.ui.Component',
  'goog.ui.ContainerRenderer',
  'goog.ui.Control'
]);
goog.addDependency('ui/containerrenderer.js', ['goog.ui.ContainerRenderer'], [
  'goog.a11y.aria',
  'goog.array',
  'goog.asserts',
  'goog.dom.NodeType',
  'goog.dom.classes',
  'goog.string',
  'goog.style',
  'goog.ui.registry',
  'goog.userAgent'
]);
goog.addDependency('ui/containerscroller.js', ['goog.ui.ContainerScroller'], [
  'goog.Disposable',
  'goog.Timer',
  'goog.events.EventHandler',
  'goog.style',
  'goog.ui.Component',
  'goog.ui.Container'
]);
goog.addDependency('ui/control.js', ['goog.ui.Control'], [
  'goog.array',
  'goog.dom',
  'goog.events.Event',
  'goog.events.EventType',
  'goog.events.KeyCodes',
  'goog.events.KeyHandler',
  'goog.string',
  'goog.ui.Component',
  'goog.ui.ControlContent',
  'goog.ui.ControlRenderer',
  'goog.ui.decorate',
  'goog.ui.registry',
  'goog.userAgent'
]);
goog.addDependency('ui/controlcontent.js', ['goog.ui.ControlContent'], []);
goog.addDependency('ui/controlrenderer.js', ['goog.ui.ControlRenderer'], [
  'goog.a11y.aria',
  'goog.a11y.aria.State',
  'goog.array',
  'goog.asserts',
  'goog.dom',
  'goog.dom.classes',
  'goog.object',
  'goog.style',
  'goog.ui.Component',
  'goog.userAgent'
]);
goog.addDependency('ui/cookieeditor.js', ['goog.ui.CookieEditor'], [
  'goog.asserts',
  'goog.dom',
  'goog.dom.TagName',
  'goog.events.EventType',
  'goog.net.cookies',
  'goog.string',
  'goog.style',
  'goog.ui.Component'
]);
goog.addDependency('ui/css3buttonrenderer.js', ['goog.ui.Css3ButtonRenderer'], [
  'goog.dom.TagName',
  'goog.dom.classes',
  'goog.ui.Button',
  'goog.ui.ButtonRenderer',
  'goog.ui.Component',
  'goog.ui.INLINE_BLOCK_CLASSNAME',
  'goog.ui.registry'
]);
goog.addDependency('ui/css3menubuttonrenderer.js', ['goog.ui.Css3MenuButtonRenderer'], [
  'goog.dom',
  'goog.dom.TagName',
  'goog.ui.INLINE_BLOCK_CLASSNAME',
  'goog.ui.MenuButton',
  'goog.ui.MenuButtonRenderer',
  'goog.ui.registry'
]);
goog.addDependency('ui/cssnames.js', ['goog.ui.INLINE_BLOCK_CLASSNAME'], []);
goog.addDependency('ui/custombutton.js', ['goog.ui.CustomButton'], [
  'goog.ui.Button',
  'goog.ui.CustomButtonRenderer',
  'goog.ui.registry'
]);
goog.addDependency('ui/custombuttonrenderer.js', ['goog.ui.CustomButtonRenderer'], [
  'goog.a11y.aria.Role',
  'goog.dom.NodeType',
  'goog.dom.classes',
  'goog.string',
  'goog.ui.ButtonRenderer',
  'goog.ui.INLINE_BLOCK_CLASSNAME'
]);
goog.addDependency('ui/customcolorpalette.js', ['goog.ui.CustomColorPalette'], [
  'goog.color',
  'goog.dom',
  'goog.dom.classes',
  'goog.ui.ColorPalette',
  'goog.ui.Component'
]);
goog.addDependency('ui/datepicker.js', [
  'goog.ui.DatePicker',
  'goog.ui.DatePicker.Events',
  'goog.ui.DatePickerEvent'
], [
  'goog.a11y.aria',
  'goog.asserts',
  'goog.date',
  'goog.date.Date',
  'goog.date.Interval',
  'goog.dom',
  'goog.dom.NodeType',
  'goog.dom.classes',
  'goog.events.Event',
  'goog.events.EventType',
  'goog.events.KeyHandler',
  'goog.i18n.DateTimeFormat',
  'goog.i18n.DateTimeSymbols',
  'goog.string',
  'goog.style',
  'goog.ui.Component',
  'goog.ui.DefaultDatePickerRenderer',
  'goog.ui.IdGenerator'
]);
goog.addDependency('ui/datepickerrenderer.js', ['goog.ui.DatePickerRenderer'], []);
goog.addDependency('ui/decorate.js', ['goog.ui.decorate'], ['goog.ui.registry']);
goog.addDependency('ui/defaultdatepickerrenderer.js', ['goog.ui.DefaultDatePickerRenderer'], [
  'goog.dom',
  'goog.dom.TagName',
  'goog.ui.DatePickerRenderer'
]);
goog.addDependency('ui/dialog.js', [
  'goog.ui.Dialog',
  'goog.ui.Dialog.ButtonSet',
  'goog.ui.Dialog.ButtonSet.DefaultButtons',
  'goog.ui.Dialog.DefaultButtonCaptions',
  'goog.ui.Dialog.DefaultButtonKeys',
  'goog.ui.Dialog.Event',
  'goog.ui.Dialog.EventType'
], [
  'goog.a11y.aria',
  'goog.a11y.aria.Role',
  'goog.a11y.aria.State',
  'goog.asserts',
  'goog.dom',
  'goog.dom.NodeType',
  'goog.dom.TagName',
  'goog.dom.classes',
  'goog.events',
  'goog.events.Event',
  'goog.events.EventType',
  'goog.events.KeyCodes',
  'goog.fx.Dragger',
  'goog.math.Rect',
  'goog.structs',
  'goog.structs.Map',
  'goog.style',
  'goog.ui.ModalPopup',
  'goog.userAgent'
]);
goog.addDependency('ui/dimensionpicker.js', ['goog.ui.DimensionPicker'], [
  'goog.events.EventType',
  'goog.events.KeyCodes',
  'goog.math.Size',
  'goog.ui.Component',
  'goog.ui.Control',
  'goog.ui.DimensionPickerRenderer',
  'goog.ui.registry'
]);
goog.addDependency('ui/dimensionpickerrenderer.js', ['goog.ui.DimensionPickerRenderer'], [
  'goog.a11y.aria',
  'goog.a11y.aria.State',
  'goog.dom',
  'goog.dom.TagName',
  'goog.i18n.bidi',
  'goog.style',
  'goog.ui.ControlRenderer',
  'goog.userAgent'
]);
goog.addDependency('ui/dragdropdetector.js', [
  'goog.ui.DragDropDetector',
  'goog.ui.DragDropDetector.EventType',
  'goog.ui.DragDropDetector.ImageDropEvent',
  'goog.ui.DragDropDetector.LinkDropEvent'
], [
  'goog.dom',
  'goog.dom.TagName',
  'goog.events.Event',
  'goog.events.EventHandler',
  'goog.events.EventTarget',
  'goog.events.EventType',
  'goog.math.Coordinate',
  'goog.string',
  'goog.style',
  'goog.userAgent'
]);
goog.addDependency('ui/drilldownrow.js', ['goog.ui.DrilldownRow'], [
  'goog.dom',
  'goog.dom.classes',
  'goog.ui.Component'
]);
goog.addDependency('ui/editor/abstractdialog.js', [
  'goog.ui.editor.AbstractDialog',
  'goog.ui.editor.AbstractDialog.Builder',
  'goog.ui.editor.AbstractDialog.EventType'
], [
  'goog.dom',
  'goog.dom.classes',
  'goog.events.EventTarget',
  'goog.string',
  'goog.ui.Dialog'
]);
goog.addDependency('ui/editor/bubble.js', ['goog.ui.editor.Bubble'], [
  'goog.dom',
  'goog.dom.TagName',
  'goog.dom.ViewportSizeMonitor',
  'goog.dom.classes',
  'goog.editor.style',
  'goog.events.EventHandler',
  'goog.events.EventTarget',
  'goog.events.EventType',
  'goog.log',
  'goog.math.Box',
  'goog.object',
  'goog.positioning',
  'goog.positioning.Corner',
  'goog.positioning.Overflow',
  'goog.positioning.OverflowStatus',
  'goog.string',
  'goog.style',
  'goog.ui.Component',
  'goog.ui.PopupBase',
  'goog.userAgent'
]);
goog.addDependency('ui/editor/defaulttoolbar.js', [
  'goog.ui.editor.ButtonDescriptor',
  'goog.ui.editor.DefaultToolbar'
], [
  'goog.dom',
  'goog.dom.TagName',
  'goog.dom.classes',
  'goog.editor.Command',
  'goog.style',
  'goog.ui.editor.ToolbarFactory',
  'goog.ui.editor.messages',
  'goog.userAgent'
]);
goog.addDependency('ui/editor/equationeditordialog.js', ['goog.ui.editor.EquationEditorDialog'], [
  'goog.editor.Command',
  'goog.ui.Dialog',
  'goog.ui.editor.AbstractDialog',
  'goog.ui.editor.EquationEditorOkEvent',
  'goog.ui.equation.TexEditor'
]);
goog.addDependency('ui/editor/equationeditorokevent.js', ['goog.ui.editor.EquationEditorOkEvent'], [
  'goog.events.Event',
  'goog.ui.editor.AbstractDialog'
]);
goog.addDependency('ui/editor/linkdialog.js', [
  'goog.ui.editor.LinkDialog',
  'goog.ui.editor.LinkDialog.BeforeTestLinkEvent',
  'goog.ui.editor.LinkDialog.EventType',
  'goog.ui.editor.LinkDialog.OkEvent'
], [
  'goog.dom',
  'goog.dom.TagName',
  'goog.editor.BrowserFeature',
  'goog.editor.Link',
  'goog.editor.focus',
  'goog.editor.node',
  'goog.events.Event',
  'goog.events.EventHandler',
  'goog.events.EventType',
  'goog.events.InputHandler',
  'goog.string',
  'goog.style',
  'goog.ui.Button',
  'goog.ui.Component',
  'goog.ui.LinkButtonRenderer',
  'goog.ui.editor.AbstractDialog',
  'goog.ui.editor.TabPane',
  'goog.ui.editor.messages',
  'goog.userAgent',
  'goog.window'
]);
goog.addDependency('ui/editor/messages.js', ['goog.ui.editor.messages'], []);
goog.addDependency('ui/editor/tabpane.js', ['goog.ui.editor.TabPane'], [
  'goog.dom.TagName',
  'goog.dom.classes',
  'goog.events.EventHandler',
  'goog.events.EventType',
  'goog.style',
  'goog.ui.Component',
  'goog.ui.Control',
  'goog.ui.Tab',
  'goog.ui.TabBar'
]);
goog.addDependency('ui/editor/toolbarcontroller.js', ['goog.ui.editor.ToolbarController'], [
  'goog.editor.Field',
  'goog.events.EventHandler',
  'goog.events.EventTarget',
  'goog.ui.Component'
]);
goog.addDependency('ui/editor/toolbarfactory.js', ['goog.ui.editor.ToolbarFactory'], [
  'goog.array',
  'goog.dom',
  'goog.dom.TagName',
  'goog.string',
  'goog.string.Unicode',
  'goog.style',
  'goog.ui.Component',
  'goog.ui.Container',
  'goog.ui.Option',
  'goog.ui.Toolbar',
  'goog.ui.ToolbarButton',
  'goog.ui.ToolbarColorMenuButton',
  'goog.ui.ToolbarMenuButton',
  'goog.ui.ToolbarRenderer',
  'goog.ui.ToolbarSelect',
  'goog.userAgent'
]);
goog.addDependency('ui/emoji/emoji.js', ['goog.ui.emoji.Emoji'], []);
goog.addDependency('ui/emoji/emojipalette.js', ['goog.ui.emoji.EmojiPalette'], [
  'goog.events.EventType',
  'goog.net.ImageLoader',
  'goog.ui.Palette',
  'goog.ui.emoji.Emoji',
  'goog.ui.emoji.EmojiPaletteRenderer'
]);
goog.addDependency('ui/emoji/emojipaletterenderer.js', ['goog.ui.emoji.EmojiPaletteRenderer'], [
  'goog.a11y.aria',
  'goog.dom.NodeType',
  'goog.dom.classes',
  'goog.style',
  'goog.ui.PaletteRenderer',
  'goog.ui.emoji.Emoji'
]);
goog.addDependency('ui/emoji/emojipicker.js', ['goog.ui.emoji.EmojiPicker'], [
  'goog.log',
  'goog.style',
  'goog.ui.Component',
  'goog.ui.TabPane',
  'goog.ui.emoji.Emoji',
  'goog.ui.emoji.EmojiPalette',
  'goog.ui.emoji.EmojiPaletteRenderer',
  'goog.ui.emoji.ProgressiveEmojiPaletteRenderer'
]);
goog.addDependency('ui/emoji/popupemojipicker.js', ['goog.ui.emoji.PopupEmojiPicker'], [
  'goog.events.EventType',
  'goog.positioning.AnchoredPosition',
  'goog.positioning.Corner',
  'goog.ui.Component',
  'goog.ui.Popup',
  'goog.ui.emoji.EmojiPicker'
]);
goog.addDependency('ui/emoji/progressiveemojipaletterenderer.js', ['goog.ui.emoji.ProgressiveEmojiPaletteRenderer'], [
  'goog.style',
  'goog.ui.emoji.EmojiPaletteRenderer'
]);
goog.addDependency('ui/emoji/spriteinfo.js', ['goog.ui.emoji.SpriteInfo'], []);
goog.addDependency('ui/equation/arrowpalette.js', ['goog.ui.equation.ArrowPalette'], [
  'goog.math.Size',
  'goog.ui.equation.Palette'
]);
goog.addDependency('ui/equation/changeevent.js', ['goog.ui.equation.ChangeEvent'], ['goog.events.Event']);
goog.addDependency('ui/equation/comparisonpalette.js', ['goog.ui.equation.ComparisonPalette'], [
  'goog.math.Size',
  'goog.ui.equation.Palette'
]);
goog.addDependency('ui/equation/editorpane.js', ['goog.ui.equation.EditorPane'], [
  'goog.style',
  'goog.ui.Component'
]);
goog.addDependency('ui/equation/equationeditor.js', ['goog.ui.equation.EquationEditor'], [
  'goog.events',
  'goog.ui.Component',
  'goog.ui.TabBar',
  'goog.ui.equation.ImageRenderer',
  'goog.ui.equation.TexPane'
]);
goog.addDependency('ui/equation/equationeditordialog.js', ['goog.ui.equation.EquationEditorDialog'], [
  'goog.dom',
  'goog.dom.classes',
  'goog.ui.Dialog',
  'goog.ui.equation.EquationEditor',
  'goog.ui.equation.PaletteManager',
  'goog.ui.equation.TexEditor'
]);
goog.addDependency('ui/equation/greekpalette.js', ['goog.ui.equation.GreekPalette'], [
  'goog.math.Size',
  'goog.ui.equation.Palette'
]);
goog.addDependency('ui/equation/imagerenderer.js', ['goog.ui.equation.ImageRenderer'], [
  'goog.dom.TagName',
  'goog.dom.classes',
  'goog.string',
  'goog.uri.utils'
]);
goog.addDependency('ui/equation/mathpalette.js', ['goog.ui.equation.MathPalette'], [
  'goog.math.Size',
  'goog.ui.equation.Palette'
]);
goog.addDependency('ui/equation/menupalette.js', [
  'goog.ui.equation.MenuPalette',
  'goog.ui.equation.MenuPaletteRenderer'
], [
  'goog.math.Size',
  'goog.ui.PaletteRenderer',
  'goog.ui.equation.Palette',
  'goog.ui.equation.PaletteRenderer'
]);
goog.addDependency('ui/equation/palette.js', [
  'goog.ui.equation.Palette',
  'goog.ui.equation.PaletteEvent',
  'goog.ui.equation.PaletteRenderer'
], [
  'goog.dom',
  'goog.dom.TagName',
  'goog.events.Event',
  'goog.ui.Palette',
  'goog.ui.PaletteRenderer'
]);
goog.addDependency('ui/equation/palettemanager.js', ['goog.ui.equation.PaletteManager'], [
  'goog.Timer',
  'goog.events.EventHandler',
  'goog.events.EventTarget',
  'goog.ui.equation.ArrowPalette',
  'goog.ui.equation.ComparisonPalette',
  'goog.ui.equation.GreekPalette',
  'goog.ui.equation.MathPalette',
  'goog.ui.equation.MenuPalette',
  'goog.ui.equation.Palette',
  'goog.ui.equation.SymbolPalette'
]);
goog.addDependency('ui/equation/symbolpalette.js', ['goog.ui.equation.SymbolPalette'], [
  'goog.math.Size',
  'goog.ui.equation.Palette'
]);
goog.addDependency('ui/equation/texeditor.js', ['goog.ui.equation.TexEditor'], [
  'goog.ui.Component',
  'goog.ui.equation.ImageRenderer',
  'goog.ui.equation.TexPane'
]);
goog.addDependency('ui/equation/texpane.js', ['goog.ui.equation.TexPane'], [
  'goog.Timer',
  'goog.dom',
  'goog.dom.TagName',
  'goog.dom.selection',
  'goog.events',
  'goog.events.EventType',
  'goog.events.InputHandler',
  'goog.style',
  'goog.ui.equation.ChangeEvent',
  'goog.ui.equation.EditorPane',
  'goog.ui.equation.ImageRenderer',
  'goog.ui.equation.Palette',
  'goog.ui.equation.PaletteEvent'
]);
goog.addDependency('ui/filteredmenu.js', ['goog.ui.FilteredMenu'], [
  'goog.dom',
  'goog.events',
  'goog.events.EventType',
  'goog.events.InputHandler',
  'goog.events.KeyCodes',
  'goog.string',
  'goog.style',
  'goog.ui.Component',
  'goog.ui.FilterObservingMenuItem',
  'goog.ui.Menu',
  'goog.userAgent'
]);
goog.addDependency('ui/filterobservingmenuitem.js', ['goog.ui.FilterObservingMenuItem'], [
  'goog.ui.FilterObservingMenuItemRenderer',
  'goog.ui.MenuItem',
  'goog.ui.registry'
]);
goog.addDependency('ui/filterobservingmenuitemrenderer.js', ['goog.ui.FilterObservingMenuItemRenderer'], ['goog.ui.MenuItemRenderer']);
goog.addDependency('ui/flatbuttonrenderer.js', ['goog.ui.FlatButtonRenderer'], [
  'goog.a11y.aria.Role',
  'goog.dom.classes',
  'goog.ui.Button',
  'goog.ui.ButtonRenderer',
  'goog.ui.INLINE_BLOCK_CLASSNAME',
  'goog.ui.registry'
]);
goog.addDependency('ui/flatmenubuttonrenderer.js', ['goog.ui.FlatMenuButtonRenderer'], [
  'goog.a11y.aria',
  'goog.a11y.aria.State',
  'goog.asserts',
  'goog.dom',
  'goog.string',
  'goog.style',
  'goog.ui.Component',
  'goog.ui.FlatButtonRenderer',
  'goog.ui.INLINE_BLOCK_CLASSNAME',
  'goog.ui.Menu',
  'goog.ui.MenuButton',
  'goog.ui.MenuRenderer',
  'goog.ui.registry'
]);
goog.addDependency('ui/formpost.js', ['goog.ui.FormPost'], [
  'goog.array',
  'goog.dom.TagName',
  'goog.string',
  'goog.string.StringBuffer',
  'goog.ui.Component'
]);
goog.addDependency('ui/gauge.js', [
  'goog.ui.Gauge',
  'goog.ui.GaugeColoredRange'
], [
  'goog.a11y.aria',
  'goog.asserts',
  'goog.events',
  'goog.fx.Animation',
  'goog.fx.Transition',
  'goog.fx.easing',
  'goog.graphics',
  'goog.graphics.Font',
  'goog.graphics.Path',
  'goog.graphics.SolidFill',
  'goog.math',
  'goog.ui.Component',
  'goog.ui.GaugeTheme'
]);
goog.addDependency('ui/gaugetheme.js', ['goog.ui.GaugeTheme'], [
  'goog.graphics.LinearGradient',
  'goog.graphics.SolidFill',
  'goog.graphics.Stroke'
]);
goog.addDependency('ui/hovercard.js', [
  'goog.ui.HoverCard',
  'goog.ui.HoverCard.EventType',
  'goog.ui.HoverCard.TriggerEvent'
], [
  'goog.array',
  'goog.dom',
  'goog.events',
  'goog.events.Event',
  'goog.events.EventType',
  'goog.ui.AdvancedTooltip',
  'goog.ui.PopupBase',
  'goog.ui.Tooltip'
]);
goog.addDependency('ui/hsvapalette.js', ['goog.ui.HsvaPalette'], [
  'goog.array',
  'goog.color.alpha',
  'goog.dom',
  'goog.dom.TagName',
  'goog.events',
  'goog.events.EventType',
  'goog.style',
  'goog.ui.Component',
  'goog.ui.HsvPalette'
]);
goog.addDependency('ui/hsvpalette.js', ['goog.ui.HsvPalette'], [
  'goog.color',
  'goog.dom.TagName',
  'goog.events',
  'goog.events.EventType',
  'goog.events.InputHandler',
  'goog.style',
  'goog.style.bidi',
  'goog.ui.Component',
  'goog.userAgent'
]);
goog.addDependency('ui/idgenerator.js', ['goog.ui.IdGenerator'], []);
goog.addDependency('ui/idletimer.js', ['goog.ui.IdleTimer'], [
  'goog.Timer',
  'goog.events',
  'goog.events.EventTarget',
  'goog.structs.Set',
  'goog.ui.ActivityMonitor'
]);
goog.addDependency('ui/iframemask.js', ['goog.ui.IframeMask'], [
  'goog.Disposable',
  'goog.Timer',
  'goog.dom',
  'goog.dom.iframe',
  'goog.events.EventHandler',
  'goog.style'
]);
goog.addDependency('ui/imagelessbuttonrenderer.js', ['goog.ui.ImagelessButtonRenderer'], [
  'goog.dom.classes',
  'goog.ui.Button',
  'goog.ui.Component',
  'goog.ui.CustomButtonRenderer',
  'goog.ui.INLINE_BLOCK_CLASSNAME',
  'goog.ui.registry'
]);
goog.addDependency('ui/imagelessmenubuttonrenderer.js', ['goog.ui.ImagelessMenuButtonRenderer'], [
  'goog.dom',
  'goog.dom.TagName',
  'goog.dom.classes',
  'goog.ui.INLINE_BLOCK_CLASSNAME',
  'goog.ui.MenuButton',
  'goog.ui.MenuButtonRenderer',
  'goog.ui.registry'
]);
goog.addDependency('ui/inputdatepicker.js', ['goog.ui.InputDatePicker'], [
  'goog.date.DateTime',
  'goog.dom',
  'goog.string',
  'goog.ui.Component',
  'goog.ui.DatePicker',
  'goog.ui.PopupBase',
  'goog.ui.PopupDatePicker'
]);
goog.addDependency('ui/itemevent.js', ['goog.ui.ItemEvent'], ['goog.events.Event']);
goog.addDependency('ui/keyboardshortcuthandler.js', [
  'goog.ui.KeyboardShortcutEvent',
  'goog.ui.KeyboardShortcutHandler',
  'goog.ui.KeyboardShortcutHandler.EventType'
], [
  'goog.Timer',
  'goog.events',
  'goog.events.Event',
  'goog.events.EventTarget',
  'goog.events.EventType',
  'goog.events.KeyCodes',
  'goog.events.KeyNames',
  'goog.object',
  'goog.userAgent'
]);
goog.addDependency('ui/labelinput.js', ['goog.ui.LabelInput'], [
  'goog.Timer',
  'goog.a11y.aria',
  'goog.a11y.aria.State',
  'goog.asserts',
  'goog.dom',
  'goog.dom.classlist',
  'goog.events.EventHandler',
  'goog.events.EventType',
  'goog.ui.Component',
  'goog.userAgent'
]);
goog.addDependency('ui/linkbuttonrenderer.js', ['goog.ui.LinkButtonRenderer'], [
  'goog.ui.Button',
  'goog.ui.FlatButtonRenderer',
  'goog.ui.registry'
]);
goog.addDependency('ui/media/flashobject.js', [
  'goog.ui.media.FlashObject',
  'goog.ui.media.FlashObject.ScriptAccessLevel',
  'goog.ui.media.FlashObject.Wmodes'
], [
  'goog.asserts',
  'goog.events.Event',
  'goog.events.EventHandler',
  'goog.events.EventType',
  'goog.log',
  'goog.object',
  'goog.string',
  'goog.structs.Map',
  'goog.style',
  'goog.ui.Component',
  'goog.userAgent',
  'goog.userAgent.flash'
]);
goog.addDependency('ui/media/flickr.js', [
  'goog.ui.media.FlickrSet',
  'goog.ui.media.FlickrSetModel'
], [
  'goog.ui.media.FlashObject',
  'goog.ui.media.Media',
  'goog.ui.media.MediaModel',
  'goog.ui.media.MediaRenderer'
]);
goog.addDependency('ui/media/googlevideo.js', [
  'goog.ui.media.GoogleVideo',
  'goog.ui.media.GoogleVideoModel'
], [
  'goog.string',
  'goog.ui.media.FlashObject',
  'goog.ui.media.Media',
  'goog.ui.media.MediaModel',
  'goog.ui.media.MediaRenderer'
]);
goog.addDependency('ui/media/media.js', [
  'goog.ui.media.Media',
  'goog.ui.media.MediaRenderer'
], [
  'goog.style',
  'goog.ui.Component',
  'goog.ui.Control',
  'goog.ui.ControlRenderer'
]);
goog.addDependency('ui/media/mediamodel.js', [
  'goog.ui.media.MediaModel',
  'goog.ui.media.MediaModel.Category',
  'goog.ui.media.MediaModel.Credit',
  'goog.ui.media.MediaModel.Credit.Role',
  'goog.ui.media.MediaModel.Credit.Scheme',
  'goog.ui.media.MediaModel.Medium',
  'goog.ui.media.MediaModel.MimeType',
  'goog.ui.media.MediaModel.Player',
  'goog.ui.media.MediaModel.SubTitle',
  'goog.ui.media.MediaModel.Thumbnail'
], ['goog.array']);
goog.addDependency('ui/media/mp3.js', ['goog.ui.media.Mp3'], [
  'goog.string',
  'goog.ui.media.FlashObject',
  'goog.ui.media.Media',
  'goog.ui.media.MediaRenderer'
]);
goog.addDependency('ui/media/photo.js', ['goog.ui.media.Photo'], [
  'goog.ui.media.Media',
  'goog.ui.media.MediaRenderer'
]);
goog.addDependency('ui/media/picasa.js', [
  'goog.ui.media.PicasaAlbum',
  'goog.ui.media.PicasaAlbumModel'
], [
  'goog.ui.media.FlashObject',
  'goog.ui.media.Media',
  'goog.ui.media.MediaModel',
  'goog.ui.media.MediaRenderer'
]);
goog.addDependency('ui/media/vimeo.js', [
  'goog.ui.media.Vimeo',
  'goog.ui.media.VimeoModel'
], [
  'goog.string',
  'goog.ui.media.FlashObject',
  'goog.ui.media.Media',
  'goog.ui.media.MediaModel',
  'goog.ui.media.MediaRenderer'
]);
goog.addDependency('ui/media/youtube.js', [
  'goog.ui.media.Youtube',
  'goog.ui.media.YoutubeModel'
], [
  'goog.string',
  'goog.ui.Component',
  'goog.ui.media.FlashObject',
  'goog.ui.media.Media',
  'goog.ui.media.MediaModel',
  'goog.ui.media.MediaRenderer'
]);
goog.addDependency('ui/menu.js', [
  'goog.ui.Menu',
  'goog.ui.Menu.EventType'
], [
  'goog.math.Coordinate',
  'goog.string',
  'goog.style',
  'goog.ui.Component.EventType',
  'goog.ui.Component.State',
  'goog.ui.Container',
  'goog.ui.Container.Orientation',
  'goog.ui.MenuHeader',
  'goog.ui.MenuItem',
  'goog.ui.MenuRenderer',
  'goog.ui.MenuSeparator'
]);
goog.addDependency('ui/menubar.js', ['goog.ui.menuBar'], [
  'goog.ui.Container',
  'goog.ui.MenuBarRenderer'
]);
goog.addDependency('ui/menubardecorator.js', ['goog.ui.menuBarDecorator'], [
  'goog.ui.MenuBarRenderer',
  'goog.ui.menuBar',
  'goog.ui.registry'
]);
goog.addDependency('ui/menubarrenderer.js', ['goog.ui.MenuBarRenderer'], [
  'goog.a11y.aria.Role',
  'goog.ui.Container',
  'goog.ui.ContainerRenderer'
]);
goog.addDependency('ui/menubase.js', ['goog.ui.MenuBase'], [
  'goog.events.EventHandler',
  'goog.events.EventType',
  'goog.events.KeyHandler',
  'goog.ui.Popup'
]);
goog.addDependency('ui/menubutton.js', ['goog.ui.MenuButton'], [
  'goog.Timer',
  'goog.a11y.aria',
  'goog.a11y.aria.State',
  'goog.asserts',
  'goog.dom',
  'goog.events.EventType',
  'goog.events.KeyCodes',
  'goog.events.KeyHandler',
  'goog.math.Box',
  'goog.math.Rect',
  'goog.positioning',
  'goog.positioning.Corner',
  'goog.positioning.MenuAnchoredPosition',
  'goog.positioning.Overflow',
  'goog.style',
  'goog.ui.Button',
  'goog.ui.Component',
  'goog.ui.Menu',
  'goog.ui.MenuButtonRenderer',
  'goog.ui.registry',
  'goog.userAgent',
  'goog.userAgent.product'
]);
goog.addDependency('ui/menubuttonrenderer.js', ['goog.ui.MenuButtonRenderer'], [
  'goog.a11y.aria',
  'goog.a11y.aria.State',
  'goog.asserts',
  'goog.dom',
  'goog.string',
  'goog.style',
  'goog.ui.Component',
  'goog.ui.CustomButtonRenderer',
  'goog.ui.INLINE_BLOCK_CLASSNAME',
  'goog.ui.Menu',
  'goog.ui.MenuRenderer',
  'goog.userAgent'
]);
goog.addDependency('ui/menuheader.js', ['goog.ui.MenuHeader'], [
  'goog.ui.Component',
  'goog.ui.Control',
  'goog.ui.MenuHeaderRenderer',
  'goog.ui.registry'
]);
goog.addDependency('ui/menuheaderrenderer.js', ['goog.ui.MenuHeaderRenderer'], ['goog.ui.ControlRenderer']);
goog.addDependency('ui/menuitem.js', ['goog.ui.MenuItem'], [
  'goog.array',
  'goog.dom',
  'goog.dom.classes',
  'goog.math.Coordinate',
  'goog.string',
  'goog.ui.Component',
  'goog.ui.Control',
  'goog.ui.MenuItemRenderer',
  'goog.ui.registry'
]);
goog.addDependency('ui/menuitemrenderer.js', ['goog.ui.MenuItemRenderer'], [
  'goog.a11y.aria',
  'goog.a11y.aria.Role',
  'goog.dom',
  'goog.dom.classes',
  'goog.ui.Component',
  'goog.ui.ControlRenderer'
]);
goog.addDependency('ui/menurenderer.js', ['goog.ui.MenuRenderer'], [
  'goog.a11y.aria',
  'goog.a11y.aria.Role',
  'goog.a11y.aria.State',
  'goog.asserts',
  'goog.dom',
  'goog.ui.ContainerRenderer',
  'goog.ui.Separator'
]);
goog.addDependency('ui/menuseparator.js', ['goog.ui.MenuSeparator'], [
  'goog.ui.MenuSeparatorRenderer',
  'goog.ui.Separator',
  'goog.ui.registry'
]);
goog.addDependency('ui/menuseparatorrenderer.js', ['goog.ui.MenuSeparatorRenderer'], [
  'goog.dom',
  'goog.dom.classes',
  'goog.ui.ControlContent',
  'goog.ui.ControlRenderer'
]);
goog.addDependency('ui/mockactivitymonitor.js', ['goog.ui.MockActivityMonitor'], [
  'goog.events.EventType',
  'goog.ui.ActivityMonitor'
]);
goog.addDependency('ui/mockactivitymonitor_test.js', ['goog.ui.MockActivityMonitorTest'], [
  'goog.events',
  'goog.functions',
  'goog.testing.jsunit',
  'goog.testing.recordFunction',
  'goog.ui.ActivityMonitor',
  'goog.ui.MockActivityMonitor'
]);
goog.addDependency('ui/modalpopup.js', ['goog.ui.ModalPopup'], [
  'goog.Timer',
  'goog.a11y.aria',
  'goog.a11y.aria.State',
  'goog.asserts',
  'goog.dom',
  'goog.dom.NodeType',
  'goog.dom.TagName',
  'goog.dom.classes',
  'goog.dom.iframe',
  'goog.events',
  'goog.events.EventType',
  'goog.events.FocusHandler',
  'goog.fx.Transition',
  'goog.style',
  'goog.ui.Component',
  'goog.ui.PopupBase',
  'goog.userAgent'
]);
goog.addDependency('ui/nativebuttonrenderer.js', ['goog.ui.NativeButtonRenderer'], [
  'goog.dom.classes',
  'goog.events.EventType',
  'goog.ui.ButtonRenderer',
  'goog.ui.Component'
]);
goog.addDependency('ui/offlineinstalldialog.js', [
  'goog.ui.OfflineInstallDialog',
  'goog.ui.OfflineInstallDialog.ButtonKeyType',
  'goog.ui.OfflineInstallDialog.EnableScreen',
  'goog.ui.OfflineInstallDialog.InstallScreen',
  'goog.ui.OfflineInstallDialog.InstallingGearsScreen',
  'goog.ui.OfflineInstallDialog.ScreenType',
  'goog.ui.OfflineInstallDialog.UpgradeScreen',
  'goog.ui.OfflineInstallDialogScreen'
], [
  'goog.Disposable',
  'goog.dom.classes',
  'goog.gears',
  'goog.string',
  'goog.string.StringBuffer',
  'goog.ui.Dialog',
  'goog.window'
]);
goog.addDependency('ui/offlinestatuscard.js', [
  'goog.ui.OfflineStatusCard',
  'goog.ui.OfflineStatusCard.EventType'
], [
  'goog.dom',
  'goog.events.EventType',
  'goog.gears.StatusType',
  'goog.structs.Map',
  'goog.style',
  'goog.ui.Component',
  'goog.ui.ProgressBar'
]);
goog.addDependency('ui/offlinestatuscomponent.js', [
  'goog.ui.OfflineStatusComponent',
  'goog.ui.OfflineStatusComponent.StatusClassNames'
], [
  'goog.dom.classes',
  'goog.events.EventType',
  'goog.gears.StatusType',
  'goog.positioning.AnchoredPosition',
  'goog.positioning.Corner',
  'goog.positioning.Overflow',
  'goog.ui.Component',
  'goog.ui.OfflineStatusCard',
  'goog.ui.Popup'
]);
goog.addDependency('ui/option.js', ['goog.ui.Option'], [
  'goog.ui.Component',
  'goog.ui.MenuItem',
  'goog.ui.registry'
]);
goog.addDependency('ui/palette.js', ['goog.ui.Palette'], [
  'goog.array',
  'goog.dom',
  'goog.events',
  'goog.events.EventType',
  'goog.events.KeyCodes',
  'goog.math.Size',
  'goog.ui.Component',
  'goog.ui.Control',
  'goog.ui.PaletteRenderer',
  'goog.ui.SelectionModel'
]);
goog.addDependency('ui/paletterenderer.js', ['goog.ui.PaletteRenderer'], [
  'goog.a11y.aria',
  'goog.a11y.aria.Role',
  'goog.a11y.aria.State',
  'goog.array',
  'goog.dom',
  'goog.dom.NodeIterator',
  'goog.dom.NodeType',
  'goog.dom.TagName',
  'goog.dom.classes',
  'goog.iter',
  'goog.style',
  'goog.ui.ControlRenderer',
  'goog.userAgent'
]);
goog.addDependency('ui/plaintextspellchecker.js', ['goog.ui.PlainTextSpellChecker'], [
  'goog.Timer',
  'goog.a11y.aria',
  'goog.asserts',
  'goog.dom',
  'goog.events.EventHandler',
  'goog.events.EventType',
  'goog.events.KeyCodes',
  'goog.events.KeyHandler',
  'goog.spell.SpellCheck',
  'goog.style',
  'goog.ui.AbstractSpellChecker',
  'goog.ui.Component',
  'goog.userAgent'
]);
goog.addDependency('ui/popup.js', [
  'goog.ui.Popup',
  'goog.ui.Popup.AbsolutePosition',
  'goog.ui.Popup.AnchoredPosition',
  'goog.ui.Popup.AnchoredViewPortPosition',
  'goog.ui.Popup.ClientPosition',
  'goog.ui.Popup.Corner',
  'goog.ui.Popup.Overflow',
  'goog.ui.Popup.ViewPortClientPosition',
  'goog.ui.Popup.ViewPortPosition'
], [
  'goog.math.Box',
  'goog.positioning.AbsolutePosition',
  'goog.positioning.AnchoredPosition',
  'goog.positioning.AnchoredViewportPosition',
  'goog.positioning.ClientPosition',
  'goog.positioning.Corner',
  'goog.positioning.Overflow',
  'goog.positioning.ViewportClientPosition',
  'goog.positioning.ViewportPosition',
  'goog.style',
  'goog.ui.PopupBase'
]);
goog.addDependency('ui/popupbase.js', [
  'goog.ui.PopupBase',
  'goog.ui.PopupBase.EventType',
  'goog.ui.PopupBase.Type'
], [
  'goog.Timer',
  'goog.dom',
  'goog.events',
  'goog.events.EventHandler',
  'goog.events.EventTarget',
  'goog.events.EventType',
  'goog.events.KeyCodes',
  'goog.fx.Transition',
  'goog.style',
  'goog.userAgent'
]);
goog.addDependency('ui/popupcolorpicker.js', ['goog.ui.PopupColorPicker'], [
  'goog.dom.classes',
  'goog.events.EventType',
  'goog.positioning.AnchoredPosition',
  'goog.positioning.Corner',
  'goog.ui.ColorPicker',
  'goog.ui.Component',
  'goog.ui.Popup'
]);
goog.addDependency('ui/popupdatepicker.js', ['goog.ui.PopupDatePicker'], [
  'goog.events.EventType',
  'goog.positioning.AnchoredPosition',
  'goog.positioning.Corner',
  'goog.style',
  'goog.ui.Component',
  'goog.ui.DatePicker',
  'goog.ui.Popup',
  'goog.ui.PopupBase'
]);
goog.addDependency('ui/popupmenu.js', ['goog.ui.PopupMenu'], [
  'goog.events.EventType',
  'goog.positioning.AnchoredViewportPosition',
  'goog.positioning.Corner',
  'goog.positioning.MenuAnchoredPosition',
  'goog.positioning.ViewportClientPosition',
  'goog.structs',
  'goog.structs.Map',
  'goog.style',
  'goog.ui.Component.EventType',
  'goog.ui.Menu',
  'goog.ui.PopupBase',
  'goog.userAgent'
]);
goog.addDependency('ui/progressbar.js', [
  'goog.ui.ProgressBar',
  'goog.ui.ProgressBar.Orientation'
], [
  'goog.a11y.aria',
  'goog.asserts',
  'goog.dom',
  'goog.dom.classes',
  'goog.events',
  'goog.events.EventType',
  'goog.ui.Component',
  'goog.ui.RangeModel',
  'goog.userAgent'
]);
goog.addDependency('ui/prompt.js', ['goog.ui.Prompt'], [
  'goog.Timer',
  'goog.dom',
  'goog.events',
  'goog.events.EventType',
  'goog.functions',
  'goog.ui.Component',
  'goog.ui.Dialog',
  'goog.userAgent'
]);
goog.addDependency('ui/rangemodel.js', ['goog.ui.RangeModel'], [
  'goog.events.EventTarget',
  'goog.ui.Component'
]);
goog.addDependency('ui/ratings.js', [
  'goog.ui.Ratings',
  'goog.ui.Ratings.EventType'
], [
  'goog.a11y.aria',
  'goog.a11y.aria.Role',
  'goog.a11y.aria.State',
  'goog.asserts',
  'goog.dom.classes',
  'goog.events.EventType',
  'goog.ui.Component'
]);
goog.addDependency('ui/registry.js', ['goog.ui.registry'], ['goog.dom.classes']);
goog.addDependency('ui/richtextspellchecker.js', ['goog.ui.RichTextSpellChecker'], [
  'goog.Timer',
  'goog.dom',
  'goog.dom.NodeType',
  'goog.events',
  'goog.events.EventType',
  'goog.spell.SpellCheck',
  'goog.string.StringBuffer',
  'goog.ui.AbstractSpellChecker'
]);
goog.addDependency('ui/roundedpanel.js', [
  'goog.ui.BaseRoundedPanel',
  'goog.ui.CssRoundedPanel',
  'goog.ui.GraphicsRoundedPanel',
  'goog.ui.RoundedPanel',
  'goog.ui.RoundedPanel.Corner'
], [
  'goog.dom',
  'goog.dom.classes',
  'goog.graphics',
  'goog.graphics.Path',
  'goog.graphics.SolidFill',
  'goog.graphics.Stroke',
  'goog.math',
  'goog.math.Coordinate',
  'goog.style',
  'goog.ui.Component',
  'goog.userAgent'
]);
goog.addDependency('ui/roundedtabrenderer.js', ['goog.ui.RoundedTabRenderer'], [
  'goog.dom',
  'goog.ui.Tab',
  'goog.ui.TabBar',
  'goog.ui.TabRenderer',
  'goog.ui.registry'
]);
goog.addDependency('ui/scrollfloater.js', [
  'goog.ui.ScrollFloater',
  'goog.ui.ScrollFloater.EventType'
], [
  'goog.array',
  'goog.dom',
  'goog.dom.classes',
  'goog.events.EventType',
  'goog.style',
  'goog.ui.Component',
  'goog.userAgent'
]);
goog.addDependency('ui/select.js', ['goog.ui.Select'], [
  'goog.a11y.aria.Role',
  'goog.events.EventType',
  'goog.ui.Component',
  'goog.ui.MenuButton',
  'goog.ui.MenuItem',
  'goog.ui.SelectionModel',
  'goog.ui.registry'
]);
goog.addDependency('ui/selectionmenubutton.js', [
  'goog.ui.SelectionMenuButton',
  'goog.ui.SelectionMenuButton.SelectionState'
], [
  'goog.events.EventType',
  'goog.style',
  'goog.ui.Component',
  'goog.ui.MenuButton',
  'goog.ui.MenuItem',
  'goog.ui.registry'
]);
goog.addDependency('ui/selectionmodel.js', ['goog.ui.SelectionModel'], [
  'goog.array',
  'goog.events.EventTarget',
  'goog.events.EventType'
]);
goog.addDependency('ui/separator.js', ['goog.ui.Separator'], [
  'goog.a11y.aria',
  'goog.asserts',
  'goog.ui.Component',
  'goog.ui.Control',
  'goog.ui.MenuSeparatorRenderer',
  'goog.ui.registry'
]);
goog.addDependency('ui/serverchart.js', [
  'goog.ui.ServerChart',
  'goog.ui.ServerChart.AxisDisplayType',
  'goog.ui.ServerChart.ChartType',
  'goog.ui.ServerChart.EncodingType',
  'goog.ui.ServerChart.Event',
  'goog.ui.ServerChart.LegendPosition',
  'goog.ui.ServerChart.MaximumValue',
  'goog.ui.ServerChart.MultiAxisAlignment',
  'goog.ui.ServerChart.MultiAxisType',
  'goog.ui.ServerChart.UriParam',
  'goog.ui.ServerChart.UriTooLongEvent'
], [
  'goog.Uri',
  'goog.array',
  'goog.asserts',
  'goog.events.Event',
  'goog.string',
  'goog.ui.Component'
]);
goog.addDependency('ui/slider.js', [
  'goog.ui.Slider',
  'goog.ui.Slider.Orientation'
], [
  'goog.a11y.aria',
  'goog.a11y.aria.Role',
  'goog.dom',
  'goog.ui.SliderBase'
]);
goog.addDependency('ui/sliderbase.js', [
  'goog.ui.SliderBase',
  'goog.ui.SliderBase.AnimationFactory',
  'goog.ui.SliderBase.Orientation'
], [
  'goog.Timer',
  'goog.a11y.aria',
  'goog.a11y.aria.Role',
  'goog.a11y.aria.State',
  'goog.array',
  'goog.asserts',
  'goog.dom',
  'goog.dom.classes',
  'goog.events',
  'goog.events.EventType',
  'goog.events.KeyCodes',
  'goog.events.KeyHandler',
  'goog.events.MouseWheelHandler',
  'goog.fx.AnimationParallelQueue',
  'goog.fx.Dragger',
  'goog.fx.Transition',
  'goog.fx.dom.ResizeHeight',
  'goog.fx.dom.ResizeWidth',
  'goog.fx.dom.Slide',
  'goog.math',
  'goog.math.Coordinate',
  'goog.style',
  'goog.style.bidi',
  'goog.ui.Component',
  'goog.ui.RangeModel'
]);
goog.addDependency('ui/splitbehavior.js', [
  'goog.ui.SplitBehavior',
  'goog.ui.SplitBehavior.DefaultHandlers'
], [
  'goog.Disposable',
  'goog.dispose',
  'goog.dom',
  'goog.dom.NodeType',
  'goog.dom.classes',
  'goog.events.EventHandler',
  'goog.ui.ButtonSide',
  'goog.ui.Component',
  'goog.ui.decorate',
  'goog.ui.registry'
]);
goog.addDependency('ui/splitpane.js', [
  'goog.ui.SplitPane',
  'goog.ui.SplitPane.Orientation'
], [
  'goog.dom',
  'goog.dom.classes',
  'goog.events.EventType',
  'goog.fx.Dragger',
  'goog.math.Rect',
  'goog.math.Size',
  'goog.style',
  'goog.ui.Component',
  'goog.userAgent'
]);
goog.addDependency('ui/style/app/buttonrenderer.js', ['goog.ui.style.app.ButtonRenderer'], [
  'goog.dom.classes',
  'goog.ui.Button',
  'goog.ui.CustomButtonRenderer',
  'goog.ui.INLINE_BLOCK_CLASSNAME',
  'goog.ui.registry'
]);
goog.addDependency('ui/style/app/menubuttonrenderer.js', ['goog.ui.style.app.MenuButtonRenderer'], [
  'goog.a11y.aria.Role',
  'goog.array',
  'goog.dom',
  'goog.style',
  'goog.ui.Menu',
  'goog.ui.MenuRenderer',
  'goog.ui.style.app.ButtonRenderer'
]);
goog.addDependency('ui/style/app/primaryactionbuttonrenderer.js', ['goog.ui.style.app.PrimaryActionButtonRenderer'], [
  'goog.ui.Button',
  'goog.ui.registry',
  'goog.ui.style.app.ButtonRenderer'
]);
goog.addDependency('ui/submenu.js', ['goog.ui.SubMenu'], [
  'goog.Timer',
  'goog.dom',
  'goog.dom.classes',
  'goog.events.KeyCodes',
  'goog.positioning.AnchoredViewportPosition',
  'goog.positioning.Corner',
  'goog.style',
  'goog.ui.Component',
  'goog.ui.Menu',
  'goog.ui.MenuItem',
  'goog.ui.SubMenuRenderer',
  'goog.ui.registry'
]);
goog.addDependency('ui/submenurenderer.js', ['goog.ui.SubMenuRenderer'], [
  'goog.a11y.aria',
  'goog.a11y.aria.State',
  'goog.asserts',
  'goog.dom',
  'goog.dom.classes',
  'goog.style',
  'goog.ui.Menu',
  'goog.ui.MenuItemRenderer'
]);
goog.addDependency('ui/tab.js', ['goog.ui.Tab'], [
  'goog.ui.Component',
  'goog.ui.Control',
  'goog.ui.TabRenderer',
  'goog.ui.registry'
]);
goog.addDependency('ui/tabbar.js', [
  'goog.ui.TabBar',
  'goog.ui.TabBar.Location'
], [
  'goog.ui.Component.EventType',
  'goog.ui.Container',
  'goog.ui.Container.Orientation',
  'goog.ui.Tab',
  'goog.ui.TabBarRenderer',
  'goog.ui.registry'
]);
goog.addDependency('ui/tabbarrenderer.js', ['goog.ui.TabBarRenderer'], [
  'goog.a11y.aria.Role',
  'goog.object',
  'goog.ui.ContainerRenderer'
]);
goog.addDependency('ui/tablesorter.js', [
  'goog.ui.TableSorter',
  'goog.ui.TableSorter.EventType'
], [
  'goog.array',
  'goog.dom',
  'goog.dom.TagName',
  'goog.dom.classes',
  'goog.events.EventType',
  'goog.functions',
  'goog.ui.Component'
]);
goog.addDependency('ui/tabpane.js', [
  'goog.ui.TabPane',
  'goog.ui.TabPane.Events',
  'goog.ui.TabPane.TabLocation',
  'goog.ui.TabPane.TabPage',
  'goog.ui.TabPaneEvent'
], [
  'goog.dom',
  'goog.dom.classes',
  'goog.events',
  'goog.events.Event',
  'goog.events.EventTarget',
  'goog.events.EventType',
  'goog.events.KeyCodes',
  'goog.style'
]);
goog.addDependency('ui/tabrenderer.js', ['goog.ui.TabRenderer'], [
  'goog.a11y.aria.Role',
  'goog.ui.Component',
  'goog.ui.ControlRenderer'
]);
goog.addDependency('ui/textarea.js', [
  'goog.ui.Textarea',
  'goog.ui.Textarea.EventType'
], [
  'goog.dom',
  'goog.events.EventType',
  'goog.style',
  'goog.ui.Control',
  'goog.ui.TextareaRenderer',
  'goog.userAgent'
]);
goog.addDependency('ui/textarearenderer.js', ['goog.ui.TextareaRenderer'], [
  'goog.dom.TagName',
  'goog.ui.Component',
  'goog.ui.ControlRenderer'
]);
goog.addDependency('ui/togglebutton.js', ['goog.ui.ToggleButton'], [
  'goog.ui.Button',
  'goog.ui.Component',
  'goog.ui.CustomButtonRenderer',
  'goog.ui.registry'
]);
goog.addDependency('ui/toolbar.js', ['goog.ui.Toolbar'], [
  'goog.ui.Container',
  'goog.ui.ToolbarRenderer'
]);
goog.addDependency('ui/toolbarbutton.js', ['goog.ui.ToolbarButton'], [
  'goog.ui.Button',
  'goog.ui.ToolbarButtonRenderer',
  'goog.ui.registry'
]);
goog.addDependency('ui/toolbarbuttonrenderer.js', ['goog.ui.ToolbarButtonRenderer'], ['goog.ui.CustomButtonRenderer']);
goog.addDependency('ui/toolbarcolormenubutton.js', ['goog.ui.ToolbarColorMenuButton'], [
  'goog.ui.ColorMenuButton',
  'goog.ui.ToolbarColorMenuButtonRenderer',
  'goog.ui.registry'
]);
goog.addDependency('ui/toolbarcolormenubuttonrenderer.js', ['goog.ui.ToolbarColorMenuButtonRenderer'], [
  'goog.dom.classes',
  'goog.ui.ColorMenuButtonRenderer',
  'goog.ui.MenuButtonRenderer',
  'goog.ui.ToolbarMenuButtonRenderer'
]);
goog.addDependency('ui/toolbarmenubutton.js', ['goog.ui.ToolbarMenuButton'], [
  'goog.ui.MenuButton',
  'goog.ui.ToolbarMenuButtonRenderer',
  'goog.ui.registry'
]);
goog.addDependency('ui/toolbarmenubuttonrenderer.js', ['goog.ui.ToolbarMenuButtonRenderer'], ['goog.ui.MenuButtonRenderer']);
goog.addDependency('ui/toolbarrenderer.js', ['goog.ui.ToolbarRenderer'], [
  'goog.a11y.aria.Role',
  'goog.ui.Container',
  'goog.ui.ContainerRenderer',
  'goog.ui.Separator',
  'goog.ui.ToolbarSeparatorRenderer'
]);
goog.addDependency('ui/toolbarselect.js', ['goog.ui.ToolbarSelect'], [
  'goog.ui.Select',
  'goog.ui.ToolbarMenuButtonRenderer',
  'goog.ui.registry'
]);
goog.addDependency('ui/toolbarseparator.js', ['goog.ui.ToolbarSeparator'], [
  'goog.ui.Separator',
  'goog.ui.ToolbarSeparatorRenderer',
  'goog.ui.registry'
]);
goog.addDependency('ui/toolbarseparatorrenderer.js', ['goog.ui.ToolbarSeparatorRenderer'], [
  'goog.dom.classes',
  'goog.ui.INLINE_BLOCK_CLASSNAME',
  'goog.ui.MenuSeparatorRenderer'
]);
goog.addDependency('ui/toolbartogglebutton.js', ['goog.ui.ToolbarToggleButton'], [
  'goog.ui.ToggleButton',
  'goog.ui.ToolbarButtonRenderer',
  'goog.ui.registry'
]);
goog.addDependency('ui/tooltip.js', [
  'goog.ui.Tooltip',
  'goog.ui.Tooltip.CursorTooltipPosition',
  'goog.ui.Tooltip.ElementTooltipPosition',
  'goog.ui.Tooltip.State'
], [
  'goog.Timer',
  'goog.array',
  'goog.dom',
  'goog.events',
  'goog.events.EventType',
  'goog.math.Box',
  'goog.math.Coordinate',
  'goog.positioning',
  'goog.positioning.AnchoredPosition',
  'goog.positioning.Corner',
  'goog.positioning.Overflow',
  'goog.positioning.OverflowStatus',
  'goog.positioning.ViewportPosition',
  'goog.structs.Set',
  'goog.style',
  'goog.ui.Popup',
  'goog.ui.PopupBase'
]);
goog.addDependency('ui/tree/basenode.js', [
  'goog.ui.tree.BaseNode',
  'goog.ui.tree.BaseNode.EventType'
], [
  'goog.Timer',
  'goog.a11y.aria',
  'goog.asserts',
  'goog.events.KeyCodes',
  'goog.string',
  'goog.string.StringBuffer',
  'goog.style',
  'goog.ui.Component',
  'goog.userAgent'
]);
goog.addDependency('ui/tree/treecontrol.js', ['goog.ui.tree.TreeControl'], [
  'goog.a11y.aria',
  'goog.asserts',
  'goog.dom.classes',
  'goog.events.EventType',
  'goog.events.FocusHandler',
  'goog.events.KeyHandler',
  'goog.log',
  'goog.ui.tree.BaseNode',
  'goog.ui.tree.TreeNode',
  'goog.ui.tree.TypeAhead',
  'goog.userAgent'
]);
goog.addDependency('ui/tree/treenode.js', ['goog.ui.tree.TreeNode'], ['goog.ui.tree.BaseNode']);
goog.addDependency('ui/tree/typeahead.js', [
  'goog.ui.tree.TypeAhead',
  'goog.ui.tree.TypeAhead.Offset'
], [
  'goog.array',
  'goog.events.KeyCodes',
  'goog.string',
  'goog.structs.Trie'
]);
goog.addDependency('ui/tristatemenuitem.js', [
  'goog.ui.TriStateMenuItem',
  'goog.ui.TriStateMenuItem.State'
], [
  'goog.dom.classes',
  'goog.ui.Component',
  'goog.ui.MenuItem',
  'goog.ui.TriStateMenuItemRenderer',
  'goog.ui.registry'
]);
goog.addDependency('ui/tristatemenuitemrenderer.js', ['goog.ui.TriStateMenuItemRenderer'], [
  'goog.dom.classes',
  'goog.ui.MenuItemRenderer'
]);
goog.addDependency('ui/twothumbslider.js', ['goog.ui.TwoThumbSlider'], [
  'goog.a11y.aria',
  'goog.a11y.aria.Role',
  'goog.dom',
  'goog.ui.SliderBase'
]);
goog.addDependency('ui/zippy.js', [
  'goog.ui.Zippy',
  'goog.ui.Zippy.Events',
  'goog.ui.ZippyEvent'
], [
  'goog.a11y.aria',
  'goog.a11y.aria.Role',
  'goog.a11y.aria.State',
  'goog.dom',
  'goog.dom.classes',
  'goog.events.Event',
  'goog.events.EventHandler',
  'goog.events.EventTarget',
  'goog.events.EventType',
  'goog.events.KeyCodes',
  'goog.style'
]);
goog.addDependency('uri/uri.js', [
  'goog.Uri',
  'goog.Uri.QueryData'
], [
  'goog.array',
  'goog.string',
  'goog.structs',
  'goog.structs.Map',
  'goog.uri.utils',
  'goog.uri.utils.ComponentIndex',
  'goog.uri.utils.StandardQueryParam'
]);
goog.addDependency('uri/uri_test.js', ['goog.UriTest'], [
  'goog.Uri',
  'goog.testing.jsunit'
]);
goog.addDependency('uri/utils.js', [
  'goog.uri.utils',
  'goog.uri.utils.ComponentIndex',
  'goog.uri.utils.QueryArray',
  'goog.uri.utils.QueryValue',
  'goog.uri.utils.StandardQueryParam'
], [
  'goog.asserts',
  'goog.string',
  'goog.userAgent'
]);
goog.addDependency('useragent/adobereader.js', ['goog.userAgent.adobeReader'], [
  'goog.string',
  'goog.userAgent'
]);
goog.addDependency('useragent/flash.js', ['goog.userAgent.flash'], ['goog.string']);
goog.addDependency('useragent/iphoto.js', ['goog.userAgent.iphoto'], [
  'goog.string',
  'goog.userAgent'
]);
goog.addDependency('useragent/jscript.js', ['goog.userAgent.jscript'], ['goog.string']);
goog.addDependency('useragent/picasa.js', ['goog.userAgent.picasa'], [
  'goog.string',
  'goog.userAgent'
]);
goog.addDependency('useragent/platform.js', ['goog.userAgent.platform'], ['goog.userAgent']);
goog.addDependency('useragent/product.js', ['goog.userAgent.product'], ['goog.userAgent']);
goog.addDependency('useragent/product_isversion.js', ['goog.userAgent.product.isVersion'], ['goog.userAgent.product']);
goog.addDependency('useragent/useragent.js', ['goog.userAgent'], ['goog.string']);
goog.addDependency('vec/float32array.js', ['goog.vec.Float32Array'], []);
goog.addDependency('vec/float64array.js', ['goog.vec.Float64Array'], []);
goog.addDependency('vec/mat3.js', ['goog.vec.Mat3'], ['goog.vec']);
goog.addDependency('vec/mat3d.js', [
  'goog.vec.mat3d',
  'goog.vec.mat3d.Type'
], ['goog.vec']);
goog.addDependency('vec/mat3f.js', [
  'goog.vec.mat3f',
  'goog.vec.mat3f.Type'
], ['goog.vec']);
goog.addDependency('vec/mat4.js', ['goog.vec.Mat4'], [
  'goog.vec',
  'goog.vec.Vec3',
  'goog.vec.Vec4'
]);
goog.addDependency('vec/mat4d.js', [
  'goog.vec.mat4d',
  'goog.vec.mat4d.Type'
], [
  'goog.vec',
  'goog.vec.vec3d',
  'goog.vec.vec4d'
]);
goog.addDependency('vec/mat4f.js', [
  'goog.vec.mat4f',
  'goog.vec.mat4f.Type'
], [
  'goog.vec',
  'goog.vec.vec3f',
  'goog.vec.vec4f'
]);
goog.addDependency('vec/matrix3.js', ['goog.vec.Matrix3'], []);
goog.addDependency('vec/matrix4.js', ['goog.vec.Matrix4'], [
  'goog.vec',
  'goog.vec.Vec3',
  'goog.vec.Vec4'
]);
goog.addDependency('vec/quaternion.js', ['goog.vec.Quaternion'], [
  'goog.vec',
  'goog.vec.Vec3',
  'goog.vec.Vec4'
]);
goog.addDependency('vec/ray.js', ['goog.vec.Ray'], ['goog.vec.Vec3']);
goog.addDependency('vec/vec.js', [
  'goog.vec',
  'goog.vec.AnyType',
  'goog.vec.ArrayType',
  'goog.vec.Float32',
  'goog.vec.Float64',
  'goog.vec.Number'
], [
  'goog.vec.Float32Array',
  'goog.vec.Float64Array'
]);
goog.addDependency('vec/vec2.js', ['goog.vec.Vec2'], ['goog.vec']);
goog.addDependency('vec/vec2d.js', [
  'goog.vec.vec2d',
  'goog.vec.vec2d.Type'
], ['goog.vec']);
goog.addDependency('vec/vec2f.js', [
  'goog.vec.vec2f',
  'goog.vec.vec2f.Type'
], ['goog.vec']);
goog.addDependency('vec/vec3.js', ['goog.vec.Vec3'], ['goog.vec']);
goog.addDependency('vec/vec3d.js', [
  'goog.vec.vec3d',
  'goog.vec.vec3d.Type'
], ['goog.vec']);
goog.addDependency('vec/vec3f.js', [
  'goog.vec.vec3f',
  'goog.vec.vec3f.Type'
], ['goog.vec']);
goog.addDependency('vec/vec4.js', ['goog.vec.Vec4'], ['goog.vec']);
goog.addDependency('vec/vec4d.js', [
  'goog.vec.vec4d',
  'goog.vec.vec4d.Type'
], ['goog.vec']);
goog.addDependency('vec/vec4f.js', [
  'goog.vec.vec4f',
  'goog.vec.vec4f.Type'
], ['goog.vec']);
goog.addDependency('webgl/webgl.js', ['goog.webgl'], []);
goog.addDependency('window/window.js', ['goog.window'], [
  'goog.string',
  'goog.userAgent'
]);
goog.provide('goog.string');
goog.provide('goog.string.Unicode');
goog.string.Unicode = { NBSP: '\xa0' };
goog.string.startsWith = function (str, prefix) {
  return str.lastIndexOf(prefix, 0) == 0;
};
goog.string.endsWith = function (str, suffix) {
  var l = str.length - suffix.length;
  return l >= 0 && str.indexOf(suffix, l) == l;
};
goog.string.caseInsensitiveStartsWith = function (str, prefix) {
  return goog.string.caseInsensitiveCompare(prefix, str.substr(0, prefix.length)) == 0;
};
goog.string.caseInsensitiveEndsWith = function (str, suffix) {
  return goog.string.caseInsensitiveCompare(suffix, str.substr(str.length - suffix.length, suffix.length)) == 0;
};
goog.string.caseInsensitiveEquals = function (str1, str2) {
  return str1.toLowerCase() == str2.toLowerCase();
};
goog.string.subs = function (str, var_args) {
  var splitParts = str.split('%s');
  var returnString = '';
  var subsArguments = Array.prototype.slice.call(arguments, 1);
  while (subsArguments.length && splitParts.length > 1) {
    returnString += splitParts.shift() + subsArguments.shift();
  }
  return returnString + splitParts.join('%s');
};
goog.string.collapseWhitespace = function (str) {
  return str.replace(/[\s\xa0]+/g, ' ').replace(/^\s+|\s+$/g, '');
};
goog.string.isEmpty = function (str) {
  return /^[\s\xa0]*$/.test(str);
};
goog.string.isEmptySafe = function (str) {
  return goog.string.isEmpty(goog.string.makeSafe(str));
};
goog.string.isBreakingWhitespace = function (str) {
  return !/[^\t\n\r ]/.test(str);
};
goog.string.isAlpha = function (str) {
  return !/[^a-zA-Z]/.test(str);
};
goog.string.isNumeric = function (str) {
  return !/[^0-9]/.test(str);
};
goog.string.isAlphaNumeric = function (str) {
  return !/[^a-zA-Z0-9]/.test(str);
};
goog.string.isSpace = function (ch) {
  return ch == ' ';
};
goog.string.isUnicodeChar = function (ch) {
  return ch.length == 1 && ch >= ' ' && ch <= '~' || ch >= '\x80' && ch <= '\ufffd';
};
goog.string.stripNewlines = function (str) {
  return str.replace(/(\r\n|\r|\n)+/g, ' ');
};
goog.string.canonicalizeNewlines = function (str) {
  return str.replace(/(\r\n|\r|\n)/g, '\n');
};
goog.string.normalizeWhitespace = function (str) {
  return str.replace(/\xa0|\s/g, ' ');
};
goog.string.normalizeSpaces = function (str) {
  return str.replace(/\xa0|[ \t]+/g, ' ');
};
goog.string.collapseBreakingSpaces = function (str) {
  return str.replace(/[\t\r\n ]+/g, ' ').replace(/^[\t\r\n ]+|[\t\r\n ]+$/g, '');
};
goog.string.trim = function (str) {
  return str.replace(/^[\s\xa0]+|[\s\xa0]+$/g, '');
};
goog.string.trimLeft = function (str) {
  return str.replace(/^[\s\xa0]+/, '');
};
goog.string.trimRight = function (str) {
  return str.replace(/[\s\xa0]+$/, '');
};
goog.string.caseInsensitiveCompare = function (str1, str2) {
  var test1 = String(str1).toLowerCase();
  var test2 = String(str2).toLowerCase();
  if (test1 < test2) {
    return -1;
  } else if (test1 == test2) {
    return 0;
  } else {
    return 1;
  }
};
goog.string.numerateCompareRegExp_ = /(\.\d+)|(\d+)|(\D+)/g;
goog.string.numerateCompare = function (str1, str2) {
  if (str1 == str2) {
    return 0;
  }
  if (!str1) {
    return -1;
  }
  if (!str2) {
    return 1;
  }
  var tokens1 = str1.toLowerCase().match(goog.string.numerateCompareRegExp_);
  var tokens2 = str2.toLowerCase().match(goog.string.numerateCompareRegExp_);
  var count = Math.min(tokens1.length, tokens2.length);
  for (var i = 0; i < count; i++) {
    var a = tokens1[i];
    var b = tokens2[i];
    if (a != b) {
      var num1 = parseInt(a, 10);
      if (!isNaN(num1)) {
        var num2 = parseInt(b, 10);
        if (!isNaN(num2) && num1 - num2) {
          return num1 - num2;
        }
      }
      return a < b ? -1 : 1;
    }
  }
  if (tokens1.length != tokens2.length) {
    return tokens1.length - tokens2.length;
  }
  return str1 < str2 ? -1 : 1;
};
goog.string.urlEncode = function (str) {
  return encodeURIComponent(String(str));
};
goog.string.urlDecode = function (str) {
  return decodeURIComponent(str.replace(/\+/g, ' '));
};
goog.string.newLineToBr = function (str, opt_xml) {
  return str.replace(/(\r\n|\r|\n)/g, opt_xml ? '<br />' : '<br>');
};
goog.string.htmlEscape = function (str, opt_isLikelyToContainHtmlChars) {
  if (opt_isLikelyToContainHtmlChars) {
    return str.replace(goog.string.amperRe_, '&amp;').replace(goog.string.ltRe_, '&lt;').replace(goog.string.gtRe_, '&gt;').replace(goog.string.quotRe_, '&quot;');
  } else {
    if (!goog.string.allRe_.test(str))
      return str;
    if (str.indexOf('&') != -1) {
      str = str.replace(goog.string.amperRe_, '&amp;');
    }
    if (str.indexOf('<') != -1) {
      str = str.replace(goog.string.ltRe_, '&lt;');
    }
    if (str.indexOf('>') != -1) {
      str = str.replace(goog.string.gtRe_, '&gt;');
    }
    if (str.indexOf('"') != -1) {
      str = str.replace(goog.string.quotRe_, '&quot;');
    }
    return str;
  }
};
goog.string.amperRe_ = /&/g;
goog.string.ltRe_ = /</g;
goog.string.gtRe_ = />/g;
goog.string.quotRe_ = /\"/g;
goog.string.allRe_ = /[&<>\"]/;
goog.string.unescapeEntities = function (str) {
  if (goog.string.contains(str, '&')) {
    if ('document' in goog.global) {
      return goog.string.unescapeEntitiesUsingDom_(str);
    } else {
      return goog.string.unescapePureXmlEntities_(str);
    }
  }
  return str;
};
goog.string.unescapeEntitiesUsingDom_ = function (str) {
  var seen = {
      '&amp;': '&',
      '&lt;': '<',
      '&gt;': '>',
      '&quot;': '"'
    };
  var div = document.createElement('div');
  return str.replace(goog.string.HTML_ENTITY_PATTERN_, function (s, entity) {
    var value = seen[s];
    if (value) {
      return value;
    }
    if (entity.charAt(0) == '#') {
      var n = Number('0' + entity.substr(1));
      if (!isNaN(n)) {
        value = String.fromCharCode(n);
      }
    }
    if (!value) {
      div.innerHTML = s + ' ';
      value = div.firstChild.nodeValue.slice(0, -1);
    }
    return seen[s] = value;
  });
};
goog.string.unescapePureXmlEntities_ = function (str) {
  return str.replace(/&([^;]+);/g, function (s, entity) {
    switch (entity) {
    case 'amp':
      return '&';
    case 'lt':
      return '<';
    case 'gt':
      return '>';
    case 'quot':
      return '"';
    default:
      if (entity.charAt(0) == '#') {
        var n = Number('0' + entity.substr(1));
        if (!isNaN(n)) {
          return String.fromCharCode(n);
        }
      }
      return s;
    }
  });
};
goog.string.HTML_ENTITY_PATTERN_ = /&([^;\s<&]+);?/g;
goog.string.whitespaceEscape = function (str, opt_xml) {
  return goog.string.newLineToBr(str.replace(/  /g, ' &#160;'), opt_xml);
};
goog.string.stripQuotes = function (str, quoteChars) {
  var length = quoteChars.length;
  for (var i = 0; i < length; i++) {
    var quoteChar = length == 1 ? quoteChars : quoteChars.charAt(i);
    if (str.charAt(0) == quoteChar && str.charAt(str.length - 1) == quoteChar) {
      return str.substring(1, str.length - 1);
    }
  }
  return str;
};
goog.string.truncate = function (str, chars, opt_protectEscapedCharacters) {
  if (opt_protectEscapedCharacters) {
    str = goog.string.unescapeEntities(str);
  }
  if (str.length > chars) {
    str = str.substring(0, chars - 3) + '...';
  }
  if (opt_protectEscapedCharacters) {
    str = goog.string.htmlEscape(str);
  }
  return str;
};
goog.string.truncateMiddle = function (str, chars, opt_protectEscapedCharacters, opt_trailingChars) {
  if (opt_protectEscapedCharacters) {
    str = goog.string.unescapeEntities(str);
  }
  if (opt_trailingChars && str.length > chars) {
    if (opt_trailingChars > chars) {
      opt_trailingChars = chars;
    }
    var endPoint = str.length - opt_trailingChars;
    var startPoint = chars - opt_trailingChars;
    str = str.substring(0, startPoint) + '...' + str.substring(endPoint);
  } else if (str.length > chars) {
    var half = Math.floor(chars / 2);
    var endPos = str.length - half;
    half += chars % 2;
    str = str.substring(0, half) + '...' + str.substring(endPos);
  }
  if (opt_protectEscapedCharacters) {
    str = goog.string.htmlEscape(str);
  }
  return str;
};
goog.string.specialEscapeChars_ = {
  '\0': '\\0',
  '\b': '\\b',
  '\f': '\\f',
  '\n': '\\n',
  '\r': '\\r',
  '\t': '\\t',
  '\x0B': '\\x0B',
  '"': '\\"',
  '\\': '\\\\'
};
goog.string.jsEscapeCache_ = { '\'': '\\\'' };
goog.string.quote = function (s) {
  s = String(s);
  if (s.quote) {
    return s.quote();
  } else {
    var sb = ['"'];
    for (var i = 0; i < s.length; i++) {
      var ch = s.charAt(i);
      var cc = ch.charCodeAt(0);
      sb[i + 1] = goog.string.specialEscapeChars_[ch] || (cc > 31 && cc < 127 ? ch : goog.string.escapeChar(ch));
    }
    sb.push('"');
    return sb.join('');
  }
};
goog.string.escapeString = function (str) {
  var sb = [];
  for (var i = 0; i < str.length; i++) {
    sb[i] = goog.string.escapeChar(str.charAt(i));
  }
  return sb.join('');
};
goog.string.escapeChar = function (c) {
  if (c in goog.string.jsEscapeCache_) {
    return goog.string.jsEscapeCache_[c];
  }
  if (c in goog.string.specialEscapeChars_) {
    return goog.string.jsEscapeCache_[c] = goog.string.specialEscapeChars_[c];
  }
  var rv = c;
  var cc = c.charCodeAt(0);
  if (cc > 31 && cc < 127) {
    rv = c;
  } else {
    if (cc < 256) {
      rv = '\\x';
      if (cc < 16 || cc > 256) {
        rv += '0';
      }
    } else {
      rv = '\\u';
      if (cc < 4096) {
        rv += '0';
      }
    }
    rv += cc.toString(16).toUpperCase();
  }
  return goog.string.jsEscapeCache_[c] = rv;
};
goog.string.toMap = function (s) {
  var rv = {};
  for (var i = 0; i < s.length; i++) {
    rv[s.charAt(i)] = true;
  }
  return rv;
};
goog.string.contains = function (s, ss) {
  return s.indexOf(ss) != -1;
};
goog.string.countOf = function (s, ss) {
  return s && ss ? s.split(ss).length - 1 : 0;
};
goog.string.removeAt = function (s, index, stringLength) {
  var resultStr = s;
  if (index >= 0 && index < s.length && stringLength > 0) {
    resultStr = s.substr(0, index) + s.substr(index + stringLength, s.length - index - stringLength);
  }
  return resultStr;
};
goog.string.remove = function (s, ss) {
  var re = new RegExp(goog.string.regExpEscape(ss), '');
  return s.replace(re, '');
};
goog.string.removeAll = function (s, ss) {
  var re = new RegExp(goog.string.regExpEscape(ss), 'g');
  return s.replace(re, '');
};
goog.string.regExpEscape = function (s) {
  return String(s).replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, '\\$1').replace(/\x08/g, '\\x08');
};
goog.string.repeat = function (string, length) {
  return new Array(length + 1).join(string);
};
goog.string.padNumber = function (num, length, opt_precision) {
  var s = goog.isDef(opt_precision) ? num.toFixed(opt_precision) : String(num);
  var index = s.indexOf('.');
  if (index == -1) {
    index = s.length;
  }
  return goog.string.repeat('0', Math.max(0, length - index)) + s;
};
goog.string.makeSafe = function (obj) {
  return obj == null ? '' : String(obj);
};
goog.string.buildString = function (var_args) {
  return Array.prototype.join.call(arguments, '');
};
goog.string.getRandomString = function () {
  var x = 2147483648;
  return Math.floor(Math.random() * x).toString(36) + Math.abs(Math.floor(Math.random() * x) ^ goog.now()).toString(36);
};
goog.string.compareVersions = function (version1, version2) {
  var order = 0;
  var v1Subs = goog.string.trim(String(version1)).split('.');
  var v2Subs = goog.string.trim(String(version2)).split('.');
  var subCount = Math.max(v1Subs.length, v2Subs.length);
  for (var subIdx = 0; order == 0 && subIdx < subCount; subIdx++) {
    var v1Sub = v1Subs[subIdx] || '';
    var v2Sub = v2Subs[subIdx] || '';
    var v1CompParser = new RegExp('(\\d*)(\\D*)', 'g');
    var v2CompParser = new RegExp('(\\d*)(\\D*)', 'g');
    do {
      var v1Comp = v1CompParser.exec(v1Sub) || [
          '',
          '',
          ''
        ];
      var v2Comp = v2CompParser.exec(v2Sub) || [
          '',
          '',
          ''
        ];
      if (v1Comp[0].length == 0 && v2Comp[0].length == 0) {
        break;
      }
      var v1CompNum = v1Comp[1].length == 0 ? 0 : parseInt(v1Comp[1], 10);
      var v2CompNum = v2Comp[1].length == 0 ? 0 : parseInt(v2Comp[1], 10);
      order = goog.string.compareElements_(v1CompNum, v2CompNum) || goog.string.compareElements_(v1Comp[2].length == 0, v2Comp[2].length == 0) || goog.string.compareElements_(v1Comp[2], v2Comp[2]);
    } while (order == 0);
  }
  return order;
};
goog.string.compareElements_ = function (left, right) {
  if (left < right) {
    return -1;
  } else if (left > right) {
    return 1;
  }
  return 0;
};
goog.string.HASHCODE_MAX_ = 4294967296;
goog.string.hashCode = function (str) {
  var result = 0;
  for (var i = 0; i < str.length; ++i) {
    result = 31 * result + str.charCodeAt(i);
    result %= goog.string.HASHCODE_MAX_;
  }
  return result;
};
goog.string.uniqueStringCounter_ = Math.random() * 2147483648 | 0;
goog.string.createUniqueString = function () {
  return 'goog_' + goog.string.uniqueStringCounter_++;
};
goog.string.toNumber = function (str) {
  var num = Number(str);
  if (num == 0 && goog.string.isEmpty(str)) {
    return NaN;
  }
  return num;
};
goog.string.isLowerCamelCase = function (str) {
  return /^[a-z]+([A-Z][a-z]*)*$/.test(str);
};
goog.string.isUpperCamelCase = function (str) {
  return /^([A-Z][a-z]*)+$/.test(str);
};
goog.string.toCamelCase = function (str) {
  return String(str).replace(/\-([a-z])/g, function (all, match) {
    return match.toUpperCase();
  });
};
goog.string.toSelectorCase = function (str) {
  return String(str).replace(/([A-Z])/g, '-$1').toLowerCase();
};
goog.string.toTitleCase = function (str, opt_delimiters) {
  var delimiters = goog.isString(opt_delimiters) ? goog.string.regExpEscape(opt_delimiters) : '\\s';
  delimiters = delimiters ? '|[' + delimiters + ']+' : '';
  var regexp = new RegExp('(^' + delimiters + ')([a-z])', 'g');
  return str.replace(regexp, function (all, p1, p2) {
    return p1 + p2.toUpperCase();
  });
};
goog.string.parseInt = function (value) {
  if (isFinite(value)) {
    value = String(value);
  }
  if (goog.isString(value)) {
    return /^\s*-?0x/i.test(value) ? parseInt(value, 16) : parseInt(value, 10);
  }
  return NaN;
};
goog.string.splitLimit = function (str, separator, limit) {
  var parts = str.split(separator);
  var returnVal = [];
  while (limit > 0 && parts.length) {
    returnVal.push(parts.shift());
    limit--;
  }
  if (parts.length) {
    returnVal.push(parts.join(separator));
  }
  return returnVal;
};
goog.provide('goog.debug.Error');
goog.debug.Error = function (opt_msg) {
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, goog.debug.Error);
  } else {
    this.stack = new Error().stack || '';
  }
  if (opt_msg) {
    this.message = String(opt_msg);
  }
};
goog.inherits(goog.debug.Error, Error);
goog.debug.Error.prototype.name = 'CustomError';
goog.provide('goog.asserts');
goog.provide('goog.asserts.AssertionError');
goog.require('goog.debug.Error');
goog.require('goog.string');
goog.define('goog.asserts.ENABLE_ASSERTS', goog.DEBUG);
goog.asserts.AssertionError = function (messagePattern, messageArgs) {
  messageArgs.unshift(messagePattern);
  goog.debug.Error.call(this, goog.string.subs.apply(null, messageArgs));
  messageArgs.shift();
  this.messagePattern = messagePattern;
};
goog.inherits(goog.asserts.AssertionError, goog.debug.Error);
goog.asserts.AssertionError.prototype.name = 'AssertionError';
goog.asserts.doAssertFailure_ = function (defaultMessage, defaultArgs, givenMessage, givenArgs) {
  var message = 'Assertion failed';
  if (givenMessage) {
    message += ': ' + givenMessage;
    var args = givenArgs;
  } else if (defaultMessage) {
    message += ': ' + defaultMessage;
    args = defaultArgs;
  }
  throw new goog.asserts.AssertionError('' + message, args || []);
};
goog.asserts.assert = function (condition, opt_message, var_args) {
  if (goog.asserts.ENABLE_ASSERTS && !condition) {
    goog.asserts.doAssertFailure_('', null, opt_message, Array.prototype.slice.call(arguments, 2));
  }
  return condition;
};
goog.asserts.fail = function (opt_message, var_args) {
  if (goog.asserts.ENABLE_ASSERTS) {
    throw new goog.asserts.AssertionError('Failure' + (opt_message ? ': ' + opt_message : ''), Array.prototype.slice.call(arguments, 1));
  }
};
goog.asserts.assertNumber = function (value, opt_message, var_args) {
  if (goog.asserts.ENABLE_ASSERTS && !goog.isNumber(value)) {
    goog.asserts.doAssertFailure_('Expected number but got %s: %s.', [
      goog.typeOf(value),
      value
    ], opt_message, Array.prototype.slice.call(arguments, 2));
  }
  return value;
};
goog.asserts.assertString = function (value, opt_message, var_args) {
  if (goog.asserts.ENABLE_ASSERTS && !goog.isString(value)) {
    goog.asserts.doAssertFailure_('Expected string but got %s: %s.', [
      goog.typeOf(value),
      value
    ], opt_message, Array.prototype.slice.call(arguments, 2));
  }
  return value;
};
goog.asserts.assertFunction = function (value, opt_message, var_args) {
  if (goog.asserts.ENABLE_ASSERTS && !goog.isFunction(value)) {
    goog.asserts.doAssertFailure_('Expected function but got %s: %s.', [
      goog.typeOf(value),
      value
    ], opt_message, Array.prototype.slice.call(arguments, 2));
  }
  return value;
};
goog.asserts.assertObject = function (value, opt_message, var_args) {
  if (goog.asserts.ENABLE_ASSERTS && !goog.isObject(value)) {
    goog.asserts.doAssertFailure_('Expected object but got %s: %s.', [
      goog.typeOf(value),
      value
    ], opt_message, Array.prototype.slice.call(arguments, 2));
  }
  return value;
};
goog.asserts.assertArray = function (value, opt_message, var_args) {
  if (goog.asserts.ENABLE_ASSERTS && !goog.isArray(value)) {
    goog.asserts.doAssertFailure_('Expected array but got %s: %s.', [
      goog.typeOf(value),
      value
    ], opt_message, Array.prototype.slice.call(arguments, 2));
  }
  return value;
};
goog.asserts.assertBoolean = function (value, opt_message, var_args) {
  if (goog.asserts.ENABLE_ASSERTS && !goog.isBoolean(value)) {
    goog.asserts.doAssertFailure_('Expected boolean but got %s: %s.', [
      goog.typeOf(value),
      value
    ], opt_message, Array.prototype.slice.call(arguments, 2));
  }
  return value;
};
goog.asserts.assertInstanceof = function (value, type, opt_message, var_args) {
  if (goog.asserts.ENABLE_ASSERTS && !(value instanceof type)) {
    goog.asserts.doAssertFailure_('instanceof check failed.', null, opt_message, Array.prototype.slice.call(arguments, 3));
  }
  return value;
};
goog.asserts.assertObjectPrototypeIsIntact = function () {
  for (var key in Object.prototype) {
    goog.asserts.fail(key + ' should not be enumerable in Object.prototype.');
  }
};
var Sk = Sk || {};
Sk.configure = function (options) {
  Sk.output = options['output'] || Sk.output;
  goog.asserts.assert(typeof Sk.output === 'function');
  Sk.debugout = options['debugout'] || Sk.debugout;
  goog.asserts.assert(typeof Sk.debugout === 'function');
  Sk.read = options['read'] || Sk.read;
  goog.asserts.assert(typeof Sk.read === 'function');
  Sk.timeoutMsg = options['timeoutMsg'] || Sk.timeoutMsg;
  goog.asserts.assert(typeof Sk.timeoutMsg === 'function');
  goog.exportSymbol('Sk.timeoutMsg', Sk.timeoutMsg);
  Sk.sysargv = options['sysargv'] || Sk.sysargv;
  goog.asserts.assert(goog.isArrayLike(Sk.sysargv));
  Sk.python3 = options['python3'] || Sk.python3;
  goog.asserts.assert(typeof Sk.python3 === 'boolean');
  Sk.inputfun = options['inputfun'] || Sk.inputfun;
  goog.asserts.assert(typeof Sk.inputfun === 'function');
  Sk.throwSystemExit = options['systemexit'] || false;
  goog.asserts.assert(typeof Sk.throwSystemExit === 'boolean');
  if (options['syspath']) {
    Sk.syspath = options['syspath'];
    goog.asserts.assert(goog.isArrayLike(Sk.syspath));
    Sk.realsyspath = undefined;
    Sk.sysmodules = new Sk.builtin.dict([]);
  }
  Sk.misceval.softspace_ = false;
};
goog.exportSymbol('Sk.configure', Sk.configure);
Sk.timeoutMsg = function () {
  return 'Program exceeded run time limit.';
};
goog.exportSymbol('Sk.timeoutMsg', Sk.timeoutMsg);
Sk.output = function (x) {
};
Sk.read = function (x) {
  throw 'Sk.read has not been implemented';
};
Sk.sysargv = [];
Sk.getSysArgv = function () {
  return Sk.sysargv;
};
goog.exportSymbol('Sk.getSysArgv', Sk.getSysArgv);
Sk.syspath = [];
Sk.inBrowser = goog.global['document'] !== undefined;
Sk.debugout = function (args) {
};
(function () {
  if (goog.global['write'] !== undefined)
    Sk.output = goog.global['write'];
  else if (goog.global['console'] !== undefined && goog.global['console']['log'] !== undefined)
    Sk.output = function (x) {
      goog.global['console']['log'](x);
    };
  else if (goog.global['print'] !== undefined)
    Sk.output = goog.global['print'];
  if (goog.global['print'] !== undefined)
    Sk.debugout = goog.global['print'];
}());
if (!Sk.inBrowser) {
  goog.global.CLOSURE_IMPORT_SCRIPT = function (src) {
    goog.global['eval'](goog.global['read']('support/closure-library/closure/goog/' + src));
    return true;
  };
}
Sk.python3 = false;
Sk.inputfun = function (args) {
  return prompt(args);
};
goog.exportSymbol('Sk.python3', Sk.python3);
goog.exportSymbol('Sk.inputfun', Sk.inputfun);
goog.require('goog.asserts');
Sk.builtin = {};
Sk.builtin.range = function range(start, stop, step) {
  var ret = [];
  var i;
  Sk.builtin.pyCheckArgs('range', arguments, 1, 3);
  Sk.builtin.pyCheckType('start', 'integer', Sk.builtin.checkInt(start));
  if (stop !== undefined) {
    Sk.builtin.pyCheckType('stop', 'integer', Sk.builtin.checkInt(stop));
  }
  if (step !== undefined) {
    Sk.builtin.pyCheckType('step', 'integer', Sk.builtin.checkInt(step));
  }
  start = Sk.builtin.asnum$(start);
  stop = Sk.builtin.asnum$(stop);
  step = Sk.builtin.asnum$(step);
  if (stop === undefined && step === undefined) {
    stop = start;
    start = 0;
    step = 1;
  } else if (step === undefined) {
    step = 1;
  }
  if (step === 0) {
    throw new Sk.builtin.ValueError('range() step argument must not be zero');
  }
  if (step > 0) {
    for (i = start; i < stop; i += step) {
      ret.push(new Sk.builtin.nmber(i, Sk.builtin.nmber.int$));
    }
  } else {
    for (i = start; i > stop; i += step) {
      ret.push(new Sk.builtin.nmber(i, Sk.builtin.nmber.int$));
    }
  }
  return new Sk.builtin.list(ret);
};
Sk.builtin.asnum$ = function (a) {
  if (a === undefined)
    return a;
  if (a === null)
    return a;
  if (a.constructor === Sk.builtin.none)
    return null;
  if (a.constructor === Sk.builtin.bool) {
    if (a.v)
      return 1;
    return 0;
  }
  if (typeof a === 'number')
    return a;
  if (typeof a === 'string')
    return a;
  if (a.constructor === Sk.builtin.nmber)
    return a.v;
  if (a.constructor === Sk.builtin.lng) {
    if (a.cantBeInt())
      return a.str$(10, true);
    return a.toInt$();
  }
  if (a.constructor === Sk.builtin.biginteger) {
    if (a.trueCompare(new Sk.builtin.biginteger(Sk.builtin.lng.threshold$)) > 0 || a.trueCompare(new Sk.builtin.biginteger(-Sk.builtin.lng.threshold$)) < 0) {
      return a.toString();
    }
    return a.intValue();
  }
  return a;
};
goog.exportSymbol('Sk.builtin.asnum$', Sk.builtin.asnum$);
Sk.builtin.assk$ = function (a, b) {
  return new Sk.builtin.nmber(a, b);
};
goog.exportSymbol('Sk.builtin.assk$', Sk.builtin.assk$);
Sk.builtin.asnum$nofloat = function (a) {
  if (a === undefined)
    return a;
  if (a === null)
    return a;
  if (a.constructor === Sk.builtin.none)
    return null;
  if (a.constructor === Sk.builtin.bool) {
    if (a.v)
      return 1;
    return 0;
  }
  if (typeof a === 'number')
    a = a.toString();
  if (a.constructor === Sk.builtin.nmber)
    a = a.v.toString();
  if (a.constructor === Sk.builtin.lng)
    a = a.str$(10, true);
  if (a.constructor === Sk.builtin.biginteger)
    a = a.toString();
  if (a.indexOf('.') < 0 && a.indexOf('e') < 0 && a.indexOf('E') < 0)
    return a;
  var expon = 0;
  var mantissa;
  if (a.indexOf('e') >= 0) {
    mantissa = a.substr(0, a.indexOf('e'));
    expon = a.substr(a.indexOf('e') + 1);
  } else if (a.indexOf('E') >= 0) {
    mantissa = a.substr(0, a.indexOf('e'));
    expon = a.substr(a.indexOf('E') + 1);
  } else {
    mantissa = a;
  }
  expon = parseInt(expon, 10);
  var decimal = mantissa.indexOf('.');
  if (decimal < 0) {
    if (expon >= 0) {
      while (expon-- > 0)
        mantissa += '0';
      return mantissa;
    } else {
      if (mantissa.length > -expon)
        return mantissa.substr(0, mantissa.length + expon);
      else
        return 0;
    }
  }
  if (decimal == 0)
    mantissa = mantissa.substr(1);
  else if (decimal < mantissa.length)
    mantissa = mantissa.substr(0, decimal) + mantissa.substr(decimal + 1);
  else
    mantissa = mantissa.substr(0, decimal);
  decimal = decimal + expon;
  while (decimal > mantissa.length)
    mantissa += '0';
  if (decimal <= 0) {
    mantissa = 0;
  } else {
    mantissa = mantissa.substr(0, decimal);
  }
  return mantissa;
};
goog.exportSymbol('Sk.builtin.asnum$nofloat', Sk.builtin.asnum$nofloat);
Sk.builtin.round = function round(number, ndigits) {
  var result, multiplier;
  Sk.builtin.pyCheckArgs('round', arguments, 1, 2);
  if (!Sk.builtin.checkNumber(number)) {
    throw new Sk.builtin.TypeError('a float is required');
  }
  if (ndigits !== undefined && !Sk.misceval.isIndex(ndigits)) {
    throw new Sk.builtin.TypeError('\'' + Sk.abstr.typeName(ndigits) + '\' object cannot be interpreted as an index');
  }
  ;
  if (ndigits === undefined) {
    ndigits = 0;
  }
  ;
  number = Sk.builtin.asnum$(number);
  ndigits = Sk.misceval.asIndex(ndigits);
  multiplier = Math.pow(10, ndigits);
  result = Math.round(number * multiplier) / multiplier;
  return new Sk.builtin.nmber(result, Sk.builtin.nmber.float$);
};
Sk.builtin.len = function len(item) {
  Sk.builtin.pyCheckArgs('len', arguments, 1, 1);
  if (item.sq$length)
    return new Sk.builtin.nmber(item.sq$length(), Sk.builtin.nmber.int$);
  if (item.mp$length)
    return new Sk.builtin.nmber(item.mp$length(), Sk.builtin.nmber.int$);
  if (item.tp$length)
    return new Sk.builtin.nmber(item.tp$length(), Sk.builtin.nmber.int$);
  throw new Sk.builtin.TypeError('object of type \'' + Sk.abstr.typeName(item) + '\' has no len()');
};
Sk.builtin.min = function min() {
  Sk.builtin.pyCheckArgs('min', arguments, 1);
  arguments = Sk.misceval.arrayFromArguments(arguments);
  var lowest = arguments[0];
  for (var i = 1; i < arguments.length; ++i) {
    if (Sk.misceval.richCompareBool(arguments[i], lowest, 'Lt'))
      lowest = arguments[i];
  }
  return lowest;
};
Sk.builtin.max = function max() {
  Sk.builtin.pyCheckArgs('max', arguments, 1);
  arguments = Sk.misceval.arrayFromArguments(arguments);
  var highest = arguments[0];
  for (var i = 1; i < arguments.length; ++i) {
    if (Sk.misceval.richCompareBool(arguments[i], highest, 'Gt'))
      highest = arguments[i];
  }
  return highest;
};
Sk.builtin.any = function any(iter) {
  var it, i;
  Sk.builtin.pyCheckArgs('any', arguments, 1);
  if (!Sk.builtin.checkIterable(iter)) {
    throw new Sk.builtin.TypeError('\'' + Sk.abstr.typeName(iter) + '\' object is not iterable');
  }
  it = iter.tp$iter();
  for (i = it.tp$iternext(); i !== undefined; i = it.tp$iternext()) {
    if (Sk.misceval.isTrue(i)) {
      return true;
    }
  }
  return false;
};
Sk.builtin.all = function all(iter) {
  var it, i;
  Sk.builtin.pyCheckArgs('all', arguments, 1);
  if (!Sk.builtin.checkIterable(iter)) {
    throw new Sk.builtin.TypeError('\'' + Sk.abstr.typeName(iter) + '\' object is not iterable');
  }
  it = iter.tp$iter();
  for (i = it.tp$iternext(); i !== undefined; i = it.tp$iternext()) {
    if (!Sk.misceval.isTrue(i)) {
      return false;
    }
  }
  return true;
};
Sk.builtin.sum = function sum(iter, start) {
  var tot;
  var it, i;
  var has_float;
  Sk.builtin.pyCheckArgs('sum', arguments, 1, 2);
  Sk.builtin.pyCheckType('iter', 'iterable', Sk.builtin.checkIterable(iter));
  if (start !== undefined && Sk.builtin.checkString(start)) {
    throw new Sk.builtin.TypeError('sum() can\'t sum strings [use \'\'.join(seq) instead]');
  }
  ;
  if (start === undefined) {
    tot = new Sk.builtin.nmber(0, Sk.builtin.nmber.int$);
  } else {
    tot = start;
  }
  it = iter.tp$iter();
  for (i = it.tp$iternext(); i !== undefined; i = it.tp$iternext()) {
    if (i.skType === Sk.builtin.nmber.float$) {
      has_float = true;
      if (tot.skType !== Sk.builtin.nmber.float$) {
        tot = new Sk.builtin.nmber(Sk.builtin.asnum$(tot), Sk.builtin.nmber.float$);
      }
    } else if (i instanceof Sk.builtin.lng) {
      if (!has_float) {
        if (!(tot instanceof Sk.builtin.lng)) {
          tot = new Sk.builtin.lng(tot);
        }
      }
    }
    if (tot.nb$add(i) !== undefined) {
      tot = tot.nb$add(i);
    } else {
      throw new Sk.builtin.TypeError('unsupported operand type(s) for +: \'' + Sk.abstr.typeName(tot) + '\' and \'' + Sk.abstr.typeName(i) + '\'');
    }
  }
  return tot;
};
Sk.builtin.zip = function zip() {
  if (arguments.length === 0) {
    return new Sk.builtin.list([]);
  }
  var iters = [];
  for (var i = 0; i < arguments.length; i++) {
    if (arguments[i].tp$iter) {
      iters.push(arguments[i].tp$iter());
    } else {
      throw 'TypeError: argument ' + i + ' must support iteration';
    }
  }
  var res = [];
  var done = false;
  while (!done) {
    var tup = [];
    for (i = 0; i < arguments.length; i++) {
      var el = iters[i].tp$iternext();
      if (el === undefined) {
        done = true;
        break;
      }
      tup.push(el);
    }
    if (!done) {
      res.push(new Sk.builtin.tuple(tup));
    }
  }
  return new Sk.builtin.list(res);
};
Sk.builtin.abs = function abs(x) {
  Sk.builtin.pyCheckArgs('abs', arguments, 1, 1);
  Sk.builtin.pyCheckType('x', 'number', Sk.builtin.checkNumber(x));
  return new Sk.builtin.nmber(Math.abs(Sk.builtin.asnum$(x)), x.skType);
};
Sk.builtin.ord = function ord(x) {
  Sk.builtin.pyCheckArgs('ord', arguments, 1, 1);
  if (!Sk.builtin.checkString(x)) {
    throw new Sk.builtin.TypeError('ord() expected a string of length 1, but ' + Sk.abstr.typeName(x) + ' found');
  } else if (x.v.length !== 1) {
    throw new Sk.builtin.TypeError('ord() expected a character, but string of length ' + x.v.length + ' found');
  }
  return new Sk.builtin.nmber(x.v.charCodeAt(0), Sk.builtin.nmber.int$);
};
Sk.builtin.chr = function chr(x) {
  Sk.builtin.pyCheckArgs('chr', arguments, 1, 1);
  if (!Sk.builtin.checkInt(x)) {
    throw new Sk.builtin.TypeError('an integer is required');
  }
  x = Sk.builtin.asnum$(x);
  if (x < 0 || x > 255) {
    throw new Sk.builtin.ValueError('chr() arg not in range(256)');
  }
  return new Sk.builtin.str(String.fromCharCode(x));
};
Sk.builtin.int2str_ = function helper_(x, radix, prefix) {
  var str = '';
  if (x instanceof Sk.builtin.lng) {
    var suffix = '';
    if (radix !== 2)
      suffix = 'L';
    str = x.str$(radix, false);
    if (x.nb$isnegative()) {
      return new Sk.builtin.str('-' + prefix + str + suffix);
    }
    return new Sk.builtin.str(prefix + str + suffix);
  } else {
    x = Sk.misceval.asIndex(x);
    str = x.toString(radix);
    if (x < 0) {
      return new Sk.builtin.str('-' + prefix + str.slice(1));
    }
    return new Sk.builtin.str(prefix + str);
  }
};
Sk.builtin.hex = function hex(x) {
  Sk.builtin.pyCheckArgs('hex', arguments, 1, 1);
  if (!Sk.misceval.isIndex(x)) {
    throw new Sk.builtin.TypeError('hex() argument can\'t be converted to hex');
  }
  return Sk.builtin.int2str_(x, 16, '0x');
};
Sk.builtin.oct = function oct(x) {
  Sk.builtin.pyCheckArgs('oct', arguments, 1, 1);
  if (!Sk.misceval.isIndex(x)) {
    throw new Sk.builtin.TypeError('oct() argument can\'t be converted to hex');
  }
  return Sk.builtin.int2str_(x, 8, '0');
};
Sk.builtin.bin = function bin(x) {
  Sk.builtin.pyCheckArgs('bin', arguments, 1, 1);
  if (!Sk.misceval.isIndex(x)) {
    throw new Sk.builtin.TypeError('\'' + Sk.abstr.typeName(x) + '\' object can\'t be interpreted as an index');
  }
  return Sk.builtin.int2str_(x, 2, '0b');
};
Sk.builtin.dir = function dir(x) {
  Sk.builtin.pyCheckArgs('dir', arguments, 1, 1);
  var getName = function (k) {
    var s = null;
    var internal = [
        '__bases__',
        '__mro__',
        '__class__'
      ];
    if (internal.indexOf(k) !== -1)
      return null;
    if (k.indexOf('$') !== -1)
      s = Sk.builtin.dir.slotNameToRichName(k);
    else if (k.charAt(k.length - 1) !== '_')
      s = k;
    else if (k.charAt(0) === '_')
      s = k;
    return s;
  };
  var names = [];
  var k;
  var s;
  var i;
  var mro;
  var base;
  var prop;
  for (k in x.constructor.prototype) {
    s = getName(k);
    if (s)
      names.push(new Sk.builtin.str(s));
  }
  if (x['$d']) {
    if (x['$d'].tp$iter) {
      var it = x['$d'].tp$iter();
      var i;
      for (i = it.tp$iternext(); i !== undefined; i = it.tp$iternext()) {
        s = new Sk.builtin.str(i);
        s = getName(s.v);
        if (s)
          names.push(new Sk.builtin.str(s));
      }
    } else {
      for (s in x['$d']) {
        names.push(new Sk.builtin.str(s));
      }
    }
  }
  mro = x.tp$mro;
  if (mro) {
    mro = x.tp$mro;
    for (i = 0; i < mro.v.length; ++i) {
      base = mro.v[i];
      for (prop in base) {
        if (base.hasOwnProperty(prop)) {
          s = getName(prop);
          if (s)
            names.push(new Sk.builtin.str(s));
        }
      }
    }
  }
  names.sort(function (a, b) {
    return (a.v > b.v) - (a.v < b.v);
  });
  var last = function (value, index, self) {
    return value !== self[index + 1];
  };
  return new Sk.builtin.list(names.filter(last));
};
Sk.builtin.dir.slotNameToRichName = function (k) {
  return undefined;
};
Sk.builtin.repr = function repr(x) {
  Sk.builtin.pyCheckArgs('repr', arguments, 1, 1);
  return Sk.misceval.objectRepr(x);
};
Sk.builtin.open = function open(filename, mode, bufsize) {
  Sk.builtin.pyCheckArgs('open', arguments, 1, 3);
  if (mode === undefined)
    mode = new Sk.builtin.str('r');
  if (mode.v !== 'r' && mode.v !== 'rb')
    throw 'todo; haven\'t implemented non-read opens';
  return new Sk.builtin.file(filename, mode, bufsize);
};
Sk.builtin.isinstance = function isinstance(obj, type) {
  Sk.builtin.pyCheckArgs('isinstance', arguments, 2, 2);
  if (!Sk.builtin.checkClass(type) && !(type instanceof Sk.builtin.tuple)) {
    throw new Sk.builtin.TypeError('isinstance() arg 2 must be a class, type, or tuple of classes and types');
  }
  if (type === Sk.builtin.int_.prototype.ob$type) {
    return obj.tp$name === 'number' && obj.skType === Sk.builtin.nmber.int$;
  }
  if (type === Sk.builtin.float_.prototype.ob$type) {
    return obj.tp$name === 'number' && obj.skType === Sk.builtin.nmber.float$;
  }
  if (type === Sk.builtin.none.prototype.ob$type) {
    return obj instanceof Sk.builtin.none;
  }
  if (obj.ob$type === type)
    return true;
  if (type instanceof Sk.builtin.tuple) {
    for (var i = 0; i < type.v.length; ++i) {
      if (Sk.builtin.isinstance(obj, type.v[i]))
        return true;
    }
    return false;
  }
  var issubclass = function (klass, base) {
    if (klass === base)
      return true;
    if (klass['$d'] === undefined)
      return false;
    var bases = klass['$d'].mp$subscript(Sk.builtin.type.basesStr_);
    for (var i = 0; i < bases.v.length; ++i) {
      if (issubclass(bases.v[i], base))
        return true;
    }
    return false;
  };
  return issubclass(obj.ob$type, type);
};
Sk.builtin.hashCount = 0;
Sk.builtin.hash = function hash(value) {
  Sk.builtin.pyCheckArgs('hash', arguments, 1, 1);
  var junk = {
      __hash__: function () {
        return 0;
      }
    };
  if (value instanceof Object && value.tp$hash !== undefined) {
    if (value.$savedHash_)
      return value.$savedHash_;
    value.$savedHash_ = value.tp$hash();
    return value.$savedHash_;
  } else if (value instanceof Object && value.__hash__ !== undefined) {
    return Sk.misceval.callsim(value.__hash__, value);
  } else if (value instanceof Sk.builtin.bool) {
    if (value.v)
      return 1;
    return 0;
  } else if (value instanceof Sk.builtin.none) {
    return 0;
  } else if (value instanceof Object) {
    if (value.__id === undefined) {
      Sk.builtin.hashCount += 1;
      value.__id = Sk.builtin.hashCount;
    }
    return value.__id;
  } else if (typeof value === 'number') {
    return value;
  } else if (value === null) {
    return 0;
  } else if (value === true) {
    return 1;
  } else if (value === false) {
    return 0;
  }
  return typeof value + ' ' + String(value);
};
Sk.builtin.getattr = function getattr(obj, name, default_) {
  Sk.builtin.pyCheckArgs('getattr', arguments, 2, 3);
  if (!Sk.builtin.checkString(name)) {
    throw new Sk.builtin.TypeError('attribute name must be string');
  }
  var ret = obj.tp$getattr(name.v);
  if (ret === undefined) {
    if (default_ !== undefined)
      return default_;
    else
      throw new Sk.builtin.AttributeError('\'' + Sk.abstr.typeName(obj) + '\' object has no attribute \'' + name.v + '\'');
  }
  return ret;
};
Sk.builtin.raw_input = function (obj, name, default_) {
  var x = Sk.inputfun(obj.v);
  return new Sk.builtin.str(x);
};
Sk.builtin.input = function (obj, name, default_) {
  var x = Sk.inputfun(obj.v);
  return new Sk.builtin.str(x);
};
Sk.builtin.jseval = function jseval(evalcode) {
  goog.global['eval'](evalcode);
};
Sk.builtin.jsmillis = function jsmillis() {
  var now = new Date();
  return now.valueOf();
};
Sk.builtin.superbi = function superbi() {
  throw new Sk.builtin.NotImplementedError('super is not yet implemented, please report your use case as a github issue.');
};
Sk.builtin.eval_ = function eval_() {
  throw new Sk.builtin.NotImplementedError('eval is not yet implemented');
};
Sk.builtin.map = function map(fun, seq) {
  Sk.builtin.pyCheckArgs('map', arguments, 2);
  if (fun instanceof Sk.builtin.none) {
    fun = {
      func_code: function (x) {
        return x;
      }
    };
  }
  if (arguments.length > 2) {
    var combined = [];
    var iterables = Array.prototype.slice.apply(arguments).slice(1);
    for (var i in iterables) {
      if (iterables[i].tp$iter === undefined) {
        var argnum = parseInt(i, 10) + 2;
        throw new Sk.builtin.TypeError('argument ' + argnum + ' to map() must support iteration');
      }
      iterables[i] = iterables[i].tp$iter();
    }
    while (true) {
      var args = [];
      var nones = 0;
      for (var i in iterables) {
        var next = iterables[i].tp$iternext();
        if (next === undefined) {
          args.push(Sk.builtin.none.none$);
          nones++;
        } else {
          args.push(next);
        }
      }
      if (nones !== iterables.length) {
        combined.push(args);
      } else {
        break;
      }
    }
    seq = new Sk.builtin.list(combined);
  }
  if (seq.tp$iter === undefined) {
    throw new Sk.builtin.TypeError('\'' + Sk.abstr.typeName(seq) + '\' object is not iterable');
  }
  var retval = [], iter = seq.tp$iter(), next = iter.tp$iternext();
  while (next !== undefined) {
    if (!(next instanceof Array)) {
      next = [next];
    }
    retval.push(fun.func_code.apply(this, next));
    next = iter.tp$iternext();
  }
  return new Sk.builtin.list(retval);
};
Sk.builtin.reduce = function reduce(fun, seq, initializer) {
  Sk.builtin.pyCheckArgs('reduce', arguments, 2, 3);
  var iter = seq.tp$iter();
  if (initializer === undefined) {
    initializer = iter.tp$iternext();
    if (initializer === undefined) {
      throw new Sk.builtin.TypeError('reduce() of empty sequence with no initial value');
    }
  }
  var accum_value = initializer;
  var next = iter.tp$iternext();
  while (next !== undefined) {
    accum_value = fun.func_code(accum_value, next);
    next = iter.tp$iternext();
  }
  return accum_value;
};
Sk.builtin.filter = function filter(fun, iterable) {
  Sk.builtin.pyCheckArgs('filter', arguments, 2, 2);
  if (iterable.tp$iter === undefined) {
    throw new Sk.builtin.TypeError('\'' + Sk.abstr.typeName(iterable) + '\' object is not iterable');
  }
  if (fun instanceof Sk.builtin.none) {
    fun = {
      func_code: function (x) {
        return Sk.builtin.bool(x);
      }
    };
  }
  var ctor = function () {
    return [];
  };
  var add = function (iter, item) {
    iter.push(item);
    return iter;
  };
  var ret = function (iter) {
    return new Sk.builtin.list(iter);
  };
  if (iterable.__class__ === Sk.builtin.str) {
    ctor = function () {
      return new Sk.builtin.str('');
    };
    add = function (iter, item) {
      return iter.sq$concat(item);
    };
    ret = function (iter) {
      return iter;
    };
  } else if (iterable.__class__ === Sk.builtin.tuple) {
    ret = function (iter) {
      return new Sk.builtin.tuple(iter);
    };
  }
  var iter = iterable.tp$iter(), next = iter.tp$iternext(), retval = ctor();
  if (next === undefined) {
    return ret(retval);
  }
  while (next !== undefined) {
    if (Sk.misceval.isTrue(fun.func_code(next))) {
      retval = add(retval, next);
    }
    next = iter.tp$iternext();
  }
  return ret(retval);
};
Sk.builtin.hasattr = function hasattr(obj, attr) {
  Sk.builtin.pyCheckArgs('hasattr', arguments, 2, 2);
  if (!Sk.builtin.checkString(attr)) {
    throw new Sk.builtin.TypeError('hasattr(): attribute name must be string');
  }
  if (obj.tp$getattr) {
    if (obj.tp$getattr(attr.v)) {
      return true;
    } else
      return false;
  } else
    throw new Sk.builtin.AttributeError('Object has no tp$getattr method');
};
Sk.builtin.pow = function pow(a, b, c) {
  Sk.builtin.pyCheckArgs('pow', arguments, 2, 3);
  var a_num = Sk.builtin.asnum$(a);
  var b_num = Sk.builtin.asnum$(b);
  var c_num = Sk.builtin.asnum$(c);
  if (!Sk.builtin.checkNumber(a) || !Sk.builtin.checkNumber(b)) {
    if (c === undefined) {
      throw new Sk.builtin.TypeError('unsupported operand type(s) for pow(): \'' + Sk.abstr.typeName(a) + '\' and \'' + Sk.abstr.typeName(b) + '\'');
    } else {
      throw new Sk.builtin.TypeError('unsupported operand type(s) for pow(): \'' + Sk.abstr.typeName(a) + '\', \'' + Sk.abstr.typeName(b) + '\', \'' + Sk.abstr.typeName(c) + '\'');
    }
  }
  if (a_num < 0 && b.skType === Sk.builtin.nmber.float$) {
    throw new Sk.builtin.ValueError('negative number cannot be raised to a fractional power');
  }
  if (c === undefined) {
    var res = Math.pow(a_num, b_num);
    if (a.skType === Sk.builtin.nmber.float$ || b.skType === Sk.builtin.nmber.float$ || b_num < 0) {
      return new Sk.builtin.nmber(res, Sk.builtin.nmber.float$);
    } else if (a instanceof Sk.builtin.lng || b instanceof Sk.builtin.lng) {
      return new Sk.builtin.lng(res);
    } else {
      return new Sk.builtin.nmber(res, Sk.builtin.nmber.int$);
    }
  } else {
    if (!Sk.builtin.checkInt(a) || !Sk.builtin.checkInt(b) || !Sk.builtin.checkInt(c)) {
      throw new Sk.builtin.TypeError('pow() 3rd argument not allowed unless all arguments are integers');
    }
    if (b_num < 0) {
      throw new Sk.builtin.TypeError('pow() 2nd argument cannot be negative when 3rd argument specified');
    }
    if (a instanceof Sk.builtin.lng || b instanceof Sk.builtin.lng || c instanceof Sk.builtin.lng || Math.pow(a_num, b_num) === Infinity) {
      a = new Sk.builtin.lng(a);
      return a.nb$power(b, c);
    } else {
      var ret = new Sk.builtin.nmber(Math.pow(a_num, b_num), Sk.builtin.nmber.int$);
      return ret.nb$remainder(c);
    }
  }
};
Sk.builtin.quit = function quit(msg) {
  var s = new Sk.builtin.str(msg).v;
  throw new Sk.builtin.SystemExit(s);
};
Sk.builtin.sorted = function sorted(iterable, cmp, key, reverse) {
  var compare_func;
  var list;
  if (key !== undefined && !(key instanceof Sk.builtin.none)) {
    if (cmp instanceof Sk.builtin.none) {
      compare_func = {
        func_code: function (a, b) {
          return Sk.misceval.richCompareBool(a[0], b[0], 'Lt') ? new Sk.builtin.nmber(-1, Sk.builtin.nmber.int$) : new Sk.builtin.nmber(0, Sk.builtin.nmber.int$);
        }
      };
    } else {
      compare_func = {
        func_code: function (a, b) {
          return cmp.func_code(a[0], b[0]);
        }
      };
    }
    var iter = iterable.tp$iter();
    var next = iter.tp$iternext();
    var arr = [];
    while (next !== undefined) {
      arr.push([
        key.func_code(next),
        next
      ]);
      next = iter.tp$iternext();
    }
    list = new Sk.builtin.list(arr);
  } else {
    if (!(cmp instanceof Sk.builtin.none) && cmp !== undefined) {
      compare_func = cmp;
    }
    list = new Sk.builtin.list(iterable);
  }
  if (compare_func !== undefined) {
    list.list_sort_(list, compare_func);
  } else {
    list.list_sort_(list);
  }
  if (reverse) {
    list.list_reverse_(list);
  }
  if (key !== undefined && !(key instanceof Sk.builtin.none)) {
    var iter = list.tp$iter();
    var next = iter.tp$iternext();
    var arr = [];
    while (next !== undefined) {
      arr.push(next[1]);
      next = iter.tp$iternext();
    }
    list = new Sk.builtin.list(arr);
  }
  return list;
};
Sk.builtin.bytearray = function bytearray() {
  throw new Sk.builtin.NotImplementedError('bytearray is not yet implemented');
};
Sk.builtin.callable = function callable() {
  throw new Sk.builtin.NotImplementedError('callable is not yet implemented');
};
Sk.builtin.complex = function complex() {
  throw new Sk.builtin.NotImplementedError('complex is not yet implemented');
};
Sk.builtin.delattr = function delattr() {
  throw new Sk.builtin.NotImplementedError('delattr is not yet implemented');
};
Sk.builtin.divmod = function divmod() {
  throw new Sk.builtin.NotImplementedError('divmod is not yet implemented');
};
Sk.builtin.execfile = function execfile() {
  throw new Sk.builtin.NotImplementedError('execfile is not yet implemented');
};
Sk.builtin.format = function format() {
  throw new Sk.builtin.NotImplementedError('format is not yet implemented');
};
Sk.builtin.frozenset = function frozenset() {
  throw new Sk.builtin.NotImplementedError('frozenset is not yet implemented');
};
Sk.builtin.globals = function globals() {
  throw new Sk.builtin.NotImplementedError('globals is not yet implemented');
};
Sk.builtin.help = function help() {
  throw new Sk.builtin.NotImplementedError('help is not yet implemented');
};
Sk.builtin.issubclass = function issubclass() {
  throw new Sk.builtin.NotImplementedError('issubclass is not yet implemented');
};
Sk.builtin.iter = function iter() {
  throw new Sk.builtin.NotImplementedError('iter is not yet implemented');
};
Sk.builtin.locals = function locals() {
  throw new Sk.builtin.NotImplementedError('locals is not yet implemented');
};
Sk.builtin.memoryview = function memoryview() {
  throw new Sk.builtin.NotImplementedError('memoryview is not yet implemented');
};
Sk.builtin.next_ = function next_() {
  throw new Sk.builtin.NotImplementedError('next is not yet implemented');
};
Sk.builtin.property = function property() {
  throw new Sk.builtin.NotImplementedError('property is not yet implemented');
};
Sk.builtin.reload = function reload() {
  throw new Sk.builtin.NotImplementedError('reload is not yet implemented');
};
Sk.builtin.reversed = function reversed() {
  throw new Sk.builtin.NotImplementedError('reversed is not yet implemented');
};
Sk.builtin.unichr = function unichr() {
  throw new Sk.builtin.NotImplementedError('unichr is not yet implemented');
};
Sk.builtin.vars = function vars() {
  throw new Sk.builtin.NotImplementedError('vars is not yet implemented');
};
Sk.builtin.xrange = Sk.builtin.range;
Sk.builtin.apply_ = function apply_() {
  throw new Sk.builtin.NotImplementedError('apply is not yet implemented');
};
Sk.builtin.buffer = function buffer() {
  throw new Sk.builtin.NotImplementedError('buffer is not yet implemented');
};
Sk.builtin.coerce = function coerce() {
  throw new Sk.builtin.NotImplementedError('coerce is not yet implemented');
};
Sk.builtin.intern = function intern() {
  throw new Sk.builtin.NotImplementedError('intern is not yet implemented');
};
Sk.builtin.Exception = function (args) {
  var args = Array.prototype.slice.call(arguments);
  for (var i = 0; i < args.length; ++i) {
    if (typeof args[i] === 'string')
      args[i] = new Sk.builtin.str(args[i]);
  }
  this.args = new Sk.builtin.tuple(args);
  if (Sk.currFilename) {
    this.filename = Sk.currFilename;
  } else if (this.args.sq$length() >= 3) {
    if (this.args.v[1].v) {
      this.filename = this.args.v[1].v;
    } else {
      this.filename = '<unknown>';
    }
  } else {
    this.filename = '<unknown>';
  }
  if (this.args.sq$length() >= 3) {
    this.lineno = this.args.v[2];
  } else if (Sk.currLineNo > 0) {
    this.lineno = Sk.currLineNo;
  } else {
    this.lineno = '<unknown>';
  }
  if (Sk.currColNo > 0) {
    this.colno = Sk.currColNo;
  } else {
    this.colno = '<unknown>';
  }
};
Sk.builtin.Exception.prototype.tp$name = 'Exception';
Sk.builtin.Exception.prototype.tp$str = function () {
  var ret = '';
  ret += this.tp$name;
  if (this.args)
    ret += ': ' + (this.args.v.length > 0 ? this.args.v[0].v : '');
  ret += ' on line ' + this.lineno;
  if (this.args.v.length > 4) {
    ret += '\n' + this.args.v[4].v + '\n';
    for (var i = 0; i < this.args.v[3]; ++i)
      ret += ' ';
    ret += '^\n';
  }
  return new Sk.builtin.str(ret);
};
Sk.builtin.Exception.prototype.toString = function () {
  return this.tp$str().v;
};
goog.exportSymbol('Sk.builtin.Exception', Sk.builtin.Exception);
Sk.builtin.AssertionError = function (args) {
  if (!(this instanceof Sk.builtin.AssertionError)) {
    var o = Object.create(Sk.builtin.AssertionError.prototype);
    o.constructor.apply(o, arguments);
    return o;
  }
  Sk.builtin.Exception.apply(this, arguments);
};
goog.inherits(Sk.builtin.AssertionError, Sk.builtin.Exception);
Sk.builtin.AssertionError.prototype.tp$name = 'AssertionError';
goog.exportSymbol('Sk.builtin.AssertionError', Sk.builtin.AssertionError);
Sk.builtin.AttributeError = function (args) {
  if (!(this instanceof Sk.builtin.AttributeError)) {
    var o = Object.create(Sk.builtin.AttributeError.prototype);
    o.constructor.apply(o, arguments);
    return o;
  }
  Sk.builtin.Exception.apply(this, arguments);
};
goog.inherits(Sk.builtin.AttributeError, Sk.builtin.Exception);
Sk.builtin.AttributeError.prototype.tp$name = 'AttributeError';
Sk.builtin.ImportError = function (args) {
  if (!(this instanceof Sk.builtin.ImportError)) {
    var o = Object.create(Sk.builtin.ImportError.prototype);
    o.constructor.apply(o, arguments);
    return o;
  }
  Sk.builtin.Exception.apply(this, arguments);
};
goog.inherits(Sk.builtin.ImportError, Sk.builtin.Exception);
Sk.builtin.ImportError.prototype.tp$name = 'ImportError';
Sk.builtin.IndentationError = function (args) {
  if (!(this instanceof Sk.builtin.IndentationError)) {
    var o = Object.create(Sk.builtin.IndentationError.prototype);
    o.constructor.apply(o, arguments);
    return o;
  }
  Sk.builtin.Exception.apply(this, arguments);
};
goog.inherits(Sk.builtin.IndentationError, Sk.builtin.Exception);
Sk.builtin.IndentationError.prototype.tp$name = 'IndentationError';
Sk.builtin.IndexError = function (args) {
  if (!(this instanceof Sk.builtin.IndexError)) {
    var o = Object.create(Sk.builtin.IndexError.prototype);
    o.constructor.apply(o, arguments);
    return o;
  }
  Sk.builtin.Exception.apply(this, arguments);
};
goog.inherits(Sk.builtin.IndexError, Sk.builtin.Exception);
Sk.builtin.IndexError.prototype.tp$name = 'IndexError';
Sk.builtin.KeyError = function (args) {
  if (!(this instanceof Sk.builtin.KeyError)) {
    var o = Object.create(Sk.builtin.KeyError.prototype);
    o.constructor.apply(o, arguments);
    return o;
  }
  Sk.builtin.Exception.apply(this, arguments);
};
goog.inherits(Sk.builtin.KeyError, Sk.builtin.Exception);
Sk.builtin.KeyError.prototype.tp$name = 'KeyError';
Sk.builtin.NameError = function (args) {
  if (!(this instanceof Sk.builtin.NameError)) {
    var o = Object.create(Sk.builtin.NameError.prototype);
    o.constructor.apply(o, arguments);
    return o;
  }
  Sk.builtin.Exception.apply(this, arguments);
};
goog.inherits(Sk.builtin.NameError, Sk.builtin.Exception);
Sk.builtin.NameError.prototype.tp$name = 'NameError';
Sk.builtin.OverflowError = function (args) {
  if (!(this instanceof Sk.builtin.OverflowError)) {
    var o = Object.create(Sk.builtin.OverflowError.prototype);
    o.constructor.apply(o, arguments);
    return o;
  }
  Sk.builtin.Exception.apply(this, arguments);
};
goog.inherits(Sk.builtin.OverflowError, Sk.builtin.Exception);
Sk.builtin.OverflowError.prototype.tp$name = 'OverflowError';
Sk.builtin.ParseError = function (args) {
  if (!(this instanceof Sk.builtin.ParseError)) {
    var o = Object.create(Sk.builtin.ParseError.prototype);
    o.constructor.apply(o, arguments);
    return o;
  }
  Sk.builtin.Exception.apply(this, arguments);
};
goog.inherits(Sk.builtin.ParseError, Sk.builtin.Exception);
Sk.builtin.ParseError.prototype.tp$name = 'ParseError';
Sk.builtin.SystemExit = function (args) {
  if (!(this instanceof Sk.builtin.SystemExit)) {
    var o = Object.create(Sk.builtin.SystemExit.prototype);
    o.constructor.apply(o, arguments);
    return o;
  }
  Sk.builtin.Exception.apply(this, arguments);
};
goog.inherits(Sk.builtin.SystemExit, Sk.builtin.Exception);
Sk.builtin.SystemExit.prototype.tp$name = 'SystemExit';
goog.exportSymbol('Sk.builtin.SystemExit', Sk.builtin.SystemExit);
Sk.builtin.SyntaxError = function (args) {
  if (!(this instanceof Sk.builtin.SyntaxError)) {
    var o = Object.create(Sk.builtin.SyntaxError.prototype);
    o.constructor.apply(o, arguments);
    return o;
  }
  Sk.builtin.Exception.apply(this, arguments);
};
goog.inherits(Sk.builtin.SyntaxError, Sk.builtin.Exception);
Sk.builtin.SyntaxError.prototype.tp$name = 'SyntaxError';
Sk.builtin.TokenError = function (args) {
  if (!(this instanceof Sk.builtin.TokenError)) {
    var o = Object.create(Sk.builtin.TokenError.prototype);
    o.constructor.apply(o, arguments);
    return o;
  }
  Sk.builtin.Exception.apply(this, arguments);
};
goog.inherits(Sk.builtin.TokenError, Sk.builtin.Exception);
Sk.builtin.TokenError.prototype.tp$name = 'TokenError';
Sk.builtin.TypeError = function (args) {
  if (!(this instanceof Sk.builtin.TypeError)) {
    var o = Object.create(Sk.builtin.TypeError.prototype);
    o.constructor.apply(o, arguments);
    return o;
  }
  Sk.builtin.Exception.apply(this, arguments);
};
goog.inherits(Sk.builtin.TypeError, Sk.builtin.Exception);
Sk.builtin.TypeError.prototype.tp$name = 'TypeError';
goog.exportSymbol('Sk.builtin.TypeError', Sk.builtin.TypeError);
Sk.builtin.ValueError = function (args) {
  if (!(this instanceof Sk.builtin.ValueError)) {
    var o = Object.create(Sk.builtin.ValueError.prototype);
    o.constructor.apply(o, arguments);
    return o;
  }
  Sk.builtin.Exception.apply(this, arguments);
};
goog.inherits(Sk.builtin.ValueError, Sk.builtin.Exception);
Sk.builtin.ValueError.prototype.tp$name = 'ValueError';
goog.exportSymbol('Sk.builtin.ValueError', Sk.builtin.ValueError);
Sk.builtin.ZeroDivisionError = function (args) {
  if (!(this instanceof Sk.builtin.ZeroDivisionError)) {
    var o = Object.create(Sk.builtin.ZeroDivisionError.prototype);
    o.constructor.apply(o, arguments);
    return o;
  }
  Sk.builtin.Exception.apply(this, arguments);
};
goog.inherits(Sk.builtin.ZeroDivisionError, Sk.builtin.Exception);
Sk.builtin.ZeroDivisionError.prototype.tp$name = 'ZeroDivisionError';
Sk.builtin.TimeLimitError = function (args) {
  if (!(this instanceof Sk.builtin.TimeLimitError)) {
    var o = Object.create(Sk.builtin.TimeLimitError.prototype);
    o.constructor.apply(o, arguments);
    return o;
  }
  Sk.builtin.Exception.apply(this, arguments);
};
goog.inherits(Sk.builtin.TimeLimitError, Sk.builtin.Exception);
Sk.builtin.TimeLimitError.prototype.tp$name = 'TimeLimitError';
goog.exportSymbol('Sk.builtin.TimeLimitError', Sk.builtin.TimeLimitError);
Sk.builtin.IOError = function (args) {
  if (!(this instanceof Sk.builtin.IOError)) {
    var o = Object.create(Sk.builtin.IOError.prototype);
    o.constructor.apply(o, arguments);
    return o;
  }
  Sk.builtin.Exception.apply(this, arguments);
};
goog.inherits(Sk.builtin.IOError, Sk.builtin.Exception);
Sk.builtin.IOError.prototype.tp$name = 'IOError';
goog.exportSymbol('Sk.builtin.IOError', Sk.builtin.IOError);
Sk.builtin.NotImplementedError = function (args) {
  if (!(this instanceof Sk.builtin.NotImplementedError)) {
    var o = Object.create(Sk.builtin.NotImplementedError.prototype);
    o.constructor.apply(o, arguments);
    return o;
  }
  Sk.builtin.Exception.apply(this, arguments);
};
goog.inherits(Sk.builtin.NotImplementedError, Sk.builtin.Exception);
Sk.builtin.NotImplementedError.prototype.tp$name = 'NotImplementedError';
goog.exportSymbol('Sk.builtin.NotImplementedError', Sk.builtin.NotImplementedError);
Sk.builtin.NegativePowerError = function (args) {
  if (!(this instanceof Sk.builtin.NegativePowerError)) {
    var o = Object.create(Sk.builtin.NegativePowerError.prototype);
    o.constructor.apply(o, arguments);
    return o;
  }
  Sk.builtin.Exception.apply(this, arguments);
};
goog.inherits(Sk.builtin.NegativePowerError, Sk.builtin.Exception);
Sk.builtin.NegativePowerError.prototype.tp$name = 'NegativePowerError';
goog.exportSymbol('Sk.builtin.NegativePowerError', Sk.builtin.NegativePowerError);
Sk.builtin.OperationError = function (args) {
  if (!(this instanceof Sk.builtin.OperationError)) {
    var o = Object.create(Sk.builtin.OperationError.prototype);
    o.constructor.apply(o, arguments);
    return o;
  }
  Sk.builtin.Exception.apply(this, arguments);
};
goog.inherits(Sk.builtin.OperationError, Sk.builtin.Exception);
Sk.builtin.OperationError.prototype.tp$name = 'OperationError';
goog.exportSymbol('Sk.builtin.OperationError', Sk.builtin.OperationError);
Sk.builtin.SystemError = function (args) {
  if (!(this instanceof Sk.builtin.SystemError)) {
    var o = Object.create(Sk.builtin.SystemError.prototype);
    o.constructor.apply(o, arguments);
    return o;
  }
  Sk.builtin.Exception.apply(this, arguments);
};
goog.inherits(Sk.builtin.SystemError, Sk.builtin.Exception);
Sk.builtin.SystemError.prototype.tp$name = 'SystemError';
goog.exportSymbol('Sk.builtin.SystemError', Sk.builtin.SystemError);
Sk.currLineNo = -1;
Sk.currColNo = -1;
Sk.currFilename = '';
goog.exportSymbol('Sk', Sk);
goog.exportProperty(Sk, 'currLineNo', Sk.currLineNo);
goog.exportProperty(Sk, 'currColNo', Sk.currColNo);
goog.exportProperty(Sk, 'currFilename', Sk.currFilename);
Sk.builtin.type = function (name, bases, dict) {
  if (bases === undefined && dict === undefined) {
    var obj = name;
    if (obj.constructor === Sk.builtin.nmber) {
      if (obj.skType === Sk.builtin.nmber.int$) {
        return Sk.builtin.int_.prototype.ob$type;
      } else {
        return Sk.builtin.float_.prototype.ob$type;
      }
    }
    return obj.ob$type;
  } else {
    var klass = function (kwdict, varargseq, kws, args) {
      if (!(this instanceof klass)) {
        return new klass(kwdict, varargseq, kws, args);
      }
      args = args || [];
      this['$d'] = new Sk.builtin.dict([]);
      var init = Sk.builtin.type.typeLookup(this.ob$type, '__init__');
      if (init !== undefined) {
        args.unshift(this);
        Sk.misceval.apply(init, kwdict, varargseq, kws, args);
      }
      return this;
    };
    for (var v in dict) {
      klass.prototype[v] = dict[v];
      klass[v] = dict[v];
    }
    klass['__class__'] = klass;
    klass.sk$klass = true;
    klass.prototype.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;
    klass.prototype.tp$setattr = Sk.builtin.object.prototype.GenericSetAttr;
    klass.prototype.tp$descr_get = function () {
      goog.asserts.fail('in type tp$descr_get');
    };
    klass.prototype['$r'] = function () {
      var reprf = this.tp$getattr('__repr__');
      if (reprf !== undefined)
        return Sk.misceval.apply(reprf, undefined, undefined, undefined, []);
      var mod = dict.__module__;
      var cname = '';
      if (mod)
        cname = mod.v + '.';
      return new Sk.builtin.str('<' + cname + name + ' object>');
    };
    klass.prototype.tp$str = function () {
      var strf = this.tp$getattr('__str__');
      if (strf !== undefined)
        return Sk.misceval.apply(strf, undefined, undefined, undefined, []);
      return this['$r']();
    };
    klass.prototype.tp$length = function () {
      var lenf = this.tp$getattr('__len__');
      if (lenf !== undefined)
        return Sk.misceval.apply(lenf, undefined, undefined, undefined, []);
      var tname = Sk.abstr.typeName(this);
      throw new Sk.builtin.AttributeError(tname + ' instance has no attribute \'__len__\'');
    };
    klass.prototype.tp$call = function (args, kw) {
      var callf = this.tp$getattr('__call__');
      if (callf)
        return Sk.misceval.apply(callf, undefined, undefined, kw, args);
      throw new Sk.builtin.TypeError('\'' + Sk.abstr.typeName(this) + '\' object is not callable');
    };
    klass.prototype.tp$iter = function () {
      var iterf = this.tp$getattr('__iter__');
      var tname = Sk.abstr.typeName(this);
      if (iterf) {
        var ret = Sk.misceval.callsim(iterf);
        if (ret.tp$getattr('next') === undefined)
          throw new Sk.builtin.TypeError('iter() return non-iterator of type \'' + tname + '\'');
        return ret;
      }
      throw new Sk.builtin.TypeError('\'' + tname + '\' object is not iterable');
    };
    klass.prototype.tp$iternext = function () {
      var iternextf = this.tp$getattr('next');
      goog.asserts.assert(iternextf !== undefined, 'iter() should have caught this');
      return Sk.misceval.callsim(iternextf);
    };
    klass.prototype.tp$getitem = function (key) {
      var getf = this.tp$getattr('__getitem__');
      if (getf !== undefined)
        return Sk.misceval.apply(getf, undefined, undefined, undefined, [key]);
      throw new Sk.builtin.TypeError('\'' + Sk.abstr.typeName(this) + '\' object does not support indexing');
    };
    klass.prototype.tp$setitem = function (key, value) {
      var setf = this.tp$getattr('__setitem__');
      if (setf !== undefined)
        return Sk.misceval.apply(setf, undefined, undefined, undefined, [
          key,
          value
        ]);
      throw new Sk.builtin.TypeError('\'' + Sk.abstr.typeName(this) + '\' object does not support item assignment');
    };
    klass.prototype.tp$name = name;
    if (bases) {
      klass['$d'] = new Sk.builtin.dict([]);
      klass['$d'].mp$ass_subscript(Sk.builtin.type.basesStr_, new Sk.builtin.tuple(bases));
      var mro = Sk.builtin.type.buildMRO(klass);
      klass['$d'].mp$ass_subscript(Sk.builtin.type.mroStr_, mro);
      klass.tp$mro = mro;
    }
    klass.prototype.ob$type = klass;
    Sk.builtin.type.makeIntoTypeObj(name, klass);
    klass.tp$setattr = Sk.builtin.type.prototype.tp$setattr;
    return klass;
  }
};
Sk.builtin.type.makeTypeObj = function (name, newedInstanceOfType) {
  var t = newedInstanceOfType;
  Sk.builtin.type.makeIntoTypeObj(name, t);
  return newedInstanceOfType;
};
Sk.builtin.type.makeIntoTypeObj = function (name, t) {
  goog.asserts.assert(name !== undefined);
  goog.asserts.assert(t !== undefined);
  t.ob$type = Sk.builtin.type;
  t.tp$name = name;
  t['$r'] = function () {
    var mod = t.__module__;
    var cname = '';
    if (mod)
      cname = mod.v + '.';
    var ctype = 'class';
    if (!mod && !t.sk$klass)
      ctype = 'type';
    return new Sk.builtin.str('<' + ctype + ' \'' + cname + t.tp$name + '\'>');
  };
  t.tp$str = undefined;
  t.tp$getattr = Sk.builtin.type.prototype.tp$getattr;
  t.tp$setattr = Sk.builtin.object.prototype.GenericSetAttr;
  t.tp$richcompare = Sk.builtin.type.prototype.tp$richcompare;
  t.sk$type = true;
  return t;
};
Sk.builtin.type.ob$type = Sk.builtin.type;
Sk.builtin.type.tp$name = 'type';
Sk.builtin.type['$r'] = function () {
  return new Sk.builtin.str('<type \'type\'>');
};
Sk.builtin.type.prototype.tp$getattr = function (name) {
  var tp = this;
  var descr = Sk.builtin.type.typeLookup(tp, name);
  var f;
  if (descr !== undefined && descr !== null && descr.ob$type !== undefined) {
    f = descr.ob$type.tp$descr_get;
  }
  if (this['$d']) {
    var res = this['$d'].mp$lookup(new Sk.builtin.str(name));
    if (res !== undefined) {
      return res;
    }
  }
  if (f) {
    return f.call(descr, null, tp);
  }
  if (descr !== undefined) {
    return descr;
  }
  return undefined;
};
Sk.builtin.type.prototype.tp$setattr = function (name, value) {
  this[name] = value;
};
Sk.builtin.type.typeLookup = function (type, name) {
  var mro = type.tp$mro;
  var pyname = new Sk.builtin.str(name);
  var base;
  var res;
  var i;
  if (!mro)
    return type.prototype[name];
  for (i = 0; i < mro.v.length; ++i) {
    base = mro.v[i];
    if (base.hasOwnProperty(name))
      return base[name];
    res = base['$d'].mp$lookup(pyname);
    if (res !== undefined) {
      return res;
    }
  }
  return undefined;
};
Sk.builtin.type.mroMerge_ = function (seqs) {
  var res = [];
  for (;;) {
    for (var i = 0; i < seqs.length; ++i) {
      var seq = seqs[i];
      if (seq.length !== 0)
        break;
    }
    if (i === seqs.length)
      return res;
    var cands = [];
    for (var i = 0; i < seqs.length; ++i) {
      var seq = seqs[i];
      if (seq.length !== 0) {
        var cand = seq[0];
        OUTER:
          for (var j = 0; j < seqs.length; ++j) {
            var sseq = seqs[j];
            for (var k = 1; k < sseq.length; ++k)
              if (sseq[k] === cand)
                break OUTER;
          }
        if (j === seqs.length)
          cands.push(cand);
      }
    }
    if (cands.length === 0)
      throw new Sk.builtin.TypeError('Inconsistent precedences in type hierarchy');
    var next = cands[0];
    res.push(next);
    for (var i = 0; i < seqs.length; ++i) {
      var seq = seqs[i];
      if (seq.length > 0 && seq[0] === next)
        seq.splice(0, 1);
    }
  }
};
Sk.builtin.type.buildMRO_ = function (klass) {
  var all = [[klass]];
  var kbases = klass['$d'].mp$subscript(Sk.builtin.type.basesStr_);
  for (var i = 0; i < kbases.v.length; ++i)
    all.push(Sk.builtin.type.buildMRO_(kbases.v[i]));
  var bases = [];
  for (var i = 0; i < kbases.v.length; ++i)
    bases.push(kbases.v[i]);
  all.push(bases);
  return Sk.builtin.type.mroMerge_(all);
};
Sk.builtin.type.buildMRO = function (klass) {
  return new Sk.builtin.tuple(Sk.builtin.type.buildMRO_(klass));
};
Sk.builtin.type.prototype.tp$richcompare = function (other, op) {
  if (other.ob$type != Sk.builtin.type)
    return undefined;
  if (!this['$r'] || !other['$r'])
    return undefined;
  var r1 = this['$r']();
  var r2 = other['$r']();
  return r1.tp$richcompare(r2, op);
};
Sk.builtin.object = function () {
  if (!(this instanceof Sk.builtin.object))
    return new Sk.builtin.object();
  this['$d'] = new Sk.builtin.dict([]);
  return this;
};
Sk.builtin.object.prototype.GenericGetAttr = function (name) {
  goog.asserts.assert(typeof name === 'string');
  var tp = this.ob$type;
  goog.asserts.assert(tp !== undefined, 'object has no ob$type!');
  var descr = Sk.builtin.type.typeLookup(tp, name);
  var f;
  if (descr !== undefined && descr !== null && descr.ob$type !== undefined) {
    f = descr.ob$type.tp$descr_get;
  }
  if (this['$d']) {
    var res;
    if (this['$d'].mp$lookup) {
      res = this['$d'].mp$lookup(new Sk.builtin.str(name));
    } else if (this['$d'].mp$subscript) {
      try {
        res = this['$d'].mp$subscript(new Sk.builtin.str(name));
      } catch (x) {
        res = undefined;
      }
    } else if (typeof this['$d'] === 'object')
      res = this['$d'][name];
    if (res !== undefined)
      return res;
  }
  if (f) {
    return f.call(descr, this, this.ob$type);
  }
  if (descr !== undefined) {
    return descr;
  }
  return undefined;
};
goog.exportSymbol('Sk.builtin.object.prototype.GenericGetAttr', Sk.builtin.object.prototype.GenericGetAttr);
Sk.builtin.object.prototype.GenericSetAttr = function (name, value) {
  goog.asserts.assert(typeof name === 'string');
  if (this['$d'].mp$ass_subscript)
    this['$d'].mp$ass_subscript(new Sk.builtin.str(name), value);
  else if (typeof this['$d'] === 'object')
    this['$d'][name] = value;
};
goog.exportSymbol('Sk.builtin.object.prototype.GenericSetAttr', Sk.builtin.object.prototype.GenericSetAttr);
Sk.builtin.object.prototype.HashNotImplemented = function () {
  throw new Sk.builtin.TypeError('unhashable type: \'' + Sk.abstr.typeName(this) + '\'');
};
Sk.builtin.object.prototype.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;
Sk.builtin.object.prototype.tp$setattr = Sk.builtin.object.prototype.GenericSetAttr;
Sk.builtin.object.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj('object', Sk.builtin.object);
Sk.builtin.none = function () {
};
Sk.builtin.none.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj('NoneType', Sk.builtin.none);
Sk.builtin.none.prototype.tp$name = 'NoneType';
Sk.builtin.none.none$ = Object.create(Sk.builtin.none.prototype, {
  v: {
    value: null,
    enumerable: true
  }
});
goog.exportSymbol('Sk.builtin.none', Sk.builtin.none);
Sk.builtin.bool = function (x) {
  Sk.builtin.pyCheckArgs('bool', arguments, 1);
  if (Sk.misceval.isTrue(x)) {
    return Sk.builtin.bool.true$;
  } else {
    return Sk.builtin.bool.false$;
  }
};
Sk.builtin.bool.prototype.tp$name = 'bool';
Sk.builtin.bool.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj('bool', Sk.builtin.bool);
Sk.builtin.bool.prototype['$r'] = function () {
  if (this.v)
    return new Sk.builtin.str('True');
  return new Sk.builtin.str('False');
};
Sk.builtin.bool.true$ = Object.create(Sk.builtin.bool.prototype, {
  v: {
    value: true,
    enumerable: true
  }
});
Sk.builtin.bool.false$ = Object.create(Sk.builtin.bool.prototype, {
  v: {
    value: false,
    enumerable: true
  }
});
goog.exportSymbol('Sk.builtin.bool', Sk.builtin.bool);
Sk.builtin.pyCheckArgs = function (name, args, minargs, maxargs, kwargs, free) {
  var nargs = args.length;
  var msg = '';
  if (maxargs === undefined) {
    maxargs = Infinity;
  }
  if (kwargs) {
    nargs -= 1;
  }
  if (free) {
    nargs -= 1;
  }
  if (nargs < minargs || nargs > maxargs) {
    if (minargs === maxargs) {
      msg = name + '() takes exactly ' + minargs + ' arguments';
    } else if (nargs < minargs) {
      msg = name + '() takes at least ' + minargs + ' arguments';
    } else {
      msg = name + '() takes at most ' + maxargs + ' arguments';
    }
    msg += ' (' + nargs + ' given)';
    throw new Sk.builtin.TypeError(msg);
  }
  ;
};
goog.exportSymbol('Sk.builtin.pyCheckArgs', Sk.builtin.pyCheckArgs);
Sk.builtin.pyCheckType = function (name, exptype, check) {
  if (!check) {
    throw new Sk.builtin.TypeError(name + ' must be a ' + exptype);
  }
  ;
};
goog.exportSymbol('Sk.builtin.pyCheckType', Sk.builtin.pyCheckType);
Sk.builtin.checkSequence = function (arg) {
  return arg !== null && arg.mp$subscript !== undefined;
};
goog.exportSymbol('Sk.builtin.checkSequence', Sk.builtin.checkSequence);
Sk.builtin.checkIterable = function (arg) {
  return arg !== null && arg.tp$iter !== undefined;
};
goog.exportSymbol('Sk.builtin.checkIterable', Sk.builtin.checkIterable);
Sk.builtin.checkNumber = function (arg) {
  return arg !== null && (typeof arg === 'number' || arg instanceof Sk.builtin.nmber || arg instanceof Sk.builtin.lng);
};
goog.exportSymbol('Sk.builtin.checkNumber', Sk.builtin.checkNumber);
Sk.builtin.checkInt = function (arg) {
  return arg !== null && (typeof arg === 'number' && arg === (arg | 0) || arg instanceof Sk.builtin.nmber && arg.skType === Sk.builtin.nmber.int$ || arg instanceof Sk.builtin.lng);
};
goog.exportSymbol('Sk.builtin.checkInt', Sk.builtin.checkInt);
Sk.builtin.checkString = function (arg) {
  return arg !== null && arg.__class__ == Sk.builtin.str;
};
goog.exportSymbol('Sk.builtin.checkString', Sk.builtin.checkString);
Sk.builtin.checkClass = function (arg) {
  return arg !== null && arg.sk$type;
};
goog.exportSymbol('Sk.builtin.checkClass', Sk.builtin.checkClass);
Sk.builtin.checkBool = function (arg) {
  return arg instanceof Sk.builtin.bool;
};
goog.exportSymbol('Sk.builtin.checkBool', Sk.builtin.checkBool);
Sk.builtin.checkFunction = function (arg) {
  return arg !== null && arg.tp$call !== undefined;
};
goog.exportSymbol('Sk.builtin.checkFunction', Sk.builtin.checkFunction);
Sk.builtin.func = function (code, globals, closure, closure2) {
  this.func_code = code;
  this.func_globals = globals || null;
  if (closure2 !== undefined) {
    for (var k in closure2)
      closure[k] = closure2[k];
  }
  this.func_closure = closure;
  return this;
};
goog.exportSymbol('Sk.builtin.func', Sk.builtin.func);
Sk.builtin.func.prototype.tp$name = 'function';
Sk.builtin.func.prototype.tp$descr_get = function (obj, objtype) {
  goog.asserts.assert(obj !== undefined && objtype !== undefined);
  if (obj == null)
    return this;
  return new Sk.builtin.method(this, obj);
};
Sk.builtin.func.prototype.tp$call = function (args, kw) {
  var name;
  if (this.func_closure) {
    args.push(this.func_closure);
  }
  var expectskw = this.func_code['co_kwargs'];
  var kwargsarr = [];
  if (this.func_code['no_kw'] && kw) {
    name = this.func_code && this.func_code['co_name'] && this.func_code['co_name'].v || '<native JS>';
    throw new Sk.builtin.TypeError(name + '() takes no keyword arguments');
  }
  if (kw) {
    var kwlen = kw.length;
    var varnames = this.func_code['co_varnames'];
    var numvarnames = varnames && varnames.length;
    for (var i = 0; i < kwlen; i += 2) {
      for (var j = 0; j < numvarnames; ++j) {
        if (kw[i] === varnames[j])
          break;
      }
      if (varnames && j !== numvarnames) {
        args[j] = kw[i + 1];
      } else if (expectskw) {
        kwargsarr.push(new Sk.builtin.str(kw[i]));
        kwargsarr.push(kw[i + 1]);
      } else {
        name = this.func_code && this.func_code['co_name'] && this.func_code['co_name'].v || '<native JS>';
        throw new Sk.builtin.TypeError(name + '() got an unexpected keyword argument \'' + kw[i] + '\'');
      }
    }
  }
  if (expectskw) {
    args.unshift(kwargsarr);
  }
  return this.func_code.apply(this.func_globals, args);
};
Sk.builtin.func.prototype.tp$getattr = function (key) {
  return this[key];
};
Sk.builtin.func.prototype.tp$setattr = function (key, value) {
  this[key] = value;
};
Sk.builtin.func.prototype.ob$type = Sk.builtin.type.makeTypeObj('function', new Sk.builtin.func(null, null));
Sk.builtin.func.prototype['$r'] = function () {
  var name = this.func_code && this.func_code['co_name'] && this.func_code['co_name'].v || '<native JS>';
  return new Sk.builtin.str('<function ' + name + '>');
};
Sk.nativejs = {
  FN_ARGS: /^function\s*[^\(]*\(\s*([^\)]*)\)/m,
  FN_ARG_SPLIT: /,/,
  FN_ARG: /^\s*(_?)(\S+?)\1\s*$/,
  STRIP_COMMENTS: /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm,
  formalParameterList: function (fn) {
    var fnText, argDecl;
    var args = [];
    fnText = fn.toString().replace(this.STRIP_COMMENTS, '');
    argDecl = fnText.match(this.FN_ARGS);
    var r = argDecl[1].split(this.FN_ARG_SPLIT);
    for (var a in r) {
      var arg = r[a];
      arg.replace(this.FN_ARG, function (all, underscore, name) {
        args.push(name);
      });
    }
    return args;
  },
  func: function (code) {
    code['co_name'] = new Sk.builtin.str(code.name);
    code['co_varnames'] = Sk.nativejs.formalParameterList(code);
    return new Sk.builtin.func(code);
  },
  func_nokw: function (code) {
    code['co_name'] = new Sk.builtin.str(code.name);
    code['co_varnames'] = Sk.nativejs.formalParameterList(code);
    code['no_kw'] = true;
    return new Sk.builtin.func(code);
  }
};
goog.exportSymbol('Sk.nativejs.func', Sk.nativejs.func);
goog.exportSymbol('Sk.nativejs.func_nokw', Sk.nativejs.func_nokw);
Sk.builtin.method = function (func, self) {
  this.im_func = func;
  this.im_self = self;
};
goog.exportSymbol('Sk.builtin.method', Sk.builtin.method);
Sk.builtin.method.prototype.tp$call = function (args, kw) {
  goog.asserts.assert(this.im_self, 'should just be a function, not a method since there\'s no self?');
  goog.asserts.assert(this.im_func instanceof Sk.builtin.func);
  args.unshift(this.im_self);
  if (kw) {
    var kwlen = kw.length;
    for (var i = 0; i < kwlen; i += 2) {
      var varnames = this.im_func.func_code['co_varnames'];
      var numvarnames = varnames && varnames.length;
      for (var j = 0; j < numvarnames; ++j) {
        if (kw[i] === varnames[j])
          break;
      }
      args[j] = kw[i + 1];
    }
  }
  return this.im_func.func_code.apply(this.im_func.func_globals, args);
};
Sk.builtin.method.prototype['$r'] = function () {
  var name = this.im_func.func_code && this.im_func.func_code['co_name'] && this.im_func.func_code['co_name'].v || '<native JS>';
  return new Sk.builtin.str('<bound method ' + this.im_self.ob$type.tp$name + '.' + name + ' of ' + this.im_self['$r']().v + '>');
};
Sk.misceval = {};
Sk.misceval.isIndex = function (o) {
  if (o === null || o.constructor === Sk.builtin.lng || o.tp$index || o === true || o === false) {
    return true;
  }
  return Sk.builtin.checkInt(o);
};
goog.exportSymbol('Sk.misceval.isIndex', Sk.misceval.isIndex);
Sk.misceval.asIndex = function (o) {
  if (!Sk.misceval.isIndex(o))
    return undefined;
  if (o === null)
    return undefined;
  if (o === true)
    return 1;
  if (o === false)
    return 0;
  if (typeof o === 'number')
    return o;
  if (o.constructor === Sk.builtin.nmber)
    return o.v;
  if (o.constructor === Sk.builtin.lng)
    return o.tp$index();
  goog.asserts.fail('todo;');
};
Sk.misceval.applySlice = function (u, v, w) {
  if (u.sq$slice && Sk.misceval.isIndex(v) && Sk.misceval.isIndex(w)) {
    var ilow = Sk.misceval.asIndex(v);
    if (ilow === undefined)
      ilow = 0;
    var ihigh = Sk.misceval.asIndex(w);
    if (ihigh === undefined)
      ihigh = 1e+100;
    return Sk.abstr.sequenceGetSlice(u, ilow, ihigh);
  }
  return Sk.abstr.objectGetItem(u, new Sk.builtin.slice(v, w, null));
};
goog.exportSymbol('Sk.misceval.applySlice', Sk.misceval.applySlice);
Sk.misceval.assignSlice = function (u, v, w, x) {
  if (u.sq$ass_slice && Sk.misceval.isIndex(v) && Sk.misceval.isIndex(w)) {
    var ilow = Sk.misceval.asIndex(v) || 0;
    var ihigh = Sk.misceval.asIndex(w) || 1e+100;
    if (x === null)
      Sk.abstr.sequenceDelSlice(u, ilow, ihigh);
    else
      Sk.abstr.sequenceSetSlice(u, ilow, ihigh, x);
  } else {
    var slice = new Sk.builtin.slice(v, w);
    if (x === null)
      return Sk.abstr.objectDelItem(u, slice);
    else
      return Sk.abstr.objectSetItem(u, slice, x);
  }
};
goog.exportSymbol('Sk.misceval.assignSlice', Sk.misceval.assignSlice);
Sk.misceval.arrayFromArguments = function (args) {
  if (args.length != 1) {
    return args;
  }
  var arg = args[0];
  if (arg instanceof Sk.builtin.set) {
    arg = arg.tp$iter().$obj;
  } else if (arg instanceof Sk.builtin.dict) {
    arg = Sk.builtin.dict.prototype['keys'].func_code(arg);
  } else if (arg instanceof Sk.builtin.str) {
    var res = [];
    for (var it = arg.tp$iter(), i = it.tp$iternext(); i !== undefined; i = it.tp$iternext()) {
      res.push(i);
    }
    return res;
  }
  if (arg instanceof Sk.builtin.list || arg instanceof Sk.builtin.tuple) {
    return arg.v;
  }
  return args;
};
goog.exportSymbol('Sk.misceval.arrayFromArguments', Sk.misceval.arrayFromArguments);
Sk.misceval.swappedOp_ = {
  'Eq': 'Eq',
  'NotEq': 'NotEq',
  'Lt': 'GtE',
  'LtE': 'Gt',
  'Gt': 'LtE',
  'GtE': 'Lt',
  'Is': 'IsNot',
  'IsNot': 'Is',
  'In_': 'NotIn',
  'NotIn': 'In_'
};
Sk.misceval.richCompareBool = function (v, w, op) {
  goog.asserts.assert(v !== null && v !== undefined, 'passed undefined or null parameter to Sk.misceval.richCompareBool');
  goog.asserts.assert(w !== null && w !== undefined, 'passed undefined or null parameter to Sk.misceval.richCompareBool');
  var v_type = new Sk.builtin.type(v);
  var w_type = new Sk.builtin.type(w);
  if (v_type !== w_type && (op === 'GtE' || op === 'Gt' || op === 'LtE' || op === 'Lt')) {
    var numeric_types = [
        Sk.builtin.float_.prototype.ob$type,
        Sk.builtin.int_.prototype.ob$type,
        Sk.builtin.lng.prototype.ob$type,
        Sk.builtin.bool.prototype.ob$type
      ];
    var sequence_types = [
        Sk.builtin.dict.prototype.ob$type,
        Sk.builtin.enumerate.prototype.ob$type,
        Sk.builtin.list.prototype.ob$type,
        Sk.builtin.str.prototype.ob$type,
        Sk.builtin.tuple.prototype.ob$type
      ];
    var v_num_type = numeric_types.indexOf(v_type);
    var v_seq_type = sequence_types.indexOf(v_type);
    var w_num_type = numeric_types.indexOf(w_type);
    var w_seq_type = sequence_types.indexOf(w_type);
    if (v_type === Sk.builtin.none.prototype.ob$type) {
      switch (op) {
      case 'Lt':
        return true;
      case 'LtE':
        return true;
      case 'Gt':
        return false;
      case 'GtE':
        return false;
      }
    }
    if (w_type === Sk.builtin.none.prototype.ob$type) {
      switch (op) {
      case 'Lt':
        return false;
      case 'LtE':
        return false;
      case 'Gt':
        return true;
      case 'GtE':
        return true;
      }
    }
    if (v_num_type !== -1 && w_seq_type !== -1) {
      switch (op) {
      case 'Lt':
        return true;
      case 'LtE':
        return true;
      case 'Gt':
        return false;
      case 'GtE':
        return false;
      }
    }
    if (v_seq_type !== -1 && w_num_type !== -1) {
      switch (op) {
      case 'Lt':
        return false;
      case 'LtE':
        return false;
      case 'Gt':
        return true;
      case 'GtE':
        return true;
      }
    }
    if (v_seq_type !== -1 && w_seq_type !== -1) {
      switch (op) {
      case 'Lt':
        return v_seq_type < w_seq_type;
      case 'LtE':
        return v_seq_type <= w_seq_type;
      case 'Gt':
        return v_seq_type > w_seq_type;
      case 'GtE':
        return v_seq_type >= w_seq_type;
      }
    }
  }
  if (op === 'Is') {
    if (v instanceof Sk.builtin.nmber && w instanceof Sk.builtin.nmber) {
      return v.numberCompare(w) === 0 && v.skType === w.skType;
    } else if (v instanceof Sk.builtin.lng && w instanceof Sk.builtin.lng) {
      return v.longCompare(w) === 0;
    }
    return v === w;
  }
  if (op === 'IsNot') {
    if (v instanceof Sk.builtin.nmber && w instanceof Sk.builtin.nmber) {
      return v.numberCompare(w) !== 0 || v.skType !== w.skType;
    } else if (v instanceof Sk.builtin.lng && w instanceof Sk.builtin.lng) {
      return v.longCompare(w) !== 0;
    }
    return v !== w;
  }
  if (op === 'In')
    return Sk.abstr.sequenceContains(w, v);
  if (op === 'NotIn')
    return !Sk.abstr.sequenceContains(w, v);
  var res;
  if (v.tp$richcompare && (res = v.tp$richcompare(w, op)) !== undefined) {
    return res;
  }
  if (w.tp$richcompare && (res = w.tp$richcompare(v, Sk.misceval.swappedOp_[op])) !== undefined) {
    return res;
  }
  var op2method = {
      'Eq': '__eq__',
      'NotEq': '__ne__',
      'Gt': '__gt__',
      'GtE': '__ge__',
      'Lt': '__lt__',
      'LtE': '__le__'
    };
  var method = op2method[op];
  var swapped_method = op2method[Sk.misceval.swappedOp_[op]];
  if (v[method]) {
    return Sk.misceval.callsim(v[method], v, w);
  } else if (w[swapped_method]) {
    return Sk.misceval.callsim(w[swapped_method], w, v);
  }
  if (v['__cmp__']) {
    var ret = Sk.misceval.callsim(v['__cmp__'], v, w);
    ret = Sk.builtin.asnum$(ret);
    if (op === 'Eq')
      return ret === 0;
    else if (op === 'NotEq')
      return ret !== 0;
    else if (op === 'Lt')
      return ret < 0;
    else if (op === 'Gt')
      return ret > 0;
    else if (op === 'LtE')
      return ret <= 0;
    else if (op === 'GtE')
      return ret >= 0;
  }
  if (w['__cmp__']) {
    var ret = Sk.misceval.callsim(w['__cmp__'], w, v);
    ret = Sk.builtin.asnum$(ret);
    if (op === 'Eq')
      return ret === 0;
    else if (op === 'NotEq')
      return ret !== 0;
    else if (op === 'Lt')
      return ret > 0;
    else if (op === 'Gt')
      return ret < 0;
    else if (op === 'LtE')
      return ret >= 0;
    else if (op === 'GtE')
      return ret <= 0;
  }
  if (v instanceof Sk.builtin.none && w instanceof Sk.builtin.none || v instanceof Sk.builtin.bool && w instanceof Sk.builtin.bool) {
    if (op === 'Eq')
      return v.v === w.v;
    if (op === 'NotEq')
      return v.v !== w.v;
    if (op === 'Gt')
      return v.v > w.v;
    if (op === 'GtE')
      return v.v >= w.v;
    if (op === 'Lt')
      return v.v < w.v;
    if (op === 'LtE')
      return v.v <= w.v;
  }
  if (op === 'Eq') {
    if (v instanceof Sk.builtin.str && w instanceof Sk.builtin.str)
      return v.v === w.v;
    return v === w;
  }
  if (op === 'NotEq') {
    if (v instanceof Sk.builtin.str && w instanceof Sk.builtin.str)
      return v.v !== w.v;
    return v !== w;
  }
  var vname = Sk.abstr.typeName(v);
  var wname = Sk.abstr.typeName(w);
  throw new Sk.builtin.ValueError('don\'t know how to compare \'' + vname + '\' and \'' + wname + '\'');
};
goog.exportSymbol('Sk.misceval.richCompareBool', Sk.misceval.richCompareBool);
Sk.misceval.objectRepr = function (v) {
  goog.asserts.assert(v !== undefined, 'trying to repr undefined');
  if (v === null || v instanceof Sk.builtin.none)
    return new Sk.builtin.str('None');
  else if (v === true)
    return new Sk.builtin.str('True');
  else if (v === false)
    return new Sk.builtin.str('False');
  else if (typeof v === 'number')
    return new Sk.builtin.str('' + v);
  else if (!v['$r']) {
    if (v.tp$name) {
      return new Sk.builtin.str('<' + v.tp$name + ' object>');
    } else {
      return new Sk.builtin.str('<unknown>');
    }
    ;
  } else if (v.constructor === Sk.builtin.nmber) {
    if (v.v === Infinity)
      return new Sk.builtin.str('inf');
    else if (v.v === -Infinity)
      return new Sk.builtin.str('-inf');
    else
      return new Sk.builtin.str('' + v.v);
  } else
    return v['$r']();
};
goog.exportSymbol('Sk.misceval.objectRepr', Sk.misceval.objectRepr);
Sk.misceval.opAllowsEquality = function (op) {
  switch (op) {
  case 'LtE':
  case 'Eq':
  case 'GtE':
    return true;
  }
  return false;
};
goog.exportSymbol('Sk.misceval.opAllowsEquality', Sk.misceval.opAllowsEquality);
Sk.misceval.isTrue = function (x) {
  if (x === true)
    return true;
  if (x === false)
    return false;
  if (x === null)
    return false;
  if (x.constructor === Sk.builtin.none)
    return false;
  if (x.constructor === Sk.builtin.bool)
    return x.v;
  if (typeof x === 'number')
    return x !== 0;
  if (x instanceof Sk.builtin.lng)
    return x.nb$nonzero();
  if (x.constructor === Sk.builtin.nmber)
    return x.v !== 0;
  if (x.mp$length)
    return x.mp$length() !== 0;
  if (x.sq$length)
    return x.sq$length() !== 0;
  return true;
};
goog.exportSymbol('Sk.misceval.isTrue', Sk.misceval.isTrue);
Sk.misceval.softspace_ = false;
Sk.misceval.print_ = function (x) {
  if (Sk.misceval.softspace_) {
    if (x !== '\n')
      Sk.output(' ');
    Sk.misceval.softspace_ = false;
  }
  var s = new Sk.builtin.str(x);
  Sk.output(s.v);
  var isspace = function (c) {
    return c === '\n' || c === '\t' || c === '\r';
  };
  if (s.v.length === 0 || !isspace(s.v[s.v.length - 1]) || s.v[s.v.length - 1] === ' ')
    Sk.misceval.softspace_ = true;
};
goog.exportSymbol('Sk.misceval.print_', Sk.misceval.print_);
Sk.misceval.loadname = function (name, other) {
  var v = other[name];
  if (v !== undefined)
    return v;
  var bi = Sk.builtins[name];
  if (bi !== undefined)
    return bi;
  name = name.replace('_$rw$', '');
  name = name.replace('_$rn$', '');
  throw new Sk.builtin.NameError('name \'' + name + '\' is not defined');
};
goog.exportSymbol('Sk.misceval.loadname', Sk.misceval.loadname);
Sk.misceval.call = function (func, kwdict, varargseq, kws, args) {
  var args = Array.prototype.slice.call(arguments, 4);
  return Sk.misceval.apply(func, kwdict, varargseq, kws, args);
};
goog.exportSymbol('Sk.misceval.call', Sk.misceval.call);
Sk.misceval.callsim = function (func, args) {
  var args = Array.prototype.slice.call(arguments, 1);
  return Sk.misceval.apply(func, undefined, undefined, undefined, args);
};
goog.exportSymbol('Sk.misceval.callsim', Sk.misceval.callsim);
Sk.misceval.apply = function (func, kwdict, varargseq, kws, args) {
  if (func === null || func instanceof Sk.builtin.none) {
    throw new Sk.builtin.TypeError('\'' + Sk.abstr.typeName(func) + '\' object is not callable');
  } else if (typeof func === 'function') {
    if (func.sk$klass) {
      return func.apply(null, [
        kwdict,
        varargseq,
        kws,
        args
      ]);
    }
    if (varargseq) {
      for (var it = varargseq.tp$iter(), i = it.tp$iternext(); i !== undefined; i = it.tp$iternext()) {
        args.push(i);
      }
    }
    if (kwdict) {
      goog.asserts.fail('kwdict not implemented;');
    }
    goog.asserts.assert(kws === undefined || kws.length === 0);
    return func.apply(null, args);
  } else {
    var fcall = func.tp$call;
    if (fcall !== undefined) {
      if (varargseq) {
        for (var it = varargseq.tp$iter(), i = it.tp$iternext(); i !== undefined; i = it.tp$iternext()) {
          args.push(i);
        }
      }
      if (kwdict) {
        goog.asserts.fail('kwdict not implemented;');
      }
      return fcall.call(func, args, kws, kwdict);
    }
    fcall = func.__call__;
    if (fcall !== undefined) {
      args.unshift(func);
      return Sk.misceval.apply(fcall, kws, args, kwdict, varargseq);
    }
    throw new Sk.builtin.TypeError('\'' + Sk.abstr.typeName(func) + '\' object is not callable');
  }
};
goog.exportSymbol('Sk.misceval.apply', Sk.misceval.apply);
Sk.misceval.buildClass = function (globals, func, name, bases) {
  var meta = Sk.builtin.type;
  var locals = {};
  func(globals, locals, []);
  locals.__module__ = globals['__name__'];
  var klass = Sk.misceval.callsim(meta, name, bases, locals);
  return klass;
};
goog.exportSymbol('Sk.misceval.buildClass', Sk.misceval.buildClass);
Sk.abstr = {};
Sk.abstr.typeName = function (v) {
  var vtypename;
  if (v instanceof Sk.builtin.nmber) {
    vtypename = v.skType;
  } else if (v.tp$name !== undefined) {
    vtypename = v.tp$name;
  } else {
    vtypename = '<invalid type>';
  }
  ;
  return vtypename;
};
Sk.abstr.binop_type_error = function (v, w, name) {
  var vtypename = Sk.abstr.typeName(v);
  var wtypename = Sk.abstr.typeName(w);
  throw new Sk.builtin.TypeError('unsupported operand type(s) for ' + name + ': \'' + vtypename + '\' and \'' + wtypename + '\'');
};
Sk.abstr.boNameToSlotFuncLhs_ = function (obj, name) {
  if (obj === null) {
    return undefined;
  }
  ;
  switch (name) {
  case 'Add':
    return obj.nb$add ? obj.nb$add : obj['__add__'];
  case 'Sub':
    return obj.nb$subtract ? obj.nb$subtract : obj['__sub__'];
  case 'Mult':
    return obj.nb$multiply ? obj.nb$multiply : obj['__mul__'];
  case 'Div':
    return obj.nb$divide ? obj.nb$divide : obj['__div__'];
  case 'FloorDiv':
    return obj.nb$floor_divide ? obj.nb$floor_divide : obj['__floordiv__'];
  case 'Mod':
    return obj.nb$remainder ? obj.nb$remainder : obj['__mod__'];
  case 'Pow':
    return obj.nb$power ? obj.nb$power : obj['__pow__'];
  case 'LShift':
    return obj.nb$lshift ? obj.nb$lshift : obj['__lshift__'];
  case 'RShift':
    return obj.nb$rshift ? obj.nb$rshift : obj['__rshift__'];
  case 'BitAnd':
    return obj.nb$and ? obj.nb$and : obj['__and__'];
  case 'BitXor':
    return obj.nb$xor ? obj.nb$xor : obj['__xor__'];
  case 'BitOr':
    return obj.nb$or ? obj.nb$or : obj['__or__'];
  }
};
Sk.abstr.boNameToSlotFuncRhs_ = function (obj, name) {
  if (obj === null) {
    return undefined;
  }
  ;
  switch (name) {
  case 'Add':
    return obj.nb$add ? obj.nb$add : obj['__radd__'];
  case 'Sub':
    return obj.nb$subtract ? obj.nb$subtract : obj['__rsub__'];
  case 'Mult':
    return obj.nb$multiply ? obj.nb$multiply : obj['__rmul__'];
  case 'Div':
    return obj.nb$divide ? obj.nb$divide : obj['__rdiv__'];
  case 'FloorDiv':
    return obj.nb$floor_divide ? obj.nb$floor_divide : obj['__rfloordiv__'];
  case 'Mod':
    return obj.nb$remainder ? obj.nb$remainder : obj['__rmod__'];
  case 'Pow':
    return obj.nb$power ? obj.nb$power : obj['__rpow__'];
  case 'LShift':
    return obj.nb$lshift ? obj.nb$lshift : obj['__rlshift__'];
  case 'RShift':
    return obj.nb$rshift ? obj.nb$rshift : obj['__rrshift__'];
  case 'BitAnd':
    return obj.nb$and ? obj.nb$and : obj['__rand__'];
  case 'BitXor':
    return obj.nb$xor ? obj.nb$xor : obj['__rxor__'];
  case 'BitOr':
    return obj.nb$or ? obj.nb$or : obj['__ror__'];
  }
};
Sk.abstr.iboNameToSlotFunc_ = function (obj, name) {
  switch (name) {
  case 'Add':
    return obj.nb$inplace_add ? obj.nb$inplace_add : obj['__iadd__'];
  case 'Sub':
    return obj.nb$inplace_subtract ? obj.nb$inplace_subtract : obj['__isub__'];
  case 'Mult':
    return obj.nb$inplace_multiply ? obj.nb$inplace_multiply : obj['__imul__'];
  case 'Div':
    return obj.nb$inplace_divide ? obj.nb$inplace_divide : obj['__idiv__'];
  case 'FloorDiv':
    return obj.nb$inplace_floor_divide ? obj.nb$inplace_floor_divide : obj['__ifloordiv__'];
  case 'Mod':
    return obj.nb$inplace_remainder;
  case 'Pow':
    return obj.nb$inplace_power;
  case 'LShift':
    return obj.nb$inplace_lshift ? obj.nb$inplace_lshift : obj['__ilshift__'];
  case 'RShift':
    return obj.nb$inplace_rshift ? obj.nb$inplace_rshift : obj['__irshift__'];
  case 'BitAnd':
    return obj.nb$inplace_and;
  case 'BitOr':
    return obj.nb$inplace_or;
  case 'BitXor':
    return obj.nb$inplace_xor ? obj.nb$inplace_xor : obj['__ixor__'];
  }
};
Sk.abstr.binary_op_ = function (v, w, opname) {
  var ret;
  var vop = Sk.abstr.boNameToSlotFuncLhs_(v, opname);
  if (vop !== undefined) {
    if (vop.call) {
      ret = vop.call(v, w);
    } else {
      ret = Sk.misceval.callsim(vop, v, w);
    }
    if (ret !== undefined)
      return ret;
  }
  var wop = Sk.abstr.boNameToSlotFuncRhs_(w, opname);
  if (wop !== undefined) {
    if (wop.call) {
      ret = wop.call(w, v);
    } else {
      ret = Sk.misceval.callsim(wop, w, v);
    }
    if (ret !== undefined)
      return ret;
  }
  Sk.abstr.binop_type_error(v, w, opname);
};
Sk.abstr.binary_iop_ = function (v, w, opname) {
  var ret;
  var vop = Sk.abstr.iboNameToSlotFunc_(v, opname);
  if (vop !== undefined) {
    if (vop.call) {
      ret = vop.call(v, w);
    } else {
      ret = Sk.misceval.callsim(vop, v, w);
    }
    if (ret !== undefined)
      return ret;
  }
  var wop = Sk.abstr.iboNameToSlotFunc_(w, opname);
  if (wop !== undefined) {
    if (wop.call) {
      ret = wop.call(w, v);
    } else {
      ret = Sk.misceval.callsim(wop, w, v);
    }
    if (ret !== undefined)
      return ret;
  }
  Sk.abstr.binop_type_error(v, w, opname);
};
Sk.abstr.numOpAndPromote = function (a, b, opfn) {
  if (a === null || b === null) {
    return undefined;
  }
  ;
  if (typeof a === 'number' && typeof b === 'number') {
    var ans = opfn(a, b);
    if ((ans > Sk.builtin.lng.threshold$ || ans < -Sk.builtin.lng.threshold$) && Math.floor(ans) === ans) {
      return [
        Sk.builtin.lng.fromInt$(a),
        Sk.builtin.lng.fromInt$(b)
      ];
    } else
      return ans;
  } else if (a === undefined || b === undefined) {
    throw new Sk.builtin.NameError('Undefined variable in expression');
  }
  if (a.constructor === Sk.builtin.lng) {
    return [
      a,
      b
    ];
  } else if (a.constructor === Sk.builtin.nmber) {
    return [
      a,
      b
    ];
  } else if (typeof a === 'number') {
    var tmp = new Sk.builtin.nmber(a, undefined);
    return [
      tmp,
      b
    ];
  } else
    return undefined;
};
Sk.abstr.boNumPromote_ = {
  'Add': function (a, b) {
    return a + b;
  },
  'Sub': function (a, b) {
    return a - b;
  },
  'Mult': function (a, b) {
    return a * b;
  },
  'Mod': function (a, b) {
    if (b === 0)
      throw new Sk.builtin.ZeroDivisionError('division or modulo by zero');
    var m = a % b;
    return m * b < 0 ? m + b : m;
  },
  'Div': function (a, b) {
    if (b === 0)
      throw new Sk.builtin.ZeroDivisionError('division or modulo by zero');
    else
      return a / b;
  },
  'FloorDiv': function (a, b) {
    if (b === 0)
      throw new Sk.builtin.ZeroDivisionError('division or modulo by zero');
    else
      return Math.floor(a / b);
  },
  'Pow': Math.pow,
  'BitAnd': function (a, b) {
    var m = a & b;
    if (m < 0) {
      m = m + 4294967296;
    }
    return m;
  },
  'BitOr': function (a, b) {
    var m = a | b;
    if (m < 0) {
      m = m + 4294967296;
    }
    return m;
  },
  'BitXor': function (a, b) {
    var m = a ^ b;
    if (m < 0) {
      m = m + 4294967296;
    }
    return m;
  },
  'LShift': function (a, b) {
    if (b < 0) {
      throw new Sk.builtin.ValueError('negative shift count');
    }
    var m = a << b;
    if (m > a) {
      return m;
    } else {
      return a * Math.pow(2, b);
    }
  },
  'RShift': function (a, b) {
    if (b < 0) {
      throw new Sk.builtin.ValueError('negative shift count');
    }
    var m = a >> b;
    if (a > 0 && m < 0) {
      m = m & Math.pow(2, 32 - b) - 1;
    }
    return m;
  }
};
Sk.abstr.numberBinOp = function (v, w, op) {
  var numPromoteFunc = Sk.abstr.boNumPromote_[op];
  if (numPromoteFunc !== undefined) {
    var tmp = Sk.abstr.numOpAndPromote(v, w, numPromoteFunc);
    if (typeof tmp === 'number') {
      return tmp;
    } else if (tmp !== undefined && tmp.constructor === Sk.builtin.nmber) {
      return tmp;
    } else if (tmp !== undefined && tmp.constructor === Sk.builtin.lng) {
      return tmp;
    } else if (tmp !== undefined) {
      v = tmp[0];
      w = tmp[1];
    }
  }
  return Sk.abstr.binary_op_(v, w, op);
};
goog.exportSymbol('Sk.abstr.numberBinOp', Sk.abstr.numberBinOp);
Sk.abstr.numberInplaceBinOp = function (v, w, op) {
  var numPromoteFunc = Sk.abstr.boNumPromote_[op];
  if (numPromoteFunc !== undefined) {
    var tmp = Sk.abstr.numOpAndPromote(v, w, numPromoteFunc);
    if (typeof tmp === 'number') {
      return tmp;
    } else if (tmp !== undefined && tmp.constructor === Sk.builtin.nmber) {
      return tmp;
    } else if (tmp !== undefined && tmp.constructor === Sk.builtin.lng) {
      return tmp;
    } else if (tmp !== undefined) {
      v = tmp[0];
      w = tmp[1];
    }
  }
  return Sk.abstr.binary_iop_(v, w, op);
};
goog.exportSymbol('Sk.abstr.numberInplaceBinOp', Sk.abstr.numberInplaceBinOp);
Sk.abstr.numberUnaryOp = function (v, op) {
  if (op === 'Not')
    return Sk.misceval.isTrue(v) ? Sk.builtin.bool.false$ : Sk.builtin.bool.true$;
  else if (v instanceof Sk.builtin.nmber || v instanceof Sk.builtin.bool) {
    var value = Sk.builtin.asnum$(v);
    if (op === 'USub')
      return new Sk.builtin.nmber(-value, value.skType);
    if (op === 'UAdd')
      return new Sk.builtin.nmber(value, value.skType);
    if (op === 'Invert')
      return new Sk.builtin.nmber(~value, value.skType);
  } else {
    if (op === 'USub' && v.nb$negative)
      return v.nb$negative();
    if (op === 'UAdd' && v.nb$positive)
      return v.nb$positive();
    if (op === 'Invert' && v.nb$invert)
      return v.nb$invert();
  }
  var vtypename = Sk.abstr.typeName(v);
  throw new Sk.builtin.TypeError('unsupported operand type for ' + op + ' \'' + vtypename + '\'');
};
goog.exportSymbol('Sk.abstr.numberUnaryOp', Sk.abstr.numberUnaryOp);
Sk.abstr.fixSeqIndex_ = function (seq, i) {
  i = Sk.builtin.asnum$(i);
  if (i < 0 && seq.sq$length)
    i += seq.sq$length();
  return i;
};
Sk.abstr.sequenceContains = function (seq, ob) {
  if (seq.sq$contains)
    return seq.sq$contains(ob);
  var seqtypename = Sk.abstr.typeName(seq);
  if (!seq.tp$iter)
    throw new Sk.builtin.TypeError('argument of type \'' + seqtypename + '\' is not iterable');
  for (var it = seq.tp$iter(), i = it.tp$iternext(); i !== undefined; i = it.tp$iternext()) {
    if (Sk.misceval.richCompareBool(i, ob, 'Eq'))
      return true;
  }
  return false;
};
Sk.abstr.sequenceGetItem = function (seq, i) {
  goog.asserts.fail();
};
Sk.abstr.sequenceSetItem = function (seq, i, x) {
  goog.asserts.fail();
};
Sk.abstr.sequenceDelItem = function (seq, i) {
  if (seq.sq$del_item) {
    i = Sk.abstr.fixSeqIndex_(seq, i);
    seq.sq$del_item(i);
    return;
  }
  var seqtypename = Sk.abstr.typeName(seq);
  throw new Sk.builtin.TypeError('\'' + seqtypename + '\' object does not support item deletion');
};
Sk.abstr.sequenceRepeat = function (f, seq, n) {
  n = Sk.builtin.asnum$(n);
  var count = Sk.misceval.asIndex(n);
  if (count === undefined) {
    var ntypename = Sk.abstr.typeName(n);
    throw new Sk.builtin.TypeError('can\'t multiply sequence by non-int of type \'' + ntypename + '\'');
  }
  return f.call(seq, n);
};
Sk.abstr.sequenceGetSlice = function (seq, i1, i2) {
  if (seq.sq$slice) {
    i1 = Sk.abstr.fixSeqIndex_(seq, i1);
    i2 = Sk.abstr.fixSeqIndex_(seq, i2);
    return seq.sq$slice(i1, i2);
  } else if (seq.mp$subscript) {
    return seq.mp$subscript(new Sk.builtin.slice(i1, i2));
  }
  var seqtypename = Sk.abstr.typeName(seq);
  throw new Sk.builtin.TypeError('\'' + seqtypename + '\' object is unsliceable');
};
Sk.abstr.sequenceDelSlice = function (seq, i1, i2) {
  if (seq.sq$del_slice) {
    i1 = Sk.abstr.fixSeqIndex_(seq, i1);
    i2 = Sk.abstr.fixSeqIndex_(seq, i2);
    seq.sq$del_slice(i1, i2);
    return;
  }
  var seqtypename = Sk.abstr.typeName(seq);
  throw new Sk.builtin.TypeError('\'' + seqtypename + '\' doesn\'t support slice deletion');
};
Sk.abstr.sequenceSetSlice = function (seq, i1, i2, x) {
  if (seq.sq$ass_slice) {
    i1 = Sk.abstr.fixSeqIndex_(seq, i1);
    i2 = Sk.abstr.fixSeqIndex_(seq, i2);
    seq.sq$ass_slice(i1, i2, x);
  } else if (seq.mp$ass_subscript) {
    seq.mp$ass_subscript(new Sk.builtin.slice(i1, i2), x);
  } else {
    var seqtypename = Sk.abstr.typeName(seq);
    throw new Sk.builtin.TypeError('\'' + seqtypename + '\' object doesn\'t support slice assignment');
  }
};
Sk.abstr.objectDelItem = function (o, key) {
  if (o !== null) {
    if (o.mp$del_subscript) {
      o.mp$del_subscript(key);
      return;
    }
    if (o.sq$ass_item) {
      var keyValue = Sk.misceval.asIndex(key);
      if (keyValue === undefined) {
        var keytypename = Sk.abstr.typeName(key);
        throw new Sk.builtin.TypeError('sequence index must be integer, not \'' + keytypename + '\'');
      }
      Sk.abstr.sequenceDelItem(o, keyValue);
      return;
    }
  }
  var otypename = Sk.abstr.typeName(o);
  throw new Sk.builtin.TypeError('\'' + otypename + '\' object does not support item deletion');
};
goog.exportSymbol('Sk.abstr.objectDelItem', Sk.abstr.objectDelItem);
Sk.abstr.objectGetItem = function (o, key) {
  if (o !== null) {
    if (o.mp$subscript)
      return o.mp$subscript(key);
    else if (Sk.misceval.isIndex(key) && o.sq$item)
      return Sk.abstr.sequenceGetItem(o, Sk.misceval.asIndex(key));
    else if (o.tp$getitem) {
      return o.tp$getitem(key);
    }
  }
  var otypename = Sk.abstr.typeName(o);
  throw new Sk.builtin.TypeError('\'' + otypename + '\' does not support indexing');
};
goog.exportSymbol('Sk.abstr.objectGetItem', Sk.abstr.objectGetItem);
Sk.abstr.objectSetItem = function (o, key, v) {
  if (o !== null) {
    if (o.mp$ass_subscript)
      return o.mp$ass_subscript(key, v);
    else if (Sk.misceval.isIndex(key) && o.sq$ass_item)
      return Sk.abstr.sequenceSetItem(o, Sk.misceval.asIndex(key), v);
    else if (o.tp$setitem)
      return o.tp$setitem(key, v);
  }
  var otypename = Sk.abstr.typeName(o);
  throw new Sk.builtin.TypeError('\'' + otypename + '\' does not support item assignment');
};
goog.exportSymbol('Sk.abstr.objectSetItem', Sk.abstr.objectSetItem);
Sk.abstr.gattr = function (obj, nameJS) {
  var objname = Sk.abstr.typeName(obj);
  if (obj === null) {
    throw new Sk.builtin.AttributeError('\'' + objname + '\' object has no attribute \'' + nameJS + '\'');
  }
  var ret = undefined;
  if (obj['__getattr__']) {
    ret = Sk.misceval.callsim(obj['__getattr__'], obj, nameJS);
  } else if (obj.tp$getattr !== undefined) {
    ret = obj.tp$getattr(nameJS);
  }
  if (ret === undefined) {
    throw new Sk.builtin.AttributeError('\'' + objname + '\' object has no attribute \'' + nameJS + '\'');
  }
  return ret;
};
goog.exportSymbol('Sk.abstr.gattr', Sk.abstr.gattr);
Sk.abstr.sattr = function (obj, nameJS, data) {
  var objname = Sk.abstr.typeName(obj);
  if (obj === null) {
    throw new Sk.builtin.AttributeError('\'' + objname + '\' object has no attribute \'' + nameJS + '\'');
  } else if (obj['__setattr__']) {
    Sk.misceval.callsim(obj['__setattr__'], obj, nameJS, data);
  } else if (obj.tp$setattr !== undefined) {
    obj.tp$setattr(nameJS, data);
  } else {
    throw new Sk.builtin.AttributeError('\'' + objname + '\' object has no attribute \'' + nameJS + '\'');
  }
};
goog.exportSymbol('Sk.abstr.sattr', Sk.abstr.sattr);
Sk.abstr.iter = function (obj) {
  if (obj.tp$iter) {
    return obj.tp$iter();
  } else {
    throw new Sk.builtin.TypeError('\'' + Sk.abstr.typeName(obj) + '\' object is not iterable');
  }
};
goog.exportSymbol('Sk.abstr.iter', Sk.abstr.iter);
Sk.abstr.iternext = function (it) {
  return it.tp$iternext();
};
goog.exportSymbol('Sk.abstr.iternext', Sk.abstr.iternext);
Sk.mergeSort = function (arr, cmp, key, reverse) {
  Sk.quickSort(arr, cmp, key, reverse);
};
Sk.quickSort = function (arr, cmp, key, reverse) {
  goog.asserts.assert(!key, 'todo;');
  if (!cmp) {
    cmp = Sk.mergeSort.stdCmp;
  }
  var partition = function (arr, begin, end, pivot, reverse) {
    var tmp;
    var piv = arr[pivot];
    tmp = arr[pivot];
    arr[pivot] = arr[end - 1];
    arr[end - 1] = tmp;
    var store = begin;
    var ix;
    for (ix = begin; ix < end - 1; ++ix) {
      if (reverse) {
        var cmpresult = Sk.misceval.callsim(cmp, piv, arr[ix]);
      } else {
        var cmpresult = Sk.misceval.callsim(cmp, arr[ix], piv);
      }
      if (Sk.builtin.asnum$(cmpresult) < 0) {
        tmp = arr[store];
        arr[store] = arr[ix];
        arr[ix] = tmp;
        ++store;
      }
    }
    tmp = arr[end - 1];
    arr[end - 1] = arr[store];
    arr[store] = tmp;
    return store;
  };
  var qsort = function (arr, begin, end, reverse) {
    if (end - 1 > begin) {
      var pivot = begin + Math.floor(Math.random() * (end - begin));
      pivot = partition(arr, begin, end, pivot, reverse);
      qsort(arr, begin, pivot, reverse);
      qsort(arr, pivot + 1, end, reverse);
    }
  };
  qsort(arr, 0, arr.length, reverse);
  return null;
};
Sk.mergeSort.stdCmp = new Sk.builtin.func(function (k0, k1) {
  var res = Sk.misceval.richCompareBool(k0, k1, 'Lt') ? -1 : 0;
  return res;
});
Sk.builtin.list = function (L) {
  if (!(this instanceof Sk.builtin.list))
    return new Sk.builtin.list(L);
  if (L === undefined) {
    this.v = [];
  } else if (Object.prototype.toString.apply(L) === '[object Array]') {
    this.v = L;
  } else {
    if (L.tp$iter) {
      this.v = [];
      for (var it = L.tp$iter(), i = it.tp$iternext(); i !== undefined; i = it.tp$iternext())
        this.v.push(i);
    } else
      throw new Sk.builtin.ValueError('expecting Array or iterable');
  }
  this.__class__ = Sk.builtin.list;
  this['v'] = this.v;
  return this;
};
Sk.builtin.list.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj('list', Sk.builtin.list);
Sk.builtin.list.prototype.list_iter_ = function () {
  var ret = {
      tp$iter: function () {
        return ret;
      },
      $obj: this,
      $index: 0,
      tp$iternext: function () {
        if (ret.$index >= ret.$obj.v.length)
          return undefined;
        return ret.$obj.v[ret.$index++];
      }
    };
  return ret;
};
Sk.builtin.list.prototype.list_concat_ = function (other) {
  if (!other.__class__ || other.__class__ != Sk.builtin.list) {
    throw new Sk.builtin.TypeError('can only concatenate list to list');
  }
  var ret = this.v.slice();
  for (var i = 0; i < other.v.length; ++i) {
    ret.push(other.v[i]);
  }
  return new Sk.builtin.list(ret);
};
Sk.builtin.list.prototype.list_del_item_ = function (i) {
  i = Sk.builtin.asnum$(i);
  if (i < 0 || i >= this.v.length)
    throw new Sk.builtin.IndexError('list assignment index out of range');
  this.list_del_slice_(i, i + 1);
};
Sk.builtin.list.prototype.list_del_slice_ = function (ilow, ihigh) {
  ilow = Sk.builtin.asnum$(ilow);
  ihigh = Sk.builtin.asnum$(ihigh);
  var args = [];
  args.unshift(ihigh - ilow);
  args.unshift(ilow);
  this.v.splice.apply(this.v, args);
};
Sk.builtin.list.prototype.list_ass_item_ = function (i, v) {
  i = Sk.builtin.asnum$(i);
  if (i < 0 || i >= this.v.length)
    throw new Sk.builtin.IndexError('list assignment index out of range');
  this.v[i] = v;
};
Sk.builtin.list.prototype.list_ass_slice_ = function (ilow, ihigh, v) {
  ilow = Sk.builtin.asnum$(ilow);
  ihigh = Sk.builtin.asnum$(ihigh);
  var args = v.v.slice(0);
  args.unshift(ihigh - ilow);
  args.unshift(ilow);
  this.v.splice.apply(this.v, args);
};
Sk.builtin.list.prototype.tp$name = 'list';
Sk.builtin.list.prototype['$r'] = function () {
  var ret = [];
  for (var it = this.tp$iter(), i = it.tp$iternext(); i !== undefined; i = it.tp$iternext())
    ret.push(Sk.misceval.objectRepr(i).v);
  return new Sk.builtin.str('[' + ret.join(', ') + ']');
};
Sk.builtin.list.prototype.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;
Sk.builtin.list.prototype.tp$hash = Sk.builtin.object.prototype.HashNotImplemented;
Sk.builtin.list.prototype.tp$richcompare = function (w, op) {
  if (this === w && Sk.misceval.opAllowsEquality(op))
    return true;
  if (!w.__class__ || w.__class__ != Sk.builtin.list) {
    if (op === 'Eq')
      return false;
    if (op === 'NotEq')
      return true;
    return false;
  }
  var v = this.v;
  var w = w.v;
  var vl = v.length;
  var wl = w.length;
  var i;
  for (i = 0; i < vl && i < wl; ++i) {
    var k = Sk.misceval.richCompareBool(v[i], w[i], 'Eq');
    if (!k)
      break;
  }
  if (i >= vl || i >= wl) {
    switch (op) {
    case 'Lt':
      return vl < wl;
    case 'LtE':
      return vl <= wl;
    case 'Eq':
      return vl === wl;
    case 'NotEq':
      return vl !== wl;
    case 'Gt':
      return vl > wl;
    case 'GtE':
      return vl >= wl;
    default:
      goog.asserts.fail();
    }
  }
  if (op === 'Eq')
    return false;
  if (op === 'NotEq')
    return true;
  return Sk.misceval.richCompareBool(v[i], w[i], op);
};
Sk.builtin.list.prototype.tp$iter = Sk.builtin.list.prototype.list_iter_;
Sk.builtin.list.prototype.sq$length = function () {
  return this.v.length;
};
Sk.builtin.list.prototype.sq$concat = Sk.builtin.list.prototype.list_concat_;
Sk.builtin.list.prototype.nb$add = Sk.builtin.list.prototype.list_concat_;
Sk.builtin.list.prototype.nb$inplace_add = Sk.builtin.list.prototype.list_concat_;
Sk.builtin.list.prototype.sq$repeat = function (n) {
  n = Sk.builtin.asnum$(n);
  var ret = [];
  for (var i = 0; i < n; ++i)
    for (var j = 0; j < this.v.length; ++j)
      ret.push(this.v[j]);
  return new Sk.builtin.list(ret);
};
Sk.builtin.list.prototype.nb$multiply = Sk.builtin.list.prototype.sq$repeat;
Sk.builtin.list.prototype.nb$inplace_multiply = Sk.builtin.list.prototype.sq$repeat;
Sk.builtin.list.prototype.sq$ass_item = Sk.builtin.list.prototype.list_ass_item_;
Sk.builtin.list.prototype.sq$del_item = Sk.builtin.list.prototype.list_del_item_;
Sk.builtin.list.prototype.sq$ass_slice = Sk.builtin.list.prototype.list_ass_slice_;
Sk.builtin.list.prototype.sq$del_slice = Sk.builtin.list.prototype.list_del_slice_;
Sk.builtin.list.prototype.list_subscript_ = function (index) {
  if (Sk.misceval.isIndex(index)) {
    var i = Sk.misceval.asIndex(index);
    if (i !== undefined) {
      if (i < 0)
        i = this.v.length + i;
      if (i < 0 || i >= this.v.length) {
        throw new Sk.builtin.IndexError('list index out of range');
      }
      return this.v[i];
    }
  } else if (index instanceof Sk.builtin.slice) {
    var ret = [];
    index.sssiter$(this, function (i, wrt) {
      ret.push(wrt.v[i]);
    });
    return new Sk.builtin.list(ret);
  }
  throw new Sk.builtin.TypeError('list indices must be integers, not ' + Sk.abstr.typeName(index));
};
Sk.builtin.list.prototype.list_ass_subscript_ = function (index, value) {
  if (Sk.misceval.isIndex(index)) {
    var i = Sk.misceval.asIndex(index);
    if (i !== undefined) {
      if (i < 0)
        i = this.v.length + i;
      this.list_ass_item_(i, value);
      return;
    }
  } else if (index instanceof Sk.builtin.slice) {
    var step = index.step !== null ? index.step : 1;
    if (step === 1)
      this.list_ass_slice_(index.start, index.stop, value);
    else {
      var tosub = [];
      index.sssiter$(this, function (i, wrt) {
        tosub.push(i);
      });
      var j = 0;
      if (tosub.length !== value.v.length)
        throw new Sk.builtin.ValueError('attempt to assign sequence of size ' + value.v.length + ' to extended slice of size ' + tosub.length);
      for (var i = 0; i < tosub.length; ++i) {
        this.v.splice(tosub[i], 1, value.v[j]);
        j += 1;
      }
    }
    return;
  }
  throw new Sk.builtin.TypeError('list indices must be integers, not ' + Sk.abstr.typeName(index));
};
Sk.builtin.list.prototype.list_del_subscript_ = function (index) {
  if (Sk.misceval.isIndex(index)) {
    var i = Sk.misceval.asIndex(index);
    if (i !== undefined) {
      if (i < 0)
        i = this.v.length + i;
      this.list_del_item_(i);
      return;
    }
  } else if (index instanceof Sk.builtin.slice) {
    if (index.step === 1)
      this.list_del_slice_(index.start, index.stop);
    else {
      var self = this;
      var dec = 0;
      var step = index.step === null ? 1 : index.step;
      var offdir = step > 0 ? 1 : 0;
      index.sssiter$(this, function (i, wrt) {
        self.v.splice(i - dec, 1);
        dec += offdir;
      });
    }
    return;
  }
  throw new Sk.builtin.TypeError('list indices must be integers, not ' + typeof index);
};
Sk.builtin.list.prototype.mp$subscript = Sk.builtin.list.prototype.list_subscript_;
Sk.builtin.list.prototype.mp$ass_subscript = Sk.builtin.list.prototype.list_ass_subscript_;
Sk.builtin.list.prototype.mp$del_subscript = Sk.builtin.list.prototype.list_del_subscript_;
Sk.builtin.list.prototype.__getitem__ = new Sk.builtin.func(function (self, index) {
  return Sk.builtin.list.prototype.list_subscript_.call(self, index);
});
Sk.builtin.list.prototype.list_sort_ = function (self, cmp, key, reverse) {
  var has_key = key !== undefined && key !== null;
  var has_cmp = cmp !== undefined && cmp !== null;
  if (reverse == undefined) {
    reverse = false;
  }
  var timsort = new Sk.builtin.timSort(self);
  self.v = [];
  var zero = new Sk.builtin.nmber(0, Sk.builtin.nmber.int$);
  if (has_key) {
    if (has_cmp) {
      timsort.lt = function (a, b) {
        return Sk.misceval.richCompareBool(cmp.func_code(a[0], b[0]), zero, 'Lt');
      };
    } else {
      timsort.lt = function (a, b) {
        return Sk.misceval.richCompareBool(a[0], b[0], 'Lt');
      };
    }
    for (var i = 0; i < timsort.listlength; i++) {
      var item = timsort.list.v[i];
      var keyvalue = key.func_code(item);
      timsort.list.v[i] = [
        keyvalue,
        item
      ];
    }
  } else if (has_cmp) {
    timsort.lt = function (a, b) {
      return Sk.misceval.richCompareBool(cmp.func_code(a, b), zero, 'Lt');
    };
  }
  if (reverse) {
    timsort.list.list_reverse_(timsort.list);
  }
  timsort.sort();
  if (reverse) {
    timsort.list.list_reverse_(timsort.list);
  }
  if (has_key) {
    for (var j = 0; j < timsort.listlength; j++) {
      item = timsort.list.v[j][1];
      timsort.list.v[j] = item;
    }
  }
  var mucked = self.sq$length() > 0;
  self.v = timsort.list.v;
  if (mucked) {
    throw new Sk.builtin.OperationError('list modified during sort');
  }
};
Sk.builtin.list.prototype.list_reverse_ = function (self) {
  Sk.builtin.pyCheckArgs('reverse', arguments, 1, 1);
  var len = self.v.length;
  var old = self.v;
  var newarr = [];
  for (var i = len - 1; i > -1; --i) {
    newarr.push(old[i]);
  }
  self.v = newarr;
  return null;
};
Sk.builtin.list.prototype['append'] = new Sk.builtin.func(function (self, item) {
  Sk.builtin.pyCheckArgs('append', arguments, 2, 2);
  self.v.push(item);
  return null;
});
Sk.builtin.list.prototype['insert'] = new Sk.builtin.func(function (self, i, x) {
  Sk.builtin.pyCheckArgs('insert', arguments, 3, 3);
  if (!Sk.builtin.checkNumber(i)) {
    throw new Sk.builtin.TypeError('an integer is required');
  }
  ;
  i = Sk.builtin.asnum$(i);
  if (i < 0)
    i = 0;
  else if (i > self.v.length)
    i = self.v.length;
  self.v.splice(i, 0, x);
});
Sk.builtin.list.prototype['extend'] = new Sk.builtin.func(function (self, b) {
  Sk.builtin.pyCheckArgs('extend', arguments, 2, 2);
  if (!Sk.builtin.checkIterable(b)) {
    throw new Sk.builtin.TypeError('\'' + Sk.abstr.typeName(b) + '\' object is not iterable');
  }
  ;
  if (self == b) {
    var newb = [];
    for (var it = b.tp$iter(), i = it.tp$iternext(); i !== undefined; i = it.tp$iternext())
      newb.push(i);
    self.v.push.apply(self.v, newb);
    return null;
  }
  ;
  for (var it = b.tp$iter(), i = it.tp$iternext(); i !== undefined; i = it.tp$iternext())
    self.v.push(i);
  return null;
});
Sk.builtin.list.prototype['pop'] = new Sk.builtin.func(function (self, i) {
  Sk.builtin.pyCheckArgs('pop', arguments, 1, 2);
  if (i === undefined) {
    i = self.v.length - 1;
  }
  ;
  if (!Sk.builtin.checkNumber(i)) {
    throw new Sk.builtin.TypeError('an integer is required');
  }
  ;
  i = Sk.builtin.asnum$(i);
  if (i < 0 || i >= self.v.length) {
    throw new Sk.builtin.IndexError('pop index out of range');
  }
  ;
  var ret = self.v[i];
  self.v.splice(i, 1);
  return ret;
});
Sk.builtin.list.prototype['remove'] = new Sk.builtin.func(function (self, item) {
  Sk.builtin.pyCheckArgs('remove', arguments, 2, 2);
  var idx = Sk.builtin.list.prototype['index'].func_code(self, item);
  self.v.splice(idx, 1);
  return null;
});
Sk.builtin.list.prototype['index'] = new Sk.builtin.func(function (self, item) {
  Sk.builtin.pyCheckArgs('index', arguments, 2, 2);
  var len = self.v.length;
  var obj = self.v;
  for (var i = 0; i < len; ++i) {
    if (Sk.misceval.richCompareBool(obj[i], item, 'Eq'))
      return i;
  }
  throw new Sk.builtin.ValueError('list.index(x): x not in list');
});
Sk.builtin.list.prototype['count'] = new Sk.builtin.func(function (self, item) {
  Sk.builtin.pyCheckArgs('count', arguments, 2, 2);
  var len = self.v.length;
  var obj = self.v;
  var count = 0;
  for (var i = 0; i < len; ++i) {
    if (Sk.misceval.richCompareBool(obj[i], item, 'Eq')) {
      count += 1;
    }
  }
  return count;
});
Sk.builtin.list.prototype['reverse'] = new Sk.builtin.func(Sk.builtin.list.prototype.list_reverse_);
Sk.builtin.list.prototype['sort'] = new Sk.builtin.func(Sk.builtin.list.prototype.list_sort_);
Sk.builtin.list.prototype['sort'].func_code['co_varnames'] = [
  '__self__',
  'cmp',
  'key',
  'reverse'
];
goog.exportSymbol('Sk.builtin.list', Sk.builtin.list);
var interned = {};
Sk.builtin.str = function (x) {
  if (x === undefined)
    x = '';
  if (x instanceof Sk.builtin.str && x !== Sk.builtin.str.prototype.ob$type)
    return x;
  if (!(this instanceof Sk.builtin.str))
    return new Sk.builtin.str(x);
  var ret;
  if (x === true)
    ret = 'True';
  else if (x === false)
    ret = 'False';
  else if (x === null || x instanceof Sk.builtin.none)
    ret = 'None';
  else if (x instanceof Sk.builtin.bool) {
    if (x.v)
      ret = 'True';
    else
      ret = 'False';
  } else if (typeof x === 'number') {
    ret = x.toString();
    if (ret === 'Infinity')
      ret = 'inf';
    else if (ret === '-Infinity')
      ret = '-inf';
  } else if (typeof x === 'string')
    ret = x;
  else if (x.tp$str !== undefined) {
    ret = x.tp$str();
    if (!(ret instanceof Sk.builtin.str))
      throw new Sk.builtin.ValueError('__str__ didn\'t return a str');
    return ret;
  } else
    return Sk.misceval.objectRepr(x);
  if (Object.prototype.hasOwnProperty.call(interned, '1' + ret)) {
    return interned['1' + ret];
  }
  this.__class__ = Sk.builtin.str;
  this.v = ret;
  this['v'] = this.v;
  interned['1' + ret] = this;
  return this;
};
goog.exportSymbol('Sk.builtin.str', Sk.builtin.str);
Sk.builtin.str.$emptystr = new Sk.builtin.str('');
Sk.builtin.str.prototype.mp$subscript = function (index) {
  index = Sk.builtin.asnum$(index);
  if (typeof index === 'number' && Math.floor(index) === index) {
    if (index < 0)
      index = this.v.length + index;
    if (index < 0 || index >= this.v.length)
      throw new Sk.builtin.IndexError('string index out of range');
    return new Sk.builtin.str(this.v.charAt(index));
  } else if (index instanceof Sk.builtin.slice) {
    var ret = '';
    index.sssiter$(this, function (i, wrt) {
      if (i >= 0 && i < wrt.v.length)
        ret += wrt.v.charAt(i);
    });
    return new Sk.builtin.str(ret);
  } else
    throw new Sk.builtin.TypeError('string indices must be numbers, not ' + typeof index);
};
Sk.builtin.str.prototype.sq$length = function () {
  return this.v.length;
};
Sk.builtin.str.prototype.sq$concat = function (other) {
  if (!other || !Sk.builtin.checkString(other)) {
    var otypename = Sk.abstr.typeName(other);
    throw new Sk.builtin.TypeError('cannot concatenate \'str\' and \'' + otypename + '\' objects');
  }
  return new Sk.builtin.str(this.v + other.v);
};
Sk.builtin.str.prototype.nb$add = Sk.builtin.str.prototype.sq$concat;
Sk.builtin.str.prototype.nb$inplace_add = Sk.builtin.str.prototype.sq$concat;
Sk.builtin.str.prototype.sq$repeat = function (n) {
  n = Sk.builtin.asnum$(n);
  var ret = '';
  for (var i = 0; i < n; ++i)
    ret += this.v;
  return new Sk.builtin.str(ret);
};
Sk.builtin.str.prototype.nb$multiply = Sk.builtin.str.prototype.sq$repeat;
Sk.builtin.str.prototype.nb$inplace_multiply = Sk.builtin.str.prototype.sq$repeat;
Sk.builtin.str.prototype.sq$item = function () {
  goog.asserts.fail();
};
Sk.builtin.str.prototype.sq$slice = function (i1, i2) {
  i1 = Sk.builtin.asnum$(i1);
  i2 = Sk.builtin.asnum$(i2);
  if (i1 < 0)
    i1 = 0;
  return new Sk.builtin.str(this.v.substr(i1, i2 - i1));
};
Sk.builtin.str.prototype.sq$contains = function (ob) {
  if (ob.v === undefined || ob.v.constructor != String) {
    throw new Sk.builtin.TypeError('TypeError: \'In <string> requires string as left operand');
  }
  if (this.v.indexOf(ob.v) != -1) {
    return true;
  } else {
    return false;
  }
};
Sk.builtin.str.prototype.tp$name = 'str';
Sk.builtin.str.prototype.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;
Sk.builtin.str.prototype.tp$iter = function () {
  var ret = {
      tp$iter: function () {
        return ret;
      },
      $obj: this,
      $index: 0,
      tp$iternext: function () {
        if (ret.$index >= ret.$obj.v.length)
          return undefined;
        return new Sk.builtin.str(ret.$obj.v.substr(ret.$index++, 1));
      }
    };
  return ret;
};
Sk.builtin.str.prototype.tp$richcompare = function (other, op) {
  if (!(other instanceof Sk.builtin.str))
    return undefined;
  if (this === other) {
    switch (op) {
    case 'Eq':
    case 'LtE':
    case 'GtE':
      return true;
    case 'NotEq':
    case 'Lt':
    case 'Gt':
      return false;
    }
  }
  var lenA = this.v.length;
  var lenB = other.v.length;
  var minLength = Math.min(lenA, lenB);
  var c = 0;
  if (minLength > 0) {
    for (var i = 0; i < minLength; ++i) {
      if (this.v[i] != other.v[i]) {
        c = this.v[i].charCodeAt(0) - other.v[i].charCodeAt(0);
        break;
      }
    }
  } else {
    c = 0;
  }
  if (c == 0) {
    c = lenA < lenB ? -1 : lenA > lenB ? 1 : 0;
  }
  switch (op) {
  case 'Lt':
    return c < 0;
  case 'LtE':
    return c <= 0;
  case 'Eq':
    return c == 0;
  case 'NotEq':
    return c != 0;
  case 'Gt':
    return c > 0;
  case 'GtE':
    return c >= 0;
  default:
    goog.asserts.fail();
  }
};
Sk.builtin.str.prototype['$r'] = function () {
  var quote = '\'';
  if (this.v.indexOf('\'') !== -1 && this.v.indexOf('"') === -1) {
    quote = '"';
  }
  var len = this.v.length;
  var ret = quote;
  for (var i = 0; i < len; ++i) {
    var c = this.v.charAt(i);
    if (c === quote || c === '\\')
      ret += '\\' + c;
    else if (c === '\t')
      ret += '\\t';
    else if (c === '\n')
      ret += '\\n';
    else if (c === '\r')
      ret += '\\r';
    else if (c < ' ' || c >= 127) {
      var ashex = c.charCodeAt(0).toString(16);
      if (ashex.length < 2)
        ashex = '0' + ashex;
      ret += '\\x' + ashex;
    } else
      ret += c;
  }
  ret += quote;
  return new Sk.builtin.str(ret);
};
Sk.builtin.str.re_escape_ = function (s) {
  var ret = [];
  var re = /^[A-Za-z0-9]+$/;
  for (var i = 0; i < s.length; ++i) {
    var c = s.charAt(i);
    if (re.test(c)) {
      ret.push(c);
    } else {
      if (c === '\\000')
        ret.push('\\000');
      else
        ret.push('\\' + c);
    }
  }
  return ret.join('');
};
Sk.builtin.str.prototype['lower'] = new Sk.builtin.func(function (self) {
  Sk.builtin.pyCheckArgs('lower', arguments, 1, 1);
  return new Sk.builtin.str(self.v.toLowerCase());
});
Sk.builtin.str.prototype['upper'] = new Sk.builtin.func(function (self) {
  Sk.builtin.pyCheckArgs('upper', arguments, 1, 1);
  return new Sk.builtin.str(self.v.toUpperCase());
});
Sk.builtin.str.prototype['capitalize'] = new Sk.builtin.func(function (self) {
  Sk.builtin.pyCheckArgs('capitalize', arguments, 1, 1);
  var orig = self.v;
  var cap;
  var i;
  if (orig.length === 0) {
    return new Sk.builtin.str('');
  }
  ;
  cap = orig.charAt(0).toUpperCase();
  for (i = 1; i < orig.length; i++) {
    cap += orig.charAt(i).toLowerCase();
  }
  ;
  return new Sk.builtin.str(cap);
});
Sk.builtin.str.prototype['join'] = new Sk.builtin.func(function (self, seq) {
  Sk.builtin.pyCheckArgs('join', arguments, 2, 2);
  Sk.builtin.pyCheckType('seq', 'iterable', Sk.builtin.checkIterable(seq));
  var arrOfStrs = [];
  for (var it = seq.tp$iter(), i = it.tp$iternext(); i !== undefined; i = it.tp$iternext()) {
    if (i.constructor !== Sk.builtin.str)
      throw 'TypeError: sequence item ' + arrOfStrs.length + ': expected string, ' + typeof i + ' found';
    arrOfStrs.push(i.v);
  }
  return new Sk.builtin.str(arrOfStrs.join(self.v));
});
Sk.builtin.str.prototype['split'] = new Sk.builtin.func(function (self, on, howmany) {
  Sk.builtin.pyCheckArgs('split', arguments, 1, 3);
  if (on === undefined || on instanceof Sk.builtin.none) {
    on = null;
  }
  if (on !== null && !Sk.builtin.checkString(on)) {
    throw new Sk.builtin.TypeError('expected a string');
  }
  if (on !== null && on.v === '') {
    throw new Sk.builtin.ValueError('empty separator');
  }
  if (howmany !== undefined && !Sk.builtin.checkInt(howmany)) {
    throw new Sk.builtin.TypeError('an integer is required');
  }
  howmany = Sk.builtin.asnum$(howmany);
  var regex = /[\s]+/g;
  var str = self.v;
  if (on === null) {
    str = str.trimLeft();
  } else {
    var s = on.v.replace(/([.*+?=|\\\/()\[\]\{\}^$])/g, '\\$1');
    regex = new RegExp(s, 'g');
  }
  var result = [];
  var match;
  var index = 0;
  var splits = 0;
  while ((match = regex.exec(str)) != null) {
    if (match.index === regex.lastIndex) {
      break;
    }
    result.push(new Sk.builtin.str(str.substring(index, match.index)));
    index = regex.lastIndex;
    splits += 1;
    if (howmany && splits >= howmany) {
      break;
    }
  }
  str = str.substring(index);
  if (on !== null || str.length > 0) {
    result.push(new Sk.builtin.str(str));
  }
  return new Sk.builtin.list(result);
});
Sk.builtin.str.prototype['strip'] = new Sk.builtin.func(function (self, chars) {
  Sk.builtin.pyCheckArgs('strip', arguments, 1, 2);
  if (chars !== undefined && !Sk.builtin.checkString(chars)) {
    throw new Sk.builtin.TypeError('strip arg must be None or str');
  }
  var pattern;
  if (chars === undefined) {
    pattern = /^\s+|\s+$/g;
  } else {
    var regex = Sk.builtin.str.re_escape_(chars.v);
    pattern = new RegExp('^[' + regex + ']+|[' + regex + ']+$', 'g');
  }
  return new Sk.builtin.str(self.v.replace(pattern, ''));
});
Sk.builtin.str.prototype['lstrip'] = new Sk.builtin.func(function (self, chars) {
  Sk.builtin.pyCheckArgs('lstrip', arguments, 1, 2);
  if (chars !== undefined && !Sk.builtin.checkString(chars)) {
    throw new Sk.builtin.TypeError('lstrip arg must be None or str');
  }
  var pattern;
  if (chars === undefined) {
    pattern = /^\s+/g;
  } else {
    var regex = Sk.builtin.str.re_escape_(chars.v);
    pattern = new RegExp('^[' + regex + ']+', 'g');
  }
  return new Sk.builtin.str(self.v.replace(pattern, ''));
});
Sk.builtin.str.prototype['rstrip'] = new Sk.builtin.func(function (self, chars) {
  Sk.builtin.pyCheckArgs('rstrip', arguments, 1, 2);
  if (chars !== undefined && !Sk.builtin.checkString(chars)) {
    throw new Sk.builtin.TypeError('rstrip arg must be None or str');
  }
  var pattern;
  if (chars === undefined) {
    pattern = /\s+$/g;
  } else {
    var regex = Sk.builtin.str.re_escape_(chars.v);
    pattern = new RegExp('[' + regex + ']+$', 'g');
  }
  return new Sk.builtin.str(self.v.replace(pattern, ''));
});
Sk.builtin.str.prototype['partition'] = new Sk.builtin.func(function (self, sep) {
  Sk.builtin.pyCheckArgs('partition', arguments, 2, 2);
  Sk.builtin.pyCheckType('sep', 'string', Sk.builtin.checkString(sep));
  var sepStr = new Sk.builtin.str(sep);
  var pos = self.v.indexOf(sepStr.v);
  if (pos < 0) {
    return new Sk.builtin.tuple([
      self,
      Sk.builtin.str.$emptystr,
      Sk.builtin.str.$emptystr
    ]);
  }
  return new Sk.builtin.tuple([
    new Sk.builtin.str(self.v.substring(0, pos)),
    sepStr,
    new Sk.builtin.str(self.v.substring(pos + sepStr.v.length))
  ]);
});
Sk.builtin.str.prototype['rpartition'] = new Sk.builtin.func(function (self, sep) {
  Sk.builtin.pyCheckArgs('rpartition', arguments, 2, 2);
  Sk.builtin.pyCheckType('sep', 'string', Sk.builtin.checkString(sep));
  var sepStr = new Sk.builtin.str(sep);
  var pos = self.v.lastIndexOf(sepStr.v);
  if (pos < 0) {
    return new Sk.builtin.tuple([
      Sk.builtin.str.$emptystr,
      Sk.builtin.str.$emptystr,
      self
    ]);
  }
  return new Sk.builtin.tuple([
    new Sk.builtin.str(self.v.substring(0, pos)),
    sepStr,
    new Sk.builtin.str(self.v.substring(pos + sepStr.v.length))
  ]);
});
Sk.builtin.str.prototype['count'] = new Sk.builtin.func(function (self, pat, start, end) {
  Sk.builtin.pyCheckArgs('count', arguments, 2, 4);
  if (!Sk.builtin.checkString(pat)) {
    throw new Sk.builtin.TypeError('expected a character buffer object');
  }
  if (start !== undefined && !Sk.builtin.checkInt(start)) {
    throw new Sk.builtin.TypeError('slice indices must be integers or None or have an __index__ method');
  }
  if (end !== undefined && !Sk.builtin.checkInt(end)) {
    throw new Sk.builtin.TypeError('slice indices must be integers or None or have an __index__ method');
  }
  if (start === undefined)
    start = 0;
  else {
    start = Sk.builtin.asnum$(start);
    start = start >= 0 ? start : self.v.length + start;
  }
  if (end === undefined)
    end = self.v.length;
  else {
    end = Sk.builtin.asnum$(end);
    end = end >= 0 ? end : self.v.length + end;
  }
  var m = new RegExp(pat.v, 'g');
  var slice = self.v.slice(start, end);
  var ctl = slice.match(m);
  if (!ctl) {
    return 0;
  } else {
    return ctl.length;
  }
});
Sk.builtin.str.prototype['ljust'] = new Sk.builtin.func(function (self, len, fillchar) {
  Sk.builtin.pyCheckArgs('ljust', arguments, 2, 3);
  if (!Sk.builtin.checkInt(len)) {
    throw new Sk.builtin.TypeError('integer argument exepcted, got ' + Sk.abstr.typeName(len));
  }
  if (fillchar !== undefined && (!Sk.builtin.checkString(fillchar) || fillchar.v.length !== 1)) {
    throw new Sk.builtin.TypeError('must be char, not ' + Sk.abstr.typeName(fillchar));
  }
  if (fillchar === undefined) {
    fillchar = ' ';
  } else {
    fillchar = fillchar.v;
  }
  len = Sk.builtin.asnum$(len);
  if (self.v.length >= len) {
    return self;
  } else {
    var newstr = Array.prototype.join.call({ length: Math.floor(len - self.v.length) + 1 }, fillchar);
    return new Sk.builtin.str(self.v + newstr);
  }
});
Sk.builtin.str.prototype['rjust'] = new Sk.builtin.func(function (self, len, fillchar) {
  Sk.builtin.pyCheckArgs('rjust', arguments, 2, 3);
  if (!Sk.builtin.checkInt(len)) {
    throw new Sk.builtin.TypeError('integer argument exepcted, got ' + Sk.abstr.typeName(len));
  }
  if (fillchar !== undefined && (!Sk.builtin.checkString(fillchar) || fillchar.v.length !== 1)) {
    throw new Sk.builtin.TypeError('must be char, not ' + Sk.abstr.typeName(fillchar));
  }
  if (fillchar === undefined) {
    fillchar = ' ';
  } else {
    fillchar = fillchar.v;
  }
  len = Sk.builtin.asnum$(len);
  if (self.v.length >= len) {
    return self;
  } else {
    var newstr = Array.prototype.join.call({ length: Math.floor(len - self.v.length) + 1 }, fillchar);
    return new Sk.builtin.str(newstr + self.v);
  }
});
Sk.builtin.str.prototype['center'] = new Sk.builtin.func(function (self, len, fillchar) {
  Sk.builtin.pyCheckArgs('center', arguments, 2, 3);
  if (!Sk.builtin.checkInt(len)) {
    throw new Sk.builtin.TypeError('integer argument exepcted, got ' + Sk.abstr.typeName(len));
  }
  if (fillchar !== undefined && (!Sk.builtin.checkString(fillchar) || fillchar.v.length !== 1)) {
    throw new Sk.builtin.TypeError('must be char, not ' + Sk.abstr.typeName(fillchar));
  }
  if (fillchar === undefined) {
    fillchar = ' ';
  } else {
    fillchar = fillchar.v;
  }
  len = Sk.builtin.asnum$(len);
  if (self.v.length >= len) {
    return self;
  } else {
    var newstr1 = Array.prototype.join.call({ length: Math.floor((len - self.v.length) / 2) + 1 }, fillchar);
    var newstr = newstr1 + self.v + newstr1;
    if (newstr.length < len) {
      newstr = newstr + fillchar;
    }
    return new Sk.builtin.str(newstr);
  }
});
Sk.builtin.str.prototype['find'] = new Sk.builtin.func(function (self, tgt, start, end) {
  Sk.builtin.pyCheckArgs('find', arguments, 2, 4);
  if (!Sk.builtin.checkString(tgt)) {
    throw new Sk.builtin.TypeError('expected a character buffer object');
  }
  if (start !== undefined && !Sk.builtin.checkInt(start)) {
    throw new Sk.builtin.TypeError('slice indices must be integers or None or have an __index__ method');
  }
  if (end !== undefined && !Sk.builtin.checkInt(end)) {
    throw new Sk.builtin.TypeError('slice indices must be integers or None or have an __index__ method');
  }
  if (start === undefined)
    start = 0;
  else {
    start = Sk.builtin.asnum$(start);
    start = start >= 0 ? start : self.v.length + start;
  }
  if (end === undefined)
    end = self.v.length;
  else {
    end = Sk.builtin.asnum$(end);
    end = end >= 0 ? end : self.v.length + end;
  }
  var idx = self.v.indexOf(tgt.v, start);
  idx = idx >= start && idx < end ? idx : -1;
  return new Sk.builtin.nmber(idx, Sk.builtin.nmber.int$);
});
Sk.builtin.str.prototype['index'] = new Sk.builtin.func(function (self, tgt, start, end) {
  Sk.builtin.pyCheckArgs('index', arguments, 2, 4);
  var idx = Sk.misceval.callsim(self['find'], self, tgt, start, end);
  if (Sk.builtin.asnum$(idx) === -1) {
    throw new Sk.builtin.ValueError('substring not found');
  }
  ;
  return idx;
});
Sk.builtin.str.prototype['rfind'] = new Sk.builtin.func(function (self, tgt, start, end) {
  Sk.builtin.pyCheckArgs('rfind', arguments, 2, 4);
  if (!Sk.builtin.checkString(tgt)) {
    throw new Sk.builtin.TypeError('expected a character buffer object');
  }
  if (start !== undefined && !Sk.builtin.checkInt(start)) {
    throw new Sk.builtin.TypeError('slice indices must be integers or None or have an __index__ method');
  }
  if (end !== undefined && !Sk.builtin.checkInt(end)) {
    throw new Sk.builtin.TypeError('slice indices must be integers or None or have an __index__ method');
  }
  if (start === undefined)
    start = 0;
  else {
    start = Sk.builtin.asnum$(start);
    start = start >= 0 ? start : self.v.length + start;
  }
  if (end === undefined)
    end = self.v.length;
  else {
    end = Sk.builtin.asnum$(end);
    end = end >= 0 ? end : self.v.length + end;
  }
  var idx = self.v.lastIndexOf(tgt.v, end);
  idx = idx !== end ? idx : self.v.lastIndexOf(tgt.v, end - 1);
  idx = idx >= start && idx < end ? idx : -1;
  return new Sk.builtin.nmber(idx, Sk.builtin.nmber.int$);
});
Sk.builtin.str.prototype['rindex'] = new Sk.builtin.func(function (self, tgt, start, end) {
  Sk.builtin.pyCheckArgs('rindex', arguments, 2, 4);
  var idx = Sk.misceval.callsim(self['rfind'], self, tgt, start, end);
  if (Sk.builtin.asnum$(idx) === -1) {
    throw new Sk.builtin.ValueError('substring not found');
  }
  ;
  return idx;
});
Sk.builtin.str.prototype['startswith'] = new Sk.builtin.func(function (self, tgt) {
  Sk.builtin.pyCheckArgs('startswith', arguments, 2, 2);
  Sk.builtin.pyCheckType('tgt', 'string', Sk.builtin.checkString(tgt));
  return Sk.builtin.bool(0 == self.v.indexOf(tgt.v));
});
Sk.builtin.str.prototype['endswith'] = new Sk.builtin.func(function (self, tgt) {
  Sk.builtin.pyCheckArgs('endswith', arguments, 2, 2);
  Sk.builtin.pyCheckType('tgt', 'string', Sk.builtin.checkString(tgt));
  return Sk.builtin.bool(self.v.indexOf(tgt.v, self.v.length - tgt.v.length) !== -1);
});
Sk.builtin.str.prototype['replace'] = new Sk.builtin.func(function (self, oldS, newS, count) {
  Sk.builtin.pyCheckArgs('replace', arguments, 3, 4);
  Sk.builtin.pyCheckType('oldS', 'string', Sk.builtin.checkString(oldS));
  Sk.builtin.pyCheckType('newS', 'string', Sk.builtin.checkString(newS));
  if (count !== undefined && !Sk.builtin.checkInt(count)) {
    throw new Sk.builtin.TypeError('integer argument expected, got ' + Sk.abstr.typeName(count));
  }
  count = Sk.builtin.asnum$(count);
  var patt = new RegExp(Sk.builtin.str.re_escape_(oldS.v), 'g');
  if (count === undefined || count < 0) {
    return new Sk.builtin.str(self.v.replace(patt, newS.v));
  }
  var c = 0;
  function replacer(match) {
    c++;
    if (c <= count) {
      return newS.v;
    }
    return match;
  }
  return new Sk.builtin.str(self.v.replace(patt, replacer));
});
Sk.builtin.str.prototype['isdigit'] = new Sk.builtin.func(function (self) {
  Sk.builtin.pyCheckArgs('isdigit', arguments, 1, 1);
  if (self.v.length === 0) {
    return Sk.builtin.bool(false);
  }
  var i;
  for (i = 0; i < self.v.length; i++) {
    var ch = self.v.charAt(i);
    if (ch < '0' || ch > '9') {
      return Sk.builtin.bool(false);
    }
    ;
  }
  ;
  return Sk.builtin.bool(true);
});
Sk.builtin.str.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj('str', Sk.builtin.str);
Sk.builtin.str.prototype.nb$remainder = function (rhs) {
  if (rhs.constructor !== Sk.builtin.tuple && (rhs.mp$subscript === undefined || rhs.constructor === Sk.builtin.str))
    rhs = new Sk.builtin.tuple([rhs]);
  var regex = /%(\([a-zA-Z0-9]+\))?([#0 +\-]+)?(\*|[0-9]+)?(\.(\*|[0-9]+))?[hlL]?([diouxXeEfFgGcrs%])/g;
  var index = 0;
  var replFunc = function (substring, mappingKey, conversionFlags, fieldWidth, precision, precbody, conversionType) {
    fieldWidth = Sk.builtin.asnum$(fieldWidth);
    precision = Sk.builtin.asnum$(precision);
    var i;
    if (mappingKey === undefined || mappingKey === '')
      i = index++;
    var zeroPad = false;
    var leftAdjust = false;
    var blankBeforePositive = false;
    var precedeWithSign = false;
    var alternateForm = false;
    if (conversionFlags) {
      if (conversionFlags.indexOf('-') !== -1)
        leftAdjust = true;
      else if (conversionFlags.indexOf('0') !== -1)
        zeroPad = true;
      if (conversionFlags.indexOf('+') !== -1)
        precedeWithSign = true;
      else if (conversionFlags.indexOf(' ') !== -1)
        blankBeforePositive = true;
      alternateForm = conversionFlags.indexOf('#') !== -1;
    }
    if (precision) {
      precision = parseInt(precision.substr(1), 10);
    }
    var formatNumber = function (n, base) {
      base = Sk.builtin.asnum$(base);
      var j;
      var r;
      var neg = false;
      var didSign = false;
      if (typeof n === 'number') {
        if (n < 0) {
          n = -n;
          neg = true;
        }
        r = n.toString(base);
      } else if (n instanceof Sk.builtin.nmber) {
        r = n.str$(base, false);
        if (r.length > 2 && r.substr(-2) === '.0')
          r = r.substr(0, r.length - 2);
        neg = n.nb$isnegative();
      } else if (n instanceof Sk.builtin.lng) {
        r = n.str$(base, false);
        neg = n.nb$isnegative();
      }
      goog.asserts.assert(r !== undefined, 'unhandled number format');
      var precZeroPadded = false;
      if (precision) {
        for (j = r.length; j < precision; ++j) {
          r = '0' + r;
          precZeroPadded = true;
        }
      }
      var prefix = '';
      if (neg)
        prefix = '-';
      else if (precedeWithSign)
        prefix = '+' + prefix;
      else if (blankBeforePositive)
        prefix = ' ' + prefix;
      if (alternateForm) {
        if (base === 16)
          prefix += '0x';
        else if (base === 8 && !precZeroPadded && r !== '0')
          prefix += '0';
      }
      return [
        prefix,
        r
      ];
    };
    var handleWidth = function (args) {
      var prefix = args[0];
      var r = args[1];
      var j;
      if (fieldWidth) {
        fieldWidth = parseInt(fieldWidth, 10);
        var totLen = r.length + prefix.length;
        if (zeroPad)
          for (j = totLen; j < fieldWidth; ++j)
            r = '0' + r;
        else if (leftAdjust)
          for (j = totLen; j < fieldWidth; ++j)
            r = r + ' ';
        else
          for (j = totLen; j < fieldWidth; ++j)
            prefix = ' ' + prefix;
      }
      return prefix + r;
    };
    var value;
    if (rhs.constructor === Sk.builtin.tuple) {
      value = rhs.v[i];
    } else if (rhs.mp$subscript !== undefined) {
      var mk = mappingKey.substring(1, mappingKey.length - 1);
      value = rhs.mp$subscript(new Sk.builtin.str(mk));
    } else
      throw new Sk.builtin.AttributeError(rhs.tp$name + ' instance has no attribute \'mp$subscript\'');
    var r;
    var base = 10;
    switch (conversionType) {
    case 'd':
    case 'i':
      return handleWidth(formatNumber(value, 10));
    case 'o':
      return handleWidth(formatNumber(value, 8));
    case 'x':
      return handleWidth(formatNumber(value, 16));
    case 'X':
      return handleWidth(formatNumber(value, 16)).toUpperCase();
    case 'f':
    case 'F':
    case 'e':
    case 'E':
    case 'g':
    case 'G':
      var convValue = Sk.builtin.asnum$(value);
      if (typeof convValue === 'string')
        convValue = Number(convValue);
      if (convValue === Infinity)
        return 'inf';
      if (convValue === -Infinity)
        return '-inf';
      if (isNaN(convValue))
        return 'nan';
      var convName = [
          'toExponential',
          'toFixed',
          'toPrecision'
        ]['efg'.indexOf(conversionType.toLowerCase())];
      if (precision === undefined || precision === '')
        if (conversionType === 'e' || conversionType === 'E')
          precision = 6;
        else if (conversionType === 'f' || conversionType === 'F')
          precision = 7;
      var result = convValue[convName](precision);
      if ('EFG'.indexOf(conversionType) !== -1)
        result = result.toUpperCase();
      return handleWidth([
        '',
        result
      ]);
    case 'c':
      if (typeof value === 'number')
        return String.fromCharCode(value);
      else if (value instanceof Sk.builtin.nmber)
        return String.fromCharCode(value.v);
      else if (value instanceof Sk.builtin.lng)
        return String.fromCharCode(value.str$(10, false)[0]);
      else if (value.constructor === Sk.builtin.str)
        return value.v.substr(0, 1);
      else
        throw new Sk.builtin.TypeError('an integer is required');
      break;
    case 'r':
      r = Sk.builtin.repr(value);
      if (precision)
        return r.v.substr(0, precision);
      return r.v;
    case 's':
      r = new Sk.builtin.str(value);
      if (precision)
        return r.v.substr(0, precision);
      return r.v;
    case '%':
      return '%';
    }
  };
  var ret = this.v.replace(regex, replFunc);
  return new Sk.builtin.str(ret);
};
Sk.builtin.tuple = function (L) {
  if (!(this instanceof Sk.builtin.tuple))
    return new Sk.builtin.tuple(L);
  if (L === undefined) {
    L = [];
  }
  if (Object.prototype.toString.apply(L) === '[object Array]') {
    this.v = L;
  } else {
    if (L.tp$iter) {
      this.v = [];
      for (var it = L.tp$iter(), i = it.tp$iternext(); i !== undefined; i = it.tp$iternext())
        this.v.push(i);
    } else
      throw new Sk.builtin.ValueError('expecting Array or iterable');
  }
  this.__class__ = Sk.builtin.tuple;
  this['v'] = this.v;
  return this;
};
Sk.builtin.tuple.prototype.tp$name = 'tuple';
Sk.builtin.tuple.prototype['$r'] = function () {
  if (this.v.length === 0)
    return new Sk.builtin.str('()');
  var bits = [];
  for (var i = 0; i < this.v.length; ++i) {
    bits[i] = Sk.misceval.objectRepr(this.v[i]).v;
  }
  var ret = bits.join(', ');
  if (this.v.length === 1)
    ret += ',';
  return new Sk.builtin.str('(' + ret + ')');
};
Sk.builtin.tuple.prototype.mp$subscript = function (index) {
  if (Sk.misceval.isIndex(index)) {
    var i = Sk.misceval.asIndex(index);
    if (i !== undefined) {
      if (i < 0)
        i = this.v.length + i;
      if (i < 0 || i >= this.v.length) {
        throw new Sk.builtin.IndexError('tuple index out of range');
      }
      return this.v[i];
    }
  } else if (index instanceof Sk.builtin.slice) {
    var ret = [];
    index.sssiter$(this, function (i, wrt) {
      ret.push(wrt.v[i]);
    });
    return new Sk.builtin.tuple(ret);
  }
  throw new Sk.builtin.TypeError('tuple indices must be integers, not ' + Sk.abstr.typeName(index));
};
Sk.builtin.tuple.prototype.tp$hash = function () {
  var mult = 1000003;
  var x = 3430008;
  var len = this.v.length;
  for (var i = 0; i < len; ++i) {
    var y = Sk.builtin.hash(this.v[i]);
    if (y === -1)
      return -1;
    x = (x ^ y) * mult;
    mult += 82520 + len + len;
  }
  x += 97531;
  if (x === -1)
    x = -2;
  return x;
};
Sk.builtin.tuple.prototype.sq$repeat = function (n) {
  n = Sk.builtin.asnum$(n);
  var ret = [];
  for (var i = 0; i < n; ++i)
    for (var j = 0; j < this.v.length; ++j)
      ret.push(this.v[j]);
  return new Sk.builtin.tuple(ret);
};
Sk.builtin.tuple.prototype.nb$multiply = Sk.builtin.tuple.prototype.sq$repeat;
Sk.builtin.tuple.prototype.nb$inplace_multiply = Sk.builtin.tuple.prototype.sq$repeat;
Sk.builtin.tuple.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj('tuple', Sk.builtin.tuple);
Sk.builtin.tuple.prototype.tp$iter = function () {
  var ret = {
      tp$iter: function () {
        return ret;
      },
      $obj: this,
      $index: 0,
      tp$iternext: function () {
        if (ret.$index >= ret.$obj.v.length)
          return undefined;
        return ret.$obj.v[ret.$index++];
      }
    };
  return ret;
};
Sk.builtin.tuple.prototype.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;
Sk.builtin.tuple.prototype.tp$richcompare = function (w, op) {
  if (!w.__class__ || w.__class__ != Sk.builtin.tuple) {
    if (op === 'Eq')
      return false;
    if (op === 'NotEq')
      return true;
    return false;
  }
  var v = this.v;
  var w = w.v;
  var vl = v.length;
  var wl = w.length;
  var i;
  for (i = 0; i < vl && i < wl; ++i) {
    var k = Sk.misceval.richCompareBool(v[i], w[i], 'Eq');
    if (!k)
      break;
  }
  if (i >= vl || i >= wl) {
    switch (op) {
    case 'Lt':
      return vl < wl;
    case 'LtE':
      return vl <= wl;
    case 'Eq':
      return vl === wl;
    case 'NotEq':
      return vl !== wl;
    case 'Gt':
      return vl > wl;
    case 'GtE':
      return vl >= wl;
    default:
      goog.asserts.fail();
    }
  }
  if (op === 'Eq')
    return false;
  if (op === 'NotEq')
    return true;
  return Sk.misceval.richCompareBool(v[i], w[i], op);
};
Sk.builtin.tuple.prototype.sq$concat = function (other) {
  return new Sk.builtin.tuple(this.v.concat(other.v));
};
Sk.builtin.tuple.prototype.nb$add = Sk.builtin.tuple.prototype.sq$concat;
Sk.builtin.tuple.prototype.nb$inplace_add = Sk.builtin.tuple.prototype.sq$concat;
Sk.builtin.tuple.prototype.sq$length = function () {
  return this.v.length;
};
Sk.builtin.tuple.prototype['index'] = new Sk.builtin.func(function (self, item) {
  var len = self.v.length;
  var obj = self.v;
  for (var i = 0; i < len; ++i) {
    if (Sk.misceval.richCompareBool(obj[i], item, 'Eq'))
      return i;
  }
  throw new Sk.builtin.ValueError('tuple.index(x): x not in tuple');
});
Sk.builtin.tuple.prototype['count'] = new Sk.builtin.func(function (self, item) {
  var len = self.v.length;
  var obj = self.v;
  var count = 0;
  for (var i = 0; i < len; ++i) {
    if (Sk.misceval.richCompareBool(obj[i], item, 'Eq')) {
      count += 1;
    }
  }
  return count;
});
goog.exportSymbol('Sk.builtin.tuple', Sk.builtin.tuple);
Sk.builtin.dict = function dict(L) {
  if (!(this instanceof Sk.builtin.dict))
    return new Sk.builtin.dict(L);
  if (L === undefined) {
    L = [];
  }
  this.size = 0;
  if (Object.prototype.toString.apply(L) === '[object Array]') {
    for (var i = 0; i < L.length; i += 2) {
      this.mp$ass_subscript(L[i], L[i + 1]);
    }
  } else if (L instanceof Sk.builtin.dict) {
    for (var it = L.tp$iter(), k = it.tp$iternext(); k !== undefined; k = it.tp$iternext()) {
      var v = L.mp$subscript(k);
      if (v === undefined) {
        v = null;
      }
      this.mp$ass_subscript(k, v);
    }
  } else if (L.tp$iter) {
    for (var it = L.tp$iter(), i = it.tp$iternext(); i !== undefined; i = it.tp$iternext()) {
      if (i.mp$subscript) {
        this.mp$ass_subscript(i.mp$subscript(0), i.mp$subscript(1));
      } else {
        throw new Sk.builtin.TypeError('element ' + this.size + ' is not a sequence');
      }
    }
  } else {
    throw new Sk.builtin.TypeError('object is not iterable');
  }
  this.__class__ = Sk.builtin.dict;
  return this;
};
Sk.builtin.dict.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj('dict', Sk.builtin.dict);
var kf = Sk.builtin.hash;
Sk.builtin.dict.prototype.key$lookup = function (bucket, key) {
  var item;
  var eq;
  var i;
  for (i = 0; i < bucket.items.length; i++) {
    item = bucket.items[i];
    eq = Sk.misceval.richCompareBool(item.lhs, key, 'Eq');
    if (eq) {
      return item;
    }
  }
  return null;
};
Sk.builtin.dict.prototype.key$pop = function (bucket, key) {
  var item;
  var eq;
  var i;
  for (i = 0; i < bucket.items.length; i++) {
    item = bucket.items[i];
    eq = Sk.misceval.richCompareBool(item.lhs, key, 'Eq');
    if (eq) {
      bucket.items.splice(i, 1);
      this.size -= 1;
      return item;
    }
  }
  return undefined;
};
Sk.builtin.dict.prototype.mp$lookup = function (key) {
  var bucket = this[kf(key)];
  var item;
  if (bucket !== undefined) {
    item = this.key$lookup(bucket, key);
    if (item) {
      return item.rhs;
    }
    ;
  }
  return undefined;
};
Sk.builtin.dict.prototype.mp$subscript = function (key) {
  var res = this.mp$lookup(key);
  if (res !== undefined) {
    return res;
  } else {
    var s = new Sk.builtin.str(key);
    throw new Sk.builtin.KeyError(s.v);
  }
};
Sk.builtin.dict.prototype.sq$contains = function (ob) {
  var res = this.mp$lookup(ob);
  return res !== undefined;
};
Sk.builtin.dict.prototype.mp$ass_subscript = function (key, w) {
  var k = kf(key);
  var bucket = this[k];
  var item;
  if (bucket === undefined) {
    bucket = {
      $hash: k,
      items: [{
          lhs: key,
          rhs: w
        }]
    };
    this[k] = bucket;
    this.size += 1;
    return;
  }
  item = this.key$lookup(bucket, key);
  if (item) {
    item.rhs = w;
    return;
  }
  ;
  bucket.items.push({
    lhs: key,
    rhs: w
  });
  this.size += 1;
};
Sk.builtin.dict.prototype.mp$del_subscript = function (key) {
  var bucket = this[kf(key)];
  var item;
  var s;
  if (bucket !== undefined) {
    item = this.key$pop(bucket, key);
    if (item !== undefined) {
      return;
    }
    ;
  }
  s = new Sk.builtin.str(key);
  throw new Sk.builtin.KeyError(s.v);
};
Sk.builtin.dict.prototype.tp$iter = function () {
  var allkeys = [];
  for (var k in this) {
    if (this.hasOwnProperty(k)) {
      var bucket = this[k];
      if (bucket && bucket.$hash !== undefined) {
        for (var i = 0; i < bucket.items.length; i++) {
          allkeys.push(bucket.items[i].lhs);
        }
      }
    }
  }
  var ret = {
      tp$iter: function () {
        return ret;
      },
      $obj: this,
      $index: 0,
      $keys: allkeys,
      tp$iternext: function () {
        if (ret.$index >= ret.$keys.length)
          return undefined;
        return ret.$keys[ret.$index++];
      }
    };
  return ret;
};
Sk.builtin.dict.prototype['$r'] = function () {
  var ret = [];
  for (var iter = this.tp$iter(), k = iter.tp$iternext(); k !== undefined; k = iter.tp$iternext()) {
    var v = this.mp$subscript(k);
    if (v === undefined) {
      v = null;
    }
    ret.push(Sk.misceval.objectRepr(k).v + ': ' + Sk.misceval.objectRepr(v).v);
  }
  return new Sk.builtin.str('{' + ret.join(', ') + '}');
};
Sk.builtin.dict.prototype.mp$length = function () {
  return this.size;
};
Sk.builtin.dict.prototype.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;
Sk.builtin.dict.prototype.tp$hash = Sk.builtin.object.prototype.HashNotImplemented;
Sk.builtin.dict.prototype.tp$richcompare = function (other, op) {
  if (this === other && Sk.misceval.opAllowsEquality(op))
    return true;
  switch (op) {
  case 'Lt':
    return undefined;
  case 'LtE':
    return undefined;
  case 'Eq':
    break;
  case 'NotEq':
    break;
  case 'Gt':
    return undefined;
  case 'GtE':
    return undefined;
  default:
    goog.asserts.fail();
  }
  if (!(other instanceof Sk.builtin.dict)) {
    if (op === 'Eq') {
      return false;
    } else {
      return true;
    }
  }
  var thisl = this.size;
  var otherl = other.size;
  if (thisl !== otherl) {
    if (op === 'Eq') {
      return false;
    } else {
      return true;
    }
  }
  for (var iter = this.tp$iter(), k = iter.tp$iternext(); k !== undefined; k = iter.tp$iternext()) {
    var v = this.mp$subscript(k);
    var otherv = other.mp$subscript(k);
    if (!Sk.misceval.richCompareBool(v, otherv, 'Eq')) {
      if (op === 'Eq') {
        return false;
      } else {
        return true;
      }
    }
  }
  if (op === 'Eq') {
    return true;
  } else {
    return false;
  }
};
Sk.builtin.dict.prototype['get'] = new Sk.builtin.func(function (self, k, d) {
  var ret;
  if (d === undefined) {
    d = null;
  }
  ret = self.mp$lookup(k);
  if (ret === undefined) {
    ret = d;
  }
  return ret;
});
Sk.builtin.dict.prototype['has_key'] = new Sk.builtin.func(function (self, k) {
  return self.sq$contains(k);
});
Sk.builtin.dict.prototype['items'] = new Sk.builtin.func(function (self) {
  var ret = [];
  for (var iter = self.tp$iter(), k = iter.tp$iternext(); k !== undefined; k = iter.tp$iternext()) {
    var v = self.mp$subscript(k);
    if (v === undefined) {
      v = null;
    }
    ret.push(new Sk.builtin.tuple([
      k,
      v
    ]));
  }
  return new Sk.builtin.list(ret);
});
Sk.builtin.dict.prototype['keys'] = new Sk.builtin.func(function (self) {
  var ret = [];
  for (var iter = self.tp$iter(), k = iter.tp$iternext(); k !== undefined; k = iter.tp$iternext()) {
    ret.push(k);
  }
  return new Sk.builtin.list(ret);
});
Sk.builtin.dict.prototype['values'] = new Sk.builtin.func(function (self) {
  var ret = [];
  for (var iter = self.tp$iter(), k = iter.tp$iternext(); k !== undefined; k = iter.tp$iternext()) {
    var v = self.mp$subscript(k);
    if (v === undefined) {
      v = null;
    }
    ret.push(v);
  }
  return new Sk.builtin.list(ret);
});
Sk.builtin.dict.prototype.tp$name = 'dict';
goog.exportSymbol('Sk.builtin.dict', Sk.builtin.dict);
Sk.builtin.biginteger = function (a, b, c) {
  if (a != null)
    if ('number' == typeof a)
      this.fromNumber(a, b, c);
    else if (b == null && 'string' != typeof a)
      this.fromString(a, 256);
    else
      this.fromString(a, b);
};
Sk.builtin.biginteger.canary = 244837814094590;
Sk.builtin.biginteger.j_lm = (Sk.builtin.biginteger.canary & 16777215) == 15715070;
Sk.builtin.biginteger.nbi = function () {
  return new Sk.builtin.biginteger(null);
};
Sk.builtin.biginteger.prototype.am1 = function (i, x, w, j, c, n) {
  while (--n >= 0) {
    var v = x * this[i++] + w[j] + c;
    c = Math.floor(v / 67108864);
    w[j++] = v & 67108863;
  }
  return c;
};
Sk.builtin.biginteger.prototype.am2 = function (i, x, w, j, c, n) {
  var xl = x & 32767, xh = x >> 15;
  while (--n >= 0) {
    var l = this[i] & 32767;
    var h = this[i++] >> 15;
    var m = xh * l + h * xl;
    l = xl * l + ((m & 32767) << 15) + w[j] + (c & 1073741823);
    c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);
    w[j++] = l & 1073741823;
  }
  return c;
};
Sk.builtin.biginteger.prototype.am3 = function (i, x, w, j, c, n) {
  var xl = x & 16383, xh = x >> 14;
  while (--n >= 0) {
    var l = this[i] & 16383;
    var h = this[i++] >> 14;
    var m = xh * l + h * xl;
    l = xl * l + ((m & 16383) << 14) + w[j] + c;
    c = (l >> 28) + (m >> 14) + xh * h;
    w[j++] = l & 268435455;
  }
  return c;
};
Sk.builtin.biginteger.prototype.am = Sk.builtin.biginteger.prototype.am3;
Sk.builtin.biginteger.dbits = 28;
Sk.builtin.biginteger.prototype.DB = Sk.builtin.biginteger.dbits;
Sk.builtin.biginteger.prototype.DM = (1 << Sk.builtin.biginteger.dbits) - 1;
Sk.builtin.biginteger.prototype.DV = 1 << Sk.builtin.biginteger.dbits;
Sk.builtin.biginteger.BI_FP = 52;
Sk.builtin.biginteger.prototype.FV = Math.pow(2, Sk.builtin.biginteger.BI_FP);
Sk.builtin.biginteger.prototype.F1 = Sk.builtin.biginteger.BI_FP - Sk.builtin.biginteger.dbits;
Sk.builtin.biginteger.prototype.F2 = 2 * Sk.builtin.biginteger.dbits - Sk.builtin.biginteger.BI_FP;
Sk.builtin.biginteger.BI_RM = '0123456789abcdefghijklmnopqrstuvwxyz';
Sk.builtin.biginteger.BI_RC = new Array();
var rr, vv;
rr = '0'.charCodeAt(0);
for (vv = 0; vv <= 9; ++vv)
  Sk.builtin.biginteger.BI_RC[rr++] = vv;
rr = 'a'.charCodeAt(0);
for (vv = 10; vv < 36; ++vv)
  Sk.builtin.biginteger.BI_RC[rr++] = vv;
rr = 'A'.charCodeAt(0);
for (vv = 10; vv < 36; ++vv)
  Sk.builtin.biginteger.BI_RC[rr++] = vv;
Sk.builtin.biginteger.int2char = function (n) {
  return Sk.builtin.biginteger.BI_RM.charAt(n);
};
Sk.builtin.biginteger.intAt = function (s, i) {
  var c = Sk.builtin.biginteger.BI_RC[s.charCodeAt(i)];
  return c == null ? -1 : c;
};
Sk.builtin.biginteger.prototype.bnpCopyTo = function (r) {
  for (var i = this.t - 1; i >= 0; --i)
    r[i] = this[i];
  r.t = this.t;
  r.s = this.s;
};
Sk.builtin.biginteger.prototype.bnpFromInt = function (x) {
  this.t = 1;
  this.s = x < 0 ? -1 : 0;
  if (x > 0)
    this[0] = x;
  else if (x < -1)
    this[0] = x + this.DV;
  else
    this.t = 0;
};
Sk.builtin.biginteger.nbv = function (i) {
  var r = new Sk.builtin.biginteger(null);
  r.bnpFromInt(i);
  return r;
};
Sk.builtin.biginteger.prototype.bnpFromString = function (s, b) {
  var k;
  if (b == 16)
    k = 4;
  else if (b == 8)
    k = 3;
  else if (b == 256)
    k = 8;
  else if (b == 2)
    k = 1;
  else if (b == 32)
    k = 5;
  else if (b == 4)
    k = 2;
  else {
    this.fromRadix(s, b);
    return;
  }
  this.t = 0;
  this.s = 0;
  var i = s.length, mi = false, sh = 0;
  while (--i >= 0) {
    var x = k == 8 ? s[i] & 255 : Sk.builtin.biginteger.intAt(s, i);
    if (x < 0) {
      if (s.charAt(i) == '-')
        mi = true;
      continue;
    }
    mi = false;
    if (sh == 0)
      this[this.t++] = x;
    else if (sh + k > this.DB) {
      this[this.t - 1] |= (x & (1 << this.DB - sh) - 1) << sh;
      this[this.t++] = x >> this.DB - sh;
    } else
      this[this.t - 1] |= x << sh;
    sh += k;
    if (sh >= this.DB)
      sh -= this.DB;
  }
  if (k == 8 && (s[0] & 128) != 0) {
    this.s = -1;
    if (sh > 0)
      this[this.t - 1] |= (1 << this.DB - sh) - 1 << sh;
  }
  this.clamp();
  if (mi)
    Sk.builtin.biginteger.ZERO.subTo(this, this);
};
Sk.builtin.biginteger.prototype.bnpClamp = function () {
  var c = this.s & this.DM;
  while (this.t > 0 && this[this.t - 1] == c)
    --this.t;
};
Sk.builtin.biginteger.prototype.bnToString = function (b) {
  if (this.s < 0)
    return '-' + this.negate().toString(b);
  var k;
  if (b == 16)
    k = 4;
  else if (b == 8)
    k = 3;
  else if (b == 2)
    k = 1;
  else if (b == 32)
    k = 5;
  else if (b == 4)
    k = 2;
  else
    return this.toRadix(b);
  var km = (1 << k) - 1, d, m = false, r = '', i = this.t;
  var p = this.DB - i * this.DB % k;
  if (i-- > 0) {
    if (p < this.DB && (d = this[i] >> p) > 0) {
      m = true;
      r = Sk.builtin.biginteger.int2char(d);
    }
    while (i >= 0) {
      if (p < k) {
        d = (this[i] & (1 << p) - 1) << k - p;
        d |= this[--i] >> (p += this.DB - k);
      } else {
        d = this[i] >> (p -= k) & km;
        if (p <= 0) {
          p += this.DB;
          --i;
        }
      }
      if (d > 0)
        m = true;
      if (m)
        r += Sk.builtin.biginteger.int2char(d);
    }
  }
  return m ? r : '0';
};
Sk.builtin.biginteger.prototype.bnNegate = function () {
  var r = Sk.builtin.biginteger.nbi();
  Sk.builtin.biginteger.ZERO.subTo(this, r);
  return r;
};
Sk.builtin.biginteger.prototype.bnAbs = function () {
  return this.s < 0 ? this.negate() : this;
};
Sk.builtin.biginteger.prototype.bnCompareTo = function (a) {
  var r = this.s - a.s;
  if (r != 0)
    return r;
  var i = this.t;
  r = i - a.t;
  if (r != 0)
    return this.s < 0 ? -r : r;
  while (--i >= 0)
    if ((r = this[i] - a[i]) != 0)
      return r;
  return 0;
};
Sk.builtin.biginteger.nbits = function (x) {
  var r = 1, t;
  if ((t = x >>> 16) != 0) {
    x = t;
    r += 16;
  }
  if ((t = x >> 8) != 0) {
    x = t;
    r += 8;
  }
  if ((t = x >> 4) != 0) {
    x = t;
    r += 4;
  }
  if ((t = x >> 2) != 0) {
    x = t;
    r += 2;
  }
  if ((t = x >> 1) != 0) {
    x = t;
    r += 1;
  }
  return r;
};
Sk.builtin.biginteger.prototype.bnBitLength = function () {
  if (this.t <= 0)
    return 0;
  return this.DB * (this.t - 1) + Sk.builtin.biginteger.nbits(this[this.t - 1] ^ this.s & this.DM);
};
Sk.builtin.biginteger.prototype.bnpDLShiftTo = function (n, r) {
  var i;
  for (i = this.t - 1; i >= 0; --i)
    r[i + n] = this[i];
  for (i = n - 1; i >= 0; --i)
    r[i] = 0;
  r.t = this.t + n;
  r.s = this.s;
};
Sk.builtin.biginteger.prototype.bnpDRShiftTo = function (n, r) {
  for (var i = n; i < this.t; ++i)
    r[i - n] = this[i];
  r.t = Math.max(this.t - n, 0);
  r.s = this.s;
};
Sk.builtin.biginteger.prototype.bnpLShiftTo = function (n, r) {
  var bs = n % this.DB;
  var cbs = this.DB - bs;
  var bm = (1 << cbs) - 1;
  var ds = Math.floor(n / this.DB), c = this.s << bs & this.DM, i;
  for (i = this.t - 1; i >= 0; --i) {
    r[i + ds + 1] = this[i] >> cbs | c;
    c = (this[i] & bm) << bs;
  }
  for (i = ds - 1; i >= 0; --i)
    r[i] = 0;
  r[ds] = c;
  r.t = this.t + ds + 1;
  r.s = this.s;
  r.clamp();
};
Sk.builtin.biginteger.prototype.bnpRShiftTo = function (n, r) {
  r.s = this.s;
  var ds = Math.floor(n / this.DB);
  if (ds >= this.t) {
    r.t = 0;
    return;
  }
  var bs = n % this.DB;
  var cbs = this.DB - bs;
  var bm = (1 << bs) - 1;
  r[0] = this[ds] >> bs;
  for (var i = ds + 1; i < this.t; ++i) {
    r[i - ds - 1] |= (this[i] & bm) << cbs;
    r[i - ds] = this[i] >> bs;
  }
  if (bs > 0)
    r[this.t - ds - 1] |= (this.s & bm) << cbs;
  r.t = this.t - ds;
  r.clamp();
};
Sk.builtin.biginteger.prototype.bnpSubTo = function (a, r) {
  var i = 0, c = 0, m = Math.min(a.t, this.t);
  while (i < m) {
    c += this[i] - a[i];
    r[i++] = c & this.DM;
    c >>= this.DB;
  }
  if (a.t < this.t) {
    c -= a.s;
    while (i < this.t) {
      c += this[i];
      r[i++] = c & this.DM;
      c >>= this.DB;
    }
    c += this.s;
  } else {
    c += this.s;
    while (i < a.t) {
      c -= a[i];
      r[i++] = c & this.DM;
      c >>= this.DB;
    }
    c -= a.s;
  }
  r.s = c < 0 ? -1 : 0;
  if (c < -1)
    r[i++] = this.DV + c;
  else if (c > 0)
    r[i++] = c;
  r.t = i;
  r.clamp();
};
Sk.builtin.biginteger.prototype.bnpMultiplyTo = function (a, r) {
  var x = this.abs(), y = a.abs();
  var i = x.t;
  r.t = i + y.t;
  while (--i >= 0)
    r[i] = 0;
  for (i = 0; i < y.t; ++i)
    r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);
  r.s = 0;
  r.clamp();
  if (this.s != a.s)
    Sk.builtin.biginteger.ZERO.subTo(r, r);
};
Sk.builtin.biginteger.prototype.bnpSquareTo = function (r) {
  var x = this.abs();
  var i = r.t = 2 * x.t;
  while (--i >= 0)
    r[i] = 0;
  for (i = 0; i < x.t - 1; ++i) {
    var c = x.am(i, x[i], r, 2 * i, 0, 1);
    if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {
      r[i + x.t] -= x.DV;
      r[i + x.t + 1] = 1;
    }
  }
  if (r.t > 0)
    r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);
  r.s = 0;
  r.clamp();
};
Sk.builtin.biginteger.prototype.bnpDivRemTo = function (m, q, r) {
  var pm = m.abs();
  if (pm.t <= 0)
    return;
  var pt = this.abs();
  if (pt.t < pm.t) {
    if (q != null)
      q.fromInt(0);
    if (r != null)
      this.copyTo(r);
    return;
  }
  if (r == null)
    r = Sk.builtin.biginteger.nbi();
  var y = Sk.builtin.biginteger.nbi(), ts = this.s, ms = m.s;
  var nsh = this.DB - Sk.builtin.biginteger.nbits(pm[pm.t - 1]);
  if (nsh > 0) {
    pm.lShiftTo(nsh, y);
    pt.lShiftTo(nsh, r);
  } else {
    pm.copyTo(y);
    pt.copyTo(r);
  }
  var ys = y.t;
  var y0 = y[ys - 1];
  if (y0 == 0)
    return;
  var yt = y0 * (1 << this.F1) + (ys > 1 ? y[ys - 2] >> this.F2 : 0);
  var d1 = this.FV / yt, d2 = (1 << this.F1) / yt, e = 1 << this.F2;
  var i = r.t, j = i - ys, t = q == null ? Sk.builtin.biginteger.nbi() : q;
  y.dlShiftTo(j, t);
  if (r.compareTo(t) >= 0) {
    r[r.t++] = 1;
    r.subTo(t, r);
  }
  Sk.builtin.biginteger.ONE.dlShiftTo(ys, t);
  t.subTo(y, y);
  while (y.t < ys)
    y[y.t++] = 0;
  while (--j >= 0) {
    var qd = r[--i] == y0 ? this.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);
    if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd) {
      y.dlShiftTo(j, t);
      r.subTo(t, r);
      while (r[i] < --qd)
        r.subTo(t, r);
    }
  }
  if (q != null) {
    r.drShiftTo(ys, q);
    if (ts != ms)
      Sk.builtin.biginteger.ZERO.subTo(q, q);
  }
  r.t = ys;
  r.clamp();
  if (nsh > 0)
    r.rShiftTo(nsh, r);
  if (ts < 0)
    Sk.builtin.biginteger.ZERO.subTo(r, r);
};
Sk.builtin.biginteger.prototype.bnMod = function (a) {
  var r = Sk.builtin.biginteger.nbi();
  this.abs().divRemTo(a, null, r);
  if (this.s < 0 && r.compareTo(Sk.builtin.biginteger.ZERO) > 0)
    a.subTo(r, r);
  return r;
};
Sk.builtin.biginteger.Classic = function (m) {
  this.m = m;
};
Sk.builtin.biginteger.prototype.cConvert = function (x) {
  if (x.s < 0 || x.compareTo(this.m) >= 0)
    return x.mod(this.m);
  else
    return x;
};
Sk.builtin.biginteger.prototype.cRevert = function (x) {
  return x;
};
Sk.builtin.biginteger.prototype.cReduce = function (x) {
  x.divRemTo(this.m, null, x);
};
Sk.builtin.biginteger.prototype.cMulTo = function (x, y, r) {
  x.multiplyTo(y, r);
  this.reduce(r);
};
Sk.builtin.biginteger.prototype.cSqrTo = function (x, r) {
  x.squareTo(r);
  this.reduce(r);
};
Sk.builtin.biginteger.Classic.prototype.convert = Sk.builtin.biginteger.prototype.cConvert;
Sk.builtin.biginteger.Classic.prototype.revert = Sk.builtin.biginteger.prototype.cRevert;
Sk.builtin.biginteger.Classic.prototype.reduce = Sk.builtin.biginteger.prototype.cReduce;
Sk.builtin.biginteger.Classic.prototype.mulTo = Sk.builtin.biginteger.prototype.cMulTo;
Sk.builtin.biginteger.Classic.prototype.sqrTo = Sk.builtin.biginteger.prototype.cSqrTo;
Sk.builtin.biginteger.prototype.bnpInvDigit = function () {
  if (this.t < 1)
    return 0;
  var x = this[0];
  if ((x & 1) == 0)
    return 0;
  var y = x & 3;
  y = y * (2 - (x & 15) * y) & 15;
  y = y * (2 - (x & 255) * y) & 255;
  y = y * (2 - ((x & 65535) * y & 65535)) & 65535;
  y = y * (2 - x * y % this.DV) % this.DV;
  return y > 0 ? this.DV - y : -y;
};
Sk.builtin.biginteger.Montgomery = function (m) {
  this.m = m;
  this.mp = m.invDigit();
  this.mpl = this.mp & 32767;
  this.mph = this.mp >> 15;
  this.um = (1 << m.DB - 15) - 1;
  this.mt2 = 2 * m.t;
};
Sk.builtin.biginteger.prototype.montConvert = function (x) {
  var r = Sk.builtin.biginteger.nbi();
  x.abs().dlShiftTo(this.m.t, r);
  r.divRemTo(this.m, null, r);
  if (x.s < 0 && r.compareTo(Sk.builtin.biginteger.ZERO) > 0)
    this.m.subTo(r, r);
  return r;
};
Sk.builtin.biginteger.prototype.montRevert = function (x) {
  var r = Sk.builtin.biginteger.nbi();
  x.copyTo(r);
  this.reduce(r);
  return r;
};
Sk.builtin.biginteger.prototype.montReduce = function (x) {
  while (x.t <= this.mt2)
    x[x.t++] = 0;
  for (var i = 0; i < this.m.t; ++i) {
    var j = x[i] & 32767;
    var u0 = j * this.mpl + ((j * this.mph + (x[i] >> 15) * this.mpl & this.um) << 15) & x.DM;
    j = i + this.m.t;
    x[j] += this.m.am(0, u0, x, i, 0, this.m.t);
    while (x[j] >= x.DV) {
      x[j] -= x.DV;
      x[++j]++;
    }
  }
  x.clamp();
  x.drShiftTo(this.m.t, x);
  if (x.compareTo(this.m) >= 0)
    x.subTo(this.m, x);
};
Sk.builtin.biginteger.prototype.montSqrTo = function (x, r) {
  x.squareTo(r);
  this.reduce(r);
};
Sk.builtin.biginteger.prototype.montMulTo = function (x, y, r) {
  x.multiplyTo(y, r);
  this.reduce(r);
};
Sk.builtin.biginteger.Montgomery.prototype.convert = Sk.builtin.biginteger.prototype.montConvert;
Sk.builtin.biginteger.Montgomery.prototype.revert = Sk.builtin.biginteger.prototype.montRevert;
Sk.builtin.biginteger.Montgomery.prototype.reduce = Sk.builtin.biginteger.prototype.montReduce;
Sk.builtin.biginteger.Montgomery.prototype.mulTo = Sk.builtin.biginteger.prototype.montMulTo;
Sk.builtin.biginteger.Montgomery.prototype.sqrTo = Sk.builtin.biginteger.prototype.montSqrTo;
Sk.builtin.biginteger.prototype.bnpIsEven = function () {
  return (this.t > 0 ? this[0] & 1 : this.s) == 0;
};
Sk.builtin.biginteger.prototype.bnpExp = function (e, z) {
  if (e > 4294967295 || e < 1)
    return Sk.builtin.biginteger.ONE;
  var r = Sk.builtin.biginteger.nbi(), r2 = Sk.builtin.biginteger.nbi(), g = z.convert(this), i = Sk.builtin.biginteger.nbits(e) - 1;
  g.copyTo(r);
  while (--i >= 0) {
    z.sqrTo(r, r2);
    if ((e & 1 << i) > 0)
      z.mulTo(r2, g, r);
    else {
      var t = r;
      r = r2;
      r2 = t;
    }
  }
  return z.revert(r);
};
Sk.builtin.biginteger.prototype.bnModPowInt = function (e, m) {
  var z;
  if (e < 256 || m.isEven())
    z = new Sk.builtin.biginteger.Classic(m);
  else
    z = new Sk.builtin.biginteger.Montgomery(m);
  return this.exp(e, z);
};
Sk.builtin.biginteger.prototype.copyTo = Sk.builtin.biginteger.prototype.bnpCopyTo;
Sk.builtin.biginteger.prototype.fromInt = Sk.builtin.biginteger.prototype.bnpFromInt;
Sk.builtin.biginteger.prototype.fromString = Sk.builtin.biginteger.prototype.bnpFromString;
Sk.builtin.biginteger.prototype.clamp = Sk.builtin.biginteger.prototype.bnpClamp;
Sk.builtin.biginteger.prototype.dlShiftTo = Sk.builtin.biginteger.prototype.bnpDLShiftTo;
Sk.builtin.biginteger.prototype.drShiftTo = Sk.builtin.biginteger.prototype.bnpDRShiftTo;
Sk.builtin.biginteger.prototype.lShiftTo = Sk.builtin.biginteger.prototype.bnpLShiftTo;
Sk.builtin.biginteger.prototype.rShiftTo = Sk.builtin.biginteger.prototype.bnpRShiftTo;
Sk.builtin.biginteger.prototype.subTo = Sk.builtin.biginteger.prototype.bnpSubTo;
Sk.builtin.biginteger.prototype.multiplyTo = Sk.builtin.biginteger.prototype.bnpMultiplyTo;
Sk.builtin.biginteger.prototype.squareTo = Sk.builtin.biginteger.prototype.bnpSquareTo;
Sk.builtin.biginteger.prototype.divRemTo = Sk.builtin.biginteger.prototype.bnpDivRemTo;
Sk.builtin.biginteger.prototype.invDigit = Sk.builtin.biginteger.prototype.bnpInvDigit;
Sk.builtin.biginteger.prototype.isEven = Sk.builtin.biginteger.prototype.bnpIsEven;
Sk.builtin.biginteger.prototype.exp = Sk.builtin.biginteger.prototype.bnpExp;
Sk.builtin.biginteger.prototype.toString = Sk.builtin.biginteger.prototype.bnToString;
Sk.builtin.biginteger.prototype.negate = Sk.builtin.biginteger.prototype.bnNegate;
Sk.builtin.biginteger.prototype.abs = Sk.builtin.biginteger.prototype.bnAbs;
Sk.builtin.biginteger.prototype.compareTo = Sk.builtin.biginteger.prototype.bnCompareTo;
Sk.builtin.biginteger.prototype.bitLength = Sk.builtin.biginteger.prototype.bnBitLength;
Sk.builtin.biginteger.prototype.mod = Sk.builtin.biginteger.prototype.bnMod;
Sk.builtin.biginteger.prototype.modPowInt = Sk.builtin.biginteger.prototype.bnModPowInt;
Sk.builtin.biginteger.ZERO = Sk.builtin.biginteger.nbv(0);
Sk.builtin.biginteger.ONE = Sk.builtin.biginteger.nbv(1);
Sk.builtin.biginteger.prototype.bnClone = function () {
  var r = Sk.builtin.biginteger.nbi();
  this.copyTo(r);
  return r;
};
Sk.builtin.biginteger.prototype.bnIntValue = function () {
  if (this.s < 0) {
    if (this.t == 1)
      return this[0] - this.DV;
    else if (this.t == 0)
      return -1;
  } else if (this.t == 1)
    return this[0];
  else if (this.t == 0)
    return 0;
  return (this[1] & (1 << 32 - this.DB) - 1) << this.DB | this[0];
};
Sk.builtin.biginteger.prototype.bnByteValue = function () {
  return this.t == 0 ? this.s : this[0] << 24 >> 24;
};
Sk.builtin.biginteger.prototype.bnShortValue = function () {
  return this.t == 0 ? this.s : this[0] << 16 >> 16;
};
Sk.builtin.biginteger.prototype.bnpChunkSize = function (r) {
  return Math.floor(Math.LN2 * this.DB / Math.log(r));
};
Sk.builtin.biginteger.prototype.bnSigNum = function () {
  if (this.s < 0)
    return -1;
  else if (this.t <= 0 || this.t == 1 && this[0] <= 0)
    return 0;
  else
    return 1;
};
Sk.builtin.biginteger.prototype.bnpToRadix = function (b) {
  if (b == null)
    b = 10;
  if (this.signum() == 0 || b < 2 || b > 36)
    return '0';
  var cs = this.chunkSize(b);
  var a = Math.pow(b, cs);
  var d = Sk.builtin.biginteger.nbv(a), y = Sk.builtin.biginteger.nbi(), z = Sk.builtin.biginteger.nbi(), r = '';
  this.divRemTo(d, y, z);
  while (y.signum() > 0) {
    r = (a + z.intValue()).toString(b).substr(1) + r;
    y.divRemTo(d, y, z);
  }
  return z.intValue().toString(b) + r;
};
Sk.builtin.biginteger.prototype.bnpFromRadix = function (s, b) {
  this.fromInt(0);
  if (b == null)
    b = 10;
  var cs = this.chunkSize(b);
  var d = Math.pow(b, cs), mi = false, j = 0, w = 0;
  for (var i = 0; i < s.length; ++i) {
    var x = Sk.builtin.biginteger.intAt(s, i);
    if (x < 0) {
      if (s.charAt(i) == '-' && this.signum() == 0)
        mi = true;
      if (s.charAt(i) == '.')
        break;
      continue;
    }
    w = b * w + x;
    if (++j >= cs) {
      this.dMultiply(d);
      this.dAddOffset(w, 0);
      j = 0;
      w = 0;
    }
  }
  if (j > 0) {
    this.dMultiply(Math.pow(b, j));
    this.dAddOffset(w, 0);
  }
  if (mi)
    Sk.builtin.biginteger.ZERO.subTo(this, this);
};
Sk.builtin.biginteger.prototype.bnpFromNumber = function (a, b, c) {
  if ('number' == typeof b) {
    if (a < 2)
      this.fromInt(1);
    else {
      this.fromNumber(a, c);
      if (!this.testBit(a - 1))
        this.bitwiseTo(Sk.builtin.biginteger.ONE.shiftLeft(a - 1), Sk.builtin.biginteger.op_or, this);
      if (this.isEven())
        this.dAddOffset(1, 0);
      while (!this.isProbablePrime(b)) {
        this.dAddOffset(2, 0);
        if (this.bitLength() > a)
          this.subTo(Sk.builtin.biginteger.ONE.shiftLeft(a - 1), this);
      }
    }
  }
  this.fromString(a + '');
};
Sk.builtin.biginteger.prototype.bnToByteArray = function () {
  var i = this.t, r = new Array();
  r[0] = this.s;
  var p = this.DB - i * this.DB % 8, d, k = 0;
  if (i-- > 0) {
    if (p < this.DB && (d = this[i] >> p) != (this.s & this.DM) >> p)
      r[k++] = d | this.s << this.DB - p;
    while (i >= 0) {
      if (p < 8) {
        d = (this[i] & (1 << p) - 1) << 8 - p;
        d |= this[--i] >> (p += this.DB - 8);
      } else {
        d = this[i] >> (p -= 8) & 255;
        if (p <= 0) {
          p += this.DB;
          --i;
        }
      }
      if ((d & 128) != 0)
        d |= -256;
      if (k == 0 && (this.s & 128) != (d & 128))
        ++k;
      if (k > 0 || d != this.s)
        r[k++] = d;
    }
  }
  return r;
};
Sk.builtin.biginteger.prototype.bnEquals = function (a) {
  return this.compareTo(a) == 0;
};
Sk.builtin.biginteger.prototype.bnMin = function (a) {
  return this.compareTo(a) < 0 ? this : a;
};
Sk.builtin.biginteger.prototype.bnMax = function (a) {
  return this.compareTo(a) > 0 ? this : a;
};
Sk.builtin.biginteger.prototype.bnpBitwiseTo = function (a, op, r) {
  var i, f, m = Math.min(a.t, this.t);
  for (i = 0; i < m; ++i)
    r[i] = op(this[i], a[i]);
  if (a.t < this.t) {
    f = a.s & this.DM;
    for (i = m; i < this.t; ++i)
      r[i] = op(this[i], f);
    r.t = this.t;
  } else {
    f = this.s & this.DM;
    for (i = m; i < a.t; ++i)
      r[i] = op(f, a[i]);
    r.t = a.t;
  }
  r.s = op(this.s, a.s);
  r.clamp();
};
Sk.builtin.biginteger.op_and = function (x, y) {
  return x & y;
};
Sk.builtin.biginteger.prototype.bnAnd = function (a) {
  var r = Sk.builtin.biginteger.nbi();
  this.bitwiseTo(a, Sk.builtin.biginteger.op_and, r);
  return r;
};
Sk.builtin.biginteger.op_or = function (x, y) {
  return x | y;
};
Sk.builtin.biginteger.prototype.bnOr = function (a) {
  var r = Sk.builtin.biginteger.nbi();
  this.bitwiseTo(a, Sk.builtin.biginteger.op_or, r);
  return r;
};
Sk.builtin.biginteger.op_xor = function (x, y) {
  return x ^ y;
};
Sk.builtin.biginteger.prototype.bnXor = function (a) {
  var r = Sk.builtin.biginteger.nbi();
  this.bitwiseTo(a, Sk.builtin.biginteger.op_xor, r);
  return r;
};
Sk.builtin.biginteger.op_andnot = function (x, y) {
  return x & ~y;
};
Sk.builtin.biginteger.prototype.bnAndNot = function (a) {
  var r = Sk.builtin.biginteger.nbi();
  this.bitwiseTo(a, Sk.builtin.biginteger.op_andnot, r);
  return r;
};
Sk.builtin.biginteger.prototype.bnNot = function () {
  var r = Sk.builtin.biginteger.nbi();
  for (var i = 0; i < this.t; ++i)
    r[i] = this.DM & ~this[i];
  r.t = this.t;
  r.s = ~this.s;
  return r;
};
Sk.builtin.biginteger.prototype.bnShiftLeft = function (n) {
  var r = Sk.builtin.biginteger.nbi();
  if (n < 0)
    this.rShiftTo(-n, r);
  else
    this.lShiftTo(n, r);
  return r;
};
Sk.builtin.biginteger.prototype.bnShiftRight = function (n) {
  var r = Sk.builtin.biginteger.nbi();
  if (n < 0)
    this.lShiftTo(-n, r);
  else
    this.rShiftTo(n, r);
  return r;
};
Sk.builtin.biginteger.lbit = function (x) {
  if (x == 0)
    return -1;
  var r = 0;
  if ((x & 65535) == 0) {
    x >>= 16;
    r += 16;
  }
  if ((x & 255) == 0) {
    x >>= 8;
    r += 8;
  }
  if ((x & 15) == 0) {
    x >>= 4;
    r += 4;
  }
  if ((x & 3) == 0) {
    x >>= 2;
    r += 2;
  }
  if ((x & 1) == 0)
    ++r;
  return r;
};
Sk.builtin.biginteger.prototype.bnGetLowestSetBit = function () {
  for (var i = 0; i < this.t; ++i)
    if (this[i] != 0)
      return i * this.DB + Sk.builtin.biginteger.lbit(this[i]);
  if (this.s < 0)
    return this.t * this.DB;
  return -1;
};
Sk.builtin.biginteger.cbit = function (x) {
  var r = 0;
  while (x != 0) {
    x &= x - 1;
    ++r;
  }
  return r;
};
Sk.builtin.biginteger.prototype.bnBitCount = function () {
  var r = 0, x = this.s & this.DM;
  for (var i = 0; i < this.t; ++i)
    r += Sk.builtin.biginteger.cbit(this[i] ^ x);
  return r;
};
Sk.builtin.biginteger.prototype.bnTestBit = function (n) {
  var j = Math.floor(n / this.DB);
  if (j >= this.t)
    return this.s != 0;
  return (this[j] & 1 << n % this.DB) != 0;
};
Sk.builtin.biginteger.prototype.bnpChangeBit = function (n, op) {
  var r = Sk.builtin.biginteger.ONE.shiftLeft(n);
  this.bitwiseTo(r, op, r);
  return r;
};
Sk.builtin.biginteger.prototype.bnSetBit = function (n) {
  return this.changeBit(n, Sk.builtin.biginteger.op_or);
};
Sk.builtin.biginteger.prototype.bnClearBit = function (n) {
  return this.changeBit(n, Sk.builtin.biginteger.op_andnot);
};
Sk.builtin.biginteger.prototype.bnFlipBit = function (n) {
  return this.changeBit(n, Sk.builtin.biginteger.op_xor);
};
Sk.builtin.biginteger.prototype.bnpAddTo = function (a, r) {
  var i = 0, c = 0, m = Math.min(a.t, this.t);
  while (i < m) {
    c += this[i] + a[i];
    r[i++] = c & this.DM;
    c >>= this.DB;
  }
  if (a.t < this.t) {
    c += a.s;
    while (i < this.t) {
      c += this[i];
      r[i++] = c & this.DM;
      c >>= this.DB;
    }
    c += this.s;
  } else {
    c += this.s;
    while (i < a.t) {
      c += a[i];
      r[i++] = c & this.DM;
      c >>= this.DB;
    }
    c += a.s;
  }
  r.s = c < 0 ? -1 : 0;
  if (c > 0)
    r[i++] = c;
  else if (c < -1)
    r[i++] = this.DV + c;
  r.t = i;
  r.clamp();
};
Sk.builtin.biginteger.prototype.bnAdd = function (a) {
  var r = Sk.builtin.biginteger.nbi();
  this.addTo(a, r);
  return r;
};
Sk.builtin.biginteger.prototype.bnSubtract = function (a) {
  var r = Sk.builtin.biginteger.nbi();
  this.subTo(a, r);
  return r;
};
Sk.builtin.biginteger.prototype.bnMultiply = function (a) {
  var r = Sk.builtin.biginteger.nbi();
  this.multiplyTo(a, r);
  return r;
};
Sk.builtin.biginteger.prototype.bnDivide = function (a) {
  var r = Sk.builtin.biginteger.nbi();
  this.divRemTo(a, r, null);
  return r;
};
Sk.builtin.biginteger.prototype.bnRemainder = function (a) {
  var r = Sk.builtin.biginteger.nbi();
  this.divRemTo(a, null, r);
  return r;
};
Sk.builtin.biginteger.prototype.bnDivideAndRemainder = function (a) {
  var q = Sk.builtin.biginteger.nbi(), r = Sk.builtin.biginteger.nbi();
  this.divRemTo(a, q, r);
  return new Array(q, r);
};
Sk.builtin.biginteger.prototype.bnpDMultiply = function (n) {
  this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
  ++this.t;
  this.clamp();
};
Sk.builtin.biginteger.prototype.bnpDAddOffset = function (n, w) {
  if (n == 0)
    return;
  while (this.t <= w)
    this[this.t++] = 0;
  this[w] += n;
  while (this[w] >= this.DV) {
    this[w] -= this.DV;
    if (++w >= this.t)
      this[this.t++] = 0;
    ++this[w];
  }
};
Sk.builtin.biginteger.NullExp = function () {
};
Sk.builtin.biginteger.prototype.nNop = function (x) {
  return x;
};
Sk.builtin.biginteger.prototype.nMulTo = function (x, y, r) {
  x.multiplyTo(y, r);
};
Sk.builtin.biginteger.prototype.nSqrTo = function (x, r) {
  x.squareTo(r);
};
Sk.builtin.biginteger.NullExp.prototype.convert = Sk.builtin.biginteger.prototype.nNop;
Sk.builtin.biginteger.NullExp.prototype.revert = Sk.builtin.biginteger.prototype.nNop;
Sk.builtin.biginteger.NullExp.prototype.mulTo = Sk.builtin.biginteger.prototype.nMulTo;
Sk.builtin.biginteger.NullExp.prototype.sqrTo = Sk.builtin.biginteger.prototype.nSqrTo;
Sk.builtin.biginteger.prototype.bnPow = function (e) {
  return this.exp(e, new Sk.builtin.biginteger.NullExp());
};
Sk.builtin.biginteger.prototype.bnpMultiplyLowerTo = function (a, n, r) {
  var i = Math.min(this.t + a.t, n);
  r.s = 0;
  r.t = i;
  while (i > 0)
    r[--i] = 0;
  var j;
  for (j = r.t - this.t; i < j; ++i)
    r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);
  for (j = Math.min(a.t, n); i < j; ++i)
    this.am(0, a[i], r, i, 0, n - i);
  r.clamp();
};
Sk.builtin.biginteger.prototype.bnpMultiplyUpperTo = function (a, n, r) {
  --n;
  var i = r.t = this.t + a.t - n;
  r.s = 0;
  while (--i >= 0)
    r[i] = 0;
  for (i = Math.max(n - this.t, 0); i < a.t; ++i)
    r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n);
  r.clamp();
  r.drShiftTo(1, r);
};
Sk.builtin.biginteger.Barrett = function (m) {
  this.r2 = Sk.builtin.biginteger.nbi();
  this.q3 = Sk.builtin.biginteger.nbi();
  Sk.builtin.biginteger.ONE.dlShiftTo(2 * m.t, this.r2);
  this.mu = this.r2.divide(m);
  this.m = m;
};
Sk.builtin.biginteger.prototype.barrettConvert = function (x) {
  if (x.s < 0 || x.t > 2 * this.m.t)
    return x.mod(this.m);
  else if (x.compareTo(this.m) < 0)
    return x;
  else {
    var r = Sk.builtin.biginteger.nbi();
    x.copyTo(r);
    this.reduce(r);
    return r;
  }
};
Sk.builtin.biginteger.prototype.barrettRevert = function (x) {
  return x;
};
Sk.builtin.biginteger.prototype.barrettReduce = function (x) {
  x.drShiftTo(this.m.t - 1, this.r2);
  if (x.t > this.m.t + 1) {
    x.t = this.m.t + 1;
    x.clamp();
  }
  this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
  this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
  while (x.compareTo(this.r2) < 0)
    x.dAddOffset(1, this.m.t + 1);
  x.subTo(this.r2, x);
  while (x.compareTo(this.m) >= 0)
    x.subTo(this.m, x);
};
Sk.builtin.biginteger.prototype.barrettSqrTo = function (x, r) {
  x.squareTo(r);
  this.reduce(r);
};
Sk.builtin.biginteger.prototype.barrettMulTo = function (x, y, r) {
  x.multiplyTo(y, r);
  this.reduce(r);
};
Sk.builtin.biginteger.Barrett.prototype.convert = Sk.builtin.biginteger.prototype.barrettConvert;
Sk.builtin.biginteger.Barrett.prototype.revert = Sk.builtin.biginteger.prototype.barrettRevert;
Sk.builtin.biginteger.Barrett.prototype.reduce = Sk.builtin.biginteger.prototype.barrettReduce;
Sk.builtin.biginteger.Barrett.prototype.mulTo = Sk.builtin.biginteger.prototype.barrettMulTo;
Sk.builtin.biginteger.Barrett.prototype.sqrTo = Sk.builtin.biginteger.prototype.barrettSqrTo;
Sk.builtin.biginteger.prototype.bnModPow = function (e, m) {
  var i = e.bitLength(), k, r = Sk.builtin.biginteger.nbv(1), z;
  if (i <= 0)
    return r;
  else if (i < 18)
    k = 1;
  else if (i < 48)
    k = 3;
  else if (i < 144)
    k = 4;
  else if (i < 768)
    k = 5;
  else
    k = 6;
  if (i < 8)
    z = new Sk.builtin.biginteger.Classic(m);
  else if (m.isEven())
    z = new Sk.builtin.biginteger.Barrett(m);
  else
    z = new Sk.builtin.biginteger.Montgomery(m);
  var g = new Array(), n = 3, k1 = k - 1, km = (1 << k) - 1;
  g[1] = z.convert(this);
  if (k > 1) {
    var g2 = Sk.builtin.biginteger.nbi();
    z.sqrTo(g[1], g2);
    while (n <= km) {
      g[n] = Sk.builtin.biginteger.nbi();
      z.mulTo(g2, g[n - 2], g[n]);
      n += 2;
    }
  }
  var j = e.t - 1, w, is1 = true, r2 = Sk.builtin.biginteger.nbi(), t;
  i = Sk.builtin.biginteger.nbits(e[j]) - 1;
  while (j >= 0) {
    if (i >= k1)
      w = e[j] >> i - k1 & km;
    else {
      w = (e[j] & (1 << i + 1) - 1) << k1 - i;
      if (j > 0)
        w |= e[j - 1] >> this.DB + i - k1;
    }
    n = k;
    while ((w & 1) == 0) {
      w >>= 1;
      --n;
    }
    if ((i -= n) < 0) {
      i += this.DB;
      --j;
    }
    if (is1) {
      g[w].copyTo(r);
      is1 = false;
    } else {
      while (n > 1) {
        z.sqrTo(r, r2);
        z.sqrTo(r2, r);
        n -= 2;
      }
      if (n > 0)
        z.sqrTo(r, r2);
      else {
        t = r;
        r = r2;
        r2 = t;
      }
      z.mulTo(r2, g[w], r);
    }
    while (j >= 0 && (e[j] & 1 << i) == 0) {
      z.sqrTo(r, r2);
      t = r;
      r = r2;
      r2 = t;
      if (--i < 0) {
        i = this.DB - 1;
        --j;
      }
    }
  }
  return z.revert(r);
};
Sk.builtin.biginteger.prototype.bnGCD = function (a) {
  var x = this.s < 0 ? this.negate() : this.clone();
  var y = a.s < 0 ? a.negate() : a.clone();
  if (x.compareTo(y) < 0) {
    var t = x;
    x = y;
    y = t;
  }
  var i = x.getLowestSetBit(), g = y.getLowestSetBit();
  if (g < 0)
    return x;
  if (i < g)
    g = i;
  if (g > 0) {
    x.rShiftTo(g, x);
    y.rShiftTo(g, y);
  }
  while (x.signum() > 0) {
    if ((i = x.getLowestSetBit()) > 0)
      x.rShiftTo(i, x);
    if ((i = y.getLowestSetBit()) > 0)
      y.rShiftTo(i, y);
    if (x.compareTo(y) >= 0) {
      x.subTo(y, x);
      x.rShiftTo(1, x);
    } else {
      y.subTo(x, y);
      y.rShiftTo(1, y);
    }
  }
  if (g > 0)
    y.lShiftTo(g, y);
  return y;
};
Sk.builtin.biginteger.prototype.bnpModInt = function (n) {
  if (n <= 0)
    return 0;
  var d = this.DV % n, r = this.s < 0 ? n - 1 : 0;
  if (this.t > 0)
    if (d == 0)
      r = this[0] % n;
    else
      for (var i = this.t - 1; i >= 0; --i)
        r = (d * r + this[i]) % n;
  return r;
};
Sk.builtin.biginteger.prototype.bnModInverse = function (m) {
  var ac = m.isEven();
  if (this.isEven() && ac || m.signum() == 0)
    return Sk.builtin.biginteger.ZERO;
  var u = m.clone(), v = this.clone();
  var a = Sk.builtin.biginteger.nbv(1), b = Sk.builtin.biginteger.nbv(0), c = Sk.builtin.biginteger.nbv(0), d = Sk.builtin.biginteger.nbv(1);
  while (u.signum() != 0) {
    while (u.isEven()) {
      u.rShiftTo(1, u);
      if (ac) {
        if (!a.isEven() || !b.isEven()) {
          a.addTo(this, a);
          b.subTo(m, b);
        }
        a.rShiftTo(1, a);
      } else if (!b.isEven())
        b.subTo(m, b);
      b.rShiftTo(1, b);
    }
    while (v.isEven()) {
      v.rShiftTo(1, v);
      if (ac) {
        if (!c.isEven() || !d.isEven()) {
          c.addTo(this, c);
          d.subTo(m, d);
        }
        c.rShiftTo(1, c);
      } else if (!d.isEven())
        d.subTo(m, d);
      d.rShiftTo(1, d);
    }
    if (u.compareTo(v) >= 0) {
      u.subTo(v, u);
      if (ac)
        a.subTo(c, a);
      b.subTo(d, b);
    } else {
      v.subTo(u, v);
      if (ac)
        c.subTo(a, c);
      d.subTo(b, d);
    }
  }
  if (v.compareTo(Sk.builtin.biginteger.ONE) != 0)
    return Sk.builtin.biginteger.ZERO;
  if (d.compareTo(m) >= 0)
    return d.subtract(m);
  if (d.signum() < 0)
    d.addTo(m, d);
  else
    return d;
  if (d.signum() < 0)
    return d.add(m);
  else
    return d;
};
Sk.builtin.biginteger.lowprimes = [
  2,
  3,
  5,
  7,
  11,
  13,
  17,
  19,
  23,
  29,
  31,
  37,
  41,
  43,
  47,
  53,
  59,
  61,
  67,
  71,
  73,
  79,
  83,
  89,
  97,
  101,
  103,
  107,
  109,
  113,
  127,
  131,
  137,
  139,
  149,
  151,
  157,
  163,
  167,
  173,
  179,
  181,
  191,
  193,
  197,
  199,
  211,
  223,
  227,
  229,
  233,
  239,
  241,
  251,
  257,
  263,
  269,
  271,
  277,
  281,
  283,
  293,
  307,
  311,
  313,
  317,
  331,
  337,
  347,
  349,
  353,
  359,
  367,
  373,
  379,
  383,
  389,
  397,
  401,
  409,
  419,
  421,
  431,
  433,
  439,
  443,
  449,
  457,
  461,
  463,
  467,
  479,
  487,
  491,
  499,
  503,
  509
];
Sk.builtin.biginteger.lplim = (1 << 26) / Sk.builtin.biginteger.lowprimes[Sk.builtin.biginteger.lowprimes.length - 1];
Sk.builtin.biginteger.prototype.bnIsProbablePrime = function (t) {
  var i, x = this.abs();
  if (x.t == 1 && x[0] <= Sk.builtin.biginteger.lowprimes[Sk.builtin.biginteger.lowprimes.length - 1]) {
    for (i = 0; i < Sk.builtin.biginteger.lowprimes.length; ++i)
      if (x[0] == Sk.builtin.biginteger.lowprimes[i])
        return true;
    return false;
  }
  if (x.isEven())
    return false;
  i = 1;
  while (i < Sk.builtin.biginteger.lowprimes.length) {
    var m = Sk.builtin.biginteger.lowprimes[i], j = i + 1;
    while (j < Sk.builtin.biginteger.lowprimes.length && m < Sk.builtin.biginteger.lplim)
      m *= Sk.builtin.biginteger.lowprimes[j++];
    m = x.modInt(m);
    while (i < j)
      if (m % Sk.builtin.biginteger.lowprimes[i++] == 0)
        return false;
  }
  return x.millerRabin(t);
};
Sk.builtin.biginteger.prototype.bnpMillerRabin = function (t) {
  var n1 = this.subtract(Sk.builtin.biginteger.ONE);
  var k = n1.getLowestSetBit();
  if (k <= 0)
    return false;
  var r = n1.shiftRight(k);
  t = t + 1 >> 1;
  if (t > Sk.builtin.biginteger.lowprimes.length)
    t = Sk.builtin.biginteger.lowprimes.length;
  var a = Sk.builtin.biginteger.nbi();
  for (var i = 0; i < t; ++i) {
    a.fromInt(Sk.builtin.biginteger.lowprimes[i]);
    var y = a.modPow(r, this);
    if (y.compareTo(Sk.builtin.biginteger.ONE) != 0 && y.compareTo(n1) != 0) {
      var j = 1;
      while (j++ < k && y.compareTo(n1) != 0) {
        y = y.modPowInt(2, this);
        if (y.compareTo(Sk.builtin.biginteger.ONE) == 0)
          return false;
      }
      if (y.compareTo(n1) != 0)
        return false;
    }
  }
  return true;
};
Sk.builtin.biginteger.prototype.isnegative = function () {
  return this.s < 0;
};
Sk.builtin.biginteger.prototype.ispositive = function () {
  return this.s >= 0;
};
Sk.builtin.biginteger.prototype.trueCompare = function (a) {
  if (this.s >= 0 && a.s < 0)
    return 1;
  if (this.s < 0 && a.s >= 0)
    return -1;
  return this.compare(a);
};
Sk.builtin.biginteger.prototype.chunkSize = Sk.builtin.biginteger.prototype.bnpChunkSize;
Sk.builtin.biginteger.prototype.toRadix = Sk.builtin.biginteger.prototype.bnpToRadix;
Sk.builtin.biginteger.prototype.fromRadix = Sk.builtin.biginteger.prototype.bnpFromRadix;
Sk.builtin.biginteger.prototype.fromNumber = Sk.builtin.biginteger.prototype.bnpFromNumber;
Sk.builtin.biginteger.prototype.bitwiseTo = Sk.builtin.biginteger.prototype.bnpBitwiseTo;
Sk.builtin.biginteger.prototype.changeBit = Sk.builtin.biginteger.prototype.bnpChangeBit;
Sk.builtin.biginteger.prototype.addTo = Sk.builtin.biginteger.prototype.bnpAddTo;
Sk.builtin.biginteger.prototype.dMultiply = Sk.builtin.biginteger.prototype.bnpDMultiply;
Sk.builtin.biginteger.prototype.dAddOffset = Sk.builtin.biginteger.prototype.bnpDAddOffset;
Sk.builtin.biginteger.prototype.multiplyLowerTo = Sk.builtin.biginteger.prototype.bnpMultiplyLowerTo;
Sk.builtin.biginteger.prototype.multiplyUpperTo = Sk.builtin.biginteger.prototype.bnpMultiplyUpperTo;
Sk.builtin.biginteger.prototype.modInt = Sk.builtin.biginteger.prototype.bnpModInt;
Sk.builtin.biginteger.prototype.millerRabin = Sk.builtin.biginteger.prototype.bnpMillerRabin;
Sk.builtin.biginteger.prototype.clone = Sk.builtin.biginteger.prototype.bnClone;
Sk.builtin.biginteger.prototype.intValue = Sk.builtin.biginteger.prototype.bnIntValue;
Sk.builtin.biginteger.prototype.byteValue = Sk.builtin.biginteger.prototype.bnByteValue;
Sk.builtin.biginteger.prototype.shortValue = Sk.builtin.biginteger.prototype.bnShortValue;
Sk.builtin.biginteger.prototype.signum = Sk.builtin.biginteger.prototype.bnSigNum;
Sk.builtin.biginteger.prototype.toByteArray = Sk.builtin.biginteger.prototype.bnToByteArray;
Sk.builtin.biginteger.prototype.equals = Sk.builtin.biginteger.prototype.bnEquals;
Sk.builtin.biginteger.prototype.compare = Sk.builtin.biginteger.prototype.compareTo;
Sk.builtin.biginteger.prototype.min = Sk.builtin.biginteger.prototype.bnMin;
Sk.builtin.biginteger.prototype.max = Sk.builtin.biginteger.prototype.bnMax;
Sk.builtin.biginteger.prototype.and = Sk.builtin.biginteger.prototype.bnAnd;
Sk.builtin.biginteger.prototype.or = Sk.builtin.biginteger.prototype.bnOr;
Sk.builtin.biginteger.prototype.xor = Sk.builtin.biginteger.prototype.bnXor;
Sk.builtin.biginteger.prototype.andNot = Sk.builtin.biginteger.prototype.bnAndNot;
Sk.builtin.biginteger.prototype.not = Sk.builtin.biginteger.prototype.bnNot;
Sk.builtin.biginteger.prototype.shiftLeft = Sk.builtin.biginteger.prototype.bnShiftLeft;
Sk.builtin.biginteger.prototype.shiftRight = Sk.builtin.biginteger.prototype.bnShiftRight;
Sk.builtin.biginteger.prototype.getLowestSetBit = Sk.builtin.biginteger.prototype.bnGetLowestSetBit;
Sk.builtin.biginteger.prototype.bitCount = Sk.builtin.biginteger.prototype.bnBitCount;
Sk.builtin.biginteger.prototype.testBit = Sk.builtin.biginteger.prototype.bnTestBit;
Sk.builtin.biginteger.prototype.setBit = Sk.builtin.biginteger.prototype.bnSetBit;
Sk.builtin.biginteger.prototype.clearBit = Sk.builtin.biginteger.prototype.bnClearBit;
Sk.builtin.biginteger.prototype.flipBit = Sk.builtin.biginteger.prototype.bnFlipBit;
Sk.builtin.biginteger.prototype.add = Sk.builtin.biginteger.prototype.bnAdd;
Sk.builtin.biginteger.prototype.subtract = Sk.builtin.biginteger.prototype.bnSubtract;
Sk.builtin.biginteger.prototype.multiply = Sk.builtin.biginteger.prototype.bnMultiply;
Sk.builtin.biginteger.prototype.divide = Sk.builtin.biginteger.prototype.bnDivide;
Sk.builtin.biginteger.prototype.remainder = Sk.builtin.biginteger.prototype.bnRemainder;
Sk.builtin.biginteger.prototype.divideAndRemainder = Sk.builtin.biginteger.prototype.bnDivideAndRemainder;
Sk.builtin.biginteger.prototype.modPow = Sk.builtin.biginteger.prototype.bnModPow;
Sk.builtin.biginteger.prototype.modInverse = Sk.builtin.biginteger.prototype.bnModInverse;
Sk.builtin.biginteger.prototype.pow = Sk.builtin.biginteger.prototype.bnPow;
Sk.builtin.biginteger.prototype.gcd = Sk.builtin.biginteger.prototype.bnGCD;
Sk.builtin.biginteger.prototype.isProbablePrime = Sk.builtin.biginteger.prototype.bnIsProbablePrime;
Sk.builtin.nmber = function (x, skType) {
  if (!(this instanceof Sk.builtin.nmber))
    return new Sk.builtin.nmber(x, skType);
  if (x instanceof Sk.builtin.str)
    x = x.v;
  if (x instanceof Sk.builtin.nmber) {
    this.v = x.v;
    this.skType = x.skType;
  } else if (typeof x === 'number') {
    this.v = x;
    if (skType === undefined) {
      if (x > Sk.builtin.nmber.threshold$ || x < -Sk.builtin.nmber.threshold$ || x % 1 != 0)
        this.skType = Sk.builtin.nmber.float$;
      else
        this.skType = Sk.builtin.nmber.int$;
    } else {
      this.skType = skType;
      if (skType === Sk.builtin.nmber.int$)
        if (x > Sk.builtin.nmber.threshold$ || x < -Sk.builtin.nmber.threshold$)
          return new Sk.builtin.lng(x);
    }
  } else if (typeof x === 'string') {
    var result = Sk.numberFromStr(x);
    if (skType !== undefined)
      result.skType = skType;
    if (skType === Sk.builtin.nmber.int$)
      if (result.v > Sk.builtin.nmber.threshold$ || result.v < -Sk.builtin.nmber.threshold$)
        return new Sk.builtin.lng(x);
    return result;
  } else if (x instanceof Sk.builtin.lng) {
    return Sk.numberFromStr(x.str$(10, true));
  } else if (x instanceof Sk.builtin.biginteger) {
    var result = Sk.numberFromStr(x.toString());
    if (skType !== undefined)
      result.skType = skType;
    if (skType === Sk.builtin.nmber.int$)
      if (result.v > Sk.builtin.nmber.threshold$ || result.v < -Sk.builtin.nmber.threshold$)
        return new Sk.builtin.lng(x);
  } else {
    this.v = 0;
    if (skType === undefined)
      this.skType = Sk.builtin.nmber.int$;
    else
      this.skType = skType;
  }
  return this;
};
Sk.builtin.nmber.prototype.tp$index = function () {
  return this.v;
};
Sk.builtin.nmber.prototype.tp$hash = function () {
  return this.v;
};
Sk.builtin.nmber.prototype.tp$name = 'number';
Sk.builtin.nmber.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj('number', Sk.builtin.nmber);
Sk.builtin.nmber.threshold$ = Math.pow(2, 53);
Sk.builtin.nmber.float$ = 'float';
Sk.builtin.nmber.int$ = 'int';
Sk.builtin.nmber.fromInt$ = function (ival) {
  return new Sk.builtin.nmber(ival, undefined);
};
Sk.numberFromStr = function (s) {
  if (s == 'inf')
    return new Sk.builtin.nmber(Infinity, undefined);
  if (s == '-inf')
    return new Sk.builtin.nmber(-Infinity, undefined);
  var res = new Sk.builtin.nmber(0, undefined);
  if (s.indexOf('.') !== -1 || s.indexOf('e') !== -1 || s.indexOf('E') !== -1) {
    res.v = parseFloat(s);
    res.skType = Sk.builtin.nmber.float$;
    return res;
  }
  var tmp = s;
  var s1;
  if (s.charAt(0) === '-')
    tmp = s.substr(1);
  if (tmp.charAt(0) === '0' && (tmp.charAt(1) === 'x' || tmp.charAt(1) === 'X'))
    s1 = parseInt(s, 16);
  else if (tmp.charAt(0) === '0' && (tmp.charAt(1) === 'b' || tmp.charAt(1) === 'B'))
    s1 = parseInt(s, 2);
  else if (tmp.charAt(0) === '0')
    s1 = parseInt(s, 8);
  else
    s1 = parseInt(s, 10);
  res.v = s1;
  res.skType = Sk.builtin.nmber.int$;
  return res;
};
goog.exportSymbol('Sk.numberFromStr', Sk.numberFromStr);
Sk.builtin.nmber.prototype.clone = function () {
  return new Sk.builtin.nmber(this, undefined);
};
Sk.builtin.nmber.prototype.toFixed = function (x) {
  x = Sk.builtin.asnum$(x);
  return this.v.toFixed(x);
};
Sk.builtin.nmber.prototype.nb$add = function (other) {
  var result;
  if (typeof other === 'number')
    other = new Sk.builtin.nmber(other, undefined);
  if (other instanceof Sk.builtin.nmber) {
    result = new Sk.builtin.nmber(this.v + other.v, undefined);
    if (this.skType === Sk.builtin.nmber.float$ || other.skType === Sk.builtin.nmber.float$)
      result.skType = Sk.builtin.nmber.float$;
    else {
      result.skType = Sk.builtin.nmber.int$;
      if (result.v > Sk.builtin.nmber.threshold$ || result.v < -Sk.builtin.nmber.threshold$) {
        result = new Sk.builtin.lng(this.v).nb$add(other.v);
      }
    }
    return result;
  }
  if (other instanceof Sk.builtin.lng) {
    if (this.skType === Sk.builtin.nmber.float$) {
      result = new Sk.builtin.nmber(this.v + parseFloat(other.str$(10, true)), Sk.builtin.nmber.float$);
    } else {
      var thisAsLong = new Sk.builtin.lng(this.v);
      result = thisAsLong.nb$add(other);
    }
    return result;
  }
  return undefined;
};
Sk.builtin.nmber.prototype.nb$subtract = function (other) {
  var result;
  if (typeof other === 'number') {
    other = new Sk.builtin.nmber(other, undefined);
  }
  if (other instanceof Sk.builtin.nmber) {
    result = new Sk.builtin.nmber(this.v - other.v, undefined);
    if (this.skType === Sk.builtin.nmber.float$ || other.skType === Sk.builtin.nmber.float$)
      result.skType = Sk.builtin.nmber.float$;
    else {
      result.skType = Sk.builtin.nmber.int$;
      if (result.v > Sk.builtin.nmber.threshold$ || result.v < -Sk.builtin.nmber.threshold$) {
        result = new Sk.builtin.lng(this.v).nb$subtract(other.v);
      }
    }
    return result;
  }
  if (other instanceof Sk.builtin.lng) {
    if (this.skType === Sk.builtin.nmber.float$) {
      result = new Sk.builtin.nmber(this.v - parseFloat(other.str$(10, true)), Sk.builtin.nmber.float$);
    } else {
      var thisAsLong = new Sk.builtin.lng(this.v);
      result = thisAsLong.nb$subtract(other);
    }
    return result;
  }
  return undefined;
};
Sk.builtin.nmber.prototype.nb$multiply = function (other) {
  var result;
  if (typeof other === 'number')
    other = new Sk.builtin.nmber(other, undefined);
  if (other instanceof Sk.builtin.nmber) {
    result = new Sk.builtin.nmber(this.v * other.v, undefined);
    if (this.skType === Sk.builtin.nmber.float$ || other.skType === Sk.builtin.nmber.float$)
      result.skType = Sk.builtin.nmber.float$;
    else {
      result.skType = Sk.builtin.nmber.int$;
      if (result.v > Sk.builtin.nmber.threshold$ || result.v < -Sk.builtin.nmber.threshold$) {
        result = new Sk.builtin.lng(this.v).nb$multiply(other.v);
      }
    }
    return result;
  }
  if (other instanceof Sk.builtin.lng) {
    if (this.skType === Sk.builtin.nmber.float$) {
      result = new Sk.builtin.nmber(this.v * parseFloat(other.str$(10, true)), Sk.builtin.nmber.float$);
    } else {
      var thisAsLong = new Sk.builtin.lng(this.v);
      result = thisAsLong.nb$multiply(other);
    }
    return result;
  }
  return undefined;
};
Sk.builtin.nmber.prototype.nb$divide = function (other) {
  var result;
  if (typeof other === 'number')
    other = new Sk.builtin.nmber(other, undefined);
  if (other instanceof Sk.builtin.nmber) {
    if (other.v == 0)
      throw new Sk.builtin.ZeroDivisionError('integer division or modulo by zero');
    if (this.v === Infinity)
      if (other.v === Infinity || other.v === -Infinity)
        return new Sk.builtin.nmber(NaN, Sk.builtin.nmber.float$);
      else if (other.nb$isnegative())
        return new Sk.builtin.nmber(-Infinity, Sk.builtin.nmber.float$);
      else
        return new Sk.builtin.nmber(Infinity, Sk.builtin.nmber.float$);
    if (this.v === -Infinity)
      if (other.v === Infinity || other.v === -Infinity)
        return new Sk.builtin.nmber(NaN, Sk.builtin.nmber.float$);
      else if (other.nb$isnegative())
        return new Sk.builtin.nmber(Infinity, Sk.builtin.nmber.float$);
      else
        return new Sk.builtin.nmber(-Infinity, Sk.builtin.nmber.float$);
    result = new Sk.builtin.nmber(this.v / other.v, undefined);
    if (this.skType === Sk.builtin.nmber.float$ || other.skType === Sk.builtin.nmber.float$ || Sk.python3)
      result.skType = Sk.builtin.nmber.float$;
    else {
      result.v = Math.floor(result.v);
      result.skType = Sk.builtin.nmber.int$;
      if (result.v > Sk.builtin.nmber.threshold$ || result.v < -Sk.builtin.nmber.threshold$) {
        result = new Sk.builtin.lng(this.v).nb$divide(other.v);
      }
    }
    return result;
  }
  if (other instanceof Sk.builtin.lng) {
    if (other.longCompare(Sk.builtin.biginteger.ZERO) == 0)
      throw new Sk.builtin.ZeroDivisionError('integer division or modulo by zero');
    if (this.v === Infinity)
      if (other.nb$isnegative())
        return new Sk.builtin.nmber(-Infinity, Sk.builtin.nmber.float$);
      else
        return new Sk.builtin.nmber(Infinity, Sk.builtin.nmber.float$);
    if (this.v === -Infinity)
      if (other.nb$isnegative())
        return new Sk.builtin.nmber(Infinity, Sk.builtin.nmber.float$);
      else
        return new Sk.builtin.nmber(-Infinity, Sk.builtin.nmber.float$);
    if (this.skType === Sk.builtin.nmber.float$) {
      result = new Sk.builtin.nmber(this.v / parseFloat(other.str$(10, true)), Sk.builtin.nmber.float$);
    } else {
      var thisAsLong = new Sk.builtin.lng(this.v);
      result = thisAsLong.nb$divide(other);
    }
    return result;
  }
  return undefined;
};
Sk.builtin.nmber.prototype.nb$floor_divide = function (other) {
  var result;
  if (typeof other === 'number')
    other = new Sk.builtin.nmber(other, undefined);
  if (this.v === Infinity || this.v === -Infinity)
    return new Sk.builtin.nmber(NaN, Sk.builtin.nmber.float$);
  if (other instanceof Sk.builtin.nmber) {
    if (other.v == 0)
      throw new Sk.builtin.ZeroDivisionError('integer division or modulo by zero');
    if (other.v === Infinity)
      if (this.nb$isnegative())
        return new Sk.builtin.nmber(-1, Sk.builtin.nmber.float$);
      else
        return new Sk.builtin.nmber(0, Sk.builtin.nmber.float$);
    if (other.v === -Infinity)
      if (this.nb$isnegative() || !this.nb$nonzero())
        return new Sk.builtin.nmber(0, Sk.builtin.nmber.float$);
      else
        return new Sk.builtin.nmber(-1, Sk.builtin.nmber.float$);
    result = new Sk.builtin.nmber(Math.floor(this.v / other.v), undefined);
    if (this.skType === Sk.builtin.nmber.float$ || other.skType === Sk.builtin.nmber.float$)
      result.skType = Sk.builtin.nmber.float$;
    else {
      result.v = Math.floor(result.v);
      result.skType = Sk.builtin.nmber.int$;
      if (result.v > Sk.builtin.nmber.threshold$ || result.v < -Sk.builtin.nmber.threshold$) {
        result = new Sk.builtin.lng(this.v).nb$floor_divide(other.v);
      }
    }
    return result;
  }
  if (other instanceof Sk.builtin.lng) {
    if (other.longCompare(Sk.builtin.biginteger.ZERO) == 0)
      throw new Sk.builtin.ZeroDivisionError('integer division or modulo by zero');
    if (this.skType === Sk.builtin.nmber.float$) {
      result = Math.floor(this.v / parseFloat(other.str$(10, true)));
      result = new Sk.builtin.nmber(result, Sk.builtin.nmber.float$);
    } else {
      var thisAsLong = new Sk.builtin.lng(this.v);
      result = thisAsLong.nb$floor_divide(other);
    }
    return result;
  }
  return undefined;
};
Sk.builtin.nmber.prototype.nb$remainder = function (other) {
  var result;
  if (typeof other === 'number')
    other = new Sk.builtin.nmber(other, undefined);
  if (other instanceof Sk.builtin.nmber) {
    if (other.v == 0)
      throw new Sk.builtin.ZeroDivisionError('integer division or modulo by zero');
    if (this.v == 0)
      if (this.skType == Sk.builtin.nmber.float$ || other.skType == Sk.builtin.nmber.float$)
        return new Sk.builtin.nmber(0, Sk.builtin.nmber.float$);
      else
        return new Sk.builtin.nmber(0, Sk.builtin.nmber.int$);
    if (other.v === Infinity)
      if (this.v === Infinity || this.v === -Infinity)
        return new Sk.builtin.nmber(NaN, Sk.builtin.nmber.float$);
      else if (this.nb$ispositive())
        return new Sk.builtin.nmber(this.v, Sk.builtin.nmber.float$);
      else
        return new Sk.builtin.nmber(Infinity, Sk.builtin.nmber.float$);
    var tmp = this.v % other.v;
    if (this.v < 0) {
      if (other.v > 0 && tmp < 0)
        tmp = tmp + other.v;
    } else {
      if (other.v < 0 && tmp != 0)
        tmp = tmp + other.v;
    }
    if (this.skType === Sk.builtin.nmber.float$ || other.skType === Sk.builtin.nmber.float$)
      result = new Sk.builtin.nmber(tmp, Sk.builtin.nmber.float$);
    else {
      result = new Sk.builtin.nmber(tmp, Sk.builtin.nmber.int$);
      if (result.v > Sk.builtin.nmber.threshold$ || result.v < -Sk.builtin.nmber.threshold$) {
        result = new Sk.builtin.lng(this.v).nb$remainder(other.v);
      }
    }
    return result;
  }
  if (other instanceof Sk.builtin.lng) {
    if (other.longCompare(Sk.builtin.biginteger.ZERO) == 0)
      throw new Sk.builtin.ZeroDivisionError('integer division or modulo by zero');
    if (this.v == 0)
      if (this.skType === Sk.builtin.nmber.int$)
        return new Sk.builtin.lng(0);
      else
        return new Sk.builtin.nmber(0, this.skType);
    if (this.skType === Sk.builtin.nmber.float$) {
      var op2 = parseFloat(other.str$(10, true));
      var tmp = this.v % op2;
      if (tmp < 0) {
        if (op2 > 0 && tmp != 0)
          tmp = tmp + op2;
      } else {
        if (op2 < 0 && tmp != 0)
          tmp = tmp + op2;
      }
      result = new Sk.builtin.nmber(tmp, Sk.builtin.nmber.float$);
    } else {
      var thisAsLong = new Sk.builtin.lng(this.v);
      result = thisAsLong.nb$remainder(other);
    }
    return result;
  }
  return undefined;
};
Sk.builtin.nmber.prototype.nb$power = function (other) {
  var result;
  if (typeof other === 'number')
    other = new Sk.builtin.nmber(other, undefined);
  if (other instanceof Sk.builtin.nmber) {
    if (this.v < 0 && other.v % 1 != 0)
      throw new Sk.builtin.NegativePowerError('cannot raise a negative number to a fractional power');
    if (this.v == 0 && other.v < 0) {
      throw new Sk.builtin.NegativePowerError('cannot raise zero to a negative power');
    }
    result = new Sk.builtin.nmber(Math.pow(this.v, other.v), undefined);
    if (this.skType === Sk.builtin.nmber.float$ || other.skType === Sk.builtin.nmber.float$ || other.v < 0)
      result.skType = Sk.builtin.nmber.float$;
    else {
      result.v = Math.floor(result.v);
      result.skType = Sk.builtin.nmber.int$;
      if (result.v > Sk.builtin.nmber.threshold$ || result.v < -Sk.builtin.nmber.threshold$) {
        result = new Sk.builtin.lng(this.v).nb$power(other.v);
      }
    }
    if (Math.abs(result.v) === Infinity && Math.abs(this.v) !== Infinity && Math.abs(other.v) !== Infinity) {
      throw new Sk.builtin.OverflowError('Numerical result out of range');
    }
    return result;
  }
  if (other instanceof Sk.builtin.lng) {
    if (this.v == 0 && other.longCompare(Sk.builtin.biginteger.ZERO) < 0)
      throw new Sk.builtin.NegativePowerError('cannot raise zero to a negative power');
    if (this.skType === Sk.builtin.nmber.float$ || other.nb$isnegative()) {
      result = new Sk.builtin.nmber(Math.pow(this.v, parseFloat(other.str$(10, true))), Sk.builtin.nmber.float$);
    } else {
      var thisAsLong = new Sk.builtin.lng(this.v);
      result = thisAsLong.nb$power(other);
    }
    return result;
  }
  return undefined;
};
Sk.builtin.nmber.prototype.nb$and = function (other) {
  var tmp;
  other = Sk.builtin.asnum$(other);
  tmp = this.v & other;
  if (tmp !== undefined && tmp < 0) {
    tmp = tmp + 4294967296;
  }
  if (tmp !== undefined)
    return new Sk.builtin.nmber(tmp, undefined);
  return undefined;
};
Sk.builtin.nmber.prototype.nb$or = function (other) {
  var tmp;
  other = Sk.builtin.asnum$(other);
  tmp = this.v | other;
  if (tmp !== undefined && tmp < 0) {
    tmp = tmp + 4294967296;
  }
  if (tmp !== undefined)
    return new Sk.builtin.nmber(tmp, undefined);
  return undefined;
};
Sk.builtin.nmber.prototype.nb$xor = function (other) {
  var tmp;
  other = Sk.builtin.asnum$(other);
  tmp = this.v ^ other;
  if (tmp !== undefined && tmp < 0) {
    tmp = tmp + 4294967296;
  }
  if (tmp !== undefined)
    return new Sk.builtin.nmber(tmp, undefined);
  return undefined;
};
Sk.builtin.nmber.prototype.nb$lshift = function (other) {
  var tmp;
  var shift = Sk.builtin.asnum$(other);
  if (shift !== undefined) {
    if (shift < 0)
      throw new Sk.builtin.ValueError('negative shift count');
    tmp = this.v << shift;
    if (tmp <= this.v) {
      return Sk.builtin.lng.fromInt$(this.v).nb$lshift(shift);
    }
  }
  if (tmp !== undefined)
    return new Sk.builtin.nmber(tmp, this.skType);
  return undefined;
};
Sk.builtin.nmber.prototype.nb$rshift = function (other) {
  var tmp;
  var shift = Sk.builtin.asnum$(other);
  if (shift !== undefined) {
    if (shift < 0)
      throw new Sk.builtin.ValueError('negative shift count');
    tmp = this.v >> shift;
    if (this.v > 0 && tmp < 0) {
      tmp = tmp & Math.pow(2, 32 - shift) - 1;
    }
  }
  if (tmp !== undefined)
    return new Sk.builtin.nmber(tmp, this.skType);
  return undefined;
};
Sk.builtin.nmber.prototype.nb$inplace_add = Sk.builtin.nmber.prototype.nb$add;
Sk.builtin.nmber.prototype.nb$inplace_subtract = Sk.builtin.nmber.prototype.nb$subtract;
Sk.builtin.nmber.prototype.nb$inplace_multiply = Sk.builtin.nmber.prototype.nb$multiply;
Sk.builtin.nmber.prototype.nb$inplace_divide = Sk.builtin.nmber.prototype.nb$divide;
Sk.builtin.nmber.prototype.nb$inplace_remainder = Sk.builtin.nmber.prototype.nb$remainder;
Sk.builtin.nmber.prototype.nb$inplace_floor_divide = Sk.builtin.nmber.prototype.nb$floor_divide;
Sk.builtin.nmber.prototype.nb$inplace_power = Sk.builtin.nmber.prototype.nb$power;
Sk.builtin.nmber.prototype.nb$inplace_and = Sk.builtin.nmber.prototype.nb$and;
Sk.builtin.nmber.prototype.nb$inplace_or = Sk.builtin.nmber.prototype.nb$or;
Sk.builtin.nmber.prototype.nb$inplace_xor = Sk.builtin.nmber.prototype.nb$xor;
Sk.builtin.nmber.prototype.nb$inplace_lshift = Sk.builtin.nmber.prototype.nb$lshift;
Sk.builtin.nmber.prototype.nb$inplace_rshift = Sk.builtin.nmber.prototype.nb$rshift;
Sk.builtin.nmber.prototype.nb$negative = function () {
  return new Sk.builtin.nmber(-this.v, undefined);
};
Sk.builtin.nmber.prototype.nb$positive = function () {
  return this.clone();
};
Sk.builtin.nmber.prototype.nb$nonzero = function () {
  return this.v !== 0;
};
Sk.builtin.nmber.prototype.nb$isnegative = function () {
  return this.v < 0;
};
Sk.builtin.nmber.prototype.nb$ispositive = function () {
  return this.v >= 0;
};
Sk.builtin.nmber.prototype.numberCompare = function (other) {
  if (other instanceof Sk.builtin.bool)
    other = Sk.builtin.asnum$(other);
  if (other instanceof Sk.builtin.none)
    other = 0;
  if (typeof other === 'number') {
    return this.v - other;
  }
  if (other instanceof Sk.builtin.nmber) {
    if (this.v == Infinity && other.v == Infinity)
      return 0;
    if (this.v == -Infinity && other.v == -Infinity)
      return 0;
    return this.v - other.v;
  }
  if (other instanceof Sk.builtin.lng) {
    if (this.skType === Sk.builtin.nmber.int$ || this.v % 1 == 0) {
      var thisAsLong = new Sk.builtin.lng(this.v);
      var tmp = thisAsLong.longCompare(other);
      return tmp;
    }
    var diff = this.nb$subtract(other);
    if (diff instanceof Sk.builtin.nmber) {
      return diff.v;
    } else if (diff instanceof Sk.builtin.lng) {
      return diff.longCompare(Sk.builtin.biginteger.ZERO);
    }
  }
  return undefined;
};
Sk.builtin.nmber.prototype.__eq__ = function (me, other) {
  return me.numberCompare(other) == 0;
};
Sk.builtin.nmber.prototype.__ne__ = function (me, other) {
  return me.numberCompare(other) != 0;
};
Sk.builtin.nmber.prototype.__lt__ = function (me, other) {
  return me.numberCompare(other) < 0;
};
Sk.builtin.nmber.prototype.__le__ = function (me, other) {
  return me.numberCompare(other) <= 0;
};
Sk.builtin.nmber.prototype.__gt__ = function (me, other) {
  return me.numberCompare(other) > 0;
};
Sk.builtin.nmber.prototype.__ge__ = function (me, other) {
  return me.numberCompare(other) >= 0;
};
Sk.builtin.nmber.prototype.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;
Sk.builtin.nmber.prototype['$r'] = function () {
  return new Sk.builtin.str(this.str$(10, true));
};
Sk.builtin.nmber.prototype.tp$str = function () {
  return new Sk.builtin.str(this.str$(10, true));
};
Sk.builtin.nmber.prototype.str$ = function (base, sign) {
  if (isNaN(this.v))
    return 'nan';
  if (sign === undefined)
    sign = true;
  if (this.v == Infinity)
    return 'inf';
  if (this.v == -Infinity && sign)
    return '-inf';
  if (this.v == -Infinity && !sign)
    return 'inf';
  var work = sign ? this.v : Math.abs(this.v);
  var tmp;
  if (base === undefined || base === 10) {
    if (this.skType == Sk.builtin.nmber.float$) {
      tmp = work.toPrecision(12);
      var idx = tmp.indexOf('.');
      var pre = work.toString().slice(0, idx);
      var post = work.toString().slice(idx);
      if (pre.match(/^-?0$/) && post.slice(1).match(/^0{4,}/)) {
        if (tmp.length < 12)
          tmp = work.toExponential();
        else
          tmp = work.toExponential(11);
      }
      while (tmp.charAt(tmp.length - 1) == '0' && tmp.indexOf('e') < 0) {
        tmp = tmp.substring(0, tmp.length - 1);
      }
      if (tmp.charAt(tmp.length - 1) == '.') {
        tmp = tmp + '0';
      }
      tmp = tmp.replace(new RegExp('\\.0+e'), 'e', 'i');
      tmp = tmp.replace(/(e[-+])([1-9])$/, '$10$2');
      tmp = tmp.replace(/0+(e.*)/, '$1');
    } else {
      tmp = work.toString();
    }
  } else {
    tmp = work.toString(base);
  }
  if (this.skType !== Sk.builtin.nmber.float$)
    return tmp;
  if (tmp.indexOf('.') < 0 && tmp.indexOf('E') < 0 && tmp.indexOf('e') < 0)
    tmp = tmp + '.0';
  return tmp;
};
goog.exportSymbol('Sk.builtin.nmber', Sk.builtin.nmber);
Sk.builtin.lng = function (x, base) {
  base = Sk.builtin.asnum$(base);
  if (!(this instanceof Sk.builtin.lng))
    return new Sk.builtin.lng(x, base);
  if (x === undefined)
    this.biginteger = new Sk.builtin.biginteger(0);
  else if (x instanceof Sk.builtin.lng)
    this.biginteger = x.biginteger.clone();
  else if (x instanceof Sk.builtin.biginteger)
    this.biginteger = x;
  else if (x instanceof String)
    return Sk.longFromStr(x, base);
  else if (x instanceof Sk.builtin.str)
    return Sk.longFromStr(x.v, base);
  else {
    if (x !== undefined && (!Sk.builtin.checkString(x) && !Sk.builtin.checkNumber(x))) {
      if (x === true)
        x = 1;
      else if (x === false)
        x = 0;
      else
        throw new Sk.builtin.TypeError('long() argument must be a string or a number, not \'' + Sk.abstr.typeName(x) + '\'');
    }
    x = Sk.builtin.asnum$nofloat(x);
    this.biginteger = new Sk.builtin.biginteger(x);
  }
  return this;
};
Sk.builtin.lng.prototype.tp$index = function () {
  return parseInt(this.str$(10, true), 10);
};
Sk.builtin.lng.prototype.tp$hash = function () {
  return this.tp$index();
};
Sk.builtin.lng.prototype.tp$name = 'long';
Sk.builtin.lng.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj('long', Sk.builtin.lng);
Sk.builtin.lng.threshold$ = Math.pow(2, 53);
Sk.builtin.lng.MAX_INT$ = new Sk.builtin.lng(Sk.builtin.lng.threshold$);
Sk.builtin.lng.MIN_INT$ = new Sk.builtin.lng(-Sk.builtin.lng.threshold$);
Sk.builtin.lng.prototype.cantBeInt = function () {
  return this.longCompare(Sk.builtin.lng.MAX_INT$) > 0 || this.longCompare(Sk.builtin.lng.MIN_INT$) < 0;
};
Sk.builtin.lng.fromInt$ = function (ival) {
  return new Sk.builtin.lng(ival);
};
Sk.longFromStr = function (s, base) {
  var parser = function (s, base) {
    if (base == 10)
      return new Sk.builtin.biginteger(s);
    else
      return new Sk.builtin.biginteger(s, base);
  };
  var biginteger = Sk.str2number(s, base, parser, function (x) {
      return x.negate();
    }, 'long');
  return new Sk.builtin.lng(biginteger);
};
goog.exportSymbol('Sk.longFromStr', Sk.longFromStr);
Sk.builtin.lng.prototype.toInt$ = function () {
  return this.biginteger.intValue();
};
Sk.builtin.lng.prototype.clone = function () {
  return new Sk.builtin.lng(this);
};
Sk.builtin.lng.prototype.nb$add = function (other) {
  if (other instanceof Sk.builtin.nmber) {
    if (other.skType === Sk.builtin.nmber.float$) {
      var thisAsFloat = new Sk.builtin.nmber(this.str$(10, true), Sk.builtin.nmber.float$);
      return thisAsFloat.nb$add(other);
    } else {
      other = new Sk.builtin.lng(other.v);
    }
  }
  if (other instanceof Sk.builtin.lng) {
    return new Sk.builtin.lng(this.biginteger.add(other.biginteger));
  }
  if (other instanceof Sk.builtin.biginteger) {
    return new Sk.builtin.lng(this.biginteger.add(other));
  }
  return new Sk.builtin.lng(this.biginteger.add(new Sk.builtin.biginteger(other)));
};
Sk.builtin.lng.prototype.nb$inplace_add = Sk.builtin.lng.prototype.nb$add;
Sk.builtin.lng.prototype.nb$subtract = function (other) {
  if (other instanceof Sk.builtin.nmber) {
    if (other.skType === Sk.builtin.nmber.float$) {
      var thisAsFloat = new Sk.builtin.nmber(this.str$(10, true), Sk.builtin.nmber.float$);
      return thisAsFloat.nb$subtract(other);
    } else {
      other = new Sk.builtin.lng(other.v);
    }
  }
  if (other instanceof Sk.builtin.lng) {
    return new Sk.builtin.lng(this.biginteger.subtract(other.biginteger));
  }
  if (other instanceof Sk.builtin.biginteger) {
    return new Sk.builtin.lng(this.biginteger.subtract(other));
  }
  return new Sk.builtin.lng(this.biginteger.subtract(new Sk.builtin.biginteger(other)));
};
Sk.builtin.lng.prototype.nb$inplace_subtract = Sk.builtin.lng.prototype.nb$subtract;
Sk.builtin.lng.prototype.nb$multiply = function (other) {
  if (other instanceof Sk.builtin.nmber) {
    if (other.skType === Sk.builtin.nmber.float$) {
      var thisAsFloat = new Sk.builtin.nmber(this.str$(10, true), Sk.builtin.nmber.float$);
      return thisAsFloat.nb$multiply(other);
    } else {
      other = new Sk.builtin.lng(other.v);
    }
  }
  if (other instanceof Sk.builtin.lng) {
    return new Sk.builtin.lng(this.biginteger.multiply(other.biginteger));
  }
  if (other instanceof Sk.builtin.biginteger) {
    return new Sk.builtin.lng(this.biginteger.multiply(other));
  }
  return new Sk.builtin.lng(this.biginteger.multiply(new Sk.builtin.biginteger(other)));
};
Sk.builtin.lng.prototype.nb$inplace_multiply = Sk.builtin.lng.prototype.nb$multiply;
Sk.builtin.lng.prototype.nb$divide = function (other) {
  if (other instanceof Sk.builtin.nmber) {
    if (other.skType === Sk.builtin.nmber.float$) {
      var thisAsFloat = new Sk.builtin.nmber(this.str$(10, true), Sk.builtin.nmber.float$);
      return thisAsFloat.nb$divide(other);
    } else {
      other = new Sk.builtin.lng(other.v);
    }
  }
  var result;
  if (!(other instanceof Sk.builtin.lng)) {
    other = new Sk.builtin.lng(other);
  }
  var thisneg = this.nb$isnegative();
  var otherneg = other.nb$isnegative();
  if (thisneg && !otherneg || otherneg && !thisneg) {
    result = this.biginteger.divideAndRemainder(other.biginteger);
    if (result[1].trueCompare(Sk.builtin.biginteger.ZERO) == 0) {
      return new Sk.builtin.lng(result[0]);
    } else {
      result = result[0].subtract(Sk.builtin.biginteger.ONE);
      return new Sk.builtin.lng(result);
    }
  } else {
    return new Sk.builtin.lng(this.biginteger.divide(other.biginteger));
  }
};
Sk.builtin.lng.prototype.nb$inplace_divide = Sk.builtin.lng.prototype.nb$divide;
Sk.builtin.lng.prototype.nb$floor_divide = function (other) {
  if (other instanceof Sk.builtin.nmber) {
    if (other.skType === Sk.builtin.nmber.float$) {
      var thisAsFloat = new Sk.builtin.nmber(this.str$(10, true), Sk.builtin.nmber.float$);
      return thisAsFloat.nb$floor_divide(other);
    }
  }
  return this.nb$divide(other);
};
Sk.builtin.lng.prototype.nb$inplace_floor_divide = Sk.builtin.lng.prototype.nb$floor_divide;
Sk.builtin.lng.prototype.nb$remainder = function (other) {
  if (this.biginteger.trueCompare(Sk.builtin.biginteger.ZERO) === 0)
    if (other instanceof Sk.builtin.nmber && other.skType === Sk.builtin.nmber.float$)
      return new Sk.builtin.nmber(0, Sk.builtin.nmber.float$);
    else
      return new Sk.builtin.lng(0);
  if (other instanceof Sk.builtin.nmber) {
    if (other.skType === Sk.builtin.nmber.float$) {
      var thisAsFloat = new Sk.builtin.nmber(this.str$(10, true), Sk.builtin.nmber.float$);
      return thisAsFloat.nb$remainder(other);
    } else {
      other = new Sk.builtin.lng(other.v);
    }
  }
  if (!(other instanceof Sk.builtin.lng)) {
    other = new Sk.builtin.lng(other);
  }
  var tmp = new Sk.builtin.lng(this.biginteger.remainder(other.biginteger));
  if (this.nb$isnegative()) {
    if (other.nb$ispositive() && tmp.nb$nonzero())
      tmp = tmp.nb$add(other).nb$remainder(other);
  } else {
    if (other.nb$isnegative() && tmp.nb$nonzero())
      tmp = tmp.nb$add(other);
  }
  return tmp;
};
Sk.builtin.lng.prototype.nb$inplace_remainder = Sk.builtin.lng.prototype.nb$remainder;
Sk.builtin.lng.prototype.nb$power = function (n, mod) {
  if (mod !== undefined) {
    n = new Sk.builtin.biginteger(Sk.builtin.asnum$(n));
    mod = new Sk.builtin.biginteger(Sk.builtin.asnum$(mod));
    return new Sk.builtin.lng(this.biginteger.modPowInt(n, mod));
  }
  if (typeof n === 'number') {
    if (n < 0) {
      var thisAsFloat = new Sk.builtin.nmber(this.str$(10, true), Sk.builtin.nmber.float$);
      return thisAsFloat.nb$power(n);
    } else
      return new Sk.builtin.lng(this.biginteger.pow(new Sk.builtin.biginteger(n)));
  }
  if (n instanceof Sk.builtin.nmber) {
    if (n.skType === Sk.builtin.nmber.float$ || n.v < 0) {
      var thisAsFloat = new Sk.builtin.nmber(this.str$(10, true), Sk.builtin.nmber.float$);
      return thisAsFloat.nb$power(n);
    } else {
      n = new Sk.builtin.lng(n.v);
    }
  }
  if (n instanceof Sk.builtin.lng) {
    if (n.nb$isnegative()) {
      var thisAsFloat = new Sk.builtin.nmber(this.str$(10, true), Sk.builtin.nmber.float$);
      return thisAsFloat.nb$power(n);
    } else
      return new Sk.builtin.lng(this.biginteger.pow(n.biginteger));
  }
  if (n instanceof Sk.builtin.biginteger) {
    if (n.isnegative()) {
      var thisAsFloat = new Sk.builtin.nmber(this.str$(10, true), Sk.builtin.nmber.float$);
      return thisAsFloat.nb$power(n);
    }
    return new Sk.builtin.lng(this.biginteger.pow(n));
  }
  return new Sk.builtin.lng(this.biginteger.pow(new Sk.builtin.biginteger(n)));
};
Sk.builtin.lng.prototype.nb$inplace_power = Sk.builtin.lng.prototype.nb$power;
Sk.builtin.lng.prototype.nb$lshift = function (other) {
  if (other instanceof Sk.builtin.lng) {
    if (other.biginteger.signum() < 0) {
      throw new Sk.builtin.ValueError('negative shift count');
    }
    return new Sk.builtin.lng(this.biginteger.shiftLeft(other.biginteger));
  }
  if (other instanceof Sk.builtin.biginteger) {
    if (other.signum() < 0) {
      throw new Sk.builtin.ValueError('negative shift count');
    }
    return new Sk.builtin.lng(this.biginteger.shiftLeft(other));
  }
  if (other < 0) {
    throw new Sk.builtin.ValueError('negative shift count');
  }
  other = Sk.builtin.asnum$(other);
  return new Sk.builtin.lng(this.biginteger.shiftLeft(new Sk.builtin.biginteger(other)));
};
Sk.builtin.lng.prototype.nb$inplace_lshift = Sk.builtin.lng.prototype.nb$lshift;
Sk.builtin.lng.prototype.nb$rshift = function (other) {
  if (other instanceof Sk.builtin.lng) {
    if (other.biginteger.signum() < 0) {
      throw new Sk.builtin.ValueError('negative shift count');
    }
    return new Sk.builtin.lng(this.biginteger.shiftRight(other.biginteger));
  }
  if (other instanceof Sk.builtin.biginteger) {
    if (other.signum() < 0) {
      throw new Sk.builtin.ValueError('negative shift count');
    }
    return new Sk.builtin.lng(this.biginteger.shiftRight(other));
  }
  if (other < 0) {
    throw new Sk.builtin.ValueError('negative shift count');
  }
  other = Sk.builtin.asnum$(other);
  return new Sk.builtin.lng(this.biginteger.shiftRight(new Sk.builtin.biginteger(other)));
};
Sk.builtin.lng.prototype.nb$inplace_rshift = Sk.builtin.lng.prototype.nb$rshift;
Sk.builtin.lng.prototype.nb$and = function (other) {
  if (other instanceof Sk.builtin.lng) {
    return new Sk.builtin.lng(this.biginteger.and(other.biginteger));
  }
  if (other instanceof Sk.builtin.biginteger) {
    return new Sk.builtin.lng(this.biginteger.and(other));
  }
  other = Sk.builtin.asnum$(other);
  return new Sk.builtin.lng(this.biginteger.and(new Sk.builtin.biginteger(other)));
};
Sk.builtin.lng.prototype.nb$inplace_and = Sk.builtin.lng.prototype.nb$and;
Sk.builtin.lng.prototype.nb$or = function (other) {
  if (other instanceof Sk.builtin.lng) {
    return new Sk.builtin.lng(this.biginteger.or(other.biginteger));
  }
  if (other instanceof Sk.builtin.biginteger) {
    return new Sk.builtin.lng(this.biginteger.or(other));
  }
  other = Sk.builtin.asnum$(other);
  return new Sk.builtin.lng(this.biginteger.or(new Sk.builtin.biginteger(other)));
};
Sk.builtin.lng.prototype.nb$inplace_or = Sk.builtin.lng.prototype.nb$or;
Sk.builtin.lng.prototype.nb$xor = function (other) {
  if (other instanceof Sk.builtin.lng) {
    return new Sk.builtin.lng(this.biginteger.xor(other.biginteger));
  }
  if (other instanceof Sk.builtin.biginteger) {
    return new Sk.builtin.lng(this.biginteger.xor(other));
  }
  other = Sk.builtin.asnum$(other);
  return new Sk.builtin.lng(this.biginteger.xor(new Sk.builtin.biginteger(other)));
};
Sk.builtin.lng.prototype.nb$inplace_xor = Sk.builtin.lng.prototype.nb$xor;
Sk.builtin.lng.prototype.nb$negative = function () {
  return new Sk.builtin.lng(this.biginteger.negate());
};
Sk.builtin.lng.prototype.nb$positive = function () {
  return this.clone();
};
Sk.builtin.lng.prototype.nb$nonzero = function () {
  return this.biginteger.trueCompare(Sk.builtin.biginteger.ZERO) !== 0;
};
Sk.builtin.lng.prototype.nb$isnegative = function () {
  return this.biginteger.isnegative();
};
Sk.builtin.lng.prototype.nb$ispositive = function () {
  return !this.biginteger.isnegative();
};
Sk.builtin.lng.prototype.nb$invert = function () {
  throw new Sk.builtin.AssertionError();
};
Sk.builtin.lng.prototype.longCompare = function (other) {
  if (typeof other === 'boolean')
    if (other)
      other = 1;
    else
      other = 0;
  var tmp;
  if (typeof other === 'number') {
    other = new Sk.builtin.lng(other);
  }
  if (other instanceof Sk.builtin.nmber) {
    if (other.skType === Sk.builtin.nmber.int$ || other.v % 1 == 0) {
      var otherAsLong = new Sk.builtin.lng(other.v);
      return this.longCompare(otherAsLong);
    } else {
      var thisAsFloat = new Sk.builtin.nmber(this, Sk.builtin.nmber.float$);
      return thisAsFloat.numberCompare(other);
    }
  } else if (other instanceof Sk.builtin.lng) {
    tmp = this.biginteger.subtract(other.biginteger);
  } else if (other instanceof Sk.builtin.biginteger) {
    tmp = this.biginteger.subtract(other);
  } else {
    tmp = this.biginteger.subtract(new Sk.builtin.biginteger(other));
  }
  return tmp;
};
Sk.builtin.lng.prototype.__eq__ = function (me, other) {
  return me.longCompare(other) == 0;
};
Sk.builtin.lng.prototype.__ne__ = function (me, other) {
  return me.longCompare(other) != 0;
};
Sk.builtin.lng.prototype.__lt__ = function (me, other) {
  return me.longCompare(other) < 0;
};
Sk.builtin.lng.prototype.__le__ = function (me, other) {
  return me.longCompare(other) <= 0;
};
Sk.builtin.lng.prototype.__gt__ = function (me, other) {
  return me.longCompare(other) > 0;
};
Sk.builtin.lng.prototype.__ge__ = function (me, other) {
  return me.longCompare(other) >= 0;
};
Sk.builtin.lng.prototype['$r'] = function () {
  return new Sk.builtin.str(this.str$(10, true) + 'L');
};
Sk.builtin.lng.prototype.tp$str = function () {
  return new Sk.builtin.str(this.str$(10, true));
};
Sk.builtin.lng.prototype.str$ = function (base, sign) {
  if (sign === undefined)
    sign = true;
  var work = sign ? this.biginteger : this.biginteger.abs();
  if (base === undefined || base === 10) {
    return work.toString();
  }
  return work.toString(base);
};
Sk.str2number = function (s, base, parser, negater, fname) {
  var origs = s;
  var neg = false;
  s = s.replace(/^\s+|\s+$/g, '');
  if (s.charAt(0) == '-') {
    neg = true;
    s = s.substring(1);
  }
  if (s.charAt(0) == '+') {
    s = s.substring(1);
  }
  if (base === undefined)
    base = 10;
  if (base < 2 || base > 36) {
    if (base != 0) {
      throw new Sk.builtin.ValueError(fname + '() base must be >= 2 and <= 36');
    }
  }
  if (s.substring(0, 2).toLowerCase() == '0x') {
    if (base != 16 && base != 0) {
      throw new Sk.builtin.ValueError('invalid literal for ' + fname + '() with base ' + base + ': \'' + origs + '\'');
    } else {
      s = s.substring(2);
      base = 16;
    }
  } else if (s.substring(0, 2).toLowerCase() == '0b') {
    if (base != 2 && base != 0) {
      throw new Sk.builtin.ValueError('invalid literal for ' + fname + '() with base ' + base + ': \'' + origs + '\'');
    } else {
      s = s.substring(2);
      base = 2;
    }
  } else if (s.substring(0, 2).toLowerCase() == '0o') {
    if (base != 8 && base != 0) {
      throw new Sk.builtin.ValueError('invalid literal for ' + fname + '() with base ' + base + ': \'' + origs + '\'');
    } else {
      s = s.substring(2);
      base = 8;
    }
  } else if (s.charAt(0) == '0') {
    if (s == '0')
      return 0;
    if (base == 8 || base == 0) {
      base = 8;
    }
  }
  if (base == 0)
    base = 10;
  if (s.length === 0) {
    throw new Sk.builtin.ValueError('invalid literal for ' + fname + '() with base ' + base + ': \'' + origs + '\'');
  }
  var i, ch, val;
  for (i = 0; i < s.length; i++) {
    ch = s.charCodeAt(i);
    val = base;
    if (ch >= 48 && ch <= 57) {
      val = ch - 48;
    } else if (ch >= 65 && ch <= 90) {
      val = ch - 65 + 10;
    } else if (ch >= 97 && ch <= 122) {
      val = ch - 97 + 10;
    }
    if (val >= base) {
      throw new Sk.builtin.ValueError('invalid literal for ' + fname + '() with base ' + base + ': \'' + origs + '\'');
    }
  }
  val = parser(s, base);
  if (neg) {
    val = negater(val);
  }
  return val;
};
Sk.builtin.int_ = function (x, base) {
  if (x !== undefined && (!Sk.builtin.checkString(x) && !Sk.builtin.checkNumber(x))) {
    if (x instanceof Sk.builtin.bool)
      x = Sk.builtin.asnum$(x);
    else
      throw new Sk.builtin.TypeError('int() argument must be a string or a number, not \'' + Sk.abstr.typeName(x) + '\'');
  }
  if (x instanceof Sk.builtin.str) {
    base = Sk.builtin.asnum$(base);
    var val = Sk.str2number(x.v, base, parseInt, function (x) {
        return -x;
      }, 'int');
    if (val > Sk.builtin.lng.threshold$ || val < -Sk.builtin.lng.threshold$) {
      return new Sk.builtin.lng(x, base);
    }
    return new Sk.builtin.nmber(val, Sk.builtin.nmber.int$);
  }
  if (base !== undefined) {
    throw new Sk.builtin.TypeError('int() can\'t convert non-string with explicit base');
  }
  if (x instanceof Sk.builtin.lng) {
    if (x.cantBeInt())
      return new Sk.builtin.lng(x);
    else
      return new Sk.builtin.nmber(x.toInt$(), Sk.builtin.nmber.int$);
  }
  x = Sk.builtin.asnum$(x);
  return new Sk.builtin.nmber(x | 0, Sk.builtin.nmber.int$);
};
Sk.builtin.int_.prototype.tp$name = 'int';
Sk.builtin.int_.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj('int', Sk.builtin.int_);
Sk.builtin.float_ = function (x) {
  if (x === undefined) {
    return new Sk.builtin.nmber(0, Sk.builtin.nmber.float$);
  }
  if (x instanceof Sk.builtin.str) {
    var tmp;
    if (x.v.match(/^-inf$/i)) {
      tmp = -Infinity;
    } else if (x.v.match(/^[+]?inf$/i)) {
      tmp = Infinity;
    } else if (x.v.match(/^[-+]?nan$/i)) {
      tmp = NaN;
    } else if (!isNaN(x.v))
      tmp = parseFloat(x.v);
    else {
      throw new Sk.builtin.ValueError('float: Argument: ' + x.v + ' is not number');
    }
    return new Sk.builtin.nmber(tmp, Sk.builtin.nmber.float$);
  }
  if (typeof x === 'number' || x instanceof Sk.builtin.nmber || x instanceof Sk.builtin.lng) {
    x = Sk.builtin.asnum$(x);
    return new Sk.builtin.nmber(x, Sk.builtin.nmber.float$);
  }
  if (x instanceof Sk.builtin.bool) {
    x = Sk.builtin.asnum$(x);
    return new Sk.builtin.nmber(x, Sk.builtin.nmber.float$);
  }
  throw new Sk.builtin.TypeError('float() argument must be a string or a number');
};
Sk.builtin.float_.prototype.tp$name = 'float';
Sk.builtin.float_.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj('float', Sk.builtin.float_);
Sk.builtin.slice = function slice(start, stop, step) {
  start = Sk.builtin.asnum$(start);
  stop = Sk.builtin.asnum$(stop);
  step = Sk.builtin.asnum$(step);
  if (!(this instanceof Sk.builtin.slice))
    return new Sk.builtin.slice(start, stop, step);
  if (stop === undefined && step === undefined) {
    stop = start;
    start = null;
  }
  if (!start)
    start = null;
  if (stop === undefined)
    stop = null;
  if (step === undefined)
    step = null;
  this.start = start;
  this.stop = stop;
  this.step = step;
  if (this.start !== null && !Sk.builtin.checkInt(this.start) || this.stop !== null && !Sk.builtin.checkInt(this.stop) || this.step !== null && !Sk.builtin.checkInt(this.step)) {
    throw new Sk.builtin.TypeError('slice indices must be integers or None');
  }
  return this;
};
Sk.builtin.slice.prototype.tp$str = function () {
  var a = Sk.builtin.repr(this.start).v;
  var b = Sk.builtin.repr(this.stop).v;
  var c = Sk.builtin.repr(this.step).v;
  return new Sk.builtin.str('slice(' + a + ', ' + b + ', ' + c + ')');
};
Sk.builtin.slice.prototype.indices = function (length) {
  length = Sk.builtin.asnum$(length);
  var start = this.start, stop = this.stop, step = this.step, i;
  if (step === null)
    step = 1;
  if (step > 0) {
    if (start === null)
      start = 0;
    if (stop === null)
      stop = length;
    if (stop > length) {
      stop = length;
    }
    if (start < 0) {
      start = length + start;
      if (start < 0) {
        start = 0;
      }
    }
    if (stop < 0)
      stop = length + stop;
  } else {
    if (start === null)
      start = length - 1;
    if (start >= length) {
      start = length - 1;
    }
    if (stop === null) {
      stop = -1;
    } else if (stop < 0) {
      stop = length + stop;
      if (stop < 0) {
        stop = -1;
      }
    }
    if (start < 0)
      start = length + start;
  }
  return [
    start,
    stop,
    step
  ];
};
Sk.builtin.slice.prototype.sssiter$ = function (wrt, f) {
  var wrtv = Sk.builtin.asnum$(wrt);
  var sss = this.indices(typeof wrtv === 'number' ? wrtv : wrt.v.length);
  if (sss[2] > 0) {
    var i;
    for (i = sss[0]; i < sss[1]; i += sss[2])
      if (f(i, wrtv) === false)
        return;
  } else {
    for (i = sss[0]; i > sss[1]; i += sss[2])
      if (f(i, wrtv) === false)
        return;
  }
};
Sk.builtin.set = function (S) {
  if (!(this instanceof Sk.builtin.set))
    return new Sk.builtin.set(S);
  if (typeof S === 'undefined') {
    S = [];
  }
  this.set_reset_();
  var S_list = new Sk.builtin.list(S);
  for (var it = S_list.tp$iter(), i = it.tp$iternext(); i !== undefined; i = it.tp$iternext()) {
    Sk.builtin.set.prototype['add'].func_code(this, i);
  }
  this.__class__ = Sk.builtin.set;
  this['v'] = this.v;
  return this;
};
Sk.builtin.set.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj('set', Sk.builtin.set);
Sk.builtin.set.prototype.set_iter_ = function () {
  var ret = Sk.builtin.dict.prototype['keys'].func_code(this['v']);
  return ret.tp$iter();
};
Sk.builtin.set.prototype.set_reset_ = function () {
  this.v = new Sk.builtin.dict([]);
};
Sk.builtin.set.prototype.tp$name = 'set';
Sk.builtin.set.prototype['$r'] = function () {
  var ret = [];
  for (var it = this.tp$iter(), i = it.tp$iternext(); i !== undefined; i = it.tp$iternext()) {
    ret.push(Sk.misceval.objectRepr(i).v);
  }
  return new Sk.builtin.str('set([' + ret.join(', ') + '])');
};
Sk.builtin.set.prototype.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;
Sk.builtin.set.prototype.tp$hash = Sk.builtin.object.prototype.HashNotImplemented;
Sk.builtin.set.prototype.tp$richcompare = function (w, op) {
  if (this === w && Sk.misceval.opAllowsEquality(op))
    return true;
  if (!w.__class__ || w.__class__ != Sk.builtin.set) {
    if (op === 'Eq')
      return false;
    if (op === 'NotEq')
      return true;
    return false;
  }
  var vl = this.sq$length();
  var wl = w.sq$length();
  if (wl !== vl) {
    if (op === 'Eq')
      return false;
    if (op === 'NotEq')
      return true;
  }
  var isSub = false;
  var isSuper = false;
  switch (op) {
  case 'Lt':
  case 'LtE':
  case 'Eq':
  case 'NotEq':
    isSub = Sk.builtin.set.prototype['issubset'].func_code(this, w);
    break;
  case 'Gt':
  case 'GtE':
    isSuper = Sk.builtin.set.prototype['issuperset'].func_code(this, w);
    break;
  default:
    goog.asserts.fail();
  }
  switch (op) {
  case 'Lt':
    return vl < wl && isSub;
  case 'LtE':
  case 'Eq':
    return isSub;
  case 'NotEq':
    return !isSub;
  case 'Gt':
    return vl > wl && isSuper;
  case 'GtE':
    return isSuper;
  }
};
Sk.builtin.set.prototype.tp$iter = Sk.builtin.set.prototype.set_iter_;
Sk.builtin.set.prototype.sq$length = function () {
  return this['v'].mp$length();
};
Sk.builtin.set.prototype['isdisjoint'] = new Sk.builtin.func(function (self, other) {
  for (var it = self.tp$iter(), item = it.tp$iternext(); item !== undefined; item = it.tp$iternext()) {
    var isIn = Sk.abstr.sequenceContains(other, item);
    if (isIn) {
      return Sk.builtin.bool.false$;
    }
  }
  return Sk.builtin.bool(true);
});
Sk.builtin.set.prototype['issubset'] = new Sk.builtin.func(function (self, other) {
  var selfLength = self.sq$length();
  var otherLength = other.sq$length();
  if (selfLength > otherLength) {
    return Sk.builtin.bool.false$;
  }
  for (var it = self.tp$iter(), item = it.tp$iternext(); item !== undefined; item = it.tp$iternext()) {
    var isIn = Sk.abstr.sequenceContains(other, item);
    if (!isIn) {
      return Sk.builtin.bool.false$;
    }
  }
  return Sk.builtin.bool.true$;
});
Sk.builtin.set.prototype['issuperset'] = new Sk.builtin.func(function (self, other) {
  return Sk.builtin.set.prototype['issubset'].func_code(other, self);
});
Sk.builtin.set.prototype['union'] = new Sk.builtin.func(function (self) {
  var S = new Sk.builtin.set(self);
  for (var i = 1; i < arguments.length; i++) {
    Sk.builtin.set.prototype['update'].func_code(S, arguments[i]);
  }
  return S;
});
Sk.builtin.set.prototype['intersection'] = new Sk.builtin.func(function (self) {
  var S = Sk.builtin.set.prototype['copy'].func_code(self);
  arguments[0] = S;
  Sk.builtin.set.prototype['intersection_update'].func_code.apply(null, arguments);
  return S;
});
Sk.builtin.set.prototype['difference'] = new Sk.builtin.func(function (self, other) {
  var S = Sk.builtin.set.prototype['copy'].func_code(self);
  arguments[0] = S;
  Sk.builtin.set.prototype['difference_update'].func_code.apply(null, arguments);
  return S;
});
Sk.builtin.set.prototype['symmetric_difference'] = new Sk.builtin.func(function (self, other) {
  var S = Sk.builtin.set.prototype['union'].func_code(self, other);
  for (var it = S.tp$iter(), item = it.tp$iternext(); item !== undefined; item = it.tp$iternext()) {
    if (Sk.abstr.sequenceContains(self, item) && Sk.abstr.sequenceContains(other, item)) {
      Sk.builtin.set.prototype['discard'].func_code(S, item);
    }
  }
  return S;
});
Sk.builtin.set.prototype['copy'] = new Sk.builtin.func(function (self) {
  return new Sk.builtin.set(self);
});
Sk.builtin.set.prototype['update'] = new Sk.builtin.func(function (self, other) {
  for (var it = other.tp$iter(), item = it.tp$iternext(); item !== undefined; item = it.tp$iternext()) {
    Sk.builtin.set.prototype['add'].func_code(self, item);
  }
  return null;
});
Sk.builtin.set.prototype['intersection_update'] = new Sk.builtin.func(function (self) {
  for (var it = self.tp$iter(), item = it.tp$iternext(); item !== undefined; item = it.tp$iternext()) {
    for (var i = 1; i < arguments.length; i++) {
      if (!Sk.abstr.sequenceContains(arguments[i], item)) {
        Sk.builtin.set.prototype['discard'].func_code(self, item);
        break;
      }
    }
  }
  return null;
});
Sk.builtin.set.prototype['difference_update'] = new Sk.builtin.func(function (self, other) {
  for (var it = self.tp$iter(), item = it.tp$iternext(); item !== undefined; item = it.tp$iternext()) {
    for (var i = 1; i < arguments.length; i++) {
      if (Sk.abstr.sequenceContains(arguments[i], item)) {
        Sk.builtin.set.prototype['discard'].func_code(self, item);
        break;
      }
    }
  }
  return null;
});
Sk.builtin.set.prototype['symmetric_difference_update'] = new Sk.builtin.func(function (self, other) {
  var sd = Sk.builtin.set.prototype['symmetric_difference'].func_code(self, other);
  self.set_reset_();
  Sk.builtin.set.prototype['update'].func_code(self, sd);
  return null;
});
Sk.builtin.set.prototype['add'] = new Sk.builtin.func(function (self, item) {
  self.v.mp$ass_subscript(item, true);
  return null;
});
Sk.builtin.set.prototype['discard'] = new Sk.builtin.func(function (self, item) {
  if (self.v.mp$lookup(item) !== undefined) {
    var kf = Sk.builtin.hash;
    var k = kf(item);
    if (self.v[k] !== undefined) {
      self.v.size -= 1;
      delete self.v[k];
    }
  }
  return null;
});
Sk.builtin.set.prototype['pop'] = new Sk.builtin.func(function (self) {
  if (self.sq$length() === 0) {
    throw new Sk.builtin.KeyError('pop from an empty set');
  }
  var it = self.tp$iter(), item = it.tp$iternext();
  Sk.builtin.set.prototype['discard'].func_code(self, item);
  return item;
});
Sk.builtin.set.prototype['remove'] = new Sk.builtin.func(function (self, item) {
  self.v.mp$del_subscript(item);
  return null;
});
goog.exportSymbol('Sk.builtin.set', Sk.builtin.set);
Sk.builtin.module = function () {
};
goog.exportSymbol('Sk.builtin.module', Sk.builtin.module);
Sk.builtin.module.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj('module', Sk.builtin.module);
Sk.builtin.module.prototype.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;
Sk.builtin.module.prototype.tp$setattr = Sk.builtin.object.prototype.GenericSetAttr;
Sk.builtin.generator = function (code, globals, args, closure, closure2) {
  if (!code)
    return;
  this.func_code = code;
  this.func_globals = globals || null;
  this.gi$running = false;
  this['gi$resumeat'] = 0;
  this['gi$sentvalue'] = undefined;
  this['gi$locals'] = {};
  if (args.length > 0) {
    for (var i = 0; i < code['co_varnames'].length; ++i)
      this['gi$locals'][code['co_varnames'][i]] = args[i];
  }
  if (closure2 !== undefined) {
    for (var k in closure2)
      closure[k] = closure2[k];
  }
  this.func_closure = closure;
  return this;
};
goog.exportSymbol('Sk.builtin.generator', Sk.builtin.generator);
Sk.builtin.generator.prototype.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;
Sk.builtin.generator.prototype.tp$iter = function () {
  return this;
};
Sk.builtin.generator.prototype.tp$iternext = function (yielded) {
  this.gi$running = true;
  if (yielded === undefined)
    yielded = null;
  this['gi$sentvalue'] = yielded;
  var args = [this];
  if (this.func_closure)
    args.push(this.func_closure);
  var ret = this.func_code.apply(this.func_globals, args);
  this.gi$running = false;
  goog.asserts.assert(ret !== undefined);
  if (ret !== null) {
    this['gi$resumeat'] = ret[0];
    ret = ret[1];
  } else {
    return undefined;
  }
  return ret;
};
Sk.builtin.generator.prototype['next'] = new Sk.builtin.func(function (self) {
  return self.tp$iternext();
});
Sk.builtin.generator.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj('generator', Sk.builtin.generator);
Sk.builtin.generator.prototype['$r'] = function () {
  return new Sk.builtin.str('<generator object ' + this.func_code['co_name'].v + '>');
};
Sk.builtin.generator.prototype['send'] = new Sk.builtin.func(function (self, value) {
  return self.tp$iternext(value);
});
Sk.builtin.makeGenerator = function (next, data) {
  var gen = new Sk.builtin.generator(null, null, null);
  gen.tp$iternext = next;
  for (var key in data) {
    if (data.hasOwnProperty(key)) {
      gen[key] = data[key];
    }
  }
  return gen;
};
goog.exportSymbol('Sk.builtin.makeGenerator', Sk.builtin.makeGenerator);
Sk.builtin.file = function (name, mode, buffering) {
  this.mode = mode;
  this.name = name;
  this.closed = false;
  if (Sk.inBrowser) {
    var elem = document.getElementById(name.v);
    if (elem == null) {
      throw new Sk.builtin.IOError('[Errno 2] No such file or directory: \'' + name.v + '\'');
    } else {
      if (elem.nodeName.toLowerCase() == 'textarea') {
        this.data$ = elem.value;
      } else {
        this.data$ = elem.textContent;
      }
    }
  } else {
    this.data$ = Sk.read(name.v);
  }
  this.lineList = this.data$.split('\n');
  this.lineList = this.lineList.slice(0, -1);
  for (var i in this.lineList) {
    this.lineList[i] = this.lineList[i] + '\n';
  }
  this.currentLine = 0;
  this.pos$ = 0;
  this.__class__ = Sk.builtin.file;
  return this;
};
Sk.builtin.file.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj('file', Sk.builtin.file);
Sk.builtin.file.prototype.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;
Sk.builtin.file.prototype['$r'] = function () {
  return new Sk.builtin.str('<' + (this.closed ? 'closed' : 'open') + 'file \'' + this.name + '\', mode \'' + this.mode + '\'>');
};
Sk.builtin.file.prototype.tp$iter = function () {
  var allLines = this.lineList;
  var ret = {
      tp$iter: function () {
        return ret;
      },
      $obj: this,
      $index: 0,
      $lines: allLines,
      tp$iternext: function () {
        if (ret.$index >= ret.$lines.length)
          return undefined;
        return new Sk.builtin.str(ret.$lines[ret.$index++]);
      }
    };
  return ret;
};
Sk.builtin.file.prototype['close'] = new Sk.builtin.func(function (self) {
  self.closed = true;
});
Sk.builtin.file.prototype['flush'] = new Sk.builtin.func(function (self) {
});
Sk.builtin.file.prototype['fileno'] = new Sk.builtin.func(function (self) {
  return 10;
});
Sk.builtin.file.prototype['isatty'] = new Sk.builtin.func(function (self) {
  return false;
});
Sk.builtin.file.prototype['read'] = new Sk.builtin.func(function (self, size) {
  if (self.closed)
    throw new Sk.builtin.ValueError('I/O operation on closed file');
  var len = self.data$.length;
  if (size === undefined)
    size = len;
  var ret = new Sk.builtin.str(self.data$.substr(self.pos$, size));
  self.pos$ += size;
  if (self.pos$ >= len)
    self.pos$ = len;
  return ret;
});
Sk.builtin.file.prototype['readline'] = new Sk.builtin.func(function (self, size) {
  var line = '';
  if (self.currentLine < self.lineList.length) {
    line = self.lineList[self.currentLine];
    self.currentLine++;
  }
  return new Sk.builtin.str(line);
});
Sk.builtin.file.prototype['readlines'] = new Sk.builtin.func(function (self, sizehint) {
  var arr = [];
  for (var i = self.currentLine; i < self.lineList.length; i++) {
    arr.push(new Sk.builtin.str(self.lineList[i]));
  }
  return new Sk.builtin.list(arr);
});
Sk.builtin.file.prototype['seek'] = new Sk.builtin.func(function (self, offset, whence) {
  if (whence === undefined)
    whence = 1;
  if (whence == 1) {
    self.pos$ = offset;
  } else {
    self.pos$ = self.data$ + offset;
  }
});
Sk.builtin.file.prototype['tell'] = new Sk.builtin.func(function (self) {
  return self.pos$;
});
Sk.builtin.file.prototype['truncate'] = new Sk.builtin.func(function (self, size) {
  goog.asserts.fail();
});
Sk.builtin.file.prototype['write'] = new Sk.builtin.func(function (self, str) {
  goog.asserts.fail();
});
goog.exportSymbol('Sk.builtin.file', Sk.builtin.file);
Sk.ffi = Sk.ffi || {};
Sk.ffi.booleanToPy = function (valueJs) {
  var t = typeof valueJs;
  if (t === 'boolean') {
    return valueJs ? Sk.builtin.bool.true$ : Sk.builtin.bool.false$;
  } else if (t === 'object' && valueJs === null) {
    return Sk.builtin.none.none$;
  } else {
    goog.asserts.fail('f5008183-bfce-4842-9496-30b936ff73f3');
  }
};
goog.exportSymbol('Sk.ffi.booleanToPy', Sk.ffi.booleanToPy);
Sk.ffi.numberToPy = function (valueJs) {
  var t = typeof valueJs;
  if (t === 'number') {
    return new Sk.builtin.nmber(valueJs, Sk.builtin.nmber.float$);
  } else if (t === 'object' && valueJs === null) {
    return Sk.builtin.none.none$;
  } else {
    goog.asserts.fail('3c68a6b8-0314-49ab-99ac-a818324417d8');
  }
};
goog.exportSymbol('Sk.ffi.numberToPy', Sk.ffi.numberToPy);
Sk.ffi.remapNumberToIntPy = function (valueJs) {
  var t = typeof valueJs;
  if (t === 'number') {
    return new Sk.builtin.nmber(valueJs, Sk.builtin.nmber.int$);
  } else if (t === 'object' && valueJs === null) {
    return Sk.builtin.none.none$;
  } else {
    goog.asserts.fail('b451b411-151c-4430-82f2-d548e5514303');
  }
};
goog.exportSymbol('Sk.ffi.remapNumberToIntPy', Sk.ffi.remapNumberToIntPy);
Sk.ffi.stringToPy = function (valueJs) {
  var t = typeof valueJs;
  if (t === 'string') {
    return new Sk.builtin.str(valueJs);
  } else if (t === 'object' && valueJs === null) {
    return Sk.builtin.none.none$;
  } else {
    goog.asserts.fail('50730498-9d4c-4a28-ab50-fd6127dd6d8c');
  }
};
goog.exportSymbol('Sk.ffi.stringToPy', Sk.ffi.stringToPy);
Sk.ffi.referenceToPy = function (valueJs, tp$name) {
  var t = typeof valueJs;
  if (t === 'object') {
    if (typeof tp$name === 'string') {
      return {
        'v': valueJs,
        'tp$name': tp$name
      };
    } else {
      goog.asserts.fail('9fad4b9e-4845-4a06-9bce-0aa7c68e1f03');
    }
  } else {
    goog.asserts.fail('306f31df-f0a9-40a0-895b-d01308df8d6e');
  }
};
goog.exportSymbol('Sk.ffi.referenceToPy', Sk.ffi.referenceToPy);
Sk.ffi.remapToPy = function (valueJs, className) {
  var t = typeof valueJs;
  if (t === 'object') {
    if (Object.prototype.toString.call(valueJs) === '[object Array]') {
      var arr = [];
      for (var i = 0; i < valueJs.length; ++i) {
        arr.push(Sk.ffi.remapToPy(valueJs[i]));
      }
      return new Sk.builtin.list(arr);
    } else if (typeof className === 'string') {
      return Sk.ffi.referenceToPy(valueJs, className);
    } else if (t === 'object' && valueJs === null) {
      return Sk.builtin.none.none$;
    } else {
      var kvs = [];
      for (var k in valueJs) {
        kvs.push(Sk.ffi.remapToPy(k));
        kvs.push(Sk.ffi.remapToPy(valueJs[k]));
      }
      return new Sk.builtin.dict(kvs);
    }
  } else if (t === 'string') {
    return Sk.ffi.stringToPy(valueJs);
  } else if (t === 'number') {
    return Sk.ffi.numberToPy(valueJs);
  } else if (t === 'boolean') {
    return Sk.ffi.booleanToPy(valueJs);
  } else {
    goog.asserts.fail('unhandled remapToPy type ' + t);
  }
};
goog.exportSymbol('Sk.ffi.remapToPy', Sk.ffi.remapToPy);
Sk.ffi.booleanToJs = function (valuePy, message) {
  if (valuePy === Sk.builtin.bool.true$) {
    return true;
  } else if (valuePy === Sk.builtin.bool.false$) {
    return false;
  } else {
    throw new Sk.builtin.AssertionError(message);
  }
};
goog.exportSymbol('Sk.ffi.booleanToJs', Sk.ffi.booleanToJs);
Sk.ffi.numberToJs = function (valuePy, message) {
  if (valuePy instanceof Sk.builtin.nmber) {
    return Sk.builtin.asnum$(valuePy);
  } else {
    if (typeof message === 'string') {
      throw new Sk.builtin.AssertionError(message);
    } else {
      goog.asserts.fail('e55f4353-0403-42f5-bd12-ec48459b3d2c');
    }
  }
};
goog.exportSymbol('Sk.ffi.numberToJs', Sk.ffi.numberToJs);
Sk.ffi.remapToJs = function (valuePy) {
  if (typeof valuePy === 'undefined') {
    return valuePy;
  } else if (valuePy instanceof Sk.builtin.dict) {
    var ret = {};
    for (var iter = valuePy.tp$iter(), k = iter.tp$iternext(); k !== undefined; k = iter.tp$iternext()) {
      var v = valuePy.mp$subscript(k);
      if (v === undefined) {
        v = null;
      }
      var kAsJs = Sk.ffi.remapToJs(k);
      ret[kAsJs] = Sk.ffi.remapToJs(v);
    }
    return ret;
  } else if (valuePy instanceof Sk.builtin.list) {
    var ret = [];
    for (var i = 0; i < valuePy.v.length; ++i) {
      ret.push(Sk.ffi.remapToJs(valuePy.v[i]));
    }
    return ret;
  } else if (valuePy instanceof Sk.builtin.nmber) {
    return Sk.builtin.asnum$(valuePy);
  } else if (valuePy instanceof Sk.builtin.lng) {
    return Sk.builtin.asnum$(valuePy);
  } else if (valuePy === Sk.builtin.bool.true$) {
    return Sk.ffi.booleanToJs(valuePy);
  } else if (valuePy === Sk.builtin.bool.false$) {
    return Sk.ffi.booleanToJs(valuePy);
  } else if (typeof valuePy.v !== 'undefined') {
    return valuePy.v;
  } else {
    return valuePy.v;
  }
};
goog.exportSymbol('Sk.ffi.remapToJs', Sk.ffi.remapToJs);
Sk.ffi.callback = function (fn) {
  if (fn === undefined)
    return fn;
  return function () {
    return Sk.misceval.apply(fn, undefined, undefined, undefined, Array.prototype.slice.call(arguments, 0));
  };
};
goog.exportSymbol('Sk.ffi.callback', Sk.ffi.callback);
Sk.builtin.enumerate = function (iterable, start) {
  if (!(this instanceof Sk.builtin.enumerate))
    return new Sk.builtin.enumerate(iterable, start);
  Sk.builtin.pyCheckArgs('enumerate', arguments, 1, 2);
  if (!Sk.builtin.checkIterable(iterable)) {
    throw new Sk.builtin.TypeError('\'' + Sk.abstr.typeName(iterable) + '\' object is not iterable');
  }
  if (start !== undefined) {
    if (!Sk.misceval.isIndex(start)) {
      throw new Sk.builtin.TypeError('\'' + Sk.abstr.typeName(start) + '\' object cannot be interpreted as an index');
    } else {
      start = Sk.misceval.asIndex(start);
    }
  } else {
    start = 0;
  }
  var it = iterable.tp$iter();
  this.tp$iter = function () {
    return this;
  };
  this.$index = start;
  this.tp$iternext = function () {
    var next = it.tp$iternext();
    if (next === undefined)
      return undefined;
    return new Sk.builtin.tuple([
      this.$index++,
      next
    ]);
  };
  this.__class__ = Sk.builtin.enumerate;
  return this;
};
Sk.builtin.enumerate.prototype.tp$name = 'enumerate';
Sk.builtin.enumerate.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj('enumerate', Sk.builtin.enumerate);
Sk.builtin.enumerate.prototype.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;
Sk.builtin.enumerate.prototype['__iter__'] = new Sk.builtin.func(function (self) {
  return self.tp$iter();
});
Sk.builtin.enumerate.prototype['next'] = new Sk.builtin.func(function (self) {
  return self.tp$iternext();
});
Sk.Tokenizer = function (filename, interactive, callback) {
  this.filename = filename;
  this.callback = callback;
  this.lnum = 0;
  this.parenlev = 0;
  this.continued = false;
  this.namechars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_';
  this.numchars = '0123456789';
  this.contstr = '';
  this.needcont = false;
  this.contline = undefined;
  this.indents = [0];
  this.endprog = /.*/;
  this.strstart = [
    -1,
    -1
  ];
  this.interactive = interactive;
  this.doneFunc = function () {
    for (var i = 1; i < this.indents.length; ++i) {
      if (this.callback(Sk.Tokenizer.Tokens.T_DEDENT, '', [
          this.lnum,
          0
        ], [
          this.lnum,
          0
        ], ''))
        return 'done';
    }
    if (this.callback(Sk.Tokenizer.Tokens.T_ENDMARKER, '', [
        this.lnum,
        0
      ], [
        this.lnum,
        0
      ], ''))
      return 'done';
    return 'failed';
  };
};
Sk.Tokenizer.Tokens = {
  T_ENDMARKER: 0,
  T_NAME: 1,
  T_NUMBER: 2,
  T_STRING: 3,
  T_NEWLINE: 4,
  T_INDENT: 5,
  T_DEDENT: 6,
  T_LPAR: 7,
  T_RPAR: 8,
  T_LSQB: 9,
  T_RSQB: 10,
  T_COLON: 11,
  T_COMMA: 12,
  T_SEMI: 13,
  T_PLUS: 14,
  T_MINUS: 15,
  T_STAR: 16,
  T_SLASH: 17,
  T_VBAR: 18,
  T_AMPER: 19,
  T_LESS: 20,
  T_GREATER: 21,
  T_EQUAL: 22,
  T_DOT: 23,
  T_PERCENT: 24,
  T_BACKQUOTE: 25,
  T_LBRACE: 26,
  T_RBRACE: 27,
  T_EQEQUAL: 28,
  T_NOTEQUAL: 29,
  T_LESSEQUAL: 30,
  T_GREATEREQUAL: 31,
  T_TILDE: 32,
  T_CIRCUMFLEX: 33,
  T_LEFTSHIFT: 34,
  T_RIGHTSHIFT: 35,
  T_DOUBLESTAR: 36,
  T_PLUSEQUAL: 37,
  T_MINEQUAL: 38,
  T_STAREQUAL: 39,
  T_SLASHEQUAL: 40,
  T_PERCENTEQUAL: 41,
  T_AMPEREQUAL: 42,
  T_VBAREQUAL: 43,
  T_CIRCUMFLEXEQUAL: 44,
  T_LEFTSHIFTEQUAL: 45,
  T_RIGHTSHIFTEQUAL: 46,
  T_DOUBLESTAREQUAL: 47,
  T_DOUBLESLASH: 48,
  T_DOUBLESLASHEQUAL: 49,
  T_AT: 50,
  T_OP: 51,
  T_COMMENT: 52,
  T_NL: 53,
  T_RARROW: 54,
  T_ERRORTOKEN: 55,
  T_N_TOKENS: 56,
  T_NT_OFFSET: 256
};
function group(x) {
  var args = Array.prototype.slice.call(arguments);
  return '(' + args.join('|') + ')';
}
function any(x) {
  return group.apply(null, arguments) + '*';
}
function maybe(x) {
  return group.apply(null, arguments) + '?';
}
var Whitespace = '[ \\f\\t]*';
var Comment_ = '#[^\\r\\n]*';
var Ident = '[a-zA-Z_]\\w*';
var Binnumber = '0[bB][01]*';
var Hexnumber = '0[xX][\\da-fA-F]*[lL]?';
var Octnumber = '0[oO]?[0-7]*[lL]?';
var Decnumber = '[1-9]\\d*[lL]?';
var Intnumber = group(Binnumber, Hexnumber, Octnumber, Decnumber);
var Exponent = '[eE][-+]?\\d+';
var Pointfloat = group('\\d+\\.\\d*', '\\.\\d+') + maybe(Exponent);
var Expfloat = '\\d+' + Exponent;
var Floatnumber = group(Pointfloat, Expfloat);
var Imagnumber = group('\\d+[jJ]', Floatnumber + '[jJ]');
var Number_ = group(Imagnumber, Floatnumber, Intnumber);
var Single = '^[^\'\\\\]*(?:\\\\.[^\'\\\\]*)*\'';
var Double_ = '^[^"\\\\]*(?:\\\\.[^"\\\\]*)*"';
var Single3 = '[^\'\\\\]*(?:(?:\\\\.|\'(?!\'\'))[^\'\\\\]*)*\'\'\'';
var Double3 = '[^"\\\\]*(?:(?:\\\\.|"(?!""))[^"\\\\]*)*"""';
var Triple = group('[ubUB]?[rR]?\'\'\'', '[ubUB]?[rR]?"""');
var String_ = group('[uU]?[rR]?\'[^\\n\'\\\\]*(?:\\\\.[^\\n\'\\\\]*)*\'', '[uU]?[rR]?"[^\\n"\\\\]*(?:\\\\.[^\\n"\\\\]*)*"');
var Operator = group('\\*\\*=?', '>>=?', '<<=?', '<>', '!=', '//=?', '->', '[+\\-*/%&|^=<>]=?', '~');
var Bracket = '[\\][(){}]';
var Special = group('\\r?\\n', '[:;.,`@]');
var Funny = group(Operator, Bracket, Special);
var ContStr = group('[uUbB]?[rR]?\'[^\\n\'\\\\]*(?:\\\\.[^\\n\'\\\\]*)*' + group('\'', '\\\\\\r?\\n'), '[uUbB]?[rR]?"[^\\n"\\\\]*(?:\\\\.[^\\n"\\\\]*)*' + group('"', '\\\\\\r?\\n'));
var PseudoExtras = group('\\\\\\r?\\n', Comment_, Triple);
var PseudoToken = '^' + group(PseudoExtras, Number_, Funny, ContStr, Ident);
var pseudoprog;
var single3prog;
var double3prog;
var endprogs = {};
var triple_quoted = {
    '\'\'\'': true,
    '"""': true,
    'r\'\'\'': true,
    'r"""': true,
    'R\'\'\'': true,
    'R"""': true,
    'u\'\'\'': true,
    'u"""': true,
    'U\'\'\'': true,
    'U"""': true,
    'b\'\'\'': true,
    'b"""': true,
    'B\'\'\'': true,
    'B"""': true,
    'ur\'\'\'': true,
    'ur"""': true,
    'Ur\'\'\'': true,
    'Ur"""': true,
    'uR\'\'\'': true,
    'uR"""': true,
    'UR\'\'\'': true,
    'UR"""': true,
    'br\'\'\'': true,
    'br"""': true,
    'Br\'\'\'': true,
    'Br"""': true,
    'bR\'\'\'': true,
    'bR"""': true,
    'BR\'\'\'': true,
    'BR"""': true
  };
var single_quoted = {
    '\'': true,
    '"': true,
    'r\'': true,
    'r"': true,
    'R\'': true,
    'R"': true,
    'u\'': true,
    'u"': true,
    'U\'': true,
    'U"': true,
    'b\'': true,
    'b"': true,
    'B\'': true,
    'B"': true,
    'ur\'': true,
    'ur"': true,
    'Ur\'': true,
    'Ur"': true,
    'uR\'': true,
    'uR"': true,
    'UR\'': true,
    'UR"': true,
    'br\'': true,
    'br"': true,
    'Br\'': true,
    'Br"': true,
    'bR\'': true,
    'bR"': true,
    'BR\'': true,
    'BR"': true
  };
(function () {
  for (var k in triple_quoted) {
  }
  for (var k in single_quoted) {
  }
}());
var tabsize = 8;
function contains(a, obj) {
  var i = a.length;
  while (i--) {
    if (a[i] === obj) {
      return true;
    }
  }
  return false;
}
function rstrip(input, what) {
  for (var i = input.length; i > 0; --i) {
    if (what.indexOf(input.charAt(i - 1)) === -1)
      break;
  }
  return input.substring(0, i);
}
Sk.Tokenizer.prototype.generateTokens = function (line) {
  var endmatch, pos, column, end, max;
  var pseudoprog = new RegExp(PseudoToken);
  var single3prog = new RegExp(Single3, 'g');
  var double3prog = new RegExp(Double3, 'g');
  var endprogs = {
      '\'': new RegExp(Single, 'g'),
      '"': new RegExp(Double_, 'g'),
      '\'\'\'': single3prog,
      '"""': double3prog,
      'r\'\'\'': single3prog,
      'r"""': double3prog,
      'u\'\'\'': single3prog,
      'u"""': double3prog,
      'b\'\'\'': single3prog,
      'b"""': double3prog,
      'ur\'\'\'': single3prog,
      'ur"""': double3prog,
      'br\'\'\'': single3prog,
      'br"""': double3prog,
      'R\'\'\'': single3prog,
      'R"""': double3prog,
      'U\'\'\'': single3prog,
      'U"""': double3prog,
      'B\'\'\'': single3prog,
      'B"""': double3prog,
      'uR\'\'\'': single3prog,
      'uR"""': double3prog,
      'Ur\'\'\'': single3prog,
      'Ur"""': double3prog,
      'UR\'\'\'': single3prog,
      'UR"""': double3prog,
      'bR\'\'\'': single3prog,
      'bR"""': double3prog,
      'Br\'\'\'': single3prog,
      'Br"""': double3prog,
      'BR\'\'\'': single3prog,
      'BR"""': double3prog,
      'r': null,
      'R': null,
      'u': null,
      'U': null,
      'b': null,
      'B': null
    };
  if (!line)
    line = '';
  this.lnum += 1;
  pos = 0;
  max = line.length;
  if (this.contstr.length > 0) {
    if (!line) {
      throw new Sk.builtin.TokenError('EOF in multi-line string', this.filename, this.strstart[0], this.strstart[1], this.contline);
    }
    this.endprog.lastIndex = 0;
    endmatch = this.endprog.test(line);
    if (endmatch) {
      pos = end = this.endprog.lastIndex;
      if (this.callback(Sk.Tokenizer.Tokens.T_STRING, this.contstr + line.substring(0, end), this.strstart, [
          this.lnum,
          end
        ], this.contline + line))
        return 'done';
      this.contstr = '';
      this.needcont = false;
      this.contline = undefined;
    } else if (this.needcont && line.substring(line.length - 2) !== '\\\n' && line.substring(line.length - 3) !== '\\\r\n') {
      if (this.callback(Sk.Tokenizer.Tokens.T_ERRORTOKEN, this.contstr + line, this.strstart, [
          this.lnum,
          line.length
        ], this.contline))
        return 'done';
      this.contstr = '';
      this.contline = undefined;
      return false;
    } else {
      this.contstr += line;
      this.contline = this.contline + line;
      return false;
    }
  } else if (this.parenlev === 0 && !this.continued) {
    if (!line)
      return this.doneFunc();
    column = 0;
    while (pos < max) {
      if (line.charAt(pos) === ' ')
        column += 1;
      else if (line.charAt(pos) === '\t')
        column = (column / tabsize + 1) * tabsize;
      else if (line.charAt(pos) === '\f')
        column = 0;
      else
        break;
      pos = pos + 1;
    }
    if (pos === max)
      return this.doneFunc();
    if ('#\r\n'.indexOf(line.charAt(pos)) !== -1) {
      if (line.charAt(pos) === '#') {
        var comment_token = rstrip(line.substring(pos), '\r\n');
        var nl_pos = pos + comment_token.length;
        if (this.callback(Sk.Tokenizer.Tokens.T_COMMENT, comment_token, [
            this.lnum,
            pos
          ], [
            this.lnum,
            pos + comment_token.length
          ], line))
          return 'done';
        if (this.callback(Sk.Tokenizer.Tokens.T_NL, line.substring(nl_pos), [
            this.lnum,
            nl_pos
          ], [
            this.lnum,
            line.length
          ], line))
          return 'done';
        return false;
      } else {
        if (this.callback(Sk.Tokenizer.Tokens.T_NL, line.substring(pos), [
            this.lnum,
            pos
          ], [
            this.lnum,
            line.length
          ], line))
          return 'done';
        if (!this.interactive)
          return false;
      }
    }
    if (column > this.indents[this.indents.length - 1]) {
      this.indents.push(column);
      if (this.callback(Sk.Tokenizer.Tokens.T_INDENT, line.substring(0, pos), [
          this.lnum,
          0
        ], [
          this.lnum,
          pos
        ], line))
        return 'done';
    }
    while (column < this.indents[this.indents.length - 1]) {
      if (!contains(this.indents, column)) {
        throw new Sk.builtin.IndentationError('unindent does not match any outer indentation level', this.filename, this.lnum, pos, line);
      }
      this.indents.splice(this.indents.length - 1, 1);
      if (this.callback(Sk.Tokenizer.Tokens.T_DEDENT, '', [
          this.lnum,
          pos
        ], [
          this.lnum,
          pos
        ], line))
        return 'done';
    }
  } else {
    if (!line) {
      throw new Sk.builtin.TokenError('EOF in multi-line statement', this.filename, this.lnum, 0, line);
    }
    this.continued = false;
  }
  while (pos < max) {
    var capos = line.charAt(pos);
    while (capos === ' ' || capos === '\f' || capos === '\t') {
      pos += 1;
      capos = line.charAt(pos);
    }
    pseudoprog.lastIndex = 0;
    var pseudomatch = pseudoprog.exec(line.substring(pos));
    if (pseudomatch) {
      var start = pos;
      end = start + pseudomatch[1].length;
      var spos = [
          this.lnum,
          start
        ];
      var epos = [
          this.lnum,
          end
        ];
      pos = end;
      var token = line.substring(start, end);
      var initial = line.charAt(start);
      if (this.numchars.indexOf(initial) !== -1 || initial === '.' && token !== '.') {
        if (this.callback(Sk.Tokenizer.Tokens.T_NUMBER, token, spos, epos, line))
          return 'done';
      } else if (initial === '\r' || initial === '\n') {
        var newl = Sk.Tokenizer.Tokens.T_NEWLINE;
        if (this.parenlev > 0)
          newl = Sk.Tokenizer.Tokens.T_NL;
        if (this.callback(newl, token, spos, epos, line))
          return 'done';
      } else if (initial === '#') {
        if (this.callback(Sk.Tokenizer.Tokens.T_COMMENT, token, spos, epos, line))
          return 'done';
      } else if (triple_quoted.hasOwnProperty(token)) {
        this.endprog = endprogs[token];
        this.endprog.lastIndex = 0;
        endmatch = this.endprog.test(line.substring(pos));
        if (endmatch) {
          pos = this.endprog.lastIndex + pos;
          token = line.substring(start, pos);
          if (this.callback(Sk.Tokenizer.Tokens.T_STRING, token, spos, [
              this.lnum,
              pos
            ], line))
            return 'done';
        } else {
          this.strstart = [
            this.lnum,
            start
          ];
          this.contstr = line.substring(start);
          this.contline = line;
          return false;
        }
      } else if (single_quoted.hasOwnProperty(initial) || single_quoted.hasOwnProperty(token.substring(0, 2)) || single_quoted.hasOwnProperty(token.substring(0, 3))) {
        if (token[token.length - 1] === '\n') {
          this.strstart = [
            this.lnum,
            start
          ];
          this.endprog = endprogs[initial] || endprogs[token[1]] || endprogs[token[2]];
          this.contstr = line.substring(start);
          this.needcont = true;
          this.contline = line;
          return false;
        } else {
          if (this.callback(Sk.Tokenizer.Tokens.T_STRING, token, spos, epos, line))
            return 'done';
        }
      } else if (this.namechars.indexOf(initial) !== -1) {
        if (this.callback(Sk.Tokenizer.Tokens.T_NAME, token, spos, epos, line))
          return 'done';
      } else if (initial === '\\') {
        if (this.callback(Sk.Tokenizer.Tokens.T_NL, token, spos, [
            this.lnum,
            pos
          ], line))
          return 'done';
        this.continued = true;
      } else {
        if ('([{'.indexOf(initial) !== -1)
          this.parenlev += 1;
        else if (')]}'.indexOf(initial) !== -1)
          this.parenlev -= 1;
        if (this.callback(Sk.Tokenizer.Tokens.T_OP, token, spos, epos, line))
          return 'done';
      }
    } else {
      if (this.callback(Sk.Tokenizer.Tokens.T_ERRORTOKEN, line.charAt(pos), [
          this.lnum,
          pos
        ], [
          this.lnum,
          pos + 1
        ], line))
        return 'done';
      pos += 1;
    }
  }
  return false;
};
Sk.Tokenizer.tokenNames = {
  0: 'T_ENDMARKER',
  1: 'T_NAME',
  2: 'T_NUMBER',
  3: 'T_STRING',
  4: 'T_NEWLINE',
  5: 'T_INDENT',
  6: 'T_DEDENT',
  7: 'T_LPAR',
  8: 'T_RPAR',
  9: 'T_LSQB',
  10: 'T_RSQB',
  11: 'T_COLON',
  12: 'T_COMMA',
  13: 'T_SEMI',
  14: 'T_PLUS',
  15: 'T_MINUS',
  16: 'T_STAR',
  17: 'T_SLASH',
  18: 'T_VBAR',
  19: 'T_AMPER',
  20: 'T_LESS',
  21: 'T_GREATER',
  22: 'T_EQUAL',
  23: 'T_DOT',
  24: 'T_PERCENT',
  25: 'T_BACKQUOTE',
  26: 'T_LBRACE',
  27: 'T_RBRACE',
  28: 'T_EQEQUAL',
  29: 'T_NOTEQUAL',
  30: 'T_LESSEQUAL',
  31: 'T_GREATEREQUAL',
  32: 'T_TILDE',
  33: 'T_CIRCUMFLEX',
  34: 'T_LEFTSHIFT',
  35: 'T_RIGHTSHIFT',
  36: 'T_DOUBLESTAR',
  37: 'T_PLUSEQUAL',
  38: 'T_MINEQUAL',
  39: 'T_STAREQUAL',
  40: 'T_SLASHEQUAL',
  41: 'T_PERCENTEQUAL',
  42: 'T_AMPEREQUAL',
  43: 'T_VBAREQUAL',
  44: 'T_CIRCUMFLEXEQUAL',
  45: 'T_LEFTSHIFTEQUAL',
  46: 'T_RIGHTSHIFTEQUAL',
  47: 'T_DOUBLESTAREQUAL',
  48: 'T_DOUBLESLASH',
  49: 'T_DOUBLESLASHEQUAL',
  50: 'T_AT',
  51: 'T_OP',
  52: 'T_COMMENT',
  53: 'T_NL',
  54: 'T_RARROW',
  55: 'T_ERRORTOKEN',
  56: 'T_N_TOKENS',
  256: 'T_NT_OFFSET'
};
goog.exportSymbol('Sk.Tokenizer', Sk.Tokenizer);
goog.exportSymbol('Sk.Tokenizer.prototype.generateTokens', Sk.Tokenizer.prototype.generateTokens);
goog.exportSymbol('Sk.Tokenizer.tokenNames', Sk.Tokenizer.tokenNames);
Sk.OpMap = {
  '(': Sk.Tokenizer.Tokens.T_LPAR,
  ')': Sk.Tokenizer.Tokens.T_RPAR,
  '[': Sk.Tokenizer.Tokens.T_LSQB,
  ']': Sk.Tokenizer.Tokens.T_RSQB,
  ':': Sk.Tokenizer.Tokens.T_COLON,
  ',': Sk.Tokenizer.Tokens.T_COMMA,
  ';': Sk.Tokenizer.Tokens.T_SEMI,
  '+': Sk.Tokenizer.Tokens.T_PLUS,
  '-': Sk.Tokenizer.Tokens.T_MINUS,
  '*': Sk.Tokenizer.Tokens.T_STAR,
  '/': Sk.Tokenizer.Tokens.T_SLASH,
  '|': Sk.Tokenizer.Tokens.T_VBAR,
  '&': Sk.Tokenizer.Tokens.T_AMPER,
  '<': Sk.Tokenizer.Tokens.T_LESS,
  '>': Sk.Tokenizer.Tokens.T_GREATER,
  '=': Sk.Tokenizer.Tokens.T_EQUAL,
  '.': Sk.Tokenizer.Tokens.T_DOT,
  '%': Sk.Tokenizer.Tokens.T_PERCENT,
  '`': Sk.Tokenizer.Tokens.T_BACKQUOTE,
  '{': Sk.Tokenizer.Tokens.T_LBRACE,
  '}': Sk.Tokenizer.Tokens.T_RBRACE,
  '@': Sk.Tokenizer.Tokens.T_AT,
  '==': Sk.Tokenizer.Tokens.T_EQEQUAL,
  '!=': Sk.Tokenizer.Tokens.T_NOTEQUAL,
  '<>': Sk.Tokenizer.Tokens.T_NOTEQUAL,
  '<=': Sk.Tokenizer.Tokens.T_LESSEQUAL,
  '>=': Sk.Tokenizer.Tokens.T_GREATEREQUAL,
  '~': Sk.Tokenizer.Tokens.T_TILDE,
  '^': Sk.Tokenizer.Tokens.T_CIRCUMFLEX,
  '<<': Sk.Tokenizer.Tokens.T_LEFTSHIFT,
  '>>': Sk.Tokenizer.Tokens.T_RIGHTSHIFT,
  '**': Sk.Tokenizer.Tokens.T_DOUBLESTAR,
  '+=': Sk.Tokenizer.Tokens.T_PLUSEQUAL,
  '-=': Sk.Tokenizer.Tokens.T_MINEQUAL,
  '*=': Sk.Tokenizer.Tokens.T_STAREQUAL,
  '/=': Sk.Tokenizer.Tokens.T_SLASHEQUAL,
  '%=': Sk.Tokenizer.Tokens.T_PERCENTEQUAL,
  '&=': Sk.Tokenizer.Tokens.T_AMPEREQUAL,
  '|=': Sk.Tokenizer.Tokens.T_VBAREQUAL,
  '^=': Sk.Tokenizer.Tokens.T_CIRCUMFLEXEQUAL,
  '<<=': Sk.Tokenizer.Tokens.T_LEFTSHIFTEQUAL,
  '>>=': Sk.Tokenizer.Tokens.T_RIGHTSHIFTEQUAL,
  '**=': Sk.Tokenizer.Tokens.T_DOUBLESTAREQUAL,
  '//': Sk.Tokenizer.Tokens.T_DOUBLESLASH,
  '//=': Sk.Tokenizer.Tokens.T_DOUBLESLASHEQUAL,
  '->': Sk.Tokenizer.Tokens.T_RARROW
};
Sk.ParseTables = {
  sym: {
    and_expr: 257,
    and_test: 258,
    arglist: 259,
    argument: 260,
    arith_expr: 261,
    assert_stmt: 262,
    atom: 263,
    augassign: 264,
    break_stmt: 265,
    classdef: 266,
    comp_op: 267,
    comparison: 268,
    compound_stmt: 269,
    continue_stmt: 270,
    decorated: 271,
    decorator: 272,
    decorators: 273,
    del_stmt: 274,
    dictmaker: 275,
    dotted_as_name: 276,
    dotted_as_names: 277,
    dotted_name: 278,
    encoding_decl: 279,
    eval_input: 280,
    except_clause: 281,
    exec_stmt: 282,
    expr: 283,
    expr_stmt: 284,
    exprlist: 285,
    factor: 286,
    file_input: 287,
    flow_stmt: 288,
    for_stmt: 289,
    fpdef: 290,
    fplist: 291,
    funcdef: 292,
    gen_for: 293,
    gen_if: 294,
    gen_iter: 295,
    global_stmt: 296,
    if_stmt: 297,
    import_as_name: 298,
    import_as_names: 299,
    import_from: 300,
    import_name: 301,
    import_stmt: 302,
    lambdef: 303,
    list_for: 304,
    list_if: 305,
    list_iter: 306,
    listmaker: 307,
    not_test: 308,
    old_lambdef: 309,
    old_test: 310,
    or_test: 311,
    parameters: 312,
    pass_stmt: 313,
    power: 314,
    print_stmt: 315,
    raise_stmt: 316,
    return_stmt: 317,
    shift_expr: 318,
    simple_stmt: 319,
    single_input: 256,
    sliceop: 320,
    small_stmt: 321,
    stmt: 322,
    subscript: 323,
    subscriptlist: 324,
    suite: 325,
    term: 326,
    test: 327,
    testlist: 328,
    testlist1: 329,
    testlist_gexp: 330,
    testlist_safe: 331,
    trailer: 332,
    try_stmt: 333,
    varargslist: 334,
    while_stmt: 335,
    with_stmt: 336,
    with_var: 337,
    xor_expr: 338,
    yield_expr: 339,
    yield_stmt: 340
  },
  number2symbol: {
    256: 'single_input',
    257: 'and_expr',
    258: 'and_test',
    259: 'arglist',
    260: 'argument',
    261: 'arith_expr',
    262: 'assert_stmt',
    263: 'atom',
    264: 'augassign',
    265: 'break_stmt',
    266: 'classdef',
    267: 'comp_op',
    268: 'comparison',
    269: 'compound_stmt',
    270: 'continue_stmt',
    271: 'decorated',
    272: 'decorator',
    273: 'decorators',
    274: 'del_stmt',
    275: 'dictmaker',
    276: 'dotted_as_name',
    277: 'dotted_as_names',
    278: 'dotted_name',
    279: 'encoding_decl',
    280: 'eval_input',
    281: 'except_clause',
    282: 'exec_stmt',
    283: 'expr',
    284: 'expr_stmt',
    285: 'exprlist',
    286: 'factor',
    287: 'file_input',
    288: 'flow_stmt',
    289: 'for_stmt',
    290: 'fpdef',
    291: 'fplist',
    292: 'funcdef',
    293: 'gen_for',
    294: 'gen_if',
    295: 'gen_iter',
    296: 'global_stmt',
    297: 'if_stmt',
    298: 'import_as_name',
    299: 'import_as_names',
    300: 'import_from',
    301: 'import_name',
    302: 'import_stmt',
    303: 'lambdef',
    304: 'list_for',
    305: 'list_if',
    306: 'list_iter',
    307: 'listmaker',
    308: 'not_test',
    309: 'old_lambdef',
    310: 'old_test',
    311: 'or_test',
    312: 'parameters',
    313: 'pass_stmt',
    314: 'power',
    315: 'print_stmt',
    316: 'raise_stmt',
    317: 'return_stmt',
    318: 'shift_expr',
    319: 'simple_stmt',
    320: 'sliceop',
    321: 'small_stmt',
    322: 'stmt',
    323: 'subscript',
    324: 'subscriptlist',
    325: 'suite',
    326: 'term',
    327: 'test',
    328: 'testlist',
    329: 'testlist1',
    330: 'testlist_gexp',
    331: 'testlist_safe',
    332: 'trailer',
    333: 'try_stmt',
    334: 'varargslist',
    335: 'while_stmt',
    336: 'with_stmt',
    337: 'with_var',
    338: 'xor_expr',
    339: 'yield_expr',
    340: 'yield_stmt'
  },
  dfas: {
    256: [
      [
        [
          [
            1,
            1
          ],
          [
            2,
            1
          ],
          [
            3,
            2
          ]
        ],
        [[
            0,
            1
          ]],
        [[
            2,
            1
          ]]
      ],
      {
        2: 1,
        4: 1,
        5: 1,
        6: 1,
        7: 1,
        8: 1,
        9: 1,
        10: 1,
        11: 1,
        12: 1,
        13: 1,
        14: 1,
        15: 1,
        16: 1,
        17: 1,
        18: 1,
        19: 1,
        20: 1,
        21: 1,
        22: 1,
        23: 1,
        24: 1,
        25: 1,
        26: 1,
        27: 1,
        28: 1,
        29: 1,
        30: 1,
        31: 1,
        32: 1,
        33: 1,
        34: 1,
        35: 1,
        36: 1
      }
    ],
    257: [
      [
        [[
            37,
            1
          ]],
        [
          [
            38,
            0
          ],
          [
            0,
            1
          ]
        ]
      ],
      {
        6: 1,
        8: 1,
        9: 1,
        11: 1,
        13: 1,
        17: 1,
        20: 1,
        24: 1,
        28: 1,
        35: 1
      }
    ],
    258: [
      [
        [[
            39,
            1
          ]],
        [
          [
            40,
            0
          ],
          [
            0,
            1
          ]
        ]
      ],
      {
        6: 1,
        7: 1,
        8: 1,
        9: 1,
        11: 1,
        13: 1,
        17: 1,
        20: 1,
        24: 1,
        28: 1,
        35: 1
      }
    ],
    259: [
      [
        [
          [
            41,
            1
          ],
          [
            42,
            2
          ],
          [
            43,
            3
          ]
        ],
        [[
            44,
            4
          ]],
        [
          [
            45,
            5
          ],
          [
            0,
            2
          ]
        ],
        [[
            44,
            6
          ]],
        [
          [
            45,
            7
          ],
          [
            0,
            4
          ]
        ],
        [
          [
            41,
            1
          ],
          [
            42,
            2
          ],
          [
            43,
            3
          ],
          [
            0,
            5
          ]
        ],
        [[
            0,
            6
          ]],
        [
          [
            42,
            4
          ],
          [
            43,
            3
          ]
        ]
      ],
      {
        6: 1,
        7: 1,
        8: 1,
        9: 1,
        11: 1,
        13: 1,
        17: 1,
        20: 1,
        24: 1,
        28: 1,
        35: 1,
        36: 1,
        41: 1,
        43: 1
      }
    ],
    260: [
      [
        [[
            44,
            1
          ]],
        [
          [
            46,
            2
          ],
          [
            47,
            3
          ],
          [
            0,
            1
          ]
        ],
        [[
            0,
            2
          ]],
        [[
            44,
            2
          ]]
      ],
      {
        6: 1,
        7: 1,
        8: 1,
        9: 1,
        11: 1,
        13: 1,
        17: 1,
        20: 1,
        24: 1,
        28: 1,
        35: 1,
        36: 1
      }
    ],
    261: [
      [
        [[
            48,
            1
          ]],
        [
          [
            24,
            0
          ],
          [
            35,
            0
          ],
          [
            0,
            1
          ]
        ]
      ],
      {
        6: 1,
        8: 1,
        9: 1,
        11: 1,
        13: 1,
        17: 1,
        20: 1,
        24: 1,
        28: 1,
        35: 1
      }
    ],
    262: [
      [
        [[
            19,
            1
          ]],
        [[
            44,
            2
          ]],
        [
          [
            45,
            3
          ],
          [
            0,
            2
          ]
        ],
        [[
            44,
            4
          ]],
        [[
            0,
            4
          ]]
      ],
      { 19: 1 }
    ],
    263: [
      [
        [
          [
            17,
            1
          ],
          [
            8,
            2
          ],
          [
            9,
            5
          ],
          [
            28,
            4
          ],
          [
            11,
            3
          ],
          [
            13,
            6
          ],
          [
            20,
            2
          ]
        ],
        [
          [
            17,
            1
          ],
          [
            0,
            1
          ]
        ],
        [[
            0,
            2
          ]],
        [
          [
            49,
            7
          ],
          [
            50,
            2
          ]
        ],
        [
          [
            51,
            2
          ],
          [
            52,
            8
          ],
          [
            53,
            8
          ]
        ],
        [
          [
            54,
            9
          ],
          [
            55,
            2
          ]
        ],
        [[
            56,
            10
          ]],
        [[
            50,
            2
          ]],
        [[
            51,
            2
          ]],
        [[
            55,
            2
          ]],
        [[
            13,
            2
          ]]
      ],
      {
        8: 1,
        9: 1,
        11: 1,
        13: 1,
        17: 1,
        20: 1,
        28: 1
      }
    ],
    264: [
      [
        [
          [
            57,
            1
          ],
          [
            58,
            1
          ],
          [
            59,
            1
          ],
          [
            60,
            1
          ],
          [
            61,
            1
          ],
          [
            62,
            1
          ],
          [
            63,
            1
          ],
          [
            64,
            1
          ],
          [
            65,
            1
          ],
          [
            66,
            1
          ],
          [
            67,
            1
          ],
          [
            68,
            1
          ]
        ],
        [[
            0,
            1
          ]]
      ],
      {
        57: 1,
        58: 1,
        59: 1,
        60: 1,
        61: 1,
        62: 1,
        63: 1,
        64: 1,
        65: 1,
        66: 1,
        67: 1,
        68: 1
      }
    ],
    265: [
      [
        [[
            31,
            1
          ]],
        [[
            0,
            1
          ]]
      ],
      { 31: 1 }
    ],
    266: [
      [
        [[
            10,
            1
          ]],
        [[
            20,
            2
          ]],
        [
          [
            69,
            3
          ],
          [
            28,
            4
          ]
        ],
        [[
            70,
            5
          ]],
        [
          [
            51,
            6
          ],
          [
            71,
            7
          ]
        ],
        [[
            0,
            5
          ]],
        [[
            69,
            3
          ]],
        [[
            51,
            6
          ]]
      ],
      { 10: 1 }
    ],
    267: [
      [
        [
          [
            72,
            1
          ],
          [
            73,
            1
          ],
          [
            7,
            2
          ],
          [
            74,
            1
          ],
          [
            72,
            1
          ],
          [
            75,
            1
          ],
          [
            76,
            1
          ],
          [
            77,
            3
          ],
          [
            78,
            1
          ],
          [
            79,
            1
          ]
        ],
        [[
            0,
            1
          ]],
        [[
            75,
            1
          ]],
        [
          [
            7,
            1
          ],
          [
            0,
            3
          ]
        ]
      ],
      {
        7: 1,
        72: 1,
        73: 1,
        74: 1,
        75: 1,
        76: 1,
        77: 1,
        78: 1,
        79: 1
      }
    ],
    268: [
      [
        [[
            80,
            1
          ]],
        [
          [
            81,
            0
          ],
          [
            0,
            1
          ]
        ]
      ],
      {
        6: 1,
        8: 1,
        9: 1,
        11: 1,
        13: 1,
        17: 1,
        20: 1,
        24: 1,
        28: 1,
        35: 1
      }
    ],
    269: [
      [
        [
          [
            82,
            1
          ],
          [
            83,
            1
          ],
          [
            84,
            1
          ],
          [
            85,
            1
          ],
          [
            86,
            1
          ],
          [
            87,
            1
          ],
          [
            88,
            1
          ],
          [
            89,
            1
          ]
        ],
        [[
            0,
            1
          ]]
      ],
      {
        4: 1,
        10: 1,
        14: 1,
        16: 1,
        27: 1,
        30: 1,
        33: 1,
        34: 1
      }
    ],
    270: [
      [
        [[
            32,
            1
          ]],
        [[
            0,
            1
          ]]
      ],
      { 32: 1 }
    ],
    271: [
      [
        [[
            90,
            1
          ]],
        [
          [
            88,
            2
          ],
          [
            85,
            2
          ]
        ],
        [[
            0,
            2
          ]]
      ],
      { 33: 1 }
    ],
    272: [
      [
        [[
            33,
            1
          ]],
        [[
            91,
            2
          ]],
        [
          [
            28,
            4
          ],
          [
            2,
            3
          ]
        ],
        [[
            0,
            3
          ]],
        [
          [
            51,
            5
          ],
          [
            92,
            6
          ]
        ],
        [[
            2,
            3
          ]],
        [[
            51,
            5
          ]]
      ],
      { 33: 1 }
    ],
    273: [
      [
        [[
            93,
            1
          ]],
        [
          [
            93,
            1
          ],
          [
            0,
            1
          ]
        ]
      ],
      { 33: 1 }
    ],
    274: [
      [
        [[
            21,
            1
          ]],
        [[
            94,
            2
          ]],
        [[
            0,
            2
          ]]
      ],
      { 21: 1 }
    ],
    275: [
      [
        [[
            44,
            1
          ]],
        [[
            69,
            2
          ]],
        [[
            44,
            3
          ]],
        [
          [
            45,
            4
          ],
          [
            0,
            3
          ]
        ],
        [
          [
            44,
            1
          ],
          [
            0,
            4
          ]
        ]
      ],
      {
        6: 1,
        7: 1,
        8: 1,
        9: 1,
        11: 1,
        13: 1,
        17: 1,
        20: 1,
        24: 1,
        28: 1,
        35: 1,
        36: 1
      }
    ],
    276: [
      [
        [[
            91,
            1
          ]],
        [
          [
            95,
            2
          ],
          [
            0,
            1
          ]
        ],
        [[
            20,
            3
          ]],
        [[
            0,
            3
          ]]
      ],
      { 20: 1 }
    ],
    277: [
      [
        [[
            96,
            1
          ]],
        [
          [
            45,
            0
          ],
          [
            0,
            1
          ]
        ]
      ],
      { 20: 1 }
    ],
    278: [
      [
        [[
            20,
            1
          ]],
        [
          [
            97,
            0
          ],
          [
            0,
            1
          ]
        ]
      ],
      { 20: 1 }
    ],
    279: [
      [
        [[
            20,
            1
          ]],
        [[
            0,
            1
          ]]
      ],
      { 20: 1 }
    ],
    280: [
      [
        [[
            71,
            1
          ]],
        [
          [
            2,
            1
          ],
          [
            98,
            2
          ]
        ],
        [[
            0,
            2
          ]]
      ],
      {
        6: 1,
        7: 1,
        8: 1,
        9: 1,
        11: 1,
        13: 1,
        17: 1,
        20: 1,
        24: 1,
        28: 1,
        35: 1,
        36: 1
      }
    ],
    281: [
      [
        [[
            99,
            1
          ]],
        [
          [
            44,
            2
          ],
          [
            0,
            1
          ]
        ],
        [
          [
            95,
            3
          ],
          [
            45,
            3
          ],
          [
            0,
            2
          ]
        ],
        [[
            44,
            4
          ]],
        [[
            0,
            4
          ]]
      ],
      { 99: 1 }
    ],
    282: [
      [
        [[
            15,
            1
          ]],
        [[
            80,
            2
          ]],
        [
          [
            75,
            3
          ],
          [
            0,
            2
          ]
        ],
        [[
            44,
            4
          ]],
        [
          [
            45,
            5
          ],
          [
            0,
            4
          ]
        ],
        [[
            44,
            6
          ]],
        [[
            0,
            6
          ]]
      ],
      { 15: 1 }
    ],
    283: [
      [
        [[
            100,
            1
          ]],
        [
          [
            101,
            0
          ],
          [
            0,
            1
          ]
        ]
      ],
      {
        6: 1,
        8: 1,
        9: 1,
        11: 1,
        13: 1,
        17: 1,
        20: 1,
        24: 1,
        28: 1,
        35: 1
      }
    ],
    284: [
      [
        [[
            71,
            1
          ]],
        [
          [
            102,
            2
          ],
          [
            47,
            3
          ],
          [
            0,
            1
          ]
        ],
        [
          [
            71,
            4
          ],
          [
            53,
            4
          ]
        ],
        [
          [
            71,
            5
          ],
          [
            53,
            5
          ]
        ],
        [[
            0,
            4
          ]],
        [
          [
            47,
            3
          ],
          [
            0,
            5
          ]
        ]
      ],
      {
        6: 1,
        7: 1,
        8: 1,
        9: 1,
        11: 1,
        13: 1,
        17: 1,
        20: 1,
        24: 1,
        28: 1,
        35: 1,
        36: 1
      }
    ],
    285: [
      [
        [[
            80,
            1
          ]],
        [
          [
            45,
            2
          ],
          [
            0,
            1
          ]
        ],
        [
          [
            80,
            1
          ],
          [
            0,
            2
          ]
        ]
      ],
      {
        6: 1,
        8: 1,
        9: 1,
        11: 1,
        13: 1,
        17: 1,
        20: 1,
        24: 1,
        28: 1,
        35: 1
      }
    ],
    286: [
      [
        [
          [
            103,
            2
          ],
          [
            24,
            1
          ],
          [
            6,
            1
          ],
          [
            35,
            1
          ]
        ],
        [[
            104,
            2
          ]],
        [[
            0,
            2
          ]]
      ],
      {
        6: 1,
        8: 1,
        9: 1,
        11: 1,
        13: 1,
        17: 1,
        20: 1,
        24: 1,
        28: 1,
        35: 1
      }
    ],
    287: [
      [
        [
          [
            2,
            0
          ],
          [
            98,
            1
          ],
          [
            105,
            0
          ]
        ],
        [[
            0,
            1
          ]]
      ],
      {
        2: 1,
        4: 1,
        5: 1,
        6: 1,
        7: 1,
        8: 1,
        9: 1,
        10: 1,
        11: 1,
        12: 1,
        13: 1,
        14: 1,
        15: 1,
        16: 1,
        17: 1,
        18: 1,
        19: 1,
        20: 1,
        21: 1,
        22: 1,
        23: 1,
        24: 1,
        25: 1,
        26: 1,
        27: 1,
        28: 1,
        29: 1,
        30: 1,
        31: 1,
        32: 1,
        33: 1,
        34: 1,
        35: 1,
        36: 1,
        98: 1
      }
    ],
    288: [
      [
        [
          [
            106,
            1
          ],
          [
            107,
            1
          ],
          [
            108,
            1
          ],
          [
            109,
            1
          ],
          [
            110,
            1
          ]
        ],
        [[
            0,
            1
          ]]
      ],
      {
        5: 1,
        18: 1,
        25: 1,
        31: 1,
        32: 1
      }
    ],
    289: [
      [
        [[
            27,
            1
          ]],
        [[
            94,
            2
          ]],
        [[
            75,
            3
          ]],
        [[
            71,
            4
          ]],
        [[
            69,
            5
          ]],
        [[
            70,
            6
          ]],
        [
          [
            111,
            7
          ],
          [
            0,
            6
          ]
        ],
        [[
            69,
            8
          ]],
        [[
            70,
            9
          ]],
        [[
            0,
            9
          ]]
      ],
      { 27: 1 }
    ],
    290: [
      [
        [
          [
            28,
            1
          ],
          [
            20,
            2
          ]
        ],
        [[
            112,
            3
          ]],
        [[
            0,
            2
          ]],
        [[
            51,
            2
          ]]
      ],
      {
        20: 1,
        28: 1
      }
    ],
    291: [
      [
        [[
            113,
            1
          ]],
        [
          [
            45,
            2
          ],
          [
            0,
            1
          ]
        ],
        [
          [
            113,
            1
          ],
          [
            0,
            2
          ]
        ]
      ],
      {
        20: 1,
        28: 1
      }
    ],
    292: [
      [
        [[
            4,
            1
          ]],
        [[
            20,
            2
          ]],
        [[
            114,
            3
          ]],
        [[
            69,
            4
          ]],
        [[
            70,
            5
          ]],
        [[
            0,
            5
          ]]
      ],
      { 4: 1 }
    ],
    293: [
      [
        [[
            27,
            1
          ]],
        [[
            94,
            2
          ]],
        [[
            75,
            3
          ]],
        [[
            115,
            4
          ]],
        [
          [
            116,
            5
          ],
          [
            0,
            4
          ]
        ],
        [[
            0,
            5
          ]]
      ],
      { 27: 1 }
    ],
    294: [
      [
        [[
            30,
            1
          ]],
        [[
            117,
            2
          ]],
        [
          [
            116,
            3
          ],
          [
            0,
            2
          ]
        ],
        [[
            0,
            3
          ]]
      ],
      { 30: 1 }
    ],
    295: [
      [
        [
          [
            46,
            1
          ],
          [
            118,
            1
          ]
        ],
        [[
            0,
            1
          ]]
      ],
      {
        27: 1,
        30: 1
      }
    ],
    296: [
      [
        [[
            26,
            1
          ]],
        [[
            20,
            2
          ]],
        [
          [
            45,
            1
          ],
          [
            0,
            2
          ]
        ]
      ],
      { 26: 1 }
    ],
    297: [
      [
        [[
            30,
            1
          ]],
        [[
            44,
            2
          ]],
        [[
            69,
            3
          ]],
        [[
            70,
            4
          ]],
        [
          [
            111,
            5
          ],
          [
            119,
            1
          ],
          [
            0,
            4
          ]
        ],
        [[
            69,
            6
          ]],
        [[
            70,
            7
          ]],
        [[
            0,
            7
          ]]
      ],
      { 30: 1 }
    ],
    298: [
      [
        [[
            20,
            1
          ]],
        [
          [
            95,
            2
          ],
          [
            0,
            1
          ]
        ],
        [[
            20,
            3
          ]],
        [[
            0,
            3
          ]]
      ],
      { 20: 1 }
    ],
    299: [
      [
        [[
            120,
            1
          ]],
        [
          [
            45,
            2
          ],
          [
            0,
            1
          ]
        ],
        [
          [
            120,
            1
          ],
          [
            0,
            2
          ]
        ]
      ],
      { 20: 1 }
    ],
    300: [
      [
        [[
            29,
            1
          ]],
        [
          [
            91,
            2
          ],
          [
            97,
            3
          ]
        ],
        [[
            23,
            4
          ]],
        [
          [
            91,
            2
          ],
          [
            23,
            4
          ],
          [
            97,
            3
          ]
        ],
        [
          [
            121,
            5
          ],
          [
            41,
            5
          ],
          [
            28,
            6
          ]
        ],
        [[
            0,
            5
          ]],
        [[
            121,
            7
          ]],
        [[
            51,
            5
          ]]
      ],
      { 29: 1 }
    ],
    301: [
      [
        [[
            23,
            1
          ]],
        [[
            122,
            2
          ]],
        [[
            0,
            2
          ]]
      ],
      { 23: 1 }
    ],
    302: [
      [
        [
          [
            123,
            1
          ],
          [
            124,
            1
          ]
        ],
        [[
            0,
            1
          ]]
      ],
      {
        23: 1,
        29: 1
      }
    ],
    303: [
      [
        [[
            36,
            1
          ]],
        [
          [
            69,
            2
          ],
          [
            125,
            3
          ]
        ],
        [[
            44,
            4
          ]],
        [[
            69,
            2
          ]],
        [[
            0,
            4
          ]]
      ],
      { 36: 1 }
    ],
    304: [
      [
        [[
            27,
            1
          ]],
        [[
            94,
            2
          ]],
        [[
            75,
            3
          ]],
        [[
            126,
            4
          ]],
        [
          [
            127,
            5
          ],
          [
            0,
            4
          ]
        ],
        [[
            0,
            5
          ]]
      ],
      { 27: 1 }
    ],
    305: [
      [
        [[
            30,
            1
          ]],
        [[
            117,
            2
          ]],
        [
          [
            127,
            3
          ],
          [
            0,
            2
          ]
        ],
        [[
            0,
            3
          ]]
      ],
      { 30: 1 }
    ],
    306: [
      [
        [
          [
            128,
            1
          ],
          [
            129,
            1
          ]
        ],
        [[
            0,
            1
          ]]
      ],
      {
        27: 1,
        30: 1
      }
    ],
    307: [
      [
        [[
            44,
            1
          ]],
        [
          [
            128,
            2
          ],
          [
            45,
            3
          ],
          [
            0,
            1
          ]
        ],
        [[
            0,
            2
          ]],
        [
          [
            44,
            4
          ],
          [
            0,
            3
          ]
        ],
        [
          [
            45,
            3
          ],
          [
            0,
            4
          ]
        ]
      ],
      {
        6: 1,
        7: 1,
        8: 1,
        9: 1,
        11: 1,
        13: 1,
        17: 1,
        20: 1,
        24: 1,
        28: 1,
        35: 1,
        36: 1
      }
    ],
    308: [
      [
        [
          [
            7,
            1
          ],
          [
            130,
            2
          ]
        ],
        [[
            39,
            2
          ]],
        [[
            0,
            2
          ]]
      ],
      {
        6: 1,
        7: 1,
        8: 1,
        9: 1,
        11: 1,
        13: 1,
        17: 1,
        20: 1,
        24: 1,
        28: 1,
        35: 1
      }
    ],
    309: [
      [
        [[
            36,
            1
          ]],
        [
          [
            69,
            2
          ],
          [
            125,
            3
          ]
        ],
        [[
            117,
            4
          ]],
        [[
            69,
            2
          ]],
        [[
            0,
            4
          ]]
      ],
      { 36: 1 }
    ],
    310: [
      [
        [
          [
            131,
            1
          ],
          [
            115,
            1
          ]
        ],
        [[
            0,
            1
          ]]
      ],
      {
        6: 1,
        7: 1,
        8: 1,
        9: 1,
        11: 1,
        13: 1,
        17: 1,
        20: 1,
        24: 1,
        28: 1,
        35: 1,
        36: 1
      }
    ],
    311: [
      [
        [[
            132,
            1
          ]],
        [
          [
            133,
            0
          ],
          [
            0,
            1
          ]
        ]
      ],
      {
        6: 1,
        7: 1,
        8: 1,
        9: 1,
        11: 1,
        13: 1,
        17: 1,
        20: 1,
        24: 1,
        28: 1,
        35: 1
      }
    ],
    312: [
      [
        [[
            28,
            1
          ]],
        [
          [
            51,
            2
          ],
          [
            125,
            3
          ]
        ],
        [[
            0,
            2
          ]],
        [[
            51,
            2
          ]]
      ],
      { 28: 1 }
    ],
    313: [
      [
        [[
            22,
            1
          ]],
        [[
            0,
            1
          ]]
      ],
      { 22: 1 }
    ],
    314: [
      [
        [[
            134,
            1
          ]],
        [
          [
            135,
            1
          ],
          [
            43,
            2
          ],
          [
            0,
            1
          ]
        ],
        [[
            104,
            3
          ]],
        [[
            0,
            3
          ]]
      ],
      {
        8: 1,
        9: 1,
        11: 1,
        13: 1,
        17: 1,
        20: 1,
        28: 1
      }
    ],
    315: [
      [
        [[
            12,
            1
          ]],
        [
          [
            44,
            2
          ],
          [
            136,
            3
          ],
          [
            0,
            1
          ]
        ],
        [
          [
            45,
            4
          ],
          [
            0,
            2
          ]
        ],
        [[
            44,
            5
          ]],
        [
          [
            44,
            2
          ],
          [
            0,
            4
          ]
        ],
        [
          [
            45,
            6
          ],
          [
            0,
            5
          ]
        ],
        [[
            44,
            7
          ]],
        [
          [
            45,
            8
          ],
          [
            0,
            7
          ]
        ],
        [
          [
            44,
            7
          ],
          [
            0,
            8
          ]
        ]
      ],
      { 12: 1 }
    ],
    316: [
      [
        [[
            5,
            1
          ]],
        [
          [
            44,
            2
          ],
          [
            0,
            1
          ]
        ],
        [
          [
            45,
            3
          ],
          [
            0,
            2
          ]
        ],
        [[
            44,
            4
          ]],
        [
          [
            45,
            5
          ],
          [
            0,
            4
          ]
        ],
        [[
            44,
            6
          ]],
        [[
            0,
            6
          ]]
      ],
      { 5: 1 }
    ],
    317: [
      [
        [[
            18,
            1
          ]],
        [
          [
            71,
            2
          ],
          [
            0,
            1
          ]
        ],
        [[
            0,
            2
          ]]
      ],
      { 18: 1 }
    ],
    318: [
      [
        [[
            137,
            1
          ]],
        [
          [
            136,
            0
          ],
          [
            138,
            0
          ],
          [
            0,
            1
          ]
        ]
      ],
      {
        6: 1,
        8: 1,
        9: 1,
        11: 1,
        13: 1,
        17: 1,
        20: 1,
        24: 1,
        28: 1,
        35: 1
      }
    ],
    319: [
      [
        [[
            139,
            1
          ]],
        [
          [
            2,
            2
          ],
          [
            140,
            3
          ]
        ],
        [[
            0,
            2
          ]],
        [
          [
            139,
            1
          ],
          [
            2,
            2
          ]
        ]
      ],
      {
        5: 1,
        6: 1,
        7: 1,
        8: 1,
        9: 1,
        11: 1,
        12: 1,
        13: 1,
        15: 1,
        17: 1,
        18: 1,
        19: 1,
        20: 1,
        21: 1,
        22: 1,
        23: 1,
        24: 1,
        25: 1,
        26: 1,
        28: 1,
        29: 1,
        31: 1,
        32: 1,
        35: 1,
        36: 1
      }
    ],
    320: [
      [
        [[
            69,
            1
          ]],
        [
          [
            44,
            2
          ],
          [
            0,
            1
          ]
        ],
        [[
            0,
            2
          ]]
      ],
      { 69: 1 }
    ],
    321: [
      [
        [
          [
            141,
            1
          ],
          [
            142,
            1
          ],
          [
            143,
            1
          ],
          [
            144,
            1
          ],
          [
            145,
            1
          ],
          [
            146,
            1
          ],
          [
            147,
            1
          ],
          [
            148,
            1
          ],
          [
            149,
            1
          ]
        ],
        [[
            0,
            1
          ]]
      ],
      {
        5: 1,
        6: 1,
        7: 1,
        8: 1,
        9: 1,
        11: 1,
        12: 1,
        13: 1,
        15: 1,
        17: 1,
        18: 1,
        19: 1,
        20: 1,
        21: 1,
        22: 1,
        23: 1,
        24: 1,
        25: 1,
        26: 1,
        28: 1,
        29: 1,
        31: 1,
        32: 1,
        35: 1,
        36: 1
      }
    ],
    322: [
      [
        [
          [
            1,
            1
          ],
          [
            3,
            1
          ]
        ],
        [[
            0,
            1
          ]]
      ],
      {
        4: 1,
        5: 1,
        6: 1,
        7: 1,
        8: 1,
        9: 1,
        10: 1,
        11: 1,
        12: 1,
        13: 1,
        14: 1,
        15: 1,
        16: 1,
        17: 1,
        18: 1,
        19: 1,
        20: 1,
        21: 1,
        22: 1,
        23: 1,
        24: 1,
        25: 1,
        26: 1,
        27: 1,
        28: 1,
        29: 1,
        30: 1,
        31: 1,
        32: 1,
        33: 1,
        34: 1,
        35: 1,
        36: 1
      }
    ],
    323: [
      [
        [
          [
            44,
            1
          ],
          [
            69,
            2
          ],
          [
            97,
            3
          ]
        ],
        [
          [
            69,
            2
          ],
          [
            0,
            1
          ]
        ],
        [
          [
            44,
            4
          ],
          [
            150,
            5
          ],
          [
            0,
            2
          ]
        ],
        [[
            97,
            6
          ]],
        [
          [
            150,
            5
          ],
          [
            0,
            4
          ]
        ],
        [[
            0,
            5
          ]],
        [[
            97,
            5
          ]]
      ],
      {
        6: 1,
        7: 1,
        8: 1,
        9: 1,
        11: 1,
        13: 1,
        17: 1,
        20: 1,
        24: 1,
        28: 1,
        35: 1,
        36: 1,
        69: 1,
        97: 1
      }
    ],
    324: [
      [
        [[
            151,
            1
          ]],
        [
          [
            45,
            2
          ],
          [
            0,
            1
          ]
        ],
        [
          [
            151,
            1
          ],
          [
            0,
            2
          ]
        ]
      ],
      {
        6: 1,
        7: 1,
        8: 1,
        9: 1,
        11: 1,
        13: 1,
        17: 1,
        20: 1,
        24: 1,
        28: 1,
        35: 1,
        36: 1,
        69: 1,
        97: 1
      }
    ],
    325: [
      [
        [
          [
            1,
            1
          ],
          [
            2,
            2
          ]
        ],
        [[
            0,
            1
          ]],
        [[
            152,
            3
          ]],
        [[
            105,
            4
          ]],
        [
          [
            153,
            1
          ],
          [
            105,
            4
          ]
        ]
      ],
      {
        2: 1,
        5: 1,
        6: 1,
        7: 1,
        8: 1,
        9: 1,
        11: 1,
        12: 1,
        13: 1,
        15: 1,
        17: 1,
        18: 1,
        19: 1,
        20: 1,
        21: 1,
        22: 1,
        23: 1,
        24: 1,
        25: 1,
        26: 1,
        28: 1,
        29: 1,
        31: 1,
        32: 1,
        35: 1,
        36: 1
      }
    ],
    326: [
      [
        [[
            104,
            1
          ]],
        [
          [
            154,
            0
          ],
          [
            41,
            0
          ],
          [
            155,
            0
          ],
          [
            156,
            0
          ],
          [
            0,
            1
          ]
        ]
      ],
      {
        6: 1,
        8: 1,
        9: 1,
        11: 1,
        13: 1,
        17: 1,
        20: 1,
        24: 1,
        28: 1,
        35: 1
      }
    ],
    327: [
      [
        [
          [
            115,
            1
          ],
          [
            157,
            2
          ]
        ],
        [
          [
            30,
            3
          ],
          [
            0,
            1
          ]
        ],
        [[
            0,
            2
          ]],
        [[
            115,
            4
          ]],
        [[
            111,
            5
          ]],
        [[
            44,
            2
          ]]
      ],
      {
        6: 1,
        7: 1,
        8: 1,
        9: 1,
        11: 1,
        13: 1,
        17: 1,
        20: 1,
        24: 1,
        28: 1,
        35: 1,
        36: 1
      }
    ],
    328: [
      [
        [[
            44,
            1
          ]],
        [
          [
            45,
            2
          ],
          [
            0,
            1
          ]
        ],
        [
          [
            44,
            1
          ],
          [
            0,
            2
          ]
        ]
      ],
      {
        6: 1,
        7: 1,
        8: 1,
        9: 1,
        11: 1,
        13: 1,
        17: 1,
        20: 1,
        24: 1,
        28: 1,
        35: 1,
        36: 1
      }
    ],
    329: [
      [
        [[
            44,
            1
          ]],
        [
          [
            45,
            0
          ],
          [
            0,
            1
          ]
        ]
      ],
      {
        6: 1,
        7: 1,
        8: 1,
        9: 1,
        11: 1,
        13: 1,
        17: 1,
        20: 1,
        24: 1,
        28: 1,
        35: 1,
        36: 1
      }
    ],
    330: [
      [
        [[
            44,
            1
          ]],
        [
          [
            46,
            2
          ],
          [
            45,
            3
          ],
          [
            0,
            1
          ]
        ],
        [[
            0,
            2
          ]],
        [
          [
            44,
            4
          ],
          [
            0,
            3
          ]
        ],
        [
          [
            45,
            3
          ],
          [
            0,
            4
          ]
        ]
      ],
      {
        6: 1,
        7: 1,
        8: 1,
        9: 1,
        11: 1,
        13: 1,
        17: 1,
        20: 1,
        24: 1,
        28: 1,
        35: 1,
        36: 1
      }
    ],
    331: [
      [
        [[
            117,
            1
          ]],
        [
          [
            45,
            2
          ],
          [
            0,
            1
          ]
        ],
        [[
            117,
            3
          ]],
        [
          [
            45,
            4
          ],
          [
            0,
            3
          ]
        ],
        [
          [
            117,
            3
          ],
          [
            0,
            4
          ]
        ]
      ],
      {
        6: 1,
        7: 1,
        8: 1,
        9: 1,
        11: 1,
        13: 1,
        17: 1,
        20: 1,
        24: 1,
        28: 1,
        35: 1,
        36: 1
      }
    ],
    332: [
      [
        [
          [
            28,
            1
          ],
          [
            97,
            2
          ],
          [
            11,
            3
          ]
        ],
        [
          [
            51,
            4
          ],
          [
            92,
            5
          ]
        ],
        [[
            20,
            4
          ]],
        [[
            158,
            6
          ]],
        [[
            0,
            4
          ]],
        [[
            51,
            4
          ]],
        [[
            50,
            4
          ]]
      ],
      {
        11: 1,
        28: 1,
        97: 1
      }
    ],
    333: [
      [
        [[
            14,
            1
          ]],
        [[
            69,
            2
          ]],
        [[
            70,
            3
          ]],
        [
          [
            159,
            4
          ],
          [
            160,
            5
          ]
        ],
        [[
            69,
            6
          ]],
        [[
            69,
            7
          ]],
        [[
            70,
            8
          ]],
        [[
            70,
            9
          ]],
        [
          [
            159,
            4
          ],
          [
            111,
            10
          ],
          [
            160,
            5
          ],
          [
            0,
            8
          ]
        ],
        [[
            0,
            9
          ]],
        [[
            69,
            11
          ]],
        [[
            70,
            12
          ]],
        [
          [
            160,
            5
          ],
          [
            0,
            12
          ]
        ]
      ],
      { 14: 1 }
    ],
    334: [
      [
        [
          [
            41,
            1
          ],
          [
            113,
            2
          ],
          [
            43,
            3
          ]
        ],
        [[
            20,
            4
          ]],
        [
          [
            47,
            5
          ],
          [
            45,
            6
          ],
          [
            0,
            2
          ]
        ],
        [[
            20,
            7
          ]],
        [
          [
            45,
            8
          ],
          [
            0,
            4
          ]
        ],
        [[
            44,
            9
          ]],
        [
          [
            41,
            1
          ],
          [
            113,
            2
          ],
          [
            43,
            3
          ],
          [
            0,
            6
          ]
        ],
        [[
            0,
            7
          ]],
        [[
            43,
            3
          ]],
        [
          [
            45,
            6
          ],
          [
            0,
            9
          ]
        ]
      ],
      {
        20: 1,
        28: 1,
        41: 1,
        43: 1
      }
    ],
    335: [
      [
        [[
            16,
            1
          ]],
        [[
            44,
            2
          ]],
        [[
            69,
            3
          ]],
        [[
            70,
            4
          ]],
        [
          [
            111,
            5
          ],
          [
            0,
            4
          ]
        ],
        [[
            69,
            6
          ]],
        [[
            70,
            7
          ]],
        [[
            0,
            7
          ]]
      ],
      { 16: 1 }
    ],
    336: [
      [
        [[
            34,
            1
          ]],
        [[
            44,
            2
          ]],
        [
          [
            69,
            3
          ],
          [
            161,
            4
          ]
        ],
        [[
            70,
            5
          ]],
        [[
            69,
            3
          ]],
        [[
            0,
            5
          ]]
      ],
      { 34: 1 }
    ],
    337: [
      [
        [[
            95,
            1
          ]],
        [[
            80,
            2
          ]],
        [[
            0,
            2
          ]]
      ],
      { 95: 1 }
    ],
    338: [
      [
        [[
            162,
            1
          ]],
        [
          [
            163,
            0
          ],
          [
            0,
            1
          ]
        ]
      ],
      {
        6: 1,
        8: 1,
        9: 1,
        11: 1,
        13: 1,
        17: 1,
        20: 1,
        24: 1,
        28: 1,
        35: 1
      }
    ],
    339: [
      [
        [[
            25,
            1
          ]],
        [
          [
            71,
            2
          ],
          [
            0,
            1
          ]
        ],
        [[
            0,
            2
          ]]
      ],
      { 25: 1 }
    ],
    340: [
      [
        [[
            53,
            1
          ]],
        [[
            0,
            1
          ]]
      ],
      { 25: 1 }
    ]
  },
  states: [
    [
      [
        [
          1,
          1
        ],
        [
          2,
          1
        ],
        [
          3,
          2
        ]
      ],
      [[
          0,
          1
        ]],
      [[
          2,
          1
        ]]
    ],
    [
      [[
          37,
          1
        ]],
      [
        [
          38,
          0
        ],
        [
          0,
          1
        ]
      ]
    ],
    [
      [[
          39,
          1
        ]],
      [
        [
          40,
          0
        ],
        [
          0,
          1
        ]
      ]
    ],
    [
      [
        [
          41,
          1
        ],
        [
          42,
          2
        ],
        [
          43,
          3
        ]
      ],
      [[
          44,
          4
        ]],
      [
        [
          45,
          5
        ],
        [
          0,
          2
        ]
      ],
      [[
          44,
          6
        ]],
      [
        [
          45,
          7
        ],
        [
          0,
          4
        ]
      ],
      [
        [
          41,
          1
        ],
        [
          42,
          2
        ],
        [
          43,
          3
        ],
        [
          0,
          5
        ]
      ],
      [[
          0,
          6
        ]],
      [
        [
          42,
          4
        ],
        [
          43,
          3
        ]
      ]
    ],
    [
      [[
          44,
          1
        ]],
      [
        [
          46,
          2
        ],
        [
          47,
          3
        ],
        [
          0,
          1
        ]
      ],
      [[
          0,
          2
        ]],
      [[
          44,
          2
        ]]
    ],
    [
      [[
          48,
          1
        ]],
      [
        [
          24,
          0
        ],
        [
          35,
          0
        ],
        [
          0,
          1
        ]
      ]
    ],
    [
      [[
          19,
          1
        ]],
      [[
          44,
          2
        ]],
      [
        [
          45,
          3
        ],
        [
          0,
          2
        ]
      ],
      [[
          44,
          4
        ]],
      [[
          0,
          4
        ]]
    ],
    [
      [
        [
          17,
          1
        ],
        [
          8,
          2
        ],
        [
          9,
          5
        ],
        [
          28,
          4
        ],
        [
          11,
          3
        ],
        [
          13,
          6
        ],
        [
          20,
          2
        ]
      ],
      [
        [
          17,
          1
        ],
        [
          0,
          1
        ]
      ],
      [[
          0,
          2
        ]],
      [
        [
          49,
          7
        ],
        [
          50,
          2
        ]
      ],
      [
        [
          51,
          2
        ],
        [
          52,
          8
        ],
        [
          53,
          8
        ]
      ],
      [
        [
          54,
          9
        ],
        [
          55,
          2
        ]
      ],
      [[
          56,
          10
        ]],
      [[
          50,
          2
        ]],
      [[
          51,
          2
        ]],
      [[
          55,
          2
        ]],
      [[
          13,
          2
        ]]
    ],
    [
      [
        [
          57,
          1
        ],
        [
          58,
          1
        ],
        [
          59,
          1
        ],
        [
          60,
          1
        ],
        [
          61,
          1
        ],
        [
          62,
          1
        ],
        [
          63,
          1
        ],
        [
          64,
          1
        ],
        [
          65,
          1
        ],
        [
          66,
          1
        ],
        [
          67,
          1
        ],
        [
          68,
          1
        ]
      ],
      [[
          0,
          1
        ]]
    ],
    [
      [[
          31,
          1
        ]],
      [[
          0,
          1
        ]]
    ],
    [
      [[
          10,
          1
        ]],
      [[
          20,
          2
        ]],
      [
        [
          69,
          3
        ],
        [
          28,
          4
        ]
      ],
      [[
          70,
          5
        ]],
      [
        [
          51,
          6
        ],
        [
          71,
          7
        ]
      ],
      [[
          0,
          5
        ]],
      [[
          69,
          3
        ]],
      [[
          51,
          6
        ]]
    ],
    [
      [
        [
          72,
          1
        ],
        [
          73,
          1
        ],
        [
          7,
          2
        ],
        [
          74,
          1
        ],
        [
          72,
          1
        ],
        [
          75,
          1
        ],
        [
          76,
          1
        ],
        [
          77,
          3
        ],
        [
          78,
          1
        ],
        [
          79,
          1
        ]
      ],
      [[
          0,
          1
        ]],
      [[
          75,
          1
        ]],
      [
        [
          7,
          1
        ],
        [
          0,
          3
        ]
      ]
    ],
    [
      [[
          80,
          1
        ]],
      [
        [
          81,
          0
        ],
        [
          0,
          1
        ]
      ]
    ],
    [
      [
        [
          82,
          1
        ],
        [
          83,
          1
        ],
        [
          84,
          1
        ],
        [
          85,
          1
        ],
        [
          86,
          1
        ],
        [
          87,
          1
        ],
        [
          88,
          1
        ],
        [
          89,
          1
        ]
      ],
      [[
          0,
          1
        ]]
    ],
    [
      [[
          32,
          1
        ]],
      [[
          0,
          1
        ]]
    ],
    [
      [[
          90,
          1
        ]],
      [
        [
          88,
          2
        ],
        [
          85,
          2
        ]
      ],
      [[
          0,
          2
        ]]
    ],
    [
      [[
          33,
          1
        ]],
      [[
          91,
          2
        ]],
      [
        [
          28,
          4
        ],
        [
          2,
          3
        ]
      ],
      [[
          0,
          3
        ]],
      [
        [
          51,
          5
        ],
        [
          92,
          6
        ]
      ],
      [[
          2,
          3
        ]],
      [[
          51,
          5
        ]]
    ],
    [
      [[
          93,
          1
        ]],
      [
        [
          93,
          1
        ],
        [
          0,
          1
        ]
      ]
    ],
    [
      [[
          21,
          1
        ]],
      [[
          94,
          2
        ]],
      [[
          0,
          2
        ]]
    ],
    [
      [[
          44,
          1
        ]],
      [[
          69,
          2
        ]],
      [[
          44,
          3
        ]],
      [
        [
          45,
          4
        ],
        [
          0,
          3
        ]
      ],
      [
        [
          44,
          1
        ],
        [
          0,
          4
        ]
      ]
    ],
    [
      [[
          91,
          1
        ]],
      [
        [
          95,
          2
        ],
        [
          0,
          1
        ]
      ],
      [[
          20,
          3
        ]],
      [[
          0,
          3
        ]]
    ],
    [
      [[
          96,
          1
        ]],
      [
        [
          45,
          0
        ],
        [
          0,
          1
        ]
      ]
    ],
    [
      [[
          20,
          1
        ]],
      [
        [
          97,
          0
        ],
        [
          0,
          1
        ]
      ]
    ],
    [
      [[
          20,
          1
        ]],
      [[
          0,
          1
        ]]
    ],
    [
      [[
          71,
          1
        ]],
      [
        [
          2,
          1
        ],
        [
          98,
          2
        ]
      ],
      [[
          0,
          2
        ]]
    ],
    [
      [[
          99,
          1
        ]],
      [
        [
          44,
          2
        ],
        [
          0,
          1
        ]
      ],
      [
        [
          95,
          3
        ],
        [
          45,
          3
        ],
        [
          0,
          2
        ]
      ],
      [[
          44,
          4
        ]],
      [[
          0,
          4
        ]]
    ],
    [
      [[
          15,
          1
        ]],
      [[
          80,
          2
        ]],
      [
        [
          75,
          3
        ],
        [
          0,
          2
        ]
      ],
      [[
          44,
          4
        ]],
      [
        [
          45,
          5
        ],
        [
          0,
          4
        ]
      ],
      [[
          44,
          6
        ]],
      [[
          0,
          6
        ]]
    ],
    [
      [[
          100,
          1
        ]],
      [
        [
          101,
          0
        ],
        [
          0,
          1
        ]
      ]
    ],
    [
      [[
          71,
          1
        ]],
      [
        [
          102,
          2
        ],
        [
          47,
          3
        ],
        [
          0,
          1
        ]
      ],
      [
        [
          71,
          4
        ],
        [
          53,
          4
        ]
      ],
      [
        [
          71,
          5
        ],
        [
          53,
          5
        ]
      ],
      [[
          0,
          4
        ]],
      [
        [
          47,
          3
        ],
        [
          0,
          5
        ]
      ]
    ],
    [
      [[
          80,
          1
        ]],
      [
        [
          45,
          2
        ],
        [
          0,
          1
        ]
      ],
      [
        [
          80,
          1
        ],
        [
          0,
          2
        ]
      ]
    ],
    [
      [
        [
          103,
          2
        ],
        [
          24,
          1
        ],
        [
          6,
          1
        ],
        [
          35,
          1
        ]
      ],
      [[
          104,
          2
        ]],
      [[
          0,
          2
        ]]
    ],
    [
      [
        [
          2,
          0
        ],
        [
          98,
          1
        ],
        [
          105,
          0
        ]
      ],
      [[
          0,
          1
        ]]
    ],
    [
      [
        [
          106,
          1
        ],
        [
          107,
          1
        ],
        [
          108,
          1
        ],
        [
          109,
          1
        ],
        [
          110,
          1
        ]
      ],
      [[
          0,
          1
        ]]
    ],
    [
      [[
          27,
          1
        ]],
      [[
          94,
          2
        ]],
      [[
          75,
          3
        ]],
      [[
          71,
          4
        ]],
      [[
          69,
          5
        ]],
      [[
          70,
          6
        ]],
      [
        [
          111,
          7
        ],
        [
          0,
          6
        ]
      ],
      [[
          69,
          8
        ]],
      [[
          70,
          9
        ]],
      [[
          0,
          9
        ]]
    ],
    [
      [
        [
          28,
          1
        ],
        [
          20,
          2
        ]
      ],
      [[
          112,
          3
        ]],
      [[
          0,
          2
        ]],
      [[
          51,
          2
        ]]
    ],
    [
      [[
          113,
          1
        ]],
      [
        [
          45,
          2
        ],
        [
          0,
          1
        ]
      ],
      [
        [
          113,
          1
        ],
        [
          0,
          2
        ]
      ]
    ],
    [
      [[
          4,
          1
        ]],
      [[
          20,
          2
        ]],
      [[
          114,
          3
        ]],
      [[
          69,
          4
        ]],
      [[
          70,
          5
        ]],
      [[
          0,
          5
        ]]
    ],
    [
      [[
          27,
          1
        ]],
      [[
          94,
          2
        ]],
      [[
          75,
          3
        ]],
      [[
          115,
          4
        ]],
      [
        [
          116,
          5
        ],
        [
          0,
          4
        ]
      ],
      [[
          0,
          5
        ]]
    ],
    [
      [[
          30,
          1
        ]],
      [[
          117,
          2
        ]],
      [
        [
          116,
          3
        ],
        [
          0,
          2
        ]
      ],
      [[
          0,
          3
        ]]
    ],
    [
      [
        [
          46,
          1
        ],
        [
          118,
          1
        ]
      ],
      [[
          0,
          1
        ]]
    ],
    [
      [[
          26,
          1
        ]],
      [[
          20,
          2
        ]],
      [
        [
          45,
          1
        ],
        [
          0,
          2
        ]
      ]
    ],
    [
      [[
          30,
          1
        ]],
      [[
          44,
          2
        ]],
      [[
          69,
          3
        ]],
      [[
          70,
          4
        ]],
      [
        [
          111,
          5
        ],
        [
          119,
          1
        ],
        [
          0,
          4
        ]
      ],
      [[
          69,
          6
        ]],
      [[
          70,
          7
        ]],
      [[
          0,
          7
        ]]
    ],
    [
      [[
          20,
          1
        ]],
      [
        [
          95,
          2
        ],
        [
          0,
          1
        ]
      ],
      [[
          20,
          3
        ]],
      [[
          0,
          3
        ]]
    ],
    [
      [[
          120,
          1
        ]],
      [
        [
          45,
          2
        ],
        [
          0,
          1
        ]
      ],
      [
        [
          120,
          1
        ],
        [
          0,
          2
        ]
      ]
    ],
    [
      [[
          29,
          1
        ]],
      [
        [
          91,
          2
        ],
        [
          97,
          3
        ]
      ],
      [[
          23,
          4
        ]],
      [
        [
          91,
          2
        ],
        [
          23,
          4
        ],
        [
          97,
          3
        ]
      ],
      [
        [
          121,
          5
        ],
        [
          41,
          5
        ],
        [
          28,
          6
        ]
      ],
      [[
          0,
          5
        ]],
      [[
          121,
          7
        ]],
      [[
          51,
          5
        ]]
    ],
    [
      [[
          23,
          1
        ]],
      [[
          122,
          2
        ]],
      [[
          0,
          2
        ]]
    ],
    [
      [
        [
          123,
          1
        ],
        [
          124,
          1
        ]
      ],
      [[
          0,
          1
        ]]
    ],
    [
      [[
          36,
          1
        ]],
      [
        [
          69,
          2
        ],
        [
          125,
          3
        ]
      ],
      [[
          44,
          4
        ]],
      [[
          69,
          2
        ]],
      [[
          0,
          4
        ]]
    ],
    [
      [[
          27,
          1
        ]],
      [[
          94,
          2
        ]],
      [[
          75,
          3
        ]],
      [[
          126,
          4
        ]],
      [
        [
          127,
          5
        ],
        [
          0,
          4
        ]
      ],
      [[
          0,
          5
        ]]
    ],
    [
      [[
          30,
          1
        ]],
      [[
          117,
          2
        ]],
      [
        [
          127,
          3
        ],
        [
          0,
          2
        ]
      ],
      [[
          0,
          3
        ]]
    ],
    [
      [
        [
          128,
          1
        ],
        [
          129,
          1
        ]
      ],
      [[
          0,
          1
        ]]
    ],
    [
      [[
          44,
          1
        ]],
      [
        [
          128,
          2
        ],
        [
          45,
          3
        ],
        [
          0,
          1
        ]
      ],
      [[
          0,
          2
        ]],
      [
        [
          44,
          4
        ],
        [
          0,
          3
        ]
      ],
      [
        [
          45,
          3
        ],
        [
          0,
          4
        ]
      ]
    ],
    [
      [
        [
          7,
          1
        ],
        [
          130,
          2
        ]
      ],
      [[
          39,
          2
        ]],
      [[
          0,
          2
        ]]
    ],
    [
      [[
          36,
          1
        ]],
      [
        [
          69,
          2
        ],
        [
          125,
          3
        ]
      ],
      [[
          117,
          4
        ]],
      [[
          69,
          2
        ]],
      [[
          0,
          4
        ]]
    ],
    [
      [
        [
          131,
          1
        ],
        [
          115,
          1
        ]
      ],
      [[
          0,
          1
        ]]
    ],
    [
      [[
          132,
          1
        ]],
      [
        [
          133,
          0
        ],
        [
          0,
          1
        ]
      ]
    ],
    [
      [[
          28,
          1
        ]],
      [
        [
          51,
          2
        ],
        [
          125,
          3
        ]
      ],
      [[
          0,
          2
        ]],
      [[
          51,
          2
        ]]
    ],
    [
      [[
          22,
          1
        ]],
      [[
          0,
          1
        ]]
    ],
    [
      [[
          134,
          1
        ]],
      [
        [
          135,
          1
        ],
        [
          43,
          2
        ],
        [
          0,
          1
        ]
      ],
      [[
          104,
          3
        ]],
      [[
          0,
          3
        ]]
    ],
    [
      [[
          12,
          1
        ]],
      [
        [
          44,
          2
        ],
        [
          136,
          3
        ],
        [
          0,
          1
        ]
      ],
      [
        [
          45,
          4
        ],
        [
          0,
          2
        ]
      ],
      [[
          44,
          5
        ]],
      [
        [
          44,
          2
        ],
        [
          0,
          4
        ]
      ],
      [
        [
          45,
          6
        ],
        [
          0,
          5
        ]
      ],
      [[
          44,
          7
        ]],
      [
        [
          45,
          8
        ],
        [
          0,
          7
        ]
      ],
      [
        [
          44,
          7
        ],
        [
          0,
          8
        ]
      ]
    ],
    [
      [[
          5,
          1
        ]],
      [
        [
          44,
          2
        ],
        [
          0,
          1
        ]
      ],
      [
        [
          45,
          3
        ],
        [
          0,
          2
        ]
      ],
      [[
          44,
          4
        ]],
      [
        [
          45,
          5
        ],
        [
          0,
          4
        ]
      ],
      [[
          44,
          6
        ]],
      [[
          0,
          6
        ]]
    ],
    [
      [[
          18,
          1
        ]],
      [
        [
          71,
          2
        ],
        [
          0,
          1
        ]
      ],
      [[
          0,
          2
        ]]
    ],
    [
      [[
          137,
          1
        ]],
      [
        [
          136,
          0
        ],
        [
          138,
          0
        ],
        [
          0,
          1
        ]
      ]
    ],
    [
      [[
          139,
          1
        ]],
      [
        [
          2,
          2
        ],
        [
          140,
          3
        ]
      ],
      [[
          0,
          2
        ]],
      [
        [
          139,
          1
        ],
        [
          2,
          2
        ]
      ]
    ],
    [
      [[
          69,
          1
        ]],
      [
        [
          44,
          2
        ],
        [
          0,
          1
        ]
      ],
      [[
          0,
          2
        ]]
    ],
    [
      [
        [
          141,
          1
        ],
        [
          142,
          1
        ],
        [
          143,
          1
        ],
        [
          144,
          1
        ],
        [
          145,
          1
        ],
        [
          146,
          1
        ],
        [
          147,
          1
        ],
        [
          148,
          1
        ],
        [
          149,
          1
        ]
      ],
      [[
          0,
          1
        ]]
    ],
    [
      [
        [
          1,
          1
        ],
        [
          3,
          1
        ]
      ],
      [[
          0,
          1
        ]]
    ],
    [
      [
        [
          44,
          1
        ],
        [
          69,
          2
        ],
        [
          97,
          3
        ]
      ],
      [
        [
          69,
          2
        ],
        [
          0,
          1
        ]
      ],
      [
        [
          44,
          4
        ],
        [
          150,
          5
        ],
        [
          0,
          2
        ]
      ],
      [[
          97,
          6
        ]],
      [
        [
          150,
          5
        ],
        [
          0,
          4
        ]
      ],
      [[
          0,
          5
        ]],
      [[
          97,
          5
        ]]
    ],
    [
      [[
          151,
          1
        ]],
      [
        [
          45,
          2
        ],
        [
          0,
          1
        ]
      ],
      [
        [
          151,
          1
        ],
        [
          0,
          2
        ]
      ]
    ],
    [
      [
        [
          1,
          1
        ],
        [
          2,
          2
        ]
      ],
      [[
          0,
          1
        ]],
      [[
          152,
          3
        ]],
      [[
          105,
          4
        ]],
      [
        [
          153,
          1
        ],
        [
          105,
          4
        ]
      ]
    ],
    [
      [[
          104,
          1
        ]],
      [
        [
          154,
          0
        ],
        [
          41,
          0
        ],
        [
          155,
          0
        ],
        [
          156,
          0
        ],
        [
          0,
          1
        ]
      ]
    ],
    [
      [
        [
          115,
          1
        ],
        [
          157,
          2
        ]
      ],
      [
        [
          30,
          3
        ],
        [
          0,
          1
        ]
      ],
      [[
          0,
          2
        ]],
      [[
          115,
          4
        ]],
      [[
          111,
          5
        ]],
      [[
          44,
          2
        ]]
    ],
    [
      [[
          44,
          1
        ]],
      [
        [
          45,
          2
        ],
        [
          0,
          1
        ]
      ],
      [
        [
          44,
          1
        ],
        [
          0,
          2
        ]
      ]
    ],
    [
      [[
          44,
          1
        ]],
      [
        [
          45,
          0
        ],
        [
          0,
          1
        ]
      ]
    ],
    [
      [[
          44,
          1
        ]],
      [
        [
          46,
          2
        ],
        [
          45,
          3
        ],
        [
          0,
          1
        ]
      ],
      [[
          0,
          2
        ]],
      [
        [
          44,
          4
        ],
        [
          0,
          3
        ]
      ],
      [
        [
          45,
          3
        ],
        [
          0,
          4
        ]
      ]
    ],
    [
      [[
          117,
          1
        ]],
      [
        [
          45,
          2
        ],
        [
          0,
          1
        ]
      ],
      [[
          117,
          3
        ]],
      [
        [
          45,
          4
        ],
        [
          0,
          3
        ]
      ],
      [
        [
          117,
          3
        ],
        [
          0,
          4
        ]
      ]
    ],
    [
      [
        [
          28,
          1
        ],
        [
          97,
          2
        ],
        [
          11,
          3
        ]
      ],
      [
        [
          51,
          4
        ],
        [
          92,
          5
        ]
      ],
      [[
          20,
          4
        ]],
      [[
          158,
          6
        ]],
      [[
          0,
          4
        ]],
      [[
          51,
          4
        ]],
      [[
          50,
          4
        ]]
    ],
    [
      [[
          14,
          1
        ]],
      [[
          69,
          2
        ]],
      [[
          70,
          3
        ]],
      [
        [
          159,
          4
        ],
        [
          160,
          5
        ]
      ],
      [[
          69,
          6
        ]],
      [[
          69,
          7
        ]],
      [[
          70,
          8
        ]],
      [[
          70,
          9
        ]],
      [
        [
          159,
          4
        ],
        [
          111,
          10
        ],
        [
          160,
          5
        ],
        [
          0,
          8
        ]
      ],
      [[
          0,
          9
        ]],
      [[
          69,
          11
        ]],
      [[
          70,
          12
        ]],
      [
        [
          160,
          5
        ],
        [
          0,
          12
        ]
      ]
    ],
    [
      [
        [
          41,
          1
        ],
        [
          113,
          2
        ],
        [
          43,
          3
        ]
      ],
      [[
          20,
          4
        ]],
      [
        [
          47,
          5
        ],
        [
          45,
          6
        ],
        [
          0,
          2
        ]
      ],
      [[
          20,
          7
        ]],
      [
        [
          45,
          8
        ],
        [
          0,
          4
        ]
      ],
      [[
          44,
          9
        ]],
      [
        [
          41,
          1
        ],
        [
          113,
          2
        ],
        [
          43,
          3
        ],
        [
          0,
          6
        ]
      ],
      [[
          0,
          7
        ]],
      [[
          43,
          3
        ]],
      [
        [
          45,
          6
        ],
        [
          0,
          9
        ]
      ]
    ],
    [
      [[
          16,
          1
        ]],
      [[
          44,
          2
        ]],
      [[
          69,
          3
        ]],
      [[
          70,
          4
        ]],
      [
        [
          111,
          5
        ],
        [
          0,
          4
        ]
      ],
      [[
          69,
          6
        ]],
      [[
          70,
          7
        ]],
      [[
          0,
          7
        ]]
    ],
    [
      [[
          34,
          1
        ]],
      [[
          44,
          2
        ]],
      [
        [
          69,
          3
        ],
        [
          161,
          4
        ]
      ],
      [[
          70,
          5
        ]],
      [[
          69,
          3
        ]],
      [[
          0,
          5
        ]]
    ],
    [
      [[
          95,
          1
        ]],
      [[
          80,
          2
        ]],
      [[
          0,
          2
        ]]
    ],
    [
      [[
          162,
          1
        ]],
      [
        [
          163,
          0
        ],
        [
          0,
          1
        ]
      ]
    ],
    [
      [[
          25,
          1
        ]],
      [
        [
          71,
          2
        ],
        [
          0,
          1
        ]
      ],
      [[
          0,
          2
        ]]
    ],
    [
      [[
          53,
          1
        ]],
      [[
          0,
          1
        ]]
    ]
  ],
  labels: [
    [
      0,
      'EMPTY'
    ],
    [
      319,
      null
    ],
    [
      4,
      null
    ],
    [
      269,
      null
    ],
    [
      1,
      'def'
    ],
    [
      1,
      'raise'
    ],
    [
      32,
      null
    ],
    [
      1,
      'not'
    ],
    [
      2,
      null
    ],
    [
      26,
      null
    ],
    [
      1,
      'class'
    ],
    [
      9,
      null
    ],
    [
      1,
      'print'
    ],
    [
      25,
      null
    ],
    [
      1,
      'try'
    ],
    [
      1,
      'exec'
    ],
    [
      1,
      'while'
    ],
    [
      3,
      null
    ],
    [
      1,
      'return'
    ],
    [
      1,
      'assert'
    ],
    [
      1,
      null
    ],
    [
      1,
      'del'
    ],
    [
      1,
      'pass'
    ],
    [
      1,
      'import'
    ],
    [
      15,
      null
    ],
    [
      1,
      'yield'
    ],
    [
      1,
      'global'
    ],
    [
      1,
      'for'
    ],
    [
      7,
      null
    ],
    [
      1,
      'from'
    ],
    [
      1,
      'if'
    ],
    [
      1,
      'break'
    ],
    [
      1,
      'continue'
    ],
    [
      50,
      null
    ],
    [
      1,
      'with'
    ],
    [
      14,
      null
    ],
    [
      1,
      'lambda'
    ],
    [
      318,
      null
    ],
    [
      19,
      null
    ],
    [
      308,
      null
    ],
    [
      1,
      'and'
    ],
    [
      16,
      null
    ],
    [
      260,
      null
    ],
    [
      36,
      null
    ],
    [
      327,
      null
    ],
    [
      12,
      null
    ],
    [
      293,
      null
    ],
    [
      22,
      null
    ],
    [
      326,
      null
    ],
    [
      307,
      null
    ],
    [
      10,
      null
    ],
    [
      8,
      null
    ],
    [
      330,
      null
    ],
    [
      339,
      null
    ],
    [
      275,
      null
    ],
    [
      27,
      null
    ],
    [
      329,
      null
    ],
    [
      46,
      null
    ],
    [
      39,
      null
    ],
    [
      41,
      null
    ],
    [
      47,
      null
    ],
    [
      42,
      null
    ],
    [
      43,
      null
    ],
    [
      37,
      null
    ],
    [
      44,
      null
    ],
    [
      49,
      null
    ],
    [
      40,
      null
    ],
    [
      38,
      null
    ],
    [
      45,
      null
    ],
    [
      11,
      null
    ],
    [
      325,
      null
    ],
    [
      328,
      null
    ],
    [
      29,
      null
    ],
    [
      21,
      null
    ],
    [
      28,
      null
    ],
    [
      1,
      'in'
    ],
    [
      30,
      null
    ],
    [
      1,
      'is'
    ],
    [
      31,
      null
    ],
    [
      20,
      null
    ],
    [
      283,
      null
    ],
    [
      267,
      null
    ],
    [
      333,
      null
    ],
    [
      297,
      null
    ],
    [
      289,
      null
    ],
    [
      266,
      null
    ],
    [
      336,
      null
    ],
    [
      335,
      null
    ],
    [
      292,
      null
    ],
    [
      271,
      null
    ],
    [
      273,
      null
    ],
    [
      278,
      null
    ],
    [
      259,
      null
    ],
    [
      272,
      null
    ],
    [
      285,
      null
    ],
    [
      1,
      'as'
    ],
    [
      276,
      null
    ],
    [
      23,
      null
    ],
    [
      0,
      null
    ],
    [
      1,
      'except'
    ],
    [
      338,
      null
    ],
    [
      18,
      null
    ],
    [
      264,
      null
    ],
    [
      314,
      null
    ],
    [
      286,
      null
    ],
    [
      322,
      null
    ],
    [
      265,
      null
    ],
    [
      270,
      null
    ],
    [
      316,
      null
    ],
    [
      317,
      null
    ],
    [
      340,
      null
    ],
    [
      1,
      'else'
    ],
    [
      291,
      null
    ],
    [
      290,
      null
    ],
    [
      312,
      null
    ],
    [
      311,
      null
    ],
    [
      295,
      null
    ],
    [
      310,
      null
    ],
    [
      294,
      null
    ],
    [
      1,
      'elif'
    ],
    [
      298,
      null
    ],
    [
      299,
      null
    ],
    [
      277,
      null
    ],
    [
      301,
      null
    ],
    [
      300,
      null
    ],
    [
      334,
      null
    ],
    [
      331,
      null
    ],
    [
      306,
      null
    ],
    [
      304,
      null
    ],
    [
      305,
      null
    ],
    [
      268,
      null
    ],
    [
      309,
      null
    ],
    [
      258,
      null
    ],
    [
      1,
      'or'
    ],
    [
      263,
      null
    ],
    [
      332,
      null
    ],
    [
      35,
      null
    ],
    [
      261,
      null
    ],
    [
      34,
      null
    ],
    [
      321,
      null
    ],
    [
      13,
      null
    ],
    [
      288,
      null
    ],
    [
      262,
      null
    ],
    [
      284,
      null
    ],
    [
      313,
      null
    ],
    [
      315,
      null
    ],
    [
      274,
      null
    ],
    [
      282,
      null
    ],
    [
      296,
      null
    ],
    [
      302,
      null
    ],
    [
      320,
      null
    ],
    [
      323,
      null
    ],
    [
      5,
      null
    ],
    [
      6,
      null
    ],
    [
      48,
      null
    ],
    [
      17,
      null
    ],
    [
      24,
      null
    ],
    [
      303,
      null
    ],
    [
      324,
      null
    ],
    [
      281,
      null
    ],
    [
      1,
      'finally'
    ],
    [
      337,
      null
    ],
    [
      257,
      null
    ],
    [
      33,
      null
    ]
  ],
  keywords: {
    'and': 40,
    'as': 95,
    'assert': 19,
    'break': 31,
    'class': 10,
    'continue': 32,
    'def': 4,
    'del': 21,
    'elif': 119,
    'else': 111,
    'except': 99,
    'exec': 15,
    'finally': 160,
    'for': 27,
    'from': 29,
    'global': 26,
    'if': 30,
    'import': 23,
    'in': 75,
    'is': 77,
    'lambda': 36,
    'not': 7,
    'or': 133,
    'pass': 22,
    'print': 12,
    'raise': 5,
    'return': 18,
    'try': 14,
    'while': 16,
    'with': 34,
    'yield': 25
  },
  tokens: {
    0: 98,
    1: 20,
    2: 8,
    3: 17,
    4: 2,
    5: 152,
    6: 153,
    7: 28,
    8: 51,
    9: 11,
    10: 50,
    11: 69,
    12: 45,
    13: 140,
    14: 35,
    15: 24,
    16: 41,
    17: 155,
    18: 101,
    19: 38,
    20: 79,
    21: 73,
    22: 47,
    23: 97,
    24: 156,
    25: 13,
    26: 9,
    27: 55,
    28: 74,
    29: 72,
    30: 76,
    31: 78,
    32: 6,
    33: 163,
    34: 138,
    35: 136,
    36: 43,
    37: 63,
    38: 67,
    39: 58,
    40: 66,
    41: 59,
    42: 61,
    43: 62,
    44: 64,
    45: 68,
    46: 57,
    47: 60,
    48: 154,
    49: 65,
    50: 33
  },
  start: 256
};
function Parser(filename, grammar) {
  this.filename = filename;
  this.grammar = grammar;
  return this;
}
Parser.prototype.setup = function (start) {
  start = start || this.grammar.start;
  var newnode = {
      type: start,
      value: null,
      context: null,
      children: []
    };
  var stackentry = {
      dfa: this.grammar.dfas[start],
      state: 0,
      node: newnode
    };
  this.stack = [stackentry];
  this.used_names = {};
};
function findInDfa(a, obj) {
  var i = a.length;
  while (i--) {
    if (a[i][0] === obj[0] && a[i][1] === obj[1]) {
      return true;
    }
  }
  return false;
}
Parser.prototype.addtoken = function (type, value, context) {
  var ilabel = this.classify(type, value, context);
  OUTERWHILE:
    while (true) {
      var tp = this.stack[this.stack.length - 1];
      var states = tp.dfa[0];
      var first = tp.dfa[1];
      var arcs = states[tp.state];
      for (var a = 0; a < arcs.length; ++a) {
        var i = arcs[a][0];
        var newstate = arcs[a][1];
        var t = this.grammar.labels[i][0];
        var v = this.grammar.labels[i][1];
        if (ilabel === i) {
          goog.asserts.assert(t < 256);
          this.shift(type, value, newstate, context);
          var state = newstate;
          while (states[state].length === 1 && states[state][0][0] === 0 && states[state][0][1] === state) {
            this.pop();
            if (this.stack.length === 0) {
              return true;
            }
            tp = this.stack[this.stack.length - 1];
            state = tp.state;
            states = tp.dfa[0];
            first = tp.dfa[1];
          }
          return false;
        } else if (t >= 256) {
          var itsdfa = this.grammar.dfas[t];
          var itsfirst = itsdfa[1];
          if (itsfirst.hasOwnProperty(ilabel)) {
            this.push(t, this.grammar.dfas[t], newstate, context);
            continue OUTERWHILE;
          }
        }
      }
      if (findInDfa(arcs, [
          0,
          tp.state
        ])) {
        this.pop();
        if (this.stack.length === 0) {
          throw new Sk.builtin.ParseError('too much input', this.filename);
        }
      } else {
        var errline = context[0][0];
        throw new Sk.builtin.ParseError('bad input', this.filename, errline, context);
      }
    }
};
Parser.prototype.classify = function (type, value, context) {
  var ilabel;
  if (type === Sk.Tokenizer.Tokens.T_NAME) {
    this.used_names[value] = true;
    ilabel = this.grammar.keywords.hasOwnProperty(value) && this.grammar.keywords[value];
    if (ilabel) {
      return ilabel;
    }
  }
  ilabel = this.grammar.tokens.hasOwnProperty(type) && this.grammar.tokens[type];
  if (!ilabel) {
    throw new Sk.builtin.ParseError('bad token', this.filename, context[0][0], context);
  }
  return ilabel;
};
Parser.prototype.shift = function (type, value, newstate, context) {
  var dfa = this.stack[this.stack.length - 1].dfa;
  var state = this.stack[this.stack.length - 1].state;
  var node = this.stack[this.stack.length - 1].node;
  var newnode = {
      type: type,
      value: value,
      lineno: context[0][0],
      col_offset: context[0][1],
      children: null
    };
  if (newnode) {
    node.children.push(newnode);
  }
  this.stack[this.stack.length - 1] = {
    dfa: dfa,
    state: newstate,
    node: node
  };
};
Parser.prototype.push = function (type, newdfa, newstate, context) {
  var dfa = this.stack[this.stack.length - 1].dfa;
  var node = this.stack[this.stack.length - 1].node;
  var newnode = {
      type: type,
      value: null,
      lineno: context[0][0],
      col_offset: context[0][1],
      children: []
    };
  this.stack[this.stack.length - 1] = {
    dfa: dfa,
    state: newstate,
    node: node
  };
  this.stack.push({
    dfa: newdfa,
    state: 0,
    node: newnode
  });
};
Parser.prototype.pop = function () {
  var pop = this.stack.pop();
  var newnode = pop.node;
  if (newnode) {
    if (this.stack.length !== 0) {
      var node = this.stack[this.stack.length - 1].node;
      node.children.push(newnode);
    } else {
      this.rootnode = newnode;
      this.rootnode.used_names = this.used_names;
    }
  }
};
function makeParser(filename, style) {
  if (style === undefined)
    style = 'file_input';
  var p = new Parser(filename, Sk.ParseTables);
  if (style === 'file_input')
    p.setup(Sk.ParseTables.sym.file_input);
  else
    goog.asserts.fail('todo;');
  var curIndex = 0;
  var lineno = 1;
  var column = 0;
  var prefix = '';
  var T_COMMENT = Sk.Tokenizer.Tokens.T_COMMENT;
  var T_NL = Sk.Tokenizer.Tokens.T_NL;
  var T_OP = Sk.Tokenizer.Tokens.T_OP;
  var tokenizer = new Sk.Tokenizer(filename, style === 'single_input', function (type, value, start, end, line) {
      var s_lineno = start[0];
      var s_column = start[1];
      if (type === T_COMMENT || type === T_NL) {
        prefix += value;
        lineno = end[0];
        column = end[1];
        if (value[value.length - 1] === '\n') {
          lineno += 1;
          column = 0;
        }
        return undefined;
      }
      if (type === T_OP) {
        type = Sk.OpMap[value];
      }
      if (p.addtoken(type, value, [
          start,
          end,
          line
        ])) {
        return true;
      }
    });
  return function (line) {
    var ret = tokenizer.generateTokens(line);
    if (ret) {
      if (ret !== 'done') {
        throw new Sk.builtin.ParseError('incomplete input', this.filename);
      }
      return p.rootnode;
    }
    return false;
  };
}
Sk.parse = function parse(filename, input) {
  var parseFunc = makeParser(filename);
  if (input.substr(input.length - 1, 1) !== '\n')
    input += '\n';
  var lines = input.split('\n');
  var ret;
  for (var i = 0; i < lines.length; ++i) {
    ret = parseFunc(lines[i] + (i === lines.length - 1 ? '' : '\n'));
  }
  return ret;
};
Sk.parseTreeDump = function parseTreeDump(n, indent) {
  indent = indent || '';
  var ret = '';
  ret += indent;
  if (n.type >= 256) {
    ret += Sk.ParseTables.number2symbol[n.type] + '\n';
    for (var i = 0; i < n.children.length; ++i) {
      ret += Sk.parseTreeDump(n.children[i], indent + '  ');
    }
  } else {
    ret += Sk.Tokenizer.tokenNames[n.type] + ': ' + new Sk.builtin.str(n.value)['$r']().v + '\n';
  }
  return ret;
};
goog.exportSymbol('Sk.parse', Sk.parse);
goog.exportSymbol('Sk.parseTreeDump', Sk.parseTreeDump);
function Load() {
}
function Store() {
}
function Del() {
}
function AugLoad() {
}
function AugStore() {
}
function Param() {
}
function And() {
}
function Or() {
}
function Add() {
}
function Sub() {
}
function Mult() {
}
function Div() {
}
function Mod() {
}
function Pow() {
}
function LShift() {
}
function RShift() {
}
function BitOr() {
}
function BitXor() {
}
function BitAnd() {
}
function FloorDiv() {
}
function Invert() {
}
function Not() {
}
function UAdd() {
}
function USub() {
}
function Eq() {
}
function NotEq() {
}
function Lt() {
}
function LtE() {
}
function Gt() {
}
function GtE() {
}
function Is() {
}
function IsNot() {
}
function In_() {
}
function NotIn() {
}
function Module(body) {
  this.body = body;
  return this;
}
function Interactive(body) {
  this.body = body;
  return this;
}
function Expression(body) {
  goog.asserts.assert(body !== null && body !== undefined);
  this.body = body;
  return this;
}
function Suite(body) {
  this.body = body;
  return this;
}
function FunctionDef(name, args, body, decorator_list, lineno, col_offset) {
  goog.asserts.assert(name !== null && name !== undefined);
  goog.asserts.assert(args !== null && args !== undefined);
  this.name = name;
  this.args = args;
  this.body = body;
  this.decorator_list = decorator_list;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}
function ClassDef(name, bases, body, decorator_list, lineno, col_offset) {
  goog.asserts.assert(name !== null && name !== undefined);
  this.name = name;
  this.bases = bases;
  this.body = body;
  this.decorator_list = decorator_list;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}
function Return_(value, lineno, col_offset) {
  this.value = value;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}
function Delete_(targets, lineno, col_offset) {
  this.targets = targets;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}
function Assign(targets, value, lineno, col_offset) {
  goog.asserts.assert(value !== null && value !== undefined);
  this.targets = targets;
  this.value = value;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}
function AugAssign(target, op, value, lineno, col_offset) {
  goog.asserts.assert(target !== null && target !== undefined);
  goog.asserts.assert(op !== null && op !== undefined);
  goog.asserts.assert(value !== null && value !== undefined);
  this.target = target;
  this.op = op;
  this.value = value;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}
function Print(dest, values, nl, lineno, col_offset) {
  this.dest = dest;
  this.values = values;
  this.nl = nl;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}
function For_(target, iter, body, orelse, lineno, col_offset) {
  goog.asserts.assert(target !== null && target !== undefined);
  goog.asserts.assert(iter !== null && iter !== undefined);
  this.target = target;
  this.iter = iter;
  this.body = body;
  this.orelse = orelse;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}
function While_(test, body, orelse, lineno, col_offset) {
  goog.asserts.assert(test !== null && test !== undefined);
  this.test = test;
  this.body = body;
  this.orelse = orelse;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}
function If_(test, body, orelse, lineno, col_offset) {
  goog.asserts.assert(test !== null && test !== undefined);
  this.test = test;
  this.body = body;
  this.orelse = orelse;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}
function With_(context_expr, optional_vars, body, lineno, col_offset) {
  goog.asserts.assert(context_expr !== null && context_expr !== undefined);
  this.context_expr = context_expr;
  this.optional_vars = optional_vars;
  this.body = body;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}
function Raise(type, inst, tback, lineno, col_offset) {
  this.type = type;
  this.inst = inst;
  this.tback = tback;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}
function TryExcept(body, handlers, orelse, lineno, col_offset) {
  this.body = body;
  this.handlers = handlers;
  this.orelse = orelse;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}
function TryFinally(body, finalbody, lineno, col_offset) {
  this.body = body;
  this.finalbody = finalbody;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}
function Assert(test, msg, lineno, col_offset) {
  goog.asserts.assert(test !== null && test !== undefined);
  this.test = test;
  this.msg = msg;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}
function Import_(names, lineno, col_offset) {
  this.names = names;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}
function ImportFrom(module, names, level, lineno, col_offset) {
  goog.asserts.assert(module !== null && module !== undefined);
  this.module = module;
  this.names = names;
  this.level = level;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}
function Exec(body, globals, locals, lineno, col_offset) {
  goog.asserts.assert(body !== null && body !== undefined);
  this.body = body;
  this.globals = globals;
  this.locals = locals;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}
function Global(names, lineno, col_offset) {
  this.names = names;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}
function Expr(value, lineno, col_offset) {
  goog.asserts.assert(value !== null && value !== undefined);
  this.value = value;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}
function Pass(lineno, col_offset) {
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}
function Break_(lineno, col_offset) {
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}
function Continue_(lineno, col_offset) {
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}
function BoolOp(op, values, lineno, col_offset) {
  goog.asserts.assert(op !== null && op !== undefined);
  this.op = op;
  this.values = values;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}
function BinOp(left, op, right, lineno, col_offset) {
  goog.asserts.assert(left !== null && left !== undefined);
  goog.asserts.assert(op !== null && op !== undefined);
  goog.asserts.assert(right !== null && right !== undefined);
  this.left = left;
  this.op = op;
  this.right = right;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}
function UnaryOp(op, operand, lineno, col_offset) {
  goog.asserts.assert(op !== null && op !== undefined);
  goog.asserts.assert(operand !== null && operand !== undefined);
  this.op = op;
  this.operand = operand;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}
function Lambda(args, body, lineno, col_offset) {
  goog.asserts.assert(args !== null && args !== undefined);
  goog.asserts.assert(body !== null && body !== undefined);
  this.args = args;
  this.body = body;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}
function IfExp(test, body, orelse, lineno, col_offset) {
  goog.asserts.assert(test !== null && test !== undefined);
  goog.asserts.assert(body !== null && body !== undefined);
  goog.asserts.assert(orelse !== null && orelse !== undefined);
  this.test = test;
  this.body = body;
  this.orelse = orelse;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}
function Dict(keys, values, lineno, col_offset) {
  this.keys = keys;
  this.values = values;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}
function ListComp(elt, generators, lineno, col_offset) {
  goog.asserts.assert(elt !== null && elt !== undefined);
  this.elt = elt;
  this.generators = generators;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}
function GeneratorExp(elt, generators, lineno, col_offset) {
  goog.asserts.assert(elt !== null && elt !== undefined);
  this.elt = elt;
  this.generators = generators;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}
function Yield(value, lineno, col_offset) {
  this.value = value;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}
function Compare(left, ops, comparators, lineno, col_offset) {
  goog.asserts.assert(left !== null && left !== undefined);
  this.left = left;
  this.ops = ops;
  this.comparators = comparators;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}
function Call(func, args, keywords, starargs, kwargs, lineno, col_offset) {
  goog.asserts.assert(func !== null && func !== undefined);
  this.func = func;
  this.args = args;
  this.keywords = keywords;
  this.starargs = starargs;
  this.kwargs = kwargs;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}
function Num(n, lineno, col_offset) {
  goog.asserts.assert(n !== null && n !== undefined);
  this.n = n;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}
function Str(s, lineno, col_offset) {
  goog.asserts.assert(s !== null && s !== undefined);
  this.s = s;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}
function Attribute(value, attr, ctx, lineno, col_offset) {
  goog.asserts.assert(value !== null && value !== undefined);
  goog.asserts.assert(attr !== null && attr !== undefined);
  goog.asserts.assert(ctx !== null && ctx !== undefined);
  this.value = value;
  this.attr = attr;
  this.ctx = ctx;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}
function Subscript(value, slice, ctx, lineno, col_offset) {
  goog.asserts.assert(value !== null && value !== undefined);
  goog.asserts.assert(slice !== null && slice !== undefined);
  goog.asserts.assert(ctx !== null && ctx !== undefined);
  this.value = value;
  this.slice = slice;
  this.ctx = ctx;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}
function Name(id, ctx, lineno, col_offset) {
  goog.asserts.assert(id !== null && id !== undefined);
  goog.asserts.assert(ctx !== null && ctx !== undefined);
  this.id = id;
  this.ctx = ctx;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}
function List(elts, ctx, lineno, col_offset) {
  goog.asserts.assert(ctx !== null && ctx !== undefined);
  this.elts = elts;
  this.ctx = ctx;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}
function Tuple(elts, ctx, lineno, col_offset) {
  goog.asserts.assert(ctx !== null && ctx !== undefined);
  this.elts = elts;
  this.ctx = ctx;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}
function Ellipsis() {
  return this;
}
function Slice(lower, upper, step) {
  this.lower = lower;
  this.upper = upper;
  this.step = step;
  return this;
}
function ExtSlice(dims) {
  this.dims = dims;
  return this;
}
function Index(value) {
  goog.asserts.assert(value !== null && value !== undefined);
  this.value = value;
  return this;
}
function comprehension(target, iter, ifs) {
  goog.asserts.assert(target !== null && target !== undefined);
  goog.asserts.assert(iter !== null && iter !== undefined);
  this.target = target;
  this.iter = iter;
  this.ifs = ifs;
  return this;
}
function ExceptHandler(type, name, body, lineno, col_offset) {
  this.type = type;
  this.name = name;
  this.body = body;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}
function arguments_(args, vararg, kwarg, defaults) {
  this.args = args;
  this.vararg = vararg;
  this.kwarg = kwarg;
  this.defaults = defaults;
  return this;
}
function keyword(arg, value) {
  goog.asserts.assert(arg !== null && arg !== undefined);
  goog.asserts.assert(value !== null && value !== undefined);
  this.arg = arg;
  this.value = value;
  return this;
}
function alias(name, asname) {
  goog.asserts.assert(name !== null && name !== undefined);
  this.name = name;
  this.asname = asname;
  return this;
}
Module.prototype._astname = 'Module';
Module.prototype._fields = [
  'body',
  function (n) {
    return n.body;
  }
];
Interactive.prototype._astname = 'Interactive';
Interactive.prototype._fields = [
  'body',
  function (n) {
    return n.body;
  }
];
Expression.prototype._astname = 'Expression';
Expression.prototype._fields = [
  'body',
  function (n) {
    return n.body;
  }
];
Suite.prototype._astname = 'Suite';
Suite.prototype._fields = [
  'body',
  function (n) {
    return n.body;
  }
];
FunctionDef.prototype._astname = 'FunctionDef';
FunctionDef.prototype._fields = [
  'name',
  function (n) {
    return n.name;
  },
  'args',
  function (n) {
    return n.args;
  },
  'body',
  function (n) {
    return n.body;
  },
  'decorator_list',
  function (n) {
    return n.decorator_list;
  }
];
ClassDef.prototype._astname = 'ClassDef';
ClassDef.prototype._fields = [
  'name',
  function (n) {
    return n.name;
  },
  'bases',
  function (n) {
    return n.bases;
  },
  'body',
  function (n) {
    return n.body;
  },
  'decorator_list',
  function (n) {
    return n.decorator_list;
  }
];
Return_.prototype._astname = 'Return';
Return_.prototype._fields = [
  'value',
  function (n) {
    return n.value;
  }
];
Delete_.prototype._astname = 'Delete';
Delete_.prototype._fields = [
  'targets',
  function (n) {
    return n.targets;
  }
];
Assign.prototype._astname = 'Assign';
Assign.prototype._fields = [
  'targets',
  function (n) {
    return n.targets;
  },
  'value',
  function (n) {
    return n.value;
  }
];
AugAssign.prototype._astname = 'AugAssign';
AugAssign.prototype._fields = [
  'target',
  function (n) {
    return n.target;
  },
  'op',
  function (n) {
    return n.op;
  },
  'value',
  function (n) {
    return n.value;
  }
];
Print.prototype._astname = 'Print';
Print.prototype._fields = [
  'dest',
  function (n) {
    return n.dest;
  },
  'values',
  function (n) {
    return n.values;
  },
  'nl',
  function (n) {
    return n.nl;
  }
];
For_.prototype._astname = 'For';
For_.prototype._fields = [
  'target',
  function (n) {
    return n.target;
  },
  'iter',
  function (n) {
    return n.iter;
  },
  'body',
  function (n) {
    return n.body;
  },
  'orelse',
  function (n) {
    return n.orelse;
  }
];
While_.prototype._astname = 'While';
While_.prototype._fields = [
  'test',
  function (n) {
    return n.test;
  },
  'body',
  function (n) {
    return n.body;
  },
  'orelse',
  function (n) {
    return n.orelse;
  }
];
If_.prototype._astname = 'If';
If_.prototype._fields = [
  'test',
  function (n) {
    return n.test;
  },
  'body',
  function (n) {
    return n.body;
  },
  'orelse',
  function (n) {
    return n.orelse;
  }
];
With_.prototype._astname = 'With';
With_.prototype._fields = [
  'context_expr',
  function (n) {
    return n.context_expr;
  },
  'optional_vars',
  function (n) {
    return n.optional_vars;
  },
  'body',
  function (n) {
    return n.body;
  }
];
Raise.prototype._astname = 'Raise';
Raise.prototype._fields = [
  'type',
  function (n) {
    return n.type;
  },
  'inst',
  function (n) {
    return n.inst;
  },
  'tback',
  function (n) {
    return n.tback;
  }
];
TryExcept.prototype._astname = 'TryExcept';
TryExcept.prototype._fields = [
  'body',
  function (n) {
    return n.body;
  },
  'handlers',
  function (n) {
    return n.handlers;
  },
  'orelse',
  function (n) {
    return n.orelse;
  }
];
TryFinally.prototype._astname = 'TryFinally';
TryFinally.prototype._fields = [
  'body',
  function (n) {
    return n.body;
  },
  'finalbody',
  function (n) {
    return n.finalbody;
  }
];
Assert.prototype._astname = 'Assert';
Assert.prototype._fields = [
  'test',
  function (n) {
    return n.test;
  },
  'msg',
  function (n) {
    return n.msg;
  }
];
Import_.prototype._astname = 'Import';
Import_.prototype._fields = [
  'names',
  function (n) {
    return n.names;
  }
];
ImportFrom.prototype._astname = 'ImportFrom';
ImportFrom.prototype._fields = [
  'module',
  function (n) {
    return n.module;
  },
  'names',
  function (n) {
    return n.names;
  },
  'level',
  function (n) {
    return n.level;
  }
];
Exec.prototype._astname = 'Exec';
Exec.prototype._fields = [
  'body',
  function (n) {
    return n.body;
  },
  'globals',
  function (n) {
    return n.globals;
  },
  'locals',
  function (n) {
    return n.locals;
  }
];
Global.prototype._astname = 'Global';
Global.prototype._fields = [
  'names',
  function (n) {
    return n.names;
  }
];
Expr.prototype._astname = 'Expr';
Expr.prototype._fields = [
  'value',
  function (n) {
    return n.value;
  }
];
Pass.prototype._astname = 'Pass';
Pass.prototype._fields = [];
Break_.prototype._astname = 'Break';
Break_.prototype._fields = [];
Continue_.prototype._astname = 'Continue';
Continue_.prototype._fields = [];
BoolOp.prototype._astname = 'BoolOp';
BoolOp.prototype._fields = [
  'op',
  function (n) {
    return n.op;
  },
  'values',
  function (n) {
    return n.values;
  }
];
BinOp.prototype._astname = 'BinOp';
BinOp.prototype._fields = [
  'left',
  function (n) {
    return n.left;
  },
  'op',
  function (n) {
    return n.op;
  },
  'right',
  function (n) {
    return n.right;
  }
];
UnaryOp.prototype._astname = 'UnaryOp';
UnaryOp.prototype._fields = [
  'op',
  function (n) {
    return n.op;
  },
  'operand',
  function (n) {
    return n.operand;
  }
];
Lambda.prototype._astname = 'Lambda';
Lambda.prototype._fields = [
  'args',
  function (n) {
    return n.args;
  },
  'body',
  function (n) {
    return n.body;
  }
];
IfExp.prototype._astname = 'IfExp';
IfExp.prototype._fields = [
  'test',
  function (n) {
    return n.test;
  },
  'body',
  function (n) {
    return n.body;
  },
  'orelse',
  function (n) {
    return n.orelse;
  }
];
Dict.prototype._astname = 'Dict';
Dict.prototype._fields = [
  'keys',
  function (n) {
    return n.keys;
  },
  'values',
  function (n) {
    return n.values;
  }
];
ListComp.prototype._astname = 'ListComp';
ListComp.prototype._fields = [
  'elt',
  function (n) {
    return n.elt;
  },
  'generators',
  function (n) {
    return n.generators;
  }
];
GeneratorExp.prototype._astname = 'GeneratorExp';
GeneratorExp.prototype._fields = [
  'elt',
  function (n) {
    return n.elt;
  },
  'generators',
  function (n) {
    return n.generators;
  }
];
Yield.prototype._astname = 'Yield';
Yield.prototype._fields = [
  'value',
  function (n) {
    return n.value;
  }
];
Compare.prototype._astname = 'Compare';
Compare.prototype._fields = [
  'left',
  function (n) {
    return n.left;
  },
  'ops',
  function (n) {
    return n.ops;
  },
  'comparators',
  function (n) {
    return n.comparators;
  }
];
Call.prototype._astname = 'Call';
Call.prototype._fields = [
  'func',
  function (n) {
    return n.func;
  },
  'args',
  function (n) {
    return n.args;
  },
  'keywords',
  function (n) {
    return n.keywords;
  },
  'starargs',
  function (n) {
    return n.starargs;
  },
  'kwargs',
  function (n) {
    return n.kwargs;
  }
];
Num.prototype._astname = 'Num';
Num.prototype._fields = [
  'n',
  function (n) {
    return n.n;
  }
];
Str.prototype._astname = 'Str';
Str.prototype._fields = [
  's',
  function (n) {
    return n.s;
  }
];
Attribute.prototype._astname = 'Attribute';
Attribute.prototype._fields = [
  'value',
  function (n) {
    return n.value;
  },
  'attr',
  function (n) {
    return n.attr;
  },
  'ctx',
  function (n) {
    return n.ctx;
  }
];
Subscript.prototype._astname = 'Subscript';
Subscript.prototype._fields = [
  'value',
  function (n) {
    return n.value;
  },
  'slice',
  function (n) {
    return n.slice;
  },
  'ctx',
  function (n) {
    return n.ctx;
  }
];
Name.prototype._astname = 'Name';
Name.prototype._fields = [
  'id',
  function (n) {
    return n.id;
  },
  'ctx',
  function (n) {
    return n.ctx;
  }
];
List.prototype._astname = 'List';
List.prototype._fields = [
  'elts',
  function (n) {
    return n.elts;
  },
  'ctx',
  function (n) {
    return n.ctx;
  }
];
Tuple.prototype._astname = 'Tuple';
Tuple.prototype._fields = [
  'elts',
  function (n) {
    return n.elts;
  },
  'ctx',
  function (n) {
    return n.ctx;
  }
];
Load.prototype._astname = 'Load';
Load.prototype._isenum = true;
Store.prototype._astname = 'Store';
Store.prototype._isenum = true;
Del.prototype._astname = 'Del';
Del.prototype._isenum = true;
AugLoad.prototype._astname = 'AugLoad';
AugLoad.prototype._isenum = true;
AugStore.prototype._astname = 'AugStore';
AugStore.prototype._isenum = true;
Param.prototype._astname = 'Param';
Param.prototype._isenum = true;
Ellipsis.prototype._astname = 'Ellipsis';
Ellipsis.prototype._fields = [];
Slice.prototype._astname = 'Slice';
Slice.prototype._fields = [
  'lower',
  function (n) {
    return n.lower;
  },
  'upper',
  function (n) {
    return n.upper;
  },
  'step',
  function (n) {
    return n.step;
  }
];
ExtSlice.prototype._astname = 'ExtSlice';
ExtSlice.prototype._fields = [
  'dims',
  function (n) {
    return n.dims;
  }
];
Index.prototype._astname = 'Index';
Index.prototype._fields = [
  'value',
  function (n) {
    return n.value;
  }
];
And.prototype._astname = 'And';
And.prototype._isenum = true;
Or.prototype._astname = 'Or';
Or.prototype._isenum = true;
Add.prototype._astname = 'Add';
Add.prototype._isenum = true;
Sub.prototype._astname = 'Sub';
Sub.prototype._isenum = true;
Mult.prototype._astname = 'Mult';
Mult.prototype._isenum = true;
Div.prototype._astname = 'Div';
Div.prototype._isenum = true;
Mod.prototype._astname = 'Mod';
Mod.prototype._isenum = true;
Pow.prototype._astname = 'Pow';
Pow.prototype._isenum = true;
LShift.prototype._astname = 'LShift';
LShift.prototype._isenum = true;
RShift.prototype._astname = 'RShift';
RShift.prototype._isenum = true;
BitOr.prototype._astname = 'BitOr';
BitOr.prototype._isenum = true;
BitXor.prototype._astname = 'BitXor';
BitXor.prototype._isenum = true;
BitAnd.prototype._astname = 'BitAnd';
BitAnd.prototype._isenum = true;
FloorDiv.prototype._astname = 'FloorDiv';
FloorDiv.prototype._isenum = true;
Invert.prototype._astname = 'Invert';
Invert.prototype._isenum = true;
Not.prototype._astname = 'Not';
Not.prototype._isenum = true;
UAdd.prototype._astname = 'UAdd';
UAdd.prototype._isenum = true;
USub.prototype._astname = 'USub';
USub.prototype._isenum = true;
Eq.prototype._astname = 'Eq';
Eq.prototype._isenum = true;
NotEq.prototype._astname = 'NotEq';
NotEq.prototype._isenum = true;
Lt.prototype._astname = 'Lt';
Lt.prototype._isenum = true;
LtE.prototype._astname = 'LtE';
LtE.prototype._isenum = true;
Gt.prototype._astname = 'Gt';
Gt.prototype._isenum = true;
GtE.prototype._astname = 'GtE';
GtE.prototype._isenum = true;
Is.prototype._astname = 'Is';
Is.prototype._isenum = true;
IsNot.prototype._astname = 'IsNot';
IsNot.prototype._isenum = true;
In_.prototype._astname = 'In';
In_.prototype._isenum = true;
NotIn.prototype._astname = 'NotIn';
NotIn.prototype._isenum = true;
comprehension.prototype._astname = 'comprehension';
comprehension.prototype._fields = [
  'target',
  function (n) {
    return n.target;
  },
  'iter',
  function (n) {
    return n.iter;
  },
  'ifs',
  function (n) {
    return n.ifs;
  }
];
ExceptHandler.prototype._astname = 'ExceptHandler';
ExceptHandler.prototype._fields = [
  'type',
  function (n) {
    return n.type;
  },
  'name',
  function (n) {
    return n.name;
  },
  'body',
  function (n) {
    return n.body;
  }
];
arguments_.prototype._astname = 'arguments';
arguments_.prototype._fields = [
  'args',
  function (n) {
    return n.args;
  },
  'vararg',
  function (n) {
    return n.vararg;
  },
  'kwarg',
  function (n) {
    return n.kwarg;
  },
  'defaults',
  function (n) {
    return n.defaults;
  }
];
keyword.prototype._astname = 'keyword';
keyword.prototype._fields = [
  'arg',
  function (n) {
    return n.arg;
  },
  'value',
  function (n) {
    return n.value;
  }
];
alias.prototype._astname = 'alias';
alias.prototype._fields = [
  'name',
  function (n) {
    return n.name;
  },
  'asname',
  function (n) {
    return n.asname;
  }
];
var SYM = Sk.ParseTables.sym;
var TOK = Sk.Tokenizer.Tokens;
function Compiling(encoding, filename) {
  this.c_encoding = encoding;
  this.c_filename = filename;
}
function NCH(n) {
  goog.asserts.assert(n !== undefined);
  if (n.children === null)
    return 0;
  return n.children.length;
}
function CHILD(n, i) {
  goog.asserts.assert(n !== undefined);
  goog.asserts.assert(i !== undefined);
  return n.children[i];
}
function REQ(n, type) {
  goog.asserts.assert(n.type === type, 'node wasn\'t expected type');
}
function strobj(s) {
  goog.asserts.assert(typeof s === 'string', 'expecting string, got ' + typeof s);
  return new Sk.builtin.str(s);
}
function numStmts(n) {
  switch (n.type) {
  case SYM.single_input:
    if (CHILD(n, 0).type === TOK.T_NEWLINE)
      return 0;
    else
      return numStmts(CHILD(n, 0));
  case SYM.file_input:
    var cnt = 0;
    for (var i = 0; i < NCH(n); ++i) {
      var ch = CHILD(n, i);
      if (ch.type === SYM.stmt)
        cnt += numStmts(ch);
    }
    return cnt;
  case SYM.stmt:
    return numStmts(CHILD(n, 0));
  case SYM.compound_stmt:
    return 1;
  case SYM.simple_stmt:
    return Math.floor(NCH(n) / 2);
  case SYM.suite:
    if (NCH(n) === 1)
      return numStmts(CHILD(n, 0));
    else {
      var cnt = 0;
      for (var i = 2; i < NCH(n) - 1; ++i)
        cnt += numStmts(CHILD(n, i));
      return cnt;
    }
  default:
    goog.asserts.fail('Non-statement found');
  }
  return 0;
}
function forbiddenCheck(c, n, x, lineno) {
  if (x === 'None')
    throw new Sk.builtin.SyntaxError('assignment to None', c.c_filename, lineno);
  if (x === 'True' || x === 'False')
    throw new Sk.builtin.SyntaxError('assignment to True or False is forbidden', c.c_filename, lineno);
}
function setContext(c, e, ctx, n) {
  goog.asserts.assert(ctx !== AugStore && ctx !== AugLoad);
  var s = null;
  var exprName = null;
  switch (e.constructor) {
  case Attribute:
  case Name:
    if (ctx === Store)
      forbiddenCheck(c, n, e.attr, n.lineno);
    e.ctx = ctx;
    break;
  case Subscript:
    e.ctx = ctx;
    break;
  case List:
    e.ctx = ctx;
    s = e.elts;
    break;
  case Tuple:
    if (e.elts.length === 0)
      throw new Sk.builtin.SyntaxError('can\'t assign to ()', c.c_filename, n.lineno);
    e.ctx = ctx;
    s = e.elts;
    break;
  case Lambda:
    exprName = 'lambda';
    break;
  case Call:
    exprName = 'function call';
    break;
  case BoolOp:
  case BinOp:
  case UnaryOp:
    exprName = 'operator';
    break;
  case GeneratorExp:
    exprName = 'generator expression';
    break;
  case Yield:
    exprName = 'yield expression';
    break;
  case ListComp:
    exprName = 'list comprehension';
    break;
  case Dict:
  case Num:
  case Str:
    exprName = 'literal';
    break;
  case Compare:
    exprName = 'comparison';
    break;
  case IfExp:
    exprName = 'conditional expression';
    break;
  default:
    goog.asserts.fail('unhandled expression in assignment');
  }
  if (exprName) {
    throw new Sk.builtin.SyntaxError('can\'t ' + (ctx === Store ? 'assign to' : 'delete') + ' ' + exprName, c.c_filename, n.lineno);
  }
  if (s) {
    for (var i = 0; i < s.length; ++i) {
      setContext(c, s[i], ctx, n);
    }
  }
}
var operatorMap = {};
(function () {
  operatorMap[TOK.T_VBAR] = BitOr;
  operatorMap[TOK.T_VBAR] = BitOr;
  operatorMap[TOK.T_CIRCUMFLEX] = BitXor;
  operatorMap[TOK.T_AMPER] = BitAnd;
  operatorMap[TOK.T_LEFTSHIFT] = LShift;
  operatorMap[TOK.T_RIGHTSHIFT] = RShift;
  operatorMap[TOK.T_PLUS] = Add;
  operatorMap[TOK.T_MINUS] = Sub;
  operatorMap[TOK.T_STAR] = Mult;
  operatorMap[TOK.T_SLASH] = Div;
  operatorMap[TOK.T_DOUBLESLASH] = FloorDiv;
  operatorMap[TOK.T_PERCENT] = Mod;
}());
function getOperator(n) {
  goog.asserts.assert(operatorMap[n.type] !== undefined);
  return operatorMap[n.type];
}
function astForCompOp(c, n) {
  REQ(n, SYM.comp_op);
  if (NCH(n) === 1) {
    n = CHILD(n, 0);
    switch (n.type) {
    case TOK.T_LESS:
      return Lt;
    case TOK.T_GREATER:
      return Gt;
    case TOK.T_EQEQUAL:
      return Eq;
    case TOK.T_LESSEQUAL:
      return LtE;
    case TOK.T_GREATEREQUAL:
      return GtE;
    case TOK.T_NOTEQUAL:
      return NotEq;
    case TOK.T_NAME:
      if (n.value === 'in')
        return In_;
      if (n.value === 'is')
        return Is;
    }
  } else if (NCH(n) === 2) {
    if (CHILD(n, 0).type === TOK.T_NAME) {
      if (CHILD(n, 1).value === 'in')
        return NotIn;
      if (CHILD(n, 0).value === 'is')
        return IsNot;
    }
  }
  goog.asserts.fail('invalid comp_op');
}
function seqForTestlist(c, n) {
  goog.asserts.assert(n.type === SYM.testlist || n.type === SYM.listmaker || n.type === SYM.testlist_gexp || n.type === SYM.testlist_safe || n.type === SYM.testlist1);
  var seq = [];
  for (var i = 0; i < NCH(n); i += 2) {
    goog.asserts.assert(CHILD(n, i).type === SYM.test || CHILD(n, i).type === SYM.old_test);
    seq[i / 2] = astForExpr(c, CHILD(n, i));
  }
  return seq;
}
function astForSuite(c, n) {
  REQ(n, SYM.suite);
  var seq = [];
  var pos = 0;
  var ch;
  if (CHILD(n, 0).type === SYM.simple_stmt) {
    n = CHILD(n, 0);
    var end = NCH(n) - 1;
    if (CHILD(n, end - 1).type === TOK.T_SEMI)
      end -= 1;
    for (var i = 0; i < end; i += 2)
      seq[pos++] = astForStmt(c, CHILD(n, i));
  } else {
    for (var i = 2; i < NCH(n) - 1; ++i) {
      ch = CHILD(n, i);
      REQ(ch, SYM.stmt);
      var num = numStmts(ch);
      if (num === 1) {
        seq[pos++] = astForStmt(c, ch);
      } else {
        ch = CHILD(ch, 0);
        REQ(ch, SYM.simple_stmt);
        for (var j = 0; j < NCH(ch); j += 2) {
          if (NCH(CHILD(ch, j)) === 0) {
            goog.asserts.assert(j + 1 === NCH(ch));
            break;
          }
          seq[pos++] = astForStmt(c, CHILD(ch, j));
        }
      }
    }
  }
  goog.asserts.assert(pos === numStmts(n));
  return seq;
}
function astForExceptClause(c, exc, body) {
  REQ(exc, SYM.except_clause);
  REQ(body, SYM.suite);
  if (NCH(exc) === 1)
    return new ExceptHandler(null, null, astForSuite(c, body), exc.lineno, exc.col_offset);
  else if (NCH(exc) === 2)
    return new ExceptHandler(astForExpr(c, CHILD(exc, 1)), null, astForSuite(c, body), exc.lineno, exc.col_offset);
  else if (NCH(exc) === 4) {
    var e = astForExpr(c, CHILD(exc, 3));
    setContext(c, e, Store, CHILD(exc, 3));
    return new ExceptHandler(astForExpr(c, CHILD(exc, 1)), e, astForSuite(c, body), exc.lineno, exc.col_offset);
  }
  goog.asserts.fail('wrong number of children for except clause');
}
function astForTryStmt(c, n) {
  var nc = NCH(n);
  var nexcept = (nc - 3) / 3;
  var body, orelse = [], finally_ = null;
  REQ(n, SYM.try_stmt);
  body = astForSuite(c, CHILD(n, 2));
  if (CHILD(n, nc - 3).type === TOK.T_NAME) {
    if (CHILD(n, nc - 3).value === 'finally') {
      if (nc >= 9 && CHILD(n, nc - 6).type === TOK.T_NAME) {
        orelse = astForSuite(c, CHILD(n, nc - 4));
        nexcept--;
      }
      finally_ = astForSuite(c, CHILD(n, nc - 1));
      nexcept--;
    } else {
      orelse = astForSuite(c, CHILD(n, nc - 1));
      nexcept--;
    }
  } else if (CHILD(n, nc - 3).type !== SYM.except_clause) {
    throw new Sk.builtin.SyntaxError('malformed \'try\' statement', c.c_filename, n.lineno);
  }
  if (nexcept > 0) {
    var handlers = [];
    for (var i = 0; i < nexcept; ++i)
      handlers[i] = astForExceptClause(c, CHILD(n, 3 + i * 3), CHILD(n, 5 + i * 3));
    var exceptSt = new TryExcept(body, handlers, orelse, n.lineno, n.col_offset);
    if (!finally_)
      return exceptSt;
    body = [exceptSt];
  }
  goog.asserts.assert(finally_ !== null);
  return new TryFinally(body, finally_, n.lineno, n.col_offset);
}
function astForDottedName(c, n) {
  REQ(n, SYM.dotted_name);
  var lineno = n.lineno;
  var col_offset = n.col_offset;
  var id = strobj(CHILD(n, 0).value);
  var e = new Name(id, Load, lineno, col_offset);
  for (var i = 2; i < NCH(n); i += 2) {
    id = strobj(CHILD(n, i).value);
    e = new Attribute(e, id, Load, lineno, col_offset);
  }
  return e;
}
function astForDecorator(c, n) {
  REQ(n, SYM.decorator);
  REQ(CHILD(n, 0), TOK.T_AT);
  REQ(CHILD(n, NCH(n) - 1), TOK.T_NEWLINE);
  var nameExpr = astForDottedName(c, CHILD(n, 1));
  var d;
  if (NCH(n) === 3)
    return nameExpr;
  else if (NCH(n) === 5)
    return new Call(nameExpr, [], [], null, null, n.lineno, n.col_offset);
  else
    return astForCall(c, CHILD(n, 3), nameExpr);
}
function astForDecorators(c, n) {
  REQ(n, SYM.decorators);
  var decoratorSeq = [];
  for (var i = 0; i < NCH(n); ++i)
    decoratorSeq[i] = astForDecorator(c, CHILD(n, i));
  return decoratorSeq;
}
function astForDecorated(c, n) {
  REQ(n, SYM.decorated);
  var decoratorSeq = astForDecorators(c, CHILD(n, 0));
  goog.asserts.assert(CHILD(n, 1).type === SYM.funcdef || CHILD(n, 1).type === SYM.classdef);
  var thing = null;
  if (CHILD(n, 1).type === SYM.funcdef)
    thing = astForFuncdef(c, CHILD(n, 1), decoratorSeq);
  else if (CHILD(n, 1) === SYM.classdef)
    thing = astForClassdef(c, CHILD(n, 1), decoratorSeq);
  if (thing) {
    thing.lineno = n.lineno;
    thing.col_offset = n.col_offset;
  }
  return thing;
}
function astForWithVar(c, n) {
  REQ(n, SYM.with_var);
  return astForExpr(c, CHILD(n, 1));
}
function astForWithStmt(c, n) {
  var suiteIndex = 3;
  goog.asserts.assert(n.type === SYM.with_stmt);
  var contextExpr = astForExpr(c, CHILD(n, 1));
  if (CHILD(n, 2).type === SYM.with_var) {
    var optionalVars = astForWithVar(c, CHILD(n, 2));
    setContext(c, optionalVars, Store, n);
    suiteIndex = 4;
  }
  return new With_(contextExpr, optionalVars, astForSuite(c, CHILD(n, suiteIndex)), n.lineno, n.col_offset);
}
function astForExecStmt(c, n) {
  var expr1, globals = null, locals = null;
  var nchildren = NCH(n);
  goog.asserts.assert(nchildren === 2 || nchildren === 4 || nchildren === 6);
  REQ(n, SYM.exec_stmt);
  var expr1 = astForExpr(c, CHILD(n, 1));
  if (nchildren >= 4)
    globals = astForExpr(c, CHILD(n, 3));
  if (nchildren === 6)
    locals = astForExpr(c, CHILD(n, 5));
  return new Exec(expr1, globals, locals, n.lineno, n.col_offset);
}
function astForIfStmt(c, n) {
  REQ(n, SYM.if_stmt);
  if (NCH(n) === 4)
    return new If_(astForExpr(c, CHILD(n, 1)), astForSuite(c, CHILD(n, 3)), [], n.lineno, n.col_offset);
  var s = CHILD(n, 4).value;
  var decider = s.charAt(2);
  if (decider === 's') {
    return new If_(astForExpr(c, CHILD(n, 1)), astForSuite(c, CHILD(n, 3)), astForSuite(c, CHILD(n, 6)), n.lineno, n.col_offset);
  } else if (decider === 'i') {
    var nElif = NCH(n) - 4;
    var hasElse = false;
    var orelse = [];
    if (CHILD(n, nElif + 1).type === TOK.T_NAME && CHILD(n, nElif + 1).value.charAt(2) === 's') {
      hasElse = true;
      nElif -= 3;
    }
    nElif /= 4;
    if (hasElse) {
      orelse = [new If_(astForExpr(c, CHILD(n, NCH(n) - 6)), astForSuite(c, CHILD(n, NCH(n) - 4)), astForSuite(c, CHILD(n, NCH(n) - 1)), CHILD(n, NCH(n) - 6).lineno, CHILD(n, NCH(n) - 6).col_offset)];
      nElif--;
    }
    for (var i = 0; i < nElif; ++i) {
      var off = 5 + (nElif - i - 1) * 4;
      orelse = [new If_(astForExpr(c, CHILD(n, off)), astForSuite(c, CHILD(n, off + 2)), orelse, CHILD(n, off).lineno, CHILD(n, off).col_offset)];
    }
    return new If_(astForExpr(c, CHILD(n, 1)), astForSuite(c, CHILD(n, 3)), orelse, n.lineno, n.col_offset);
  }
  goog.asserts.fail('unexpected token in \'if\' statement');
}
function astForExprlist(c, n, context) {
  REQ(n, SYM.exprlist);
  var seq = [];
  for (var i = 0; i < NCH(n); i += 2) {
    var e = astForExpr(c, CHILD(n, i));
    seq[i / 2] = e;
    if (context)
      setContext(c, e, context, CHILD(n, i));
  }
  return seq;
}
function astForDelStmt(c, n) {
  REQ(n, SYM.del_stmt);
  return new Delete_(astForExprlist(c, CHILD(n, 1), Del), n.lineno, n.col_offset);
}
function astForGlobalStmt(c, n) {
  REQ(n, SYM.global_stmt);
  var s = [];
  for (var i = 1; i < NCH(n); i += 2) {
    s[(i - 1) / 2] = strobj(CHILD(n, i).value);
  }
  return new Global(s, n.lineno, n.col_offset);
}
function astForAssertStmt(c, n) {
  REQ(n, SYM.assert_stmt);
  if (NCH(n) === 2)
    return new Assert(astForExpr(c, CHILD(n, 1)), null, n.lineno, n.col_offset);
  else if (NCH(n) === 4)
    return new Assert(astForExpr(c, CHILD(n, 1)), astForExpr(c, CHILD(n, 3)), n.lineno, n.col_offset);
  goog.asserts.fail('improper number of parts to assert stmt');
}
function aliasForImportName(c, n) {
  loop:
    while (true) {
      switch (n.type) {
      case SYM.import_as_name:
        var str = null;
        var name = strobj(CHILD(n, 0).value);
        if (NCH(n) === 3)
          str = CHILD(n, 2).value;
        return new alias(name, str == null ? null : strobj(str));
      case SYM.dotted_as_name:
        if (NCH(n) === 1) {
          n = CHILD(n, 0);
          continue loop;
        } else {
          var a = aliasForImportName(c, CHILD(n, 0));
          goog.asserts.assert(!a.asname);
          a.asname = strobj(CHILD(n, 2).value);
          return a;
        }
      case SYM.dotted_name:
        if (NCH(n) === 1)
          return new alias(strobj(CHILD(n, 0).value), null);
        else {
          var str = '';
          for (var i = 0; i < NCH(n); i += 2)
            str += CHILD(n, i).value + '.';
          return new alias(strobj(str.substr(0, str.length - 1)), null);
        }
      case TOK.T_STAR:
        return new alias(strobj('*'), null);
      default:
        throw new Sk.builtin.SyntaxError('unexpected import name', c.c_filename, n.lineno);
      }
      break;
    }
}
function astForImportStmt(c, n) {
  REQ(n, SYM.import_stmt);
  var lineno = n.lineno;
  var col_offset = n.col_offset;
  n = CHILD(n, 0);
  if (n.type === SYM.import_name) {
    n = CHILD(n, 1);
    REQ(n, SYM.dotted_as_names);
    var aliases = [];
    for (var i = 0; i < NCH(n); i += 2)
      aliases[i / 2] = aliasForImportName(c, CHILD(n, i));
    return new Import_(aliases, lineno, col_offset);
  } else if (n.type === SYM.import_from) {
    var mod = null;
    var ndots = 0;
    var nchildren;
    for (var idx = 1; idx < NCH(n); ++idx) {
      if (CHILD(n, idx).type === SYM.dotted_name) {
        mod = aliasForImportName(c, CHILD(n, idx));
        idx++;
        break;
      } else if (CHILD(n, idx).type !== TOK.T_DOT)
        break;
      ndots++;
    }
    ++idx;
    switch (CHILD(n, idx).type) {
    case TOK.T_STAR:
      n = CHILD(n, idx);
      nchildren = 1;
      break;
    case TOK.T_LPAR:
      n = CHILD(n, idx + 1);
      nchildren = NCH(n);
      break;
    case SYM.import_as_names:
      n = CHILD(n, idx);
      nchildren = NCH(n);
      if (nchildren % 2 === 0)
        throw new Sk.builtin.SyntaxError('trailing comma not allowed without surrounding parentheses', c.c_filename, n.lineno);
      break;
    default:
      throw new Sk.builtin.SyntaxError('Unexpected node-type in from-import', c.c_filename, n.lineno);
    }
    var aliases = [];
    if (n.type === TOK.T_STAR)
      aliases[0] = aliasForImportName(c, n);
    else
      for (var i = 0; i < NCH(n); i += 2)
        aliases[i / 2] = aliasForImportName(c, CHILD(n, i));
    var modname = mod ? mod.name.v : '';
    return new ImportFrom(strobj(modname), aliases, ndots, lineno, col_offset);
  }
  throw new Sk.builtin.SyntaxError('unknown import statement', c.c_filename, n.lineno);
}
function astForTestlistGexp(c, n) {
  goog.asserts.assert(n.type === SYM.testlist_gexp || n.type === SYM.argument);
  if (NCH(n) > 1 && CHILD(n, 1).type === SYM.gen_for)
    return astForGenexp(c, n);
  return astForTestlist(c, n);
}
function astForListcomp(c, n) {
  function countListFors(c, n) {
    var nfors = 0;
    var ch = CHILD(n, 1);
    count_list_for:
      while (true) {
        nfors++;
        REQ(ch, SYM.list_for);
        if (NCH(ch) === 5)
          ch = CHILD(ch, 4);
        else
          return nfors;
        count_list_iter:
          while (true) {
            REQ(ch, SYM.list_iter);
            ch = CHILD(ch, 0);
            if (ch.type === SYM.list_for)
              continue count_list_for;
            else if (ch.type === SYM.list_if) {
              if (NCH(ch) === 3) {
                ch = CHILD(ch, 2);
                continue count_list_iter;
              } else
                return nfors;
            }
            break;
          }
        break;
      }
  }
  function countListIfs(c, n) {
    var nifs = 0;
    while (true) {
      REQ(n, SYM.list_iter);
      if (CHILD(n, 0).type === SYM.list_for)
        return nifs;
      n = CHILD(n, 0);
      REQ(n, SYM.list_if);
      nifs++;
      if (NCH(n) == 2)
        return nifs;
      n = CHILD(n, 2);
    }
  }
  REQ(n, SYM.listmaker);
  goog.asserts.assert(NCH(n) > 1);
  var elt = astForExpr(c, CHILD(n, 0));
  var nfors = countListFors(c, n);
  var listcomps = [];
  var ch = CHILD(n, 1);
  for (var i = 0; i < nfors; ++i) {
    REQ(ch, SYM.list_for);
    var forch = CHILD(ch, 1);
    var t = astForExprlist(c, forch, Store);
    var expression = astForTestlist(c, CHILD(ch, 3));
    var lc;
    if (NCH(forch) === 1)
      lc = new comprehension(t[0], expression, []);
    else
      lc = new comprehension(new Tuple(t, Store, ch.lineno, ch.col_offset), expression, []);
    if (NCH(ch) === 5) {
      ch = CHILD(ch, 4);
      var nifs = countListIfs(c, ch);
      var ifs = [];
      for (var j = 0; j < nifs; ++j) {
        REQ(ch, SYM.list_iter);
        ch = CHILD(ch, 0);
        REQ(ch, SYM.list_if);
        ifs[j] = astForExpr(c, CHILD(ch, 1));
        if (NCH(ch) === 3)
          ch = CHILD(ch, 2);
      }
      if (ch.type === SYM.list_iter)
        ch = CHILD(ch, 0);
      lc.ifs = ifs;
    }
    listcomps[i] = lc;
  }
  return new ListComp(elt, listcomps, n.lineno, n.col_offset);
}
function astForFactor(c, n) {
  if (CHILD(n, 0).type === TOK.T_MINUS && NCH(n) === 2) {
    var pfactor = CHILD(n, 1);
    if (pfactor.type === SYM.factor && NCH(pfactor) === 1) {
      var ppower = CHILD(pfactor, 0);
      if (ppower.type === SYM.power && NCH(ppower) === 1) {
        var patom = CHILD(ppower, 0);
        if (patom.type === SYM.atom) {
          var pnum = CHILD(patom, 0);
          if (pnum.type === TOK.T_NUMBER) {
            pnum.value = '-' + pnum.value;
            return astForAtom(c, patom);
          }
        }
      }
    }
  }
  var expression = astForExpr(c, CHILD(n, 1));
  switch (CHILD(n, 0).type) {
  case TOK.T_PLUS:
    return new UnaryOp(UAdd, expression, n.lineno, n.col_offset);
  case TOK.T_MINUS:
    return new UnaryOp(USub, expression, n.lineno, n.col_offset);
  case TOK.T_TILDE:
    return new UnaryOp(Invert, expression, n.lineno, n.col_offset);
  }
  goog.asserts.fail('unhandled factor');
}
function astForForStmt(c, n) {
  var seq = [];
  REQ(n, SYM.for_stmt);
  if (NCH(n) === 9)
    seq = astForSuite(c, CHILD(n, 8));
  var nodeTarget = CHILD(n, 1);
  var _target = astForExprlist(c, nodeTarget, Store);
  var target;
  if (NCH(nodeTarget) === 1)
    target = _target[0];
  else
    target = new Tuple(_target, Store, n.lineno, n.col_offset);
  return new For_(target, astForTestlist(c, CHILD(n, 3)), astForSuite(c, CHILD(n, 5)), seq, n.lineno, n.col_offset);
}
function astForCall(c, n, func) {
  REQ(n, SYM.arglist);
  var nargs = 0;
  var nkeywords = 0;
  var ngens = 0;
  for (var i = 0; i < NCH(n); ++i) {
    var ch = CHILD(n, i);
    if (ch.type === SYM.argument) {
      if (NCH(ch) === 1)
        nargs++;
      else if (CHILD(ch, 1).type === SYM.gen_for)
        ngens++;
      else
        nkeywords++;
    }
  }
  if (ngens > 1 || ngens && (nargs || nkeywords))
    throw new Sk.builtin.SyntaxError('Generator expression must be parenthesized if not sole argument', c.c_filename, n.lineno);
  if (nargs + nkeywords + ngens > 255)
    throw new Sk.builtin.SyntaxError('more than 255 arguments', c.c_filename, n.lineno);
  var args = [];
  var keywords = [];
  nargs = 0;
  nkeywords = 0;
  var vararg = null;
  var kwarg = null;
  for (var i = 0; i < NCH(n); ++i) {
    var ch = CHILD(n, i);
    if (ch.type === SYM.argument) {
      if (NCH(ch) === 1) {
        if (nkeywords)
          throw new Sk.builtin.SyntaxError('non-keyword arg after keyword arg', c.c_filename, n.lineno);
        if (vararg)
          throw new Sk.builtin.SyntaxError('only named arguments may follow *expression', c.c_filename, n.lineno);
        args[nargs++] = astForExpr(c, CHILD(ch, 0));
      } else if (CHILD(ch, 1).type === SYM.gen_for)
        args[nargs++] = astForGenexp(c, ch);
      else {
        var e = astForExpr(c, CHILD(ch, 0));
        if (e.constructor === Lambda)
          throw new Sk.builtin.SyntaxError('lambda cannot contain assignment', c.c_filename, n.lineno);
        else if (e.constructor !== Name)
          throw new Sk.builtin.SyntaxError('keyword can\'t be an expression', c.c_filename, n.lineno);
        var key = e.id;
        forbiddenCheck(c, CHILD(ch, 0), key, n.lineno);
        for (var k = 0; k < nkeywords; ++k) {
          var tmp = keywords[k].arg;
          if (tmp === key)
            throw new Sk.builtin.SyntaxError('keyword argument repeated', c.c_filename, n.lineno);
        }
        keywords[nkeywords++] = new keyword(key, astForExpr(c, CHILD(ch, 2)));
      }
    } else if (ch.type === TOK.T_STAR)
      vararg = astForExpr(c, CHILD(n, ++i));
    else if (ch.type === TOK.T_DOUBLESTAR)
      kwarg = astForExpr(c, CHILD(n, ++i));
  }
  return new Call(func, args, keywords, vararg, kwarg, func.lineno, func.col_offset);
}
function astForTrailer(c, n, leftExpr) {
  REQ(n, SYM.trailer);
  if (CHILD(n, 0).type === TOK.T_LPAR) {
    if (NCH(n) === 2)
      return new Call(leftExpr, [], [], null, null, n.lineno, n.col_offset);
    else
      return astForCall(c, CHILD(n, 1), leftExpr);
  } else if (CHILD(n, 0).type === TOK.T_DOT)
    return new Attribute(leftExpr, strobj(CHILD(n, 1).value), Load, n.lineno, n.col_offset);
  else {
    REQ(CHILD(n, 0), TOK.T_LSQB);
    REQ(CHILD(n, 2), TOK.T_RSQB);
    n = CHILD(n, 1);
    if (NCH(n) === 1)
      return new Subscript(leftExpr, astForSlice(c, CHILD(n, 0)), Load, n.lineno, n.col_offset);
    else {
      var simple = true;
      var slices = [];
      for (var j = 0; j < NCH(n); j += 2) {
        var slc = astForSlice(c, CHILD(n, j));
        if (slc.constructor !== Index)
          simple = false;
        slices[j / 2] = slc;
      }
      if (!simple) {
        return new Subscript(leftExpr, new ExtSlice(slices), Load, n.lineno, n.col_offset);
      }
      var elts = [];
      for (var j = 0; j < slices.length; ++j) {
        var slc = slices[j];
        goog.asserts.assert(slc.constructor === Index && slc.value !== null && slc.value !== undefined);
        elts[j] = slc.value;
      }
      var e = new Tuple(elts, Load, n.lineno, n.col_offset);
      return new Subscript(leftExpr, new Index(e), Load, n.lineno, n.col_offset);
    }
  }
}
function astForFlowStmt(c, n) {
  var ch;
  REQ(n, SYM.flow_stmt);
  ch = CHILD(n, 0);
  switch (ch.type) {
  case SYM.break_stmt:
    return new Break_(n.lineno, n.col_offset);
  case SYM.continue_stmt:
    return new Continue_(n.lineno, n.col_offset);
  case SYM.yield_stmt:
    return new Expr(astForExpr(c, CHILD(ch, 0)), n.lineno, n.col_offset);
  case SYM.return_stmt:
    if (NCH(ch) === 1)
      return new Return_(null, n.lineno, n.col_offset);
    else
      return new Return_(astForTestlist(c, CHILD(ch, 1)), n.lineno, n.col_offset);
  case SYM.raise_stmt:
    if (NCH(ch) === 1)
      return new Raise(null, null, null, n.lineno, n.col_offset);
    else if (NCH(ch) === 2)
      return new Raise(astForExpr(c, CHILD(ch, 1)), null, null, n.lineno, n.col_offset);
    else if (NCH(ch) === 4)
      return new Raise(astForExpr(c, CHILD(ch, 1)), astForExpr(c, CHILD(ch, 3)), null, n.lineno, n.col_offset);
    else if (NCH(ch) === 6)
      return new Raise(astForExpr(c, CHILD(ch, 1)), astForExpr(c, CHILD(ch, 3)), astForExpr(c, CHILD(ch, 5)), n.lineno, n.col_offset);
  default:
    goog.asserts.fail('unexpected flow_stmt');
  }
  goog.asserts.fail('unhandled flow statement');
}
function astForArguments(c, n) {
  var ch;
  var vararg = null;
  var kwarg = null;
  if (n.type === SYM.parameters) {
    if (NCH(n) === 2)
      return new arguments_([], null, null, []);
    n = CHILD(n, 1);
  }
  REQ(n, SYM.varargslist);
  var args = [];
  var defaults = [];
  var foundDefault = false;
  var i = 0;
  var j = 0;
  var k = 0;
  while (i < NCH(n)) {
    ch = CHILD(n, i);
    switch (ch.type) {
    case SYM.fpdef:
      var complexArgs = 0;
      var parenthesized = 0;
      handle_fpdef:
        while (true) {
          if (i + 1 < NCH(n) && CHILD(n, i + 1).type === TOK.T_EQUAL) {
            defaults[j++] = astForExpr(c, CHILD(n, i + 2));
            i += 2;
            foundDefault = true;
          } else if (foundDefault) {
            if (parenthesized && !complexArgs)
              throw new Sk.builtin.SyntaxError('parenthesized arg with default', c.c_filename, n.lineno);
            throw new Sk.builtin.SyntaxError('non-default argument follows default argument', c.c_filename, n.lineno);
          }
          if (NCH(ch) === 3) {
            ch = CHILD(ch, 1);
            if (NCH(ch) !== 1) {
              throw new Sk.builtin.SyntaxError('tuple parameter unpacking has been removed', c.c_filename, n.lineno);
            } else {
              parenthesized = true;
              ch = CHILD(ch, 0);
              goog.asserts.assert(ch.type === SYM.fpdef);
              continue handle_fpdef;
            }
          }
          if (CHILD(ch, 0).type === TOK.T_NAME) {
            forbiddenCheck(c, n, CHILD(ch, 0).value, n.lineno);
            var id = strobj(CHILD(ch, 0).value);
            args[k++] = new Name(id, Param, ch.lineno, ch.col_offset);
          }
          i += 2;
          if (parenthesized)
            throw new Sk.builtin.SyntaxError('parenthesized argument names are invalid', c.c_filename, n.lineno);
          break;
        }
      break;
    case TOK.T_STAR:
      forbiddenCheck(c, CHILD(n, i + 1), CHILD(n, i + 1).value, n.lineno);
      vararg = strobj(CHILD(n, i + 1).value);
      i += 3;
      break;
    case TOK.T_DOUBLESTAR:
      forbiddenCheck(c, CHILD(n, i + 1), CHILD(n, i + 1).value, n.lineno);
      kwarg = strobj(CHILD(n, i + 1).value);
      i += 3;
      break;
    default:
      goog.asserts.fail('unexpected node in varargslist');
    }
  }
  return new arguments_(args, vararg, kwarg, defaults);
}
function astForFuncdef(c, n, decoratorSeq) {
  REQ(n, SYM.funcdef);
  var name = strobj(CHILD(n, 1).value);
  forbiddenCheck(c, CHILD(n, 1), CHILD(n, 1).value, n.lineno);
  var args = astForArguments(c, CHILD(n, 2));
  var body = astForSuite(c, CHILD(n, 4));
  return new FunctionDef(name, args, body, decoratorSeq, n.lineno, n.col_offset);
}
function astForClassBases(c, n) {
  goog.asserts.assert(NCH(n) > 0);
  REQ(n, SYM.testlist);
  if (NCH(n) === 1)
    return [astForExpr(c, CHILD(n, 0))];
  return seqForTestlist(c, n);
}
function astForClassdef(c, n, decoratorSeq) {
  REQ(n, SYM.classdef);
  forbiddenCheck(c, n, CHILD(n, 1).value, n.lineno);
  var classname = strobj(CHILD(n, 1).value);
  if (NCH(n) === 4)
    return new ClassDef(classname, [], astForSuite(c, CHILD(n, 3)), decoratorSeq, n.lineno, n.col_offset);
  if (CHILD(n, 3).type === TOK.T_RPAR)
    return new ClassDef(classname, [], astForSuite(c, CHILD(n, 5)), decoratorSeq, n.lineno, n.col_offset);
  var bases = astForClassBases(c, CHILD(n, 3));
  var s = astForSuite(c, CHILD(n, 6));
  return new ClassDef(classname, bases, s, decoratorSeq, n.lineno, n.col_offset);
}
function astForLambdef(c, n) {
  var args;
  var expression;
  if (NCH(n) === 3) {
    args = new arguments_([], null, null, []);
    expression = astForExpr(c, CHILD(n, 2));
  } else {
    args = astForArguments(c, CHILD(n, 1));
    expression = astForExpr(c, CHILD(n, 3));
  }
  return new Lambda(args, expression, n.lineno, n.col_offset);
}
function astForGenexp(c, n) {
  goog.asserts.assert(n.type === SYM.testlist_gexp || n.type === SYM.argument);
  goog.asserts.assert(NCH(n) > 1);
  function countGenFors(c, n) {
    var nfors = 0;
    var ch = CHILD(n, 1);
    count_gen_for:
      while (true) {
        nfors++;
        REQ(ch, SYM.gen_for);
        if (NCH(ch) === 5)
          ch = CHILD(ch, 4);
        else
          return nfors;
        count_gen_iter:
          while (true) {
            REQ(ch, SYM.gen_iter);
            ch = CHILD(ch, 0);
            if (ch.type === SYM.gen_for)
              continue count_gen_for;
            else if (ch.type === SYM.gen_if) {
              if (NCH(ch) === 3) {
                ch = CHILD(ch, 2);
                continue count_gen_iter;
              } else
                return nfors;
            }
            break;
          }
        break;
      }
    goog.asserts.fail('logic error in countGenFors');
  }
  function countGenIfs(c, n) {
    var nifs = 0;
    while (true) {
      REQ(n, SYM.gen_iter);
      if (CHILD(n, 0).type === SYM.gen_for)
        return nifs;
      n = CHILD(n, 0);
      REQ(n, SYM.gen_if);
      nifs++;
      if (NCH(n) == 2)
        return nifs;
      n = CHILD(n, 2);
    }
  }
  var elt = astForExpr(c, CHILD(n, 0));
  var nfors = countGenFors(c, n);
  var genexps = [];
  var ch = CHILD(n, 1);
  for (var i = 0; i < nfors; ++i) {
    REQ(ch, SYM.gen_for);
    var forch = CHILD(ch, 1);
    var t = astForExprlist(c, forch, Store);
    var expression = astForExpr(c, CHILD(ch, 3));
    var ge;
    if (NCH(forch) === 1)
      ge = new comprehension(t[0], expression, []);
    else
      ge = new comprehension(new Tuple(t, Store, ch.lineno, ch.col_offset), expression, []);
    if (NCH(ch) === 5) {
      ch = CHILD(ch, 4);
      var nifs = countGenIfs(c, ch);
      var ifs = [];
      for (var j = 0; j < nifs; ++j) {
        REQ(ch, SYM.gen_iter);
        ch = CHILD(ch, 0);
        REQ(ch, SYM.gen_if);
        expression = astForExpr(c, CHILD(ch, 1));
        ifs[j] = expression;
        if (NCH(ch) === 3)
          ch = CHILD(ch, 2);
      }
      if (ch.type === SYM.gen_iter)
        ch = CHILD(ch, 0);
      ge.ifs = ifs;
    }
    genexps[i] = ge;
  }
  return new GeneratorExp(elt, genexps, n.lineno, n.col_offset);
}
function astForWhileStmt(c, n) {
  REQ(n, SYM.while_stmt);
  if (NCH(n) === 4)
    return new While_(astForExpr(c, CHILD(n, 1)), astForSuite(c, CHILD(n, 3)), [], n.lineno, n.col_offset);
  else if (NCH(n) === 7)
    return new While_(astForExpr(c, CHILD(n, 1)), astForSuite(c, CHILD(n, 3)), astForSuite(c, CHILD(n, 6)), n.lineno, n.col_offset);
  goog.asserts.fail('wrong number of tokens for \'while\' stmt');
}
function astForAugassign(c, n) {
  REQ(n, SYM.augassign);
  n = CHILD(n, 0);
  switch (n.value.charAt(0)) {
  case '+':
    return Add;
  case '-':
    return Sub;
  case '/':
    if (n.value.charAt(1) === '/')
      return FloorDiv;
    return Div;
  case '%':
    return Mod;
  case '<':
    return LShift;
  case '>':
    return RShift;
  case '&':
    return BitAnd;
  case '^':
    return BitXor;
  case '|':
    return BitOr;
  case '*':
    if (n.value.charAt(1) === '*')
      return Pow;
    return Mult;
  default:
    goog.asserts.fail('invalid augassign');
  }
}
function astForBinop(c, n) {
  var result = new BinOp(astForExpr(c, CHILD(n, 0)), getOperator(CHILD(n, 1)), astForExpr(c, CHILD(n, 2)), n.lineno, n.col_offset);
  var nops = (NCH(n) - 1) / 2;
  for (var i = 1; i < nops; ++i) {
    var nextOper = CHILD(n, i * 2 + 1);
    var newoperator = getOperator(nextOper);
    var tmp = astForExpr(c, CHILD(n, i * 2 + 2));
    result = new BinOp(result, newoperator, tmp, nextOper.lineno, nextOper.col_offset);
  }
  return result;
}
function astForTestlist(c, n) {
  goog.asserts.assert(NCH(n) > 0);
  if (n.type === SYM.testlist_gexp) {
    if (NCH(n) > 1) {
      goog.asserts.assert(CHILD(n, 1).type !== SYM.gen_for);
    }
  } else {
    goog.asserts.assert(n.type === SYM.testlist || n.type === SYM.testlist_safe || n.type === SYM.testlist1);
  }
  if (NCH(n) === 1) {
    return astForExpr(c, CHILD(n, 0));
  } else {
    return new Tuple(seqForTestlist(c, n), Load, n.lineno, n.col_offset);
  }
}
function astForExprStmt(c, n) {
  REQ(n, SYM.expr_stmt);
  if (NCH(n) === 1)
    return new Expr(astForTestlist(c, CHILD(n, 0)), n.lineno, n.col_offset);
  else if (CHILD(n, 1).type === SYM.augassign) {
    var ch = CHILD(n, 0);
    var expr1 = astForTestlist(c, ch);
    switch (expr1.constructor) {
    case GeneratorExp:
      throw new Sk.builtin.SyntaxError('augmented assignment to generator expression not possible', c.c_filename, n.lineno);
    case Yield:
      throw new Sk.builtin.SyntaxError('augmented assignment to yield expression not possible', c.c_filename, n.lineno);
    case Name:
      var varName = expr1.id;
      forbiddenCheck(c, ch, varName, n.lineno);
      break;
    case Attribute:
    case Subscript:
      break;
    default:
      throw new Sk.builtin.SyntaxError('illegal expression for augmented assignment', c.c_filename, n.lineno);
    }
    setContext(c, expr1, Store, ch);
    ch = CHILD(n, 2);
    var expr2;
    if (ch.type === SYM.testlist)
      expr2 = astForTestlist(c, ch);
    else
      expr2 = astForExpr(c, ch);
    return new AugAssign(expr1, astForAugassign(c, CHILD(n, 1)), expr2, n.lineno, n.col_offset);
  } else {
    REQ(CHILD(n, 1), TOK.T_EQUAL);
    var targets = [];
    for (var i = 0; i < NCH(n) - 2; i += 2) {
      var ch = CHILD(n, i);
      if (ch.type === SYM.yield_expr)
        throw new Sk.builtin.SyntaxError('assignment to yield expression not possible', c.c_filename, n.lineno);
      var e = astForTestlist(c, ch);
      setContext(c, e, Store, CHILD(n, i));
      targets[i / 2] = e;
    }
    var value = CHILD(n, NCH(n) - 1);
    var expression;
    if (value.type === SYM.testlist)
      expression = astForTestlist(c, value);
    else
      expression = astForExpr(c, value);
    return new Assign(targets, expression, n.lineno, n.col_offset);
  }
}
function astForIfexpr(c, n) {
  goog.asserts.assert(NCH(n) === 5);
  return new IfExp(astForExpr(c, CHILD(n, 2)), astForExpr(c, CHILD(n, 0)), astForExpr(c, CHILD(n, 4)), n.lineno, n.col_offset);
}
function parsestr(c, s) {
  var encodeUtf8 = function (s) {
    return unescape(encodeURIComponent(s));
  };
  var decodeUtf8 = function (s) {
    return decodeURIComponent(escape(s));
  };
  var decodeEscape = function (s, quote) {
    var len = s.length;
    var ret = '';
    for (var i = 0; i < len; ++i) {
      var c = s.charAt(i);
      if (c === '\\') {
        ++i;
        c = s.charAt(i);
        if (c === 'n')
          ret += '\n';
        else if (c === '\\')
          ret += '\\';
        else if (c === 't')
          ret += '\t';
        else if (c === 'r')
          ret += '\r';
        else if (c === 'b')
          ret += '\b';
        else if (c === 'f')
          ret += '\f';
        else if (c === 'v')
          ret += '\x0B';
        else if (c === '0')
          ret += '\0';
        else if (c === '"')
          ret += '"';
        else if (c === '\'')
          ret += '\'';
        else if (c === '\n') {
        } else if (c === 'x') {
          var d0 = s.charAt(++i);
          var d1 = s.charAt(++i);
          ret += String.fromCharCode(parseInt(d0 + d1, 16));
        } else if (c === 'u' || c === 'U') {
          var d0 = s.charAt(++i);
          var d1 = s.charAt(++i);
          var d2 = s.charAt(++i);
          var d3 = s.charAt(++i);
          ret += String.fromCharCode(parseInt(d0 + d1, 16), parseInt(d2 + d3, 16));
        } else {
          ret += '\\' + c;
        }
      } else {
        ret += c;
      }
    }
    return ret;
  };
  var quote = s.charAt(0);
  var rawmode = false;
  if (quote === 'u' || quote === 'U') {
    s = s.substr(1);
    quote = s.charAt(0);
  } else if (quote === 'r' || quote === 'R') {
    s = s.substr(1);
    quote = s.charAt(0);
    rawmode = true;
  }
  goog.asserts.assert(quote !== 'b' && quote !== 'B', 'todo; haven\'t done b\'\' strings yet');
  goog.asserts.assert(quote === '\'' || quote === '"' && s.charAt(s.length - 1) === quote);
  s = s.substr(1, s.length - 2);
  if (s.length >= 4 && s.charAt(0) === quote && s.charAt(1) === quote) {
    goog.asserts.assert(s.charAt(s.length - 1) === quote && s.charAt(s.length - 2) === quote);
    s = s.substr(2, s.length - 4);
  }
  if (rawmode || s.indexOf('\\') === -1) {
    return strobj(decodeUtf8(s));
  }
  return strobj(decodeEscape(s, quote));
}
function parsestrplus(c, n) {
  REQ(CHILD(n, 0), TOK.T_STRING);
  var ret = new Sk.builtin.str('');
  for (var i = 0; i < NCH(n); ++i) {
    try {
      ret = ret.sq$concat(parsestr(c, CHILD(n, i).value));
    } catch (x) {
      throw new Sk.builtin.SyntaxError('invalid string (possibly contains a unicode character)', c.c_filename, CHILD(n, i).lineno);
    }
  }
  return ret;
}
function parsenumber(c, s, lineno) {
  var end = s.charAt(s.length - 1);
  if (end === 'j' || end === 'J') {
    throw new Sk.builtin.SyntaxError('complex numbers are currently unsupported', c.c_filename, lineno);
  }
  if (end === 'l' || end === 'L') {
    return Sk.longFromStr(s.substr(0, s.length - 1), 0);
  }
  if (s.indexOf('.') !== -1) {
    return new Sk.builtin.nmber(parseFloat(s), Sk.builtin.nmber.float$);
  }
  var tmp = s;
  var val;
  var neg = false;
  if (s.charAt(0) === '-') {
    tmp = s.substr(1);
    neg = true;
  }
  if (tmp.charAt(0) === '0' && (tmp.charAt(1) === 'x' || tmp.charAt(1) === 'X')) {
    tmp = tmp.substring(2);
    val = parseInt(tmp, 16);
  } else if (s.indexOf('e') !== -1 || s.indexOf('E') !== -1) {
    return new Sk.builtin.nmber(parseFloat(s), Sk.builtin.nmber.float$);
  } else if (tmp.charAt(0) === '0' && (tmp.charAt(1) === 'b' || tmp.charAt(1) === 'B')) {
    tmp = tmp.substring(2);
    val = parseInt(tmp, 2);
  } else if (tmp.charAt(0) === '0') {
    if (tmp === '0') {
      val = 0;
    } else {
      tmp = tmp.substring(1);
      if (tmp.charAt(0) === 'o' || tmp.charAt(0) === 'O') {
        tmp = tmp.substring(1);
      }
      val = parseInt(tmp, 8);
    }
  } else {
    val = parseInt(tmp, 10);
  }
  if (val > Sk.builtin.lng.threshold$ && Math.floor(val) === val && (s.indexOf('e') === -1 && s.indexOf('E') === -1)) {
    return Sk.longFromStr(s, 0);
  }
  if (neg) {
    return new Sk.builtin.nmber(-val, Sk.builtin.int$);
  } else {
    return new Sk.builtin.nmber(val, Sk.builtin.int$);
  }
}
function astForSlice(c, n) {
  REQ(n, SYM.subscript);
  var ch = CHILD(n, 0);
  var lower = null;
  var upper = null;
  var step = null;
  if (ch.type === TOK.T_DOT)
    return new Ellipsis();
  if (NCH(n) === 1 && ch.type === SYM.test)
    return new Index(astForExpr(c, ch));
  if (ch.type === SYM.test)
    lower = astForExpr(c, ch);
  if (ch.type === TOK.T_COLON) {
    if (NCH(n) > 1) {
      var n2 = CHILD(n, 1);
      if (n2.type === SYM.test)
        upper = astForExpr(c, n2);
    }
  } else if (NCH(n) > 2) {
    var n2 = CHILD(n, 2);
    if (n2.type === SYM.test)
      upper = astForExpr(c, n2);
  }
  ch = CHILD(n, NCH(n) - 1);
  if (ch.type === SYM.sliceop) {
    if (NCH(ch) === 1) {
      ch = CHILD(ch, 0);
      step = new Name(strobj('None'), Load, ch.lineno, ch.col_offset);
    } else {
      ch = CHILD(ch, 1);
      if (ch.type === SYM.test)
        step = astForExpr(c, ch);
    }
  }
  return new Slice(lower, upper, step);
}
function astForAtom(c, n) {
  var ch = CHILD(n, 0);
  switch (ch.type) {
  case TOK.T_NAME:
    return new Name(strobj(ch.value), Load, n.lineno, n.col_offset);
  case TOK.T_STRING:
    return new Str(parsestrplus(c, n), n.lineno, n.col_offset);
  case TOK.T_NUMBER:
    return new Num(parsenumber(c, ch.value, n.lineno), n.lineno, n.col_offset);
  case TOK.T_LPAR:
    ch = CHILD(n, 1);
    if (ch.type === TOK.T_RPAR)
      return new Tuple([], Load, n.lineno, n.col_offset);
    if (ch.type === SYM.yield_expr)
      return astForExpr(c, ch);
    if (NCH(ch) > 1 && CHILD(ch, 1).type === SYM.gen_for)
      return astForGenexp(c, ch);
    return astForTestlistGexp(c, ch);
  case TOK.T_LSQB:
    ch = CHILD(n, 1);
    if (ch.type === TOK.T_RSQB)
      return new List([], Load, n.lineno, n.col_offset);
    REQ(ch, SYM.listmaker);
    if (NCH(ch) === 1 || CHILD(ch, 1).type === TOK.T_COMMA)
      return new List(seqForTestlist(c, ch), Load, n.lineno, n.col_offset);
    else
      return astForListcomp(c, ch);
  case TOK.T_LBRACE:
    ch = CHILD(n, 1);
    var size = Math.floor((NCH(ch) + 1) / 4);
    var keys = [];
    var values = [];
    for (var i = 0; i < NCH(ch); i += 4) {
      keys[i / 4] = astForExpr(c, CHILD(ch, i));
      values[i / 4] = astForExpr(c, CHILD(ch, i + 2));
    }
    return new Dict(keys, values, n.lineno, n.col_offset);
  case TOK.T_BACKQUOTE:
    throw new Sk.builtin.SyntaxError('backquote not supported, use repr()', c.c_filename, n.lineno);
  default:
    goog.asserts.fail('unhandled atom', ch.type);
  }
}
function astForPower(c, n) {
  REQ(n, SYM.power);
  var e = astForAtom(c, CHILD(n, 0));
  if (NCH(n) === 1)
    return e;
  for (var i = 1; i < NCH(n); ++i) {
    var ch = CHILD(n, i);
    if (ch.type !== SYM.trailer)
      break;
    var tmp = astForTrailer(c, ch, e);
    tmp.lineno = e.lineno;
    tmp.col_offset = e.col_offset;
    e = tmp;
  }
  if (CHILD(n, NCH(n) - 1).type === SYM.factor) {
    var f = astForExpr(c, CHILD(n, NCH(n) - 1));
    e = new BinOp(e, Pow, f, n.lineno, n.col_offset);
  }
  return e;
}
function astForExpr(c, n) {
  LOOP:
    while (true) {
      switch (n.type) {
      case SYM.test:
      case SYM.old_test:
        if (CHILD(n, 0).type === SYM.lambdef || CHILD(n, 0).type === SYM.old_lambdef)
          return astForLambdef(c, CHILD(n, 0));
        else if (NCH(n) > 1)
          return astForIfexpr(c, n);
      case SYM.or_test:
      case SYM.and_test:
        if (NCH(n) === 1) {
          n = CHILD(n, 0);
          continue LOOP;
        }
        var seq = [];
        for (var i = 0; i < NCH(n); i += 2)
          seq[i / 2] = astForExpr(c, CHILD(n, i));
        if (CHILD(n, 1).value === 'and')
          return new BoolOp(And, seq, n.lineno, n.col_offset);
        goog.asserts.assert(CHILD(n, 1).value === 'or');
        return new BoolOp(Or, seq, n.lineno, n.col_offset);
      case SYM.not_test:
        if (NCH(n) === 1) {
          n = CHILD(n, 0);
          continue LOOP;
        } else {
          return new UnaryOp(Not, astForExpr(c, CHILD(n, 1)), n.lineno, n.col_offset);
        }
      case SYM.comparison:
        if (NCH(n) === 1) {
          n = CHILD(n, 0);
          continue LOOP;
        } else {
          var ops = [];
          var cmps = [];
          for (var i = 1; i < NCH(n); i += 2) {
            ops[(i - 1) / 2] = astForCompOp(c, CHILD(n, i));
            cmps[(i - 1) / 2] = astForExpr(c, CHILD(n, i + 1));
          }
          return new Compare(astForExpr(c, CHILD(n, 0)), ops, cmps, n.lineno, n.col_offset);
        }
      case SYM.expr:
      case SYM.xor_expr:
      case SYM.and_expr:
      case SYM.shift_expr:
      case SYM.arith_expr:
      case SYM.term:
        if (NCH(n) === 1) {
          n = CHILD(n, 0);
          continue LOOP;
        }
        return astForBinop(c, n);
      case SYM.yield_expr:
        var exp = null;
        if (NCH(n) === 2) {
          exp = astForTestlist(c, CHILD(n, 1));
        }
        return new Yield(exp, n.lineno, n.col_offset);
      case SYM.factor:
        if (NCH(n) === 1) {
          n = CHILD(n, 0);
          continue LOOP;
        }
        return astForFactor(c, n);
      case SYM.power:
        return astForPower(c, n);
      default:
        goog.asserts.fail('unhandled expr', 'n.type: %d', n.type);
      }
      break;
    }
}
function astForPrintStmt(c, n) {
  var start = 1;
  var dest = null;
  REQ(n, SYM.print_stmt);
  if (NCH(n) >= 2 && CHILD(n, 1).type === TOK.T_RIGHTSHIFT) {
    dest = astForExpr(c, CHILD(n, 2));
    start = 4;
  }
  var seq = [];
  for (var i = start, j = 0; i < NCH(n); i += 2, ++j) {
    seq[j] = astForExpr(c, CHILD(n, i));
  }
  var nl = CHILD(n, NCH(n) - 1).type === TOK.T_COMMA ? false : true;
  return new Print(dest, seq, nl, n.lineno, n.col_offset);
}
function astForStmt(c, n) {
  if (n.type === SYM.stmt) {
    goog.asserts.assert(NCH(n) === 1);
    n = CHILD(n, 0);
  }
  if (n.type === SYM.simple_stmt) {
    goog.asserts.assert(numStmts(n) === 1);
    n = CHILD(n, 0);
  }
  if (n.type === SYM.small_stmt) {
    REQ(n, SYM.small_stmt);
    n = CHILD(n, 0);
    switch (n.type) {
    case SYM.expr_stmt:
      return astForExprStmt(c, n);
    case SYM.print_stmt:
      return astForPrintStmt(c, n);
    case SYM.del_stmt:
      return astForDelStmt(c, n);
    case SYM.pass_stmt:
      return new Pass(n.lineno, n.col_offset);
    case SYM.flow_stmt:
      return astForFlowStmt(c, n);
    case SYM.import_stmt:
      return astForImportStmt(c, n);
    case SYM.global_stmt:
      return astForGlobalStmt(c, n);
    case SYM.exec_stmt:
      return astForExecStmt(c, n);
    case SYM.assert_stmt:
      return astForAssertStmt(c, n);
    default:
      goog.asserts.fail('unhandled small_stmt');
    }
  } else {
    var ch = CHILD(n, 0);
    REQ(n, SYM.compound_stmt);
    switch (ch.type) {
    case SYM.if_stmt:
      return astForIfStmt(c, ch);
    case SYM.while_stmt:
      return astForWhileStmt(c, ch);
    case SYM.for_stmt:
      return astForForStmt(c, ch);
    case SYM.try_stmt:
      return astForTryStmt(c, ch);
    case SYM.with_stmt:
      return astForWithStmt(c, ch);
    case SYM.funcdef:
      return astForFuncdef(c, ch, []);
    case SYM.classdef:
      return astForClassdef(c, ch, []);
    case SYM.decorated:
      return astForDecorated(c, ch);
    default:
      goog.asserts.assert('unhandled compound_stmt');
    }
  }
}
Sk.astFromParse = function (n, filename) {
  var c = new Compiling('utf-8', filename);
  var stmts = [];
  var ch;
  var k = 0;
  switch (n.type) {
  case SYM.file_input:
    for (var i = 0; i < NCH(n) - 1; ++i) {
      var ch = CHILD(n, i);
      if (n.type === TOK.T_NEWLINE)
        continue;
      REQ(ch, SYM.stmt);
      var num = numStmts(ch);
      if (num === 1) {
        stmts[k++] = astForStmt(c, ch);
      } else {
        ch = CHILD(ch, 0);
        REQ(ch, SYM.simple_stmt);
        for (var j = 0; j < num; ++j) {
          stmts[k++] = astForStmt(c, CHILD(ch, j * 2));
        }
      }
    }
    return new Module(stmts);
  case SYM.eval_input:
    goog.asserts.fail('todo;');
  case SYM.single_input:
    goog.asserts.fail('todo;');
  default:
    goog.asserts.fail('todo;');
  }
};
Sk.astDump = function (node) {
  var spaces = function (n) {
    var ret = '';
    for (var i = 0; i < n; ++i)
      ret += ' ';
    return ret;
  };
  var _format = function (node, indent) {
    if (node === null) {
      return indent + 'None';
    } else if (node.prototype && node.prototype._astname !== undefined && node.prototype._isenum) {
      return indent + node.prototype._astname + '()';
    } else if (node._astname !== undefined) {
      var namelen = spaces(node._astname.length + 1);
      var fields = [];
      for (var i = 0; i < node._fields.length; i += 2) {
        var a = node._fields[i];
        var b = node._fields[i + 1](node);
        var fieldlen = spaces(a.length + 1);
        fields.push([
          a,
          _format(b, indent + namelen + fieldlen)
        ]);
      }
      var attrs = [];
      for (var i = 0; i < fields.length; ++i) {
        var field = fields[i];
        attrs.push(field[0] + '=' + field[1].replace(/^\s+/, ''));
      }
      var fieldstr = attrs.join(',\n' + indent + namelen);
      return indent + node._astname + '(' + fieldstr + ')';
    } else if (goog.isArrayLike(node)) {
      var elems = [];
      for (var i = 0; i < node.length; ++i) {
        var x = node[i];
        elems.push(_format(x, indent + ' '));
      }
      var elemsstr = elems.join(',\n');
      return indent + '[' + elemsstr.replace(/^\s+/, '') + ']';
    } else {
      var ret;
      if (node === true)
        ret = 'True';
      else if (node === false)
        ret = 'False';
      else if (node instanceof Sk.builtin.lng)
        ret = node.tp$str().v;
      else if (node instanceof Sk.builtin.str)
        ret = node['$r']().v;
      else
        ret = '' + node;
      return indent + ret;
    }
  };
  return _format(node, '');
};
goog.exportSymbol('Sk.astFromParse', Sk.astFromParse);
goog.exportSymbol('Sk.astDump', Sk.astDump);
var DEF_GLOBAL = 1;
var DEF_LOCAL = 2;
var DEF_PARAM = 2 << 1;
var USE = 2 << 2;
var DEF_STAR = 2 << 3;
var DEF_DOUBLESTAR = 2 << 4;
var DEF_INTUPLE = 2 << 5;
var DEF_FREE = 2 << 6;
var DEF_FREE_GLOBAL = 2 << 7;
var DEF_FREE_CLASS = 2 << 8;
var DEF_IMPORT = 2 << 9;
var DEF_BOUND = DEF_LOCAL | DEF_PARAM | DEF_IMPORT;
var SCOPE_OFF = 11;
var SCOPE_MASK = 7;
var LOCAL = 1;
var GLOBAL_EXPLICIT = 2;
var GLOBAL_IMPLICIT = 3;
var FREE = 4;
var CELL = 5;
var OPT_IMPORT_STAR = 1;
var OPT_EXEC = 2;
var OPT_BARE_EXEC = 4;
var OPT_TOPLEVEL = 8;
var GENERATOR = 2;
var GENERATOR_EXPRESSION = 2;
var ModuleBlock = 'module';
var FunctionBlock = 'function';
var ClassBlock = 'class';
function Symbol(name, flags, namespaces) {
  this.__name = name;
  this.__flags = flags;
  this.__scope = flags >> SCOPE_OFF & SCOPE_MASK;
  this.__namespaces = namespaces || [];
}
;
Symbol.prototype.get_name = function () {
  return this.__name;
};
Symbol.prototype.is_referenced = function () {
  return !!(this.__flags & USE);
};
Symbol.prototype.is_parameter = function () {
  return !!(this.__flags & DEF_PARAM);
};
Symbol.prototype.is_global = function () {
  return this.__scope === GLOBAL_IMPLICIT || this.__scope == GLOBAL_EXPLICIT;
};
Symbol.prototype.is_declared_global = function () {
  return this.__scope == GLOBAL_EXPLICIT;
};
Symbol.prototype.is_local = function () {
  return !!(this.__flags & DEF_BOUND);
};
Symbol.prototype.is_free = function () {
  return this.__scope == FREE;
};
Symbol.prototype.is_imported = function () {
  return !!(this.__flags & DEF_IMPORT);
};
Symbol.prototype.is_assigned = function () {
  return !!(this.__flags & DEF_LOCAL);
};
Symbol.prototype.is_namespace = function () {
  return this.__namespaces && this.__namespaces.length > 0;
};
Symbol.prototype.get_namespaces = function () {
  return this.__namespaces;
};
var astScopeCounter = 0;
function SymbolTableScope(table, name, type, ast, lineno) {
  this.symFlags = {};
  this.name = name;
  this.varnames = [];
  this.children = [];
  this.blockType = type;
  this.isNested = false;
  this.hasFree = false;
  this.childHasFree = false;
  this.generator = false;
  this.varargs = false;
  this.varkeywords = false;
  this.returnsValue = false;
  this.lineno = lineno;
  this.table = table;
  if (table.cur && (table.cur.nested || table.cur.blockType === FunctionBlock))
    this.isNested = true;
  ast.scopeId = astScopeCounter++;
  table.stss[ast.scopeId] = this;
  this.symbols = {};
}
SymbolTableScope.prototype.get_type = function () {
  return this.blockType;
};
SymbolTableScope.prototype.get_name = function () {
  return this.name;
};
SymbolTableScope.prototype.get_lineno = function () {
  return this.lineno;
};
SymbolTableScope.prototype.is_nested = function () {
  return this.isNested;
};
SymbolTableScope.prototype.has_children = function () {
  return this.children.length > 0;
};
SymbolTableScope.prototype.get_identifiers = function () {
  return this._identsMatching(function (x) {
    return true;
  });
};
SymbolTableScope.prototype.lookup = function (name) {
  var sym;
  if (!this.symbols.hasOwnProperty(name)) {
    var flags = this.symFlags[name];
    var namespaces = this.__check_children(name);
    sym = this.symbols[name] = new Symbol(name, flags, namespaces);
  } else {
    sym = this.symbols[name];
  }
  return sym;
};
SymbolTableScope.prototype.__check_children = function (name) {
  var ret = [];
  for (var i = 0; i < this.children.length; ++i) {
    var child = this.children[i];
    if (child.name === name)
      ret.push(child);
  }
  return ret;
};
SymbolTableScope.prototype._identsMatching = function (f) {
  var ret = [];
  for (var k in this.symFlags) {
    if (this.symFlags.hasOwnProperty(k)) {
      if (f(this.symFlags[k]))
        ret.push(k);
    }
  }
  ret.sort();
  return ret;
};
SymbolTableScope.prototype.get_parameters = function () {
  goog.asserts.assert(this.get_type() == 'function', 'get_parameters only valid for function scopes');
  if (!this._funcParams)
    this._funcParams = this._identsMatching(function (x) {
      return x & DEF_PARAM;
    });
  return this._funcParams;
};
SymbolTableScope.prototype.get_locals = function () {
  goog.asserts.assert(this.get_type() == 'function', 'get_locals only valid for function scopes');
  if (!this._funcLocals)
    this._funcLocals = this._identsMatching(function (x) {
      return x & DEF_BOUND;
    });
  return this._funcLocals;
};
SymbolTableScope.prototype.get_globals = function () {
  goog.asserts.assert(this.get_type() == 'function', 'get_globals only valid for function scopes');
  if (!this._funcGlobals) {
    this._funcGlobals = this._identsMatching(function (x) {
      var masked = x >> SCOPE_OFF & SCOPE_MASK;
      return masked == GLOBAL_IMPLICIT || masked == GLOBAL_EXPLICIT;
    });
  }
  return this._funcGlobals;
};
SymbolTableScope.prototype.get_frees = function () {
  goog.asserts.assert(this.get_type() == 'function', 'get_frees only valid for function scopes');
  if (!this._funcFrees) {
    this._funcFrees = this._identsMatching(function (x) {
      var masked = x >> SCOPE_OFF & SCOPE_MASK;
      return masked == FREE;
    });
  }
  return this._funcFrees;
};
SymbolTableScope.prototype.get_methods = function () {
  goog.asserts.assert(this.get_type() == 'class', 'get_methods only valid for class scopes');
  if (!this._classMethods) {
    var all = [];
    for (var i = 0; i < this.children.length; ++i)
      all.push(this.children[i].name);
    all.sort();
    this._classMethods = all;
  }
  return this._classMethods;
};
SymbolTableScope.prototype.getScope = function (name) {
  var v = this.symFlags[name];
  if (v === undefined)
    return 0;
  return v >> SCOPE_OFF & SCOPE_MASK;
};
function SymbolTable(filename) {
  this.filename = filename;
  this.cur = null;
  this.top = null;
  this.stack = [];
  this.global = null;
  this.curClass = null;
  this.tmpname = 0;
  this.stss = {};
}
SymbolTable.prototype.getStsForAst = function (ast) {
  goog.asserts.assert(ast.scopeId !== undefined, 'ast wasn\'t added to st?');
  var v = this.stss[ast.scopeId];
  goog.asserts.assert(v !== undefined, 'unknown sym tab entry');
  return v;
};
SymbolTable.prototype.SEQStmt = function (nodes) {
  goog.asserts.assert(goog.isArrayLike(nodes), 'SEQ: nodes isn\'t array? got %s', nodes);
  var len = nodes.length;
  for (var i = 0; i < len; ++i) {
    var val = nodes[i];
    if (val)
      this.visitStmt(val);
  }
};
SymbolTable.prototype.SEQExpr = function (nodes) {
  goog.asserts.assert(goog.isArrayLike(nodes), 'SEQ: nodes isn\'t array? got %s', nodes);
  var len = nodes.length;
  for (var i = 0; i < len; ++i) {
    var val = nodes[i];
    if (val)
      this.visitExpr(val);
  }
};
SymbolTable.prototype.enterBlock = function (name, blockType, ast, lineno) {
  name = fixReservedNames(name);
  var prev = null;
  if (this.cur) {
    prev = this.cur;
    this.stack.push(this.cur);
  }
  this.cur = new SymbolTableScope(this, name, blockType, ast, lineno);
  if (name === 'top') {
    this.global = this.cur.symFlags;
  }
  if (prev) {
    prev.children.push(this.cur);
  }
};
SymbolTable.prototype.exitBlock = function () {
  this.cur = null;
  if (this.stack.length > 0)
    this.cur = this.stack.pop();
};
SymbolTable.prototype.visitParams = function (args, toplevel) {
  for (var i = 0; i < args.length; ++i) {
    var arg = args[i];
    if (arg.constructor === Name) {
      goog.asserts.assert(arg.ctx === Param || arg.ctx === Store && !toplevel);
      this.addDef(arg.id, DEF_PARAM, arg.lineno);
    } else {
      throw new Sk.builtin.SyntaxError('invalid expression in parameter list', this.filename);
    }
  }
};
SymbolTable.prototype.visitArguments = function (a, lineno) {
  if (a.args)
    this.visitParams(a.args, true);
  if (a.vararg) {
    this.addDef(a.vararg, DEF_PARAM, lineno);
    this.cur.varargs = true;
  }
  if (a.kwarg) {
    this.addDef(a.kwarg, DEF_PARAM, lineno);
    this.cur.varkeywords = true;
  }
};
SymbolTable.prototype.newTmpname = function (lineno) {
  this.addDef(new Sk.builtin.str('_[' + ++this.tmpname + ']'), DEF_LOCAL, lineno);
};
SymbolTable.prototype.addDef = function (name, flag, lineno) {
  var mangled = mangleName(this.curClass, new Sk.builtin.str(name)).v;
  mangled = fixReservedNames(mangled);
  var val = this.cur.symFlags[mangled];
  if (val !== undefined) {
    if (flag & DEF_PARAM && val & DEF_PARAM) {
      throw new Sk.builtin.SyntaxError('duplicate argument \'' + name.v + '\' in function definition', this.filename, lineno);
    }
    val |= flag;
  } else {
    val = flag;
  }
  this.cur.symFlags[mangled] = val;
  if (flag & DEF_PARAM) {
    this.cur.varnames.push(mangled);
  } else if (flag & DEF_GLOBAL) {
    val = flag;
    var fromGlobal = this.global[mangled];
    if (fromGlobal !== undefined)
      val |= fromGlobal;
    this.global[mangled] = val;
  }
};
SymbolTable.prototype.visitSlice = function (s) {
  switch (s.constructor) {
  case Slice:
    if (s.lower)
      this.visitExpr(s.lower);
    if (s.upper)
      this.visitExpr(s.upper);
    if (s.step)
      this.visitExpr(s.step);
    break;
  case ExtSlice:
    for (var i = 0; i < s.dims.length; ++i)
      this.visitSlice(s.dims[i]);
    break;
  case Index:
    this.visitExpr(s.value);
    break;
  case Ellipsis:
    break;
  }
};
SymbolTable.prototype.visitStmt = function (s) {
  goog.asserts.assert(s !== undefined, 'visitStmt called with undefined');
  switch (s.constructor) {
  case FunctionDef:
    this.addDef(s.name, DEF_LOCAL, s.lineno);
    if (s.args.defaults)
      this.SEQExpr(s.args.defaults);
    if (s.decorator_list)
      this.SEQExpr(s.decorator_list);
    this.enterBlock(s.name.v, FunctionBlock, s, s.lineno);
    this.visitArguments(s.args, s.lineno);
    this.SEQStmt(s.body);
    this.exitBlock();
    break;
  case ClassDef:
    this.addDef(s.name, DEF_LOCAL, s.lineno);
    this.SEQExpr(s.bases);
    if (s.decorator_list)
      this.SEQExpr(s.decorator_list);
    this.enterBlock(s.name.v, ClassBlock, s, s.lineno);
    var tmp = this.curClass;
    this.curClass = s.name;
    this.SEQStmt(s.body);
    this.curCalss = tmp;
    this.exitBlock();
    break;
  case Return_:
    if (s.value) {
      this.visitExpr(s.value);
      this.cur.returnsValue = true;
      if (this.cur.generator)
        throw new Sk.builtin.SyntaxError('\'return\' with argument inside generator', this.filename);
    }
    break;
  case Delete_:
    this.SEQExpr(s.targets);
    break;
  case Assign:
    this.SEQExpr(s.targets);
    this.visitExpr(s.value);
    break;
  case AugAssign:
    this.visitExpr(s.target);
    this.visitExpr(s.value);
    break;
  case Print:
    if (s.dest)
      this.visitExpr(s.dest);
    this.SEQExpr(s.values);
    break;
  case For_:
    this.visitExpr(s.target);
    this.visitExpr(s.iter);
    this.SEQStmt(s.body);
    if (s.orelse)
      this.SEQStmt(s.orelse);
    break;
  case While_:
    this.visitExpr(s.test);
    this.SEQStmt(s.body);
    if (s.orelse)
      this.SEQStmt(s.orelse);
    break;
  case If_:
    this.visitExpr(s.test);
    this.SEQStmt(s.body);
    if (s.orelse)
      this.SEQStmt(s.orelse);
    break;
  case Raise:
    if (s.type) {
      this.visitExpr(s.type);
      if (s.inst) {
        this.visitExpr(s.inst);
        if (s.tback)
          this.visitExpr(s.tback);
      }
    }
    break;
  case TryExcept:
    this.SEQStmt(s.body);
    this.SEQStmt(s.orelse);
    this.visitExcepthandlers(s.handlers);
    break;
  case TryFinally:
    this.SEQStmt(s.body);
    this.SEQStmt(s.finalbody);
    break;
  case Assert:
    this.visitExpr(s.test);
    if (s.msg)
      this.visitExpr(s.msg);
    break;
  case Import_:
  case ImportFrom:
    this.visitAlias(s.names, s.lineno);
    break;
  case Exec:
    this.visitExpr(s.body);
    if (s.globals) {
      this.visitExpr(s.globals);
      if (s.locals)
        this.visitExpr(s.locals);
    }
    break;
  case Global:
    var nameslen = s.names.length;
    for (var i = 0; i < nameslen; ++i) {
      var name = mangleName(this.curClass, s.names[i]).v;
      name = fixReservedNames(name);
      var cur = this.cur.symFlags[name];
      if (cur & (DEF_LOCAL | USE)) {
        if (cur & DEF_LOCAL) {
          throw new Sk.builtin.SyntaxError('name \'' + name + '\' is assigned to before global declaration', this.filename, s.lineno);
        } else
          throw new Sk.builtin.SyntaxError('name \'' + name + '\' is used prior to global declaration', this.filename, s.lineno);
      }
      this.addDef(new Sk.builtin.str(name), DEF_GLOBAL, s.lineno);
    }
    break;
  case Expr:
    this.visitExpr(s.value);
    break;
  case Pass:
  case Break_:
  case Continue_:
    break;
  case With_:
    this.newTmpname(s.lineno);
    this.visitExpr(s.context_expr);
    if (s.optional_vars) {
      this.newTmpname(s.lineno);
      this.visitExpr(s.optional_vars);
    }
    this.SEQStmt(s.body);
    break;
  default:
    goog.asserts.fail('Unhandled type ' + s.constructor.name + ' in visitStmt');
  }
};
SymbolTable.prototype.visitExpr = function (e) {
  goog.asserts.assert(e !== undefined, 'visitExpr called with undefined');
  switch (e.constructor) {
  case BoolOp:
    this.SEQExpr(e.values);
    break;
  case BinOp:
    this.visitExpr(e.left);
    this.visitExpr(e.right);
    break;
  case UnaryOp:
    this.visitExpr(e.operand);
    break;
  case Lambda:
    this.addDef(new Sk.builtin.str('lambda'), DEF_LOCAL, e.lineno);
    if (e.args.defaults)
      this.SEQExpr(e.args.defaults);
    this.enterBlock('lambda', FunctionBlock, e, e.lineno);
    this.visitArguments(e.args, e.lineno);
    this.visitExpr(e.body);
    this.exitBlock();
    break;
  case IfExp:
    this.visitExpr(e.test);
    this.visitExpr(e.body);
    this.visitExpr(e.orelse);
    break;
  case Dict:
    this.SEQExpr(e.keys);
    this.SEQExpr(e.values);
    break;
  case ListComp:
    this.newTmpname(e.lineno);
    this.visitExpr(e.elt);
    this.visitComprehension(e.generators, 0);
    break;
  case GeneratorExp:
    this.visitGenexp(e);
    break;
  case Yield:
    if (e.value)
      this.visitExpr(e.value);
    this.cur.generator = true;
    if (this.cur.returnsValue)
      throw new Sk.builtin.SyntaxError('\'return\' with argument inside generator', this.filename);
    break;
  case Compare:
    this.visitExpr(e.left);
    this.SEQExpr(e.comparators);
    break;
  case Call:
    this.visitExpr(e.func);
    this.SEQExpr(e.args);
    for (var i = 0; i < e.keywords.length; ++i)
      this.visitExpr(e.keywords[i].value);
    if (e.starargs)
      this.visitExpr(e.starargs);
    if (e.kwargs)
      this.visitExpr(e.kwargs);
    break;
  case Num:
  case Str:
    break;
  case Attribute:
    this.visitExpr(e.value);
    break;
  case Subscript:
    this.visitExpr(e.value);
    this.visitSlice(e.slice);
    break;
  case Name:
    this.addDef(e.id, e.ctx === Load ? USE : DEF_LOCAL, e.lineno);
    break;
  case List:
  case Tuple:
    this.SEQExpr(e.elts);
    break;
  default:
    goog.asserts.fail('Unhandled type ' + e.constructor.name + ' in visitExpr');
  }
};
SymbolTable.prototype.visitComprehension = function (lcs, startAt) {
  var len = lcs.length;
  for (var i = startAt; i < len; ++i) {
    var lc = lcs[i];
    this.visitExpr(lc.target);
    this.visitExpr(lc.iter);
    this.SEQExpr(lc.ifs);
  }
};
SymbolTable.prototype.visitAlias = function (names, lineno) {
  for (var i = 0; i < names.length; ++i) {
    var a = names[i];
    var name = a.asname === null ? a.name.v : a.asname.v;
    var storename = name;
    var dot = name.indexOf('.');
    if (dot !== -1)
      storename = name.substr(0, dot);
    if (name !== '*')
      this.addDef(new Sk.builtin.str(storename), DEF_IMPORT, lineno);
    else {
      if (this.cur.blockType !== ModuleBlock)
        throw new Sk.builtin.SyntaxError('import * only allowed at module level', this.filename);
    }
  }
};
SymbolTable.prototype.visitGenexp = function (e) {
  var outermost = e.generators[0];
  this.visitExpr(outermost.iter);
  this.enterBlock('genexpr', FunctionBlock, e, e.lineno);
  this.cur.generator = true;
  this.addDef(new Sk.builtin.str('.0'), DEF_PARAM, e.lineno);
  this.visitExpr(outermost.target);
  this.SEQExpr(outermost.ifs);
  this.visitComprehension(e.generators, 1);
  this.visitExpr(e.elt);
  this.exitBlock();
};
SymbolTable.prototype.visitExcepthandlers = function (handlers) {
  for (var i = 0, eh; eh = handlers[i]; ++i) {
    if (eh.type)
      this.visitExpr(eh.type);
    if (eh.name)
      this.visitExpr(eh.name);
    this.SEQStmt(eh.body);
  }
};
function _dictUpdate(a, b) {
  for (var kb in b) {
    a[kb] = b[kb];
  }
}
SymbolTable.prototype.analyzeBlock = function (ste, bound, free, global) {
  var local = {};
  var scope = {};
  var newglobal = {};
  var newbound = {};
  var newfree = {};
  if (ste.blockType == ClassBlock) {
    _dictUpdate(newglobal, global);
    if (bound)
      _dictUpdate(newbound, bound);
  }
  for (var name in ste.symFlags) {
    var flags = ste.symFlags[name];
    this.analyzeName(ste, scope, name, flags, bound, local, free, global);
  }
  if (ste.blockType !== ClassBlock) {
    if (ste.blockType === FunctionBlock)
      _dictUpdate(newbound, local);
    if (bound)
      _dictUpdate(newbound, bound);
    _dictUpdate(newglobal, global);
  }
  var allfree = {};
  var childlen = ste.children.length;
  for (var i = 0; i < childlen; ++i) {
    var c = ste.children[i];
    this.analyzeChildBlock(c, newbound, newfree, newglobal, allfree);
    if (c.hasFree || c.childHasFree)
      ste.childHasFree = true;
  }
  _dictUpdate(newfree, allfree);
  if (ste.blockType === FunctionBlock)
    this.analyzeCells(scope, newfree);
  this.updateSymbols(ste.symFlags, scope, bound, newfree, ste.blockType === ClassBlock);
  _dictUpdate(free, newfree);
};
SymbolTable.prototype.analyzeChildBlock = function (entry, bound, free, global, childFree) {
  var tempBound = {};
  _dictUpdate(tempBound, bound);
  var tempFree = {};
  _dictUpdate(tempFree, free);
  var tempGlobal = {};
  _dictUpdate(tempGlobal, global);
  this.analyzeBlock(entry, tempBound, tempFree, tempGlobal);
  _dictUpdate(childFree, tempFree);
};
SymbolTable.prototype.analyzeCells = function (scope, free) {
  for (var name in scope) {
    var flags = scope[name];
    if (flags !== LOCAL)
      continue;
    if (free[name] === undefined)
      continue;
    scope[name] = CELL;
    delete free[name];
  }
};
SymbolTable.prototype.updateSymbols = function (symbols, scope, bound, free, classflag) {
  for (var name in symbols) {
    var flags = symbols[name];
    var w = scope[name];
    flags |= w << SCOPE_OFF;
    symbols[name] = flags;
  }
  var freeValue = FREE << SCOPE_OFF;
  var pos = 0;
  for (var name in free) {
    var o = symbols[name];
    if (o !== undefined) {
      if (classflag && o & (DEF_BOUND | DEF_GLOBAL)) {
        var i = o | DEF_FREE_CLASS;
        symbols[name] = i;
      }
      continue;
    }
    if (bound[name] === undefined)
      continue;
    symbols[name] = freeValue;
  }
};
SymbolTable.prototype.analyzeName = function (ste, dict, name, flags, bound, local, free, global) {
  if (flags & DEF_GLOBAL) {
    if (flags & DEF_PARAM)
      throw new Sk.builtin.SyntaxError('name \'' + name + '\' is local and global', this.filename, ste.lineno);
    dict[name] = GLOBAL_EXPLICIT;
    global[name] = null;
    if (bound && bound[name] !== undefined)
      delete bound[name];
    return;
  }
  if (flags & DEF_BOUND) {
    dict[name] = LOCAL;
    local[name] = null;
    delete global[name];
    return;
  }
  if (bound && bound[name] !== undefined) {
    dict[name] = FREE;
    ste.hasFree = true;
    free[name] = null;
  } else if (global && global[name] !== undefined) {
    dict[name] = GLOBAL_IMPLICIT;
  } else {
    if (ste.isNested)
      ste.hasFree = true;
    dict[name] = GLOBAL_IMPLICIT;
  }
};
SymbolTable.prototype.analyze = function () {
  var free = {};
  var global = {};
  this.analyzeBlock(this.top, null, free, global);
};
Sk.symboltable = function (ast, filename) {
  var ret = new SymbolTable(filename);
  ret.enterBlock('top', ModuleBlock, ast, 0);
  ret.top = ret.cur;
  for (var i = 0; i < ast.body.length; ++i)
    ret.visitStmt(ast.body[i]);
  ret.exitBlock();
  ret.analyze();
  return ret;
};
Sk.dumpSymtab = function (st) {
  var pyBoolStr = function (b) {
    return b ? 'True' : 'False';
  };
  var pyList = function (l) {
    var ret = [];
    for (var i = 0; i < l.length; ++i) {
      ret.push(new Sk.builtin.str(l[i])['$r']().v);
    }
    return '[' + ret.join(', ') + ']';
  };
  var getIdents = function (obj, indent) {
    if (indent === undefined)
      indent = '';
    var ret = '';
    ret += indent + 'Sym_type: ' + obj.get_type() + '\n';
    ret += indent + 'Sym_name: ' + obj.get_name() + '\n';
    ret += indent + 'Sym_lineno: ' + obj.get_lineno() + '\n';
    ret += indent + 'Sym_nested: ' + pyBoolStr(obj.is_nested()) + '\n';
    ret += indent + 'Sym_haschildren: ' + pyBoolStr(obj.has_children()) + '\n';
    if (obj.get_type() === 'class') {
      ret += indent + 'Class_methods: ' + pyList(obj.get_methods()) + '\n';
    } else if (obj.get_type() === 'function') {
      ret += indent + 'Func_params: ' + pyList(obj.get_parameters()) + '\n';
      ret += indent + 'Func_locals: ' + pyList(obj.get_locals()) + '\n';
      ret += indent + 'Func_globals: ' + pyList(obj.get_globals()) + '\n';
      ret += indent + 'Func_frees: ' + pyList(obj.get_frees()) + '\n';
    }
    ret += indent + '-- Identifiers --\n';
    var objidents = obj.get_identifiers();
    var objidentslen = objidents.length;
    for (var i = 0; i < objidentslen; ++i) {
      var info = obj.lookup(objidents[i]);
      ret += indent + 'name: ' + info.get_name() + '\n';
      ret += indent + '  is_referenced: ' + pyBoolStr(info.is_referenced()) + '\n';
      ret += indent + '  is_imported: ' + pyBoolStr(info.is_imported()) + '\n';
      ret += indent + '  is_parameter: ' + pyBoolStr(info.is_parameter()) + '\n';
      ret += indent + '  is_global: ' + pyBoolStr(info.is_global()) + '\n';
      ret += indent + '  is_declared_global: ' + pyBoolStr(info.is_declared_global()) + '\n';
      ret += indent + '  is_local: ' + pyBoolStr(info.is_local()) + '\n';
      ret += indent + '  is_free: ' + pyBoolStr(info.is_free()) + '\n';
      ret += indent + '  is_assigned: ' + pyBoolStr(info.is_assigned()) + '\n';
      ret += indent + '  is_namespace: ' + pyBoolStr(info.is_namespace()) + '\n';
      var nss = info.get_namespaces();
      var nsslen = nss.length;
      ret += indent + '  namespaces: [\n';
      var sub = [];
      for (var j = 0; j < nsslen; ++j) {
        var ns = nss[j];
        sub.push(getIdents(ns, indent + '    '));
      }
      ret += sub.join('\n');
      ret += indent + '  ]\n';
    }
    return ret;
  };
  return getIdents(st.top, '');
};
goog.exportSymbol('Sk.symboltable', Sk.symboltable);
goog.exportSymbol('Sk.dumpSymtab', Sk.dumpSymtab);
var out;
Sk.gensymcount = 0;
function Compiler(filename, st, flags, sourceCodeForAnnotation) {
  this.filename = filename;
  this.st = st;
  this.flags = flags;
  this.interactive = false;
  this.nestlevel = 0;
  this.u = null;
  this.stack = [];
  this.result = [];
  this.allUnits = [];
  this.source = sourceCodeForAnnotation ? sourceCodeForAnnotation.split('\n') : false;
}
function CompilerUnit() {
  this.ste = null;
  this.name = null;
  this.private_ = null;
  this.firstlineno = 0;
  this.lineno = 0;
  this.linenoSet = false;
  this.localnames = [];
  this.blocknum = 0;
  this.blocks = [];
  this.curblock = 0;
  this.scopename = null;
  this.prefixCode = '';
  this.varDeclsCode = '';
  this.switchCode = '';
  this.suffixCode = '';
  this.breakBlocks = [];
  this.continueBlocks = [];
  this.exceptBlocks = [];
  this.finallyBlocks = [];
}
CompilerUnit.prototype.activateScope = function () {
  var self = this;
  out = function () {
    var b = self.blocks[self.curblock];
    for (var i = 0; i < arguments.length; ++i)
      b.push(arguments[i]);
  };
};
Compiler.prototype.getSourceLine = function (lineno) {
  goog.asserts.assert(this.source);
  return this.source[lineno - 1];
};
Compiler.prototype.annotateSource = function (ast) {
  if (this.source) {
    var lineno = ast.lineno;
    var col_offset = ast.col_offset;
    out('\n//\n// line ', lineno, ':\n// ', this.getSourceLine(lineno), '\n// ');
    for (var i = 0; i < col_offset; ++i)
      out(' ');
    out('^\n//\n');
    out('\nSk.currLineNo = ', lineno, ';\nSk.currColNo = ', col_offset, '\n\n');
    out('\nSk.currFilename = \'', this.filename, '\';\n\n');
  }
};
Compiler.prototype.gensym = function (hint) {
  hint = hint || '';
  hint = '$' + hint;
  hint += Sk.gensymcount++;
  return hint;
};
Compiler.prototype.niceName = function (roughName) {
  return this.gensym(roughName.replace('<', '').replace('>', '').replace(' ', '_'));
};
var reservedWords_ = {
    'abstract': true,
    'as': true,
    'boolean': true,
    'break': true,
    'byte': true,
    'case': true,
    'catch': true,
    'char': true,
    'class': true,
    'continue': true,
    'const': true,
    'debugger': true,
    'default': true,
    'delete': true,
    'do': true,
    'double': true,
    'else': true,
    'enum': true,
    'export': true,
    'extends': true,
    'false': true,
    'final': true,
    'finally': true,
    'float': true,
    'for': true,
    'function': true,
    'goto': true,
    'if': true,
    'implements': true,
    'import': true,
    'in': true,
    'instanceof': true,
    'int': true,
    'interface': true,
    'is': true,
    'long': true,
    'namespace': true,
    'native': true,
    'new': true,
    'null': true,
    'package': true,
    'private': true,
    'protected': true,
    'public': true,
    'return': true,
    'short': true,
    'static': true,
    'super': false,
    'switch': true,
    'synchronized': true,
    'this': true,
    'throw': true,
    'throws': true,
    'transient': true,
    'true': true,
    'try': true,
    'typeof': true,
    'use': true,
    'var': true,
    'void': true,
    'volatile': true,
    'while': true,
    'with': true
  };
function fixReservedWords(name) {
  if (reservedWords_[name] !== true)
    return name;
  return name + '_$rw$';
}
var reservedNames_ = {
    '__defineGetter__': true,
    '__defineSetter__': true,
    'apply': true,
    'call': true,
    'eval': true,
    'hasOwnProperty': true,
    'isPrototypeOf': true,
    '__lookupGetter__': true,
    '__lookupSetter__': true,
    '__noSuchMethod__': true,
    'propertyIsEnumerable': true,
    'toSource': true,
    'toLocaleString': true,
    'toString': true,
    'unwatch': true,
    'valueOf': true,
    'watch': true
  };
function fixReservedNames(name) {
  if (reservedNames_[name])
    return name + '_$rn$';
  return name;
}
function mangleName(priv, ident) {
  var name = ident.v;
  var strpriv = null;
  if (priv === null || name === null || name.charAt(0) !== '_' || name.charAt(1) !== '_')
    return ident;
  if (name.charAt(name.length - 1) === '_' && name.charAt(name.length - 2) === '_')
    return ident;
  strpriv = priv.v;
  strpriv.replace(/_/g, '');
  if (strpriv === '')
    return ident;
  strpriv = priv.v;
  strpriv.replace(/^_*/, '');
  strpriv = new Sk.builtin.str('_' + strpriv + name);
  return strpriv;
}
Compiler.prototype._gr = function (hint, rest) {
  var v = this.gensym(hint);
  out('var ', v, '=');
  for (var i = 1; i < arguments.length; ++i) {
    out(arguments[i]);
  }
  out(';');
  return v;
};
Compiler.prototype._interruptTest = function () {
  out('if (Sk.execStart === undefined) {Sk.execStart=new Date()}');
  out('if (Sk.execLimit != null && new Date() - Sk.execStart > Sk.execLimit) {throw new Sk.builtin.TimeLimitError(Sk.timeoutMsg())}');
};
Compiler.prototype._jumpfalse = function (test, block) {
  var cond = this._gr('jfalse', '(', test, '===false||!Sk.misceval.isTrue(', test, '))');
  this._interruptTest();
  out('if(', cond, '){/*test failed */$blk=', block, ';continue;}');
};
Compiler.prototype._jumpundef = function (test, block) {
  this._interruptTest();
  out('if(', test, '===undefined){$blk=', block, ';continue;}');
};
Compiler.prototype._jumptrue = function (test, block) {
  var cond = this._gr('jtrue', '(', test, '===true||Sk.misceval.isTrue(', test, '))');
  this._interruptTest();
  out('if(', cond, '){/*test passed */$blk=', block, ';continue;}');
};
Compiler.prototype._jump = function (block) {
  this._interruptTest();
  out('$blk=', block, ';/* jump */continue;');
};
Compiler.prototype.ctupleorlist = function (e, data, tuporlist) {
  goog.asserts.assert(tuporlist === 'tuple' || tuporlist === 'list');
  if (e.ctx === Store) {
    for (var i = 0; i < e.elts.length; ++i) {
      this.vexpr(e.elts[i], 'Sk.abstr.objectGetItem(' + data + ',' + i + ')');
    }
  } else if (e.ctx === Load) {
    var items = [];
    for (var i = 0; i < e.elts.length; ++i) {
      items.push(this._gr('elem', this.vexpr(e.elts[i])));
    }
    return this._gr('load' + tuporlist, 'new Sk.builtins[\'', tuporlist, '\']([', items, '])');
  }
};
Compiler.prototype.cdict = function (e) {
  goog.asserts.assert(e.values.length === e.keys.length);
  var items = [];
  for (var i = 0; i < e.values.length; ++i) {
    var v = this.vexpr(e.values[i]);
    items.push(this.vexpr(e.keys[i]));
    items.push(v);
  }
  return this._gr('loaddict', 'new Sk.builtins[\'dict\']([', items, '])');
};
Compiler.prototype.clistcompgen = function (tmpname, generators, genIndex, elt) {
  var start = this.newBlock('list gen start');
  var skip = this.newBlock('list gen skip');
  var anchor = this.newBlock('list gen anchor');
  var l = generators[genIndex];
  var toiter = this.vexpr(l.iter);
  var iter = this._gr('iter', 'Sk.abstr.iter(', toiter, ')');
  this._jump(start);
  this.setBlock(start);
  var nexti = this._gr('next', 'Sk.abstr.iternext(', iter, ')');
  this._jumpundef(nexti, anchor);
  var target = this.vexpr(l.target, nexti);
  var n = l.ifs.length;
  for (var i = 0; i < n; ++i) {
    var ifres = this.vexpr(l.ifs[i]);
    this._jumpfalse(ifres, start);
  }
  if (++genIndex < generators.length) {
    this.clistcompgen(tmpname, generators, genIndex, elt);
  }
  if (genIndex >= generators.length) {
    var velt = this.vexpr(elt);
    out(tmpname, '.v.push(', velt, ');');
    this._jump(skip);
    this.setBlock(skip);
  }
  this._jump(start);
  this.setBlock(anchor);
  return tmpname;
};
Compiler.prototype.clistcomp = function (e) {
  goog.asserts.assert(e instanceof ListComp);
  var tmp = this._gr('_compr', 'new Sk.builtins[\'list\']([])');
  return this.clistcompgen(tmp, e.generators, 0, e.elt);
};
Compiler.prototype.cyield = function (e) {
  if (this.u.ste.blockType !== FunctionBlock)
    throw new SyntaxError('\'yield\' outside function');
  var val = 'null';
  if (e.value)
    val = this.vexpr(e.value);
  var nextBlock = this.newBlock('after yield');
  out('return [/*resume*/', nextBlock, ',/*ret*/', val, '];');
  this.setBlock(nextBlock);
  return '$gen.gi$sentvalue';
};
Compiler.prototype.ccompare = function (e) {
  goog.asserts.assert(e.ops.length === e.comparators.length);
  var cur = this.vexpr(e.left);
  var n = e.ops.length;
  var done = this.newBlock('done');
  var fres = this._gr('compareres', 'null');
  for (var i = 0; i < n; ++i) {
    var rhs = this.vexpr(e.comparators[i]);
    var res = this._gr('compare', 'Sk.builtin.bool(Sk.misceval.richCompareBool(', cur, ',', rhs, ',\'', e.ops[i].prototype._astname, '\'))');
    out(fres, '=', res, ';');
    this._jumpfalse(res, done);
    cur = rhs;
  }
  this._jump(done);
  this.setBlock(done);
  return fres;
};
Compiler.prototype.ccall = function (e) {
  var func = this.vexpr(e.func);
  var args = this.vseqexpr(e.args);
  if (e.keywords.length > 0 || e.starargs || e.kwargs) {
    var kwarray = [];
    for (var i = 0; i < e.keywords.length; ++i) {
      kwarray.push('\'' + e.keywords[i].arg.v + '\'');
      kwarray.push(this.vexpr(e.keywords[i].value));
    }
    var keywords = '[' + kwarray.join(',') + ']';
    var starargs = 'undefined';
    var kwargs = 'undefined';
    if (e.starargs)
      starargs = this.vexpr(e.starargs);
    if (e.kwargs)
      kwargs = this.vexpr(e.kwargs);
    return this._gr('call', 'Sk.misceval.call(', func, ',', kwargs, ',', starargs, ',', keywords, args.length > 0 ? ',' : '', args, ')');
  } else {
    return this._gr('call', 'Sk.misceval.callsim(', func, args.length > 0 ? ',' : '', args, ')');
  }
};
Compiler.prototype.cslice = function (s) {
  goog.asserts.assert(s instanceof Slice);
  var low = s.lower ? this.vexpr(s.lower) : 'null';
  var high = s.upper ? this.vexpr(s.upper) : 'null';
  var step = s.step ? this.vexpr(s.step) : 'null';
  return this._gr('slice', 'new Sk.builtins[\'slice\'](', low, ',', high, ',', step, ')');
};
Compiler.prototype.vslicesub = function (s) {
  var subs;
  switch (s.constructor) {
  case Number:
  case String:
    subs = s;
    break;
  case Index:
    subs = this.vexpr(s.value);
    break;
  case Slice:
    subs = this.cslice(s);
    break;
  case Ellipsis:
  case ExtSlice:
    goog.asserts.fail('todo;');
    break;
  default:
    goog.asserts.fail('invalid subscript kind');
  }
  return subs;
};
Compiler.prototype.vslice = function (s, ctx, obj, dataToStore) {
  var subs = this.vslicesub(s);
  return this.chandlesubscr(ctx, obj, subs, dataToStore);
};
Compiler.prototype.chandlesubscr = function (ctx, obj, subs, data) {
  if (ctx === Load || ctx === AugLoad)
    return this._gr('lsubscr', 'Sk.abstr.objectGetItem(', obj, ',', subs, ')');
  else if (ctx === Store || ctx === AugStore)
    out('Sk.abstr.objectSetItem(', obj, ',', subs, ',', data, ');');
  else if (ctx === Del)
    out('Sk.abstr.objectDelItem(', obj, ',', subs, ');');
  else
    goog.asserts.fail('handlesubscr fail');
};
Compiler.prototype.cboolop = function (e) {
  goog.asserts.assert(e instanceof BoolOp);
  var jtype;
  var ifFailed;
  if (e.op === And)
    jtype = this._jumpfalse;
  else
    jtype = this._jumptrue;
  var end = this.newBlock('end of boolop');
  var s = e.values;
  var n = s.length;
  var retval;
  for (var i = 0; i < n; ++i) {
    var expres = this.vexpr(s[i]);
    if (i === 0) {
      retval = this._gr('boolopsucc', expres);
    }
    out(retval, '=', expres, ';');
    jtype.call(this, expres, end);
  }
  this._jump(end);
  this.setBlock(end);
  return retval;
};
Compiler.prototype.vexpr = function (e, data, augstoreval) {
  if (e.lineno > this.u.lineno) {
    this.u.lineno = e.lineno;
    this.u.linenoSet = false;
  }
  switch (e.constructor) {
  case BoolOp:
    return this.cboolop(e);
  case BinOp:
    return this._gr('binop', 'Sk.abstr.numberBinOp(', this.vexpr(e.left), ',', this.vexpr(e.right), ',\'', e.op.prototype._astname, '\')');
  case UnaryOp:
    return this._gr('unaryop', 'Sk.abstr.numberUnaryOp(', this.vexpr(e.operand), ',\'', e.op.prototype._astname, '\')');
  case Lambda:
    return this.clambda(e);
  case IfExp:
    return this.cifexp(e);
  case Dict:
    return this.cdict(e);
  case ListComp:
    return this.clistcomp(e);
  case GeneratorExp:
    return this.cgenexp(e);
  case Yield:
    return this.cyield(e);
  case Compare:
    return this.ccompare(e);
  case Call:
    var result = this.ccall(e);
    this.annotateSource(e);
    return result;
  case Num:
    if (typeof e.n === 'number')
      return e.n;
    else if (e.n instanceof Sk.builtin.nmber)
      return 'new Sk.builtin.nmber(' + e.n.v + ',\'' + e.n.skType + '\')';
    else if (e.n instanceof Sk.builtin.lng)
      return 'Sk.longFromStr(\'' + e.n.tp$str().v + '\')';
    goog.asserts.fail('unhandled Num type');
  case Str:
    return this._gr('str', 'new Sk.builtins[\'str\'](', e.s['$r']().v, ')');
  case Attribute:
    var val;
    if (e.ctx !== AugStore)
      val = this.vexpr(e.value);
    var mangled = e.attr['$r']().v;
    mangled = mangled.substring(1, mangled.length - 1);
    mangled = mangleName(this.u.private_, new Sk.builtin.str(mangled)).v;
    mangled = fixReservedWords(mangled);
    mangled = fixReservedNames(mangled);
    switch (e.ctx) {
    case AugLoad:
    case Load:
      return this._gr('lattr', 'Sk.abstr.gattr(', val, ',\'', mangled, '\')');
    case AugStore:
      out('if(', data, '!==undefined){');
      val = this.vexpr(augstoreval || null);
      out('Sk.abstr.sattr(', val, ',\'', mangled, '\',', data, ');');
      out('}');
      break;
    case Store:
      out('Sk.abstr.sattr(', val, ',\'', mangled, '\',', data, ');');
      break;
    case Del:
      goog.asserts.fail('todo;');
      break;
    case Param:
    default:
      goog.asserts.fail('invalid attribute expression');
    }
    break;
  case Subscript:
    var val;
    switch (e.ctx) {
    case AugLoad:
    case Load:
    case Store:
    case Del:
      return this.vslice(e.slice, e.ctx, this.vexpr(e.value), data);
    case AugStore:
      out('if(', data, '!==undefined){');
      val = this.vexpr(augstoreval || null);
      this.vslice(e.slice, e.ctx, val, data);
      out('}');
      break;
    case Param:
    default:
      goog.asserts.fail('invalid subscript expression');
    }
    break;
  case Name:
    return this.nameop(e.id, e.ctx, data);
  case List:
    return this.ctupleorlist(e, data, 'list');
  case Tuple:
    return this.ctupleorlist(e, data, 'tuple');
  default:
    goog.asserts.fail('unhandled case in vexpr');
  }
};
Compiler.prototype.vseqexpr = function (exprs, data) {
  goog.asserts.assert(data === undefined || exprs.length === data.length);
  var ret = [];
  for (var i = 0; i < exprs.length; ++i)
    ret.push(this.vexpr(exprs[i], data === undefined ? undefined : data[i]));
  return ret;
};
Compiler.prototype.caugassign = function (s) {
  goog.asserts.assert(s instanceof AugAssign);
  var e = s.target;
  switch (e.constructor) {
  case Attribute:
    var auge = new Attribute(e.value, e.attr, AugLoad, e.lineno, e.col_offset);
    var aug = this.vexpr(auge);
    var val = this.vexpr(s.value);
    var res = this._gr('inplbinopattr', 'Sk.abstr.numberInplaceBinOp(', aug, ',', val, ',\'', s.op.prototype._astname, '\')');
    auge.ctx = AugStore;
    return this.vexpr(auge, res, e.value);
  case Subscript:
    var augsub = this.vslicesub(e.slice);
    var auge = new Subscript(e.value, augsub, AugLoad, e.lineno, e.col_offset);
    var aug = this.vexpr(auge);
    var val = this.vexpr(s.value);
    var res = this._gr('inplbinopsubscr', 'Sk.abstr.numberInplaceBinOp(', aug, ',', val, ',\'', s.op.prototype._astname, '\')');
    auge.ctx = AugStore;
    return this.vexpr(auge, res, e.value);
  case Name:
    var to = this.nameop(e.id, Load);
    var val = this.vexpr(s.value);
    var res = this._gr('inplbinop', 'Sk.abstr.numberInplaceBinOp(', to, ',', val, ',\'', s.op.prototype._astname, '\')');
    return this.nameop(e.id, Store, res);
  default:
    goog.asserts.fail('unhandled case in augassign');
  }
};
Compiler.prototype.exprConstant = function (e) {
  switch (e.constructor) {
  case Num:
    return Sk.misceval.isTrue(e.n);
  case Str:
    return Sk.misceval.isTrue(e.s);
  case Name:
  default:
    return -1;
  }
};
Compiler.prototype.newBlock = function (name) {
  var ret = this.u.blocknum++;
  this.u.blocks[ret] = [];
  this.u.blocks[ret]._name = name || '<unnamed>';
  return ret;
};
Compiler.prototype.setBlock = function (n) {
  goog.asserts.assert(n >= 0 && n < this.u.blocknum);
  this.u.curblock = n;
};
Compiler.prototype.pushBreakBlock = function (n) {
  goog.asserts.assert(n >= 0 && n < this.u.blocknum);
  this.u.breakBlocks.push(n);
};
Compiler.prototype.popBreakBlock = function () {
  this.u.breakBlocks.pop();
};
Compiler.prototype.pushContinueBlock = function (n) {
  goog.asserts.assert(n >= 0 && n < this.u.blocknum);
  this.u.continueBlocks.push(n);
};
Compiler.prototype.popContinueBlock = function () {
  this.u.continueBlocks.pop();
};
Compiler.prototype.pushExceptBlock = function (n) {
  goog.asserts.assert(n >= 0 && n < this.u.blocknum);
  this.u.exceptBlocks.push(n);
};
Compiler.prototype.popExceptBlock = function () {
  this.u.exceptBlocks.pop();
};
Compiler.prototype.pushFinallyBlock = function (n) {
  goog.asserts.assert(n >= 0 && n < this.u.blocknum);
  this.u.finallyBlocks.push(n);
};
Compiler.prototype.popFinallyBlock = function () {
  this.u.finallyBlocks.pop();
};
Compiler.prototype.setupExcept = function (eb) {
  out('$exc.push(', eb, ');');
};
Compiler.prototype.endExcept = function () {
  out('$exc.pop();');
};
Compiler.prototype.outputLocals = function (unit) {
  var have = {};
  for (var i = 0; unit.argnames && i < unit.argnames.length; ++i)
    have[unit.argnames[i]] = true;
  unit.localnames.sort();
  var output = [];
  for (var i = 0; i < unit.localnames.length; ++i) {
    var name = unit.localnames[i];
    if (have[name] === undefined) {
      output.push(name);
      have[name] = true;
    }
  }
  if (output.length > 0)
    return 'var ' + output.join(',') + '; /* locals */';
  return '';
};
Compiler.prototype.outputAllUnits = function () {
  var ret = '';
  for (var j = 0; j < this.allUnits.length; ++j) {
    var unit = this.allUnits[j];
    ret += unit.prefixCode;
    ret += this.outputLocals(unit);
    ret += unit.varDeclsCode;
    ret += unit.switchCode;
    var blocks = unit.blocks;
    for (var i = 0; i < blocks.length; ++i) {
      ret += 'case ' + i + ': /* --- ' + blocks[i]._name + ' --- */';
      ret += blocks[i].join('');
      ret += 'throw new Sk.builtin.SystemError(\'internal error: unterminated block\');';
    }
    ret += unit.suffixCode;
  }
  return ret;
};
Compiler.prototype.cif = function (s) {
  goog.asserts.assert(s instanceof If_);
  var constant = this.exprConstant(s.test);
  if (constant === 0) {
    if (s.orelse)
      this.vseqstmt(s.orelse);
  } else if (constant === 1) {
    this.vseqstmt(s.body);
  } else {
    var end = this.newBlock('end of if');
    var next = this.newBlock('next branch of if');
    var test = this.vexpr(s.test);
    this._jumpfalse(test, next);
    this.vseqstmt(s.body);
    this._jump(end);
    this.setBlock(next);
    if (s.orelse)
      this.vseqstmt(s.orelse);
    this._jump(end);
  }
  this.setBlock(end);
};
Compiler.prototype.cwhile = function (s) {
  var constant = this.exprConstant(s.test);
  if (constant === 0) {
    if (s.orelse)
      this.vseqstmt(s.orelse);
  } else {
    var top = this.newBlock('while test');
    this._jump(top);
    this.setBlock(top);
    var next = this.newBlock('after while');
    var orelse = s.orelse.length > 0 ? this.newBlock('while orelse') : null;
    var body = this.newBlock('while body');
    this._jumpfalse(this.vexpr(s.test), orelse ? orelse : next);
    this._jump(body);
    this.pushBreakBlock(next);
    this.pushContinueBlock(top);
    this.setBlock(body);
    this.vseqstmt(s.body);
    this._jump(top);
    this.popContinueBlock();
    this.popBreakBlock();
    if (s.orelse.length > 0) {
      this.setBlock(orelse);
      this.vseqstmt(s.orelse);
      this._jump(next);
    }
    this.setBlock(next);
  }
};
Compiler.prototype.cfor = function (s) {
  var start = this.newBlock('for start');
  var cleanup = this.newBlock('for cleanup');
  var end = this.newBlock('for end');
  this.pushBreakBlock(end);
  this.pushContinueBlock(start);
  var toiter = this.vexpr(s.iter);
  var iter;
  if (this.u.ste.generator) {
    iter = '$loc.' + this.gensym('iter');
    out(iter, '=Sk.abstr.iter(', toiter, ');');
  } else
    iter = this._gr('iter', 'Sk.abstr.iter(', toiter, ')');
  this._jump(start);
  this.setBlock(start);
  var nexti = this._gr('next', 'Sk.abstr.iternext(', iter, ')');
  this._jumpundef(nexti, cleanup);
  var target = this.vexpr(s.target, nexti);
  this.vseqstmt(s.body);
  this._jump(start);
  this.setBlock(cleanup);
  this.popContinueBlock();
  this.popBreakBlock();
  this.vseqstmt(s.orelse);
  this._jump(end);
  this.setBlock(end);
};
Compiler.prototype.craise = function (s) {
  if (s && s.type && s.type.id && s.type.id.v === 'StopIteration') {
    out('return undefined;');
  } else {
    var inst = '';
    if (s.inst) {
      inst = this.vexpr(s.inst);
      out('throw ', this.vexpr(s.type), '(', inst, ');');
    } else if (s.type) {
      if (s.type.func) {
        out('throw ', this.vexpr(s.type), ';');
      } else {
        out('throw ', this.vexpr(s.type), '(\'\');');
      }
    } else {
      out('throw $err;');
    }
  }
};
Compiler.prototype.ctryexcept = function (s) {
  var n = s.handlers.length;
  var handlers = [];
  for (var i = 0; i < n; ++i) {
    handlers.push(this.newBlock('except_' + i + '_'));
  }
  var unhandled = this.newBlock('unhandled');
  var orelse = this.newBlock('orelse');
  var end = this.newBlock('end');
  this.setupExcept(handlers[0]);
  this.vseqstmt(s.body);
  this.endExcept();
  this._jump(orelse);
  for (var i = 0; i < n; ++i) {
    this.setBlock(handlers[i]);
    var handler = s.handlers[i];
    if (!handler.type && i < n - 1) {
      throw new SyntaxError('default \'except:\' must be last');
    }
    if (handler.type) {
      var handlertype = this.vexpr(handler.type);
      var next = i == n - 1 ? unhandled : handlers[i + 1];
      var check = this._gr('instance', '$err instanceof ', handlertype);
      this._jumpfalse(check, next);
    }
    if (handler.name) {
      this.vexpr(handler.name, '$err');
    }
    this.vseqstmt(handler.body);
    this._jump(end);
  }
  this.setBlock(unhandled);
  out('throw $err;');
  this.setBlock(orelse);
  this.vseqstmt(s.orelse);
  this._jump(end);
  this.setBlock(end);
};
Compiler.prototype.ctryfinally = function (s) {
  out('/*todo; tryfinally*/');
  this.ctryexcept(s.body[0]);
};
Compiler.prototype.cassert = function (s) {
  var test = this.vexpr(s.test);
  var end = this.newBlock('end');
  this._jumptrue(test, end);
  out('throw new Sk.builtin.AssertionError(', s.msg ? this.vexpr(s.msg) : '', ');');
  this.setBlock(end);
};
Compiler.prototype.cimportas = function (name, asname, mod) {
  var src = name.v;
  var dotLoc = src.indexOf('.');
  var cur = mod;
  if (dotLoc !== -1) {
    src = src.substr(dotLoc + 1);
    while (dotLoc !== -1) {
      dotLoc = src.indexOf('.');
      var attr = dotLoc !== -1 ? src.substr(0, dotLoc) : src;
      cur = this._gr('lattr', 'Sk.abstr.gattr(', cur, ',\'', attr, '\')');
      src = src.substr(dotLoc + 1);
    }
  }
  return this.nameop(asname, Store, cur);
};
Compiler.prototype.cimport = function (s) {
  var n = s.names.length;
  for (var i = 0; i < n; ++i) {
    var alias = s.names[i];
    var mod = this._gr('module', 'Sk.builtin.__import__(', alias.name['$r']().v, ',$gbl,$loc,[])');
    if (alias.asname) {
      this.cimportas(alias.name, alias.asname, mod);
    } else {
      var tmp = alias.name;
      var lastDot = tmp.v.indexOf('.');
      if (lastDot !== -1)
        tmp = new Sk.builtin.str(tmp.v.substr(0, lastDot));
      this.nameop(tmp, Store, mod);
    }
  }
};
Compiler.prototype.cfromimport = function (s) {
  var n = s.names.length;
  var names = [];
  for (var i = 0; i < n; ++i)
    names[i] = s.names[i].name['$r']().v;
  var mod = this._gr('module', 'Sk.builtin.__import__(', s.module['$r']().v, ',$gbl,$loc,[', names, '])');
  for (var i = 0; i < n; ++i) {
    var alias = s.names[i];
    if (i === 0 && alias.name.v === '*') {
      goog.asserts.assert(n === 1);
      out('Sk.importStar(', mod, ',$loc, $gbl);');
      return;
    }
    var got = this._gr('item', 'Sk.abstr.gattr(', mod, ',', alias.name['$r']().v, ')');
    var storeName = alias.name;
    if (alias.asname)
      storeName = alias.asname;
    this.nameop(storeName, Store, got);
  }
};
Compiler.prototype.buildcodeobj = function (n, coname, decorator_list, args, callback) {
  var decos = [];
  var defaults = [];
  var vararg = null;
  var kwarg = null;
  if (decorator_list)
    decos = this.vseqexpr(decorator_list);
  if (args && args.defaults)
    defaults = this.vseqexpr(args.defaults);
  if (args && args.vararg)
    vararg = args.vararg;
  if (args && args.kwarg)
    kwarg = args.kwarg;
  var scopename = this.enterScope(coname, n, n.lineno);
  var isGenerator = this.u.ste.generator;
  var hasFree = this.u.ste.hasFree;
  var hasCell = this.u.ste.childHasFree;
  var entryBlock = this.newBlock('codeobj entry');
  this.u.prefixCode = 'var ' + scopename + '=(function ' + this.niceName(coname.v) + '$(';
  var funcArgs = [];
  if (isGenerator) {
    if (kwarg) {
      throw new SyntaxError(coname.v + '(): keyword arguments in generators not supported');
    }
    if (vararg) {
      throw new SyntaxError(coname.v + '(): variable number of arguments in generators not supported');
    }
    funcArgs.push('$gen');
  } else {
    if (kwarg)
      funcArgs.push('$kwa');
    for (var i = 0; args && i < args.args.length; ++i)
      funcArgs.push(this.nameop(args.args[i].id, Param));
  }
  if (hasFree)
    funcArgs.push('$free');
  this.u.prefixCode += funcArgs.join(',');
  this.u.prefixCode += '){';
  if (isGenerator)
    this.u.prefixCode += '\n// generator\n';
  if (hasFree)
    this.u.prefixCode += '\n// has free\n';
  if (hasCell)
    this.u.prefixCode += '\n// has cell\n';
  var locals = '{}';
  if (isGenerator) {
    entryBlock = '$gen.gi$resumeat';
    locals = '$gen.gi$locals';
  }
  var cells = '';
  if (hasCell)
    cells = ',$cell={}';
  this.u.varDeclsCode += 'var $blk=' + entryBlock + ',$exc=[],$loc=' + locals + cells + ',$gbl=this,$err=undefined;';
  for (var i = 0; args && i < args.args.length; ++i) {
    var id = args.args[i].id;
    if (this.isCell(id))
      this.u.varDeclsCode += '$cell.' + id.v + '=' + id.v + ';';
  }
  if (!isGenerator) {
    var minargs = args ? args.args.length - defaults.length : 0;
    var maxargs = vararg ? Infinity : args ? args.args.length : 0;
    var kw = kwarg ? true : false;
    this.u.varDeclsCode += 'Sk.builtin.pyCheckArgs("' + coname.v + '", arguments, ' + minargs + ', ' + maxargs + ', ' + kw + ', ' + hasFree + ');';
  }
  if (defaults.length > 0) {
    var offset = args.args.length - defaults.length;
    for (var i = 0; i < defaults.length; ++i) {
      var argname = this.nameop(args.args[i + offset].id, Param);
      this.u.varDeclsCode += 'if(' + argname + '===undefined)' + argname + '=' + scopename + '.$defaults[' + i + '];';
    }
  }
  if (vararg) {
    var start = funcArgs.length;
    this.u.varDeclsCode += vararg.v + '=new Sk.builtins[\'tuple\'](Array.prototype.slice.call(arguments,' + start + ')); /*vararg*/';
  }
  if (kwarg) {
    this.u.varDeclsCode += kwarg.v + '=new Sk.builtins[\'dict\']($kwa);';
  }
  this.u.switchCode = 'while(true){try{ switch($blk){';
  this.u.suffixCode = '} }catch(err){if ($exc.length>0) { $err = err; $blk=$exc.pop(); continue; } else { throw err; }} }});';
  callback.call(this, scopename);
  var argnames;
  if (args && args.args.length > 0) {
    var argnamesarr = [];
    for (var i = 0; i < args.args.length; ++i)
      argnamesarr.push(args.args[i].id.v);
    argnames = argnamesarr.join('\', \'');
    this.u.argnames = argnamesarr;
  }
  this.exitScope();
  if (defaults.length > 0)
    out(scopename, '.$defaults=[', defaults.join(','), '];');
  if (argnames) {
    out(scopename, '.co_varnames=[\'', argnames, '\'];');
  }
  if (kwarg) {
    out(scopename, '.co_kwargs=1;');
  }
  var frees = '';
  if (hasFree) {
    frees = ',$cell';
    var containingHasFree = this.u.ste.hasFree;
    if (containingHasFree)
      frees += ',$free';
  }
  if (isGenerator)
    if (args && args.args.length > 0)
      return this._gr('gener', '(function(){var $origargs=Array.prototype.slice.call(arguments);Sk.builtin.pyCheckArgs("', coname.v, '",arguments,', args.args.length - defaults.length, ',', args.args.length, ');return new Sk.builtins[\'generator\'](', scopename, ',$gbl,$origargs', frees, ');})');
    else
      return this._gr('gener', '(function(){Sk.builtin.pyCheckArgs("', coname.v, '",arguments,0,0);return new Sk.builtins[\'generator\'](', scopename, ',$gbl,[]', frees, ');})');
  else
    return this._gr('funcobj', 'new Sk.builtins[\'function\'](', scopename, ',$gbl', frees, ')');
};
Compiler.prototype.cfunction = function (s) {
  goog.asserts.assert(s instanceof FunctionDef);
  var funcorgen = this.buildcodeobj(s, s.name, s.decorator_list, s.args, function (scopename) {
      this.vseqstmt(s.body);
      out('return Sk.builtin.none.none$;');
    });
  this.nameop(s.name, Store, funcorgen);
};
Compiler.prototype.clambda = function (e) {
  goog.asserts.assert(e instanceof Lambda);
  var func = this.buildcodeobj(e, new Sk.builtin.str('<lambda>'), null, e.args, function (scopename) {
      var val = this.vexpr(e.body);
      out('return ', val, ';');
    });
  return func;
};
Compiler.prototype.cifexp = function (e) {
  var next = this.newBlock('next of ifexp');
  var end = this.newBlock('end of ifexp');
  var ret = this._gr('res', 'null');
  var test = this.vexpr(e.test);
  this._jumpfalse(test, next);
  out(ret, '=', this.vexpr(e.body), ';');
  this._jump(end);
  this.setBlock(next);
  out(ret, '=', this.vexpr(e.orelse), ';');
  this._jump(end);
  this.setBlock(end);
  return ret;
};
Compiler.prototype.cgenexpgen = function (generators, genIndex, elt) {
  var start = this.newBlock('start for ' + genIndex);
  var skip = this.newBlock('skip for ' + genIndex);
  var ifCleanup = this.newBlock('if cleanup for ' + genIndex);
  var end = this.newBlock('end for ' + genIndex);
  var ge = generators[genIndex];
  var iter;
  if (genIndex === 0) {
    iter = '$loc.$iter0';
  } else {
    var toiter = this.vexpr(ge.iter);
    iter = '$loc.' + this.gensym('iter');
    out(iter, '=', 'Sk.abstr.iter(', toiter, ');');
  }
  this._jump(start);
  this.setBlock(start);
  var nexti = this._gr('next', 'Sk.abstr.iternext(', iter, ')');
  this._jumpundef(nexti, end);
  var target = this.vexpr(ge.target, nexti);
  var n = ge.ifs.length;
  for (var i = 0; i < n; ++i) {
    var ifres = this.vexpr(ge.ifs[i]);
    this._jumpfalse(ifres, start);
  }
  if (++genIndex < generators.length) {
    this.cgenexpgen(generators, genIndex, elt);
  }
  if (genIndex >= generators.length) {
    var velt = this.vexpr(elt);
    out('return [', skip, '/*resume*/,', velt, '/*ret*/];');
    this.setBlock(skip);
  }
  this._jump(start);
  this.setBlock(end);
  if (genIndex === 1)
    out('return null;');
};
Compiler.prototype.cgenexp = function (e) {
  var gen = this.buildcodeobj(e, new Sk.builtin.str('<genexpr>'), null, null, function (scopename) {
      this.cgenexpgen(e.generators, 0, e.elt);
    });
  var gener = this._gr('gener', gen, '()');
  out(gener, '.gi$locals.$iter0=Sk.abstr.iter(', this.vexpr(e.generators[0].iter), ');');
  return gener;
};
Compiler.prototype.cclass = function (s) {
  goog.asserts.assert(s instanceof ClassDef);
  var decos = s.decorator_list;
  var bases = this.vseqexpr(s.bases);
  var scopename = this.enterScope(s.name, s, s.lineno);
  var entryBlock = this.newBlock('class entry');
  this.u.prefixCode = 'var ' + scopename + '=(function $' + s.name.v + '$class_outer($globals,$locals,$rest){var $gbl=$globals,$loc=$locals;';
  this.u.switchCode += 'return(function ' + s.name.v + '(){';
  this.u.switchCode += 'var $blk=' + entryBlock + ',$exc=[];while(true){switch($blk){';
  this.u.suffixCode = '}break;}}).apply(null,$rest);});';
  this.u.private_ = s.name;
  this.cbody(s.body);
  out('break;');
  this.exitScope();
  var wrapped = this._gr('built', 'Sk.misceval.buildClass($gbl,', scopename, ',', s.name['$r']().v, ',[', bases, '])');
  this.nameop(s.name, Store, wrapped);
};
Compiler.prototype.ccontinue = function (s) {
  if (this.u.continueBlocks.length === 0)
    throw new SyntaxError('\'continue\' outside loop');
  this._jump(this.u.continueBlocks[this.u.continueBlocks.length - 1]);
};
Compiler.prototype.vstmt = function (s) {
  this.u.lineno = s.lineno;
  this.u.linenoSet = false;
  this.annotateSource(s);
  switch (s.constructor) {
  case FunctionDef:
    this.cfunction(s);
    break;
  case ClassDef:
    this.cclass(s);
    break;
  case Return_:
    if (this.u.ste.blockType !== FunctionBlock)
      throw new SyntaxError('\'return\' outside function');
    if (s.value)
      out('return ', this.vexpr(s.value), ';');
    else
      out('return null;');
    break;
  case Delete_:
    this.vseqexpr(s.targets);
    break;
  case Assign:
    var n = s.targets.length;
    var val = this.vexpr(s.value);
    for (var i = 0; i < n; ++i)
      this.vexpr(s.targets[i], val);
    break;
  case AugAssign:
    return this.caugassign(s);
  case Print:
    this.cprint(s);
    break;
  case For_:
    return this.cfor(s);
  case While_:
    return this.cwhile(s);
  case If_:
    return this.cif(s);
  case Raise:
    return this.craise(s);
  case TryExcept:
    return this.ctryexcept(s);
  case TryFinally:
    return this.ctryfinally(s);
  case Assert:
    return this.cassert(s);
  case Import_:
    return this.cimport(s);
  case ImportFrom:
    return this.cfromimport(s);
  case Global:
    break;
  case Expr:
    this.vexpr(s.value);
    break;
  case Pass:
    break;
  case Break_:
    if (this.u.breakBlocks.length === 0)
      throw new SyntaxError('\'break\' outside loop');
    this._jump(this.u.breakBlocks[this.u.breakBlocks.length - 1]);
    break;
  case Continue_:
    this.ccontinue(s);
    break;
  default:
    goog.asserts.fail('unhandled case in vstmt');
  }
};
Compiler.prototype.vseqstmt = function (stmts) {
  for (var i = 0; i < stmts.length; ++i)
    this.vstmt(stmts[i]);
};
var OP_FAST = 0;
var OP_GLOBAL = 1;
var OP_DEREF = 2;
var OP_NAME = 3;
var D_NAMES = 0;
var D_FREEVARS = 1;
var D_CELLVARS = 2;
Compiler.prototype.isCell = function (name) {
  var mangled = mangleName(this.u.private_, name).v;
  var scope = this.u.ste.getScope(mangled);
  var dict = null;
  if (scope === CELL)
    return true;
  return false;
};
Compiler.prototype.nameop = function (name, ctx, dataToStore) {
  if ((ctx === Store || ctx === AugStore || ctx === Del) && name.v === '__debug__')
    throw new Sk.builtin.SyntaxError('can not assign to __debug__');
  if ((ctx === Store || ctx === AugStore || ctx === Del) && name.v === 'None')
    throw new Sk.builtin.SyntaxError('can not assign to None');
  if (name.v === 'None')
    return 'Sk.builtin.none.none$';
  if (name.v === 'True')
    return 'Sk.builtin.bool.true$';
  if (name.v === 'False')
    return 'Sk.builtin.bool.false$';
  var mangled = mangleName(this.u.private_, name).v;
  mangled = fixReservedNames(mangled);
  var op = 0;
  var optype = OP_NAME;
  var scope = this.u.ste.getScope(mangled);
  var dict = null;
  switch (scope) {
  case FREE:
    dict = '$free';
    optype = OP_DEREF;
    break;
  case CELL:
    dict = '$cell';
    optype = OP_DEREF;
    break;
  case LOCAL:
    if (this.u.ste.blockType === FunctionBlock && !this.u.ste.generator)
      optype = OP_FAST;
    break;
  case GLOBAL_IMPLICIT:
    if (this.u.ste.blockType === FunctionBlock)
      optype = OP_GLOBAL;
    break;
  case GLOBAL_EXPLICIT:
    optype = OP_GLOBAL;
  default:
    break;
  }
  mangled = fixReservedWords(mangled);
  goog.asserts.assert(scope || name.v.charAt(1) === '_');
  var mangledNoPre = mangled;
  if (this.u.ste.generator || this.u.ste.blockType !== FunctionBlock)
    mangled = '$loc.' + mangled;
  else if (optype === OP_FAST || optype === OP_NAME)
    this.u.localnames.push(mangled);
  switch (optype) {
  case OP_FAST:
    switch (ctx) {
    case Load:
    case Param:
      out('if (', mangled, ' === undefined) { throw new Error(\'local variable \\\'', mangled, '\\\' referenced before assignment\'); }\n');
      return mangled;
    case Store:
      out(mangled, '=', dataToStore, ';');
      break;
    case Del:
      out('delete ', mangled, ';');
      break;
    default:
      goog.asserts.fail('unhandled');
    }
    break;
  case OP_NAME:
    switch (ctx) {
    case Load:
      var v = this.gensym('loadname');
      out('var ', v, '=', mangled, '!==undefined?', mangled, ':Sk.misceval.loadname(\'', mangledNoPre, '\',$gbl);');
      return v;
    case Store:
      out(mangled, '=', dataToStore, ';');
      break;
    case Del:
      out('delete ', mangled, ';');
      break;
    case Param:
      return mangled;
    default:
      goog.asserts.fail('unhandled');
    }
    break;
  case OP_GLOBAL:
    switch (ctx) {
    case Load:
      return this._gr('loadgbl', 'Sk.misceval.loadname(\'', mangledNoPre, '\',$gbl)');
    case Store:
      out('$gbl.', mangledNoPre, '=', dataToStore, ';');
      break;
    case Del:
      out('delete $gbl.', mangledNoPre);
      break;
    default:
      goog.asserts.fail('unhandled case in name op_global');
    }
    break;
  case OP_DEREF:
    switch (ctx) {
    case Load:
      return dict + '.' + mangledNoPre;
    case Store:
      out(dict, '.', mangledNoPre, '=', dataToStore, ';');
      break;
    case Param:
      return mangledNoPre;
    default:
      goog.asserts.fail('unhandled case in name op_deref');
    }
    break;
  default:
    goog.asserts.fail('unhandled case');
  }
};
Compiler.prototype.enterScope = function (name, key, lineno) {
  var u = new CompilerUnit();
  u.ste = this.st.getStsForAst(key);
  u.name = name;
  u.firstlineno = lineno;
  if (this.u && this.u.private_)
    u.private_ = this.u.private_;
  this.stack.push(this.u);
  this.allUnits.push(u);
  var scopeName = this.gensym('scope');
  u.scopename = scopeName;
  this.u = u;
  this.u.activateScope();
  this.nestlevel++;
  return scopeName;
};
Compiler.prototype.exitScope = function () {
  var prev = this.u;
  this.nestlevel--;
  if (this.stack.length - 1 >= 0)
    this.u = this.stack.pop();
  else
    this.u = null;
  if (this.u)
    this.u.activateScope();
  if (prev.name.v !== '<module>') {
    var mangled = prev.name['$r']().v;
    mangled = mangled.substring(1, mangled.length - 1);
    mangled = fixReservedWords(mangled);
    mangled = fixReservedNames(mangled);
    out(prev.scopename, '.co_name=new Sk.builtins[\'str\'](\'', mangled, '\');');
  }
};
Compiler.prototype.cbody = function (stmts) {
  for (var i = 0; i < stmts.length; ++i)
    this.vstmt(stmts[i]);
};
Compiler.prototype.cprint = function (s) {
  goog.asserts.assert(s instanceof Print);
  var dest = 'null';
  if (s.dest)
    dest = this.vexpr(s.dest);
  var n = s.values.length;
  for (var i = 0; i < n; ++i)
    out('Sk.misceval.print_(', 'new Sk.builtins[\'str\'](', this.vexpr(s.values[i]), ').v);');
  if (s.nl)
    out('Sk.misceval.print_(', '"\\n");');
};
Compiler.prototype.cmod = function (mod) {
  var modf = this.enterScope(new Sk.builtin.str('<module>'), mod, 0);
  var entryBlock = this.newBlock('module entry');
  this.u.prefixCode = 'var ' + modf + '=(function($modname){';
  this.u.varDeclsCode = 'var $blk=' + entryBlock + ',$exc=[],$gbl={},$loc=$gbl,$err=undefined;$gbl.__name__=$modname;Sk.globals=$gbl;';
  this.u.switchCode = 'try { while(true){try{ switch($blk){';
  this.u.suffixCode = '} }catch(err){if ($exc.length>0) { $err = err; $blk=$exc.pop(); continue; } else { throw err; }} } }catch(err){ if (err instanceof Sk.builtin.SystemExit && !Sk.throwSystemExit) { Sk.misceval.print_(err.toString() + \'\\n\'); return $loc; } else { throw err; } } });';
  switch (mod.constructor) {
  case Module:
    this.cbody(mod.body);
    out('return $loc;');
    break;
  default:
    goog.asserts.fail('todo; unhandled case in compilerMod');
  }
  this.exitScope();
  this.result.push(this.outputAllUnits());
  return modf;
};
Sk.compile = function (source, filename, mode) {
  var cst = Sk.parse(filename, source);
  var ast = Sk.astFromParse(cst, filename);
  var st = Sk.symboltable(ast, filename);
  var c = new Compiler(filename, st, 0, source);
  var funcname = c.cmod(ast);
  var ret = c.result.join('');
  return {
    funcname: funcname,
    code: ret
  };
};
goog.exportSymbol('Sk.compile', Sk.compile);
Sk.resetCompiler = function () {
  Sk.gensymcount = 0;
};
goog.exportSymbol('Sk.resetCompiler', Sk.resetCompiler);
Sk.sysmodules = new Sk.builtin.dict([]);
Sk.realsyspath = undefined;
Sk.importSearchPathForName = function (name, ext, failok) {
  var L = Sk.realsyspath;
  for (var it = L.tp$iter(), i = it.tp$iternext(); i !== undefined; i = it.tp$iternext()) {
    var nameAsPath = name.replace(/\./g, '/');
    var fns = [
        i.v + '/' + nameAsPath + ext,
        i.v + '/' + nameAsPath + '/__init__' + ext
      ];
    for (var j = 0; j < fns.length; ++j) {
      var fn = fns[j];
      try {
        Sk.read(fn);
        return fn;
      } catch (e) {
      }
      ;
    }
  }
  if (!failok)
    throw new Sk.builtin.ImportError('No module named ' + name);
};
Sk.doOneTimeInitialization = function () {
  Sk.builtin.type.basesStr_ = new Sk.builtin.str('__bases__');
  Sk.builtin.type.mroStr_ = new Sk.builtin.str('__mro__');
  Sk.builtin.object['$d'] = new Sk.builtin.dict([]);
  Sk.builtin.object['$d'].mp$ass_subscript(Sk.builtin.type.basesStr_, new Sk.builtin.tuple([]));
  Sk.builtin.object['$d'].mp$ass_subscript(Sk.builtin.type.mroStr_, new Sk.builtin.tuple([Sk.builtin.object]));
};
Sk.importSetUpPath = function () {
  if (!Sk.realsyspath) {
    var paths = [
        new Sk.builtin.str('src/builtin'),
        new Sk.builtin.str('src/lib'),
        new Sk.builtin.str('.')
      ];
    for (var i = 0; i < Sk.syspath.length; ++i)
      paths.push(new Sk.builtin.str(Sk.syspath[i]));
    Sk.realsyspath = new Sk.builtin.list(paths);
    Sk.doOneTimeInitialization();
  }
};
if (COMPILED) {
  var js_beautify = function (x) {
    return x;
  };
}
Sk.importModuleInternal_ = function (name, dumpJS, modname, suppliedPyBody) {
  Sk.importSetUpPath();
  if (modname === undefined)
    modname = name;
  var toReturn = null;
  var modNameSplit = modname.split('.');
  var parentModName;
  try {
    var prev = Sk.sysmodules.mp$subscript(modname);
    if (modNameSplit.length > 1)
      return Sk.sysmodules.mp$subscript(modNameSplit[0]);
    else
      return prev;
  } catch (x) {
  }
  if (modNameSplit.length > 1) {
    parentModName = modNameSplit.slice(0, modNameSplit.length - 1).join('.');
    toReturn = Sk.importModuleInternal_(parentModName, dumpJS);
  }
  var module = new Sk.builtin.module();
  Sk.sysmodules.mp$ass_subscript(name, module);
  var filename, co, googClosure;
  if (suppliedPyBody) {
    filename = name + '.py';
    co = Sk.compile(suppliedPyBody, filename, 'exec');
  } else {
    var builtinfn = Sk.importSearchPathForName(name, '.js', true);
    if (builtinfn) {
      filename = builtinfn;
      co = {
        funcname: '$builtinmodule',
        code: Sk.read(filename)
      };
    } else {
      filename = Sk.importSearchPathForName(name, '.py');
      co = Sk.compile(Sk.read(filename), filename, 'exec');
    }
  }
  module.$js = co.code;
  var finalcode = co.code;
  if (Sk.dateSet == null || !Sk.dateSet) {
    finalcode = 'Sk.execStart = new Date();\n' + co.code;
    Sk.dateSet = true;
  }
  {
    if (dumpJS) {
      var withLineNumbers = function (code) {
        var beaut = js_beautify(co.code);
        var lines = beaut.split('\n');
        for (var i = 1; i <= lines.length; ++i) {
          var width = ('' + i).length;
          var pad = '';
          for (var j = width; j < 5; ++j)
            pad += ' ';
          lines[i - 1] = '/* ' + pad + i + ' */ ' + lines[i - 1];
        }
        return lines.join('\n');
      };
      finalcode = withLineNumbers(co.code);
      Sk.debugout(finalcode);
    }
  }
  var namestr = 'new Sk.builtin.str(\'' + modname + '\')';
  finalcode += '\n' + co.funcname + '(' + namestr + ');';
  var modlocs = goog.global['eval'](finalcode);
  if (!modlocs['__name__'])
    modlocs['__name__'] = new Sk.builtin.str(modname);
  module['$d'] = modlocs;
  if (toReturn) {
    var parentModule = Sk.sysmodules.mp$subscript(parentModName);
    parentModule.tp$setattr(modNameSplit[modNameSplit.length - 1], module);
    return toReturn;
  }
  return module;
};
Sk.importModule = function (name, dumpJS) {
  return Sk.importModuleInternal_(name, dumpJS);
};
Sk.importMain = function (name, dumpJS) {
  Sk.dateSet = false;
  Sk.filesLoaded = false;
  Sk.sysmodules = new Sk.builtin.dict([]);
  Sk.realsyspath = undefined;
  Sk.resetCompiler();
  return Sk.importModuleInternal_(name, dumpJS, '__main__');
};
Sk.importMainWithBody = function (name, dumpJS, body) {
  Sk.dateSet = false;
  Sk.filesLoaded = false;
  Sk.sysmodules = new Sk.builtin.dict([]);
  Sk.realsyspath = undefined;
  Sk.resetCompiler();
  return Sk.importModuleInternal_(name, dumpJS, '__main__', body);
};
Sk.builtin.__import__ = function (name, globals, locals, fromlist) {
  var ret = Sk.importModuleInternal_(name);
  if (!fromlist || fromlist.length === 0)
    return ret;
  ret = Sk.sysmodules.mp$subscript(name);
  goog.asserts.assert(ret);
  return ret;
};
Sk.importStar = function (module, loc) {
  var props = Object['getOwnPropertyNames'](module['$d']);
  for (var i in props) {
    loc[props[i]] = module['$d'][props[i]];
  }
};
goog.exportSymbol('Sk.importMain', Sk.importMain);
goog.exportSymbol('Sk.importMainWithBody', Sk.importMainWithBody);
goog.exportSymbol('Sk.builtin.__import__', Sk.builtin.__import__);
goog.exportSymbol('Sk.importStar', Sk.importStar);
Sk.builtin.timSort = function (list, length) {
  this.list = new Sk.builtin.list(list.v);
  this.MIN_GALLOP = 7;
  if (length) {
    this.listlength = length;
  } else {
    this.listlength = list.sq$length();
  }
};
Sk.builtin.timSort.prototype.lt = function (a, b) {
  return Sk.misceval.richCompareBool(a, b, 'Lt');
};
Sk.builtin.timSort.prototype.le = function (a, b) {
  return !this.lt(b, a);
};
Sk.builtin.timSort.prototype.setitem = function (item, value) {
  this.list.v[item] = value;
};
Sk.builtin.timSort.prototype.binary_sort = function (a, sorted) {
  for (var start = a.base + sorted; start < a.base + a.len; start++) {
    var l = a.base;
    var r = start;
    var pivot = a.getitem(r);
    while (l < r) {
      var p = l + (r - l >> 1);
      if (this.lt(pivot, a.getitem(p))) {
        r = p;
      } else {
        l = p + 1;
      }
    }
    goog.asserts.assert(l === r);
    for (var p = start; p > l; p--) {
      a.setitem(p, a.getitem(p - 1));
    }
    a.setitem(l, pivot);
  }
};
Sk.builtin.timSort.prototype.count_run = function (a) {
  var descending;
  if (a.len <= 1) {
    var n = a.len;
    descending = false;
  } else {
    var n = 2;
    if (this.lt(a.getitem(a.base + 1), a.getitem(a.base))) {
      descending = true;
      for (var p = a.base + 2; p < a.base + a.len; p++) {
        if (this.lt(a.getitem(p), a.getitem(p - 1))) {
          n++;
        } else {
          break;
        }
      }
    } else {
      descending = false;
      for (p = a.base + 2; p < a.base + a.len; p++) {
        if (this.lt(a.getitem(p), a.getitem(p - 1))) {
          break;
        } else {
          n++;
        }
      }
    }
  }
  return {
    'run': new Sk.builtin.listSlice(a.list, a.base, n),
    'descending': descending
  };
};
Sk.builtin.timSort.prototype.sort = function () {
  var remaining = new Sk.builtin.listSlice(this.list, 0, this.listlength);
  if (remaining.len < 2) {
    return;
  }
  this.merge_init();
  var minrun = this.merge_compute_minrun(remaining.len);
  while (remaining.len > 0) {
    var cr = this.count_run(remaining);
    if (cr.descending) {
      cr.run.reverse();
    }
    if (cr.run.len < minrun) {
      var sorted = cr.run.len;
      if (minrun < remaining.len) {
        cr.run.len = minrun;
      } else {
        cr.run.len = remaining.len;
      }
      this.binary_sort(cr.run, sorted);
    }
    remaining.advance(cr.run.len);
    this.pending.push(cr.run);
    this.merge_collapse();
  }
  goog.asserts.assert(remaining.base == this.listlength);
  this.merge_force_collapse();
  goog.asserts.assert(this.pending.length == 1);
  goog.asserts.assert(this.pending[0].base == 0);
  goog.asserts.assert(this.pending[0].len == this.listlength);
};
Sk.builtin.timSort.prototype.gallop = function (key, a, hint, rightmost) {
  goog.asserts.assert(0 <= hint && hint < a.len);
  var lower;
  var self = this;
  if (rightmost) {
    lower = function (a, b) {
      return self.le(a, b);
    };
  } else {
    lower = function (a, b) {
      return self.lt(a, b);
    };
  }
  var p = a.base + hint;
  var lastofs = 0;
  var ofs = 1;
  var maxofs;
  if (lower(a.getitem(p), key)) {
    maxofs = a.len - hint;
    while (ofs < maxofs) {
      if (lower(a.getitem(p + ofs), key)) {
        lastofs = ofs;
        try {
          ofs = (ofs << 1) + 1;
        } catch (err) {
          ofs = maxofs;
        }
      } else {
        break;
      }
    }
    if (ofs > maxofs) {
      ofs = maxofs;
    }
    lastofs += hint;
    ofs += hint;
  } else {
    maxofs = hint + 1;
    while (ofs < maxofs) {
      if (lower(a.getitem(p - ofs), key)) {
        break;
      } else {
        lastofs = ofs;
        try {
          ofs = (ofs << 1) + 1;
        } catch (err) {
          ofs = maxofs;
        }
      }
    }
    if (ofs > maxofs) {
      ofs = maxofs;
    }
    var hintminofs = hint - ofs;
    var hintminlastofs = hint - lastofs;
    lastofs = hintminofs;
    ofs = hintminlastofs;
  }
  goog.asserts.assert(-1 <= lastofs < ofs <= a.len);
  lastofs += 1;
  while (lastofs < ofs) {
    var m = lastofs + (ofs - lastofs >> 1);
    if (lower(a.getitem(a.base + m), key)) {
      lastofs = m + 1;
    } else {
      ofs = m;
    }
  }
  goog.asserts.assert(lastofs == ofs);
  return ofs;
};
Sk.builtin.timSort.prototype.merge_init = function () {
  this.min_gallop = this.MIN_GALLOP;
  this.pending = [];
};
Sk.builtin.timSort.prototype.merge_lo = function (a, b) {
  goog.asserts.assert(a.len > 0 && b.len > 0 && a.base + a.len == b.base);
  var min_gallop = this.min_gallop;
  var dest = a.base;
  a = a.copyitems();
  try {
    this.setitem(dest, b.popleft());
    dest++;
    if (a.len == 1 || b.len == 0) {
      return;
    }
    var acount, bcount;
    while (true) {
      acount = 0;
      bcount = 0;
      while (true) {
        if (this.lt(b.getitem(b.base), a.getitem(a.base))) {
          this.setitem(dest, b.popleft());
          dest++;
          if (b.len == 0) {
            return;
          }
          bcount++;
          acount = 0;
          if (bcount >= min_gallop) {
            break;
          }
        } else {
          this.setitem(dest, a.popleft());
          dest++;
          if (a.len == 1) {
            return;
          }
          acount++;
          bcount = 0;
          if (acount >= min_gallop) {
            break;
          }
        }
      }
      min_gallop += 1;
      while (true) {
        min_gallop -= min_gallop > 1;
        this.min_gallop = min_gallop;
        acount = this.gallop(b.getitem(b.base), a, 0, true);
        for (var p = a.base; p < a.base + acount; p++) {
          this.setitem(dest, a.getitem(p));
          dest++;
        }
        a.advance(acount);
        if (a.len <= 1) {
          return;
        }
        this.setitem(dest, b.popleft());
        dest++;
        if (b.len == 0) {
          return;
        }
        bcount = this.gallop(a.getitem(a.base), b, 0, false);
        for (var p = b.base; p < b.base + bcount; p++) {
          this.setitem(dest, b.getitem(p));
          dest++;
        }
        b.advance(bcount);
        if (b.len == 0) {
          return;
        }
        this.setitem(dest, a.popleft());
        dest++;
        if (a.len == 1) {
          return;
        }
        if (acount < this.MIN_GALLOP && bcount < this.MIN_GALLOP) {
          break;
        }
        min_gallop++;
        this.min_gallop = min_gallop;
      }
    }
  } finally {
    goog.asserts.assert(a.len >= 0 && b.len >= 0);
    for (var p = b.base; p < b.base + b.len; p++) {
      this.setitem(dest, b.getitem(p));
      dest++;
    }
    for (var p = a.base; p < a.base + a.len; p++) {
      this.setitem(dest, a.getitem(p));
      dest++;
    }
  }
};
Sk.builtin.timSort.prototype.merge_hi = function (a, b) {
  goog.asserts.assert(a.len > 0 && b.len > 0 && a.base + a.len == b.base);
  var min_gallop = this.min_gallop;
  var dest = b.base + b.len;
  b = b.copyitems();
  try {
    dest--;
    this.setitem(dest, a.popright());
    if (a.len == 0 || b.len == 1) {
      return;
    }
    var acount, bcount, nexta, nextb;
    while (true) {
      acount = 0;
      bcount = 0;
      while (true) {
        nexta = a.getitem(a.base + a.len - 1);
        nextb = b.getitem(b.base + b.len - 1);
        if (this.lt(nextb, nexta)) {
          dest--;
          this.setitem(dest, nexta);
          a.len--;
          if (a.len == 0) {
            return;
          }
          acount++;
          bcount = 0;
          if (acount >= min_gallop) {
            break;
          }
        } else {
          dest--;
          this.setitem(dest, nextb);
          b.len--;
          if (b.len == 1) {
            return;
          }
          bcount++;
          acount = 0;
          if (bcount >= min_gallop) {
            break;
          }
        }
      }
      min_gallop += 1;
      while (true) {
        min_gallop -= min_gallop > 1;
        this.min_gallop = min_gallop;
        nextb = b.getitem(b.base + b.len - 1);
        var k = this.gallop(nextb, a, a.len - 1, true);
        acount = a.len - k;
        for (var p = a.base + a.len - 1; p > a.base + k - 1; p--) {
          dest--;
          this.setitem(dest, a.getitem(p));
        }
        a.len -= acount;
        if (a.len == 0) {
          return;
        }
        dest--;
        this.setitem(dest, b.popright());
        if (b.len == 1) {
          return;
        }
        nexta = a.getitem(a.base + a.len - 1);
        k = this.gallop(nexta, b, b.len - 1, false);
        bcount = b.len - k;
        for (var p = b.base + b.len - 1; p > b.base + k - 1; p--) {
          dest--;
          this.setitem(dest, b.getitem(p));
        }
        b.len -= bcount;
        if (b.len <= 1) {
          return;
        }
        dest--;
        this.setitem(dest, a.popright());
        if (a.len == 0) {
          return;
        }
        if (acount < this.MIN_GALLOP && bcount < this.MIN_GALLOP) {
          break;
        }
        min_gallop++;
        this.min_gallop = min_gallop;
      }
    }
  } finally {
    goog.asserts.assert(a.len >= 0 && b.len >= 0);
    for (var p = a.base + a.len - 1; p > a.base - 1; p--) {
      dest--;
      this.setitem(dest, a.getitem(p));
    }
    for (var p = b.base + b.len - 1; p > b.base - 1; p--) {
      dest--;
      this.setitem(dest, b.getitem(p));
    }
  }
};
Sk.builtin.timSort.prototype.merge_at = function (i) {
  if (i < 0) {
    i = this.pending.length + i;
  }
  var a = this.pending[i];
  var b = this.pending[i + 1];
  goog.asserts.assert(a.len > 0 && b.len > 0);
  goog.asserts.assert(a.base + a.len == b.base);
  this.pending[i] = new Sk.builtin.listSlice(this.list, a.base, a.len + b.len);
  this.pending.splice(i + 1, 1);
  var k = this.gallop(b.getitem(b.base), a, 0, true);
  a.advance(k);
  if (a.len == 0) {
    return;
  }
  b.len = this.gallop(a.getitem(a.base + a.len - 1), b, b.len - 1, false);
  if (b.len == 0) {
    return;
  }
  if (a.len <= b.len) {
    this.merge_lo(a, b);
  } else {
    this.merge_hi(a, b);
  }
};
Sk.builtin.timSort.prototype.merge_collapse = function () {
  var p = this.pending;
  while (p.length > 1) {
    if (p.length >= 3 && p[p.length - 3].len <= p[p.length - 2].len + p[p.length - 1].len) {
      if (p[p.length - 3].len < p[p.length - 1].len) {
        this.merge_at(-3);
      } else {
        this.merge_at(-2);
      }
    } else if (p[p.length - 2].len <= p[p.length - 1].len) {
      this.merge_at(-2);
    } else {
      break;
    }
  }
};
Sk.builtin.timSort.prototype.merge_force_collapse = function () {
  var p = this.pending;
  while (p.length > 1) {
    if (p.length >= 3 && p[p.length - 3].len < p[p.length - 1].len) {
      this.merge_at(-3);
    } else {
      this.merge_at(-2);
    }
  }
};
Sk.builtin.timSort.prototype.merge_compute_minrun = function (n) {
  var r = 0;
  while (n >= 64) {
    r = r | n & 1;
    n >>= 1;
  }
  return n + r;
};
Sk.builtin.listSlice = function (list, base, len) {
  this.list = list;
  this.base = base;
  this.len = len;
};
Sk.builtin.listSlice.prototype.copyitems = function () {
  var start = this.base;
  var stop = this.base + this.len;
  goog.asserts.assert(0 <= start <= stop);
  return new Sk.builtin.listSlice(new Sk.builtin.list(this.list.v.slice(start, stop)), 0, this.len);
};
Sk.builtin.listSlice.prototype.advance = function (n) {
  this.base += n;
  this.len -= n;
  goog.asserts.assert(this.base <= this.list.sq$length());
};
Sk.builtin.listSlice.prototype.getitem = function (item) {
  return this.list.v[item];
};
Sk.builtin.listSlice.prototype.setitem = function (item, value) {
  this.list.v[item] = value;
};
Sk.builtin.listSlice.prototype.popleft = function () {
  var result = this.list.v[this.base];
  this.base++;
  this.len--;
  return result;
};
Sk.builtin.listSlice.prototype.popright = function () {
  this.len--;
  return this.list.v[this.base + this.len];
};
Sk.builtin.listSlice.prototype.reverse = function () {
  var list = this.list;
  var lo = this.base;
  var hi = lo + this.len - 1;
  while (lo < hi) {
    var list_hi = list.v[hi];
    var list_lo = list.v[lo];
    list.v[lo] = list_hi;
    list.v[hi] = list_lo;
    lo++;
    hi--;
  }
};
goog.exportSymbol('Sk.builtin.listSlice', Sk.builtin.listSlice);
goog.exportSymbol('Sk.builtin.timSort', Sk.builtin.timSort);
Sk.builtins = {
  'range': Sk.builtin.range,
  'round': Sk.builtin.round,
  'len': Sk.builtin.len,
  'min': Sk.builtin.min,
  'max': Sk.builtin.max,
  'sum': Sk.builtin.sum,
  'zip': Sk.builtin.zip,
  'abs': Sk.builtin.abs,
  'fabs': Sk.builtin.abs,
  'ord': Sk.builtin.ord,
  'chr': Sk.builtin.chr,
  'hex': Sk.builtin.hex,
  'oct': Sk.builtin.oct,
  'bin': Sk.builtin.bin,
  'dir': Sk.builtin.dir,
  'repr': Sk.builtin.repr,
  'open': Sk.builtin.open,
  'isinstance': Sk.builtin.isinstance,
  'hash': Sk.builtin.hash,
  'getattr': Sk.builtin.getattr,
  'float_$rw$': Sk.builtin.float_,
  'int_$rw$': Sk.builtin.int_,
  'hasattr': Sk.builtin.hasattr,
  'map': Sk.builtin.map,
  'filter': Sk.builtin.filter,
  'reduce': Sk.builtin.reduce,
  'sorted': Sk.builtin.sorted,
  'bool': Sk.builtin.bool,
  'any': Sk.builtin.any,
  'all': Sk.builtin.all,
  'enumerate': Sk.builtin.enumerate,
  'AttributeError': Sk.builtin.AttributeError,
  'ValueError': Sk.builtin.ValueError,
  'Exception': Sk.builtin.Exception,
  'ZeroDivisionError': Sk.builtin.ZeroDivisionError,
  'AssertionError': Sk.builtin.AssertionError,
  'ImportError': Sk.builtin.ImportError,
  'IndentationError': Sk.builtin.IndentationError,
  'IndexError': Sk.builtin.IndexError,
  'KeyError': Sk.builtin.KeyError,
  'TypeError': Sk.builtin.TypeError,
  'NameError': Sk.builtin.NameError,
  'IOError': Sk.builtin.IOError,
  'NotImplementedError': Sk.builtin.NotImplementedError,
  'SystemExit': Sk.builtin.SystemExit,
  'OverflowError': Sk.builtin.OverflowError,
  'OperationError': Sk.builtin.OperationError,
  'dict': Sk.builtin.dict,
  'file': Sk.builtin.file,
  'function': Sk.builtin.func,
  'generator': Sk.builtin.generator,
  'list': Sk.builtin.list,
  'long_$rw$': Sk.builtin.lng,
  'method': Sk.builtin.method,
  'object': Sk.builtin.object,
  'slice': Sk.builtin.slice,
  'str': Sk.builtin.str,
  'set': Sk.builtin.set,
  'tuple': Sk.builtin.tuple,
  'type': Sk.builtin.type,
  'input': Sk.builtin.input,
  'raw_input': Sk.builtin.raw_input,
  'jseval': Sk.builtin.jseval,
  'jsmillis': Sk.builtin.jsmillis,
  'quit': Sk.builtin.quit,
  'exit': Sk.builtin.quit,
  'bytearray': Sk.builtin.bytearray,
  'callable': Sk.builtin.callable,
  'complex': Sk.builtin.complex,
  'delattr': Sk.builtin.delattr,
  'divmod': Sk.builtin.divmod,
  'eval_$rn$': Sk.builtin.eval_,
  'execfile': Sk.builtin.execfile,
  'format': Sk.builtin.format,
  'frozenset': Sk.builtin.frozenset,
  'globals': Sk.builtin.globals,
  'help': Sk.builtin.help,
  'issubclass': Sk.builtin.issubclass,
  'iter': Sk.builtin.iter,
  'locals': Sk.builtin.locals,
  'memoryview': Sk.builtin.memoryview,
  'next': Sk.builtin.next_,
  'pow': Sk.builtin.pow,
  'property': Sk.builtin.property,
  'reload': Sk.builtin.reload,
  'reversed': Sk.builtin.reversed,
  'super': Sk.builtin.superbi,
  'unichr': Sk.builtin.unichr,
  'vars': Sk.builtin.vars,
  'xrange': Sk.builtin.xrange,
  'apply_$rn$': Sk.builtin.apply_,
  'buffer': Sk.builtin.buffer,
  'coerce': Sk.builtin.coerce,
  'intern': Sk.builtin.intern
};
goog.exportSymbol('Sk.builtins', Sk.builtins);
Sk.builtin.buildDocumentClass = function (mod) {
  var DOCUMENT_CLASS = 'Document';
  var EVENT = 'Event';
  var NODE = 'Node';
  var PROP_BODY = 'body';
  var PROP_WEBKIT_HIDDEN = 'webkitHidden';
  var METHOD_ADD_EVENT_LISTENER = 'addEventListener';
  var METHOD_CREATE_ELEMENT = 'createElement';
  var METHOD_GET_ELEMENT_BY_ID = 'getElementById';
  var METHOD_GET_ELEMENTS_BY_TAG_NAME = 'getElementsByTagName';
  var METHOD_REMOVE_EVENT_LISTENER = 'removeEventListener';
  var wrapNode = function (node) {
    if (node) {
      return Sk.misceval.callsim(mod[NODE], node);
    } else {
      return Sk.builtin.none.none$;
    }
  };
  var stringFromArg = function (arg) {
    if (arg) {
      return arg.v;
    } else {
      return null;
    }
  };
  var docListeners = {};
  return Sk.misceval.buildClass(mod, function ($gbl, $loc) {
    $loc.__init__ = new Sk.builtin.func(function (documentPy) {
      documentPy.tp$name = DOCUMENT_CLASS;
      documentPy.v = document;
    });
    $loc.__getattr__ = new Sk.builtin.func(function (self, name) {
      switch (name) {
      case PROP_BODY: {
          return Sk.misceval.callsim(mod[NODE], document[PROP_BODY]);
        }
      case PROP_WEBKIT_HIDDEN: {
          return document[PROP_WEBKIT_HIDDEN];
        }
      case METHOD_ADD_EVENT_LISTENER: {
          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function ($gbl, $loc) {
            $loc.__init__ = new Sk.builtin.func(function (self) {
              self.tp$name = METHOD_ADD_EVENT_LISTENER;
            });
            $loc.__call__ = new Sk.builtin.func(function (self, typePy, listenerPy, useCapture) {
              var type = Sk.ffi.remapToJs(typePy);
              var listener = function (event) {
                var eventPy = Sk.misceval.callsim(mod[EVENT], Sk.ffi.remapToPy(event, EVENT));
                Sk.misceval.callsim(listenerPy, eventPy);
              };
              docListeners[type] = listener;
              document[METHOD_ADD_EVENT_LISTENER](type, listener, useCapture);
            });
            $loc.__str__ = new Sk.builtin.func(function (self) {
              return new Sk.builtin.str(METHOD_ADD_EVENT_LISTENER);
            });
            $loc.__repr__ = new Sk.builtin.func(function (self) {
              return new Sk.builtin.str(METHOD_ADD_EVENT_LISTENER);
            });
          }, METHOD_ADD_EVENT_LISTENER, []));
        }
      case METHOD_REMOVE_EVENT_LISTENER: {
          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function ($gbl, $loc) {
            $loc.__init__ = new Sk.builtin.func(function (self) {
              self.tp$name = METHOD_REMOVE_EVENT_LISTENER;
            });
            $loc.__call__ = new Sk.builtin.func(function (self, typePy, listener, useCapture) {
              var type = Sk.ffi.remapToJs(typePy);
              var listener = docListeners[type];
              delete docListeners[type];
              document[METHOD_REMOVE_EVENT_LISTENER](type, listener, useCapture);
            });
            $loc.__str__ = new Sk.builtin.func(function (self) {
              return new Sk.builtin.str(METHOD_REMOVE_EVENT_LISTENER);
            });
            $loc.__repr__ = new Sk.builtin.func(function (self) {
              return new Sk.builtin.str(METHOD_REMOVE_EVENT_LISTENER);
            });
          }, METHOD_REMOVE_EVENT_LISTENER, []));
        }
      case METHOD_CREATE_ELEMENT: {
          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function ($gbl, $loc) {
            $loc.__init__ = new Sk.builtin.func(function (self) {
              self.tp$name = METHOD_CREATE_ELEMENT;
            });
            $loc.__call__ = new Sk.builtin.func(function (self, tagName, attributes) {
              var element = document.createElement(stringFromArg(tagName));
              if (attributes instanceof Sk.builtin.dict) {
                for (var iter = attributes.tp$iter(), k = iter.tp$iternext(); k !== undefined; k = iter.tp$iternext()) {
                  var v = attributes.mp$subscript(k);
                  if (v === undefined) {
                    v = null;
                  }
                  var kAsJs = Sk.ffi.remapToJs(k);
                  var vAsJs = Sk.ffi.remapToJs(v);
                  element.setAttribute(kAsJs, vAsJs);
                }
              }
              return wrapNode(element);
            });
            $loc.__str__ = new Sk.builtin.func(function (self) {
              return new Sk.builtin.str(METHOD_CREATE_ELEMENT);
            });
            $loc.__repr__ = new Sk.builtin.func(function (self) {
              return new Sk.builtin.str(METHOD_CREATE_ELEMENT);
            });
          }, METHOD_CREATE_ELEMENT, []));
        }
      case METHOD_GET_ELEMENT_BY_ID: {
          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function ($gbl, $loc) {
            $loc.__init__ = new Sk.builtin.func(function (self) {
              self.tp$name = METHOD_GET_ELEMENT_BY_ID;
            });
            $loc.__call__ = new Sk.builtin.func(function (self, id) {
              return wrapNode(document.getElementById(stringFromArg(id)));
            });
            $loc.__str__ = new Sk.builtin.func(function (self) {
              return new Sk.builtin.str(METHOD_GET_ELEMENT_BY_ID);
            });
            $loc.__repr__ = new Sk.builtin.func(function (self) {
              return new Sk.builtin.str(METHOD_GET_ELEMENT_BY_ID);
            });
          }, METHOD_GET_ELEMENT_BY_ID, []));
        }
      case METHOD_GET_ELEMENTS_BY_TAG_NAME: {
          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function ($gbl, $loc) {
            $loc.__init__ = new Sk.builtin.func(function (self) {
              self.tp$name = METHOD_GET_ELEMENTS_BY_TAG_NAME;
            });
            $loc.__call__ = new Sk.builtin.func(function (self, tagName) {
              var elements = document.getElementsByTagName(stringFromArg(tagName));
              var xs = [];
              for (var i = elements.length - 1; i >= 0; i--) {
                xs.push(wrapNode(elements[i]));
              }
              return new Sk.builtin.list(xs);
            });
            $loc.__str__ = new Sk.builtin.func(function (self) {
              return new Sk.builtin.str(METHOD_GET_ELEMENTS_BY_TAG_NAME);
            });
            $loc.__repr__ = new Sk.builtin.func(function (self) {
              return new Sk.builtin.str(METHOD_GET_ELEMENTS_BY_TAG_NAME);
            });
          }, METHOD_GET_ELEMENTS_BY_TAG_NAME, []));
        }
      }
    });
    $loc.__str__ = new Sk.builtin.func(function (self) {
      return new Sk.builtin.str(DOCUMENT_CLASS);
    });
    $loc.__repr__ = new Sk.builtin.func(function (self) {
      return new Sk.builtin.str(DOCUMENT_CLASS);
    });
  }, DOCUMENT_CLASS, []);
};
Sk.builtin.buildEventClass = function (mod) {
  var EVENT = 'Event';
  var PROP_ALT_KEY = 'altKey';
  var PROP_BUBBLES = 'bubbles';
  var PROP_BUTTON = 'button';
  var PROP_CANCELABLE = 'cancelable';
  var PROP_CLIENT_X = 'clientX';
  var PROP_CLIENT_Y = 'clientY';
  var PROP_CTRL_KEY = 'ctrlKey';
  var PROP_DEFAULT_PREVENTED = 'defaultPrevented';
  var PROP_KEY_CODE = 'keyCode';
  var PROP_SCREEN_X = 'screenX';
  var PROP_SCREEN_Y = 'screenY';
  var PROP_SHIFT_KEY = 'shiftKey';
  var PROP_TARGET = 'target';
  var PROP_TYPE = 'type';
  var METHOD_ADD_EVENT_LISTENER = 'addEventListener';
  var METHOD_PREVENT_DEFAULT = 'preventDefault';
  var METHOD_STOP_IMMEDIATE_PROPAGATION = 'stopImmediatePropagation';
  var METHOD_STOP_PROPAGATION = 'stopPropagation';
  return Sk.misceval.buildClass(mod, function ($gbl, $loc) {
    $loc.__init__ = new Sk.builtin.func(function (eventPy, argPy) {
      eventPy.tp$name = EVENT;
      eventPy.v = Sk.ffi.remapToJs(argPy);
    });
    $loc.__getattr__ = new Sk.builtin.func(function (eventPy, name) {
      var event = Sk.ffi.remapToJs(eventPy);
      switch (name) {
      case PROP_ALT_KEY: {
          return event[PROP_ALT_KEY];
        }
      case PROP_BUBBLES: {
          return event[PROP_BUBBLES];
        }
      case PROP_BUTTON: {
          return Sk.builtin.assk$(event[PROP_BUTTON], Sk.builtin.nmber.int$);
        }
      case PROP_CANCELABLE: {
          return event[PROP_CANCELABLE];
        }
      case PROP_CLIENT_X: {
          return Sk.builtin.assk$(event[PROP_CLIENT_X], Sk.builtin.nmber.int$);
        }
      case PROP_CLIENT_Y: {
          return Sk.builtin.assk$(event[PROP_CLIENT_Y], Sk.builtin.nmber.int$);
        }
      case PROP_CTRL_KEY: {
          return event[PROP_CTRL_KEY];
        }
      case PROP_DEFAULT_PREVENTED: {
          return event[PROP_DEFAULT_PREVENTED];
        }
      case PROP_KEY_CODE: {
          return Sk.builtin.assk$(event[PROP_KEY_CODE], Sk.builtin.nmber.int$);
        }
      case PROP_SCREEN_X: {
          return Sk.builtin.assk$(event[PROP_SCREEN_X], Sk.builtin.nmber.int$);
        }
      case PROP_SCREEN_Y: {
          return Sk.builtin.assk$(event[PROP_SCREEN_Y], Sk.builtin.nmber.int$);
        }
      case PROP_SHIFT_KEY: {
          return event[PROP_SHIFT_KEY];
        }
      case PROP_TARGET: {
          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function ($gbl, $loc) {
            $loc.__init__ = new Sk.builtin.func(function (targetPy) {
              targetPy.tp$name = PROP_TARGET;
              targetPy.v = event.target;
            });
            $loc.__getattr__ = new Sk.builtin.func(function (targetPy, name) {
              return Sk.ffi.remapToPy(event.target[name], '');
            });
            $loc.__setattr__ = new Sk.builtin.func(function (targetPy, name, valuePy) {
              event.target[name] = Sk.ffi.remapToJs(valuePy);
            });
            $loc.__str__ = new Sk.builtin.func(function (targetPy) {
              var target = Sk.ffi.remapToJs(targetPy);
              return new Sk.builtin.str('' + target);
            });
            $loc.__repr__ = new Sk.builtin.func(function (targetPy) {
              var target = Sk.ffi.remapToJs(targetPy);
              return new Sk.builtin.str('' + target);
            });
          }, PROP_TARGET, []));
        }
      case PROP_TYPE: {
          return new Sk.builtin.str(event[PROP_TYPE]);
        }
      case METHOD_ADD_EVENT_LISTENER: {
          return Sk.builtin.addEventListener(mod, event);
        }
      case METHOD_PREVENT_DEFAULT: {
          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function ($gbl, $loc) {
            $loc.__init__ = new Sk.builtin.func(function (self) {
              self.tp$name = METHOD_PREVENT_DEFAULT;
            });
            $loc.__call__ = new Sk.builtin.func(function (self) {
              event[METHOD_PREVENT_DEFAULT]();
            });
            $loc.__str__ = new Sk.builtin.func(function (self) {
              return new Sk.builtin.str(METHOD_PREVENT_DEFAULT);
            });
            $loc.__repr__ = new Sk.builtin.func(function (self) {
              return new Sk.builtin.str(METHOD_PREVENT_DEFAULT);
            });
          }, METHOD_PREVENT_DEFAULT, []));
        }
      case METHOD_STOP_IMMEDIATE_PROPAGATION: {
          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function ($gbl, $loc) {
            $loc.__init__ = new Sk.builtin.func(function (self) {
              self.tp$name = METHOD_STOP_IMMEDIATE_PROPAGATION;
            });
            $loc.__call__ = new Sk.builtin.func(function (self) {
              event[METHOD_STOP_IMMEDIATE_PROPAGATION]();
            });
            $loc.__str__ = new Sk.builtin.func(function (self) {
              return new Sk.builtin.str(METHOD_STOP_IMMEDIATE_PROPAGATION);
            });
            $loc.__repr__ = new Sk.builtin.func(function (self) {
              return new Sk.builtin.str(METHOD_STOP_IMMEDIATE_PROPAGATION);
            });
          }, METHOD_STOP_IMMEDIATE_PROPAGATION, []));
        }
      case METHOD_STOP_PROPAGATION: {
          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function ($gbl, $loc) {
            $loc.__init__ = new Sk.builtin.func(function (self) {
              self.tp$name = METHOD_STOP_PROPAGATION;
            });
            $loc.__call__ = new Sk.builtin.func(function (self) {
              event[METHOD_STOP_PROPAGATION]();
            });
            $loc.__str__ = new Sk.builtin.func(function (self) {
              return new Sk.builtin.str(METHOD_STOP_PROPAGATION);
            });
            $loc.__repr__ = new Sk.builtin.func(function (self) {
              return new Sk.builtin.str(METHOD_STOP_PROPAGATION);
            });
          }, METHOD_STOP_PROPAGATION, []));
        }
      default: {
          return Sk.ffi.remapToPy(event[name], '');
        }
      }
    });
    $loc.__str__ = new Sk.builtin.func(function (eventPy) {
      var event = Sk.ffi.remapToJs(eventPy);
      return new Sk.builtin.str('' + event);
    });
    $loc.__repr__ = new Sk.builtin.func(function (eventPy) {
      var event = Sk.ffi.remapToJs(eventPy);
      return new Sk.builtin.str('' + event);
    });
  }, EVENT, []);
};
Sk.builtin.addEventListener = function (mod, eventTarget) {
  var EVENT = 'Event';
  var METHOD_ADD_EVENT_LISTENER = 'addEventListener';
  return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function ($gbl, $loc) {
    $loc.__init__ = new Sk.builtin.func(function (self) {
      self.tp$name = METHOD_ADD_EVENT_LISTENER;
      self.v = eventTarget[METHOD_ADD_EVENT_LISTENER];
    });
    $loc.__call__ = new Sk.builtin.func(function (self, typePy, listenerPy, useCapturePy) {
      var type = Sk.ffi.remapToJs(typePy);
      var listenerJs = function (event) {
        var eventPy = Sk.misceval.callsim(mod[EVENT], Sk.ffi.referenceToPy(event, EVENT));
        Sk.misceval.callsim(listenerPy, eventPy);
      };
      var useCapture = Sk.ffi.remapToJs(useCapturePy);
      eventTarget[METHOD_ADD_EVENT_LISTENER](type, listenerJs, useCapture);
    });
  }, METHOD_ADD_EVENT_LISTENER, []));
};
Sk.builtin.buildNodeClass = function (mod) {
  var NODE = 'Node';
  var CANVAS_GRADIENT_CLASS = 'CanvasGradient';
  var CANVAS_RENDERING_CONTEXT_2D = 'CanvasRenderingContext2D';
  var PROP_CLIENT_HEIGHT = 'clientHeight';
  var PROP_CLIENT_WIDTH = 'clientWidth';
  var PROP_DIR = 'dir';
  var PROP_FILL_STYLE = 'fillStyle';
  var PROP_FIRST_CHILD = 'firstChild';
  var PROP_FONT = 'font';
  var PROP_HEIGHT = 'height';
  var PROP_LAST_CHILD = 'lastChild';
  var PROP_LEFT = 'left';
  var PROP_LINE_CAP = 'lineCap';
  var PROP_LINE_JOIN = 'lineJoin';
  var PROP_LINE_WIDTH = 'lineWidth';
  var PROP_NEXT_SIBLING = 'nextSibling';
  var PROP_PARENT_NODE = 'parentNode';
  var PROP_POSITION = 'position';
  var PROP_PREVIOUS_SIBLING = 'previousSibling';
  var PROP_SHADOW_BLUR = 'shadowBlur';
  var PROP_SHADOW_COLOR = 'shadowColor';
  var PROP_SHADOW_OFFSET_X = 'shadowOffsetX';
  var PROP_SHADOW_OFFSET_Y = 'shadowOffsetY';
  var PROP_STYLE = 'style';
  var PROP_STROKE_STYLE = 'strokeStyle';
  var PROP_TEXT_ALIGN = 'textAlign';
  var PROP_TEXT_BASELINE = 'textBaseline';
  var PROP_TOP = 'top';
  var PROP_WEBKIT_BACKING_STORE_PIXEL_RATIO = 'webkitBackingStorePixelRatio';
  var PROP_WIDTH = 'width';
  var METHOD_ADD_COLOR_STOP = 'addColorStop';
  var METHOD_APPEND_CHILD = 'appendChild';
  var METHOD_ARC = 'arc';
  var METHOD_ARC_TO = 'arcTo';
  var METHOD_BEGIN_PATH = 'beginPath';
  var METHOD_BEZIER_CURVE_TO = 'bezierCurveTo';
  var METHOD_CLEAR_RECT = 'clearRect';
  var METHOD_CLIP = 'clip';
  var METHOD_CLOSE_PATH = 'closePath';
  var METHOD_CREATE_LINEAR_GRADIENT = 'createLinearGradient';
  var METHOD_FILL = 'fill';
  var METHOD_FILL_RECT = 'fillRect';
  var METHOD_FILL_TEXT = 'fillText';
  var METHOD_GET_CONTEXT = 'getContext';
  var METHOD_INSERT_BEFORE = 'insertBefore';
  var METHOD_LINE_TO = 'lineTo';
  var METHOD_MOVE_TO = 'moveTo';
  var METHOD_QUADRATIC_CURVE_TO = 'quadraticCurveTo';
  var METHOD_RECT = 'rect';
  var METHOD_REMOVE_CHILD = 'removeChild';
  var METHOD_RESTORE = 'restore';
  var METHOD_ROTATE = 'rotate';
  var METHOD_SAVE = 'save';
  var METHOD_SCALE = 'scale';
  var METHOD_SET_ATTRIBUTE = 'setAttribute';
  var METHOD_SET_TRANSFORM = 'setTransform';
  var METHOD_STROKE = 'stroke';
  var METHOD_STROKE_RECT = 'strokeRect';
  var METHOD_STROKE_TEXT = 'strokeText';
  var METHOD_TRANSFORM = 'transform';
  var METHOD_TRANSLATE = 'translate';
  var wrapNode = function (node) {
    if (node) {
      return Sk.misceval.callsim(mod[NODE], node);
    } else {
      return Sk.builtin.none.none$;
    }
  };
  var wrapNumber = function (n) {
    if (typeof n === 'number') {
      return Sk.builtin.assk$(n, Sk.builtin.nmber.float$);
    } else {
      return Sk.builtin.none.none$;
    }
  };
  var wrapString = function (s) {
    if (typeof s === 'string') {
      return new Sk.builtin.str(s);
    } else {
      return Sk.builtin.none.none$;
    }
  };
  var nodeFromArg = function (arg) {
    if (arg) {
      return arg.v;
    } else {
      return null;
    }
  };
  var numberFromArg = function (arg) {
    if (arg) {
      return arg.v;
    } else {
      return null;
    }
  };
  var stringFromArg = function (arg) {
    if (arg) {
      return arg.v;
    } else {
      return null;
    }
  };
  return Sk.misceval.buildClass(mod, function ($gbl, $loc) {
    $loc.__init__ = new Sk.builtin.func(function (self, node) {
      self.tp$name = NODE;
      self.v = node;
    });
    $loc.__getattr__ = new Sk.builtin.func(function (nodePy, name) {
      var node = Sk.ffi.remapToJs(nodePy);
      switch (name) {
      case PROP_CLIENT_HEIGHT: {
          return wrapNumber(node[PROP_CLIENT_HEIGHT]);
        }
      case PROP_CLIENT_WIDTH: {
          return wrapNumber(node[PROP_CLIENT_WIDTH]);
        }
      case PROP_DIR: {
          return new Sk.builtin.str(node[PROP_DIR]);
        }
      case PROP_FIRST_CHILD: {
          return wrapNode(node[PROP_FIRST_CHILD]);
        }
      case PROP_LAST_CHILD: {
          return wrapNode(node[PROP_LAST_CHILD]);
        }
      case PROP_NEXT_SIBLING: {
          return wrapNode(node[PROP_NEXT_SIBLING]);
        }
      case PROP_PARENT_NODE: {
          return wrapNode(node[PROP_PARENT_NODE]);
        }
      case PROP_PREVIOUS_SIBLING: {
          return wrapNode(node[PROP_PREVIOUS_SIBLING]);
        }
      case PROP_HEIGHT: {
          return Sk.builtin.assk$(node[PROP_HEIGHT], Sk.builtin.nmber.int$);
        }
      case PROP_WIDTH: {
          return Sk.builtin.assk$(node[PROP_WIDTH], Sk.builtin.nmber.int$);
        }
      case PROP_STYLE: {
          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function ($gbl, $loc) {
            $loc.__init__ = new Sk.builtin.func(function (self) {
              self.tp$name = PROP_STYLE;
              self.v = node.style;
            });
            $loc.__getattr__ = new Sk.builtin.func(function (stylePy, name) {
              var style = Sk.ffi.remapToJs(stylePy);
              switch (name) {
              case PROP_HEIGHT: {
                  return new Sk.builtin.str(style[PROP_HEIGHT]);
                }
              case PROP_LEFT: {
                  return new Sk.builtin.str(style[PROP_LEFT]);
                }
              case PROP_POSITION: {
                  return new Sk.builtin.str(style[PROP_POSITION]);
                }
              case PROP_TOP: {
                  return new Sk.builtin.str(style[PROP_TOP]);
                }
              case PROP_WIDTH: {
                  return new Sk.builtin.str(style[PROP_WIDTH]);
                }
              }
            });
            $loc.__setattr__ = new Sk.builtin.func(function (stylePy, name, valuePy) {
              var style = Sk.ffi.remapToJs(stylePy);
              var value = Sk.ffi.remapToJs(valuePy);
              switch (name) {
              case PROP_HEIGHT: {
                  style[PROP_HEIGHT] = value;
                }
                break;
              case PROP_LEFT: {
                  style[PROP_LEFT] = value;
                }
                break;
              case PROP_POSITION: {
                  style[PROP_POSITION] = value;
                }
                break;
              case PROP_TOP: {
                  style[PROP_TOP] = value;
                }
                break;
              case PROP_WIDTH: {
                  style[PROP_WIDTH] = value;
                }
                break;
              default: {
                  throw new Sk.builtin.AssertionError(name + ' is not a writeable attribute of ' + PROP_STYLE);
                }
              }
            });
            $loc.__str__ = new Sk.builtin.func(function (self) {
              return new Sk.builtin.str(PROP_STYLE);
            });
            $loc.__repr__ = new Sk.builtin.func(function (self) {
              return new Sk.builtin.str(PROP_STYLE);
            });
          }, PROP_STYLE, []));
        }
      case METHOD_APPEND_CHILD: {
          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function ($gbl, $loc) {
            $loc.__init__ = new Sk.builtin.func(function (self) {
              self.tp$name = METHOD_APPEND_CHILD;
            });
            $loc.__call__ = new Sk.builtin.func(function (self, childNode) {
              return wrapNode(node.appendChild(nodeFromArg(childNode)));
            });
            $loc.__str__ = new Sk.builtin.func(function (self) {
              return new Sk.builtin.str(METHOD_APPEND_CHILD);
            });
            $loc.__repr__ = new Sk.builtin.func(function (self) {
              return new Sk.builtin.str(METHOD_APPEND_CHILD);
            });
          }, METHOD_APPEND_CHILD, []));
        }
      case METHOD_GET_CONTEXT: {
          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function ($gbl, $loc) {
            $loc.__init__ = new Sk.builtin.func(function (self) {
              self.tp$name = METHOD_GET_CONTEXT;
            });
            $loc.__call__ = new Sk.builtin.func(function (self, contextIdPy, contextAttributePy) {
              var contextId = Sk.ffi.remapToJs(contextIdPy);
              var contextAttribute = Sk.ffi.remapToJs(contextAttributePy);
              var context = node.getContext(contextId, contextAttribute);
              return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function ($gbl, $loc) {
                $loc.__init__ = new Sk.builtin.func(function (self) {
                  self.tp$name = CANVAS_RENDERING_CONTEXT_2D;
                  self.v = context;
                });
                $loc.__getattr__ = new Sk.builtin.func(function (contextPy, name) {
                  switch (name) {
                  case PROP_FILL_STYLE: {
                      return new Sk.builtin.str(context[PROP_FILL_STYLE]);
                    }
                  case PROP_FONT: {
                      return new Sk.builtin.str(context[PROP_FONT]);
                    }
                  case PROP_LINE_CAP: {
                      return new Sk.builtin.str(context[PROP_LINE_CAP]);
                    }
                  case PROP_LINE_JOIN: {
                      return new Sk.builtin.str(context[PROP_LINE_JOIN]);
                    }
                  case PROP_LINE_WIDTH: {
                      return Sk.builtin.assk$(context[PROP_LINE_WIDTH], Sk.builtin.nmber.int$);
                    }
                  case PROP_SHADOW_BLUR: {
                      return Sk.builtin.assk$(context[PROP_SHADOW_BLUR], Sk.builtin.nmber.int$);
                    }
                  case PROP_SHADOW_COLOR: {
                      return new Sk.builtin.str(context[PROP_SHADOW_COLOR]);
                    }
                  case PROP_SHADOW_OFFSET_X: {
                      return Sk.builtin.assk$(context[PROP_SHADOW_OFFSET_X], Sk.builtin.nmber.int$);
                    }
                  case PROP_SHADOW_OFFSET_Y: {
                      return Sk.builtin.assk$(context[PROP_SHADOW_OFFSET_Y], Sk.builtin.nmber.int$);
                    }
                  case PROP_STROKE_STYLE: {
                      return new Sk.builtin.str(context[PROP_STROKE_STYLE]);
                    }
                  case PROP_TEXT_ALIGN: {
                      return new Sk.builtin.str(context[PROP_TEXT_ALIGN]);
                    }
                  case PROP_TEXT_BASELINE: {
                      return new Sk.builtin.str(context[PROP_TEXT_BASELINE]);
                    }
                  case PROP_WEBKIT_BACKING_STORE_PIXEL_RATIO: {
                      return Sk.builtin.assk$(context[PROP_WEBKIT_BACKING_STORE_PIXEL_RATIO], Sk.builtin.nmber.int$);
                    }
                  case METHOD_ARC: {
                      return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function ($gbl, $loc) {
                        $loc.__init__ = new Sk.builtin.func(function (self) {
                          self.tp$name = METHOD_ARC;
                        });
                        $loc.__call__ = new Sk.builtin.func(function (self, x, y, radius, startAngle, endAngle, anticlockwise) {
                          x = Sk.ffi.remapToJs(x);
                          y = Sk.ffi.remapToJs(y);
                          radius = Sk.ffi.remapToJs(radius);
                          startAngle = Sk.ffi.remapToJs(startAngle);
                          endAngle = Sk.ffi.remapToJs(endAngle);
                          anticlockwise = Sk.ffi.remapToJs(anticlockwise);
                          context[METHOD_ARC](x, y, radius, startAngle, endAngle, anticlockwise);
                        });
                        $loc.__str__ = new Sk.builtin.func(function (self) {
                          return new Sk.builtin.str(METHOD_ARC);
                        });
                        $loc.__repr__ = new Sk.builtin.func(function (self) {
                          return new Sk.builtin.str(METHOD_ARC);
                        });
                      }, METHOD_ARC, []));
                    }
                  case METHOD_ARC_TO: {
                      return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function ($gbl, $loc) {
                        $loc.__init__ = new Sk.builtin.func(function (self) {
                          self.tp$name = METHOD_ARC_TO;
                        });
                        $loc.__call__ = new Sk.builtin.func(function (self, x1, y1, x2, y2, radiusX, radiusY, rotation) {
                          x1 = Sk.ffi.remapToJs(x1);
                          y1 = Sk.ffi.remapToJs(y1);
                          x2 = Sk.ffi.remapToJs(x2);
                          y2 = Sk.ffi.remapToJs(y2);
                          radiusX = Sk.ffi.remapToJs(radiusX);
                          radiusY = Sk.ffi.remapToJs(radiusY);
                          rotation = Sk.ffi.remapToJs(rotation);
                          context[METHOD_ARC_TO](x1, y1, x2, y2, radiusX, radiusY, rotation);
                        });
                        $loc.__str__ = new Sk.builtin.func(function (self) {
                          return new Sk.builtin.str(METHOD_ARC_TO);
                        });
                        $loc.__repr__ = new Sk.builtin.func(function (self) {
                          return new Sk.builtin.str(METHOD_ARC_TO);
                        });
                      }, METHOD_ARC_TO, []));
                    }
                  case METHOD_BEGIN_PATH: {
                      return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function ($gbl, $loc) {
                        $loc.__init__ = new Sk.builtin.func(function (self) {
                          self.tp$name = METHOD_BEGIN_PATH;
                        });
                        $loc.__call__ = new Sk.builtin.func(function (self) {
                          context[METHOD_BEGIN_PATH]();
                        });
                        $loc.__str__ = new Sk.builtin.func(function (self) {
                          return new Sk.builtin.str(METHOD_BEGIN_PATH);
                        });
                        $loc.__repr__ = new Sk.builtin.func(function (self) {
                          return new Sk.builtin.str(METHOD_BEGIN_PATH);
                        });
                      }, METHOD_BEGIN_PATH, []));
                    }
                  case METHOD_BEZIER_CURVE_TO: {
                      return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function ($gbl, $loc) {
                        $loc.__init__ = new Sk.builtin.func(function (self) {
                          self.tp$name = METHOD_BEZIER_CURVE_TO;
                        });
                        $loc.__call__ = new Sk.builtin.func(function (self, cp1x, cp1y, cp2x, cp2y, x, y) {
                          cp1x = Sk.ffi.remapToJs(cp1x);
                          cp1y = Sk.ffi.remapToJs(cp1y);
                          cp2x = Sk.ffi.remapToJs(cp2x);
                          cp2y = Sk.ffi.remapToJs(cp2y);
                          x = Sk.ffi.remapToJs(x);
                          y = Sk.ffi.remapToJs(y);
                          context[METHOD_BEZIER_CURVE_TO](cp1x, cp1y, cp2x, cp2y, x, y);
                        });
                        $loc.__str__ = new Sk.builtin.func(function (self) {
                          return new Sk.builtin.str(METHOD_BEZIER_CURVE_TO);
                        });
                        $loc.__repr__ = new Sk.builtin.func(function (self) {
                          return new Sk.builtin.str(METHOD_BEZIER_CURVE_TO);
                        });
                      }, METHOD_BEZIER_CURVE_TO, []));
                    }
                  case METHOD_CLEAR_RECT: {
                      return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function ($gbl, $loc) {
                        $loc.__init__ = new Sk.builtin.func(function (self) {
                          self.tp$name = METHOD_CLEAR_RECT;
                        });
                        $loc.__call__ = new Sk.builtin.func(function (self, x, y, w, h) {
                          x = Sk.ffi.remapToJs(x);
                          y = Sk.ffi.remapToJs(y);
                          w = Sk.ffi.remapToJs(w);
                          h = Sk.ffi.remapToJs(h);
                          context[METHOD_CLEAR_RECT](x, y, w, h);
                        });
                        $loc.__str__ = new Sk.builtin.func(function (self) {
                          return new Sk.builtin.str(METHOD_CLEAR_RECT);
                        });
                        $loc.__repr__ = new Sk.builtin.func(function (self) {
                          return new Sk.builtin.str(METHOD_CLEAR_RECT);
                        });
                      }, METHOD_CLEAR_RECT, []));
                    }
                  case METHOD_CLIP: {
                      return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function ($gbl, $loc) {
                        $loc.__init__ = new Sk.builtin.func(function (self) {
                          self.tp$name = METHOD_CLIP;
                        });
                        $loc.__call__ = new Sk.builtin.func(function (self) {
                          context[METHOD_CLIP]();
                        });
                        $loc.__str__ = new Sk.builtin.func(function (self) {
                          return new Sk.builtin.str(METHOD_CLIP);
                        });
                        $loc.__repr__ = new Sk.builtin.func(function (self) {
                          return new Sk.builtin.str(METHOD_CLIP);
                        });
                      }, METHOD_CLIP, []));
                    }
                  case METHOD_CLOSE_PATH: {
                      return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function ($gbl, $loc) {
                        $loc.__init__ = new Sk.builtin.func(function (self) {
                          self.tp$name = METHOD_CLOSE_PATH;
                        });
                        $loc.__call__ = new Sk.builtin.func(function (self) {
                          context[METHOD_CLOSE_PATH]();
                        });
                        $loc.__str__ = new Sk.builtin.func(function (self) {
                          return new Sk.builtin.str(METHOD_CLOSE_PATH);
                        });
                        $loc.__repr__ = new Sk.builtin.func(function (self) {
                          return new Sk.builtin.str(METHOD_CLOSE_PATH);
                        });
                      }, METHOD_CLOSE_PATH, []));
                    }
                  case METHOD_CREATE_LINEAR_GRADIENT: {
                      return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function ($gbl, $loc) {
                        $loc.__init__ = new Sk.builtin.func(function (self) {
                          self.tp$name = METHOD_CREATE_LINEAR_GRADIENT;
                        });
                        $loc.__call__ = new Sk.builtin.func(function (self, x0, y0, x1, y1) {
                          x0 = Sk.ffi.remapToJs(x0);
                          y0 = Sk.ffi.remapToJs(y0);
                          x1 = Sk.ffi.remapToJs(x1);
                          y1 = Sk.ffi.remapToJs(y1);
                          var gradient = context[METHOD_CREATE_LINEAR_GRADIENT](x0, y0, x1, y1);
                          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function ($gbl, $loc) {
                            $loc.__init__ = new Sk.builtin.func(function (self) {
                              self.tp$name = CANVAS_GRADIENT_CLASS;
                              self.v = gradient;
                            });
                            $loc.__getattr__ = new Sk.builtin.func(function (gradientPy, name) {
                              switch (name) {
                              case METHOD_ADD_COLOR_STOP: {
                                  return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function ($gbl, $loc) {
                                    $loc.__init__ = new Sk.builtin.func(function (self) {
                                      self.tp$name = METHOD_ADD_COLOR_STOP;
                                    });
                                    $loc.__call__ = new Sk.builtin.func(function (self, offset, color) {
                                      offset = Sk.ffi.remapToJs(offset);
                                      color = Sk.ffi.remapToJs(color);
                                      gradient[METHOD_ADD_COLOR_STOP](offset, color);
                                    });
                                    $loc.__str__ = new Sk.builtin.func(function (self) {
                                      return new Sk.builtin.str(METHOD_ADD_COLOR_STOP);
                                    });
                                    $loc.__repr__ = new Sk.builtin.func(function (self) {
                                      return new Sk.builtin.str(METHOD_ADD_COLOR_STOP);
                                    });
                                  }, METHOD_ADD_COLOR_STOP, []));
                                }
                              }
                            });
                            $loc.__setattr__ = new Sk.builtin.func(function (gradientPy, name, valuePy) {
                              var value = Sk.ffi.remapToJs(valuePy);
                              switch (name) {
                              default: {
                                  throw new Sk.builtin.AssertionError(name + ' is not a writeable attribute of ' + CANVAS_GRADIENT_CLASS);
                                }
                              }
                            });
                            $loc.__str__ = new Sk.builtin.func(function (self) {
                              return new Sk.builtin.str(CANVAS_GRADIENT_CLASS);
                            });
                            $loc.__repr__ = new Sk.builtin.func(function (self) {
                              return new Sk.builtin.str(CANVAS_GRADIENT_CLASS);
                            });
                          }, CANVAS_GRADIENT_CLASS, []));
                        });
                        $loc.__str__ = new Sk.builtin.func(function (self) {
                          return new Sk.builtin.str(METHOD_CREATE_LINEAR_GRADIENT);
                        });
                        $loc.__repr__ = new Sk.builtin.func(function (self) {
                          return new Sk.builtin.str(METHOD_CREATE_LINEAR_GRADIENT);
                        });
                      }, METHOD_CREATE_LINEAR_GRADIENT, []));
                    }
                  case METHOD_FILL: {
                      return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function ($gbl, $loc) {
                        $loc.__init__ = new Sk.builtin.func(function (self) {
                          self.tp$name = METHOD_FILL;
                        });
                        $loc.__call__ = new Sk.builtin.func(function (self) {
                          context[METHOD_FILL]();
                        });
                        $loc.__str__ = new Sk.builtin.func(function (self) {
                          return new Sk.builtin.str(METHOD_FILL);
                        });
                        $loc.__repr__ = new Sk.builtin.func(function (self) {
                          return new Sk.builtin.str(METHOD_FILL);
                        });
                      }, METHOD_FILL, []));
                    }
                  case METHOD_FILL_RECT: {
                      return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function ($gbl, $loc) {
                        $loc.__init__ = new Sk.builtin.func(function (self) {
                          self.tp$name = METHOD_FILL_RECT;
                        });
                        $loc.__call__ = new Sk.builtin.func(function (self, x, y, w, h) {
                          x = Sk.ffi.remapToJs(x);
                          y = Sk.ffi.remapToJs(y);
                          w = Sk.ffi.remapToJs(w);
                          h = Sk.ffi.remapToJs(h);
                          context[METHOD_FILL_RECT](x, y, w, h);
                        });
                        $loc.__str__ = new Sk.builtin.func(function (self) {
                          return new Sk.builtin.str(METHOD_FILL_RECT);
                        });
                        $loc.__repr__ = new Sk.builtin.func(function (self) {
                          return new Sk.builtin.str(METHOD_FILL_RECT);
                        });
                      }, METHOD_FILL_RECT, []));
                    }
                  case METHOD_FILL_TEXT: {
                      return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function ($gbl, $loc) {
                        $loc.__init__ = new Sk.builtin.func(function (self) {
                          self.tp$name = METHOD_FILL_TEXT;
                        });
                        $loc.__call__ = new Sk.builtin.func(function (self, text, x, y, maxWidthPy) {
                          text = Sk.ffi.remapToJs(text);
                          x = Sk.ffi.remapToJs(x);
                          y = Sk.ffi.remapToJs(y);
                          var maxWidth = Sk.ffi.remapToJs(maxWidthPy);
                          if (typeof maxWidth === 'undefined') {
                            context[METHOD_FILL_TEXT](text, x, y);
                          } else if (typeof maxWidth === 'number') {
                            context[METHOD_FILL_TEXT](text, x, y, maxWidth);
                          } else {
                            throw new Sk.builtin.TypeError('maxWidth');
                          }
                        });
                        $loc.__str__ = new Sk.builtin.func(function (self) {
                          return new Sk.builtin.str(METHOD_FILL_TEXT);
                        });
                        $loc.__repr__ = new Sk.builtin.func(function (self) {
                          return new Sk.builtin.str(METHOD_FILL_TEXT);
                        });
                      }, METHOD_FILL_TEXT, []));
                    }
                  case METHOD_LINE_TO: {
                      return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function ($gbl, $loc) {
                        $loc.__init__ = new Sk.builtin.func(function (self) {
                          self.tp$name = METHOD_LINE_TO;
                        });
                        $loc.__call__ = new Sk.builtin.func(function (self, x, y) {
                          x = Sk.ffi.remapToJs(x);
                          y = Sk.ffi.remapToJs(y);
                          context[METHOD_LINE_TO](x, y);
                        });
                        $loc.__str__ = new Sk.builtin.func(function (self) {
                          return new Sk.builtin.str(METHOD_LINE_TO);
                        });
                        $loc.__repr__ = new Sk.builtin.func(function (self) {
                          return new Sk.builtin.str(METHOD_LINE_TO);
                        });
                      }, METHOD_LINE_TO, []));
                    }
                  case METHOD_MOVE_TO: {
                      return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function ($gbl, $loc) {
                        $loc.__init__ = new Sk.builtin.func(function (self) {
                          self.tp$name = METHOD_MOVE_TO;
                        });
                        $loc.__call__ = new Sk.builtin.func(function (self, x, y) {
                          x = Sk.ffi.remapToJs(x);
                          y = Sk.ffi.remapToJs(y);
                          context[METHOD_MOVE_TO](x, y);
                        });
                        $loc.__str__ = new Sk.builtin.func(function (self) {
                          return new Sk.builtin.str(METHOD_MOVE_TO);
                        });
                        $loc.__repr__ = new Sk.builtin.func(function (self) {
                          return new Sk.builtin.str(METHOD_MOVE_TO);
                        });
                      }, METHOD_MOVE_TO, []));
                    }
                  case METHOD_QUADRATIC_CURVE_TO: {
                      return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function ($gbl, $loc) {
                        $loc.__init__ = new Sk.builtin.func(function (self) {
                          self.tp$name = METHOD_QUADRATIC_CURVE_TO;
                        });
                        $loc.__call__ = new Sk.builtin.func(function (self, cpx, cpy, x, y) {
                          cpx = Sk.ffi.remapToJs(cpx);
                          cpy = Sk.ffi.remapToJs(cpy);
                          x = Sk.ffi.remapToJs(x);
                          y = Sk.ffi.remapToJs(y);
                          context[METHOD_QUADRATIC_CURVE_TO](cpx, cpy, x, y);
                        });
                        $loc.__str__ = new Sk.builtin.func(function (self) {
                          return new Sk.builtin.str(METHOD_QUADRATIC_CURVE_TO);
                        });
                        $loc.__repr__ = new Sk.builtin.func(function (self) {
                          return new Sk.builtin.str(METHOD_QUADRATIC_CURVE_TO);
                        });
                      }, METHOD_QUADRATIC_CURVE_TO, []));
                    }
                  case METHOD_RECT: {
                      return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function ($gbl, $loc) {
                        $loc.__init__ = new Sk.builtin.func(function (self) {
                          self.tp$name = METHOD_RECT;
                        });
                        $loc.__call__ = new Sk.builtin.func(function (self, x, y, w, h) {
                          x = Sk.ffi.remapToJs(x);
                          y = Sk.ffi.remapToJs(y);
                          w = Sk.ffi.remapToJs(w);
                          h = Sk.ffi.remapToJs(h);
                          context[METHOD_RECT](x, y, w, h);
                        });
                        $loc.__str__ = new Sk.builtin.func(function (self) {
                          return new Sk.builtin.str(METHOD_RECT);
                        });
                        $loc.__repr__ = new Sk.builtin.func(function (self) {
                          return new Sk.builtin.str(METHOD_RECT);
                        });
                      }, METHOD_RECT, []));
                    }
                  case METHOD_RESTORE: {
                      return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function ($gbl, $loc) {
                        $loc.__init__ = new Sk.builtin.func(function (self) {
                          self.tp$name = METHOD_RESTORE;
                        });
                        $loc.__call__ = new Sk.builtin.func(function (self) {
                          context[METHOD_RESTORE]();
                        });
                        $loc.__str__ = new Sk.builtin.func(function (self) {
                          return new Sk.builtin.str(METHOD_RESTORE);
                        });
                        $loc.__repr__ = new Sk.builtin.func(function (self) {
                          return new Sk.builtin.str(METHOD_RESTORE);
                        });
                      }, METHOD_RESTORE, []));
                    }
                  case METHOD_ROTATE: {
                      return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function ($gbl, $loc) {
                        $loc.__init__ = new Sk.builtin.func(function (self) {
                          self.tp$name = METHOD_ROTATE;
                        });
                        $loc.__call__ = new Sk.builtin.func(function (self, angle) {
                          angle = Sk.ffi.remapToJs(angle);
                          context[METHOD_ROTATE](angle);
                        });
                        $loc.__str__ = new Sk.builtin.func(function (self) {
                          return new Sk.builtin.str(METHOD_ROTATE);
                        });
                        $loc.__repr__ = new Sk.builtin.func(function (self) {
                          return new Sk.builtin.str(METHOD_ROTATE);
                        });
                      }, METHOD_ROTATE, []));
                    }
                  case METHOD_SAVE: {
                      return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function ($gbl, $loc) {
                        $loc.__init__ = new Sk.builtin.func(function (self) {
                          self.tp$name = METHOD_SAVE;
                        });
                        $loc.__call__ = new Sk.builtin.func(function (self) {
                          context[METHOD_SAVE]();
                        });
                        $loc.__str__ = new Sk.builtin.func(function (self) {
                          return new Sk.builtin.str(METHOD_SAVE);
                        });
                        $loc.__repr__ = new Sk.builtin.func(function (self) {
                          return new Sk.builtin.str(METHOD_SAVE);
                        });
                      }, METHOD_SAVE, []));
                    }
                  case METHOD_SCALE: {
                      return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function ($gbl, $loc) {
                        $loc.__init__ = new Sk.builtin.func(function (self) {
                          self.tp$name = METHOD_SCALE;
                        });
                        $loc.__call__ = new Sk.builtin.func(function (self, x, y) {
                          x = Sk.ffi.remapToJs(x);
                          y = Sk.ffi.remapToJs(y);
                          context[METHOD_SCALE](x, y);
                        });
                        $loc.__str__ = new Sk.builtin.func(function (self) {
                          return new Sk.builtin.str(METHOD_SCALE);
                        });
                        $loc.__repr__ = new Sk.builtin.func(function (self) {
                          return new Sk.builtin.str(METHOD_SCALE);
                        });
                      }, METHOD_SCALE, []));
                    }
                  case METHOD_SET_TRANSFORM: {
                      return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function ($gbl, $loc) {
                        $loc.__init__ = new Sk.builtin.func(function (self) {
                          self.tp$name = METHOD_SET_TRANSFORM;
                        });
                        $loc.__call__ = new Sk.builtin.func(function (self, a, b, c, d, e, f) {
                          a = Sk.ffi.remapToJs(a);
                          b = Sk.ffi.remapToJs(b);
                          c = Sk.ffi.remapToJs(c);
                          d = Sk.ffi.remapToJs(d);
                          e = Sk.ffi.remapToJs(e);
                          f = Sk.ffi.remapToJs(f);
                          context[METHOD_SET_TRANSFORM](a, b, c, d, e, f);
                        });
                        $loc.__str__ = new Sk.builtin.func(function (self) {
                          return new Sk.builtin.str(METHOD_SET_TRANSFORM);
                        });
                        $loc.__repr__ = new Sk.builtin.func(function (self) {
                          return new Sk.builtin.str(METHOD_SET_TRANSFORM);
                        });
                      }, METHOD_SET_TRANSFORM, []));
                    }
                  case METHOD_STROKE: {
                      return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function ($gbl, $loc) {
                        $loc.__init__ = new Sk.builtin.func(function (self) {
                          self.tp$name = METHOD_STROKE;
                        });
                        $loc.__call__ = new Sk.builtin.func(function (self) {
                          context[METHOD_STROKE]();
                        });
                        $loc.__str__ = new Sk.builtin.func(function (self) {
                          return new Sk.builtin.str(METHOD_STROKE);
                        });
                        $loc.__repr__ = new Sk.builtin.func(function (self) {
                          return new Sk.builtin.str(METHOD_STROKE);
                        });
                      }, METHOD_STROKE, []));
                    }
                  case METHOD_STROKE_RECT: {
                      return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function ($gbl, $loc) {
                        $loc.__init__ = new Sk.builtin.func(function (self) {
                          self.tp$name = METHOD_STROKE_RECT;
                        });
                        $loc.__call__ = new Sk.builtin.func(function (self, x, y, w, h) {
                          x = Sk.ffi.remapToJs(x);
                          y = Sk.ffi.remapToJs(y);
                          w = Sk.ffi.remapToJs(w);
                          h = Sk.ffi.remapToJs(h);
                          context[METHOD_STROKE_RECT](x, y, w, h);
                        });
                        $loc.__str__ = new Sk.builtin.func(function (self) {
                          return new Sk.builtin.str(METHOD_STROKE_RECT);
                        });
                        $loc.__repr__ = new Sk.builtin.func(function (self) {
                          return new Sk.builtin.str(METHOD_STROKE_RECT);
                        });
                      }, METHOD_STROKE_RECT, []));
                    }
                  case METHOD_STROKE_TEXT: {
                      return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function ($gbl, $loc) {
                        $loc.__init__ = new Sk.builtin.func(function (self) {
                          self.tp$name = METHOD_STROKE_TEXT;
                        });
                        $loc.__call__ = new Sk.builtin.func(function (self, text, x, y, maxWidthPy) {
                          text = Sk.ffi.remapToJs(text);
                          x = Sk.ffi.remapToJs(x);
                          y = Sk.ffi.remapToJs(y);
                          var maxWidth = Sk.ffi.remapToJs(maxWidthPy);
                          if (typeof maxWidth === 'undefined') {
                            context[METHOD_STROKE_TEXT](text, x, y);
                          } else if (typeof maxWidth === 'number') {
                            context[METHOD_STROKE_TEXT](text, x, y, maxWidth);
                          } else {
                            throw new Sk.builtin.TypeError('maxWidth');
                          }
                        });
                        $loc.__str__ = new Sk.builtin.func(function (self) {
                          return new Sk.builtin.str(METHOD_STROKE_TEXT);
                        });
                        $loc.__repr__ = new Sk.builtin.func(function (self) {
                          return new Sk.builtin.str(METHOD_STROKE_TEXT);
                        });
                      }, METHOD_STROKE_TEXT, []));
                    }
                  case METHOD_TRANSFORM: {
                      return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function ($gbl, $loc) {
                        $loc.__init__ = new Sk.builtin.func(function (self) {
                          self.tp$name = METHOD_TRANSFORM;
                        });
                        $loc.__call__ = new Sk.builtin.func(function (self, a, b, c, d, e, f) {
                          a = Sk.ffi.remapToJs(a);
                          b = Sk.ffi.remapToJs(b);
                          c = Sk.ffi.remapToJs(c);
                          d = Sk.ffi.remapToJs(d);
                          e = Sk.ffi.remapToJs(e);
                          f = Sk.ffi.remapToJs(f);
                          context[METHOD_TRANSFORM](a, b, c, d, e, f);
                        });
                        $loc.__str__ = new Sk.builtin.func(function (self) {
                          return new Sk.builtin.str(METHOD_TRANSFORM);
                        });
                        $loc.__repr__ = new Sk.builtin.func(function (self) {
                          return new Sk.builtin.str(METHOD_TRANSFORM);
                        });
                      }, METHOD_TRANSFORM, []));
                    }
                  case METHOD_TRANSLATE: {
                      return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function ($gbl, $loc) {
                        $loc.__init__ = new Sk.builtin.func(function (self) {
                          self.tp$name = METHOD_TRANSLATE;
                        });
                        $loc.__call__ = new Sk.builtin.func(function (self, x, y) {
                          x = Sk.ffi.remapToJs(x);
                          y = Sk.ffi.remapToJs(y);
                          context[METHOD_TRANSLATE](x, y);
                        });
                        $loc.__str__ = new Sk.builtin.func(function (self) {
                          return new Sk.builtin.str(METHOD_TRANSLATE);
                        });
                        $loc.__repr__ = new Sk.builtin.func(function (self) {
                          return new Sk.builtin.str(METHOD_TRANSLATE);
                        });
                      }, METHOD_TRANSLATE, []));
                    }
                  }
                });
                $loc.__setattr__ = new Sk.builtin.func(function (contextPy, name, valuePy) {
                  var context = Sk.ffi.remapToJs(contextPy);
                  var value = Sk.ffi.remapToJs(valuePy);
                  switch (name) {
                  case PROP_FILL_STYLE: {
                      context[PROP_FILL_STYLE] = value;
                    }
                    break;
                  case PROP_FONT: {
                      context[PROP_FONT] = value;
                    }
                    break;
                  case PROP_LINE_CAP: {
                      context[PROP_LINE_CAP] = value;
                    }
                    break;
                  case PROP_LINE_JOIN: {
                      context[PROP_LINE_JOIN] = value;
                    }
                    break;
                  case PROP_LINE_WIDTH: {
                      context[PROP_LINE_WIDTH] = value;
                    }
                    break;
                  case PROP_SHADOW_BLUR: {
                      context[PROP_SHADOW_BLUR] = value;
                    }
                    break;
                  case PROP_SHADOW_COLOR: {
                      context[PROP_SHADOW_COLOR] = value;
                    }
                    break;
                  case PROP_SHADOW_OFFSET_X: {
                      context[PROP_SHADOW_OFFSET_X] = value;
                    }
                    break;
                  case PROP_SHADOW_OFFSET_Y: {
                      context[PROP_SHADOW_OFFSET_Y] = value;
                    }
                    break;
                  case PROP_STROKE_STYLE: {
                      context[PROP_STROKE_STYLE] = value;
                    }
                    break;
                  case PROP_TEXT_ALIGN: {
                      context[PROP_TEXT_ALIGN] = value;
                    }
                    break;
                  case PROP_TEXT_BASELINE: {
                      context[PROP_TEXT_BASELINE] = value;
                    }
                    break;
                  default: {
                      throw new Sk.builtin.AssertionError(name + ' is not a writeable attribute of ' + CANVAS_RENDERING_CONTEXT_2D);
                    }
                  }
                });
                $loc.__str__ = new Sk.builtin.func(function (self) {
                  return new Sk.builtin.str(CANVAS_RENDERING_CONTEXT_2D);
                });
                $loc.__repr__ = new Sk.builtin.func(function (self) {
                  return new Sk.builtin.str(CANVAS_RENDERING_CONTEXT_2D);
                });
              }, CANVAS_RENDERING_CONTEXT_2D, []));
            });
            $loc.__str__ = new Sk.builtin.func(function (self) {
              return new Sk.builtin.str(METHOD_GET_CONTEXT);
            });
            $loc.__repr__ = new Sk.builtin.func(function (self) {
              return new Sk.builtin.str(METHOD_GET_CONTEXT);
            });
          }, METHOD_GET_CONTEXT, []));
        }
      case METHOD_INSERT_BEFORE: {
          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function ($gbl, $loc) {
            $loc.__init__ = new Sk.builtin.func(function (self) {
              self.tp$name = METHOD_INSERT_BEFORE;
            });
            $loc.__call__ = new Sk.builtin.func(function (self, newNode, refNode) {
              return wrapNode(node.insertBefore(nodeFromArg(newNode), nodeFromArg(refNode)));
            });
            $loc.__str__ = new Sk.builtin.func(function (self) {
              return new Sk.builtin.str(METHOD_INSERT_BEFORE);
            });
            $loc.__repr__ = new Sk.builtin.func(function (self) {
              return new Sk.builtin.str(METHOD_INSERT_BEFORE);
            });
          }, METHOD_INSERT_BEFORE, []));
        }
      case METHOD_REMOVE_CHILD: {
          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function ($gbl, $loc) {
            $loc.__init__ = new Sk.builtin.func(function (self) {
              self.tp$name = METHOD_REMOVE_CHILD;
            });
            $loc.__call__ = new Sk.builtin.func(function (self, childNode) {
              return wrapNode(node.removeChild(nodeFromArg(childNode)));
            });
            $loc.__str__ = new Sk.builtin.func(function (self) {
              return new Sk.builtin.str(METHOD_REMOVE_CHILD);
            });
            $loc.__repr__ = new Sk.builtin.func(function (self) {
              return new Sk.builtin.str(METHOD_REMOVE_CHILD);
            });
          }, METHOD_REMOVE_CHILD, []));
        }
      case METHOD_SET_ATTRIBUTE: {
          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function ($gbl, $loc) {
            $loc.__init__ = new Sk.builtin.func(function (self) {
              self.tp$name = METHOD_SET_ATTRIBUTE;
            });
            $loc.__call__ = new Sk.builtin.func(function (self, name, value) {
              node.setAttribute(stringFromArg(name), stringFromArg(value));
            });
            $loc.__str__ = new Sk.builtin.func(function (self) {
              return new Sk.builtin.str(METHOD_SET_ATTRIBUTE);
            });
            $loc.__repr__ = new Sk.builtin.func(function (self) {
              return new Sk.builtin.str(METHOD_SET_ATTRIBUTE);
            });
          }, METHOD_SET_ATTRIBUTE, []));
        }
      }
    });
    $loc.__setattr__ = new Sk.builtin.func(function (nodePy, name, valuePy) {
      var node = Sk.ffi.remapToJs(nodePy);
      var value = Sk.ffi.remapToJs(valuePy);
      switch (name) {
      case PROP_DIR: {
          node[PROP_DIR] = value;
        }
        break;
      case 'id': {
          node.setAttribute(name, value);
        }
        break;
      case PROP_HEIGHT: {
          node[PROP_HEIGHT] = value;
        }
        break;
      case PROP_WIDTH: {
          node[PROP_WIDTH] = value;
        }
        break;
      default: {
          node.setAttribute(name, stringFromArg(value));
        }
      }
    });
    $loc.getCSS = new Sk.builtin.func(function (self, key) {
      return new Sk.builtin.str(self.v.style[key.v]);
    });
    $loc.setCSS = new Sk.builtin.func(function (self, attr, value) {
      self.v.style[attr.v] = value.v;
    });
    $loc.getAttribute = new Sk.builtin.func(function (self, key) {
      var res = self.v.getAttribute(key.v);
      if (res) {
        return new Sk.builtin.str(res);
      } else {
        return null;
      }
    });
    $loc.setAttribute = new Sk.builtin.func(function (self, attr, value) {
      self.v.setAttribute(attr.v, value.v);
    });
    $loc.__str__ = new Sk.builtin.func(function (self) {
      return new Sk.builtin.str(self.v.tagName);
    });
    $loc.__repr__ = new Sk.builtin.func(function (self) {
      return new Sk.builtin.str(NODE);
    });
  }, NODE, []);
};
Sk.builtin.buildWindowClass = function (mod) {
  var EVENT = 'Event';
  var WINDOW_CLASS = 'Window';
  var PROP_ANIMATION_TIME = 'animationTime';
  var PROP_DOCUMENT = 'document';
  var PROP_DEVICE_PIXEL_RATIO = 'devicePixelRatio';
  var METHOD_ADD_EVENT_LISTENER = 'addEventListener';
  var METHOD_CANCEL_ANIMATION_FRAME = 'cancelAnimationFrame';
  var METHOD_REMOVE_EVENT_LISTENER = 'removeEventListener';
  var METHOD_REQUEST_ANIMATION_FRAME = 'requestAnimationFrame';
  var METHOD_SET_TIMEOUT = 'setTimeout';
  var wrapNumber = function (n) {
    if (typeof n === 'number') {
      return Sk.builtin.assk$(n, Sk.builtin.nmber.float$);
    } else {
      return Sk.builtin.none.none$;
    }
  };
  var numberFromArg = function (arg) {
    if (arg) {
      return arg.v;
    } else {
      return null;
    }
  };
  var winListeners = {};
  return Sk.misceval.buildClass(mod, function ($gbl, $loc) {
    $loc.__init__ = new Sk.builtin.func(function (windowPy) {
      windowPy.tp$name = WINDOW_CLASS;
      windowPy.v = window;
    });
    $loc.__getattr__ = new Sk.builtin.func(function (self, name) {
      switch (name) {
      case PROP_ANIMATION_TIME: {
          return wrapNumber(window[PROP_ANIMATION_TIME]);
        }
      case PROP_DOCUMENT: {
          return mod[PROP_DOCUMENT];
        }
      case 'innerHeight': {
          return wrapNumber(window[name]);
        }
      case 'innerWidth': {
          return wrapNumber(window[name]);
        }
      case PROP_DEVICE_PIXEL_RATIO: {
          return Sk.builtin.assk$(window[PROP_DEVICE_PIXEL_RATIO], Sk.builtin.nmber.int$);
        }
      case METHOD_ADD_EVENT_LISTENER: {
          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function ($gbl, $loc) {
            $loc.__init__ = new Sk.builtin.func(function (self) {
              self.tp$name = METHOD_ADD_EVENT_LISTENER;
            });
            $loc.__call__ = new Sk.builtin.func(function (self, typePy, listenerPy, useCapture) {
              var type = Sk.ffi.remapToJs(typePy);
              var listener = function (event) {
                var eventPy = Sk.misceval.callsim(mod[EVENT], Sk.ffi.referenceToPy(event, EVENT));
                Sk.misceval.callsim(listenerPy, eventPy);
              };
              winListeners[type] = listener;
              window[METHOD_ADD_EVENT_LISTENER](type, listener, useCapture);
            });
            $loc.__str__ = new Sk.builtin.func(function (self) {
              return new Sk.builtin.str(METHOD_ADD_EVENT_LISTENER);
            });
            $loc.__repr__ = new Sk.builtin.func(function (self) {
              return new Sk.builtin.str(METHOD_ADD_EVENT_LISTENER);
            });
          }, METHOD_ADD_EVENT_LISTENER, []));
        }
      case METHOD_REMOVE_EVENT_LISTENER: {
          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function ($gbl, $loc) {
            $loc.__init__ = new Sk.builtin.func(function (self) {
              self.tp$name = METHOD_REMOVE_EVENT_LISTENER;
            });
            $loc.__call__ = new Sk.builtin.func(function (self, typePy, listener, useCapture) {
              var type = Sk.ffi.remapToJs(typePy);
              var listener = winListeners[type];
              delete winListeners[type];
              window[METHOD_REMOVE_EVENT_LISTENER](type, listener, useCapture);
            });
            $loc.__str__ = new Sk.builtin.func(function (self) {
              return new Sk.builtin.str(METHOD_REMOVE_EVENT_LISTENER);
            });
            $loc.__repr__ = new Sk.builtin.func(function (self) {
              return new Sk.builtin.str(METHOD_REMOVE_EVENT_LISTENER);
            });
          }, METHOD_REMOVE_EVENT_LISTENER, []));
        }
      case METHOD_CANCEL_ANIMATION_FRAME: {
          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function ($gbl, $loc) {
            $loc.__init__ = new Sk.builtin.func(function (self) {
              self.tp$name = METHOD_CANCEL_ANIMATION_FRAME;
            });
            $loc.__call__ = new Sk.builtin.func(function (self, requestID) {
              if (requestID) {
                window[METHOD_CANCEL_ANIMATION_FRAME](numberFromArg(requestID));
              }
            });
            $loc.__str__ = new Sk.builtin.func(function (self) {
              return new Sk.builtin.str(METHOD_CANCEL_ANIMATION_FRAME);
            });
            $loc.__repr__ = new Sk.builtin.func(function (self) {
              return new Sk.builtin.str(METHOD_CANCEL_ANIMATION_FRAME);
            });
          }, METHOD_CANCEL_ANIMATION_FRAME, []));
        }
      case METHOD_REQUEST_ANIMATION_FRAME: {
          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function ($gbl, $loc) {
            $loc.__init__ = new Sk.builtin.func(function (self) {
              self.tp$name = METHOD_REQUEST_ANIMATION_FRAME;
            });
            $loc.__call__ = new Sk.builtin.func(function (self, callback) {
              var requestID = window[METHOD_REQUEST_ANIMATION_FRAME](function (timestamp) {
                  Sk.misceval.callsim(callback, wrapNumber(timestamp));
                });
              return wrapNumber(requestID);
            });
            $loc.__str__ = new Sk.builtin.func(function (self) {
              return new Sk.builtin.str(METHOD_REQUEST_ANIMATION_FRAME);
            });
            $loc.__repr__ = new Sk.builtin.func(function (self) {
              return new Sk.builtin.str(METHOD_REQUEST_ANIMATION_FRAME);
            });
          }, METHOD_REQUEST_ANIMATION_FRAME, []));
        }
      case METHOD_SET_TIMEOUT: {
          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function ($gbl, $loc) {
            $loc.__init__ = new Sk.builtin.func(function (self) {
              self.tp$name = METHOD_SET_TIMEOUT;
            });
            $loc.__call__ = new Sk.builtin.func(function (self, funcPy, delayPy, paramsPy) {
              var delay = Sk.ffi.remapToJs(delayPy);
              var params = Sk.ffi.remapToJs(paramsPy);
              var timeoutID = window[METHOD_SET_TIMEOUT](function () {
                  Sk.misceval.callsim(funcPy);
                }, delay, params);
              return wrapNumber(timeoutID);
            });
            $loc.__str__ = new Sk.builtin.func(function (self) {
              return new Sk.builtin.str(METHOD_SET_TIMEOUT);
            });
            $loc.__repr__ = new Sk.builtin.func(function (self) {
              return new Sk.builtin.str(METHOD_SET_TIMEOUT);
            });
          }, METHOD_SET_TIMEOUT, []));
        }
      }
    });
    $loc.__str__ = new Sk.builtin.func(function (self) {
      return new Sk.builtin.str(WINDOW_CLASS);
    });
    $loc.__repr__ = new Sk.builtin.func(function (self, arg) {
      return new Sk.builtin.str(WINDOW_CLASS);
    });
  }, WINDOW_CLASS, []);
};
Sk.builtin.defineEuclidean2 = function (mod) {
  var EUCLIDEAN_2 = 'Euclidean2';
  var SCALAR_2 = 'Scalar2';
  var VECTOR_2 = 'Vector2';
  var PSEUDOSCALAR_2 = 'Pseudoscalar2';
  var PROP_W = 'w';
  var PROP_X = 'x';
  var PROP_Y = 'y';
  var PROP_XY = 'xy';
  var METHOD_CLONE = 'clone';
  var METHOD_LENGTH = 'length';
  function isNumber(x) {
    return typeof x === 'number';
  }
  function remapE2ToPy(x00, x01, x10, x11) {
    return Sk.misceval.callsim(mod[EUCLIDEAN_2], Sk.builtin.assk$(x00, Sk.builtin.nmber.float$), Sk.builtin.assk$(x01, Sk.builtin.nmber.float$), Sk.builtin.assk$(x10, Sk.builtin.nmber.float$), Sk.builtin.assk$(x11, Sk.builtin.nmber.float$));
  }
  function stringFromCoordinates(coordinates, labels, multiplier) {
    var append, i, sb, str, _i, _ref;
    sb = [];
    append = function (number, label) {
      var n;
      if (number !== 0) {
        if (number >= 0) {
          if (sb.length > 0) {
            sb.push('+');
          }
        } else {
          sb.push('-');
        }
        n = Math.abs(number);
        if (n === 1) {
          return sb.push(label);
        } else {
          sb.push(n.toString());
          if (label !== '1') {
            sb.push(multiplier);
            return sb.push(label);
          }
        }
      }
    };
    for (i = _i = 0, _ref = coordinates.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      append(coordinates[i], labels[i]);
    }
    if (sb.length > 0) {
      str = sb.join('');
    } else {
      str = '0';
    }
    return str;
  }
  function divide(a00, a01, a10, a11, b00, b01, b10, b11, x) {
    var r00 = +b00;
    var r01 = +b01;
    var r10 = +b10;
    var r11 = -b11;
    var m00 = b00 * r00 + b01 * r01 + b10 * r10 - b11 * r11;
    var m01 = 0;
    var m10 = 0;
    var m11 = 0;
    var c00 = +m00;
    var c01 = -m01;
    var c10 = -m10;
    var c11 = -m11;
    var s00 = r00 * c00 + r01 * c01 + r10 * c10 - r11 * c11;
    var s01 = r00 * c01 + r01 * c00 - r10 * c11 + r11 * c10;
    var s10 = r00 * c10 + r01 * c11 + r10 * c00 - r11 * c01;
    var s11 = r00 * c11 + r01 * c10 - r10 * c01 + r11 * c00;
    var k00 = b00 * s00 + b01 * s01 + b10 * s10 - b11 * s11;
    var i00 = s00 / k00;
    var i01 = s01 / k00;
    var i10 = s10 / k00;
    var i11 = s11 / k00;
    var x00 = a00 * i00 + a01 * i01 + a10 * i10 - a11 * i11;
    var x01 = a00 * i01 + a01 * i00 - a10 * i11 + a11 * i10;
    var x10 = a00 * i10 + a01 * i11 + a10 * i00 - a11 * i01;
    var x11 = a00 * i11 + a01 * i10 - a10 * i01 + a11 * i00;
    if (typeof x !== 'undefined') {
      x[0] = x00;
      x[1] = x01;
      x[2] = x10;
      x[3] = x11;
    } else {
      return remapE2ToPy(x00, x01, x10, x11);
    }
  }
  mod[SCALAR_2] = new Sk.builtin.func(function (w) {
    Sk.builtin.pyCheckArgs(SCALAR_2, arguments, 1, 1);
    Sk.builtin.pyCheckType('w', 'Number', Sk.builtin.checkNumber(w));
    w = Sk.ffi.remapToJs(w);
    return remapE2ToPy(w, 0, 0, 0);
  });
  mod[VECTOR_2] = new Sk.builtin.func(function (x, y) {
    Sk.builtin.pyCheckArgs(VECTOR_2, arguments, 2, 2);
    Sk.builtin.pyCheckType('x', 'Number', Sk.builtin.checkNumber(x));
    Sk.builtin.pyCheckType('y', 'Number', Sk.builtin.checkNumber(y));
    x = Sk.ffi.remapToJs(x);
    y = Sk.ffi.remapToJs(y);
    return remapE2ToPy(0, x, y, 0);
  });
  mod[PSEUDOSCALAR_2] = new Sk.builtin.func(function (xy) {
    Sk.builtin.pyCheckArgs(PSEUDOSCALAR_2, arguments, 1, 1);
    Sk.builtin.pyCheckType('xy', 'Number', Sk.builtin.checkNumber(xy));
    xy = Sk.ffi.remapToJs(xy);
    return remapE2ToPy(0, 0, 0, xy);
  });
  mod[EUCLIDEAN_2] = Sk.misceval.buildClass(mod, function ($gbl, $loc) {
    $loc.__init__ = new Sk.builtin.func(function (self, x00, x01, x10, x11) {
      x00 = Sk.ffi.remapToJs(x00);
      x01 = Sk.ffi.remapToJs(x01);
      x10 = Sk.ffi.remapToJs(x10);
      x11 = Sk.ffi.remapToJs(x11);
      self.tp$name = EUCLIDEAN_2;
      self.v = [
        x00,
        x01,
        x10,
        x11
      ];
    });
    $loc.__add__ = new Sk.builtin.func(function (lhs, rhs) {
      lhs = Sk.ffi.remapToJs(lhs);
      rhs = Sk.ffi.remapToJs(rhs);
      if (isNumber(rhs)) {
        return remapE2ToPy(lhs[0] + rhs, lhs[1], lhs[2], lhs[3]);
      } else {
        return remapE2ToPy(lhs[0] + rhs[0], lhs[1] + rhs[1], lhs[2] + rhs[2], lhs[3] + rhs[3]);
      }
    });
    $loc.__radd__ = new Sk.builtin.func(function (rhs, lhs) {
      lhs = Sk.ffi.remapToJs(lhs);
      rhs = Sk.ffi.remapToJs(rhs);
      if (isNumber(lhs)) {
        return remapE2ToPy(lhs + rhs[0], rhs[1], rhs[2], rhs[3]);
      } else {
        throw new Sk.builtin.AssertionError('' + JSON.stringify(lhs, null, 2) + ' + ' + JSON.stringify(rhs, null, 2));
      }
    });
    $loc.__iadd__ = new Sk.builtin.func(function (selfPy, otherPy) {
      var self = Sk.ffi.remapToJs(selfPy);
      var other = Sk.ffi.remapToJs(otherPy);
      if (isNumber(other)) {
        self[0] += other;
        return selfPy;
      } else {
        self[0] += other[0];
        self[1] += other[1];
        self[2] += other[2];
        self[3] += other[3];
        return selfPy;
      }
    });
    $loc.__sub__ = new Sk.builtin.func(function (lhs, rhs) {
      lhs = Sk.ffi.remapToJs(lhs);
      rhs = Sk.ffi.remapToJs(rhs);
      if (isNumber(rhs)) {
        return remapE2ToPy(lhs[0] - rhs, lhs[1], lhs[2], lhs[3]);
      } else {
        return remapE2ToPy(lhs[0] - rhs[0], lhs[1] - rhs[1], lhs[2] - rhs[2], lhs[3] - rhs[3]);
      }
    });
    $loc.__rsub__ = new Sk.builtin.func(function (rhs, lhs) {
      lhs = Sk.ffi.remapToJs(lhs);
      rhs = Sk.ffi.remapToJs(rhs);
      if (isNumber(lhs)) {
        return remapE2ToPy(lhs - rhs[0], -rhs[1], -rhs[2], -rhs[3]);
      } else {
        throw new Sk.builtin.AssertionError('' + JSON.stringify(lhs, null, 2) + ' - ' + JSON.stringify(rhs, null, 2));
      }
    });
    $loc.__isub__ = new Sk.builtin.func(function (selfPy, otherPy) {
      var self = Sk.ffi.remapToJs(selfPy);
      var other = Sk.ffi.remapToJs(otherPy);
      if (isNumber(other)) {
        self[0] -= other;
        return selfPy;
      } else {
        self[0] -= other[0];
        self[1] -= other[1];
        self[2] -= other[2];
        self[3] -= other[3];
        return selfPy;
      }
    });
    $loc.__mul__ = new Sk.builtin.func(function (a, b) {
      a = Sk.ffi.remapToJs(a);
      b = Sk.ffi.remapToJs(b);
      if (isNumber(b)) {
        return remapE2ToPy(a[0] * b, a[1] * b, a[2] * b, a[3] * b);
      } else {
        var a00 = a[0];
        var a01 = a[1];
        var a10 = a[2];
        var a11 = a[3];
        var b00 = b[0];
        var b01 = b[1];
        var b10 = b[2];
        var b11 = b[3];
        var x00 = a00 * b00 + a01 * b01 + a10 * b10 - a11 * b11;
        var x01 = a00 * b01 + a01 * b00 - a10 * b11 + a11 * b10;
        var x10 = a00 * b10 + a01 * b11 + a10 * b00 - a11 * b01;
        var x11 = a00 * b11 + a01 * b10 - a10 * b01 + a11 * b00;
        return remapE2ToPy(x00, x01, x10, x11);
      }
    });
    $loc.__rmul__ = new Sk.builtin.func(function (rhs, lhs) {
      lhs = Sk.ffi.remapToJs(lhs);
      rhs = Sk.ffi.remapToJs(rhs);
      if (isNumber(lhs)) {
        return remapE2ToPy(lhs * rhs[0], lhs * rhs[1], lhs * rhs[2], lhs * rhs[3]);
      } else {
        throw new Sk.builtin.AssertionError('' + JSON.stringify(lhs, null, 2) + ' * ' + JSON.stringify(rhs, null, 2));
      }
    });
    $loc.__imul__ = new Sk.builtin.func(function (selfPy, otherPy) {
      var self = Sk.ffi.remapToJs(selfPy);
      var other = Sk.ffi.remapToJs(otherPy);
      if (isNumber(other)) {
        self[0] *= other;
        self[1] *= other;
        self[2] *= other;
        self[3] *= other;
        return selfPy;
      } else {
        var a00 = self[0];
        var a01 = self[1];
        var a10 = self[2];
        var a11 = self[3];
        var b00 = other[0];
        var b01 = other[1];
        var b10 = other[2];
        var b11 = other[3];
        self[0] = a00 * b00 + a01 * b01 + a10 * b10 - a11 * b11;
        self[1] = a00 * b01 + a01 * b00 - a10 * b11 + a11 * b10;
        self[2] = a00 * b10 + a01 * b11 + a10 * b00 - a11 * b01;
        self[3] = a00 * b11 + a01 * b10 - a10 * b01 + a11 * b00;
        return selfPy;
      }
    });
    $loc.__div__ = new Sk.builtin.func(function (a, b) {
      a = Sk.ffi.remapToJs(a);
      b = Sk.ffi.remapToJs(b);
      if (isNumber(b)) {
        return divide(a[0], a[1], a[2], a[3], b, 0, 0, 0, undefined);
      } else {
        return divide(a[0], a[1], a[2], a[3], b[0], b[1], b[2], b[3], undefined);
      }
    });
    $loc.__rdiv__ = new Sk.builtin.func(function (rhs, lhs) {
      lhs = Sk.ffi.remapToJs(lhs);
      rhs = Sk.ffi.remapToJs(rhs);
      if (isNumber(lhs)) {
        return divide(lhs, 0, 0, 0, rhs[0], rhs[1], rhs[2], rhs[3], undefined);
      } else {
        throw new Sk.builtin.AssertionError('' + JSON.stringify(lhs, null, 2) + ' / ' + JSON.stringify(rhs, null, 2));
      }
    });
    $loc.__idiv__ = new Sk.builtin.func(function (selfPy, otherPy) {
      var self = Sk.ffi.remapToJs(selfPy);
      var other = Sk.ffi.remapToJs(otherPy);
      if (isNumber(other)) {
        divide(self[0], self[1], self[2], self[3], other, 0, 0, 0, self);
        return selfPy;
      } else {
        divide(self[0], self[1], self[2], self[3], other[0], other[1], other[2], other[3], self);
        return selfPy;
      }
    });
    $loc.__xor__ = new Sk.builtin.func(function (a, b) {
      a = Sk.ffi.remapToJs(a);
      b = Sk.ffi.remapToJs(b);
      if (isNumber(b)) {
        return remapE2ToPy(a[0] * b, a[1] * b, a[2] * b, a[3] * b);
      } else {
        var a00 = a[0];
        var a01 = a[1];
        var a10 = a[2];
        var a11 = a[3];
        var b00 = b[0];
        var b01 = b[1];
        var b10 = b[2];
        var b11 = b[3];
        var x00 = a00 * b00;
        var x01 = a00 * b01 + a01 * b00;
        var x10 = a00 * b10 + a10 * b00;
        var x11 = a00 * b11 + a01 * b10 - a10 * b01 + a11 * b00;
        return remapE2ToPy(x00, x01, x10, x11);
      }
    });
    $loc.__rxor__ = new Sk.builtin.func(function (rhs, lhs) {
      lhs = Sk.ffi.remapToJs(lhs);
      rhs = Sk.ffi.remapToJs(rhs);
      if (isNumber(lhs)) {
        return remapE2ToPy(lhs * rhs[0], lhs * rhs[1], lhs * rhs[2], lhs * rhs[3]);
      } else {
        throw new Sk.builtin.AssertionError('' + JSON.stringify(lhs, null, 2) + ' ^ ' + JSON.stringify(rhs, null, 2));
      }
    });
    $loc.__ixor__ = new Sk.builtin.func(function (selfPy, otherPy) {
      var self = Sk.ffi.remapToJs(selfPy);
      var other = Sk.ffi.remapToJs(otherPy);
      if (isNumber(other)) {
        self[0] *= other;
        self[1] *= other;
        self[2] *= other;
        self[3] *= other;
        return selfPy;
      } else {
        var a00 = self[0];
        var a01 = self[1];
        var a10 = self[2];
        var a11 = self[3];
        var b00 = other[0];
        var b01 = other[1];
        var b10 = other[2];
        var b11 = other[3];
        self[0] = a00 * b00;
        self[1] = a00 * b01 + a01 * b00;
        self[2] = a00 * b10 + a10 * b00;
        self[3] = a00 * b11 + a01 * b10 - a10 * b01 + a11 * b00;
        return selfPy;
      }
    });
    $loc.__lshift__ = new Sk.builtin.func(function (a, b) {
      a = Sk.ffi.remapToJs(a);
      b = Sk.ffi.remapToJs(b);
      if (isNumber(b)) {
        return remapE2ToPy(a[0] * b, 0, 0, 0);
      } else {
        var a00 = a[0];
        var a01 = a[1];
        var a10 = a[2];
        var a11 = a[3];
        var b00 = b[0];
        var b01 = b[1];
        var b10 = b[2];
        var b11 = b[3];
        var x00 = a00 * b00 + a01 * b01 + a10 * b10 - a11 * b11;
        var x01 = a00 * b01 - a10 * b11;
        var x10 = a00 * b10 + a01 * b11;
        var x11 = a00 * b11;
        return remapE2ToPy(x00, x01, x10, x11);
      }
    });
    $loc.__rlshift__ = new Sk.builtin.func(function (rhs, lhs) {
      lhs = Sk.ffi.remapToJs(lhs);
      rhs = Sk.ffi.remapToJs(rhs);
      if (isNumber(lhs)) {
        return remapE2ToPy(lhs * rhs[0], lhs * rhs[1], lhs * rhs[2], lhs * rhs[3]);
      } else {
        throw new Sk.builtin.AssertionError('' + JSON.stringify(lhs, null, 2) + ' << ' + JSON.stringify(rhs, null, 2));
      }
    });
    $loc.__ilshift__ = new Sk.builtin.func(function (selfPy, otherPy) {
      var self = Sk.ffi.remapToJs(selfPy);
      var other = Sk.ffi.remapToJs(otherPy);
      if (isNumber(other)) {
        self[0] *= other;
        self[1] = 0;
        self[2] = 0;
        self[3] = 0;
        return selfPy;
      } else {
        var a00 = self[0];
        var a01 = self[1];
        var a10 = self[2];
        var a11 = self[3];
        var b00 = other[0];
        var b01 = other[1];
        var b10 = other[2];
        var b11 = other[3];
        self[0] = a00 * b00 + a01 * b01 + a10 * b10 - a11 * b11;
        self[1] = a00 * b01 - a10 * b11;
        self[2] = a00 * b10 + a01 * b11;
        self[3] = a00 * b11;
        return selfPy;
      }
    });
    $loc.__rshift__ = new Sk.builtin.func(function (a, b) {
      a = Sk.ffi.remapToJs(a);
      b = Sk.ffi.remapToJs(b);
      if (isNumber(b)) {
        return remapE2ToPy(a[0] * b, -a[1] * b, -a[2] * b, a[3] * b);
      } else {
        var a00 = a[0];
        var a01 = a[1];
        var a10 = a[2];
        var a11 = a[3];
        var b00 = b[0];
        var b01 = b[1];
        var b10 = b[2];
        var b11 = b[3];
        var x00 = a00 * b00 + a01 * b01 + a10 * b10 - a11 * b11;
        var x01 = +a01 * b00 + a11 * b10;
        var x10 = +a10 * b00 - a11 * b01;
        var x11 = a11 * b00;
        return remapE2ToPy(x00, x01, x10, x11);
      }
    });
    $loc.__rrshift__ = new Sk.builtin.func(function (rhs, lhs) {
      lhs = Sk.ffi.remapToJs(lhs);
      rhs = Sk.ffi.remapToJs(rhs);
      if (isNumber(lhs)) {
        return remapE2ToPy(lhs * rhs[0], 0, 0, 0);
      } else {
        throw new Sk.builtin.AssertionError('' + JSON.stringify(lhs, null, 2) + ' >> ' + JSON.stringify(rhs, null, 2));
      }
    });
    $loc.__irshift__ = new Sk.builtin.func(function (selfPy, otherPy) {
      var self = Sk.ffi.remapToJs(selfPy);
      var other = Sk.ffi.remapToJs(otherPy);
      if (isNumber(other)) {
        var a00 = self[0];
        var a01 = self[1];
        var a10 = self[2];
        var a11 = self[3];
        var b00 = other;
        var b01 = 0;
        var b10 = 0;
        var b11 = 0;
        self[0] *= other;
        self[1] *= -other;
        self[2] *= -other;
        self[3] *= other;
        return selfPy;
      } else {
        var a00 = self[0];
        var a01 = self[1];
        var a10 = self[2];
        var a11 = self[3];
        var b00 = other[0];
        var b01 = other[1];
        var b10 = other[2];
        var b11 = other[3];
        self[0] = a00 * b00 + a01 * b01 + a10 * b10 - a11 * b11;
        self[1] = +a01 * b00 + a11 * b10;
        self[2] = +a10 * b00 - a11 * b01;
        self[3] = a11 * b00;
        return selfPy;
      }
    });
    $loc.nb$negative = function () {
      var self = Sk.ffi.remapToJs(this);
      return remapE2ToPy(-self[0], -self[1], -self[2], -self[3]);
    };
    $loc.nb$positive = function () {
      return this;
    };
    $loc.nb$invert = function () {
      var self = Sk.ffi.remapToJs(this);
      return remapE2ToPy(self[0], self[1], self[2], -self[3]);
    };
    $loc.__getitem__ = new Sk.builtin.func(function (mv, index) {
      mv = Sk.ffi.remapToJs(mv);
      index = Sk.builtin.asnum$(index);
      switch (index) {
      case 0: {
          return remapE2ToPy(mv[0], 0, 0, 0);
        }
      case 1: {
          return remapE2ToPy(0, mv[1], mv[2], 0);
        }
      case 2: {
          return remapE2ToPy(0, 0, 0, mv[3]);
        }
      }
    });
    $loc.__repr__ = new Sk.builtin.func(function (mv) {
      mv = Sk.ffi.remapToJs(mv);
      return new Sk.builtin.str(EUCLIDEAN_2 + '(' + mv.join(', ') + ')');
    });
    $loc.__str__ = new Sk.builtin.func(function (mv) {
      mv = Sk.ffi.remapToJs(mv);
      if (typeof mv !== 'undefined') {
        return new Sk.builtin.str(stringFromCoordinates([
          mv[0],
          mv[1],
          mv[2],
          mv[3]
        ], [
          '1',
          'i',
          'j',
          'I'
        ], '*'));
      } else {
        return new Sk.builtin.str('<type \'' + EUCLIDEAN_2 + '\'>');
      }
    });
    $loc.__eq__ = new Sk.builtin.func(function (a, b) {
      a = Sk.ffi.remapToJs(a);
      b = Sk.ffi.remapToJs(b);
      return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
    });
    $loc.__ne__ = new Sk.builtin.func(function (a, b) {
      a = Sk.ffi.remapToJs(a);
      b = Sk.ffi.remapToJs(b);
      return a[0] !== b[0] || a[1] !== b[1] || a[2] !== b[2] || a[3] !== b[3];
    });
    $loc.__getattr__ = new Sk.builtin.func(function (mvPy, name) {
      var mv = Sk.ffi.remapToJs(mvPy);
      switch (name) {
      case PROP_W: {
          return Sk.builtin.assk$(mv[0], Sk.builtin.nmber.float$);
        }
        break;
      case PROP_X: {
          return Sk.builtin.assk$(mv[1], Sk.builtin.nmber.float$);
        }
        break;
      case PROP_Y: {
          return Sk.builtin.assk$(mv[2], Sk.builtin.nmber.float$);
        }
        break;
      case PROP_XY: {
          return Sk.builtin.assk$(mv[3], Sk.builtin.nmber.float$);
        }
        break;
      case METHOD_CLONE: {
          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function ($gbl, $loc) {
            $loc.__init__ = new Sk.builtin.func(function (methodPy) {
              methodPy.tp$name = METHOD_CLONE;
            });
            $loc.__call__ = new Sk.builtin.func(function (methodPy) {
              return remapE2ToPy(mv[0], mv[1], mv[2], mv[3]);
            });
            $loc.__str__ = new Sk.builtin.func(function (methodPy) {
              return new Sk.builtin.str(METHOD_CLONE);
            });
            $loc.__repr__ = new Sk.builtin.func(function (methodPy) {
              return new Sk.builtin.str(METHOD_CLONE);
            });
          }, METHOD_CLONE, []));
        }
      case METHOD_LENGTH: {
          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function ($gbl, $loc) {
            $loc.__init__ = new Sk.builtin.func(function (self) {
              self.tp$name = METHOD_LENGTH;
            });
            $loc.__call__ = new Sk.builtin.func(function (self) {
              return Sk.builtin.assk$(4, Sk.builtin.nmber.int$);
            });
            $loc.__str__ = new Sk.builtin.func(function (self) {
              return new Sk.builtin.str(METHOD_LENGTH);
            });
            $loc.__repr__ = new Sk.builtin.func(function (self) {
              return new Sk.builtin.str(METHOD_LENGTH);
            });
          }, METHOD_LENGTH, []));
        }
      default: {
          throw new Sk.builtin.AttributeError(name + ' is not a readable attribute of ' + EUCLIDEAN_2);
        }
      }
    });
    $loc.__setattr__ = new Sk.builtin.func(function (selfPy, name, valuePy) {
      var self = Sk.ffi.remapToJs(selfPy);
      var value = Sk.ffi.remapToJs(valuePy);
      switch (name) {
      case PROP_W: {
          self[0] = value;
        }
        break;
      case PROP_X: {
          self[1] = value;
        }
        break;
      case PROP_Y: {
          self[2] = value;
        }
        break;
      case PROP_XY: {
          self[3] = value;
        }
        break;
      default: {
          throw new Sk.builtin.AttributeError(name + ' is not a writeable attribute of ' + EUCLIDEAN_2);
        }
      }
    });
  }, EUCLIDEAN_2, []);
};
Sk.builtin.defineEuclidean3 = function (mod) {
  var EUCLIDEAN_3 = 'Euclidean3';
  var SCALAR_3 = 'Scalar3';
  var VECTOR_3 = 'Vector3';
  var BIVECTOR_3 = 'Bivector3';
  var PSEUDOSCALAR_3 = 'Pseudoscalar3';
  var PROP_W = 'w';
  var PROP_X = 'x';
  var PROP_Y = 'y';
  var PROP_Z = 'z';
  var PROP_XY = 'xy';
  var PROP_YZ = 'yz';
  var PROP_ZX = 'zx';
  var PROP_XYZ = 'xyz';
  var METHOD_ADD = 'add';
  var METHOD_CLONE = 'clone';
  var METHOD_CROSS = 'cross';
  var METHOD_DOT = 'dot';
  var METHOD_LENGTH = 'length';
  var METHOD_NORMALIZE = 'normalize';
  var METHOD_SET = 'set';
  var METHOD_SET_X = 'setX';
  var METHOD_SET_Y = 'setY';
  var METHOD_SET_Z = 'setZ';
  var METHOD_GET_COMPONENT = 'getComponent';
  var METHOD_SET_COMPONENT = 'setComponent';
  function Vector3(x, y, z) {
    this.x = x || 0;
    this.y = y || 0;
    this.z = z || 0;
  }
  Vector3.prototype = {
    constructor: Vector3,
    set: function (x, y, z) {
      this.x = x;
      this.y = y;
      this.z = z;
      return this;
    },
    setX: function (x) {
      this.x = x;
      return this;
    },
    setY: function (y) {
      this.y = y;
      return this;
    },
    setZ: function (z) {
      this.z = z;
      return this;
    },
    setComponent: function (index, value) {
      switch (index) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      case 2:
        this.z = value;
        break;
      default:
        throw new Error('index is out of range: ' + index);
      }
    },
    getComponent: function (index) {
      switch (index) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error('index is out of range: ' + index);
      }
    },
    copy: function (v) {
      this.x = v.x;
      this.y = v.y;
      this.z = v.z;
      return this;
    },
    add: function (v) {
      this.x += v.x;
      this.y += v.y;
      this.z += v.z;
      return this;
    },
    addScalar: function (s) {
      this.x += s;
      this.y += s;
      this.z += s;
      return this;
    },
    addVectors: function (a, b) {
      this.x = a.x + b.x;
      this.y = a.y + b.y;
      this.z = a.z + b.z;
      return this;
    },
    sub: function (v) {
      this.x -= v.x;
      this.y -= v.y;
      this.z -= v.z;
      return this;
    },
    subVectors: function (a, b) {
      this.x = a.x - b.x;
      this.y = a.y - b.y;
      this.z = a.z - b.z;
      return this;
    },
    multiply: function (v) {
      this.x *= v.x;
      this.y *= v.y;
      this.z *= v.z;
      return this;
    },
    multiplyScalar: function (scalar) {
      this.x *= scalar;
      this.y *= scalar;
      this.z *= scalar;
      return this;
    },
    multiplyVectors: function (a, b) {
      this.x = a.x * b.x;
      this.y = a.y * b.y;
      this.z = a.z * b.z;
      return this;
    },
    applyMatrix3: function (m) {
      var x = this.x;
      var y = this.y;
      var z = this.z;
      var e = m.elements;
      this.x = e[0] * x + e[3] * y + e[6] * z;
      this.y = e[1] * x + e[4] * y + e[7] * z;
      this.z = e[2] * x + e[5] * y + e[8] * z;
      return this;
    },
    applyMatrix4: function (m) {
      var x = this.x, y = this.y, z = this.z;
      var e = m.elements;
      this.x = e[0] * x + e[4] * y + e[8] * z + e[12];
      this.y = e[1] * x + e[5] * y + e[9] * z + e[13];
      this.z = e[2] * x + e[6] * y + e[10] * z + e[14];
      return this;
    },
    applyProjection: function (m) {
      var x = this.x, y = this.y, z = this.z;
      var e = m.elements;
      var d = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
      this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * d;
      this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * d;
      this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * d;
      return this;
    },
    applyQuaternion: function (q) {
      var x = this.x;
      var y = this.y;
      var z = this.z;
      var qx = q.x;
      var qy = q.y;
      var qz = q.z;
      var qw = q.w;
      var ix = qw * x + qy * z - qz * y;
      var iy = qw * y + qz * x - qx * z;
      var iz = qw * z + qx * y - qy * x;
      var iw = -qx * x - qy * y - qz * z;
      this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
      this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
      this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
      return this;
    },
    transformDirection: function (m) {
      var x = this.x, y = this.y, z = this.z;
      var e = m.elements;
      this.x = e[0] * x + e[4] * y + e[8] * z;
      this.y = e[1] * x + e[5] * y + e[9] * z;
      this.z = e[2] * x + e[6] * y + e[10] * z;
      this.normalize();
      return this;
    },
    divide: function (v) {
      this.x /= v.x;
      this.y /= v.y;
      this.z /= v.z;
      return this;
    },
    divideScalar: function (scalar) {
      if (scalar !== 0) {
        var invScalar = 1 / scalar;
        this.x *= invScalar;
        this.y *= invScalar;
        this.z *= invScalar;
      } else {
        this.x = 0;
        this.y = 0;
        this.z = 0;
      }
      return this;
    },
    min: function (v) {
      if (this.x > v.x) {
        this.x = v.x;
      }
      if (this.y > v.y) {
        this.y = v.y;
      }
      if (this.z > v.z) {
        this.z = v.z;
      }
      return this;
    },
    max: function (v) {
      if (this.x < v.x) {
        this.x = v.x;
      }
      if (this.y < v.y) {
        this.y = v.y;
      }
      if (this.z < v.z) {
        this.z = v.z;
      }
      return this;
    },
    clamp: function (min, max) {
      if (this.x < min.x) {
        this.x = min.x;
      } else if (this.x > max.x) {
        this.x = max.x;
      }
      if (this.y < min.y) {
        this.y = min.y;
      } else if (this.y > max.y) {
        this.y = max.y;
      }
      if (this.z < min.z) {
        this.z = min.z;
      } else if (this.z > max.z) {
        this.z = max.z;
      }
      return this;
    },
    negate: function () {
      return this.multiplyScalar(-1);
    },
    dot: function (v) {
      return this.x * v.x + this.y * v.y + this.z * v.z;
    },
    lengthSq: function () {
      return this.x * this.x + this.y * this.y + this.z * this.z;
    },
    length: function () {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    },
    lengthManhattan: function () {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
    },
    normalize: function () {
      return this.divideScalar(this.length());
    },
    setLength: function (l) {
      var oldLength = this.length();
      if (oldLength !== 0 && l !== oldLength) {
        this.multiplyScalar(l / oldLength);
      }
      return this;
    },
    lerp: function (v, alpha) {
      this.x += (v.x - this.x) * alpha;
      this.y += (v.y - this.y) * alpha;
      this.z += (v.z - this.z) * alpha;
      return this;
    },
    cross: function (v) {
      var x = this.x, y = this.y, z = this.z;
      this.x = y * v.z - z * v.y;
      this.y = z * v.x - x * v.z;
      this.z = x * v.y - y * v.x;
      return this;
    },
    crossVectors: function (a, b) {
      this.x = a.y * b.z - a.z * b.y;
      this.y = a.z * b.x - a.x * b.z;
      this.z = a.x * b.y - a.y * b.x;
      return this;
    },
    angleTo: function (v) {
      var theta = this.dot(v) / (this.length() * v.length());
      return Math.acos(clamp(theta, -1, 1));
    },
    distanceTo: function (v) {
      return Math.sqrt(this.distanceToSquared(v));
    },
    distanceToSquared: function (v) {
      var dx = this.x - v.x;
      var dy = this.y - v.y;
      var dz = this.z - v.z;
      return dx * dx + dy * dy + dz * dz;
    },
    getPositionFromMatrix: function (m) {
      this.x = m.elements[12];
      this.y = m.elements[13];
      this.z = m.elements[14];
      return this;
    },
    getScaleFromMatrix: function (m) {
      var sx = this.set(m.elements[0], m.elements[1], m.elements[2]).length();
      var sy = this.set(m.elements[4], m.elements[5], m.elements[6]).length();
      var sz = this.set(m.elements[8], m.elements[9], m.elements[10]).length();
      this.x = sx;
      this.y = sy;
      this.z = sz;
      return this;
    },
    getColumnFromMatrix: function (index, matrix) {
      var offset = index * 4;
      var me = matrix.elements;
      this.x = me[offset];
      this.y = me[offset + 1];
      this.z = me[offset + 2];
      return this;
    },
    equals: function (v) {
      return v.x === this.x && v.y === this.y && v.z === this.z;
    },
    fromArray: function (array) {
      this.x = array[0];
      this.y = array[1];
      this.z = array[2];
      return this;
    },
    toArray: function () {
      return [
        this.x,
        this.y,
        this.z
      ];
    },
    clone: function () {
      return new Vector3(this.x, this.y, this.z);
    }
  };
  function clamp(x, a, b) {
    return x < a ? a : x > b ? b : x;
  }
  function isNumber(x) {
    return typeof x === 'number';
  }
  function isUndefined(x) {
    return typeof x === 'undefined';
  }
  function isDefined(x) {
    return typeof x !== 'undefined';
  }
  function stringFromCoordinates(coordinates, labels) {
    var append, i, sb, str, _i, _ref;
    sb = [];
    append = function (number, label) {
      var n;
      if (number !== 0) {
        if (number >= 0) {
          if (sb.length > 0) {
            sb.push('+');
          }
        } else {
          sb.push('-');
        }
        n = Math.abs(number);
        if (n === 1) {
          return sb.push(label);
        } else {
          sb.push(n.toString());
          if (label !== '1') {
            sb.push('*');
            return sb.push(label);
          }
        }
      }
    };
    for (i = _i = 0, _ref = coordinates.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      append(coordinates[i], labels[i]);
    }
    if (sb.length > 0) {
      str = sb.join('');
    } else {
      str = '0';
    }
    return str;
  }
  function mulE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, index) {
    a0 = +a0;
    a1 = +a1;
    a2 = +a2;
    a3 = +a3;
    a4 = +a4;
    a5 = +a5;
    a6 = +a6;
    a7 = +a7;
    b0 = +b0;
    b1 = +b1;
    b2 = +b2;
    b3 = +b3;
    b4 = +b4;
    b5 = +b5;
    b6 = +b6;
    b7 = +b7;
    index = index | 0;
    var x = 0;
    switch (~~index) {
    case 0: {
        x = +(a0 * b0 + a1 * b1 + a2 * b2 + a3 * b3 - a4 * b4 - a5 * b5 - a6 * b6 - a7 * b7);
      }
      break;
    case 1: {
        x = +(a0 * b1 + a1 * b0 - a2 * b4 + a3 * b6 + a4 * b2 - a5 * b7 - a6 * b3 - a7 * b5);
      }
      break;
    case 2: {
        x = +(a0 * b2 + a1 * b4 + a2 * b0 - a3 * b5 - a4 * b1 + a5 * b3 - a6 * b7 - a7 * b6);
      }
      break;
    case 3: {
        x = +(a0 * b3 - a1 * b6 + a2 * b5 + a3 * b0 - a4 * b7 - a5 * b2 + a6 * b1 - a7 * b4);
      }
      break;
    case 4: {
        x = +(a0 * b4 + a1 * b2 - a2 * b1 + a3 * b7 + a4 * b0 - a5 * b6 + a6 * b5 + a7 * b3);
      }
      break;
    case 5: {
        x = +(a0 * b5 + a1 * b7 + a2 * b3 - a3 * b2 + a4 * b6 + a5 * b0 - a6 * b4 + a7 * b1);
      }
      break;
    case 6: {
        x = +(a0 * b6 - a1 * b3 + a2 * b7 + a3 * b1 - a4 * b5 + a5 * b4 + a6 * b0 + a7 * b2);
      }
      break;
    case 7: {
        x = +(a0 * b7 + a1 * b5 + a2 * b6 + a3 * b4 + a4 * b3 + a5 * b1 + a6 * b2 + a7 * b0);
      }
      break;
    default: {
      }
    }
    return +x;
  }
  function extE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, index) {
    a0 = +a0;
    a1 = +a1;
    a2 = +a2;
    a3 = +a3;
    a4 = +a4;
    a5 = +a5;
    a6 = +a6;
    a7 = +a7;
    b0 = +b0;
    b1 = +b1;
    b2 = +b2;
    b3 = +b3;
    b4 = +b4;
    b5 = +b5;
    b6 = +b6;
    b7 = +b7;
    index = index | 0;
    var x = 0;
    switch (~~index) {
    case 0: {
        x = +(a0 * b0);
      }
      break;
    case 1: {
        x = +(a0 * b1 + a1 * b0);
      }
      break;
    case 2: {
        x = +(a0 * b2 + a2 * b0);
      }
      break;
    case 3: {
        x = +(a0 * b3 + a3 * b0);
      }
      break;
    case 4: {
        x = +(a0 * b4 + a1 * b2 - a2 * b1 + a4 * b0);
      }
      break;
    case 5: {
        x = +(a0 * b5 + a2 * b3 - a3 * b2 + a5 * b0);
      }
      break;
    case 6: {
        x = +(a0 * b6 - a1 * b3 + a3 * b1 + a6 * b0);
      }
      break;
    case 7: {
        x = +(a0 * b7 + a1 * b5 + a2 * b6 + a3 * b4 + a4 * b3 + a5 * b1 + a6 * b2 + a7 * b0);
      }
      break;
    default: {
      }
    }
    return +x;
  }
  function lcoE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, index) {
    a0 = +a0;
    a1 = +a1;
    a2 = +a2;
    a3 = +a3;
    a4 = +a4;
    a5 = +a5;
    a6 = +a6;
    a7 = +a7;
    b0 = +b0;
    b1 = +b1;
    b2 = +b2;
    b3 = +b3;
    b4 = +b4;
    b5 = +b5;
    b6 = +b6;
    b7 = +b7;
    index = index | 0;
    var x = 0;
    switch (~~index) {
    case 0: {
        x = +(a0 * b0 + a1 * b1 + a2 * b2 + a3 * b3 - a4 * b4 - a5 * b5 - a6 * b6 - a7 * b7);
      }
      break;
    case 1: {
        x = +(a0 * b1 - a2 * b4 + a3 * b6 - a5 * b7);
      }
      break;
    case 2: {
        x = +(a0 * b2 + a1 * b4 - a3 * b5 - a6 * b7);
      }
      break;
    case 3: {
        x = +(a0 * b3 - a1 * b6 + a2 * b5 - a4 * b7);
      }
      break;
    case 4: {
        x = +(a0 * b4 + a3 * b7);
      }
      break;
    case 5: {
        x = +(a0 * b5 + a1 * b7);
      }
      break;
    case 6: {
        x = +(a0 * b6 + a2 * b7);
      }
      break;
    case 7: {
        x = +(a0 * b7);
      }
      break;
    default: {
      }
    }
    return +x;
  }
  function rcoE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, index) {
    a0 = +a0;
    a1 = +a1;
    a2 = +a2;
    a3 = +a3;
    a4 = +a4;
    a5 = +a5;
    a6 = +a6;
    a7 = +a7;
    b0 = +b0;
    b1 = +b1;
    b2 = +b2;
    b3 = +b3;
    b4 = +b4;
    b5 = +b5;
    b6 = +b6;
    b7 = +b7;
    index = index | 0;
    var x = 0;
    switch (~~index) {
    case 0: {
        x = +(a0 * b0 + a1 * b1 + a2 * b2 + a3 * b3 - a4 * b4 - a5 * b5 - a6 * b6 - a7 * b7);
      }
      break;
    case 1: {
        x = +(+a1 * b0 + a4 * b2 - a6 * b3 - a7 * b5);
      }
      break;
    case 2: {
        x = +(+a2 * b0 - a4 * b1 + a5 * b3 - a7 * b6);
      }
      break;
    case 3: {
        x = +(+a3 * b0 - a5 * b2 + a6 * b1 - a7 * b4);
      }
      break;
    case 4: {
        x = +(+a4 * b0 + a7 * b3);
      }
      break;
    case 5: {
        x = +(+a5 * b0 + a7 * b1);
      }
      break;
    case 6: {
        x = +(+a6 * b0 + a7 * b2);
      }
      break;
    case 7: {
        x = +(+a7 * b0);
      }
      break;
    default: {
      }
    }
    return +x;
  }
  function divide(a000, a001, a010, a011, a100, a101, a110, a111, b000, b001, b010, b011, b100, b101, b110, b111, dst) {
    var r000 = +b000;
    var r001 = +b001;
    var r010 = +b010;
    var r011 = -b011;
    var r100 = +b100;
    var r101 = -b101;
    var r110 = -b110;
    var r111 = -b111;
    var m000 = mulE3(b000, b001, b010, b100, b011, b110, -b101, b111, r000, r001, r010, r100, r011, r110, -r101, r111, 0);
    var m001 = mulE3(b000, b001, b010, b100, b011, b110, -b101, b111, r000, r001, r010, r100, r011, r110, -r101, r111, 1);
    var m010 = mulE3(b000, b001, b010, b100, b011, b110, -b101, b111, r000, r001, r010, r100, r011, r110, -r101, r111, 2);
    var m011 = 0;
    var m100 = mulE3(b000, b001, b010, b100, b011, b110, -b101, b111, r000, r001, r010, r100, r011, r110, -r101, r111, 3);
    var m101 = 0;
    var m110 = 0;
    var m111 = 0;
    var c000 = +m000;
    var c001 = -m001;
    var c010 = -m010;
    var c011 = -m011;
    var c100 = -m100;
    var c101 = -m101;
    var c110 = -m110;
    var c111 = +m111;
    var s000 = mulE3(r000, r001, r010, r100, r011, r110, -r101, r111, c000, c001, c010, c100, c011, c110, -c101, c111, 0);
    var s001 = mulE3(r000, r001, r010, r100, r011, r110, -r101, r111, c000, c001, c010, c100, c011, c110, -c101, c111, 1);
    var s010 = mulE3(r000, r001, r010, r100, r011, r110, -r101, r111, c000, c001, c010, c100, c011, c110, -c101, c111, 2);
    var s011 = mulE3(r000, r001, r010, r100, r011, r110, -r101, r111, c000, c001, c010, c100, c011, c110, -c101, c111, 4);
    var s100 = mulE3(r000, r001, r010, r100, r011, r110, -r101, r111, c000, c001, c010, c100, c011, c110, -c101, c111, 3);
    var s101 = -mulE3(r000, r001, r010, r100, r011, r110, -r101, r111, c000, c001, c010, c100, c011, c110, -c101, c111, 6);
    var s110 = mulE3(r000, r001, r010, r100, r011, r110, -r101, r111, c000, c001, c010, c100, c011, c110, -c101, c111, 5);
    var s111 = mulE3(r000, r001, r010, r100, r011, r110, -r101, r111, c000, c001, c010, c100, c011, c110, -c101, c111, 7);
    var k000 = mulE3(b000, b001, b010, b100, b011, b110, -b101, b111, s000, s001, s010, s100, s011, s110, -s101, s111, 0);
    var i000 = s000 / k000;
    var i001 = s001 / k000;
    var i010 = s010 / k000;
    var i011 = s011 / k000;
    var i100 = s100 / k000;
    var i101 = s101 / k000;
    var i110 = s110 / k000;
    var i111 = s111 / k000;
    var x000 = mulE3(a000, a001, a010, a100, a011, a110, -a101, a111, i000, i001, i010, i100, i011, i110, -i101, i111, 0);
    var x001 = mulE3(a000, a001, a010, a100, a011, a110, -a101, a111, i000, i001, i010, i100, i011, i110, -i101, i111, 1);
    var x010 = mulE3(a000, a001, a010, a100, a011, a110, -a101, a111, i000, i001, i010, i100, i011, i110, -i101, i111, 2);
    var x011 = mulE3(a000, a001, a010, a100, a011, a110, -a101, a111, i000, i001, i010, i100, i011, i110, -i101, i111, 4);
    var x100 = mulE3(a000, a001, a010, a100, a011, a110, -a101, a111, i000, i001, i010, i100, i011, i110, -i101, i111, 3);
    var x101 = -mulE3(a000, a001, a010, a100, a011, a110, -a101, a111, i000, i001, i010, i100, i011, i110, -i101, i111, 6);
    var x110 = mulE3(a000, a001, a010, a100, a011, a110, -a101, a111, i000, i001, i010, i100, i011, i110, -i101, i111, 5);
    var x111 = mulE3(a000, a001, a010, a100, a011, a110, -a101, a111, i000, i001, i010, i100, i011, i110, -i101, i111, 7);
    var w = x000;
    var x = x001;
    var y = x010;
    var z = x100;
    var xy = x011;
    var yz = x110;
    var zx = -x101;
    var xyz = x111;
    if (typeof dst !== 'undefined') {
      dst.w = w;
      dst.x = x;
      dst.y = y;
      dst.z = z;
      dst.xy = xy;
      dst.yz = yz;
      dst.zx = zx;
      dst.xyz = xyz;
    } else {
      return remapE3ToPy(w, x, y, z, xy, yz, zx, xyz);
    }
  }
  function multiVector3(w, vector, xy, yz, zx, xyz) {
    vector.w = w;
    vector.xy = xy;
    vector.yz = yz;
    vector.zx = zx;
    vector.xyz = xyz;
    return vector;
  }
  function remapE3ToPy(w, x, y, z, xy, yz, zx, xyz) {
    w = Sk.ffi.numberToPy(w);
    x = Sk.ffi.numberToPy(x);
    y = Sk.ffi.numberToPy(y);
    z = Sk.ffi.numberToPy(z);
    xy = Sk.ffi.numberToPy(xy);
    yz = Sk.ffi.numberToPy(yz);
    zx = Sk.ffi.numberToPy(zx);
    xyz = Sk.ffi.numberToPy(xyz);
    return Sk.misceval.callsim(mod[EUCLIDEAN_3], w, x, y, z, xy, yz, zx, xyz);
  }
  function coord(mv, index) {
    switch (index) {
    case 0: {
        return mv.w;
      }
    case 1: {
        return mv.x;
      }
    case 2: {
        return mv.y;
      }
    case 3: {
        return mv.z;
      }
    case 4: {
        return mv.xy;
      }
    case 5: {
        return mv.yz;
      }
    case 6: {
        return mv.zx;
      }
    case 7: {
        return mv.xyz;
      }
    default: {
        throw new Sk.builtin.AssertionError('' + index + ' is not a valid multivector coordinate index');
      }
    }
  }
  function compute(f, a, b, coord, pack) {
    var a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, x0, x1, x2, x3, x4, x5, x6, x7;
    a0 = a.w;
    a1 = a.x;
    a2 = a.y;
    a3 = a.z;
    a4 = a.xy;
    a5 = a.yz;
    a6 = a.zx;
    a7 = a.xyz;
    b0 = b.w;
    b1 = b.x;
    b2 = b.y;
    b3 = b.z;
    b4 = b.xy;
    b5 = b.yz;
    b6 = b.zx;
    b7 = b.xyz;
    x0 = f(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 0);
    x1 = f(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 1);
    x2 = f(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 2);
    x3 = f(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 3);
    x4 = f(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 4);
    x5 = f(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 5);
    x6 = f(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 6);
    x7 = f(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 7);
    return pack(x0, x1, x2, x3, x4, x5, x6, x7);
  }
  mod[SCALAR_3] = new Sk.builtin.func(function (w) {
    Sk.builtin.pyCheckArgs(SCALAR_3, arguments, 1, 1);
    Sk.builtin.pyCheckType('w', 'Number', Sk.builtin.checkNumber(w));
    w = Sk.ffi.numberToJs(w);
    return remapE3ToPy(w, 0, 0, 0, 0, 0, 0, 0);
  });
  mod[VECTOR_3] = new Sk.builtin.func(function (x, y, z) {
    Sk.builtin.pyCheckArgs(VECTOR_3, arguments, 3, 3);
    Sk.builtin.pyCheckType('x', 'Number', Sk.builtin.checkNumber(x));
    Sk.builtin.pyCheckType('y', 'Number', Sk.builtin.checkNumber(y));
    Sk.builtin.pyCheckType('z', 'Number', Sk.builtin.checkNumber(z));
    x = Sk.ffi.numberToJs(x);
    y = Sk.ffi.numberToJs(y);
    z = Sk.ffi.numberToJs(z);
    return remapE3ToPy(0, x, y, z, 0, 0, 0, 0);
  });
  mod[BIVECTOR_3] = new Sk.builtin.func(function (xy, yz, zx) {
    Sk.builtin.pyCheckArgs(BIVECTOR_3, arguments, 3, 3);
    Sk.builtin.pyCheckType('xy', 'Number', Sk.builtin.checkNumber(xy));
    Sk.builtin.pyCheckType('yz', 'Number', Sk.builtin.checkNumber(yz));
    Sk.builtin.pyCheckType('zx', 'Number', Sk.builtin.checkNumber(zx));
    xy = Sk.ffi.numberToJs(xy);
    yz = Sk.ffi.numberToJs(yz);
    zx = Sk.ffi.numberToJs(zx);
    return remapE3ToPy(0, 0, 0, 0, xy, yz, zx, 0);
  });
  mod[PSEUDOSCALAR_3] = new Sk.builtin.func(function (xyz) {
    Sk.builtin.pyCheckArgs(PSEUDOSCALAR_3, arguments, 1, 1);
    Sk.builtin.pyCheckType('xyz', 'Number', Sk.builtin.checkNumber(xyz));
    xyz = Sk.ffi.numberToJs(xyz);
    return remapE3ToPy(0, 0, 0, 0, 0, 0, 0, xyz);
  });
  mod[EUCLIDEAN_3] = Sk.misceval.buildClass(mod, function ($gbl, $loc) {
    $loc.__init__ = new Sk.builtin.func(function (self, w, x, y, z, xy, yz, zx, xyz) {
      w = Sk.ffi.remapToJs(w);
      x = Sk.ffi.remapToJs(x);
      y = Sk.ffi.remapToJs(y);
      z = Sk.ffi.remapToJs(z);
      xy = Sk.ffi.remapToJs(xy);
      yz = Sk.ffi.remapToJs(yz);
      zx = Sk.ffi.remapToJs(zx);
      xyz = Sk.ffi.remapToJs(xyz);
      if (isNumber(w) && isNumber(x) && isNumber(y) && isNumber(z) && isNumber(xy) && isNumber(yz) && isNumber(zx) && isNumber(xyz)) {
        self.v = multiVector3(w, new Vector3(x, y, z), xy, yz, zx, xyz);
      } else if (isDefined(w) && isUndefined(x) && isUndefined(y) && isUndefined(z) && isUndefined(xy) && isUndefined(yz) && isUndefined(zx) && isUndefined(xyz)) {
        self.v = multiVector3(w.w || 0, w, w.xy || 0, w.yz || 0, w.zx || 0, w.xyz || 0);
      } else if (isDefined(w) && isUndefined(x) && isUndefined(y) && isUndefined(z) && isDefined(xy) && isDefined(yz) && isDefined(zx) && isDefined(xyz)) {
        self.v = multiVector3(w, new Vector3(0, 0, 0), xy, yz, zx, xyz);
      } else if (isUndefined(w) && isUndefined(x) && isUndefined(y) && isUndefined(z) && isUndefined(xy) && isUndefined(yz) && isUndefined(zx) && isUndefined(xyz)) {
        self.v = multiVector3(0, new Vector3(0, 0, 0), 0, 0, 0, 0);
      } else {
        throw new Sk.builtin.AssertionError(EUCLIDEAN_3);
      }
      self.tp$name = EUCLIDEAN_3;
    });
    $loc.__add__ = new Sk.builtin.func(function (a, b) {
      a = Sk.ffi.remapToJs(a);
      b = Sk.ffi.remapToJs(b);
      if (isNumber(b)) {
        return remapE3ToPy(a.w + b, a.x, a.y, a.z, a.xy, a.yz, a.zx, a.xyz);
      } else {
        var w = a.w + b.w;
        var x = a.x + b.x;
        var y = a.y + b.y;
        var z = a.z + b.z;
        var xy = a.xy + b.xy;
        var yz = a.yz + b.yz;
        var zx = a.zx + b.zx;
        var xyz = a.xyz + b.xyz;
        return remapE3ToPy(w, x, y, z, xy, yz, zx, xyz);
      }
    });
    $loc.__radd__ = new Sk.builtin.func(function (b, a) {
      a = Sk.ffi.remapToJs(a);
      b = Sk.ffi.remapToJs(b);
      if (isNumber(a)) {
        return remapE3ToPy(a + b.w, b.x, b.y, b.z, b.xy, b.yz, b.zx, b.xyz);
      } else {
        throw new Sk.builtin.AssertionError();
      }
    });
    $loc.__iadd__ = new Sk.builtin.func(function (selfPy, otherPy) {
      var self = Sk.ffi.remapToJs(selfPy);
      var other = Sk.ffi.remapToJs(otherPy);
      if (isNumber(other)) {
        self.w += other;
      } else {
        self.w += other.w;
        self.x += other.x;
        self.y += other.y;
        self.z += other.z;
        self.xy += other.xy;
        self.yz += other.yz;
        self.zx += other.zx;
        self.xyz += other.xyz;
      }
      return selfPy;
    });
    $loc.__sub__ = new Sk.builtin.func(function (a, b) {
      a = Sk.ffi.remapToJs(a);
      b = Sk.ffi.remapToJs(b);
      if (isNumber(b)) {
        return remapE3ToPy(a.w - b, a.x, a.y, a.z, a.xy, a.yz, a.zx, a.xyz);
      } else {
        var w = a.w - b.w;
        var x = a.x - b.x;
        var y = a.y - b.y;
        var z = a.z - b.z;
        var xy = a.xy - b.xy;
        var yz = a.yz - b.yz;
        var zx = a.zx - b.zx;
        var xyz = a.xyz - b.xyz;
        return remapE3ToPy(w, x, y, z, xy, yz, zx, xyz);
      }
    });
    $loc.__rsub__ = new Sk.builtin.func(function (b, a) {
      a = Sk.ffi.remapToJs(a);
      b = Sk.ffi.remapToJs(b);
      if (isNumber(a)) {
        return remapE3ToPy(a - b.w, -b.x, -b.y, -b.z, -b.xy, -b.yz, -b.zx, -b.xyz);
      } else {
        throw new Sk.builtin.AssertionError();
      }
    });
    $loc.__isub__ = new Sk.builtin.func(function (selfPy, otherPy) {
      var self = Sk.ffi.remapToJs(selfPy);
      var other = Sk.ffi.remapToJs(otherPy);
      if (isNumber(other)) {
        self.w -= other;
      } else {
        self.w -= other.w;
        self.x -= other.x;
        self.y -= other.y;
        self.z -= other.z;
        self.xy -= other.xy;
        self.yz -= other.yz;
        self.zx -= other.zx;
        self.xyz -= other.xyz;
      }
      return selfPy;
    });
    $loc.__mul__ = new Sk.builtin.func(function (a, b) {
      a = Sk.ffi.remapToJs(a);
      b = Sk.ffi.remapToJs(b);
      if (isNumber(b)) {
        return remapE3ToPy(a.w * b, a.x * b, a.y * b, a.z * b, a.xy * b, a.yz * b, a.zx * b, a.xyz * b);
      } else {
        return compute(mulE3, a, b, coord, remapE3ToPy);
      }
    });
    $loc.__rmul__ = new Sk.builtin.func(function (b, a) {
      a = Sk.ffi.remapToJs(a);
      b = Sk.ffi.remapToJs(b);
      if (isNumber(a)) {
        return remapE3ToPy(a * b.w, a * b.x, a * b.y, a * b.z, a * b.xy, a * b.yz, a * b.zx, a * b.xyz);
      } else {
        throw new Sk.builtin.AssertionError();
      }
    });
    $loc.__imul__ = new Sk.builtin.func(function (selfPy, otherPy) {
      var a = Sk.ffi.remapToJs(selfPy);
      var b = Sk.ffi.remapToJs(otherPy);
      var a0 = a.w;
      var a1 = a.x;
      var a2 = a.y;
      var a3 = a.z;
      var a4 = a.xy;
      var a5 = a.yz;
      var a6 = a.zx;
      var a7 = a.xyz;
      var b0, b1, b2, b3, b4, b5, b6, b7;
      if (isNumber(b)) {
        b0 = b;
        b1 = 0;
        b2 = 0;
        b3 = 0;
        b4 = 0;
        b5 = 0;
        b6 = 0;
        b7 = 0;
      } else {
        b0 = b.w;
        b1 = b.x;
        b2 = b.y;
        b3 = b.z;
        b4 = b.xy;
        b5 = b.yz;
        b6 = b.zx;
        b7 = b.xyz;
      }
      a.w = mulE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 0);
      a.x = mulE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 1);
      a.y = mulE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 2);
      a.z = mulE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 3);
      a.xy = mulE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 4);
      a.yz = mulE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 5);
      a.zx = mulE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 6);
      a.xyz = mulE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 7);
      return selfPy;
    });
    $loc.__div__ = new Sk.builtin.func(function (a, b) {
      a = Sk.ffi.remapToJs(a);
      b = Sk.ffi.remapToJs(b);
      if (isNumber(b)) {
        return divide(a.w, a.x, a.y, a.xy, a.z, -a.zx, a.yz, a.xyz, b, 0, 0, 0, 0, 0, 0, 0, undefined);
      } else {
        return divide(a.w, a.x, a.y, a.xy, a.z, -a.zx, a.yz, a.xyz, b.w, b.x, b.y, b.xy, b.z, -b.zx, b.yz, b.xyz, undefined);
      }
    });
    $loc.__rdiv__ = new Sk.builtin.func(function (rhs, lhs) {
      lhs = Sk.ffi.remapToJs(lhs);
      rhs = Sk.ffi.remapToJs(rhs);
      if (isNumber(lhs)) {
        return divide(lhs, 0, 0, 0, 0, 0, 0, 0, rhs.w, rhs.x, rhs.y, rhs.xy, rhs.z, -rhs.zx, rhs.yz, rhs.xyz, undefined);
      } else {
        throw new Sk.builtin.AssertionError('' + JSON.stringify(lhs, null, 2) + ' / ' + JSON.stringify(rhs, null, 2));
      }
    });
    $loc.__idiv__ = new Sk.builtin.func(function (selfPy, otherPy) {
      var a = Sk.ffi.remapToJs(selfPy);
      var b = Sk.ffi.remapToJs(otherPy);
      if (isNumber(b)) {
        divide(a.w, a.x, a.y, a.xy, a.z, -a.zx, a.yz, a.xyz, b, 0, 0, 0, 0, 0, 0, 0, a);
        return selfPy;
      } else {
        divide(a.w, a.x, a.y, a.xy, a.z, -a.zx, a.yz, a.xyz, b.w, b.x, b.y, b.xy, b.z, -b.zx, b.yz, b.xyz, a);
        return selfPy;
      }
    });
    $loc.__xor__ = new Sk.builtin.func(function (a, b) {
      a = Sk.ffi.remapToJs(a);
      b = Sk.ffi.remapToJs(b);
      if (isNumber(b)) {
        return remapE3ToPy(a.w * b, a.x * b, a.y * b, a.z * b, a.xy * b, a.yz * b, a.zx * b, a.xyz * b);
      } else {
        return compute(extE3, a, b, coord, remapE3ToPy);
      }
    });
    $loc.__rxor__ = new Sk.builtin.func(function (b, a) {
      a = Sk.ffi.remapToJs(a);
      b = Sk.ffi.remapToJs(b);
      if (isNumber(a)) {
        return remapE3ToPy(a * b.w, a * b.x, a * b.y, a * b.z, a * b.xy, a * b.yz, a * b.zx, a * b.xyz);
      } else {
        throw new Sk.builtin.AssertionError();
      }
    });
    $loc.__ixor__ = new Sk.builtin.func(function (selfPy, otherPy) {
      var a = Sk.ffi.remapToJs(selfPy);
      var b = Sk.ffi.remapToJs(otherPy);
      var a0 = a.w;
      var a1 = a.x;
      var a2 = a.y;
      var a3 = a.z;
      var a4 = a.xy;
      var a5 = a.yz;
      var a6 = a.zx;
      var a7 = a.xyz;
      var b0, b1, b2, b3, b4, b5, b6, b7;
      if (isNumber(b)) {
        b0 = b;
        b1 = 0;
        b2 = 0;
        b3 = 0;
        b4 = 0;
        b5 = 0;
        b6 = 0;
        b7 = 0;
      } else {
        b0 = b.w;
        b1 = b.x;
        b2 = b.y;
        b3 = b.z;
        b4 = b.xy;
        b5 = b.yz;
        b6 = b.zx;
        b7 = b.xyz;
      }
      a.w = extE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 0);
      a.x = extE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 1);
      a.y = extE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 2);
      a.z = extE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 3);
      a.xy = extE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 4);
      a.yz = extE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 5);
      a.zx = extE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 6);
      a.xyz = extE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 7);
      return selfPy;
    });
    $loc.__lshift__ = new Sk.builtin.func(function (a, b) {
      a = Sk.ffi.remapToJs(a);
      b = Sk.ffi.remapToJs(b);
      if (isNumber(b)) {
        return remapE3ToPy(a.w * b, 0, 0, 0, 0, 0, 0, 0);
      } else {
        return compute(lcoE3, a, b, coord, remapE3ToPy);
      }
    });
    $loc.__rlshift__ = new Sk.builtin.func(function (b, a) {
      a = Sk.ffi.remapToJs(a);
      b = Sk.ffi.remapToJs(b);
      if (isNumber(a)) {
        return remapE3ToPy(a * b.w, a * b.x, a * b.y, a * b.z, a * b.xy, a * b.yz, a * b.zx, a * b.xyz);
      } else {
        throw new Sk.builtin.AssertionError();
      }
    });
    $loc.__ilshift__ = new Sk.builtin.func(function (selfPy, otherPy) {
      var a = Sk.ffi.remapToJs(selfPy);
      var b = Sk.ffi.remapToJs(otherPy);
      var a0 = a.w;
      var a1 = a.x;
      var a2 = a.y;
      var a3 = a.z;
      var a4 = a.xy;
      var a5 = a.yz;
      var a6 = a.zx;
      var a7 = a.xyz;
      var b0, b1, b2, b3, b4, b5, b6, b7;
      if (isNumber(b)) {
        b0 = b;
        b1 = 0;
        b2 = 0;
        b3 = 0;
        b4 = 0;
        b5 = 0;
        b6 = 0;
        b7 = 0;
      } else {
        b0 = b.w;
        b1 = b.x;
        b2 = b.y;
        b3 = b.z;
        b4 = b.xy;
        b5 = b.yz;
        b6 = b.zx;
        b7 = b.xyz;
      }
      a.w = lcoE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 0);
      a.x = lcoE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 1);
      a.y = lcoE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 2);
      a.z = lcoE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 3);
      a.xy = lcoE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 4);
      a.yz = lcoE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 5);
      a.zx = lcoE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 6);
      a.xyz = lcoE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 7);
      return selfPy;
    });
    $loc.__rshift__ = new Sk.builtin.func(function (a, b) {
      a = Sk.ffi.remapToJs(a);
      b = Sk.ffi.remapToJs(b);
      if (isNumber(b)) {
        return remapE3ToPy(a.w * b, a.x * b, a.y * b, a.z * b, a.xy * b, a.yz * b, a.zx * b, a.xyz * b);
      } else {
        return compute(rcoE3, a, b, coord, remapE3ToPy);
      }
    });
    $loc.__rrshift__ = new Sk.builtin.func(function (b, a) {
      a = Sk.ffi.remapToJs(a);
      b = Sk.ffi.remapToJs(b);
      if (isNumber(a)) {
        return remapE3ToPy(a * b.w, 0, 0, 0, 0, 0, 0, 0);
      } else {
        throw new Sk.builtin.AssertionError();
      }
    });
    $loc.__irshift__ = new Sk.builtin.func(function (selfPy, otherPy) {
      var a = Sk.ffi.remapToJs(selfPy);
      var b = Sk.ffi.remapToJs(otherPy);
      var a0 = a.w;
      var a1 = a.x;
      var a2 = a.y;
      var a3 = a.z;
      var a4 = a.xy;
      var a5 = a.yz;
      var a6 = a.zx;
      var a7 = a.xyz;
      var b0, b1, b2, b3, b4, b5, b6, b7;
      if (isNumber(b)) {
        b0 = b;
        b1 = 0;
        b2 = 0;
        b3 = 0;
        b4 = 0;
        b5 = 0;
        b6 = 0;
        b7 = 0;
      } else {
        b0 = b.w;
        b1 = b.x;
        b2 = b.y;
        b3 = b.z;
        b4 = b.xy;
        b5 = b.yz;
        b6 = b.zx;
        b7 = b.xyz;
      }
      a.w = rcoE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 0);
      a.x = rcoE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 1);
      a.y = rcoE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 2);
      a.z = rcoE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 3);
      a.xy = rcoE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 4);
      a.yz = rcoE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 5);
      a.zx = rcoE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 6);
      a.xyz = rcoE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 7);
      return selfPy;
    });
    $loc.nb$positive = function () {
      return this;
    };
    $loc.nb$negative = function () {
      var mv = Sk.ffi.remapToJs(this);
      return remapE3ToPy(-mv.w, -mv.x, -mv.y, -mv.z, -mv.xy, -mv.yz, -mv.zx, -mv.xyz);
    };
    $loc.nb$invert = function () {
      var mv = Sk.ffi.remapToJs(this);
      return remapE3ToPy(mv.w, mv.x, mv.y, mv.z, -mv.xy, -mv.yz, -mv.zx, -mv.xyz);
    };
    $loc.__eq__ = new Sk.builtin.func(function (a, b) {
      a = Sk.ffi.remapToJs(a);
      b = Sk.ffi.remapToJs(b);
      return a.w === b.w && a.x === b.x && a.y === b.y && a.z === b.z && a.xy === b.xy && a.yz === b.yz && a.zx === b.zx && a.xyz === b.xyz;
    });
    $loc.__ne__ = new Sk.builtin.func(function (a, b) {
      a = Sk.ffi.remapToJs(a);
      b = Sk.ffi.remapToJs(b);
      return a.w !== b.w || a.x !== b.x || a.y !== b.y || a.z !== b.z || a.xy !== b.xy || a.yz !== b.yz || a.zx !== b.zx || a.xyz !== b.xyz;
    });
    $loc.__getitem__ = new Sk.builtin.func(function (mv, index) {
      mv = Sk.ffi.remapToJs(mv);
      index = Sk.builtin.asnum$(index);
      switch (index) {
      case 0: {
          return remapE3ToPy(mv.w, 0, 0, 0, 0, 0, 0, 0);
        }
      case 1: {
          return remapE3ToPy(0, mv.x, mv.y, mv.z, 0, 0, 0, 0);
        }
      case 2: {
          return remapE3ToPy(0, 0, 0, 0, mv.xy, mv.yz, mv.zx, 0);
        }
      case 3: {
          return remapE3ToPy(0, 0, 0, 0, 0, 0, 0, mv.xyz);
        }
      }
    });
    $loc.__getattr__ = new Sk.builtin.func(function (mvPy, name) {
      var mv = Sk.ffi.remapToJs(mvPy);
      switch (name) {
      case PROP_W: {
          return Sk.ffi.numberToPy(mv.w);
        }
      case PROP_X: {
          return Sk.ffi.numberToPy(mv.x);
        }
      case PROP_Y: {
          return Sk.ffi.numberToPy(mv.y);
        }
      case PROP_Z: {
          return Sk.ffi.numberToPy(mv.z);
        }
      case PROP_XY: {
          return Sk.ffi.numberToPy(mv.xy);
        }
      case PROP_YZ: {
          return Sk.ffi.numberToPy(mv.yz);
        }
      case PROP_ZX: {
          return Sk.ffi.numberToPy(mv.zx);
        }
      case PROP_XYZ: {
          return Sk.ffi.numberToPy(mv.xyz);
        }
      case METHOD_ADD: {
          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function ($gbl, $loc) {
            $loc.__init__ = new Sk.builtin.func(function (self) {
              self.tp$name = METHOD_ADD;
            });
            $loc.__call__ = new Sk.builtin.func(function (self, arg) {
              arg = Sk.ffi.remapToJs(arg);
              mv.w += arg.w;
              mv.x += arg.x;
              mv.y += arg.y;
              mv.z += arg.z;
              mv.xy += arg.xy;
              mv.yz += arg.yz;
              mv.zx += arg.zx;
              mv.xyz += arg.xyz;
              return mvPy;
            });
            $loc.__str__ = new Sk.builtin.func(function (self) {
              return new Sk.builtin.str(METHOD_ADD);
            });
            $loc.__repr__ = new Sk.builtin.func(function (self) {
              return new Sk.builtin.str(METHOD_ADD);
            });
          }, METHOD_ADD, []));
        }
      case METHOD_CROSS: {
          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function ($gbl, $loc) {
            $loc.__init__ = new Sk.builtin.func(function (self) {
              self.tp$name = METHOD_CROSS;
            });
            $loc.__call__ = new Sk.builtin.func(function (self, vPy) {
              var v = Sk.ffi.remapToJs(vPy);
              mv.w = 0;
              mv[METHOD_CROSS](v);
              mv.xy = 0;
              mv.yz = 0;
              mv.zx = 0;
              mv.xyz = 0;
              return mvPy;
            });
            $loc.__str__ = new Sk.builtin.func(function (self) {
              return new Sk.builtin.str(METHOD_CROSS);
            });
            $loc.__repr__ = new Sk.builtin.func(function (self) {
              return new Sk.builtin.str(METHOD_CROSS);
            });
          }, METHOD_CROSS, []));
        }
      case METHOD_DOT: {
          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function ($gbl, $loc) {
            $loc.__init__ = new Sk.builtin.func(function (self) {
              self.tp$name = METHOD_DOT;
            });
            $loc.__call__ = new Sk.builtin.func(function (self, vPy) {
              var v = Sk.ffi.remapToJs(vPy);
              return Sk.ffi.numberToPy(mv[METHOD_DOT](v));
            });
            $loc.__str__ = new Sk.builtin.func(function (self) {
              return Sk.ffi.stringToPy(METHOD_DOT);
            });
            $loc.__repr__ = new Sk.builtin.func(function (self) {
              return Sk.ffi.stringToPy(METHOD_DOT);
            });
          }, METHOD_DOT, []));
        }
      case METHOD_SET_X: {
          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function ($gbl, $loc) {
            $loc.__init__ = new Sk.builtin.func(function (self) {
              self.tp$name = METHOD_SET_X;
            });
            $loc.__call__ = new Sk.builtin.func(function (self, x) {
              x = Sk.ffi.remapToJs(x);
              mv[METHOD_SET_X](x);
              return mvPy;
            });
            $loc.__str__ = new Sk.builtin.func(function (self) {
              return new Sk.builtin.str(METHOD_SET_X);
            });
            $loc.__repr__ = new Sk.builtin.func(function (self) {
              return new Sk.builtin.str(METHOD_SET_X);
            });
          }, METHOD_SET_X, []));
        }
      case METHOD_SET_Y: {
          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function ($gbl, $loc) {
            $loc.__init__ = new Sk.builtin.func(function (self) {
              self.tp$name = METHOD_SET_Y;
            });
            $loc.__call__ = new Sk.builtin.func(function (self, y) {
              y = Sk.ffi.remapToJs(y);
              mv[METHOD_SET_Y](y);
              return mvPy;
            });
            $loc.__str__ = new Sk.builtin.func(function (self) {
              return new Sk.builtin.str(METHOD_SET_Y);
            });
            $loc.__repr__ = new Sk.builtin.func(function (self) {
              return new Sk.builtin.str(METHOD_SET_Y);
            });
          }, METHOD_SET_Y, []));
        }
      case METHOD_SET_Z: {
          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function ($gbl, $loc) {
            $loc.__init__ = new Sk.builtin.func(function (self) {
              self.tp$name = METHOD_SET_Z;
            });
            $loc.__call__ = new Sk.builtin.func(function (self, z) {
              z = Sk.ffi.remapToJs(z);
              mv[METHOD_SET_Z](z);
              return mvPy;
            });
            $loc.__str__ = new Sk.builtin.func(function (self) {
              return new Sk.builtin.str(METHOD_SET_Z);
            });
            $loc.__repr__ = new Sk.builtin.func(function (self) {
              return new Sk.builtin.str(METHOD_SET_Z);
            });
          }, METHOD_SET_Z, []));
        }
      case METHOD_GET_COMPONENT: {
          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function ($gbl, $loc) {
            $loc.__init__ = new Sk.builtin.func(function (self) {
              self.tp$name = METHOD_GET_COMPONENT;
            });
            $loc.__call__ = new Sk.builtin.func(function (self, index) {
              index = Sk.ffi.remapToJs(index);
              return Sk.ffi.numberToPy(mv[METHOD_GET_COMPONENT](index));
            });
            $loc.__str__ = new Sk.builtin.func(function (self) {
              return new Sk.builtin.str(METHOD_GET_COMPONENT);
            });
            $loc.__repr__ = new Sk.builtin.func(function (self) {
              return new Sk.builtin.str(METHOD_GET_COMPONENT);
            });
          }, METHOD_GET_COMPONENT, []));
        }
      case METHOD_SET_COMPONENT: {
          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function ($gbl, $loc) {
            $loc.__init__ = new Sk.builtin.func(function (self) {
              self.tp$name = METHOD_SET_COMPONENT;
            });
            $loc.__call__ = new Sk.builtin.func(function (self, index, value) {
              index = Sk.ffi.remapToJs(index);
              value = Sk.ffi.remapToJs(value);
              mv[METHOD_SET_COMPONENT](index, value);
              return mvPy;
            });
            $loc.__str__ = new Sk.builtin.func(function (self) {
              return new Sk.builtin.str(METHOD_SET_COMPONENT);
            });
            $loc.__repr__ = new Sk.builtin.func(function (self) {
              return new Sk.builtin.str(METHOD_SET_COMPONENT);
            });
          }, METHOD_SET_COMPONENT, []));
        }
      case METHOD_SET: {
          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function ($gbl, $loc) {
            $loc.__init__ = new Sk.builtin.func(function (self) {
              self.tp$name = METHOD_SET;
            });
            $loc.__call__ = new Sk.builtin.func(function (self, x, y, z) {
              x = Sk.ffi.remapToJs(x);
              y = Sk.ffi.remapToJs(y);
              z = Sk.ffi.remapToJs(z);
              mv[METHOD_SET](x, y, z);
              return mvPy;
            });
            $loc.__str__ = new Sk.builtin.func(function (self) {
              return new Sk.builtin.str(METHOD_SET);
            });
            $loc.__repr__ = new Sk.builtin.func(function (self) {
              return new Sk.builtin.str(METHOD_SET);
            });
          }, METHOD_SET, []));
        }
      case METHOD_CLONE: {
          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function ($gbl, $loc) {
            $loc.__init__ = new Sk.builtin.func(function (self) {
              self.tp$name = METHOD_CLONE;
            });
            $loc.__call__ = new Sk.builtin.func(function (self) {
              return remapE3ToPy(mv.w, mv.x, mv.y, mv.z, mv.xy, mv.yz, mv.zx, mv.xyz);
            });
            $loc.__str__ = new Sk.builtin.func(function (self) {
              return new Sk.builtin.str(METHOD_CLONE);
            });
            $loc.__repr__ = new Sk.builtin.func(function (self) {
              return new Sk.builtin.str(METHOD_CLONE);
            });
          }, METHOD_CLONE, []));
        }
      case METHOD_LENGTH: {
          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function ($gbl, $loc) {
            $loc.__init__ = new Sk.builtin.func(function (self) {
              self.tp$name = METHOD_LENGTH;
            });
            $loc.__call__ = new Sk.builtin.func(function (self) {
              return Sk.ffi.numberToPy(mv['length']());
            });
            $loc.__str__ = new Sk.builtin.func(function (self) {
              return new Sk.builtin.str(METHOD_LENGTH);
            });
            $loc.__repr__ = new Sk.builtin.func(function (self) {
              return new Sk.builtin.str(METHOD_LENGTH);
            });
          }, METHOD_LENGTH, []));
        }
      case METHOD_NORMALIZE: {
          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function ($gbl, $loc) {
            $loc.__init__ = new Sk.builtin.func(function (self) {
              self.tp$name = METHOD_NORMALIZE;
            });
            $loc.__call__ = new Sk.builtin.func(function (self) {
              mv[METHOD_NORMALIZE]();
              return mvPy;
            });
            $loc.__str__ = new Sk.builtin.func(function (self) {
              return new Sk.builtin.str(METHOD_NORMALIZE);
            });
            $loc.__repr__ = new Sk.builtin.func(function (self) {
              return new Sk.builtin.str(METHOD_NORMALIZE);
            });
          }, METHOD_NORMALIZE, []));
        }
      }
    });
    $loc.__setattr__ = new Sk.builtin.func(function (mv, name, value) {
      mv = Sk.ffi.remapToJs(mv);
      value = Sk.ffi.remapToJs(value);
      switch (name) {
      case PROP_W: {
          mv.w = value;
        }
        break;
      case PROP_X: {
          mv.x = value;
        }
        break;
      case PROP_Y: {
          mv.y = value;
        }
        break;
      case PROP_Z: {
          mv.z = value;
        }
        break;
      case PROP_XY: {
          mv.xy = value;
        }
        break;
      case PROP_YZ: {
          mv.yz = value;
        }
        break;
      case PROP_ZX: {
          mv.zx = value;
        }
        break;
      case PROP_XYZ: {
          mv.xyz = value;
        }
        break;
      default: {
          throw new Sk.builtin.AttributeError(name + ' is not an attribute of ' + EUCLIDEAN_3);
        }
      }
    });
    $loc.__repr__ = new Sk.builtin.func(function (m) {
      m = Sk.ffi.remapToJs(m);
      var grade0 = m.w !== 0;
      var grade1 = m.x !== 0 || m.y != 0 || m.z !== 0;
      var grade2 = m.xy !== 0 || m.yz !== 0 || m.zx !== 0;
      var grade3 = m.xyz !== 0;
      if (grade0 && !grade1 && !grade2 && !grade3) {
        var args = [m.w];
        return new Sk.builtin.str(SCALAR_3 + '(' + args.join(', ') + ')');
      } else if (!grade0 && grade1 && !grade2 && !grade3) {
        var args = [
            m.x,
            m.y,
            m.z
          ];
        return new Sk.builtin.str(VECTOR_3 + '(' + args.join(', ') + ')');
      } else if (!grade0 && !grade1 && grade2 && !grade3) {
        var args = [
            m.xy,
            m.yz,
            m.zx
          ];
        return new Sk.builtin.str(BIVECTOR_3 + '(' + args.join(', ') + ')');
      } else if (!grade0 && !grade1 && !grade2 && grade3) {
        var args = [m.xyz];
        return new Sk.builtin.str(PSEUDOSCALAR_3 + '(' + args.join(', ') + ')');
      } else {
        var args = [
            m.w,
            m.x,
            m.y,
            m.z,
            m.xy,
            m.yz,
            m.zx,
            m.xyz
          ];
        return new Sk.builtin.str(EUCLIDEAN_3 + '(' + args.join(', ') + ')');
      }
    });
    $loc.__str__ = new Sk.builtin.func(function (mv) {
      mv = Sk.ffi.remapToJs(mv);
      if (isDefined(mv)) {
        return new Sk.builtin.str(stringFromCoordinates([
          mv.w,
          mv.x,
          mv.y,
          mv.z,
          mv.xy,
          mv.yz,
          mv.zx,
          mv.xyz
        ], [
          '1',
          'i',
          'j',
          'k',
          'ij',
          'jk',
          'ki',
          'I'
        ]));
      } else {
        return new Sk.builtin.str('<type \'' + EUCLIDEAN_3 + '\'>');
      }
    });
  }, EUCLIDEAN_3, []);
};
Sk.builtinFiles = {
  'files': {
    'src/lib/pythonds/trees/binheap.py': '# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005\n# \n\n# this heap takes key value pairs, we will assume that the keys are integers\nclass BinHeap:\n    def __init__(self):\n        self.heapList = [0]\n        self.currentSize = 0\n\n\n    def buildHeap(self,alist):\n        i = len(alist) // 2\n        self.currentSize = len(alist)\n        self.heapList = [0] + alist[:]\n        print(len(self.heapList), i)\n        while (i > 0):\n            print(self.heapList, i)\n            self.percDown(i)\n            i = i - 1\n        print(self.heapList,i)\n                        \n    def percDown(self,i):\n        while (i * 2) <= self.currentSize:\n            mc = self.minChild(i)\n            if self.heapList[i] > self.heapList[mc]:\n                tmp = self.heapList[i]\n                self.heapList[i] = self.heapList[mc]\n                self.heapList[mc] = tmp\n            i = mc\n                \n    def minChild(self,i):\n        if i * 2 + 1 > self.currentSize:\n            return i * 2\n        else:\n            if self.heapList[i * 2] < self.heapList[i * 2 + 1]:\n                return i * 2\n            else:\n                return i * 2 + 1\n\n    def percUp(self,i):\n        while i // 2 > 0:\n            if self.heapList[i] < self.heapList[i//2]:\n               tmp = self.heapList[i // 2]\n               self.heapList[i // 2] = self.heapList[i]\n               self.heapList[i] = tmp\n            i = i // 2\n \n    def insert(self,k):\n        self.heapList.append(k)\n        self.currentSize = self.currentSize + 1\n        self.percUp(self.currentSize)\n\n    def delMin(self):\n        retval = self.heapList[1]\n        self.heapList[1] = self.heapList[self.currentSize]\n        self.currentSize = self.currentSize - 1\n        self.heapList.pop()\n        self.percDown(1)\n        return retval\n        \n    def isEmpty(self):\n        if currentSize == 0:\n            return True\n        else:\n            return False\n',
    'src/lib/pythonds/basic/stack.py': '# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005\n# \n#stack.py\r\n\r\nclass Stack:\r\n    def __init__(self):\r\n        self.items = []\r\n\r\n    def isEmpty(self):\r\n        return self.items == []\r\n\r\n    def push(self, item):\r\n        self.items.append(item)\r\n\r\n    def pop(self):\r\n        return self.items.pop()\r\n\r\n    def peek(self):\r\n        return self.items[len(self.items)-1]\r\n\r\n    def size(self):\r\n        return len(self.items)\r\n\r\n',
    'src/lib/pythonds/trees/bst.py': '#!/bin/env python3.1\n# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005, 2010\n# \n\nclass BinarySearchTree:\n    \'\'\'\n    Author:  Brad Miller\n    Date:  1/15/2005\n    Description:  Imlement a binary search tree with the following interface\n                  functions:  \n                  __contains__(y) <==> y in x\n                  __getitem__(y) <==> x[y]\n                  __init__()\n                  __len__() <==> len(x)\n                  __setitem__(k,v) <==> x[k] = v\n                  clear()\n                  get(k)\n                  items() \n                  keys() \n                  values()\n                  put(k,v)\n                  in\n                  del <==> \n    \'\'\'\n\n    def __init__(self):\n        self.root = None\n        self.size = 0\n    \n    def put(self,key,val):\n        if self.root:\n            self._put(key,val,self.root)\n        else:\n            self.root = TreeNode(key,val)\n        self.size = self.size + 1\n\n    def _put(self,key,val,currentNode):\n        if key < currentNode.key:\n            if currentNode.hasLeftChild():\n                self._put(key,val,currentNode.leftChild)\n            else:\n                currentNode.leftChild = TreeNode(key,val,parent=currentNode)\n        else:\n            if currentNode.hasRightChild():\n                self._put(key,val,currentNode.rightChild)\n            else:\n                currentNode.rightChild = TreeNode(key,val,parent=currentNode)\n            \n    def __setitem__(self,k,v):\n        self.put(k,v)\n\n    def get(self,key):\n        if self.root:\n            res = self._get(key,self.root)\n            if res:\n                return res.payload\n            else:\n                return None\n        else:\n            return None\n        \n    def _get(self,key,currentNode):\n        if not currentNode:\n            return None\n        elif currentNode.key == key:\n            return currentNode\n        elif key < currentNode.key:\n            return self._get(key,currentNode.leftChild)\n        else:\n            return self._get(key,currentNode.rightChild)\n            \n        \n    def __getitem__(self,key):\n        res = self.get(key)\n        if res:\n            return res\n        else:\n            raise KeyError(\'Error, key not in tree\')\n            \n\n    def __contains__(self,key):\n        if self._get(key,self.root):\n            return True\n        else:\n            return False\n        \n    def length(self):\n        return self.size\n\n    def __len__(self):\n        return self.size\n\n    def __iter__(self):\n        return self.root.__iter__()\n    \n    def delete(self,key):\n        if self.size > 1:\n            nodeToRemove = self._get(key,self.root)\n            if nodeToRemove:\n                self.remove(nodeToRemove)\n                self.size = self.size-1\n            else:\n                raise KeyError(\'Error, key not in tree\')\n        elif self.size == 1 and self.root.key == key:\n            self.root = None\n            self.size = self.size - 1\n        else:\n            raise KeyError(\'Error, key not in tree\')\n\n    def __delitem__(self,key):\n        self.delete(key)\n    \n    def remove(self,currentNode):\n        if currentNode.isLeaf(): #leaf\n            if currentNode == currentNode.parent.leftChild:\n                currentNode.parent.leftChild = None\n            else:\n                currentNode.parent.rightChild = None\n        elif currentNode.hasBothChildren(): #interior\n            succ = currentNode.findSuccessor()\n            succ.spliceOut()\n            currentNode.key = succ.key\n            currentNode.payload = succ.payload\n        else: # this node has one child\n            if currentNode.hasLeftChild():\n                if currentNode.isLeftChild():\n                    currentNode.leftChild.parent = currentNode.parent\n                    currentNode.parent.leftChild = currentNode.leftChild\n                elif currentNode.isRightChild():\n                    currentNode.leftChild.parent = currentNode.parent\n                    currentNode.parent.rightChild = currentNode.leftChild\n                else:\n                    currentNode.replaceNodeData(currentNode.leftChild.key,\n                                       currentNode.leftChild.payload,\n                                       currentNode.leftChild.leftChild,\n                                       currentNode.leftChild.rightChild)\n            else:\n                if currentNode.isLeftChild():\n                    currentNode.rightChild.parent = currentNode.parent\n                    currentNode.parent.leftChild = currentNode.rightChild\n                elif currentNode.isRightChild():\n                    currentNode.rightChild.parent = currentNode.parent\n                    currentNode.parent.rightChild = currentNode.rightChild\n                else:\n                    currentNode.replaceNodeData(currentNode.rightChild.key,\n                                       currentNode.rightChild.payload,\n                                       currentNode.rightChild.leftChild,\n                                       currentNode.rightChild.rightChild)\n\n    def inorder(self):\n        self._inorder(self.root)\n\n    def _inorder(self,tree):\n        if tree != None:\n            self._inorder(tree.leftChild)\n            print(tree.key)\n            self._inorder(tree.rightChild)\n\n    def postorder(self):\n        self._postorder(self.root)\n\n    def _postorder(self, tree):\n        if tree:\n            self._postorder(tree.rightChild)\n            self._postorder(tree.leftChild)\n            print(tree.key)            \n\n    def preorder(self):\n        self._preorder(self,self.root)\n\n    def _preorder(self,tree):\n        if tree:\n            print(tree.key)            \n            self._preorder(tree.leftChild)\n            self._preorder(tree.rightChild)\n\n                \nclass TreeNode:\n    def __init__(self,key,val,left=None,right=None,parent=None):\n        self.key = key\n        self.payload = val\n        self.leftChild = left\n        self.rightChild = right\n        self.parent = parent\n        self.balanceFactor = 0\n        \n    def hasLeftChild(self):\n        return self.leftChild\n\n    def hasRightChild(self):\n        return self.rightChild\n    \n    def isLeftChild(self):\n        return self.parent and self.parent.leftChild == self\n\n    def isRightChild(self):\n        return self.parent and self.parent.rightChild == self\n\n    def isRoot(self):\n        return not self.parent\n\n    def isLeaf(self):\n        return not (self.rightChild or self.leftChild)\n\n    def hasAnyChildren(self):\n        return self.rightChild or self.leftChild\n\n    def hasBothChildren(self):\n        return self.rightChild and self.leftChild\n    \n    def replaceNodeData(self,key,value,lc,rc):\n        self.key = key\n        self.payload = value\n        self.leftChild = lc\n        self.rightChild = rc\n        if self.hasLeftChild():\n            self.leftChild.parent = self\n        if self.hasRightChild():\n            self.rightChild.parent = self\n        \n    def findSuccessor(self):\n        succ = None\n        if self.hasRightChild():\n            succ = self.rightChild.findMin()\n        else:\n            if self.parent:\n                if self.isLeftChild():\n                    succ = self.parent\n                else:\n                    self.parent.rightChild = None\n                    succ = self.parent.findSuccessor()\n                    self.parent.rightChild = self\n        return succ\n\n\n    def spliceOut(self):\n        if self.isLeaf():\n            if self.isLeftChild():\n                self.parent.leftChild = None\n            else:\n                self.parent.rightChild = None\n        elif self.hasAnyChildren():\n            if self.hasLeftChild():\n                if self.isLeftChild():\n                    self.parent.leftChild = self.leftChild\n                else:\n                    self.parent.rightChild = self.leftChild\n                self.leftChild.parent = self.parent\n            else:\n                if self.isLeftChild():\n                    self.parent.leftChild = self.rightChild\n                else:\n                    self.parent.rightChild = self.rightChild\n                self.rightChild.parent = self.parent\n\n    def findMin(self):\n        current = self\n        while current.hasLeftChild():\n            current = current.leftChild\n        return current\n\n    def __iter__(self):\n        """The standard inorder traversal of a binary tree."""\n        if self:\n            if self.hasLeftChild():\n                for elem in self.leftChild:\n                    yield elem\n            yield self.key\n            if self.hasRightChild():\n                for elem in self.rightChild:\n                    yield elem\n\n            \n',
    'src/lib/time/__init__.js': '\n/*\n\tBarebones implementation of the Python time package.\n\n\tFor now, only the time() function is implemented.\n*/\n \nvar $builtinmodule = function(name)\n{\n    var mod = {};\n\n    mod.time = new Sk.builtin.func(function() {\n\t  return Sk.builtin.assk$(new Date().getTime() / 1000, undefined);\n    });\n\n    return mod;\n}\n',
    'src/lib/image/__init__.js': 'var ImageMod; // the single identifier needed in the global scope\n\nif (! ImageMod) {\n    ImageMod = { };\n    ImageMod.canvasLib = [];\n}\n\n//  todo create an empty image by reading image data from a blank canvas of the appropriate size\n\nvar $builtinmodule = function(name) {\n    var mod = {};\n\n    var image = function($gbl, $loc) {\n        $loc.__init__ = new Sk.builtin.func(function(self,imageId) {\n            self.image = document.getElementById(imageId.v);\n            if (self.image == null) {\n                throw "There is no image on this page named: " + imageId.v;\n            }\n            self.width = self.image.width;\n            self.height = self.image.height;\n            self.canvas = document.createElement("canvas");\n            self.canvas.height = self.height;\n            self.canvas.width = self.width;\n            self.ctx = self.canvas.getContext("2d");\n            self.ctx.drawImage(self.image,0,0)\n            self.imagedata = self.ctx.getImageData(0,0,self.width,self.height);\n        });\n\n        $loc.getPixel = new Sk.builtin.func(function(self,x,y) {\n\t\t\tx = Sk.builtin.asnum$(x);\n\t\t\ty = Sk.builtin.asnum$(y);\n            var index = (y*4)*self.width+(x*4);\n            var red = self.imagedata.data[index]\n            var green = self.imagedata.data[index+1]\n            var blue = self.imagedata.data[index+2]\n            return Sk.misceval.callsim(mod.Pixel,red,green,blue);\n        });\n\n        $loc.setPixel = new Sk.builtin.func(function(self, x, y, pix) {\n\t\t\tx = Sk.builtin.asnum$(x);\n\t\t\ty = Sk.builtin.asnum$(y);\n            var index = (y*4)*self.width+(x*4);\n            self.imagedata.data[index] = Sk.misceval.callsim(pix.getRed,pix);\n            self.imagedata.data[index+1] = Sk.misceval.callsim(pix.getGreen,pix);\n            self.imagedata.data[index+2] = Sk.misceval.callsim(pix.getBlue,pix);\n            self.imagedata.data[index+3] = 255;\n        });\n\n        $loc.getHeight = new Sk.builtin.func(function(self) {\n            return self.image.height;\n        });\n\n        $loc.getWidth = new Sk.builtin.func(function(self,titlestring) {\n            return self.image.width;\n        });\n\n        $loc.draw = new Sk.builtin.func(function(self,win,ulx,uly) {\n\t\t\twin = Sk.builtin.asnum$(win);\n\t\t\tulx = Sk.builtin.asnum$(ulx);\n\t\t\tuly = Sk.builtin.asnum$(uly);\n            var can = Sk.misceval.callsim(win.getWin,win);\n            var ctx = can.getContext("2d");\n            //ctx.putImageData(self.imagedata,0,0,0,0,self.imagedata.width,self.imagedata.height);\n            if (! ulx) {\n                ulx = 0;\n                uly = 0;\n            }\n            ctx.putImageData(self.imagedata,ulx,uly);\n        });\n\n        // toList\n\n    }\n\n    mod.Image = Sk.misceval.buildClass(mod, image, \'Image\', []);\n\n    var eImage = function($gbl, $loc) {\n        $loc.__init__ = new Sk.builtin.func(function(self,width,height) {\n            self.width = Sk.builtin.asnum$(width);\n            self.height = Sk.builtin.asnum$(height);\n            self.canvas = document.createElement("canvas");\n            self.ctx = self.canvas.getContext(\'2d\');\n            self.canvas.height = self.height;\n            self.canvas.width = self.width;\n            self.imagedata = self.ctx.getImageData(0,0,self.width,self.height);\n        });\n\n    }\n\n    mod.EmptyImage = Sk.misceval.buildClass(mod, eImage, \'EmptyImage\', [mod.Image]);\n\n    // create a ListImage object\n\n    \n    var pixel = function($gbl, $loc) {\n        $loc.__init__ = new Sk.builtin.func(function(self,r,g,b) {\n            self.red = Sk.builtin.asnum$(r);\n            self.green = Sk.builtin.asnum$(g);\n            self.blue = Sk.builtin.asnum$(b);\n        });\n\n        $loc.getRed = new Sk.builtin.func(function(self) {\n           return self.red;\n        });\n\n        $loc.getGreen = new Sk.builtin.func(function(self) {\n           return self.green;\n        });\n\n        $loc.getBlue = new Sk.builtin.func(function(self) {\n           return self.blue;\n        });\n\n        $loc.setRed = new Sk.builtin.func(function(self,r) {\n           self.red = Sk.builtin.asnum$(r);\n        });\n\n        $loc.setGreen = new Sk.builtin.func(function(self,g) {\n           self.green = Sk.builtin.asnum$(g);\n        });\n\n        $loc.setBlue = new Sk.builtin.func(function(self,b) {\n           self.blue = Sk.builtin.asnum$(b);\n        });\n\n        $loc.__getitem__ = new Sk.builtin.func(function(self,k) {\n\t\t   k = Sk.builtin.asnum$(k);\n           if(k == 0) {\n               return self.red;\n           } else if (k == 1) {\n               return self.green;\n           } else if (k == 2) {\n               return self.blue;\n           }\n        });\n\n        $loc.__str__ = new Sk.builtin.func(function(self) {\n            return "[" + self.red + "," + self.green + "," + self.blue + "]"\n        });\n        \n        //getColorTuple\n        $loc.getColorTuple = new Sk.builtin.func(function(self,x,y) {\n\n        });\n\n        //setRange -- change from 0..255 to 0.0 .. 1.0\n        $loc.setRange = new Sk.builtin.func(function(self,mx) {\n            self.max = Sk.builtin.asnum$(mx);\n        });\n\n    }\n    mod.Pixel = Sk.misceval.buildClass(mod, pixel, \'Pixel\', []);\n\n\n\n    var screen = function($gbl, $loc) {\n        $loc.__init__ = new Sk.builtin.func(function(self,width,height) {\n            var currentCanvas = ImageMod.canvasLib[Sk.canvas];\n            if (currentCanvas === undefined) {\n                self.theScreen = document.getElementById(Sk.canvas);\n                if (width !== undefined) {\n                    self.theScreen.height = height;\n                    self.theScreen.width = width;\n                }\n\n                ImageMod.canvasLib[Sk.canvas] = self.theScreen;\n            } else {\n                self.theScreen = currentCanvas;\n                self.theScreen.height = self.theScreen.height;\n            }\n            self.theScreen.style.display = "block";\n        });\n\n        $loc.getWin = new Sk.builtin.func(function(self) {\n           return self.theScreen;\n        });\n\n        // exitonclick\n        $loc.exitonclick = new Sk.builtin.func(function(self) {\n            var canvas_id = self.theScreen.id;\n            self.theScreen.onclick = function() {\n                document.getElementById(canvas_id).style.display = \'none\';\n                document.getElementById(canvas_id).onclick = null;\n                delete ImageMod.canvasLib[canvas_id];\n            }\n\n        });\n        //getMouse\n    }\n\n    mod.ImageWin = Sk.misceval.buildClass(mod, screen, \'ImageWin\', []);\n\n    return mod\n}\n',
    'src/lib/browser/__init__.js': '/*\n * browser Python module\n *\n * Exposes the window and document variables.\n */\nvar $builtinmodule = function(name) {\n\n  var mod = {};\n\n  var EVENT = \'Event\';\n  var NODE  = \'Node\';\n\n  mod[EVENT] = Sk.builtin.buildEventClass(mod);\n\n  mod[NODE]  = Sk.builtin.buildNodeClass(mod);\n\n  mod[\'window\'] = Sk.misceval.callsim(Sk.builtin.buildWindowClass(mod));\n\n  mod[\'document\'] = Sk.misceval.callsim(Sk.builtin.buildDocumentClass(mod));\n\n  return mod;\n}\n',
    'src/lib/pythonds/basic/__init__.py': '\n#__all__ = ["stack"]\n\n\n#from .stack import Stack\n#from .queue import Queue\n\n\n\n',
    'src/lib/sprite/__init__.js': '//\n//\n// Sprite Graphics Module for DaVinci.\n//\n// Based on the turtle module by Brad Miller.\n//\n// Dependencies:\n//   jQuery\n//\n//\n\nvar SpriteGraphics; // the single identifier needed in the global scope\n\nif (! SpriteGraphics) {\n  SpriteGraphics = {};\n}\n\n\n(function () {\n\n  var Degree2Rad = Math.PI / 180.0; // conversion factor for degrees to radians.\n  var Rad2Degree = 180.0 / Math.PI; // conversion factor for radians to degrees.\n\n  function SpriteCanvas(options) {\n    this.canvasID = SpriteGraphics.defaults.canvasID;\n    if (options.canvasID) {\n      this.canvasID = options.canvasID;\n    }\n\n    this.canvas = document.getElementById(this.canvasID);\n    this.context = this.canvas.getContext(\'2d\');\n    $(this.canvas).fadeIn();\n\n    this.lineScale = 1.0;\n    this.xptscale = 1.0;\n    this.yptscale = 1.0;\n\n    this.llx = -this.canvas.width / 2;\n    this.lly = -this.canvas.height / 2;\n    this.urx = this.canvas.width / 2;\n    this.ury = this.canvas.height / 2;\n    this.setup(this.canvas.width,this.canvas.height);\n    SpriteGraphics.canvasInit = true;\n    this.tlist = []\n\n    this.timeFactor = 5;\n    if (SpriteGraphics.defaults.animate) {\n      this.delay = 5 * this.timeFactor;\n    }\n    else {\n      this.delay = 0;\n    }\n    this.segmentLength = 10;\n    this.renderCounter = 1;\n    this.clearPoint = 0;\n    SpriteGraphics.canvasLib[this.canvasID] = this;\n    //  This can be set to false AFTER the program completes to turn off the fade out on the canvas as a result of exitonclick\n    Sk.tg.fadeOnExit = true;\n  }\n\n  SpriteCanvas.prototype.setup = function(width, height) {\n    this.canvas.width = width;\n    this.canvas.height = height;\n    this.lineScale = 1.0;\n    this.xptscale = 1.0;\n    this.yptscale = 1.0;\n\n    this.llx = -this.canvas.width / 2;\n    this.lly = -this.canvas.height / 2;\n    this.urx = this.canvas.width / 2;\n    this.ury = this.canvas.height / 2;\n    this.renderCounter = 1;\n    this.clearPoint = 0;\n    this.timeFactor = 5;\n    if (SpriteGraphics.defaults.animate) {\n      this.delay = 5 * this.timeFactor;\n    }\n    else {\n      this.delay = 0;\n    }\n\n    if (SpriteGraphics.canvasInit == false) {\n      this.context.save();\n      this.context.translate(this.canvas.width / 2, this.canvas.height / 2); // move 0,0 to center.\n      this.context.scale(1, -1); // scaling like this flips the y axis the right way.\n      SpriteGraphics.canvasInit = true;\n      SpriteGraphics.eventCount = 0;\n      SpriteGraphics.renderClock = 0;\n      SpriteGraphics.renderTime = 0;\n    }\n    else {\n      this.context.restore();\n      this.context.translate(this.canvas.width / 2, this.canvas.height / 2); // move 0,0 to center.\n      this.context.scale(1, -1); // scaling like this flips the y axis the right way.\n      this.context.clearRect(-this.canvas.width / 2, -this.canvas.height / 2, this.canvas.width, this.canvas.height);\n    }\n  }\n\n  SpriteCanvas.prototype.addToCanvas = function(t) {\n    this.tlist.push(t);\n  }\n\n  SpriteCanvas.prototype.onCanvas = function(t) {\n    return (this.tlist.indexOf(t) >= 0);\n  }\n\n  SpriteCanvas.prototype.isAnimating = function() {\n    return (this.tlist.length > 0);\n  }\n\n  SpriteCanvas.prototype.startAnimating = function(t) {\n    if (! this.isAnimating()) {\n      this.intervalId = setTimeout(render, this.delay);\n    }\n    // Added in case startAnimating is called after it\'s already been added.\n    if (!this.onCanvas(t)) {\n      this.addToCanvas(t);\n    }\n    Sk.isSpriteProgram = true;\n  }\n\n  SpriteCanvas.prototype.doneAnimating = function(t) {\n    this.tlist.splice(0,this.tlist.length);\n    clearTimeout(this.intervalId);\n    $(Sk.runButton).removeAttr(\'disabled\');\n  }\n\n  SpriteCanvas.prototype.cancelAnimation = function() {\n    if (this.intervalId) {\n      clearTimeout(this.intervalId);\n    }\n\n    for (var t in this.tlist) {\n      this.tlist[t].aCount = this.tlist[t].drawingEvents.length - 1;\n    }\n    render();\n  }\n\n  SpriteCanvas.prototype.setSpeedDelay = function(s) {\n    var df = 10 - (s % 11) + 1;\n    this.delay = df * this.timeFactor;\n  }\n\n  SpriteCanvas.prototype.setDelay = function(d) {\n    this.delay = d;\n  }\n\n  SpriteCanvas.prototype.getDelay = function(s) {\n    return this.delay;\n  }\n\n  SpriteCanvas.prototype.setCounter = function(s) {\n    if (!s || s <= 0) {\n      s = 1;\n    }\n    this.renderCounter = s;\n  }\n\n  SpriteCanvas.prototype.getCounter = function() {\n    return this.renderCounter;\n  }\n\n  SpriteCanvas.prototype.setworldcoordinates = function(llx, lly, urx, ury) {\n    this.context.restore();\n    this.context.scale(this.canvas.width / (urx - llx), -this.canvas.height / (ury - lly));\n    if (lly == 0) {\n      this.context.translate(-llx, lly - (ury - lly));\n    }\n    else if (lly > 0) {\n      this.context.translate(-llx, -lly * 2);\n    }\n    else {\n      this.context.translate(-llx, -ury);\n    }\n\n    var xlinescale = (urx - llx) / this.canvas.width;\n    var ylinescale = (ury - lly) / this.canvas.height;\n    this.xptscale = xlinescale;\n    this.yptscale = ylinescale;\n    this.lineScale = Math.min(xlinescale,ylinescale);\n    this.context.save();\n\n    this.llx = llx;\n    this.lly = lly;\n    this.urx = urx;\n    this.ury = ury;\n\n  }\n\n  SpriteCanvas.prototype.window_width = function() {\n    return this.canvas.width;\n  }\n\n  SpriteCanvas.prototype.window_height = function() {\n    return this.canvas.height;\n  }\n\n  SpriteCanvas.prototype.bgcolor = function(c) {\n    this.background_color = c;\n    $(this.canvas).css("background-color",c.v);\n  }\n\n  SpriteCanvas.prototype.setSegmentLength = function(s) {\n    this.segmentLength = s;\n  }\n\n  SpriteCanvas.prototype.getSegmentLength = function() {\n    return this.segmentLength;\n  }\n\n  // todo: if animating, this should be deferred until the proper time\n  SpriteCanvas.prototype.exitonclick = function () {\n    var canvas_id = this.canvasID;\n    var theCanvas = this;\n    $(this.canvas).click(function() {\n      if (! theCanvas.isAnimating()) {\n        if (Sk.tg.fadeOnExit) {\n         $("#"+canvas_id).hide();\n       }\n       $("#"+canvas_id).unbind(\'click\');\n       Sk.tg.canvasInit = false;\n       delete Sk.tg.canvasLib[canvas_id];\n     }\n   });\n  }\n\n  SpriteCanvas.prototype.sprites = function() {\n    return SpriteGraphics.spriteList;\n  }\n\n /**\n  * New version NOT attached to a sprite (as per real sprite)\n  */\n  SpriteCanvas.prototype.tracer = function(t, d) {\n    this.setCounter(t);\n    if (t == 0) {\n      for (var i in this.spriteList) {\n        this.spriteList[i].animate = false;\n      }\n      this.cancelAnimation();\n    }\n    if (d !== undefined) {\n      this.setDelay(d);\n    }\n  }\n\n  // check if all sprites are done\n  allDone = function() {\n    var allDone = true;\n    for (var tix in SpriteGraphics.spriteList) {\n      var theT = SpriteGraphics.spriteList[tix];\n      allDone = allDone && (theT.aCount >= theT.drawingEvents.length);\n    }\n    return allDone;\n  }\n\n  //\n  //  This is the function that provides the animation\n  //\n  render = function () {\n    var context = document.getElementById(SpriteGraphics.defaults.canvasID).getContext(\'2d\');\n    with (context) {\n      with (SpriteGraphics.canvasLib[SpriteGraphics.defaults.canvasID]) {\n        clearRect(llx, lly, (urx - llx), (ury - lly));\n      }\n      var incr = SpriteGraphics.canvasLib[SpriteGraphics.defaults.canvasID].getCounter();\n      var lastCanvas = null;\n\n      SpriteGraphics.renderClock += incr;\n\n      for (var tix in SpriteGraphics.spriteList) {\n        var t = SpriteGraphics.spriteList[tix]\n        lastCanvas = t.spriteCanvas \n        if (t.aCount >= t.drawingEvents.length) {\n          t.aCount = t.drawingEvents.length - 1;\n        }\n        moveTo(0, 0);\n        var currentPos = new Vector(0,0,0);\n        var currentHead = new Vector(1,0,0);\n        lineWidth = t.get_pen_width();\n        lineCap = \'round\';\n        lineJoin = \'round\';\n        strokeStyle = \'black\';\n        var filling = false;\n        if (isNaN(t.spriteCanvas.delay)) {\n          t.spriteCanvas.delay = 0\n        }\n        for (var i = t.clearPoint; (i <= t.aCount || t.spriteCanvas.delay == 0) && i < t.drawingEvents.length; i++) {\n          if (i > t.aCount) {\n            // If se jump past aCount, jump it ahead\n            t.aCount = i\n          }\n          var oper = t.drawingEvents[i];\n          var ts = oper[oper.length-1];\n          if (ts <= SpriteGraphics.renderClock || t.spriteCanvas.delay == 0) {\n            if (ts > SpriteGraphics.renderClock) {\n              // If we go past the render clock, jump it ahead\n              SpriteGraphics.renderClock = ts\n            }\n            if (oper[0] == "LT") {  //  line to\n              if (! filling) {\n                beginPath();\n                moveTo(oper[1], oper[2]);\n              }\n              lineTo(oper[3], oper[4]);\n              strokeStyle = oper[5];\n              stroke();\n              currentPos = new Vector(oper[3],oper[4],0);\n              if (! filling)\n                closePath();\n            }\n            else if (oper[0] == "MT") {  // move to\n              moveTo(oper[3], oper[4]);\n              currentPos = new Vector(oper[3],oper[4],0);\n            }\n            else if (oper[0] == "BF") {  // begin fill\n              beginPath();\n              moveTo(oper[1], oper[2]);\n              filling = true;\n            }\n            else if (oper[0] == "EF") {  // end fill\n              fillStyle = oper[3];\n              stroke();\n              fill();\n              closePath();\n              filling = false;\n            }\n            else if (oper[0] == "FC") {  // fill color\n              fillStyle = oper[1];\n            }\n            else if (oper[0] == "TC") {  // sprite color\n              strokeStyle = oper[1];\n            }\n            else if (oper[0] == "PW") {  // Pen width\n              lineWidth = oper[1];\n            }\n            else if (oper[0] == "DT") {  // Dot\n              var col = fillStyle;\n              fillStyle = oper[2];\n              var size = oper[1];\n              fillRect(oper[3] - size / 2, oper[4] - size / 2, size, size);\n              fillStyle = col;\n            }\n            else if (oper[0] == "CI") {  // Circle\n              if (!filling)\n                beginPath();\n              arc(oper[1], oper[2], oper[3], oper[4], oper[5], oper[6]);\n              currentPos = new Vector(oper[1]+Math.cos(oper[5])*oper[3],\n                oper[2]+Math.sin(oper[5])*oper[3],0);\n              stroke();\n              if (! filling) {\n                closePath();\n              }\n            }\n            else if (oper[0] == "WT") { // write\n              if (font)\n                font = oper[2];\n              scale(1, -1);\n              fillText(oper[1], oper[3], -oper[4]);\n              scale(1, -1);\n            } else if (oper[0] == "ST") {  // stamp\n              t.drawSprite(oper[3], new Vector(oper[1], oper[2], 0));\n            } else if (oper[0] == "HT") { // hide sprite\n              t.visible = false;\n            } else if (oper[0] == "SH") { // show sprite\n              t.visible = true;\n            } else if (oper[0] == "TT") {\n              currentHead = oper[1];\n            } else if (oper[0] == "CL") { // RNL clear\n              clear_canvas(t.canvasID);\n              t.clearPoint = i; // Different from reset that calls clear because it leaves the sprites where they are\n            } else if (oper[0] == "DL") { // RNL delay\n              var df = oper[1];\n              t.spriteCanvas.delay = df\n            } else if (oper[0] == "SC") { // RNL speed change\n              var s = oper[1]\n              if (s < 0)\n                s = 0\n              if (s > 10)\n                s = 10\n              var df = (10 - (s % 11) + 1) * t.spriteCanvas.timeFactor  //  10\n              if (s == 0) {\n                df = 0\n              }\n              // t.spriteCanvas.intervalId = clearInterval(t.spriteCanvas.intervalId);\n              t.spriteCanvas.delay = df;\n              // t.spriteCanvas.intervalId = setInterval(render, t.spriteCanvas.delay)\n              if (oper[2]) {\n                t.spriteCanvas.setSegmentLength(oper[2]);\n              }\n            } else if (oper[0] == "NO") {\n              // RNL no op\n            } else {\n            } // end of oper[0] test\n          } // end of if ts < render clock\n        } // end of for\n        t.aCount += incr;\n        if (t.visible) {\n          // draw the sprite\n          t.drawSprite(currentHead.toAngle(), currentPos); // just use currentHead\n        }\n      }\n      // if (t.aCount >= t.drawingEvents.length) {\n      if (SpriteGraphics.renderClock > SpriteGraphics.eventCount ){ // && allDone() ){\n        // t.spriteCanvas.doneAnimating(t);\n        if (lastCanvas) lastCanvas.doneAnimating(t);\n      }\n      else {\n        // t.spriteCanvas.intervalId = setTimeout(render, t.spriteCanvas.delay)\n        if (lastCanvas) {\n          lastCanvas.intervalId = setTimeout(render, lastCanvas.delay)\n        }\n      }\n    }\n  }\n\n  // Constructor for Sprite objects\n  function Sprite() {\n    if (arguments.length >= 1) {\n      this.initialize(arguments[0]);\n    }\n    else {\n      this.initialize();\n    }\n    SpriteGraphics.spriteList.push(this);\n  }\n\n  Sprite.prototype.go_home = function () {\n    // Put sprite in initial state\n    // sprite is headed to the right\n    // with position 0,0,0 in the middle of the canvas.\n    // x grows to the right\n    // y grows towards the top of the canvas\n    with (this) {\n      position = home;\n      context.moveTo(home[0], home[1]);\n      heading = new Vector([1.0, 0.0, 0.0]); // to the right; in sprite space x+ direction\n      normal = new Vector([0.0, 0.0, -1.0]); // in z- direction\n    }\n  };\n\n  Sprite.prototype.initialize = function () {\n    // Initialize the sprite.\n    var options = { };\n\n    if (arguments.length >= 1) {\n      options = arguments[0];\n    }\n\n    this.canvasID = SpriteGraphics.defaults.canvasID;\n    if (options.canvasID) {\n      this.canvasID = options.canvasID;\n    }\n    this.context = document.getElementById(this.canvasID).getContext(\'2d\');\n\n    this.animate = SpriteGraphics.defaults.animate;\n\n    with (this.context) {\n      if (SpriteGraphics.canvasInit == false) {\n        save();\n        translate(canvas.width / 2, canvas.height / 2); // move 0,0 to center.\n        scale(1, -1); // scaling like this flips the y axis the right way.\n        if (! SpriteGraphics.canvasLib[this.canvasID]) {\n          SpriteGraphics.canvasLib[this.canvasID] = new SpriteCanvas(options);\n        }\n        SpriteGraphics.canvasInit = true;\n      }\n      else {\n        clear_canvas(this.canvasID);\n      }\n\n      this.spriteCanvas = SpriteGraphics.canvasLib[this.canvasID];\n      this.home = new Vector([0.0, 0.0, 0.0]);\n      this.visible = true;\n      this.shapeStore = {};\n      this.shapeStore[\'turtle\'] = turtleShapePoints();\n      this.shapeStore[\'arrow\'] = defaultShapePoints();\n      this.shapeStore[\'circle\'] = circleShapePoints();\n      this.shapeStore[\'classic\'] = classicShapePoints();\n      this.currentShape = \'classic\';\n      this.drawingEvents = [];\n\n      this.filling = false;\n      this.pen = true;\n      this.penStyle = \'black\';\n      this.penWidth = 2;\n      this.fillStyle = \'black\';\n      this.position = [ ];\n      this.heading = [ ];\n      this.normal = [ ];\n      this.go_home();\n      this.aCount = 0;\n      this.clearPoint = 0;\n    }\n  }\n\n  function turtleShapePoints() {\n    var pl = [\n    [0,16],\n    [-2,14],\n    [-1,10],\n    [-4,7],\n    [-7,9],\n    [-9,8],\n    [-6,5],\n    [-7,1],\n    [-5,-3],\n    [-8,-6],\n    [-6,-8],\n    [-4,-5],\n    [0,-7],\n    [4,-5],\n    [6,-8],\n    [8,-6],\n    [5,-3],\n    [7,1],\n    [6,5],\n    [9,8],\n    [7,9],\n    [4,7],\n    [1,10],\n    [2,14]\n    ];\n    res = [];\n    for (p in pl) {\n      res.push(new Vector(pl[p]));\n    }\n    return res;\n  }\n\n  function defaultShapePoints() {\n    var pl = [\n    [-10,0],\n    [10,0],\n    [0,10]\n    ];\n    res = [];\n    for (p in pl) {\n      res.push(new Vector(pl[p]));\n    }\n    return res;\n  }\n\n  function circleShapePoints() {\n    var pl = [\n    [10,0],\n    [9.51,3.09],\n    [8.09,5.88],\n    [5.88,8.09],\n    [3.09,9.51],\n    [0,10],\n    [-3.09,9.51],\n    [-5.88,8.09],\n    [-8.09,5.88],\n    [-9.51,3.09],\n    [-10,0],\n    [-9.51,-3.09],\n    [-8.09,-5.88],\n    [-5.88,-8.09],\n    [-3.09,-9.51],\n    [-0.00,-10.00],\n    [3.09,-9.51],\n    [5.88,-8.09],\n    [8.09,-5.88],\n    [9.51,-3.09]\n    ];\n    res = [];\n    for (p in pl) {\n      res.push(new Vector(pl[p]));\n    }\n    return res;\n  }\n\n  function classicShapePoints() {\n    var pl = [\n    [0,0],\n    [-5,-9],\n    [0,-7],\n    [5,-9]\n    ];\n    res = [];\n    for (p in pl) {\n      res.push(new Vector(pl[p]));\n    }\n    return res;\n  }\n\n  Sprite.prototype.clean = function () {\n    // Clean the canvas\n    // Optional second argument is color\n    with (this) {\n      if (arguments.length >= 1) {\n        clear_canvas(canvasID, arguments[0]);\n      }\n      else {\n        clear_canvas(canvasID);\n      }\n      initialize();\n    }\n  }\n\n  Sprite.prototype.addDrawingEvent = function(eventList) {\n    SpriteGraphics.eventCount += 1;\n    eventList.push(SpriteGraphics.eventCount);\n    this.drawingEvents.push(eventList);\n  }\n\n  //  \n  //  Drawing Functions\n  //\n\n    // break a line into segments\n    // sp:  Vector of starting position\n    // ep:  Vector of ending position\n    // sl:  int length of segments\n    segmentLine = function(sp, ep, sL, pen) {\n      var head = ep.sub(sp).normalize();\n      var numSegs = Math.floor(ep.sub(sp).len() / sL);\n      var res = [];\n      var oldp = sp;\n      var newp;\n      var op = ""\n      if (pen)\n        op = "LT"\n      else\n        op = "MT"\n      for (var i = 0; i < numSegs; i++) {\n        newp = oldp.linear(1, sL, head);\n        res.push([op,oldp[0],oldp[1],newp[0],newp[1]]);\n        oldp = newp;\n      }\n      if (! ((oldp[0] == ep[0]) && (oldp[1] == ep[1])))\n        res.push([op, oldp[0], oldp[1], ep[0], ep[1]]);\n      return res;\n    }\n\n    Sprite.prototype.draw_line = function(newposition) {\n      with (this) {\n        with (context) {\n          if (! animate) {\n            if (! filling) {\n              beginPath();\n              moveTo(position[0], position[1]);\n            }\n            lineCap = \'round\';\n            lineJoin = \'round\';\n            lineWidth = get_pen_width();\n            strokeStyle = penStyle;\n            lineTo(newposition[0], newposition[1]);\n            stroke();\n            if (! filling)\n              closePath();\n          } else {\n            var r = segmentLine(position, newposition, spriteCanvas.getSegmentLength(), pen);\n            for (var s in r) {\n              r[s].push(penStyle);\n              addDrawingEvent(r[s]);\n            }\n            if (! spriteCanvas.isAnimating()) {\n              spriteCanvas.startAnimating(this);\n            } else {\n              if (! spriteCanvas.onCanvas(this))\n                spriteCanvas.addToCanvas(this);\n            }\n          }\n        }\n      }\n    }\n\n    Sprite.prototype.forward = function (d) {\n      with (this) {\n        var newposition = position.linear(1, d, heading);\n        goto(newposition);\n      }\n    }\n\n    Sprite.prototype.backward = function(d) {\n      this.forward(-d);\n    }\n\n    // This is an internal function that sets the position without doing any drawing\n    Sprite.prototype.teleport_to = function(nx, ny) {\n      if (nx instanceof Vector)\n        var newposition = nx;\n      else\n        var newposition = new Vector([nx,ny,0]);\n      this.context.moveTo(newposition[0], newposition[1]);\n      this.position = newposition;\n    }\n\n    Sprite.prototype.goto = function(nx, ny) {\n      if (nx instanceof Vector)\n        var newposition = nx;\n      else\n        var newposition = new Vector([nx,ny,0]);\n      with (this) {\n        if (pen) {\n          draw_line(newposition);\n        } else {\n          if (! animate) {\n            context.moveTo(newposition[0], newposition[1]);\n          } else {\n            var r = segmentLine(position, newposition, spriteCanvas.getSegmentLength(), pen);\n            for (var s in r)\n              addDrawingEvent(r[s]);\n            if (! spriteCanvas.isAnimating()) {\n              spriteCanvas.startAnimating(this);\n            } else {\n              if (! spriteCanvas.onCanvas(this))\n                spriteCanvas.addToCanvas(this);\n            }\n          }\n        }\n        position = newposition;\n      }\n    }\n\n    Sprite.prototype.delay = function(d) {\n      if (d != null) {\n        if (d < 0) {\n          d = -d;\n        }\n        if (!this.animate) {\n          this.spriteCanvas.setDelay(d);\n        } \n        else {\n          this.spriteCanvas.setDelay(d);\n          this.addDrawingEvent(["DL", d]);\n          this.addDrawingEvent(["NO"]);\n        }\n      }\n      return this.spriteCanvas.getDelay();\n    }\n\n    Sprite.prototype.speed = function(s,t) {\n      if (s > 0 && !this.animate) {\n        this.animate = true;\n        this.spriteCanvas.setSpeedDelay(s);\n      }\n      else if (s == 0 && !this.animate) {\n        this.spriteCanvas.setSpeedDelay(s);\n      }\n      else {\n        // this.animate = false;\n        // this.spriteCanvas.cancelAnimation();\n        this.addDrawingEvent(["SC", s, t]);\n        this.addDrawingEvent(["NO"]);\n      }\n      if (t) {\n        this.spriteCanvas.setSegmentLength(t);\n        // set the number of units to divide a segment into\n      }\n      else {\n        this.spriteCanvas.setSegmentLength(10);\n      }\n    }\n\n    Sprite.prototype.tracer = function(t, d) {\n      this.spriteCanvas.setCounter(t);\n      if (t == 0) {\n       this.animate=false;\n       this.spriteCanvas.cancelAnimation();\n     }\n     if (d !== undefined)\n       this.spriteCanvas.setDelay(d);\n   }\n\n   Sprite.prototype.getRenderCounter = function() {\n    return this.spriteCanvas.getCounter();\n  }\n\n  Sprite.prototype.turn = function (phi) {\n    with (this) {\n      var alpha = phi * Degree2Rad;\n      var left = normal.cross(heading);\n      var newheading = heading.rotateNormal(left, normal, alpha);\n      heading = newheading;\n\n      if (animate) {\n        addDrawingEvent(["TT",heading]);\n      }\n    }\n  }\n\n  Sprite.prototype.right = Sprite.prototype.turn;\n\n  Sprite.prototype.left = function(phi) {\n    this.turn(-phi);\n  }\n\n  Sprite.prototype.get_heading = function () {\n    if (SpriteGraphics.defaults.degrees)\n      return this.heading.toAngle()\n    else\n      return this.heading\n  }\n\n  Sprite.prototype.get_position = function () {\n    return this.position;\n  }\n\n  Sprite.prototype.getx = function () {\n    return this.position[0];\n  }\n\n  Sprite.prototype.gety = function () {\n    return this.position[1];\n  }\n\n  Sprite.prototype.set_heading = function(newhead) {\n    if ((typeof(newhead)).toLowerCase() === \'number\') {\n      this.heading = Vector.angle2vec(newhead);\n    } else {\n      this.heading = newhead;\n    }\n  }\n\n  Sprite.prototype.towards = function(to, y) {\n    // set heading vector to point towards another point.\n    if ((typeof(to)).toLowerCase() === \'number\')\n      to = new Vector(to, y, 0);\n    else if (! (to instanceof Vector)) {\n      to = new Vector(to);\n    }\n    var res = to.sub(this.position);\n    res = res.normalize();\n    if (SpriteGraphics.defaults.degrees)\n      return res.toAngle();\n    else\n      return res;\n  }\n\n  Sprite.prototype.distance = function(to, y) {\n    if ((typeof(to)).toLowerCase() === \'number\')\n      to = new Vector(to, y, 0);\n    return this.position.sub(new Vector(to)).len();\n  }\n\n  Sprite.prototype.dot = function() {\n    var size = 2;\n    if (arguments.length >= 1) size = arguments[0];\n    size = size * this.spriteCanvas.lineScale;\n    with (this) {\n      with (context) {\n        var color = penStyle;\n        var nc = arguments[1] || color;\n        if (! animate) {\n          fillStyle = nc;\n          fillRect(position[0] - size / 2, position[1] - size / 2, size, size);\n          fillStyle = color;\n        } else {\n          addDrawingEvent(["DT", size, nc, position[0], position[1]]);\n        }\n      }\n    }\n  }\n\n  Sprite.prototype.circle = function(radius, extent) {\n    if (extent === undefined) {\n      extent = 360\n    }\n    if (this.animate) {\n     var arcLen = Math.abs(radius * Math.PI * 2.0  * extent / 360);\n     var segLen = this.spriteCanvas.getSegmentLength();\n     if (arcLen <= segLen)\n      this.arc(radius,extent);\n    else {\n        //  Break the arc into segments for animation\n        var extentPart = (segLen / arcLen) * extent;\n        var extentLeft = extent;\n        while (Math.abs(extentLeft) > Math.abs(extentPart)) {\n          this.arc(radius, extentPart);\n          extentLeft = extentLeft - extentPart;\n        }\n        if (Math.abs(extentLeft) > 0.01)\n          this.arc(radius, extentLeft);\n      }\n    } else {\n      this.arc(radius,extent);\n    }\n  }\n  \n  Sprite.prototype.arc = function(radius, extent) {\n    //  Figure out where the sprite is and which way it\'s facing\n    var spriteHeading = this.get_heading()\n    var tx = this.position[0]\n    var ty = this.position[1]\n\n    //  Figure out the circle center\n    var cx = tx + (radius * Math.cos((spriteHeading + 90) * Degree2Rad));\n    var cy = ty + (radius * Math.sin((spriteHeading + 90) * Degree2Rad));\n\n    //  Canvas arc angles go CLOCKWISE, not COUNTERCLOCKWISE like Sprite\n\n    //  Figure out our arc angles\n    var startAngleDeg;\n    if (radius >= 0)\n      startAngleDeg = spriteHeading - 90;\n    else\n      startAngleDeg = spriteHeading + 90;\n\n    var endAngleDeg;\n    if (extent) {\n      if (radius >= 0)\n        endAngleDeg = startAngleDeg + extent;\n      else\n        endAngleDeg = startAngleDeg - extent;\n    }\n    else {\n      if (radius >= 0)\n        endAngleDeg = startAngleDeg + 360;\n      else\n        endAngleDeg = startAngleDeg - 360;\n    }\n\n    //  Canvas angles are opposite\n    startAngleDeg = 360 - startAngleDeg\n    endAngleDeg   = 360 - endAngleDeg\n\n    //  Becuase the y axis has been flipped in HTML5 Canvas with a tanslation, we need to adjust the angles\n    startAngleDeg = -startAngleDeg\n    endAngleDeg   = -endAngleDeg\n\n    //  Convert to radians\n    var startAngle = startAngleDeg * Degree2Rad;\n    var endAngle   = endAngleDeg   * Degree2Rad;\n\n\n    //  Do the drawing\n    if (! this.animate) {\n      if (!this.filling)\n        this.context.beginPath();\n      this.context.arc(cx, cy, Math.abs(radius), startAngle, endAngle, (radius * extent <= 0));\n      this.context.stroke();\n      if (!this.filling)\n        this.context.closePath();\n    }\n    else {\n      this.addDrawingEvent(["CI", cx, cy, Math.abs(radius), startAngle, endAngle, (radius * extent <= 0)]);\n    }\n\n    //  Move the sprite only if we have to\n    if (extent && (extent % 360) != 0) {\n      var turtleArc;\n      if (radius >= 0)\n        turtleArc = extent;\n      else \n        turtleArc = -extent;\n      var newHeading = (spriteHeading + turtleArc) % 360;\n      if (newHeading < 0)\n        newHeading = newHeading + 360;\n\n      var nx = cx + (radius * Math.cos((newHeading - 90) * Degree2Rad));\n      var ny = cy + (radius * Math.sin((newHeading - 90) * Degree2Rad));  //  y coord is inverted in sprite\n\n      //  Move it internally\n      this.set_heading(newHeading);\n      this.teleport_to(nx,ny);\n\n      //  If we\'re animating the sprite, move it on the screen\n      if (this.animate) {\n        this.addDrawingEvent(["TT", this.heading]);\n      }\n    }\n  }\n\n  Sprite.prototype.write = function(theText, move, align, font) {\n    if (! this.animate) {\n      if (font)\n        this.context.font = font.v;\n      this.context.scale(1, -1);\n      this.context.fillText(theText, this.position[0], -this.position[1]);\n      this.context.scale(1, -1);\n    } else {\n      var fontspec;\n      if (font)\n        fontspec = font.v\n      this.addDrawingEvent(["WT", theText, fontspec, this.position[0], this.position[1]]);\n    }\n  }\n\n  Sprite.prototype.setworldcoordinates = function(llx, lly, urx, ury) {\n    this.spriteCanvas.setworldcoordinates(llx, lly, urx, ury);\n  }\n\n  //\n  // Pen and Style functions\n  //\n  Sprite.prototype.pen_down = function () {\n    this.pen = true;\n  }\n\n  Sprite.prototype.down = Sprite.prototype.pen_down;\n\n  Sprite.prototype.pen_up = function () {\n    this.pen = false;\n  }\n\n  Sprite.prototype.up = Sprite.prototype.pen_up;\n\n  Sprite.prototype.get_pen = function () {\n    return this.pen;\n  }\n\n  Sprite.prototype.set_pen_width = function (w) {\n    if (this.animate)\n      this.addDrawingEvent(["PW", w * this.spriteCanvas.lineScale]);\n    else\n      this.penWidth = w;\n  }\n\n  Sprite.prototype.get_pen_width = function() {\n    return this.penWidth * this.spriteCanvas.lineScale;\n  }\n\n  Sprite.prototype.set_pen_color = function (c, g, b) {\n    if (typeof(c) == "string") {\n      this.penStyle = c;\n    }\n    else {\n      var rs\n      var gs\n      var bs\n      if (typeof( c) == "object" && c.length == 3) {\n        var c0 = Sk.builtin.asnum$(c[0]);\n        var c1 = Sk.builtin.asnum$(c[1]);\n        var c2 = Sk.builtin.asnum$(c[2]);\n      }\n      else {\n        var c0 = Sk.builtin.asnum$(c);\n        var c1 = Sk.builtin.asnum$(g);\n        var c2 = Sk.builtin.asnum$(b);\n      }\n      rs = c0.toString(16);\n      gs = c1.toString(16);\n      bs = c2.toString(16);\n      while (rs.length < 2) rs = "0" + rs;\n      while (gs.length < 2) gs = "0" + gs;\n      while (bs.length < 2) bs = "0" + bs;\n      c = "#" + rs + gs + bs;\n      this.penStyle = c;\n    }\n\n    this.context.strokeStyle = c;\n    if (this.animate)\n      this.addDrawingEvent(["TC", c]);\n  }\n\n  Sprite.prototype.set_fill_color = function (c, g, b) {\n    if (typeof(c) == "string") {\n      this.fillStyle = c;\n    }\n    else {\n      var rs\n      var gs\n      var bs\n      if (typeof( c) == "object" && c.length == 3) {\n        var c0 = Sk.builtin.asnum$(c[0]);\n        var c1 = Sk.builtin.asnum$(c[1]);\n        var c2 = Sk.builtin.asnum$(c[2]);\n      } else {\n        var c0 = Sk.builtin.asnum$(c);\n        var c1 = Sk.builtin.asnum$(g);\n        var c2 = Sk.builtin.asnum$(b);\n      }\n      rs = c0.toString(16)\n      gs = c1.toString(16)\n      bs = c2.toString(16)\n      while (rs.length < 2) rs = "0" + rs;\n      while (gs.length < 2) gs = "0" + gs;\n      while (bs.length < 2) bs = "0" + bs;\n      c = "#" + rs + gs + bs;\n      this.fillStyle = c;\n    }\n\n    this.context.fillStyle = c;\n    if (this.animate)\n      this.addDrawingEvent(["FC", c]);\n  }\n\n  Sprite.prototype.begin_fill = function () {\n    if (! this.animate) {\n      this.filling = true;\n      this.context.beginPath();\n      this.context.moveTo(this.position[0], this.position[1]);\n    }\n    else {\n      this.addDrawingEvent(["BF", this.position[0], this.position[1]]);\n    }\n  }\n\n  Sprite.prototype.end_fill = function () {\n    if (! this.animate) {\n      this.context.stroke();\n      this.context.fill();\n      this.context.closePath();\n      this.filling = false;\n    } else\n    this.addDrawingEvent(["EF", this.position[0], this.position[1], this.fillStyle]);\n  }\n\n  Sprite.prototype.showturtle = function() {\n    if (this.animate) {\n      this.addDrawingEvent(["SH"]);\n    }\n    this.visible = true;\n  }\n\n  Sprite.prototype.hideturtle = function() {\n    if (this.animate) {\n      this.addDrawingEvent(["HT"]);\n    }\n    this.visible = false;\n  }\n\n  Sprite.prototype.isvisible = function() {\n    return this.visible;\n  }\n\n  // \n  // Appearance\n  //\n\n  Sprite.prototype.shape = function(s) {\n    if (this.shapeStore[s])\n      this.currentShape = s;\n    else {\n    }\n  }\n\n  Sprite.prototype.drawSprite = function(heading, position) {\n    var rtPoints = [];\n    var plist = this.shapeStore[this.currentShape];\n    var head;\n    if (! (heading === undefined))\n      head = heading - 90.0;\n    else\n      head = this.heading.toAngle() - 90.0;\n    if (! position)\n      position = this.position\n    for (p in plist) {\n      rtPoints.push(plist[p].scale(this.spriteCanvas.xptscale,this.spriteCanvas.yptscale).rotate(head).add(position));\n    }\n    this.context.beginPath();\n    this.context.moveTo(rtPoints[0][0], rtPoints[0][1]);\n    for (var i = 1; i < rtPoints.length; i++) {\n      this.context.lineTo(rtPoints[i][0], rtPoints[i][1]);\n    }\n    this.context.closePath();\n    this.context.stroke();\n    if (this.fillStyle) {\n      this.context.fill();\n    }\n  }\n\n  Sprite.prototype.stamp = function() {\n    // either call drawSprite or just add a DT with current position and heading to the drawingEvents list.\n    if (this.animate) {\n      this.addDrawingEvent(["ST",this.position[0],this.position[1],this.heading.toAngle()]);\n    } else\n    this.drawSprite();\n  }\n\n  Sprite.prototype.clear = function () {\n    if (this.animate) {\n      this.addDrawingEvent(["CL"])\n    }\n    else {\n      clear_canvas(this.canvasID);\n    }\n  }\n\n  function clear_canvas(canId) {\n    with (document.getElementById(canId).getContext(\'2d\')) {\n      if (arguments.length >= 2) {\n        // fillStyle = arguments[1];\n        // fillRect(0, 0, canvas.width, canvas.height);\n      }\n      clearRect(-canvas.width / 2, -canvas.height / 2, canvas.width, canvas.height);\n    }\n  }\n\n\n  // Create a 3d Vector class for manipulating sprite heading, and position.\n\n  function Vector(x, y, z) {\n    if ((typeof(x)).toLowerCase() === \'number\') {\n      Array.prototype.push.call(this, x);\n      Array.prototype.push.call(this, y);\n      Array.prototype.push.call(this, z);\n    }\n    else {\n      for (var i in x) {\n        Array.prototype.push.call(this, x[i]);\n      }\n    }\n  }\n\n\n  // Create a vector object given a direction as an angle.\n  Vector.angle2vec = function(phi) {\n    var res = new Vector([0.0,0.0,0.0]);\n    phi = phi * Degree2Rad;\n    res[0] = Math.cos(phi);\n    res[1] = Math.sin(phi);\n    return res.normalize();\n  }\n\n  // This trick allows you to access a Vector object like an array\n  // myVec[0] == x\n  // myVec[1] == y\n  // myVec[2] == z\n  // we really only need the z for the convenience of rotating!\n  // If we were using Geometric Algebra we wouldn\'t need it at all and could stay in the plane.\n  Vector.prototype.addItem = function(item) {\n    Array.prototype.push.call(this, item);\n  }\n\n  Vector.prototype.linear = function(a, b, v) {\n    var result = [ ];\n    for (var c = 0; c <= 2; ++c) {\n      result[c] = a * this[c] + b * v[c];\n    }\n    return new Vector(result);\n  }\n\n  Vector.prototype.cross = function(v) {\n    // Return cross product of this and v\n    var result = [ ];\n    for (var c = 0; c <= 2; ++c) {\n      result[c] = this[(c + 1) % 3] * v[(c + 2) % 3] - this[(c + 2) % 3] * v[(c + 1) % 3];\n    }\n    return new Vector(result);\n  }\n\n  Vector.prototype.rotate = function(angle) {\n    // Rotate this counter clockwise by angle.\n    var perp = new Vector(-this[1], this[0], 0);\n    angle = angle * Degree2Rad;\n    var c = Math.cos(angle);\n    var s = Math.sin(angle);\n    return new Vector(this[0] * c + perp[0] * s, this[1] * c + perp[1] * s, 0);\n  }\n\n  Vector.prototype.rotateNormal = function(v, w, alpha) {\n    // Return rotation of this in direction of v about w over alpha\n    // Requires: v, w are vectors; alpha is angle in radians\n    //   this, v, w are orthonormal\n    return this.linear(Math.cos(alpha), Math.sin(alpha), v);\n  }\n\n  Vector.prototype.normalize = function() {\n    var n = this.len();\n    var res = this.div(n);\n    return res;\n  }\n\n  Vector.prototype.toAngle = function() {\n    // workaround for values getting set to +/i xxx e -16 fooling the +/- checks below\n    if (Math.abs(this[1]) < 0.00001) this[1] = 0.0;\n    if (Math.abs(this[0]) < 0.00001) this[0] = 0.0;\n    var rads = Math.atan(Math.abs(this[1]) / Math.abs(this[0]));\n    var deg = rads * Rad2Degree;\n    if (this[0] < 0 && this[1] > 0) deg = 180 - deg;\n    else if (this[0] < 0 && this[1] <= 0) deg = 180.0 + deg;\n    else if (this[0] >= 0 && this[1] < 0) deg = 360 - deg;\n    return deg;\n  }\n\n  // divide all vector components by the same value\n  Vector.prototype.div = function(n) {\n    res = []\n    res[0] = this[0] / n;\n    res[1] = this[1] / n;\n    res[2] = this[2] / n;\n    return new Vector(res);\n  }\n\n  // subtract one vector from another\n  Vector.prototype.sub = function(v) {\n    res = new Vector(0, 0, 0);\n    res[0] = this[0] - v[0];\n    res[1] = this[1] - v[1];\n    res[2] = this[2] - v[2];\n    return res;\n  }\n\n  Vector.prototype.add = function(v) {\n    res = new Vector(0, 0, 0);\n    res[0] = this[0] + v[0];\n    res[1] = this[1] + v[1];\n    res[2] = this[2] + v[2];\n    return res;\n  }\n\n  Vector.prototype.smul = function(k) {  // scalar multiplication\n    res = new Vector(0, 0, 0);\n    res[0] = this[0] * k;\n    res[1] = this[1] * k;\n    res[2] = this[2] * k;\n    return res;\n  }\n\n  Vector.prototype.scale = function(xs,ys) {\n    res = new Vector(0,0,0);\n    res[0] =  this[0] * ys;\n    res[1] =  this[1] * xs;\n    res[2] = 1.0;\n    return res;\n  }\n\n  Vector.prototype.len = function() {\n    return Math.sqrt(this[0] * this[0] + this[1] * this[1] + this[2] * this[2]);\n  }\n\n  SpriteGraphics.defaults = {canvasID: \'mycanvas\', degrees: true, animate: true};\n  SpriteGraphics.spriteList = [];\n  SpriteGraphics.Sprite = Sprite;\n  SpriteGraphics.SpriteCanvas = SpriteCanvas;\n  SpriteGraphics.canvasLib = {};\n  SpriteGraphics.clear_canvas = clear_canvas;\n  SpriteGraphics.Vector = Vector;\n  SpriteGraphics.canvasInit = false;\n  SpriteGraphics.eventCount = 0;\n  SpriteGraphics.renderClock = 0;\n  SpriteGraphics.renderTime  = 0;\n\n})();\n\nvar $builtinmodule = function(name) {\n\n  var mod = {};\n\n  // The exported name of the SPRITE class.\n  var SPRITE = "Sprite";\n\n  // First we create an object, this will end up being the class\n  Sk.tg = SpriteGraphics;\n\n  var checkArgs = function(expected, actual, func) {\n    if (actual != expected ) {\n      throw new Sk.builtin.TypeError(func + " takes exactly " + expected + " positional argument (" + actual + " given)");\n    }\n  }\n\n  var sprite = function($gbl, $loc) {\n\n    $loc.__init__ = new Sk.builtin.func(function(self, options) {\n      SpriteGraphics.defaults = {"canvasID": Sk.canvas, "animate": true, "degrees": true};\n      self.skType = SPRITE;\n      self.tp$name = SPRITE;\n      self.v = new SpriteGraphics.Sprite();\n      if (options instanceof Sk.builtin.dict) {\n        for (var iter = options.tp$iter(), k = iter.tp$iternext(); k !== undefined; k = iter.tp$iternext()) {\n          var v = options.mp$subscript(k);\n          if (v === undefined) {\n            v = null;\n          }\n          var kAsJs = Sk.ffi.remapToJs(k);\n          var vAsJs = Sk.ffi.remapToJs(v);\n          Sk.misceval.callsim(self[\'__setattr__\'], self, kAsJs, v);\n        }\n      }\n    });\n\n    $loc.__getattr__ = new Sk.builtin.func(function(self, key) {\n\n      var BACKWARD = "backward";\n      var BEGIN_FILL = "begin_fill";\n      // color is implemented as a callable attribute for compatibility.\n      var COLOR = "color";\n      var DOWN = "down";\n      var END_FILL = "end_fill";\n      // FILL_COLOR is implemented as a callable attribute for backwcompatibility.\n      var FILL_COLOR = "fillcolor";\n      var FORWARD = "forward";\n      var GOTO = "goto";\n      var LEFT = "left";\n      var POSITION = "position";\n      var RIGHT = "right";\n      // shape is implemented as a callable attribute for compatibility.\n      var SHAPE = "shape";\n      var STAMP = "stamp";\n      var UP = "up";\n      // Capture the target of the attribute operation.\n      var target = self.v;\n\n      switch(key) {\n        case BACKWARD: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = BACKWARD;\n            });\n\n            $loc.__call__ = new Sk.builtin.func(function(self, distance) {\n              distance = Sk.builtin.asnum$(distance);\n              checkArgs(2, arguments.length, BACKWARD);\n              target.forward(-distance);\n            });\n\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(BACKWARD)\n            })\n\n            $loc.__repr__ = new Sk.builtin.func(function(self, arg) {\n              return new Sk.builtin.str(BACKWARD)\n            })\n\n          }, BACKWARD, []));\n        }\n        case BEGIN_FILL: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = BEGIN_FILL;\n            });\n\n            $loc.__call__ = new Sk.builtin.func(function(self) {\n              checkArgs(1, arguments.length, BEGIN_FILL);\n              target.begin_fill();\n            });\n\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(BEGIN_FILL)\n            })\n\n            $loc.__repr__ = new Sk.builtin.func(function(self, arg) {\n              return new Sk.builtin.str(BEGIN_FILL)\n            })\n\n          }, BEGIN_FILL, []));\n        }\n        case COLOR: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = COLOR;\n            });\n\n            $loc.__call__ = new Sk.builtin.func(function(self, color, green, blue) {\n              if(color) {\n                if (blue) {\n                  target.set_pen_color(color, green, blue);\n                  target.set_fill_color(color, green, blue);\n                }\n                else {\n                  color = color.v || target.context.fillStyle;\n                  target.set_pen_color(color);\n                  target.set_fill_color(color);\n                }\n              }\n              else {\n                return [target.penStyle, target.fillStyle];\n              }\n            });\n\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(COLOR)\n            })\n\n            $loc.__repr__ = new Sk.builtin.func(function(self, arg) {\n              return new Sk.builtin.str(COLOR)\n            })\n\n          }, COLOR, []));\n        }\n        case DOWN: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = DOWN;\n            });\n\n            $loc.__call__ = new Sk.builtin.func(function(self) {\n              checkArgs(1, arguments.length, DOWN);\n              target.pen_down();\n            });\n\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(DOWN)\n            })\n\n            $loc.__repr__ = new Sk.builtin.func(function(self, arg) {\n              return new Sk.builtin.str(DOWN)\n            })\n\n          }, DOWN, []));\n        }\n        case END_FILL: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = END_FILL;\n            });\n\n            $loc.__call__ = new Sk.builtin.func(function(self) {\n              checkArgs(1, arguments.length, END_FILL);\n              target.end_fill();\n            });\n\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(END_FILL)\n            })\n\n            $loc.__repr__ = new Sk.builtin.func(function(self, arg) {\n              return new Sk.builtin.str(END_FILL)\n            })\n\n          }, END_FILL, []));\n        }\n        case FILL_COLOR: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = FILL_COLOR;\n            });\n\n            $loc.__call__ = new Sk.builtin.func(function(self, color, green, blue) {\n              if (color) {\n                if (blue) {\n                  target.set_fill_color(color, green, blue);\n                }\n                else {\n                  color = color.v || target.context.fillStyle;\n                  target.set_fill_color(color);\n                }\n              }\n              else {\n                return target.fillStyle;\n              }\n            });\n\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(FILL_COLOR)\n            })\n\n            $loc.__repr__ = new Sk.builtin.func(function(self, arg) {\n              return new Sk.builtin.str(FILL_COLOR)\n            })\n\n          }, FILL_COLOR, []));\n        }\n        case FORWARD: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = FORWARD;\n            });\n\n            $loc.__call__ = new Sk.builtin.func(function(self, distance) {\n              distance = Sk.builtin.asnum$(distance);\n              checkArgs(2, arguments.length, FORWARD);\n              target.forward(distance);\n            });\n\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(FORWARD)\n            })\n\n            $loc.__repr__ = new Sk.builtin.func(function(self, arg) {\n              return new Sk.builtin.str(FORWARD)\n            })\n\n          }, FORWARD, []));\n        }\n        case GOTO: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = GOTO;\n            });\n\n            $loc.__call__ = new Sk.builtin.func(function(self, nx, ny) {\n              nx = Sk.builtin.asnum$(nx);\n              ny = Sk.builtin.asnum$(ny);\n              checkArgs(3, arguments.length, GOTO);\n              target.goto(nx, ny);\n            });\n\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(GOTO)\n            })\n\n            $loc.__repr__ = new Sk.builtin.func(function(self, arg) {\n              return new Sk.builtin.str(GOTO)\n            })\n\n          }, GOTO, []));\n        }\n        case LEFT: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = LEFT;\n            });\n\n            $loc.__call__ = new Sk.builtin.func(function(self, angle) {\n              angle = Sk.builtin.asnum$(angle);\n              checkArgs(2, arguments.length, LEFT);\n              target.turn(-angle);\n            });\n\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(LEFT)\n            })\n\n            $loc.__repr__ = new Sk.builtin.func(function(self, arg) {\n              return new Sk.builtin.str(LEFT)\n            })\n\n          }, LEFT, []));\n        }\n        case POSITION: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = POSITION;\n              checkArgs(1, arguments.length, POSITION);\n            });\n\n            $loc.__getattr__ = new Sk.builtin.func(function(self, key) {\n              switch(key) {\n                case "x": {\n                  var position = target.get_position();\n                  return Sk.builtin.assk$(position[0], Sk.builtin.nmber.float$);\n                }\n                break;\n                case "y": {\n                  var position = target.get_position();\n                  return Sk.builtin.assk$(position[1], Sk.builtin.nmber.float$);\n                }\n                break;\n                default: {\n                  // do nothing.\n                }\n              }\n            });\n\n            $loc.__setattr__ = new Sk.builtin.func(function(self, key, value) {\n              switch(key) {\n                case "x": {\n                  var nx = Sk.builtin.asnum$(value);\n                  checkArgs(3, arguments.length, key);\n                  target.goto(nx, target.gety());\n                }\n                break;\n                case "y": {\n                  var ny = Sk.builtin.asnum$(value);\n                  checkArgs(3, arguments.length, key);\n                  target.goto(target.getx(), ny);\n                }\n                break;\n                default: {\n                  // do nothing.\n                }\n              }\n            });\n\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(POSITION)\n            })\n\n            $loc.__repr__ = new Sk.builtin.func(function(self, arg) {\n              return new Sk.builtin.str(POSITION)\n            })\n\n          }, POSITION, []));\n        }\n        case RIGHT: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = RIGHT;\n            });\n\n            $loc.__call__ = new Sk.builtin.func(function(self, angle) {\n              angle = Sk.builtin.asnum$(angle);\n              checkArgs(2, arguments.length, RIGHT);\n              target.turn(angle);\n            });\n\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(RIGHT)\n            })\n\n            $loc.__repr__ = new Sk.builtin.func(function(self, arg) {\n              return new Sk.builtin.str(RIGHT)\n            })\n\n          }, RIGHT, []));\n        }\n        case SHAPE: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = SHAPE;\n            });\n\n            $loc.__call__ = new Sk.builtin.func(function(self, shape) {\n              checkArgs(2, arguments.length, SHAPE);\n              target.shape(shape.v);\n            });\n\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(SHAPE)\n            })\n\n            $loc.__repr__ = new Sk.builtin.func(function(self, arg) {\n              return new Sk.builtin.str(SHAPE)\n            })\n\n          }, SHAPE, []));\n        }\n        case STAMP: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = STAMP;\n            });\n\n            $loc.__call__ = new Sk.builtin.func(function(self) {\n              checkArgs(1, arguments.length, STAMP);\n              target.stamp();\n            });\n\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(STAMP)\n            })\n\n            $loc.__repr__ = new Sk.builtin.func(function(self, arg) {\n              return new Sk.builtin.str(STAMP)\n            })\n\n          }, STAMP, []));\n        }\n        case UP: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = UP;\n            });\n\n            $loc.__call__ = new Sk.builtin.func(function(self) {\n              checkArgs(1, arguments.length, UP);\n              target.pen_up();\n            });\n\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(UP)\n            })\n\n            $loc.__repr__ = new Sk.builtin.func(function(self, arg) {\n              return new Sk.builtin.str(UP)\n            })\n\n          }, UP, []));\n        }\n        default: {\n          // Do nothing\n        }\n      }\n    });\n\n    $loc.__setattr__ = new Sk.builtin.func(function(self, name, value) {\n\n      var COLOR = "color";\n      var FILL_COLOR = "fillcolor";\n      var POSITION = "position";\n      var SHAPE = "shape";\n\n      switch(name) {\n        case COLOR: {\n          if(value) {\n            var color = value.v || self.v.context.fillStyle;\n            self.v.set_pen_color(color);\n            self.v.set_fill_color(color);\n          }\n        }\n        break;\n        case FILL_COLOR: {\n          if (value) {\n            self.v.set_fill_color(value.v || self.v.context.fillStyle);\n          }\n        }\n        break;\n        case POSITION: {\n          if (value) {\n            checkArgs(3, arguments.length, SHAPE);\n            self.v.goto(value.v[1], value.v[2]);\n          }\n        }\n        break;\n        case SHAPE: {\n          if (value) {\n            checkArgs(3, arguments.length, SHAPE);\n            self.v.shape(value.v);\n          }\n        }\n        break;\n        default: {\n//          throw new Sk.builtin.AttributeError("\'" + SPRITE + "\' object has no attribute setter \'" + name + "\'.");\n        }\n      }\n    });\n\n    $loc.setposition = new Sk.builtin.func(function(self,nx,ny) {\n      nx = Sk.builtin.asnum$(nx);\n      ny = Sk.builtin.asnum$(ny);\n      checkArgs(3,arguments.length,"setposition()");\n      self.v.up();\n      self.v.goto(nx,ny);\n      self.v.down();\n    });\n\n    $loc.setpos = $loc.setposition;\n\n    $loc.setheading = new Sk.builtin.func(function(self, newhead) {\n      newhead = Sk.builtin.asnum$(newhead);\n      checkArgs(2,arguments.length,"setheading()");\n      return self.v.set_heading(newhead);\n    });\n\n    $loc.seth = $loc.setheading;\n\n    $loc.home = new Sk.builtin.func(function(self) {\n      self.v.go_home();\n    });\n\n    $loc.dot = new Sk.builtin.func(function(self, /*opt*/ size, color) {\n      size = Sk.builtin.asnum$(size);\n      size = size || 1;\n      if (color) {\n        color = color.v || self.v.penStyle;\n      }\n      self.v.dot(size, color);\n    });\n\n    $loc.circle = new Sk.builtin.func(function(self, radius, extent) {\n      radius = Sk.builtin.asnum$(radius);\n      extent = Sk.builtin.asnum$(extent);\n      self.v.circle(radius, extent);\n    });\n\n    $loc.delay = new Sk.builtin.func(function(self, d) {\n      d = Sk.builtin.asnum$(d);\n      return self.v.delay(d);\n    });\n\n    $loc.speed = new Sk.builtin.func(function(self, s, t) {\n      s = Sk.builtin.asnum$(s);\n      t = Sk.builtin.asnum$(t);\n      self.v.speed(s,t);\n    });\n\n    $loc.tracer = new Sk.builtin.func(function(self, t, d) {\n      t = Sk.builtin.asnum$(t);\n      d = Sk.builtin.asnum$(d);\n      self.v.tracer(t, d);\n    });\n\n    $loc.update = new Sk.builtin.func(function(self) {\n      //  Dummy function to emulate update... when not animating, we don\'t save the drawing operations, so this is pointless for us\n    });\n\n    $loc.heading = new Sk.builtin.func(function(self) {\n      checkArgs(1,arguments.length,"heading()");\n      return self.v.get_heading();\n    });\n\n    $loc.xcor = new Sk.builtin.func(function(self) {\n      checkArgs(1,arguments.length,"xcor()");\n      var res = self.v.getx();\n      return res;\n    });\n\n    $loc.ycor = new Sk.builtin.func(function(self) {\n      checkArgs(1,arguments.length,"ycor()");\n      var res = self.v.gety();\n      return res;\n    });\n\n    $loc.towards = new Sk.builtin.func(function(self, tx, ty) {\n      tx = Sk.builtin.asnum$(tx);\n      ty = Sk.builtin.asnum$(ty);\n      if ((typeof(tx)).toLowerCase() === \'number\')\n        tx = [tx, ty, 0];\n      return self.v.towards(tx);\n    });\n\n    // tx can be either a number or a vector position.\n    // tx can not be a sprite at this time as multiple sprites have not been implemented yet.\n    $loc.distance = new Sk.builtin.func(function(self, tx, ty) {\n      tx = Sk.builtin.asnum$(tx);\n      ty = Sk.builtin.asnum$(ty);\n      if ((typeof(tx)).toLowerCase() === \'number\') {\n        tx = [tx, ty, 0];\n      }\n      else {\n        tx = [tx.v.getx(), tx.v.gety(), 0];\n      }\n      return self.v.distance(tx);\n    });\n\n    //\n    // Setting and Measurement\n    //\n\n    $loc.width = new Sk.builtin.func(function(self, w) {\n     w = Sk.builtin.asnum$(w);\n     checkArgs(2,arguments.length,"width()");\n     self.v.set_pen_width(w);\n   });\n\n    $loc.pensize = $loc.width;\n\n    $loc.isdown = new Sk.builtin.func(function(self) {\n      checkArgs(1,arguments.length,"isdown()");\n      return self.v.get_pen();\n    });\n\n    $loc.pencolor = new Sk.builtin.func(function(self, color, green, blue) {\n      if (color) {\n        if (blue) {\n          color = Sk.builtin.asnum$(color);\n          green = Sk.builtin.asnum$(green);\n          blue = Sk.builtin.asnum$(blue);\n          self.v.set_pen_color(color, green, blue);\n        }\n        else {\n          color = color.v || self.v.context.fillStyle;\n          self.v.set_pen_color(color);\n        }\n      }\n      else {\n        return self.v.penStyle;\n      }\n    });\n\n    $loc.color = new Sk.builtin.func(function(self, color, green, blue) {\n      if(color) {\n        if (blue) {\n          self.v.set_pen_color(color, green, blue);\n          self.v.set_fill_color(color, green, blue);\n        }\n        else {\n          color = color.v || self.v.context.fillStyle;\n          self.v.set_pen_color(color);\n          self.v.set_fill_color(color);\n        }\n      }\n      else {\n        return [self.v.penStyle, self.v.fillStyle];\n      }\n    });\n\n    $loc.fill = new Sk.builtin.func(function(self, fillt) {\n      if (fillt === undefined)\n        return self.v.filling;\n      if (fillt)\n        self.v.begin_fill();\n      else\n        self.v.end_fill();\n    });\n\n    //\n    // More drawing control\n    //\n\n    $loc.reset = new Sk.builtin.func(function(self) {\n      self.v.clean();\n    });\n\n    $loc.showturtle = new Sk.builtin.func(function(self) {\n      checkArgs(1,arguments.length,"showturtle()");\n      self.v.showturtle();\n    });\n\n    $loc.st = $loc.showturtle;\n\n    $loc.hideturtle = new Sk.builtin.func(function(self) {\n      checkArgs(1,arguments.length,"hideturtle()");\n      self.v.hideturtle();\n    });\n\n    $loc.ht = $loc.hideturtle;\n\n    $loc.isvisible = new Sk.builtin.func(function(self) {\n      checkArgs(1,arguments.length,"isvisible()");\n      self.v.isvisible()\n    });\n\n    // todo the move, align, and font parameters should be kwargs...\n    $loc.write = new Sk.builtin.func(function(self, mystr, move, align, font) {\n      self.v.write(mystr.v, move, align, font);\n    });\n\n    // todo clean  -- again multiple sprites\n\n    $loc.setworldcoordinates = new Sk.builtin.func(function(self, llx, lly, urx, ury) {\n      llx = Sk.builtin.asnum$(llx);\n      lly = Sk.builtin.asnum$(lly);\n      urx = Sk.builtin.asnum$(urx);\n      ury = Sk.builtin.asnum$(ury);\n      self.v.setworldcoordinates(llx, lly, urx, ury);\n    });\n\n    $loc.clear = new Sk.builtin.func(function(self) {\n      self.v.clear()\n    });\n  }\n\n  mod[SPRITE] = Sk.misceval.buildClass(mod, sprite, SPRITE, []);\n\n  var screen = function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self) {\n      SpriteGraphics.defaults = {canvasID: Sk.canvas, animate: true, degrees: true};\n      var currentCanvas = SpriteGraphics.canvasLib[SpriteGraphics.defaults.canvasID];\n      if (currentCanvas === undefined) {\n        self.theScreen = new SpriteGraphics.SpriteCanvas(SpriteGraphics.defaults);\n      } else {\n        self.theScreen = currentCanvas;\n      }\n    });\n\n    $loc.bgcolor = new Sk.builtin.func(function(self, c) {\n      self.theScreen.bgcolor(c);\n    });\n\n    $loc.setworldcoordinates = new Sk.builtin.func(function(self, llx,lly,urx,ury) {\n     llx = Sk.builtin.asnum$(llx);\n     lly = Sk.builtin.asnum$(lly);\n     urx = Sk.builtin.asnum$(urx);\n     ury = Sk.builtin.asnum$(ury);\n     self.theScreen.setworldcoordinates(llx,lly,urx,ury);\n   });\n\n    $loc.exitonclick = new Sk.builtin.func(function(self) {\n      self.theScreen.exitonclick();\n    });\n\n    $loc.title = new Sk.builtin.func(function(self,titlestring) {\n      // no op....\n    });\n\n    $loc.window_width = new Sk.builtin.func(function(self) {\n      return self.theScreen.window_width();\n    });\n\n    $loc.window_height = new Sk.builtin.func(function(self) {\n      return self.theScreen.window_height();\n    });\n\n    $loc.sprites = new Sk.builtin.func(function(self) {\n      return self.theScreen.sprites();\n    });\n\n    $loc.colormode = new Sk.builtin.func(function(self) {\n      //  Empty function to emulate compatibility\n    });\n\n    var myfunc = function(self, width, height, startx, starty) {\n      width = Sk.builtin.asnum$(width);\n      height = Sk.builtin.asnum$(height);\n      self.theScreen.setup(width,height);\n    }\n    // this should allow for named parameters\n    myfunc.co_varnames = [\'self\',\'width\',\'height\',\'startx\',\'starty\'];\n    myfunc.$defaults = [null,500,500,0,0];\n    $loc.setup = new Sk.builtin.func(myfunc);\n  }\n\n  mod.Screen = Sk.misceval.buildClass(mod, screen, \'Screen\', []);\n\n  mod.tracer = new Sk.builtin.func(function(t, d) {\n    t = Sk.builtin.asnum$(t);\n    d = Sk.builtin.asnum$(d);\n    for (var i in Sk.tg.canvasLib) {\n      Sk.tg.canvasLib[i].tracer(t, d);\n    }\n  });\n\n  mod.update = new Sk.builtin.func(function(self) {\n    //  Dummy function to emulate update... when not animating, we don\'t save the drawing operations, so this is pointless for us\n  });\n\n  return mod\n}\n',
    'src/lib/unittestgui/__init__.py': '__author__ = \'bmiller\'\n\nimport document\n\n\nclass unittest:\n    def __init__(self):\n        self.numPassed = 0\n        self.numFailed = 0\n        self.divid = document.currentDiv()\n        self.mydiv = document.getElementById(self.divid)\n        res = document.getElementById(self.divid+\'_unit_results\')\n        if res:\n            self.resdiv = res\n            res.innerHTML = \'\'\n        else:\n            self.resdiv = document.createElement(\'div\')\n            self.resdiv.setAttribute(\'id\',self.divid+\'_unit_results\')\n            self.resdiv.setAttribute(\'class\',\'unittest-results\')\n        self.mydiv.appendChild(self.resdiv)\n\n        self.tlist = []\n        testNames = {}\n        for name in dir(self):\n            if name[:4] == \'test\' and name not in testNames:\n                self.tlist.append(getattr(self,name))\n                testNames[name]=True\n\n    def setup(self):\n        pass\n\n    def tearDown(self):\n        pass\n\n    def main(self):\n        l = document.createElement(\'ul\')\n        self.resdiv.appendChild(l)\n        self.resList = l\n\n        for func in self.tlist:\n            try:\n                self.setup()\n                func()\n                self.tearDown()\n            except:\n                self.appendResult(\'Error\')\n                self.numFailed += 1\n        self.showSummary()\n\n    def assertEqual(self, actual, expected, feedback=""):\n        res = actual==expected\n        self.appendResult(res,str(actual)+\' to be equal to \',expected, feedback)\n\n    def assertNotEqual(actual, expected, feedback=""):\n        res = actual != expected\n        self.appendResult(res,str(actual)+\' to not equal \',expected,feedback)\n\n    def assertTrue(self,x, feedback=""):\n        res = x\n        self.appendResult(res,str(x)+\' to be \',True,feedback)\n\n    def assertFalse(self,x, feedback=""):\n        res = not x\n        self.appendResult(res,str(x)+\' to be \',False,feedback)\n\n    def assertIs(self,a,b, feedback=""):\n        res = a is b\n        self.appendResult(res,str(a)+\' to be the same object as \',b,feedback)\n\n    def assertIsNot(self,a,b, feedback=""):\n        res = a is not b\n        self.appendResult(res,str(a)+\' to not be the same object as \',b,feedback)\n\n    def assertIsNone(self,x, feedback=""):\n        res = x is None\n        self.appendResult(res,x,None,feedback)\n\n    def assertIsNotNone(self,x, feedback=""):\n        res = x is not None\n        self.appendResult(res,str(x)+\' to not be \',None,feedback)\n\n    def assertIn(self,a,b, feedback=""):\n        res = a in b\n        self.appendResult(res,str(a)+\' to be in \',b,feedback)\n\n    def assertNotIn(self,a,b, feedback=""):\n        res = a not in b\n        self.appendResult(res,str(a)+\' to not be in \',b,feedback)\n\n    def assertIsInstance(self,a,b, feedback=""):\n        res = isinstance(a,b)\n        self.appendResult(res,str(a)+\' to be an instance of \',b,feedback)\n\n    def assertNotIsInstance(self,a,b, feedback=""):\n        res = not isinstance(a,b)\n        self.appendResult(res,str(a)+\' to not be an instance of \',b,feedback)\n\n    def assertAlmostEqual(self,a,b, feedback=""):\n        res = round(a-b,7) == 0\n        self.appendResult(res,str(a)+\' to equal \',b,feedback)\n\n    def assertNotAlmostEqual(self,a,b, feedback=""):\n        res = round(a-b,7) != 0\n        self.appendResult(res,str(a)+\' to not equal \',b,feedback)\n\n    def assertGreater(self,a,b, feedback=""):\n        res = a > b\n        self.appendResult(res,str(a)+\' to be greater than \',b,feedback)\n\n    def assertGreaterEqual(self,a,b, feedback=""):\n        res = a >= b\n        self.appendResult(res,str(a)+\' to be greater than or equal to \',b,feedback)\n\n    def assertLess(self,a,b, feedback=""):\n        res = a < b\n        self.appendResult(res,str(a)+\' to be less than \',b,feedback)\n\n    def assertLessEqual(self,a,b, feedback=""):\n        res = a <= b\n        self.appendResult(res,str(a)+\' to be less than or equal to \',b,feedback)\n\n    def appendResult(self,res,actual,expected,feedback):\n        if res == \'Error\':\n            msg = \'Error\'\n        elif res:\n            msg = \'Pass\'\n            self.numPassed += 1\n        else:\n            msg = \'Fail: expected %s  %s \' % (str(actual),str(expected)) + feedback\n            self.numFailed += 1\n\n        pTag = document.createElement(\'li\')\n        pTag.innerHTML = msg\n        self.resList.appendChild(pTag)\n\n    def showSummary(self):\n        pct = self.numPassed / (self.numPassed+self.numFailed) * 100\n        pTag = document.createElement(\'p\')\n        pTag.innerHTML = "You passed: " + str(pct) + "% of the tests"\n        self.resdiv.appendChild(pTag)\n        if pct < 90:\n            self.resdiv.setCSS(\'background-color\',\'#de8e96\')\n        else:\n            self.resdiv.setCSS(\'background-color\',\'#83d382\')\n\n\n\n',
    'src/lib/webgl/matrix4.js': '// more from \'tdl\'\nvar $builtinmodule = function(name)\n{\n    var mod = {};\n\n    var temp0v3_ = new Float32Array(3);\n    var temp1v3_ = new Float32Array(3);\n    var temp2v3_ = new Float32Array(3);\n\n    var temp0v4_ = new Float32Array(4);\n    var temp1v4_ = new Float32Array(4);\n    var temp2v4_ = new Float32Array(4);\n\n    var temp0m4_ = new Float32Array(16);\n    var temp1m4_ = new Float32Array(16);\n    var temp2m4_ = new Float32Array(16);\n\n    var normalize = function(dst, a) {\n        var n = 0.0;\n        var aLength = a.length;\n        for (var i = 0; i < aLength; ++i)\n            n += a[i] * a[i];\n        n = Math.sqrt(n);\n        if (n > 0.00001) {\n            for (var i = 0; i < aLength; ++i)\n                dst[i] = a[i] / n;\n        } else {\n            for (var i = 0; i < aLength; ++i)\n                dst[i] = 0;\n        }\n        return dst;\n    };\n\n    var cross = function(dst, a, b) {\n        dst[0] = a[1] * b[2] - a[2] * b[1];\n        dst[1] = a[2] * b[0] - a[0] * b[2];\n        dst[2] = a[0] * b[1] - a[1] * b[0];\n        return dst;\n    };\n\n    var subVector = function(dst, a, b) {\n        var aLength = a.length;\n        for (var i = 0; i < aLength; ++i)\n            dst[i] = a[i] - b[i];\n        return dst;\n    };\n\n    var dot = function(a, b) {\n        return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2]);\n    };\n\n    mod.lookAt = new Sk.builtin.func(function(view, eye, target, up)\n            {\n                var t0 = temp0v3_;\n                var t1 = temp1v3_;\n                var t2 = temp2v3_;\n\n                var vz = normalize(t0, subVector(t0, eye.v, target.v));\n                var vx = normalize(t1, cross(t1, up.v, vz));\n                var vy = cross(t2, vz, vx);\n\n                var dst = view.v;\n                dst[ 0] = vx[0];\n                dst[ 1] = vy[0];\n                dst[ 2] = vz[0];\n                dst[ 3] = 0;\n                dst[ 4] = vx[1];\n                dst[ 5] = vy[1];\n                dst[ 6] = vz[1];\n                dst[ 7] = 0;\n                dst[ 8] = vx[2];\n                dst[ 9] = vy[2];\n                dst[10] = vz[2];\n                dst[11] = 0;\n                dst[12] = -dot(vx, eye.v);\n                dst[13] = -dot(vy, eye.v);\n                dst[14] = -dot(vz, eye.v);\n                dst[15] = 1;\n\n                return view;\n            });\n\n    mod.perspective = new Sk.builtin.func(function(proj, angle, aspect, near, far)\n            {\n                var f = Math.tan(Math.PI * 0.5 - 0.5 * (angle * Math.PI / 180));\n                var rangeInv = 1.0 / (near - far);\n\n                var dst = proj.v;\n\n                dst[0]  = f / aspect;\n                dst[1]  = 0;\n                dst[2]  = 0;\n                dst[3]  = 0;\n\n                dst[4]  = 0;\n                dst[5]  = f;\n                dst[6]  = 0;\n                dst[7]  = 0;\n\n                dst[8]  = 0;\n                dst[9]  = 0;\n                dst[10] = (near + far) * rangeInv;\n                dst[11] = -1;\n\n                dst[12] = 0;\n                dst[13] = 0;\n                dst[14] = near * far * rangeInv * 2;\n                dst[15] = 0;\n\n                return proj;\n            });\n\n    // builds, not appending\n    mod.rotationY = new Sk.builtin.func(function(target, angle)\n            {\n                var dst = target.v;\n                var c = Math.cos(angle * Math.PI / 180);\n                var s = Math.sin(angle * Math.PI / 180);\n\n                dst[ 0] = c;\n                dst[ 1] = 0;\n                dst[ 2] = -s;\n                dst[ 3] = 0;\n                dst[ 4] = 0;\n                dst[ 5] = 1;\n                dst[ 6] = 0;\n                dst[ 7] = 0;\n                dst[ 8] = s;\n                dst[ 9] = 0;\n                dst[10] = c;\n                dst[11] = 0;\n                dst[12] = 0;\n                dst[13] = 0;\n                dst[14] = 0;\n                dst[15] = 1;\n\n                return target;\n            });\n\n    mod.identity = new Sk.builtin.func(function(target)\n            {\n                var dst = target.v;\n                dst[ 0] = 1;\n                dst[ 1] = 0;\n                dst[ 2] = 0;\n                dst[ 3] = 0;\n                dst[ 4] = 0;\n                dst[ 5] = 1;\n                dst[ 6] = 0;\n                dst[ 7] = 0;\n                dst[ 8] = 0;\n                dst[ 9] = 0;\n                dst[10] = 1;\n                dst[11] = 0;\n                dst[12] = 0;\n                dst[13] = 0;\n                dst[14] = 0;\n                dst[15] = 1;\n                return target;\n            });\n\n    // row major\n    mod.mul = new Sk.builtin.func(function(target, x, y)\n            {\n                var dst = target.v;\n                var a = x.v;\n                var b = y.v;\n                var a00 = a[0];\n                var a01 = a[1];\n                var a02 = a[2];\n                var a03 = a[3];\n                var a10 = a[ 4 + 0];\n                var a11 = a[ 4 + 1];\n                var a12 = a[ 4 + 2];\n                var a13 = a[ 4 + 3];\n                var a20 = a[ 8 + 0];\n                var a21 = a[ 8 + 1];\n                var a22 = a[ 8 + 2];\n                var a23 = a[ 8 + 3];\n                var a30 = a[12 + 0];\n                var a31 = a[12 + 1];\n                var a32 = a[12 + 2];\n                var a33 = a[12 + 3];\n                var b00 = b[0];\n                var b01 = b[1];\n                var b02 = b[2];\n                var b03 = b[3];\n                var b10 = b[ 4 + 0];\n                var b11 = b[ 4 + 1];\n                var b12 = b[ 4 + 2];\n                var b13 = b[ 4 + 3];\n                var b20 = b[ 8 + 0];\n                var b21 = b[ 8 + 1];\n                var b22 = b[ 8 + 2];\n                var b23 = b[ 8 + 3];\n                var b30 = b[12 + 0];\n                var b31 = b[12 + 1];\n                var b32 = b[12 + 2];\n                var b33 = b[12 + 3];\n                dst[ 0] = a00 * b00 + a01 * b10 + a02 * b20 + a03 * b30;\n                dst[ 1] = a00 * b01 + a01 * b11 + a02 * b21 + a03 * b31;\n                dst[ 2] = a00 * b02 + a01 * b12 + a02 * b22 + a03 * b32;\n                dst[ 3] = a00 * b03 + a01 * b13 + a02 * b23 + a03 * b33;\n                dst[ 4] = a10 * b00 + a11 * b10 + a12 * b20 + a13 * b30;\n                dst[ 5] = a10 * b01 + a11 * b11 + a12 * b21 + a13 * b31;\n                dst[ 6] = a10 * b02 + a11 * b12 + a12 * b22 + a13 * b32;\n                dst[ 7] = a10 * b03 + a11 * b13 + a12 * b23 + a13 * b33;\n                dst[ 8] = a20 * b00 + a21 * b10 + a22 * b20 + a23 * b30;\n                dst[ 9] = a20 * b01 + a21 * b11 + a22 * b21 + a23 * b31;\n                dst[10] = a20 * b02 + a21 * b12 + a22 * b22 + a23 * b32;\n                dst[11] = a20 * b03 + a21 * b13 + a22 * b23 + a23 * b33;\n                dst[12] = a30 * b00 + a31 * b10 + a32 * b20 + a33 * b30;\n                dst[13] = a30 * b01 + a31 * b11 + a32 * b21 + a33 * b31;\n                dst[14] = a30 * b02 + a31 * b12 + a32 * b22 + a33 * b32;\n                dst[15] = a30 * b03 + a31 * b13 + a32 * b23 + a33 * b33;\n                return target;\n            });\n\n    mod.invert = new Sk.builtin.func(function(target, mat)\n            {\n                var dst = target.v;\n                var m = mat.v;\n                var m00 = m[0 * 4 + 0];\n                var m01 = m[0 * 4 + 1];\n                var m02 = m[0 * 4 + 2];\n                var m03 = m[0 * 4 + 3];\n                var m10 = m[1 * 4 + 0];\n                var m11 = m[1 * 4 + 1];\n                var m12 = m[1 * 4 + 2];\n                var m13 = m[1 * 4 + 3];\n                var m20 = m[2 * 4 + 0];\n                var m21 = m[2 * 4 + 1];\n                var m22 = m[2 * 4 + 2];\n                var m23 = m[2 * 4 + 3];\n                var m30 = m[3 * 4 + 0];\n                var m31 = m[3 * 4 + 1];\n                var m32 = m[3 * 4 + 2];\n                var m33 = m[3 * 4 + 3];\n                var tmp_0  = m22 * m33;\n                var tmp_1  = m32 * m23;\n                var tmp_2  = m12 * m33;\n                var tmp_3  = m32 * m13;\n                var tmp_4  = m12 * m23;\n                var tmp_5  = m22 * m13;\n                var tmp_6  = m02 * m33;\n                var tmp_7  = m32 * m03;\n                var tmp_8  = m02 * m23;\n                var tmp_9  = m22 * m03;\n                var tmp_10 = m02 * m13;\n                var tmp_11 = m12 * m03;\n                var tmp_12 = m20 * m31;\n                var tmp_13 = m30 * m21;\n                var tmp_14 = m10 * m31;\n                var tmp_15 = m30 * m11;\n                var tmp_16 = m10 * m21;\n                var tmp_17 = m20 * m11;\n                var tmp_18 = m00 * m31;\n                var tmp_19 = m30 * m01;\n                var tmp_20 = m00 * m21;\n                var tmp_21 = m20 * m01;\n                var tmp_22 = m00 * m11;\n                var tmp_23 = m10 * m01;\n\n                var t0 = (tmp_0 * m11 + tmp_3 * m21 + tmp_4 * m31) -\n                    (tmp_1 * m11 + tmp_2 * m21 + tmp_5 * m31);\n                var t1 = (tmp_1 * m01 + tmp_6 * m21 + tmp_9 * m31) -\n                    (tmp_0 * m01 + tmp_7 * m21 + tmp_8 * m31);\n                var t2 = (tmp_2 * m01 + tmp_7 * m11 + tmp_10 * m31) -\n                    (tmp_3 * m01 + tmp_6 * m11 + tmp_11 * m31);\n                var t3 = (tmp_5 * m01 + tmp_8 * m11 + tmp_11 * m21) -\n                    (tmp_4 * m01 + tmp_9 * m11 + tmp_10 * m21);\n\n                var d = 1.0 / (m00 * t0 + m10 * t1 + m20 * t2 + m30 * t3);\n\n                dst[ 0] = d * t0;\n                dst[ 1] = d * t1;\n                dst[ 2] = d * t2;\n                dst[ 3] = d * t3;\n                dst[ 4] = d * ((tmp_1 * m10 + tmp_2 * m20 + tmp_5 * m30) -\n                        (tmp_0 * m10 + tmp_3 * m20 + tmp_4 * m30));\n                dst[ 5] = d * ((tmp_0 * m00 + tmp_7 * m20 + tmp_8 * m30) -\n                        (tmp_1 * m00 + tmp_6 * m20 + tmp_9 * m30));\n                dst[ 6] = d * ((tmp_3 * m00 + tmp_6 * m10 + tmp_11 * m30) -\n                        (tmp_2 * m00 + tmp_7 * m10 + tmp_10 * m30));\n                dst[ 7] = d * ((tmp_4 * m00 + tmp_9 * m10 + tmp_10 * m20) -\n                        (tmp_5 * m00 + tmp_8 * m10 + tmp_11 * m20));\n                dst[ 8] = d * ((tmp_12 * m13 + tmp_15 * m23 + tmp_16 * m33) -\n                        (tmp_13 * m13 + tmp_14 * m23 + tmp_17 * m33));\n                dst[ 9] = d * ((tmp_13 * m03 + tmp_18 * m23 + tmp_21 * m33) -\n                        (tmp_12 * m03 + tmp_19 * m23 + tmp_20 * m33));\n                dst[10] = d * ((tmp_14 * m03 + tmp_19 * m13 + tmp_22 * m33) -\n                        (tmp_15 * m03 + tmp_18 * m13 + tmp_23 * m33));\n                dst[11] = d * ((tmp_17 * m03 + tmp_20 * m13 + tmp_23 * m23) -\n                        (tmp_16 * m03 + tmp_21 * m13 + tmp_22 * m23));\n                dst[12] = d * ((tmp_14 * m22 + tmp_17 * m32 + tmp_13 * m12) -\n                        (tmp_16 * m32 + tmp_12 * m12 + tmp_15 * m22));\n                dst[13] = d * ((tmp_20 * m32 + tmp_12 * m02 + tmp_19 * m22) -\n                        (tmp_18 * m22 + tmp_21 * m32 + tmp_13 * m02));\n                dst[14] = d * ((tmp_18 * m12 + tmp_23 * m32 + tmp_15 * m02) -\n                        (tmp_22 * m32 + tmp_14 * m02 + tmp_19 * m12));\n                dst[15] = d * ((tmp_22 * m22 + tmp_16 * m02 + tmp_21 * m12) -\n                        (tmp_20 * m12 + tmp_23 * m22 + tmp_17 * m02));\n                return target;\n            });\n\n    mod.transpose = new Sk.builtin.func(function(target, mat)\n            {\n                var dst = target.v;\n                var m = mat.v;\n                for (var j = 0; j < 4; ++j) {\n                    for (var i = 0; i < 4; ++i)\n                    dst[j * 4 + i] = m[i * 4 + j];\n                }\n                return dst;\n            });\n\n    return mod;\n};\n',
    'src/lib/webgl/__init__.js': 'var $builtinmodule = function(name)\n{\n  var mod = {};\n\n  var makeFailHTML = function(msg) {\n    return \'\' +\n      \'<table style="background-color: #8CE; width: 100%; height: 100%;"><tr>\' +\n      \'<td align="center">\' +\n      \'<div style="display: table-cell; vertical-align: middle;">\' +\n      \'<div style="">\' + msg + \'</div>\' +\n      \'</div>\' +\n      \'</td></tr></table>\';\n  };\n\n  var GET_A_WEBGL_BROWSER = \'\' +\n    \'This page requires a browser that supports WebGL.<br/>\' +\n    \'<a href="http://get.webgl.org">Click here to upgrade your browser.</a>\';\n\n  var NEED_HARDWARE = \'\' +\n    "It doesn\'t appear your computer can support WebGL.<br/>" +\n    \'<a href="http://get.webgl.org">Click here for more information.</a>\';\n  \n  var create3DContext = function(canvas) {\n    var names = ["webgl", "experimental-webgl", "webkit-3d", "moz-webgl"];\n    var gl = null;\n    for (var ii = 0; ii < names.length; ++ii) {\n      try {\n        gl = canvas.getContext(names[ii]);\n      }\n      catch(e) {\n      }\n      if (gl) {\n          break;\n      }\n    }\n    if (gl) {\n      // Disallow selection by default. This keeps the cursor from changing to an\n      // I-beam when the user clicks and drags. It\'s easier on the eyes.\n      function returnFalse() {\n        return false;\n      }\n\n      canvas.onselectstart = returnFalse;\n      canvas.onmousedown = returnFalse;\n    }\n    return gl;\n  };\n\n  var setupWebGL = function(canvasContainerId, opt_canvas) {\n    var container = document.getElementById(canvasContainerId);\n    var context;\n    if (!opt_canvas) {\n      opt_canvas = container.getElementsByTagName("canvas")[0];\n    }\n    if (!opt_canvas) {\n        // this browser doesn\'t support the canvas tag at all. Not even 2d.\n      container.innerHTML = makeFailHTML(GET_A_WEBGL_BROWSER);\n      return;\n    }\n\n    var gl = create3DContext(opt_canvas);\n    if (!gl) {\n      // TODO(gman): fix to official way to detect that it\'s the user\'s machine, not the browser.\n      var browserStrings = navigator.userAgent.match(/(\\w+\\/.*? )/g);\n      var browsers = {};\n      try {\n        for (var b = 0; b < browserStrings.length; ++b) {\n          var parts = browserStrings[b].match(/(\\w+)/g);\n          var bb = [];\n          for (var ii = 1; ii < parts.length; ++ii) {\n            bb.push(parseInt(parts[ii]));\n          }\n          browsers[parts[0]] = bb;\n        }\n      }\n      catch (e) {\n      }\n      if (browsers.Chrome &&\n           (browsers.Chrome[0] > 7 ||\n                 (browsers.Chrome[0] == 7 && browsers.Chrome[1] > 0) ||\n                 (browsers.Chrome[0] == 7 && browsers.Chrome[1] == 0 && browsers.Chrome[2] >= 521))) {\n        container.innerHTML = makeFailHTML(NEED_HARDWARE);\n      }\n      else {\n        container.innerHTML = makeFailHTML(GET_A_WEBGL_BROWSER);\n      }\n    }\n    return gl;\n  };\n\n  /**\n   * The Context encapsulates the underlying WebGL native JavaScript API.\n   */\n  mod.Context = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(\n      function(self, canvasid) {\n        var canvas = document.getElementById(canvasid.v);\n        var gl = setupWebGL(canvasid.v, canvas)\n        if (!gl) {\n          throw new Error("Your browser does not appear to support WebGL.");\n        }\n\n        self.gl = gl;\n\n        // Copy symbolic constants and functions from native WebGL, encapsulating where necessary.       \n        for (var k in gl.__proto__) {\n          if (typeof gl.__proto__[k] === \'number\') {\n            Sk.abstr.objectSetItem(self[\'$d\'], new Sk.builtin.str(k), gl.__proto__[k]);\n          }\n          else if (typeof gl.__proto__[k] === "function") {\n            switch(k) {\n              case \'bufferData\': {\n              }\n              break;\n              case \'clearColor\': {\n              }\n              break;\n              case \'drawArrays\': {\n              }\n              break;\n              case \'getAttribLocation\': {\n              }\n              break;\n              case \'getUniformLocation\': {\n              }\n              break;\n              case \'shaderSource\': {\n              }\n              break;\n              case \'uniformMatrix4fv\': {\n              }\n              break;\n              case \'vertexAttribPointer\': {\n              }\n              break;\n              case \'viewport\': {\n              }\n              break;\n              default: {\n                (function(key) {\n                  Sk.abstr.objectSetItem(self[\'$d\'], new Sk.builtin.str(k), new Sk.builtin.func(function() {\n                    var f = gl.__proto__[key];\n                    return f.apply(gl, arguments);\n                  }));\n                 }(k));\n              }\n            }\n          }\n        }\n\n        gl.clearColor(100.0/255.0, 149.0/255.0, 237.0/255.0, 1.0);\n        gl.clear(gl.COLOR_BUFFER_BIT);\n      }\n    );\n\n    $loc.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;\n\n    $loc.bufferData = new Sk.builtin.func(\n      function(self, target, data, usage) {\n        self.gl.bufferData(target, data.v, usage);\n      }\n    );\n\n    $loc.clearColor = new Sk.builtin.func(\n      function(self, red, green, blue, alpha) {\n        self.gl.clearColor(Sk.builtin.asnum$(red), Sk.builtin.asnum$(green), Sk.builtin.asnum$(blue), Sk.builtin.asnum$(alpha));\n      }\n    );\n\n    $loc.getAttribLocation = new Sk.builtin.func(\n      function(self, program, name) {\n        return self.gl.getAttribLocation(program, name.v);\n      }\n    );\n\n    $loc.getUniformLocation = new Sk.builtin.func(\n      function(self, program, name) {\n        return self.gl.getUniformLocation(program, name.v);\n      }\n    );\n\n    $loc.shaderSource = new Sk.builtin.func(\n      function(self, shader, src) {\n        self.gl.shaderSource(shader, src.v);\n      }\n    );\n\n    $loc.drawArrays = new Sk.builtin.func(\n      function(self, mode, first, count) {\n        self.gl.drawArrays(Sk.builtin.asnum$(mode), Sk.builtin.asnum$(first), Sk.builtin.asnum$(count));\n      }\n    );\n\n    $loc.vertexAttribPointer = new Sk.builtin.func(\n      function(self, index, size, type, normalized, stride, dunno) {\n        self.gl.vertexAttribPointer(index, Sk.builtin.asnum$(size), Sk.builtin.asnum$(type), normalized, Sk.builtin.asnum$(stride), Sk.builtin.asnum$(dunno));\n      }\n    );\n\n    $loc.viewport = new Sk.builtin.func(\n      function(self, x, y, width, height) {\n        self.gl.viewport(Sk.builtin.asnum$(x), Sk.builtin.asnum$(y), Sk.builtin.asnum$(width), Sk.builtin.asnum$(height));\n      }\n    );\n\n    $loc.uniformMatrix4fv = new Sk.builtin.func(\n      function(self, location, transpose, values) {\n//        console.log("location  " + (typeof location));\n//        console.log("transpose " + (typeof transpose));\n//        console.log("values.v  " + (typeof values.v));\n        self.gl.uniformMatrix4fv(Sk.builtin.asnum$(location), transpose, values.v);\n      }\n    );\n\n    $loc.setDrawFunc = new Sk.builtin.func(function(self, func) {\n      var startTime = (new Date()).getTime();\n      var intervalId = setInterval(\n        function() {\n          Sk.misceval.callsim(func, self, (new Date()).getTime() - startTime);\n        }, 1000.0 / 60.0); // 60 fps\n    });\n\n  }, \'Context\', []);\n\n  mod.Float32Array = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self, data) {\n      if (typeof data === "number") {\n        self.v = new Float32Array(data);\n      }\n      else {\n        self.v = new Float32Array(Sk.ffi.remapToJs(data));\n      }\n    });\n\n    $loc.__repr__ = new Sk.builtin.func(function(self) {\n      var copy = [];\n      for (var i = 0; i < self.v.length; ++i) {\n        copy.push(self.v[i]);\n      }\n      return new Sk.builtin.str("[" + copy.join(\', \') + "]");\n     });\n  }, \'Float32Array\', []);\n\n  /**\n   * A 4x4 (mutable) matrix suitable for OpenGL.\n   *\n   * Mutability is chosen for performance.\n   * The inderlying implementation is Float32Array.\n   * The indexing of the elements is\n   * 0 4  8 12\n   * 1 5  9 13\n   * 2 6 10 14\n   * 3 7 11 15\n   */\n  mod.Matrix4x4 = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self, data) {\n      self.v = new Float32Array(Sk.ffi.remapToJs(data));\n    });\n\n    $loc.identity = new Sk.builtin.func(\n      function(self) {\n\n        var m = self.v;\n\n        m[0]  = 1;\n        m[1]  = 0;\n        m[2]  = 0;\n        m[3]  = 0;\n\n        m[4]  = 0;\n        m[5]  = 1;\n        m[6]  = 0;\n        m[7]  = 0;\n\n        m[8]  = 0;\n        m[9]  = 0;\n        m[10] = 1;\n        m[11] = 0;\n\n        m[12] = 0;\n        m[13] = 0;\n        m[14] = 0;\n        m[15] = 1;\n      }\n    );\n\n    $loc.perspective = new Sk.builtin.func(\n      function(self, fov, aspect, near, far) {\n        \n        var t = Math.tan(Math.PI * 0.5 - 0.5 * (Sk.builtin.asnum$(fov) * Math.PI / 180));\n        var a = Sk.builtin.asnum$(aspect)\n        var n = Sk.builtin.asnum$(near)\n        var f = Sk.builtin.asnum$(far)\n        var k = 1.0 / (n - f);\n\n        var m = self.v;\n\n        m[0]  = t / a;\n        m[1]  = 0;\n        m[2]  = 0;\n        m[3]  = 0;\n\n        m[4]  = 0;\n        m[5]  = t;\n        m[6]  = 0;\n        m[7]  = 0;\n\n        m[8]  = 0;\n        m[9]  = 0;\n        m[10] = (n + f) * k;\n        m[11] = -1;\n\n        m[12] = 0;\n        m[13] = 0;\n        m[14] = n * f * k * 2;\n        m[15] = 0;\n      }\n    );\n\n    $loc.translate = new Sk.builtin.func(\n      function(self, translation) {\n\n        var m = self.v;\n        var t = Sk.ffi.remapToJs(translation);\n\n        m[0]  = 1;\n        m[1]  = 0;\n        m[2]  = 0;\n        m[3]  = 0;\n\n        m[4]  = 0;\n        m[5]  = 1;\n        m[6]  = 0;\n        m[7]  = 0;\n\n        m[8]  = 0;\n        m[9]  = 0;\n        m[10] = 1;\n        m[11] = 0;\n\n        m[12] = t[0];\n        m[13] = t[1];\n        m[14] = t[2];\n        m[15] = 1;\n      }\n    );\n\n    $loc.__repr__ = new Sk.builtin.func(function(self) {\n      var copy = [];\n      for (var i = 0; i < self.v.length; ++i) {\n        copy.push(self.v[i]);\n      }\n      return new Sk.builtin.str("[" + copy.join(\', \') + "]");\n     });\n  }, \'Matrix4x4\', []);\n\n  return mod;\n};',
    'src/builtin/sys.js': 'var $builtinmodule = function(name)\n{\n    var sys = {};\n\n    var args = [];\n    var argv = Sk.getSysArgv();\n    for (var i = 0; i < argv.length; ++i)\n        args.push(new Sk.builtin.str(argv[i]));\n    sys.argv = new Sk.builtins[\'list\'](args);\n\n    sys.copyright = Sk.builtin[\'str\']("Copyright 2009-2010 Scott Graham.\\nAll Rights Reserved.\\n");\n\n    sys.modules = Sk.sysmodules;\n\n    sys.path = Sk.realsyspath;\n\n    sys.getExecutionLimit = new Sk.builtin.func(function() {\n        return Sk.execLimit\n    });\n\n    sys.setExecutionLimit = new Sk.builtin.func(function(t) {\n        if (t !==  undefined) {\n            Sk.execLimit = t\n        }\n    });\n\n    sys.resetTimeout = new Sk.builtin.func(function() {\n        Sk.execStart = new Date();\n    });\n\n    sys.debug = new Sk.builtin.func(function() {\n        debugger;\n    });\n\n    return sys;\n};\n',
    'src/lib/pythonds/trees/balance.py': '#!/bin/env python3.1\n# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005, 2010\n# \n\nfrom .bst import BinarySearchTree, TreeNode\n\nclass AVLTree(BinarySearchTree):\n    \'\'\'\n    Author:  Brad Miller\n    Date:  1/15/2005\n    Description:  Imlement a binary search tree with the following interface\n                  functions:  \n                  __contains__(y) <==> y in x\n                  __getitem__(y) <==> x[y]\n                  __init__()\n                  __len__() <==> len(x)\n                  __setitem__(k,v) <==> x[k] = v\n                  clear()\n                  get(k)\n                  has_key(k)\n                  items() \n                  keys() \n                  values()\n                  put(k,v)\n    \'\'\'\n\n\n    def _put(self,key,val,currentNode):\n        if key < currentNode.key:\n            if currentNode.hasLeftChild():\n                self._put(key,val,currentNode.leftChild)\n            else:\n                currentNode.leftChild = TreeNode(key,val,parent=currentNode)\n                self.updateBalance(currentNode.leftChild)\n        else:\n            if currentNode.hasRightChild():\n                self._put(key,val,currentNode.rightChild)\n            else:\n                currentNode.rightChild = TreeNode(key,val,parent=currentNode)\n                self.updateBalance(currentNode.rightChild)                \n\n    def updateBalance(self,node):\n        if node.balanceFactor > 1 or node.balanceFactor < -1:\n            self.rebalance(node)\n            return\n        if node.parent != None:\n            if node.isLeftChild():\n                node.parent.balanceFactor += 1\n            elif node.isRightChild():\n                node.parent.balanceFactor -= 1\n\n            if node.parent.balanceFactor != 0:\n                self.updateBalance(node.parent)\n\n    def rebalance(self,node):\n        if node.balanceFactor < 0:\n            if node.rightChild.balanceFactor > 0:\n                # Do an LR Rotation\n                self.rotateRight(node.rightChild)\n                self.rotateLeft(node)\n            else:\n                # single left\n                self.rotateLeft(node)\n        elif node.balanceFactor > 0:\n            if node.leftChild.balanceFactor < 0:\n                # Do an RL Rotation\n                self.rotateLeft(node.leftChild)\n                self.rotateRight(node)\n            else:\n                # single right\n                self.rotateRight(node)\n\n    def rotateLeft(self,rotRoot):\n        newRoot = rotRoot.rightChild\n        rotRoot.rightChild = newRoot.leftChild\n        if newRoot.leftChild != None:\n            newRoot.leftChild.parent = rotRoot\n        newRoot.parent = rotRoot.parent\n        if rotRoot.isRoot():\n            self.root = newRoot\n        else:\n            if rotRoot.isLeftChild():\n                rotRoot.parent.leftChild = newRoot\n            else:\n                rotRoot.parent.rightChild = newRoot\n        newRoot.leftChild = rotRoot\n        rotRoot.parent = newRoot\n        rotRoot.balanceFactor = rotRoot.balanceFactor + 1 - min(newRoot.balanceFactor, 0)\n        newRoot.balanceFactor = newRoot.balanceFactor + 1 + max(rotRoot.balanceFactor, 0)\n\n\n    def rotateRight(self,rotRoot):\n        newRoot = rotRoot.leftChild\n        rotRoot.leftChild = newRoot.rightChild\n        if newRoot.rightChild != None:\n            newRoot.rightChild.parent = rotRoot\n        newRoot.parent = rotRoot.parent\n        if rotRoot.isRoot():\n            self.root = newRoot\n        else:\n            if rotRoot.isRightChild():\n                rotRoot.parent.rightChild = newRoot\n            else:\n                rotRoot.parent.leftChild = newRoot\n        newRoot.rightChild = rotRoot\n        rotRoot.parent = newRoot\n        rotRoot.balanceFactor = rotRoot.balanceFactor - 1 - max(newRoot.balanceFactor, 0)\n        newRoot.balanceFactor = newRoot.balanceFactor - 1 + min(rotRoot.balanceFactor, 0)\n        \n',
    'src/lib/urllib/request/__init__.js': 'var $builtinmodule = function(name)\n{\n  var request = {};\n\n\n  //~ Classes .................................................................\n\n  // Response class\n  //\n  // Response objects are returned by the request, get, post, etc.\n  // methods, allowing the user to access the response text, status\n  // code, and other information.\n\n  // ------------------------------------------------------------\n  var response = function($gbl, $loc) {\n\n    // ------------------------------------------------------------\n    $loc.__init__ = new Sk.builtin.func(function(self, xhr) {\n      self.data$ = xhr.responseText;\n      self.lineList = self.data$.split("\\n");\n      self.lineList = self.lineList.slice(0,-1);\n      for(var i =0 ; i < self.lineList.length; i++) {\n        self.lineList[i] = self.lineList[i]+\'\\n\';\n      }\n      self.currentLine = 0;\n      self.pos$ = 0;\n    });\n\n\n    // ------------------------------------------------------------\n    $loc.__str__ = new Sk.builtin.func(function(self) {\n      return Sk.ffi.remapToPy(\'<Response>\');\n    });\n\n\n    // ------------------------------------------------------------\n    $loc.__iter__ = new Sk.builtin.func(function(self) {\n      var allLines = self.lineList;\n\n      return Sk.builtin.makeGenerator(function() {\n          if (this.$index >= this.$lines.length) return undefined;\n          return new Sk.builtin.str(this.$lines[this.$index++]);\n        }, {\n          $obj: self,\n          $index: 0,\n          $lines: allLines\n        });\n    });\n\n\n    // ------------------------------------------------------------\n    $loc.read = new Sk.builtin.func(function(self, size) {\n      if (self.closed) throw new Sk.builtin.ValueError("I/O operation on closed file");\n      var len = self.data$.length;\n      if (size === undefined) size = len;\n      var ret = new Sk.builtin.str(self.data$.substr(self.pos$, size));\n      self.pos$ += size;\n      if (self.pos$ >= len) self.pos$ = len;\n      return ret;\n    });\n\n\n    // ------------------------------------------------------------\n    $loc.readline = new Sk.builtin.func(function(self, size) {\n      var line = "";\n      if (self.currentLine < self.lineList.length) {\n        line = self.lineList[self.currentLine];\n        self.currentLine++;\n      }\n      return new Sk.builtin.str(line);\n    });\n\n\n    // ------------------------------------------------------------\n    $loc.readlines = new Sk.builtin.func(function(self, sizehint) {\n      var arr = [];\n      for(var i = self.currentLine; i < self.lineList.length; i++) {\n        arr.push(new Sk.builtin.str(self.lineList[i]));\n      }\n      return new Sk.builtin.list(arr);\n    });\n\n  };\n\n  request.Response =\n    Sk.misceval.buildClass(request, response, \'Response\', []);\n\n\n  //~ Module functions ........................................................\n\n  // ------------------------------------------------------------\n  /**\n   * Constructs and sends a Request. Returns Response object.\n   *\n   * http://docs.python-requests.org/en/latest/api/#requests.request\n   *\n   * For now, this implementation doesn\'t actually construct a Request\n   * object; it just makes the request through jQuery.ajax and then\n   * constructs a Response.\n   */\n  request.urlopen = new Sk.builtin.func(function(url, data, timeout) {\n    var xmlhttp = new XMLHttpRequest();\n    xmlhttp.open("GET",url.v,false);\n    xmlhttp.send(null);\n\n    return Sk.misceval.callsim(request.Response,xmlhttp)\n  });\n\n\n  return request;\n};\n',
    'src/lib/pythonds/basic/queue.py': '# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005\n# \n#queue.py\r\n\r\nclass Queue:\r\n    def __init__(self):\r\n        self.items = []\r\n\r\n    def isEmpty(self):\r\n        return self.items == []\r\n\r\n    def enqueue(self, item):\r\n        self.items.insert(0,item)\r\n\r\n    def dequeue(self):\r\n        return self.items.pop()\r\n\r\n    def size(self):\r\n        return len(self.items)\r\n',
    'src/lib/pythonds/graphs/adjGraph.py': '#\n#  adjGraph\n#\n#  Created by Brad Miller on 2005-02-24.\n#  Copyright (c) 2005 Brad Miller, David Ranum, Luther College. All rights reserved.\n#\n\nimport sys\nimport os\nimport unittest\n\nclass Graph:\n    def __init__(self):\n        self.vertices = {}\n        self.numVertices = 0\n        \n    def addVertex(self,key):\n        self.numVertices = self.numVertices + 1\n        newVertex = Vertex(key)\n        self.vertices[key] = newVertex\n        return newVertex\n    \n    def getVertex(self,n):\n        if n in self.vertices:\n            return self.vertices[n]\n        else:\n            return None\n\n    def __contains__(self,n):\n        return n in self.vertices\n    \n    def addEdge(self,f,t,cost=0):\n            if f not in self.vertices:\n                nv = self.addVertex(f)\n            if t not in self.vertices:\n                nv = self.addVertex(t)\n            self.vertices[f].addNeighbor(self.vertices[t],cost)\n    \n    def getVertices(self):\n        return list(self.vertices.keys())\n        \n    def __iter__(self):\n        return iter(self.vertices.values())\n                \nclass Vertex:\n    def __init__(self,num):\n        self.id = num\n        self.connectedTo = {}\n        self.color = \'white\'\n        self.dist = sys.maxsize\n        self.pred = None\n        self.disc = 0\n        self.fin = 0\n\n    # def __lt__(self,o):\n    #     return self.id < o.id\n    \n    def addNeighbor(self,nbr,weight=0):\n        self.connectedTo[nbr] = weight\n        \n    def setColor(self,color):\n        self.color = color\n        \n    def setDistance(self,d):\n        self.dist = d\n\n    def setPred(self,p):\n        self.pred = p\n\n    def setDiscovery(self,dtime):\n        self.disc = dtime\n        \n    def setFinish(self,ftime):\n        self.fin = ftime\n        \n    def getFinish(self):\n        return self.fin\n        \n    def getDiscovery(self):\n        return self.disc\n        \n    def getPred(self):\n        return self.pred\n        \n    def getDistance(self):\n        return self.dist\n        \n    def getColor(self):\n        return self.color\n    \n    def getConnections(self):\n        return self.connectedTo.keys()\n        \n    def getWeight(self,nbr):\n        return self.connectedTo[nbr]\n                \n    def __str__(self):\n        return str(self.id) + ":color " + self.color + ":disc " + str(self.disc) + ":fin " + str(self.fin) + ":dist " + str(self.dist) + ":pred \\n\\t[" + str(self.pred)+ "]\\n"\n    \n    def getId(self):\n        return self.id\n\nclass adjGraphTests(unittest.TestCase):\n    def setUp(self):\n        self.tGraph = Graph()\n        \n    def testMakeGraph(self):\n        gFile = open("test.dat")\n        for line in gFile:\n            fVertex, tVertex = line.split(\'|\')\n            fVertex = int(fVertex)\n            tVertex = int(tVertex)\n            self.tGraph.addEdge(fVertex,tVertex)\n        for i in self.tGraph:\n            adj = i.getAdj()\n            for k in adj:\n                print(i, k)\n\n        \nif __name__ == \'__main__\':\n    unittest.main()\n              \n',
    'src/lib/easel/__init__.js': '/**\n * Geometric Algebra (e2ga) module.\n *\n * David Holmes (david.geo.holmes@gmail.com)\n */\nvar $builtinmodule = function(name) {\n\n  var CONTAINER                  = "Container";\n  var EASE                       = "Ease";\n  var EUCLIDEAN_2                = "Euclidean2";\n  var EVENT                      = "Event";\n  var GRAPHICS                   = "Graphics";\n  var MOVIE_CLIP                 = "MovieClip";\n  var POINT                      = "Point";\n  var SHAPE                      = "Shape";\n  var STAGE                      = "Stage";\n  var TEXT                       = "Text";\n  var TICKER                     = "Ticker";\n  var TWEEN                      = "Tween";\n\n  var PROP_ALPHA                 = "alpha";\n  var PROP_AUTO_CLEAR            = "autoClear";\n  var PROP_BOUNCE_OUT            = "bounceOut";\n  var PROP_CANVAS                = "canvas";\n  var PROP_GRAPHICS              = "graphics";\n  var PROP_HIT_AREA              = "hitArea";\n  var PROP_MOUSE_IN_BOUNDS       = "mouseInBounds";\n  var PROP_MOUSE_MOVE_OUTSIDE    = "mouseMoveOutside";\n  var PROP_MOUSE_X               = "mouseX";\n  var PROP_MOUSE_Y               = "mouseY";\n  var PROP_NAME                  = "name";\n  var PROP_ROTATION              = "rotation";\n  var PROP_TEXT                  = "text";\n  var PROP_TEXT_ALIGN            = "textAlign";\n  var PROP_TIMELINE              = "timeline";\n  var PROP_W                     = "w";\n  var PROP_X                     = "x";\n  var PROP_Y                     = "y";\n  var PROP_XY                    = "xy";\n\n  var METHOD_ADD_CHILD           = "addChild";\n  var METHOD_ADD_EVENT_LISTENER  = "addEventListener";\n  var METHOD_ADD_TWEEN           = "addTween";\n  var METHOD_BEGIN_FILL          = "beginFill";\n  var METHOD_BEGIN_STROKE        = "beginStroke";\n  var METHOD_CALL                = "onComplete";\n  var METHOD_CLONE               = "clone";\n  var METHOD_DRAW_CIRCLE         = "drawCircle";\n  var METHOD_DRAW_RECT           = "drawRect";\n  var METHOD_ENABLE_MOUSE_OVER   = "enableMouseOver";\n  var METHOD_END_FILL            = "endFill";\n  var METHOD_END_STROKE          = "endStroke";\n  var METHOD_GET                 = "get";\n  var METHOD_GET_CHILD_AT        = "getChildAt";\n  var METHOD_GET_NUM_CHILDREN    = "getNumChildren";\n  var METHOD_GET_MEASURED_HEIGHT = "getMeasuredHeight";\n  var METHOD_GET_MEASURED_WIDTH  = "getMeasuredWidth";\n  var METHOD_GLOBAL_TO_LOCAL     = "globalToLocal";\n  var METHOD_GOTO_AND_PLAY       = "gotoAndPlay";\n  var METHOD_HIT_TEST            = "hitTest";\n  var METHOD_LENGTH              = "length";\n  var METHOD_LOCAL_TO_LOCAL      = "localToLocal";\n  var METHOD_LINE_TO             = "lineTo";\n  var METHOD_MOVE_TO             = "moveTo";\n  var METHOD_SET_STROKE_STYLE    = "setStrokeStyle";\n  var METHOD_TO                  = "to";\n  var METHOD_UPDATE              = "update";\n  var METHOD_WAIT                = "wait";\n\n  var mod = {};\n\n  mod[EVENT] = Sk.builtin.buildEventClass(mod);\n\n  mod[GRAPHICS] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self, graphicsPy) {\n      self.tp$name = GRAPHICS;\n      var graphics = Sk.ffi.remapToJs(graphicsPy);\n      if (graphics) {\n        self.v = graphics;\n      }\n      else {\n        if (typeof createjs[GRAPHICS] === \'undefined\') {\n          throw new Error("Missing " + GRAPHICS + " JavaScript implementation.");\n        }\n        self.v = new createjs[GRAPHICS]();\n      }\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(graphicsPy, name) {\n      var graphics = Sk.ffi.remapToJs(graphicsPy);\n      switch(name) {\n        case METHOD_BEGIN_FILL: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_BEGIN_FILL;\n              self.v = graphics[METHOD_BEGIN_FILL];\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, color) {\n              color = Sk.ffi.remapToJs(color);\n              graphics[METHOD_BEGIN_FILL](color);\n              return graphicsPy;\n            });\n          }, METHOD_BEGIN_FILL, []));\n        }\n        case METHOD_BEGIN_STROKE: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_BEGIN_STROKE;\n              self.v = graphics[METHOD_BEGIN_STROKE];\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, color) {\n              color = Sk.ffi.remapToJs(color);\n              graphics[METHOD_BEGIN_STROKE](color);\n              return graphicsPy;\n            });\n          }, METHOD_BEGIN_STROKE, []));\n        }\n        case METHOD_DRAW_CIRCLE: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_DRAW_CIRCLE;\n              self.v = graphics[METHOD_DRAW_CIRCLE];\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, x, y, radius) {\n              x = Sk.ffi.remapToJs(x);\n              y = Sk.ffi.remapToJs(y);\n              radius = Sk.ffi.remapToJs(radius);\n              graphics[METHOD_DRAW_CIRCLE](x, y, radius);\n              return graphicsPy;\n            });\n          }, METHOD_DRAW_CIRCLE, []));\n        }\n        case METHOD_DRAW_RECT: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_DRAW_RECT;\n              self.v = graphics[METHOD_DRAW_RECT];\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, x, y, w, h) {\n              x = Sk.ffi.remapToJs(x);\n              y = Sk.ffi.remapToJs(y);\n              w = Sk.ffi.remapToJs(w);\n              h = Sk.ffi.remapToJs(h);\n              graphics[METHOD_DRAW_RECT](x, y, w, h);\n              return graphicsPy;\n            });\n          }, METHOD_DRAW_RECT, []));\n        }\n        case METHOD_END_FILL: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_END_FILL;\n              self.v = graphics[METHOD_END_FILL];\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self) {\n              graphics[METHOD_END_FILL]();\n              return graphicsPy;\n            });\n          }, METHOD_END_FILL, []));\n        }\n        case METHOD_END_STROKE: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_END_STROKE;\n              self.v = graphics[METHOD_END_STROKE];\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self) {\n              graphics[METHOD_END_STROKE]();\n              return graphicsPy;\n            });\n          }, METHOD_END_STROKE, []));\n        }\n        case METHOD_LINE_TO: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_LINE_TO;\n              self.v = graphics[METHOD_LINE_TO];\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, x, y) {\n              x = Sk.ffi.remapToJs(x);\n              y = Sk.ffi.remapToJs(y);\n              graphics[METHOD_LINE_TO](x, y);\n              return graphicsPy;\n            });\n          }, METHOD_LINE_TO, []));\n        }\n        case METHOD_MOVE_TO: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_MOVE_TO;\n              self.v = graphics[METHOD_MOVE_TO];\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, x, y) {\n              x = Sk.ffi.remapToJs(x);\n              y = Sk.ffi.remapToJs(y);\n              graphics[METHOD_MOVE_TO](x, y);\n              return graphicsPy;\n            });\n          }, METHOD_MOVE_TO, []));\n        }\n        case METHOD_SET_STROKE_STYLE: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_SET_STROKE_STYLE;\n              self.v = graphics[METHOD_SET_STROKE_STYLE];\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, thickness, caps, joints, miterLimit, ignoreScale) {\n              thickness = Sk.ffi.remapToJs(thickness);\n              caps = Sk.ffi.remapToJs(caps);\n              joints = Sk.ffi.remapToJs(joints);\n              miterLimit = Sk.ffi.remapToJs(miterLimit);\n              ignoreScale = Sk.ffi.remapToJs(ignoreScale);\n              graphics[METHOD_SET_STROKE_STYLE](thickness, caps, joints, miterLimit, ignoreScale);\n              return graphicsPy;\n            });\n          }, METHOD_SET_STROKE_STYLE, []));\n        }\n      }\n    });\n  }, GRAPHICS, []);\n\n  mod[MOVIE_CLIP] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self, modePy, startPositionPy, loopPy, labelsPy) {\n      var mode = (modePy !== null) ? Sk.ffi.remapToJs(modePy) : null;\n      var startPosition = Sk.ffi.remapToJs(startPositionPy);\n      var loop = Sk.ffi.remapToJs(loopPy);\n      var labels = Sk.ffi.remapToJs(labelsPy);\n      self.tp$name = MOVIE_CLIP;\n      if (typeof createjs[MOVIE_CLIP] === \'undefined\') {\n        throw new Error("Missing " + MOVIE_CLIP + " JavaScript implementation.");\n      }\n      self.v = new createjs[MOVIE_CLIP](mode, startPosition, loop, labels);\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(movieClipPy, name) {\n      var movieClip = Sk.ffi.remapToJs(movieClipPy);\n      switch(name) {\n        case PROP_TIMELINE: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = PROP_TIMELINE;\n              self.v = movieClip.timeline;\n            });\n            $loc.__getattr__ = new Sk.builtin.func(function(timelinePy, name) {\n              var timeline = Sk.ffi.remapToJs(timelinePy);\n              switch(name) {\n                case METHOD_ADD_TWEEN: {\n                  return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n                    $loc.__init__ = new Sk.builtin.func(function(self) {\n                      self.tp$name = METHOD_ADD_TWEEN;\n                      self.v = timeline[METHOD_ADD_TWEEN];\n                    });\n                    $loc.__call__ = new Sk.builtin.func(function(self, tweenPy) {\n                      var tween = Sk.ffi.remapToJs(tweenPy);\n                      timeline.addTween(tween);\n                    });\n                  }, METHOD_ADD_TWEEN, []));\n                }\n                break;\n              }\n            });\n          }, PROP_TIMELINE, []));\n        }\n        break;\n        case METHOD_GOTO_AND_PLAY: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_GOTO_AND_PLAY;\n              self.v = movieClip[METHOD_GOTO_AND_PLAY];\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, labelPy) {\n              var label = Sk.ffi.remapToJs(labelPy);\n              movieClip[METHOD_GOTO_AND_PLAY](label);\n            });\n          }, METHOD_GOTO_AND_PLAY, []));\n        }\n        break;\n       }\n    });\n  }, MOVIE_CLIP, []);\n\n  mod[SHAPE] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(shapePy, argPy) {\n      shapePy.tp$name = SHAPE;\n      if (typeof argPy === \'undefined\') {\n        shapePy.v = new createjs[SHAPE]();\n      }\n      else {\n        var name = argPy.tp$name;\n        if (typeof name === \'string\') {\n          switch(name) {\n            case SHAPE: {\n              shapePy.v = Sk.ffi.remapToJs(argPy);\n            }\n            break;\n            case GRAPHICS: {\n              shapePy.v = new createjs[SHAPE](Sk.ffi.remapToJs(argPy));\n            }\n            break;\n            default: {\n              throw new Error(name);\n            }\n          }\n        }\n        else {\n          throw new Error(typeof name);\n        }\n      }\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(shapePy, name) {\n      var shape = Sk.ffi.remapToJs(shapePy);\n      switch(name) {\n        case PROP_ALPHA: {\n          return Sk.builtin.assk$(shape[PROP_ALPHA], Sk.builtin.nmber.float$);\n        }\n        case PROP_GRAPHICS: {\n          return Sk.misceval.callsim(mod[GRAPHICS], Sk.ffi.referenceToPy(shape.graphics, GRAPHICS));\n        }\n        case PROP_NAME: {\n          return new Sk.builtin.str(shape[PROP_NAME]);\n        }\n        case PROP_X: {\n          return Sk.builtin.assk$(shape[PROP_X], Sk.builtin.nmber.int$);\n        }\n        case PROP_Y: {\n          return Sk.builtin.assk$(shape[PROP_Y], Sk.builtin.nmber.int$);\n        }\n        case PROP_ROTATION: {\n          return Sk.builtin.assk$(shape[PROP_ROTATION], Sk.builtin.nmber.float$);\n        }\n        case METHOD_ADD_EVENT_LISTENER: {\n          return Sk.builtin.addEventListener(mod, shape);\n        }\n        case METHOD_GLOBAL_TO_LOCAL: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_GLOBAL_TO_LOCAL;\n              self.v = shape[METHOD_GLOBAL_TO_LOCAL];\n            });\n            $loc.__call__ = new Sk.builtin.func(function(methodPy, x, y) {\n              var point = shape[METHOD_GLOBAL_TO_LOCAL](Sk.ffi.remapToJs(x), Sk.ffi.remapToJs(y));\n              return Sk.misceval.callsim(mod[POINT], Sk.ffi.referenceToPy(point, POINT));\n            });\n          }, METHOD_GLOBAL_TO_LOCAL, []));\n        }\n        case METHOD_HIT_TEST: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_HIT_TEST;\n              self.v = shape[METHOD_HIT_TEST];\n            });\n            $loc.__call__ = new Sk.builtin.func(function(methodPy, x, y) {\n              return Sk.ffi.remapToPy(shape[METHOD_HIT_TEST](Sk.ffi.remapToJs(x), Sk.ffi.remapToJs(y)));\n            });\n          }, METHOD_HIT_TEST, []));\n        }\n        case METHOD_LOCAL_TO_LOCAL: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_LOCAL_TO_LOCAL;\n              self.v = shape[METHOD_LOCAL_TO_LOCAL];\n            });\n            $loc.__call__ = new Sk.builtin.func(function(methodPy, x, y, target) {\n              var point = shape[METHOD_LOCAL_TO_LOCAL](Sk.ffi.remapToJs(x), Sk.ffi.remapToJs(y), Sk.ffi.remapToJs(target));\n              return Sk.misceval.callsim(mod[POINT], Sk.ffi.referenceToPy(point, POINT));\n            });\n          }, METHOD_LOCAL_TO_LOCAL, []));\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(shapePy, name, valuePy) {\n      var shape = Sk.ffi.remapToJs(shapePy);\n      var value = Sk.ffi.remapToJs(valuePy);\n      switch(name) {\n        case PROP_ALPHA: {\n          shape[PROP_ALPHA] = value;\n        }\n        break;\n        case PROP_NAME: {\n          shape[PROP_NAME] = value;\n        }\n        break;\n        case PROP_X: {\n          shape[PROP_X] = value;\n        }\n        break;\n        case PROP_Y: {\n          shape[PROP_Y] = value;\n        }\n        break;\n        case PROP_ROTATION: {\n          shape[PROP_ROTATION] = value;\n        }\n        break;\n        default: {\n          throw new Sk.builtin.AttributeError(name + " is not a writeable attribute of " + SHAPE);\n        }\n      }\n    });\n  }, SHAPE, []);\n\n  mod[STAGE] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self, canvasPy) {\n      var canvas = Sk.ffi.remapToJs(canvasPy);\n      self.tp$name = STAGE;\n      if (typeof createjs[STAGE] === \'undefined\') {\n        throw new Error("Missing " + STAGE + " JavaScript implementation.");\n      }\n      self.v = new createjs[STAGE](canvas);\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(stagePy, name) {\n      var stage = Sk.ffi.remapToJs(stagePy);\n      switch(name) {\n        case PROP_CANVAS: {\n          return Sk.builtin.assk$(5, Sk.builtin.nmber.int$);\n        }\n        case PROP_MOUSE_IN_BOUNDS: {\n          return Sk.ffi.remapToPy(stage[PROP_MOUSE_IN_BOUNDS]);\n        }\n        case PROP_MOUSE_MOVE_OUTSIDE: {\n          return Sk.ffi.remapToPy(stage[PROP_MOUSE_MOVE_OUTSIDE]);\n        }\n        case PROP_MOUSE_X: {\n          return Sk.builtin.assk$(stage[PROP_MOUSE_X], Sk.builtin.nmber.int$);\n        }\n        case PROP_MOUSE_Y: {\n          return Sk.builtin.assk$(stage[PROP_MOUSE_Y], Sk.builtin.nmber.int$);\n        }\n        case METHOD_ADD_CHILD: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_ADD_CHILD;\n              self.v = stage[METHOD_ADD_CHILD];\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, childPy) {\n              var child = stage.addChild(Sk.ffi.remapToJs(childPy));\n              return Sk.misceval.callsim(mod[childPy.tp$name], Sk.ffi.referenceToPy(child, childPy.tp$name));\n            });\n          }, METHOD_ADD_CHILD, []));\n        }\n        case METHOD_ENABLE_MOUSE_OVER: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_ENABLE_MOUSE_OVER;\n              self.v = stage[METHOD_ENABLE_MOUSE_OVER];\n            });\n            $loc.__call__ = new Sk.builtin.func(function(updatePy) {\n              stage[METHOD_ENABLE_MOUSE_OVER]();\n            });\n          }, METHOD_ENABLE_MOUSE_OVER, []));\n        }\n        case METHOD_UPDATE: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_UPDATE;\n              self.v = stage[METHOD_UPDATE];\n            });\n            $loc.__call__ = new Sk.builtin.func(function(updatePy) {\n              stage[METHOD_UPDATE]();\n            });\n          }, METHOD_UPDATE, []));\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(stagePy, name, valuePy) {\n      var stage = Sk.ffi.remapToJs(stagePy);\n      var value = Sk.ffi.remapToJs(valuePy);\n      switch(name) {\n        case PROP_AUTO_CLEAR: {\n          stage[PROP_AUTO_CLEAR] = value;\n        }\n        break;\n        case PROP_MOUSE_MOVE_OUTSIDE: {\n          stage[PROP_MOUSE_MOVE_OUTSIDE] = value;\n        }\n        break;\n        default: {\n          throw new Sk.builtin.AttributeError(name + " is not a writeable attribute of " + STAGE);\n        }\n      }\n    });\n  }, STAGE, []);\n\n  mod[TEXT] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(selfPy, textPy, fontPy, colorPy) {\n      selfPy.tp$name = TEXT;\n      var text = Sk.ffi.remapToJs(textPy);\n      var font = Sk.ffi.remapToJs(fontPy);\n      var color = Sk.ffi.remapToJs(colorPy);\n      selfPy.v = new createjs[TEXT](text, font, color);\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(textPy, name) {\n      var text = Sk.ffi.remapToJs(textPy);\n      switch(name) {\n        case PROP_ALPHA: {\n          return Sk.builtin.assk$(text[PROP_ALPHA], Sk.builtin.nmber.float$);\n        }\n        case PROP_X: {\n          return Sk.builtin.assk$(text[PROP_X], Sk.builtin.nmber.float$);\n        }\n        case PROP_Y: {\n          return Sk.builtin.assk$(text[PROP_Y], Sk.builtin.nmber.float$);\n        }\n        case PROP_ROTATION: {\n          return Sk.builtin.assk$(text[PROP_ROTATION], Sk.builtin.nmber.float$);\n        }\n        case PROP_TEXT: {\n          return new Sk.builtin.str(text[PROP_TEXT]);\n        }\n        case PROP_TEXT_ALIGN: {\n          return new Sk.builtin.str(text[PROP_TEXT_ALIGN]);\n        }\n        case METHOD_ADD_EVENT_LISTENER: {\n          return Sk.builtin.addEventListener(mod, text);\n        }\n        case METHOD_GET_MEASURED_WIDTH: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(methodPy) {\n              methodPy.tp$name = METHOD_GET_MEASURED_WIDTH;\n              methodPy.v = text[METHOD_GET_MEASURED_WIDTH];\n            });\n            $loc.__call__ = new Sk.builtin.func(function(methodPy, childPy) {\n              return Sk.builtin.assk$(text[METHOD_GET_MEASURED_WIDTH](), Sk.builtin.nmber.float$);\n            });\n          }, METHOD_GET_MEASURED_WIDTH, []));\n        }\n        case METHOD_GET_MEASURED_HEIGHT: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(methodPy) {\n              methodPy.tp$name = METHOD_GET_MEASURED_HEIGHT;\n              methodPy.v = text[METHOD_GET_MEASURED_HEIGHT];\n            });\n            $loc.__call__ = new Sk.builtin.func(function(methodPy, childPy) {\n              return Sk.builtin.assk$(text[METHOD_GET_MEASURED_HEIGHT](), Sk.builtin.nmber.float$);\n            });\n          }, METHOD_GET_MEASURED_HEIGHT, []));\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(textPy, name, valuePy) {\n      var text = Sk.ffi.remapToJs(textPy);\n      var value = Sk.ffi.remapToJs(valuePy);\n      switch(name) {\n        case PROP_ALPHA: {\n          Sk.builtin.pyCheckType(PROP_ALPHA, "Number", Sk.builtin.checkNumber(valuePy));\n          text[PROP_ALPHA] = value;\n        }\n        break;\n        case PROP_HIT_AREA: {\n          text[PROP_HIT_AREA] = value;\n        }\n        break;\n        case PROP_X: {\n          text[PROP_X] = value;\n        }\n        break;\n        case PROP_Y: {\n          text[PROP_Y] = value;\n        }\n        break;\n        case PROP_ROTATION: {\n          text[PROP_ROTATION] = value;\n        }\n        break;\n        case PROP_TEXT: {\n          text[PROP_TEXT] = value;\n        }\n        break;\n        case PROP_TEXT_ALIGN: {\n          text[PROP_TEXT_ALIGN] = value;\n        }\n        break;\n        default: {\n          throw new Sk.builtin.AttributeError(name + " is not a writeable attribute of " + TEXT);\n        }\n      }\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(selfPy) {\n      var self = Sk.ffi.remapToJs(selfPy);\n      return new Sk.builtin.str(TEXT + "(" + self.x + ", " + self.y + ")");\n    });\n    $loc.__str__ = new Sk.builtin.func(function(selfPy) {\n      var self = Sk.ffi.remapToJs(selfPy);\n      return new Sk.builtin.str("[" + self.x + ", " + self.y + "]");\n    });\n  }, TEXT, []);\n\n  mod[TICKER] = Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self) {\n      self.tp$name = TICKER;\n      self.v = createjs[TICKER];\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(tickerPy, name) {\n      var ticker = Sk.ffi.remapToJs(tickerPy);\n      switch(name) {\n        case METHOD_ADD_EVENT_LISTENER: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_ADD_EVENT_LISTENER;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, typePy, listenerPy, useCapture) {\n              var type = Sk.ffi.remapToJs(typePy);\n              var listener = Sk.ffi.remapToJs(listenerPy);\n              if (typeof listener === \'object\') {\n                ticker[METHOD_ADD_EVENT_LISTENER](type, listener, useCapture);\n              }\n              else {\n                var listener = function(event) {\n                  Sk.misceval.callsim(listenerPy);\n                };\n                ticker[METHOD_ADD_EVENT_LISTENER](type, listener, useCapture);\n              }\n            });\n          }, METHOD_ADD_EVENT_LISTENER, []));\n        }\n        break;\n      }\n    });\n  }, TICKER, []));\n\n  mod[TWEEN] = Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self) {\n      self.tp$name = TWEEN;\n      self.v = createjs[TWEEN];\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(entryPointPy, name) {\n      var entryPoint = Sk.ffi.remapToJs(entryPointPy);\n      switch(name) {\n        case METHOD_GET: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_GET;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, target, props, pluginData, override) {\n              target = Sk.ffi.remapToJs(target);\n              props = Sk.ffi.remapToJs(props);\n              pluginData = Sk.ffi.remapToJs(pluginData);\n              override = Sk.ffi.remapToJs(override);\n              var tween = entryPoint[METHOD_GET](target, props, pluginData, override);\n              return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n                $loc.__init__ = new Sk.builtin.func(function(self) {\n                  self.tp$name = TWEEN;\n                  self.v = tween;\n                });\n                $loc.__getattr__ = new Sk.builtin.func(function(tweenPy, name) {\n                  var tween = Sk.ffi.remapToJs(tweenPy);\n                  switch(name) {\n                    case METHOD_TO: {\n                      return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n                        $loc.__init__ = new Sk.builtin.func(function(self) {\n                          self.tp$name = METHOD_TO;\n                        });\n                        $loc.__call__ = new Sk.builtin.func(function(self, props, duration, ease) {\n                          props = Sk.ffi.remapToJs(props);\n                          duration = Sk.ffi.remapToJs(duration);\n                          ease = Sk.ffi.remapToJs(ease);\n                          tween[METHOD_TO](props, duration, ease);\n                          return tweenPy;\n                        });\n                      }, METHOD_TO, []));\n                    }\n                    break;\n                    case METHOD_CALL: {\n                      return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n                        $loc.__init__ = new Sk.builtin.func(function(self) {\n                          self.tp$name = METHOD_CALL;\n                        });\n                        $loc.__call__ = new Sk.builtin.func(function(self, callbackPy, argsPy) {\n                          var callbackJS = function(argsJs) {\n                            Sk.misceval.callsim(callbackPy, Sk.ffi.remapToPy(argsJs));\n                          };\n                          var argsJs = Sk.ffi.remapToJs(argsPy);\n                          tween.call(callbackJS, argsJs);\n                          return tweenPy;\n                        });\n                      }, METHOD_CALL, []));\n                    }\n                    break;\n                    case METHOD_WAIT: {\n                      return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n                        $loc.__init__ = new Sk.builtin.func(function(self) {\n                          self.tp$name = METHOD_WAIT;\n                        });\n                        $loc.__call__ = new Sk.builtin.func(function(self, duration) {\n                          duration = Sk.ffi.remapToJs(duration);\n                          tween[METHOD_WAIT](duration);\n                          return tweenPy;\n                        });\n                      }, METHOD_WAIT, []));\n                    }\n                    break;\n                  }\n                });\n              }, TWEEN, []));\n            });\n          }, METHOD_GET, []));\n        }\n        break;\n      }\n    });\n  }, TWEEN, []));\n\n  mod[CONTAINER] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(containerPy, argPy) {\n      containerPy.tp$name = CONTAINER;\n      if (typeof argPy === \'undefined\') {\n        containerPy.v = new createjs[CONTAINER]();\n      }\n      else {\n        var name = argPy.tp$name;\n        if (typeof name === \'string\') {\n          switch(name) {\n            case CONTAINER: {\n              containerPy.v = Sk.ffi.remapToJs(argPy);\n            }\n            break;\n            default: {\n              throw new Error(name);\n            }\n          }\n        }\n        else {\n          throw new Error(typeof name);\n        }\n      }\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(containerPy, name) {\n      var container = Sk.ffi.remapToJs(containerPy);\n      switch(name) {\n        case PROP_NAME: {\n          return new Sk.builtin.str(container[PROP_NAME]);\n        }\n        case PROP_X: {\n          return Sk.builtin.assk$(container[PROP_X], Sk.builtin.nmber.float$);\n        }\n        case PROP_Y: {\n          return Sk.builtin.assk$(container[PROP_Y], Sk.builtin.nmber.float$);\n        }\n        case PROP_ROTATION: {\n          return Sk.builtin.assk$(container[PROP_ROTATION], Sk.builtin.nmber.float$);\n        }\n        case METHOD_ADD_CHILD: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(methodPy) {\n              methodPy.tp$name = METHOD_ADD_CHILD;\n              methodPy.v = container[METHOD_ADD_CHILD];\n            });\n            $loc.__call__ = new Sk.builtin.func(function(methodPy, childPy) {\n              var child = container.addChild(Sk.ffi.remapToJs(childPy));\n              return Sk.misceval.callsim(mod[childPy.tp$name], Sk.ffi.referenceToPy(child, childPy.tp$name));\n            });\n          }, METHOD_ADD_CHILD, []));\n        }\n        case METHOD_ADD_EVENT_LISTENER: {\n          return Sk.builtin.addEventListener(mod, container);\n        }\n        case METHOD_GET_CHILD_AT: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(methodPy) {\n              methodPy.tp$name = METHOD_GET_CHILD_AT;\n              methodPy.v = container[METHOD_GET_CHILD_AT];\n            });\n            $loc.__call__ = new Sk.builtin.func(function(methodPy, indexPy) {\n              var child = container[METHOD_GET_CHILD_AT](Sk.ffi.remapToJs(indexPy));\n              return Sk.misceval.callsim(mod[SHAPE], Sk.ffi.referenceToPy(child, SHAPE));\n            });\n          }, METHOD_GET_CHILD_AT, []));\n        }\n        case METHOD_GET_NUM_CHILDREN: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(methodPy) {\n              methodPy.tp$name = METHOD_GET_NUM_CHILDREN;\n              methodPy.v = container[METHOD_GET_NUM_CHILDREN];\n            });\n            $loc.__call__ = new Sk.builtin.func(function(methodPy, childPy) {\n              return Sk.builtin.assk$(container[METHOD_GET_NUM_CHILDREN](), Sk.builtin.nmber.int$);\n            });\n          }, METHOD_GET_NUM_CHILDREN, []));\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(containerPy, name, valuePy) {\n      var container = Sk.ffi.remapToJs(containerPy);\n      var value = Sk.ffi.remapToJs(valuePy);\n      switch(name) {\n        case PROP_NAME: {\n          container[PROP_NAME] = value;\n        }\n        break;\n        case PROP_X: {\n          container[PROP_X] = value;\n        }\n        break;\n        case PROP_Y: {\n          container[PROP_Y] = value;\n        }\n        break;\n        case PROP_ROTATION: {\n          container[PROP_ROTATION] = value;\n        }\n        break;\n        default: {\n          throw new Sk.builtin.AttributeError(name + " is not a writeable attribute of " + CONTAINER);\n        }\n      }\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(selfPy) {\n      var self = Sk.ffi.remapToJs(selfPy);\n      return new Sk.builtin.str(CONTAINER + "(" + self.x + ", " + self.y + ")");\n    });\n    $loc.__str__ = new Sk.builtin.func(function(selfPy) {\n      var self = Sk.ffi.remapToJs(selfPy);\n      return new Sk.builtin.str("[" + self.x + ", " + self.y + "]");\n    });\n  }, CONTAINER, []);\n\n  mod[EASE] = Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self) {\n      self.tp$name = EASE;\n      self.v = createjs[EASE];\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(self, name) {\n      switch(name) {\n        case PROP_BOUNCE_OUT: {\n          var fn = createjs[EASE][PROP_BOUNCE_OUT];\n          return {"v": fn};\n        }\n      }\n    });\n  }, EASE, []));\n\n  mod[POINT] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self, x, y) {\n      Sk.builtin.pyCheckArgs(POINT, arguments, 1, 3);\n      self.tp$name = POINT;\n      switch(arguments.length) {\n        case 1: {\n          self.v = new createjs.Point();\n        }\n        break;\n        case 2: {\n          x = Sk.ffi.remapToJs(x);\n          self.tp$name = POINT;\n          self.v = x;\n        }\n        break;\n        case 3: {\n          Sk.builtin.pyCheckType("x", "number", Sk.builtin.checkNumber(x));\n          Sk.builtin.pyCheckType("y", "number", Sk.builtin.checkNumber(y));\n          x = Sk.ffi.remapToJs(x);\n          y = Sk.ffi.remapToJs(y);\n          self.tp$name = POINT;\n          self.v = new createjs.Point(x, y);\n        }\n        break;\n      }\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(pointPy, name) {\n      var point = Sk.ffi.remapToJs(pointPy);\n      switch(name) {\n        case PROP_X: {\n          return Sk.builtin.assk$(point.x, Sk.builtin.nmber.float$);\n        }\n        case PROP_Y: {\n          return Sk.builtin.assk$(point.y, Sk.builtin.nmber.float$);\n        }\n        case METHOD_CLONE: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(methodPy) {\n              methodPy.tp$name = METHOD_CLONE;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(methodPy) {\n              return Sk.misceval.callsim(mod[POINT], Sk.ffi.remapToPy(point.x), Sk.ffi.remapToPy(point.y));\n            });\n          }, METHOD_CLONE, []));\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(pointPy, name, valuePy) {\n      var point = Sk.ffi.remapToJs(pointPy);\n      var value = Sk.ffi.remapToJs(valuePy);\n      switch(name) {\n        case PROP_X: {\n          point.x = value;\n        }\n        break;\n        case PROP_Y: {\n          point.y = value;\n        }\n        break;\n      }\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(pointPy) {\n      var point = Sk.ffi.remapToJs(pointPy);\n      return new Sk.builtin.str(POINT + "(" + point.x + ", " + point.y + ")");\n    });\n    $loc.__str__ = new Sk.builtin.func(function(pointPy) {\n      var point = Sk.ffi.remapToJs(pointPy);\n      return new Sk.builtin.str("[" + point.x + ", " + point.y + "]");\n    });\n  }, POINT, []);\n\n  Sk.builtin.defineEuclidean2(mod);\n\n  mod[\'getHSL\'] = new Sk.builtin.func(function(hue, saturation, lightness, alpha) {\n    hue = Sk.ffi.remapToJs(hue);\n    saturation = Sk.ffi.remapToJs(saturation);\n    lightness = Sk.ffi.remapToJs(lightness);\n    alpha = Sk.ffi.remapToJs(alpha);\n    return new Sk.builtin.str(createjs[GRAPHICS].getHSL(hue, saturation, lightness, alpha));\n  });\n\n  return mod;\n}\n',
    'src/lib/turtle/__init__.js': '//\n//\n// Turtle Graphics Module for Skulpt\n//\n// Brad Miller\n//\n//\n//\n\n\nvar TurtleGraphics; // the single identifier needed in the global scope\n\nif (! TurtleGraphics) {\n    TurtleGraphics = { };\n}\n\n\n(function () {\n\n    // Define private constants\n\n    var Degree2Rad = Math.PI / 180.0; // conversion factor for degrees to radians\n    var Rad2Degree = 180.0 / Math.PI\n\n    //\n    // Define TurtleCanvas\n    // \n\n    function TurtleCanvas(options) {\n        this.canvasID = TurtleGraphics.defaults.canvasID;\n        if (options.canvasID) {\n            this.canvasID = options.canvasID;\n        }\n\n        this.canvas = document.getElementById(this.canvasID);\n        this.context = this.canvas.getContext(\'2d\');\n        //this.canvas.style.display = \'block\';\n        $(this.canvas).fadeIn();\n\n        this.lineScale = 1.0;\n        this.xptscale = 1.0;\n        this.yptscale = 1.0\n\n        this.llx = -this.canvas.width / 2;\n        this.lly = -this.canvas.height / 2;\n        this.urx = this.canvas.width / 2;\n        this.ury = this.canvas.height / 2;\n        this.setup(this.canvas.width,this.canvas.height);\n        TurtleGraphics.canvasInit = true;\n        this.tlist = []\n\n\t\tthis.timeFactor = 5;\n        if (TurtleGraphics.defaults.animate) {\n            this.delay = 5 * this.timeFactor;\n        } else {\n            this.delay = 0;\n        }\n        this.segmentLength = 10;\n        this.renderCounter = 1;\n        this.clearPoint = 0;\n        TurtleGraphics.canvasLib[this.canvasID] = this;\n\t\tSk.tg.fadeOnExit = true;\t//\tThis can be set to false AFTER the program completes to turn off the fade out on the canvas as a result of exitonclick\n    }\n\n    TurtleCanvas.prototype.setup = function(width, height) {\n        this.canvas.width = width;\n        this.canvas.height = height;\n        this.lineScale = 1.0;\n        this.xptscale = 1.0;\n        this.yptscale = 1.0;\n\n        this.llx = -this.canvas.width / 2;\n        this.lly = -this.canvas.height / 2;\n        this.urx = this.canvas.width / 2;\n        this.ury = this.canvas.height / 2;\n        this.renderCounter = 1;\n        this.clearPoint = 0;\n\t\tthis.timeFactor = 5;\n        if (TurtleGraphics.defaults.animate ) {\n            this.delay = 5 * this.timeFactor;\n        } else {\n            this.delay = 0;\n        }\n\n        if (TurtleGraphics.canvasInit == false) {\n            this.context.save();\n            this.context.translate(this.canvas.width / 2, this.canvas.height / 2); // move 0,0 to center.\n            this.context.scale(1, -1); // scaling like this flips the y axis the right way.\n            TurtleGraphics.canvasInit = true;\n            TurtleGraphics.eventCount = 0;\n            TurtleGraphics.renderClock = 0;\n            TurtleGraphics.renderTime = 0;\t// RNL\n        } else {\n            this.context.restore();\n            this.context.translate(this.canvas.width / 2, this.canvas.height / 2); // move 0,0 to center.\n            this.context.scale(1, -1); // scaling like this flips the y axis the right way.\n            this.context.clearRect(-this.canvas.width / 2, -this.canvas.height / 2,\n                                    this.canvas.width, this.canvas.height);\n        }\n    }\n    TurtleCanvas.prototype.addToCanvas = function(t) {\n\t        this.tlist.push(t);\n    }\n\n    TurtleCanvas.prototype.onCanvas = function(t) {\n        return (this.tlist.indexOf(t) >= 0);\n    }\n\n    TurtleCanvas.prototype.isAnimating = function() {\n        return (this.tlist.length > 0)\n    }\n\n    TurtleCanvas.prototype.startAnimating = function(t) {\n\t\tif (! this.isAnimating()) {\n        \tthis.intervalId = setTimeout(render, this.delay);\t//\tsetInterval(render, this.delay);\n\t\t}\n    \tif (!this.onCanvas(t))\t//\tAdded by RNL in case startAnimating is called after it\'s already been added\n       \t\tthis.addToCanvas(t);\n        Sk.isTurtleProgram = true;\n    }\n\n    TurtleCanvas.prototype.doneAnimating = function(t) {\n        this.tlist.splice(0,this.tlist.length)\n        clearTimeout(this.intervalId)   \n        $(Sk.runButton).removeAttr(\'disabled\');\n    }\n\n    TurtleCanvas.prototype.cancelAnimation = function() {\n        if (this.intervalId) {\n            clearTimeout(this.intervalId)\t//\tclearInterval(this.intervalId);\n        }\n\n        for (var t in this.tlist) {\n            this.tlist[t].aCount = this.tlist[t].drawingEvents.length - 1;\n        }\n        render();\n    }\n\n    TurtleCanvas.prototype.setSpeedDelay = function(s) {\t// RNL\n        var df = 10 - (s % 11) + 1;\n        this.delay = df * this.timeFactor;\t//\tRNL was 10;\n    }\n\n    TurtleCanvas.prototype.setDelay = function(d) {\n        this.delay = d;\n    }\n\n    TurtleCanvas.prototype.getDelay = function(s) { // RNL\n        return this.delay;\n    }\n\n    TurtleCanvas.prototype.setCounter = function(s) {\n\t\tif (!s || s <= 0)\t//\tDon\'t let this be less than 1\n\t\t\ts = 1;\n        this.renderCounter = s;\n    }\n\n    TurtleCanvas.prototype.getCounter = function() {\n        return this.renderCounter;\n    }\n\n    TurtleCanvas.prototype.setworldcoordinates = function(llx, lly, urx, ury) {\n        this.context.restore();\n        this.context.scale(this.canvas.width / (urx - llx), -this.canvas.height / (ury - lly));\n        if (lly == 0)\n            this.context.translate(-llx, lly - (ury - lly));\n        else if (lly > 0)\n            this.context.translate(-llx, -lly * 2);\n        else\n            this.context.translate(-llx, -ury);\n\n        var xlinescale = (urx - llx) / this.canvas.width;\n        var ylinescale = (ury - lly) / this.canvas.height;\n        this.xptscale = xlinescale;\n        this.yptscale = ylinescale;\n        this.lineScale = Math.min(xlinescale,ylinescale)\n        this.context.save();\n\n        this.llx = llx;\n        this.lly = lly;\n        this.urx = urx;\n        this.ury = ury;\n\n    }\n\n    TurtleCanvas.prototype.window_width = function() {\n        return this.canvas.width;\n    }\n\n    TurtleCanvas.prototype.window_height = function() {\n        return this.canvas.height;\n    }\n\n    TurtleCanvas.prototype.bgcolor = function(c) {\n        this.background_color = c;\n        //this.canvas.style.setProperty("background-color", c.v);\n        $(this.canvas).css("background-color",c.v);\n    }\n\n    TurtleCanvas.prototype.setSegmentLength = function(s) {\n        this.segmentLength = s;\n    }\n\n    TurtleCanvas.prototype.getSegmentLength = function() {\n        return this.segmentLength;\n    }\n    \n    // todo: if animating, this should be deferred until the proper time\n    TurtleCanvas.prototype.exitonclick = function () {\n        var canvas_id = this.canvasID;\n        var theCanvas = this;\n        $(this.canvas).click(function() {\n            if (! theCanvas.isAnimating()) {\n\t\t\t\tif (Sk.tg.fadeOnExit)\t//\tLet\'s this be configurable\n                \t$("#"+canvas_id).hide();\n                $("#"+canvas_id).unbind(\'click\');\n                Sk.tg.canvasInit = false;\n                delete Sk.tg.canvasLib[canvas_id];\n            }\n        });\n    }\n\n    TurtleCanvas.prototype.turtles = function() {\n        return TurtleGraphics.turtleList;\n    }\n\n\tTurtleCanvas.prototype.tracer = function(t, d) {\t//\tNew version NOT attached to a turtle (as per real turtle)\n        this.setCounter(t);\n\t\tif (t == 0) {\n\t\t\tfor (var i in this.turtleList)\n\t\t\t\tthis.turtleList[i].animate = false;\n\t\t\tthis.cancelAnimation();\n\t\t}\n\t\tif (d !== undefined)\n\t\t\tthis.setDelay(d);\n\t}\n\n    // check if all turtles are done\n    allDone = function() {\n        var allDone = true;\n        for (var tix in TurtleGraphics.turtleList) {\n            var theT = TurtleGraphics.turtleList[tix];\n            allDone = allDone && (theT.aCount >= theT.drawingEvents.length);\n        }\n        return allDone;\n    }\n    //\n    //  This is the function that provides the animation\n    //\n    render = function () {\n        var context = document.getElementById(TurtleGraphics.defaults.canvasID).getContext(\'2d\');\n        with (context) {\n            with (TurtleGraphics.canvasLib[TurtleGraphics.defaults.canvasID]) {\n                clearRect(llx, lly, (urx - llx), (ury - lly));\n                //canvas.style.setProperty("background-color",TurtleGraphics.turtleCanvas.bgcolor.v);\n            }\n            var incr = TurtleGraphics.canvasLib[TurtleGraphics.defaults.canvasID].getCounter();\n            var lastCanvas = null\n\n            TurtleGraphics.renderClock += incr;\n\n            for (var tix in TurtleGraphics.turtleList) {\n                var t = TurtleGraphics.turtleList[tix]\n                lastCanvas = t.turtleCanvas \n                if (t.aCount >= t.drawingEvents.length)\n                    t.aCount = t.drawingEvents.length - 1;\n                moveTo(0, 0);\n                var currentPos = new Vector(0,0,0);\n                var currentHead = new Vector(1,0,0);\n                lineWidth = t.get_pen_width();\n                lineCap = \'round\';\n                lineJoin = \'round\';\n                strokeStyle = \'black\';\n                var filling = false;\n                if (isNaN(t.turtleCanvas.delay))\n                \tt.turtleCanvas.delay = 0\n//\t\t\t\tconsole.log(tix + " : " + t.clearPoint + " to " + t.aCount)\n                for (var i = t.clearPoint; (i <= t.aCount || t.turtleCanvas.delay == 0) && i < t.drawingEvents.length; i++) {\n                \tif (i > t.aCount)\t//\tIf se jump past aCount, jump it ahead\n                \t\tt.aCount = i\n                    var oper = t.drawingEvents[i];\n                    var ts = oper[oper.length-1];\n//\t\t\t\t\tconsole.log(i + "/" + ts + oper [0] + "{" + oper [1] + "}" + t.turtleCanvas.delay)\n                    if (ts <= TurtleGraphics.renderClock || t.turtleCanvas.delay == 0) {\n                    \tif (ts > TurtleGraphics.renderClock)\t//\tIf we go past the render clock, jump it ahead\n                    \t\tTurtleGraphics.renderClock = ts\n//\t\t\t\t\t\tconsole.log("<==")\n                        if (oper[0] == "LT") {  //  line to\n                            if (! filling) {\n                                beginPath();\n                                moveTo(oper[1], oper[2]);\n                            }\n                            lineTo(oper[3], oper[4]);\n                            strokeStyle = oper[5];\n                            stroke();\n                            currentPos = new Vector(oper[3],oper[4],0);\n                            if (! filling)\n                                closePath();\n                        }\n                        else if (oper[0] == "MT") {  // move to\n                            moveTo(oper[3], oper[4]);\n                            currentPos = new Vector(oper[3],oper[4],0);\n                        }\n                        else if (oper[0] == "BF") {  // begin fill\n                            beginPath();\n                            moveTo(oper[1], oper[2]);\n                            filling = true;\n                        }\n                        else if (oper[0] == "EF") {  // end fill\n                            fillStyle = oper[3];\n                            stroke();\n                            fill();\n                            closePath();\n                            filling = false;\n                        }\n                        else if (oper[0] == "FC") {  // fill color\n                            fillStyle = oper[1];\n                        }\n                        else if (oper[0] == "TC") {  // turtle color\n                            strokeStyle = oper[1];\n                        }\n                        else if (oper[0] == "PW") {  // Pen width\n                            lineWidth = oper[1];\n                        }\n                        else if (oper[0] == "DT") {  // Dot\n                            var col = fillStyle;\n                            fillStyle = oper[2];\n                            var size = oper[1];\n                            fillRect(oper[3] - size / 2, oper[4] - size / 2, size, size);\n                            fillStyle = col;\n                        }\n                        else if (oper[0] == "CI") {  // Circle\n                            if (!filling)\n\t\t\t\t\t\t\t\tbeginPath();\n                            arc(oper[1], oper[2], oper[3], oper[4], oper[5], oper[6]);\n                            currentPos = new Vector(oper[1]+Math.cos(oper[5])*oper[3],\n                                oper[2]+Math.sin(oper[5])*oper[3],0);\n                            stroke();\n                            if (! filling) {\n                                closePath();\n                            }\n                        }\n                        else if (oper[0] == "WT") { // write\n                            if (font)\n                                font = oper[2];\n                            scale(1, -1);\n                            fillText(oper[1], oper[3], -oper[4]);\n                            scale(1, -1);\n                        } else if (oper[0] == "ST") {  // stamp\n                            t.drawturtle(oper[3], new Vector(oper[1], oper[2], 0));\n                        } else if (oper[0] == "HT") { // hide turtle\n                            t.visible = false;\n                        } else if (oper[0] == "SH") { // show turtle\n                            t.visible = true;\n                        } else if (oper[0] == "TT") {\n                            currentHead = oper[1];\n                        } else if (oper[0] == "CL") { // RNL clear\n                        \tclear_canvas(t.canvasID);\n                        \tt.clearPoint = i;\t// Different from reset that calls clear because it leaves the turtles where they are\n                        } else if (oper[0] == "DL") { // RNL delay\n                        \tvar df = oper[1]\n//                      \tconsole.log("animated delay set " + df)\n                        \tt.turtleCanvas.delay = df\n                        } else if (oper[0] == "SC") { // RNL speed change\n                        \tvar s = oper[1]\n                        \tif (s < 0)\n                        \t\ts = 0\n                        \tif (s > 10)\n                        \t\ts = 10\n       \t\t\t\t\t\tvar df = (10 - (s % 11) + 1) * t.turtleCanvas.timeFactor\t//\t10\n       \t\t\t\t\t\tif (s == 0) {\n       \t\t\t\t\t\t\tdf = 0\n       \t\t\t\t\t\t}\n\t                        //\tt.turtleCanvas.intervalId = clearInterval(t.turtleCanvas.intervalId);\n\t       \t\t\t\t\tt.turtleCanvas.delay = df;\n\t       \t\t\t\t\t//\tt.turtleCanvas.intervalId = setInterval(render, t.turtleCanvas.delay)\n       \t\t\t\t\t\tif (oper[2]) {\n       \t\t\t\t\t\t\tt.turtleCanvas.setSegmentLength(oper[2]);\n       \t\t\t\t\t\t}\n       \t\t\t\t\t} else if (oper[0] == "NO") { // RNL no op                \t\n                        } else {\n\t\t\t\t\t\t\tconsole.log("unknown op: " + oper[0]);\n                        } // end of oper[0] test\n                    } // end of if ts < render clock\n                } // end of for\n//\t\t\t\tconsole.log(TurtleGraphics.renderClock + " / " + t.aCount)\n//\t\t\t\tconsole.log("------------------------------")\n                t.aCount += incr;\n                if (t.visible) {\n                    // draw the turtle\n                    t.drawturtle(currentHead.toAngle(), currentPos); // just use currentHead\n                }\n            }\n            //if (t.aCount >= t.drawingEvents.length) {\n            if (TurtleGraphics.renderClock > TurtleGraphics.eventCount ){ // && allDone() ){\n//              t.turtleCanvas.doneAnimating(t);\n//\t\t\t\tconsole.log("done animating")\n                if (lastCanvas) lastCanvas.doneAnimating(t);\n            } else {\n//    \t\t\tt.turtleCanvas.intervalId = setTimeout(render, t.turtleCanvas.delay)\n    \t\t\tif (lastCanvas) {\n    \t\t\t\tlastCanvas.intervalId = setTimeout(render, lastCanvas.delay)\n    \t\t\t}\n            }\n        }\n    }\n\n\n\n    // Constructor for Turtle objects\n    function Turtle() {\n        if (arguments.length >= 1) {\n            this.initialize(arguments[0]);\n        }\n        else {\n            this.initialize();\n        }\n        TurtleGraphics.turtleList.push(this);\n    }\n\n\n    Turtle.prototype.go_home = function () {\n        // Put turtle in initial state\n        // turtle is headed to the right\n        // with location 0,0,0 in the middle of the canvas.\n        // x grows to the right\n        // y grows towards the top of the canvas\n        with (this) {\n            position = home;\n            context.moveTo(home[0], home[1]);\n            heading = new Vector([1.0, 0.0, 0.0]); // to the right; in turtle space x+ direction\n            normal = new Vector([0.0, 0.0, -1.0]); // in z- direction\n        }\n    };\n\n    Turtle.prototype.initialize = function () {\n        // Initialize the turtle.\n        var options = { };\n\n        if (arguments.length >= 1) {\n            options = arguments[0];\n        }\n\n        this.canvasID = TurtleGraphics.defaults.canvasID;\n        if (options.canvasID) {\n            this.canvasID = options.canvasID;\n        }\n        this.context = document.getElementById(this.canvasID).getContext(\'2d\');\n\n        this.animate = TurtleGraphics.defaults.animate;\n\n        with (this.context) {\n            if (TurtleGraphics.canvasInit == false) {   // This is a workaround until I understand skulpt re-running better\n                // the downside is that this limits us to a single turtle...\n                save();\n                translate(canvas.width / 2, canvas.height / 2); // move 0,0 to center.\n                scale(1, -1); // scaling like this flips the y axis the right way.\n                if (! TurtleGraphics.canvasLib[this.canvasID]) {\n                    TurtleGraphics.canvasLib[this.canvasID] = new TurtleCanvas(options);\n                }\n                TurtleGraphics.canvasInit = true;\n            } else {\n                clear_canvas(this.canvasID);\n            }\n\n            this.turtleCanvas = TurtleGraphics.canvasLib[this.canvasID];\n            this.home = new Vector([0.0, 0.0, 0.0]);\n            this.visible = true;\n            this.shapeStore = {};\n            this.shapeStore[\'turtle\'] = turtleShapePoints();\n            this.shapeStore[\'arrow\'] = defaultShapePoints();\n            this.shapeStore[\'circle\'] = circleShapePoints();\n            this.shapeStore[\'square\'] = squareShapePoints();\n            this.shapeStore[\'triangle\'] = triangleShapePoints();\n            this.shapeStore[\'blank\'] = [new Vector(0,0)];\n            this.shapeStore[\'classic\'] = classicShapePoints();\n            this.currentShape = \'classic\';\n            this.drawingEvents = [];\n\n            this.filling = false;\n            this.pen = true;\n            this.penStyle = \'black\';\n            this.penWidth = 2;\n            this.fillStyle = \'black\';\n            this.position = [ ];\n            this.heading = [ ];\n            this.normal = [ ];\n            this.go_home();\n            this.aCount = 0;\n            this.clearPoint = 0;\t// RNL for clear/clearScreen\n        }\n    }\n    function turtleShapePoints() {\n        var pl = [\n            [0,16],\n            [-2,14],\n            [-1,10],\n            [-4,7],\n            [-7,9],\n            [-9,8],\n            [-6,5],\n            [-7,1],\n            [-5,-3],\n            [-8,-6],\n            [-6,-8],\n            [-4,-5],\n            [0,-7],\n            [4,-5],\n            [6,-8],\n            [8,-6],\n            [5,-3],\n            [7,1],\n            [6,5],\n            [9,8],\n            [7,9],\n            [4,7],\n            [1,10],\n            [2,14]\n        ];\n        res = [];\n        for (p in pl) {\n            res.push(new Vector(pl[p]));\n        }\n        return res;\n    }\n\n    function defaultShapePoints() {\n        var pl = [\n            [-10,0],\n            [10,0],\n            [0,10]\n        ];\n        res = [];\n        for (p in pl) {\n            res.push(new Vector(pl[p]));\n        }\n        return res;\n    }\n\n    function circleShapePoints() {\n        var pl = [\n            [10,0],\n            [9.51,3.09],\n            [8.09,5.88],\n            [5.88,8.09],\n            [3.09,9.51],\n            [0,10],\n            [-3.09,9.51],\n            [-5.88,8.09],\n            [-8.09,5.88],\n            [-9.51,3.09],\n            [-10,0],\n            [-9.51,-3.09],\n            [-8.09,-5.88],\n            [-5.88,-8.09],\n            [-3.09,-9.51],\n            [-0.00,-10.00],\n            [3.09,-9.51],\n            [5.88,-8.09],\n            [8.09,-5.88],\n            [9.51,-3.09]\n        ];\n        res = [];\n        for (p in pl) {\n            res.push(new Vector(pl[p]));\n        }\n        return res;\n    }\n\n    function triangleShapePoints() {\n        var pl = [\n            [10,-5.77],\n            [0,11.55],\n            [-10,-5.77]\n        ];\n\n        res = [];\n        for (p in pl) {\n            res.push(new Vector(pl[p]));\n        }\n        return res;\n\n    }\n\n    function squareShapePoints() {\n        var pl = [\n            [10,-10],\n            [10,10],\n            [-10,10],\n            [-10,-10]\n        ];\n\n        res = [];\n        for (p in pl) {\n            res.push(new Vector(pl[p]));\n        }\n        return res;\n\n    }\n\n    function classicShapePoints() {\n        var pl = [\n            [0,0],\n            [-5,-9],\n            [0,-7],\n            [5,-9]\n        ];\n\n        res = [];\n        for (p in pl) {\n            res.push(new Vector(pl[p]));\n        }\n        return res;\n\n    }\n\n    Turtle.prototype.clean = function () {\n        // Clean the canvas\n        // Optional second argument is color\n        with (this) {\n            if (arguments.length >= 1) {\n                clear_canvas(canvasID, arguments[0]);\n            }\n            else {\n                clear_canvas(canvasID);\n            }\n            initialize();\n        }\n    }\n\n    Turtle.prototype.addDrawingEvent = function(eventList) {\n        TurtleGraphics.eventCount += 1;\n        eventList.push(TurtleGraphics.eventCount);\n        this.drawingEvents.push(eventList);\n    }\n//  \n//  Drawing Functions\n//\n\n    // break a line into segments\n    // sp:  Vector of starting position\n    // ep:  Vector of ending position\n    // sl:  int length of segments\n    segmentLine = function(sp, ep, sL, pen) {\n        var head = ep.sub(sp).normalize();\n        var numSegs = Math.floor(ep.sub(sp).len() / sL);\n        var res = [];\n        var oldp = sp;\n        var newp;\n        var op = ""\n        if (pen)\n            op = "LT"\n        else\n            op = "MT"\n        for (var i = 0; i < numSegs; i++) {\n            newp = oldp.linear(1, sL, head);\n            res.push([op,oldp[0],oldp[1],newp[0],newp[1]]);\n            oldp = newp;\n        }\n        if (! ((oldp[0] == ep[0]) && (oldp[1] == ep[1])))\n            res.push([op, oldp[0], oldp[1], ep[0], ep[1]]);\n        return res;\n    }\n\n    Turtle.prototype.draw_line = function(newposition) {\n        with (this) {\n            with (context) {\n                if (! animate) {\n                    if (! filling) {\n                        beginPath();\n                        moveTo(position[0], position[1]);\n                    }\n                    lineCap = \'round\';\n                    lineJoin = \'round\';\n                    lineWidth = get_pen_width();\n                    strokeStyle = penStyle;\n                    lineTo(newposition[0], newposition[1]);\n                    stroke();\n                    if (! filling)\n                        closePath();\n                } else {\n                    var r = segmentLine(position, newposition, turtleCanvas.getSegmentLength(), pen);\n                    for (var s in r) {\n                        r[s].push(penStyle);\n                        addDrawingEvent(r[s]);\n                    }\n                    if (! turtleCanvas.isAnimating()) {\n                        turtleCanvas.startAnimating(this);\n                    } else {\n                        if (! turtleCanvas.onCanvas(this))\n                            turtleCanvas.addToCanvas(this);\n                    }\n                }\n            }\n        }\n\n    }\n\n\n    Turtle.prototype.forward = function (d) {\n        with (this) {\n            var newposition = position.linear(1, d, heading);\n            goto(newposition);\n        }\n    }\n\n    Turtle.prototype.backward = function(d) {\n        this.forward(-d);\n    }\n\n//\tThis is an internal function that sets the position without doing any drawing\n    Turtle.prototype.teleport_to = function(nx, ny) {\n        if (nx instanceof Vector)\n            var newposition = nx;\n        else\n            var newposition = new Vector([nx,ny,0]);\n        this.context.moveTo(newposition[0], newposition[1]);\n\t\tthis.position = newposition;\n\t}\n\n    Turtle.prototype.goto = function(nx, ny) {\n        if (nx instanceof Vector)\n            var newposition = nx;\n        else\n            var newposition = new Vector([nx,ny,0]);\n        with (this) {\n            if (pen) {\n                draw_line(newposition);\n            } else {\n                if (! animate) {\n                    context.moveTo(newposition[0], newposition[1]);\n                } else {\n                    var r = segmentLine(position, newposition, turtleCanvas.getSegmentLength(), pen);\n                    for (var s in r)\n                        addDrawingEvent(r[s]);\n                    if (! turtleCanvas.isAnimating()) {\n                        turtleCanvas.startAnimating(this);\n                    } else {\n                        if (! turtleCanvas.onCanvas(this))\n                            turtleCanvas.addToCanvas(this);\n                    }\n                }\n            }\n            position = newposition;\n\n        }\n    }\n\n    Turtle.prototype.delay = function(d) {\t// RNL\n    \tif (d != null) {\n    \t\tif (d < 0)\n    \t\t\td = -d\n    \t\tif (!this.animate) \n    \t\t\tthis.turtleCanvas.setDelay(d)\n    \t\telse {\n    \t\t\tthis.turtleCanvas.setDelay(d)\n\t    \t\tthis.addDrawingEvent(["DL", d])\n\t    \t\tthis.addDrawingEvent(["NO"])\n    \t\t}\n    \t}\n        return this.turtleCanvas.getDelay();\n    }\n\n    Turtle.prototype.speed = function(s,t) {\n        if (s > 0 && !this.animate) {\n            this.animate = true;\n            this.turtleCanvas.setSpeedDelay(s)\n        } else if (s == 0 && !this.animate) {\n        \tthis.turtleCanvas.setSpeedDelay(s)\n        } else {\n//          this.animate = false;\n//          this.turtleCanvas.cancelAnimation();\n\t\t\tthis.addDrawingEvent(["SC", s, t])\n\t\t\tthis.addDrawingEvent(["NO"])\n        }\n        if (t) {\n            this.turtleCanvas.setSegmentLength(t);\n            // set the number of units to divide a segment into\n        } else {\n            this.turtleCanvas.setSegmentLength(10);\n        }\n    }\n\n    Turtle.prototype.tracer = function(t, d) {\n        this.turtleCanvas.setCounter(t);\n\t\tif (t == 0) {\n\t\t\tthis.animate=false;\n\t\t\tthis.turtleCanvas.cancelAnimation();\n\t\t}\n\t\tif (d !== undefined)\n\t\t\tthis.turtleCanvas.setDelay(d);\n    }\n\n    Turtle.prototype.getRenderCounter = function() {\n        return this.turtleCanvas.getCounter();\n    }\n\n    Turtle.prototype.turn = function (phi) {\n        with (this) {\n            var alpha = phi * Degree2Rad;\n            var left = normal.cross(heading);\n            var newheading = heading.rotateNormal(left, normal, alpha);\n            heading = newheading;\n\n            if (animate) {\n                addDrawingEvent(["TT",heading]);\n            }\n        }\n    }\n\n    Turtle.prototype.right = Turtle.prototype.turn;\n\n    Turtle.prototype.left = function(phi) {\n        this.turn(-phi);\n    }\n\n    Turtle.prototype.get_heading = function () {\n        if (TurtleGraphics.defaults.degrees)\n            return this.heading.toAngle()\n        else\n            return this.heading\n    }\n\n    Turtle.prototype.get_position = function () {\n        return this.position;\n    }\n\n    Turtle.prototype.getx = function () {\n        return this.position[0];\n    }\n\n    Turtle.prototype.gety = function () {\n        return this.position[1];\n    }\n\n    Turtle.prototype.set_heading = function(newhead) {\n        if ((typeof(newhead)).toLowerCase() === \'number\') {\n            this.heading = Vector.angle2vec(newhead);\n        } else {\n            this.heading = newhead;\n        }\n    }\n\n    Turtle.prototype.towards = function(to, y) {\n        // set heading vector to point towards another point.\n        if ((typeof(to)).toLowerCase() === \'number\')\n            to = new Vector(to, y, 0);\n        else if (! (to instanceof Vector)) {\n            to = new Vector(to);\n        }\n        var res = to.sub(this.position);\n        res = res.normalize();\n        if (TurtleGraphics.defaults.degrees) {\n            return res.toAngle();\n        }\n        else {\n            return res;\n        }\n    }\n\n    Turtle.prototype.distance = function(to, y) {\n        if ((typeof(to)).toLowerCase() === \'number\')\n            to = new Vector(to, y, 0);\n        return this.position.sub(new Vector(to)).len();\n    }\n\n    Turtle.prototype.dot = function() {\n        var size = 2;\n        if (arguments.length >= 1) size = arguments[0];\n        size = size * this.turtleCanvas.lineScale;\n        with (this) {\n            with (context) {\n                var color = penStyle;\n                var nc = arguments[1] || color;\n                if (! animate) {\n                    fillStyle = nc;\n                    fillRect(position[0] - size / 2, position[1] - size / 2, size, size);\n                    fillStyle = color;\n                } else {\n                    addDrawingEvent(["DT", size, nc, position[0], position[1]]);\n                }\n            }\n        }\n\n    }\n\n    Turtle.prototype.circle = function(radius, extent) {\n        if (extent === undefined) {\n            extent = 360\n        }\n\t\tif (this.animate) {\n\t\t\tvar arcLen = Math.abs(radius * Math.PI * 2.0  * extent / 360);\n\t\t\tvar segLen = this.turtleCanvas.getSegmentLength();\n\t\t\tif (arcLen <= segLen)\n\t\t\t\tthis.arc(radius,extent);\n\t\t\telse {\n\t\t\t\t//\tBreak the arc into segments for animation\n\t\t\t\tvar extentPart = (segLen / arcLen) * extent;\n\t\t\t\tvar extentLeft = extent;\n\t\t\t\twhile (Math.abs(extentLeft) > Math.abs(extentPart)) {\n\t\t\t\t\tthis.arc(radius, extentPart);\n\t\t\t\t\textentLeft = extentLeft - extentPart;\n\t\t\t\t}\n\t\t\t\tif (Math.abs(extentLeft) > 0.01)\n\t\t\t\t\tthis.arc(radius, extentLeft);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.arc(radius,extent);\n\t\t}\n\t}\n\t\n    Turtle.prototype.arc = function(radius, extent) {\n\t\t//\tFigure out where the turtle is and which way it\'s facing\n\t\tvar turtleHeading = this.get_heading()\n\t\tvar tx = this.position[0]\n\t\tvar ty = this.position[1]\n\n\t\t//\tFigure out the circle center\n\t\tvar cx = tx + (radius * Math.cos((turtleHeading + 90) * Degree2Rad));\n\t\tvar cy = ty + (radius * Math.sin((turtleHeading + 90) * Degree2Rad));\n\n\t\t//\tCanvas arc angles go CLOCKWISE, not COUNTERCLOCKWISE like Turtle\n\n\t\t//\tFigure out our arc angles\n\t\tvar startAngleDeg;\n\t\tif (radius >= 0)\n\t\t\tstartAngleDeg = turtleHeading - 90;\n\t\telse\n\t\t\tstartAngleDeg = turtleHeading + 90;\n\n\t\tvar endAngleDeg;\n        if (extent) {\n\t\t\tif (radius >= 0)\n\t            endAngleDeg = startAngleDeg + extent;\n\t\t\telse\n\t            endAngleDeg = startAngleDeg - extent;\n        } else {\n\t\t\tif (radius >= 0)\n\t            endAngleDeg = startAngleDeg + 360;\n\t\t\telse\n\t\t\t\tendAngleDeg = startAngleDeg - 360;\n\t\t}\n\n\t\t//\tCanvas angles are opposite\n\t\tstartAngleDeg = 360 - startAngleDeg\n\t\tendAngleDeg   = 360 - endAngleDeg\n\n\t\t//\tBecuase the y axis has been flipped in HTML5 Canvas with a tanslation, we need to adjust the angles\n\t\tstartAngleDeg = -startAngleDeg\n\t\tendAngleDeg   = -endAngleDeg\n\n\t\t//\tConvert to radians\n\t\tvar startAngle = startAngleDeg * Degree2Rad;\n\t\tvar endAngle   = endAngleDeg   * Degree2Rad;\n\n\n\t\t//\tDo the drawing\n        if (! this.animate) {\n\t\t\tif (!this.filling)\n\t\t\t\tthis.context.beginPath();\n            this.context.arc(cx, cy, Math.abs(radius), startAngle, endAngle, (radius * extent <= 0));\n            this.context.stroke();\n\t\t\tif (!this.filling)\n\t\t\t\tthis.context.closePath();\n        } else {\n            this.addDrawingEvent(["CI", cx, cy, Math.abs(radius), startAngle, endAngle, (radius * extent <= 0)]);\n        }\n\n\t\t//\tMove the turtle only if we have to\n\t\tif (extent && (extent % 360) != 0) {\n\t\t\tvar turtleArc;\n\t\t\tif (radius >= 0)\n\t\t\t\tturtleArc = extent;\n\t\t\telse \n\t\t\t\tturtleArc = -extent;\n\t\t\tvar newTurtleHeading = (turtleHeading + turtleArc) % 360;\n\t\t\tif (newTurtleHeading < 0)\n\t\t\t\tnewTurtleHeading = newTurtleHeading + 360;\n\n\t\t\tvar nx = cx + (radius * Math.cos((newTurtleHeading - 90) * Degree2Rad));\n\t\t\tvar ny = cy + (radius * Math.sin((newTurtleHeading - 90) * Degree2Rad));\t//\ty coord is inverted in turtle\n\n\t\t\t//\tMove it internally\n\t\t\tthis.set_heading(newTurtleHeading);\n\t\t\tthis.teleport_to(nx,ny);\n\n\t\t\t//\tIf we\'re animating the turtle, move it on the screen\n\t\t\tif (this.animate) {\n\t\t\t\tthis.addDrawingEvent(["TT", this.heading]);\n\t\t\t}\n\t\t}\n\n    }\n\n    Turtle.prototype.write = function(theText, move, align, font) {\n        if (! this.animate) {\n            if (font)\n                this.context.font = font.v;\n            this.context.scale(1, -1);\n            this.context.fillText(theText, this.position[0], -this.position[1]);\n            this.context.scale(1, -1);\n        } else {\n            var fontspec;\n            if (font)\n                fontspec = font.v\n            this.addDrawingEvent(["WT", theText, fontspec, this.position[0], this.position[1]]);\n        }\n    }\n\n    Turtle.prototype.setworldcoordinates = function(llx, lly, urx, ury) {\n        this.turtleCanvas.setworldcoordinates(llx, lly, urx, ury);\n    }\n\n//\n// Pen and Style functions\n//\n    Turtle.prototype.pen_down = function () {\n        this.pen = true;\n    }\n\n    Turtle.prototype.down = Turtle.prototype.pen_down;\n\n    Turtle.prototype.pen_up = function () {\n        this.pen = false;\n    }\n\n    Turtle.prototype.up = Turtle.prototype.pen_up;\n\n    Turtle.prototype.get_pen = function () {\n        return this.pen;\n    }\n\n    Turtle.prototype.set_pen_width = function (w) {\n        if (this.animate)\n            this.addDrawingEvent(["PW", w * this.turtleCanvas.lineScale]);\n        else\n            this.penWidth = w;\n    }\n\n    Turtle.prototype.get_pen_width = function() {\n        return this.penWidth * this.turtleCanvas.lineScale;\n    }\n\n    Turtle.prototype.set_pen_color = function (c, g, b) {\n        if (typeof(c) == "string") {\n            this.penStyle = c;\n        } else {\n        \tvar rs\n        \tvar gs\n        \tvar bs\n        \tif (typeof( c) == "object" && c.length == 3) {\n\t\t\t\tvar c0 = Sk.builtin.asnum$(c[0]);\n\t\t\t\tvar c1 = Sk.builtin.asnum$(c[1]);\n\t\t\t\tvar c2 = Sk.builtin.asnum$(c[2]);\n        \t} else {\n                var c0 = Sk.builtin.asnum$(c);\n                var c1 = Sk.builtin.asnum$(g);\n                var c2 = Sk.builtin.asnum$(b);\n        \t}\n            rs = c0.toString(16);\n            gs = c1.toString(16);\n            bs = c2.toString(16);\n            while (rs.length < 2) rs = "0" + rs;\n            while (gs.length < 2) gs = "0" + gs;\n            while (bs.length < 2) bs = "0" + bs;\n            c = "#" + rs + gs + bs;\n            this.penStyle = c;\n        }\n\n        this.context.strokeStyle = c;\n        if (this.animate)\n            this.addDrawingEvent(["TC", c]);\n    }\n\n    Turtle.prototype.set_fill_color = function (c, g, b) {\n        if (typeof(c) == "string") {\n            this.fillStyle = c;\n        } else {\n        \tvar rs\n        \tvar gs\n        \tvar bs\n        \tif (typeof( c) == "object" && c.length == 3) {\n\t\t\t\tvar c0 = Sk.builtin.asnum$(c[0]);\n\t\t\t\tvar c1 = Sk.builtin.asnum$(c[1]);\n\t\t\t\tvar c2 = Sk.builtin.asnum$(c[2]);\n        \t} else {\n                var c0 = Sk.builtin.asnum$(c);\n                var c1 = Sk.builtin.asnum$(g);\n                var c2 = Sk.builtin.asnum$(b);\n        \t}\n            rs = c0.toString(16)\n            gs = c1.toString(16)\n            bs = c2.toString(16)\n            while (rs.length < 2) rs = "0" + rs;\n            while (gs.length < 2) gs = "0" + gs;\n            while (bs.length < 2) bs = "0" + bs;\n            c = "#" + rs + gs + bs;\n            this.fillStyle = c;\n        }\n\n        this.context.fillStyle = c;\n        if (this.animate)\n            this.addDrawingEvent(["FC", c]);\n    }\n\n    Turtle.prototype.begin_fill = function () {\n        if (! this.animate) {\n            this.filling = true;\n            this.context.beginPath();\n            this.context.moveTo(this.position[0], this.position[1]);\n        } else\n            this.addDrawingEvent(["BF", this.position[0], this.position[1]]);\n\n    }\n\n    Turtle.prototype.end_fill = function () {\n        if (! this.animate) {\n            this.context.stroke();\n            this.context.fill();\n            this.context.closePath();\n            this.filling = false;\n        } else\n            this.addDrawingEvent(["EF", this.position[0], this.position[1], this.fillStyle]);\n    }\n\n\n    Turtle.prototype.showturtle = function() {\n        if (this.animate) {\n            this.addDrawingEvent(["SH"]);\n        }\n        this.visible = true;\n    }\n\n    Turtle.prototype.hideturtle = function() {\n        if (this.animate) {\n            this.addDrawingEvent(["HT"]);\n        }\n        this.visible = false;\n    }\n\n    Turtle.prototype.isvisible = function() {\n        return this.visible;\n    }\n\n    // \n    // Appearance\n    //\n\n    Turtle.prototype.shape = function(s) {\n        if (this.shapeStore[s])\n            this.currentShape = s;\n        else {\n        }\n    }\n\n    Turtle.prototype.drawturtle = function(heading, position) {\n        var rtPoints = [];\n        var plist = this.shapeStore[this.currentShape];\n        var head;\n        if (! (heading === undefined))\n            head = heading - 90.0;\n        else\n            head = this.heading.toAngle() - 90.0;\n        if (! position)\n            position = this.position\n        for (p in plist) {\n            rtPoints.push(plist[p].scale(this.turtleCanvas.xptscale,this.turtleCanvas.yptscale).rotate(head).add(position));\n        }\n        this.context.beginPath();\n        this.context.moveTo(rtPoints[0][0], rtPoints[0][1]);\n        for (var i = 1; i < rtPoints.length; i++) {\n            this.context.lineTo(rtPoints[i][0], rtPoints[i][1]);\n        }\n        this.context.closePath();\n        this.context.stroke();\n        if (this.fillStyle) {\n            this.context.fill();\n        }\n    }\n\n    Turtle.prototype.stamp = function() {\n        // either call drawTurtle or just add a DT with current position and heading to the drawingEvents list.\n        if (this.animate) {\n            this.addDrawingEvent(["ST",this.position[0],this.position[1],this.heading.toAngle()]);\n        } else\n            this.drawturtle();\n    }\n    \n    Turtle.prototype.clear = function () {\n    \tif (this.animate) {\n    \t\tthis.addDrawingEvent(["CL"])\n    \t} else {\n    \t\tclear_canvas(this.canvasID);\n    \t}\n    }\n\n    function clear_canvas(canId) {\n        with (document.getElementById(canId).getContext(\'2d\')) {\n            if (arguments.length >= 2) {\n//\t\tfillStyle = arguments[1];\n//\t\tfillRect(0, 0, canvas.width, canvas.height);\n            }\n            clearRect(-canvas.width / 2, -canvas.height / 2, canvas.width, canvas.height);\n        }\n    }\n\n\n    // Create a 3d Vector class for manipulating turtle heading, and position.\n\n    function Vector(x, y, z) {\n        if ((typeof(x)).toLowerCase() === \'number\') {\n            Array.prototype.push.call(this, x);\n            Array.prototype.push.call(this, y);\n            Array.prototype.push.call(this, z);\n        }\n        else {\n            for (var i in x) {\n                Array.prototype.push.call(this, x[i]);\n            }\n        }\n    }\n\n\n    // Create a vector object given a direction as an angle.\n    Vector.angle2vec = function(phi) {\n        var res = new Vector([0.0,0.0,0.0]);\n        phi = phi * Degree2Rad;\n        res[0] = Math.cos(phi);\n        res[1] = Math.sin(phi);\n        return res.normalize();\n    }\n\n    // This trick allows you to access a Vector object like an array\n    // myVec[0] == x\n    // myVec[1] == y\n    // myVec[2] == z\n    // we really only need the z for the convenience of rotating\n    Vector.prototype.addItem = function(item) {\n        Array.prototype.push.call(this, item);\n    }\n\n    Vector.prototype.linear = function(a, b, v) {\n        var result = [ ];\n        for (var c = 0; c <= 2; ++c) {\n            result[c] = a * this[c] + b * v[c];\n        }\n        return new Vector(result);\n    }\n\n    Vector.prototype.cross = function(v) {\n        // Return cross product of this and v\n        var result = [ ];\n        for (var c = 0; c <= 2; ++c) {\n            result[c] = this[(c + 1) % 3] * v[(c + 2) % 3] - this[(c + 2) % 3] * v[(c + 1) % 3];\n        }\n        return new Vector(result);\n    }\n\n    Vector.prototype.rotate = function(angle) {\n        // Rotate this counter clockwise by angle.\n        var perp = new Vector(-this[1], this[0], 0);\n        angle = angle * Degree2Rad;\n        var c = Math.cos(angle);\n        var s = Math.sin(angle);\n        return new Vector(this[0] * c + perp[0] * s, this[1] * c + perp[1] * s, 0);\n    }\n\n    Vector.prototype.rotateNormal = function(v, w, alpha) {\n        // Return rotation of this in direction of v about w over alpha\n        // Requires: v, w are vectors; alpha is angle in radians\n        //   this, v, w are orthonormal\n        return this.linear(Math.cos(alpha), Math.sin(alpha), v);\n    }\n\n    Vector.prototype.normalize = function() {\n        var n = this.len();\n        var res = this.div(n);\n        return res;\n    }\n\n    Vector.prototype.toAngle = function() {\n        // workaround for values getting set to +/i xxx e -16 fooling the +/- checks below\n        if (Math.abs(this[1]) < 0.00001) this[1] = 0.0;\n        if (Math.abs(this[0]) < 0.00001) this[0] = 0.0;\n        var rads = Math.atan(Math.abs(this[1]) / Math.abs(this[0]));\n        var deg = rads * Rad2Degree;\n        if (this[0] < 0 && this[1] > 0) deg = 180 - deg;\n        else if (this[0] < 0 && this[1] <= 0) deg = 180.0 + deg;\n        else if (this[0] >= 0 && this[1] < 0) deg = 360 - deg;\n        return deg;\n    }\n\n    // divide all vector components by the same value\n    Vector.prototype.div = function(n) {\n        res = []\n        res[0] = this[0] / n;\n        res[1] = this[1] / n;\n        res[2] = this[2] / n;\n        return new Vector(res);\n    }\n\n    // subtract one vector from another\n    Vector.prototype.sub = function(v) {\n        res = new Vector(0, 0, 0);\n        res[0] = this[0] - v[0];\n        res[1] = this[1] - v[1];\n        res[2] = this[2] - v[2];\n        return res;\n    }\n\n    Vector.prototype.add = function(v) {\n        res = new Vector(0, 0, 0);\n        res[0] = this[0] + v[0];\n        res[1] = this[1] + v[1];\n        res[2] = this[2] + v[2];\n        return res;\n    }\n\n    Vector.prototype.smul = function(k) {  // scalar multiplication\n        res = new Vector(0, 0, 0);\n        res[0] = this[0] * k;\n        res[1] = this[1] * k;\n        res[2] = this[2] * k;\n        return res;\n    }\n\n    Vector.prototype.scale = function(xs,ys) {\n        res = new Vector(0,0,0);\n        res[0] =  this[0] * ys;\n        res[1] =  this[1] * xs;\n        res[2] = 1.0;\n        return res;\n    }\n\n    Vector.prototype.len = function() {\n        return Math.sqrt(this[0] * this[0] + this[1] * this[1] + this[2] * this[2]);\n    }\n\n\n    TurtleGraphics.defaults = { canvasID: \'mycanvas\', degrees: true, animate: true }\n    TurtleGraphics.turtleList = [];\n    TurtleGraphics.Turtle = Turtle;\n    TurtleGraphics.TurtleCanvas = TurtleCanvas;\n    TurtleGraphics.canvasLib = {}\n    TurtleGraphics.clear_canvas = clear_canvas;\n    TurtleGraphics.Vector = Vector;\n    TurtleGraphics.canvasInit = false;\n    TurtleGraphics.eventCount = 0;\n    TurtleGraphics.renderClock = 0;\n    TurtleGraphics.renderTime  = 0; // RNL\n\n})();\n\n\n//\n// Wrapper around the Turtle Module starts here.\n//\n//\nvar $builtinmodule = function(name) {\n    var mod = {};\n    // First we create an object, this will end up being the class\n    // class\n    Sk.tg = TurtleGraphics;\n\n    var checkArgs = function(expected, actual, func) {\n        if (actual != expected ) {\n            throw new Sk.builtin.TypeError(func + " takes exactly " + expected +\n                    " positional argument (" + actual + " given)")\n        }\n    }\n\n    var turtle = function($gbl, $loc) {\n        $loc.__init__ = new Sk.builtin.func(function(self) {\n            TurtleGraphics.defaults = {canvasID: Sk.canvas, animate: true, degrees: true};\n            self.theTurtle = new TurtleGraphics.Turtle();\n        });\n\n//\n// Turtle Motion\n//\n        //\n        // Move and Draw\n        //\n        $loc.forward = new Sk.builtin.func(function(self, dist) {\n\t\t\tdist = Sk.builtin.asnum$(dist);\n            checkArgs(2,arguments.length,"forward()");\n            self.theTurtle.forward(dist);\n        });\n\n        $loc.fd = $loc.forward;\n\n        $loc.backward = new Sk.builtin.func(function(self, dist) {\n\t\t\tdist = Sk.builtin.asnum$(dist);\n            checkArgs(2,arguments.length,"backward()");\n            self.theTurtle.forward(-dist);\n        });\n\n        $loc.back = $loc.backward;\n        $loc.bk = $loc.backward;\n\n        $loc.right = new Sk.builtin.func(function(self, angle) {\n\t\t\tangle = Sk.builtin.asnum$(angle);\n            checkArgs(2,arguments.length,"right()");\n            self.theTurtle.turn(angle);\n        });\n\n        $loc.rt = $loc.right;\n\n        $loc.left = new Sk.builtin.func(function(self, angle) {\n\t\t\tangle = Sk.builtin.asnum$(angle);\n            checkArgs(2,arguments.length,"left()");\n            self.theTurtle.turn(-angle);\n        });\n\n        $loc.lt = $loc.left;\n\n        $loc.goto_$rw$ = new Sk.builtin.func(function(self, nx, ny) {\n\t\t\tnx = Sk.builtin.asnum$(nx);\n\t\t\tny = Sk.builtin.asnum$(ny);\n            checkArgs(3,arguments.length,"goto()");\n            self.theTurtle.goto(nx, ny);\n        });\n\n        $loc.setposition = new Sk.builtin.func(function(self,nx,ny) {\n\t\t\tnx = Sk.builtin.asnum$(nx);\n\t\t\tny = Sk.builtin.asnum$(ny);\n            checkArgs(3,arguments.length,"setposition()");\n            self.theTurtle.up();\n            self.theTurtle.goto(nx,ny);\n            self.theTurtle.down();\n        });\n        $loc.setpos = $loc.setposition;\n\n        $loc.setx = new Sk.builtin.func(function(self, nx) {\n\t\t\tnx = Sk.builtin.asnum$(nx);\n            checkArgs(2,arguments.length,"setx()");\n            self.theTurtle.goto(nx, self.theTurtle.GetY());\n        });\n\n        $loc.sety = new Sk.builtin.func(function(self, ny) {\n\t\t\tny = Sk.builtin.asnum$(ny);\n            checkArgs(2,arguments.length,"sety()");\n            self.theTurtle.goto(self.theTurtle.GetX(), ny);\n        });\n\n        $loc.setheading = new Sk.builtin.func(function(self, newhead) {\n\t\t\tnewhead = Sk.builtin.asnum$(newhead);\n            checkArgs(2,arguments.length,"setheading()");\n            return self.theTurtle.set_heading(newhead);\n        });\n\n        $loc.seth = $loc.setheading;\n\n        $loc.home = new Sk.builtin.func(function(self) {\n            self.theTurtle.go_home();\n        });\n\n        $loc.dot = new Sk.builtin.func(function(self, /*opt*/ size, color) {\n\t\t\tsize = Sk.builtin.asnum$(size);\n            size = size || 1;\n            if (color) {\n                color = color.v || self.theTurtle.penStyle;\n            }\n            self.theTurtle.dot(size, color);\n        });\n\n        $loc.circle = new Sk.builtin.func(function(self, radius, extent) {\n\t\t\tradius = Sk.builtin.asnum$(radius);\n\t\t\textent = Sk.builtin.asnum$(extent);\n            self.theTurtle.circle(radius, extent);\n        });\n\n        $loc.delay = new Sk.builtin.func(function(self, d) {\n\t\t\td = Sk.builtin.asnum$(d);\n            return self.theTurtle.delay(d);\n        });\n\n        $loc.speed = new Sk.builtin.func(function(self, s, t) {\n\t\t\ts = Sk.builtin.asnum$(s);\n\t\t\tt = Sk.builtin.asnum$(t);\n            self.theTurtle.speed(s,t);\n        });\n\n        $loc.tracer = new Sk.builtin.func(function(self, t, d) {\n\t\t\tt = Sk.builtin.asnum$(t);\n\t\t\td = Sk.builtin.asnum$(d);\n            self.theTurtle.tracer(t, d);\n        });\n\n\t\t$loc.update = new Sk.builtin.func(function(self) {\n\t\t\t//\tDummy function to emulate update... when not animating, we don\'t save the drawing operations, so this is pointless for us\n\t\t});\n\n        // todo:  stamp, clearstamp, clearstamps, undo, speed\n\n        //\n        // Tell Turtle\'s state\n        //\n        $loc.heading = new Sk.builtin.func(function(self) {\n            checkArgs(1,arguments.length,"heading()");\n            return Sk.builtin.assk$(self.theTurtle.get_heading(),Sk.builtin.nmber.float$);\n        });\n\n        $loc.position = new Sk.builtin.func(function(self) {\n            checkArgs(1,arguments.length,"position()");\n            var res = self.theTurtle.get_position();\n            var x = new Sk.builtin.tuple([Sk.builtin.assk$(res[0],Sk.builtin.nmber.float$),\n                                          Sk.builtin.assk$(res[1],Sk.builtin.nmber.float$) ]);\n            return x;\n        });\n\n        $loc.pos = $loc.position;\n\n        $loc.xcor = new Sk.builtin.func(function(self) {\n            checkArgs(1,arguments.length,"xcor()");\n            var res = self.theTurtle.getx();\n            return Sk.builtin.assk$(res,Sk.builtin.nmber.float$);\n        });\n\n        $loc.ycor = new Sk.builtin.func(function(self) {\n            checkArgs(1,arguments.length,"ycor()");\n            var res = self.theTurtle.gety();\n            return Sk.builtin.assk$(res,Sk.builtin.nmber.float$);\n        });\n\n        $loc.towards = new Sk.builtin.func(function(self, tx, ty) {\n\t\t\ttx = Sk.builtin.asnum$(tx);\n\t\t\tty = Sk.builtin.asnum$(ty);\n            if ((typeof(tx)).toLowerCase() === \'number\') {\n                tx = [tx, ty, 0];\n            } else {\n                tx = [Sk.builtin.asnum$(tx.theTurtle.getx()),Sk.builtin.asnum$(tx.theTurtle.gety()),Sk.builtin.asnum$(0)]\n            }\n            return Sk.builtin.assk$(self.theTurtle.towards(tx),Sk.builtin.nmber.float$);\n        });\n\n        // tx can be either a number or a vector position.\n        // tx can not be a turtle at this time as multiple turtles have not been implemented yet.\n        $loc.distance = new Sk.builtin.func(function(self, tx, ty) {\n\t\t\ttx = Sk.builtin.asnum$(tx);\n\t\t\tty = Sk.builtin.asnum$(ty);\n            if ((typeof(tx)).toLowerCase() === \'number\') {\n                tx = [tx, ty, 0];\n            } else {\n                tx = [tx.theTurtle.getx(), tx.theTurtle.gety(), 0];\n            }\n            return Sk.builtin.assk$(self.theTurtle.distance(tx),Sk.builtin.nmber.float$);\n        });\n\n        //\n        // Setting and Measurement\n        //\n\n        // todo:  degrees and radians...\n\n//\n// Pen Control\n//\n\n        //\n        // Drawing State\n        //\n\n        $loc.up = new Sk.builtin.func(function(self) {\n            checkArgs(1,arguments.length,"up()");\n            self.theTurtle.pen_up();\n        });\n\n        $loc.penup = $loc.up;\n        $loc.pu = $loc.up;\n\n        $loc.down = new Sk.builtin.func(function(self) {\n            checkArgs(1,arguments.length,"down()");\n            self.theTurtle.pen_down();\n        });\n\n        $loc.pendown = $loc.down;\n        $loc.pd = $loc.down;\n\n        $loc.width = new Sk.builtin.func(function(self, w) {\n\t\t\tw = Sk.builtin.asnum$(w);\n            checkArgs(2,arguments.length,"width()");\n            self.theTurtle.set_pen_width(w);\n        });\n\n        $loc.pensize = $loc.width;\n\n        $loc.isdown = new Sk.builtin.func(function(self) {\n            checkArgs(1,arguments.length,"isdown()");\n            return self.theTurtle.get_pen();\n        });\n\n        // todo:  pen  -- return a dictionary full of pen stuff\n\n        //\n        // Color Control\n        //\n\n        $loc.fillcolor = new Sk.builtin.func(function(self, color, green, blue) {\n            if (color) {\n                if (blue) {\n                    self.theTurtle.set_fill_color(color, green, blue);\n                } else {\n                    color = color.v || self.theTurtle.context.fillStyle;\n                    self.theTurtle.set_fill_color(color);\n                }\n            } else\n                return self.theTurtle.fillStyle;\n        });\n\n        $loc.pencolor = new Sk.builtin.func(function(self, color, green, blue) {\n            if (color) {\n                if (blue) {\n\t\t\t\t\tcolor = Sk.builtin.asnum$(color);\n\t\t\t\t\tgreen = Sk.builtin.asnum$(green);\n\t\t\t\t\tblue = Sk.builtin.asnum$(blue);\n                    self.theTurtle.set_pen_color(color, green, blue);\n                } else {\n                    color = color.v || self.theTurtle.context.fillStyle;\n                    self.theTurtle.set_pen_color(color);\n                }\n            } else\n                return self.theTurtle.penStyle;\n        });\n\n        $loc.color = new Sk.builtin.func(function(self, color, green, blue) {\n            if(color) {\n                if (blue) {\n                    self.theTurtle.set_pen_color(color, green, blue);\n                    self.theTurtle.set_fill_color(color, green, blue);\n                } else {\n                    color = color.v || self.theTurtle.context.fillStyle;\n                    self.theTurtle.set_pen_color(color);\n                    self.theTurtle.set_fill_color(color);\n                }\n            } else \n                return [self.theTurtle.penStyle, self.theTurtle.fillStyle];            \n        });\n\n        //\n        //  Filling\n        //\n\n        $loc.begin_fill = new Sk.builtin.func(function(self) {\n            checkArgs(1,arguments.length,"begin_fill()");\n            self.theTurtle.begin_fill();\n        });\n\n        $loc.end_fill = new Sk.builtin.func(function(self) {\n            checkArgs(1,arguments.length,"end_fill()");\n            self.theTurtle.end_fill();\n        });\n\n        $loc.fill = new Sk.builtin.func(function(self, fillt) {\n\t\t\tif (fillt === undefined)\n\t\t\t\treturn self.theTurtle.filling;\n            if (fillt)\n                self.theTurtle.begin_fill();\n            else\n                self.theTurtle.end_fill();\n        });\n\n        //\n        // More drawing control\n        //\n\n        $loc.reset = new Sk.builtin.func(function(self) {\n            self.theTurtle.clean();\n        });\n\n        $loc.showturtle = new Sk.builtin.func(function(self) {\n            checkArgs(1,arguments.length,"showturtle()");\n            self.theTurtle.showturtle();\n        });\n        $loc.st = $loc.showturtle;\n\n        $loc.hideturtle = new Sk.builtin.func(function(self) {\n            checkArgs(1,arguments.length,"hideturtle()");\n            self.theTurtle.hideturtle();\n        });\n        $loc.ht = $loc.hideturtle;\n\n        $loc.isvisible = new Sk.builtin.func(function(self) {\n            checkArgs(1,arguments.length,"isvisible()");\n            self.theTurtle.isvisible()\n        });\n\n        $loc.stamp = new Sk.builtin.func(function(self) {\n            checkArgs(1,arguments.length,"stamp()");\n            self.theTurtle.stamp();\n        });\n\n        $loc.shape = new Sk.builtin.func(function(self, s) {\n            checkArgs(2,arguments.length,"shape()");\n            self.theTurtle.shape(s.v);\n        });\n\n\n        // todo the move, align, and font parameters should be kwargs...\n        $loc.write = new Sk.builtin.func(function(self, mystr, move, align, font) {\n            self.theTurtle.write(mystr.v, move, align, font);\n        });\n\n        // todo clean  -- again multiple turtles\n\n        $loc.setworldcoordinates = new Sk.builtin.func(function(self, llx, lly, urx, ury) {\n\t\t\tllx = Sk.builtin.asnum$(llx);\n\t\t\tlly = Sk.builtin.asnum$(lly);\n\t\t\turx = Sk.builtin.asnum$(urx);\n\t\t\tury = Sk.builtin.asnum$(ury);\n            self.theTurtle.setworldcoordinates(llx, lly, urx, ury);\n        });\n\n\t\t//\tAdded by RNL\n\n\t\t$loc.clear = new Sk.builtin.func(function(self) {\n\t\t\tself.theTurtle.clear()\n\t\t});\n\n    }\n\n    mod.Turtle = Sk.misceval.buildClass(mod, turtle, \'Turtle\', []);\n\n    var screen = function($gbl, $loc) {\n        $loc.__init__ = new Sk.builtin.func(function(self) {\n            TurtleGraphics.defaults = {canvasID: Sk.canvas, animate: true, degrees: true};\n            var currentCanvas = TurtleGraphics.canvasLib[TurtleGraphics.defaults.canvasID];\n            if (currentCanvas === undefined) {\n                self.theScreen = new TurtleGraphics.TurtleCanvas(TurtleGraphics.defaults);\n            } else {\n                self.theScreen = currentCanvas;\n            }\n        });\n\n        $loc.bgcolor = new Sk.builtin.func(function(self, c) {\n            self.theScreen.bgcolor(c);\n        });\n\n        $loc.setworldcoordinates = new Sk.builtin.func(function(self, llx,lly,urx,ury) {\n\t\t\tllx = Sk.builtin.asnum$(llx);\n\t\t\tlly = Sk.builtin.asnum$(lly);\n\t\t\turx = Sk.builtin.asnum$(urx);\n\t\t\tury = Sk.builtin.asnum$(ury);\n            self.theScreen.setworldcoordinates(llx,lly,urx,ury);\n        });\n\n        $loc.exitonclick = new Sk.builtin.func(function(self) {\n            self.theScreen.exitonclick();\n        });\n\n        $loc.title = new Sk.builtin.func(function(self,titlestring) {\n            // no op....\n        });\n\n        $loc.window_width = new Sk.builtin.func(function(self) {\n            return self.theScreen.window_width();\n        });\n\n        $loc.window_height = new Sk.builtin.func(function(self) {\n            return self.theScreen.window_height();\n        });\n\n        $loc.turtles = new Sk.builtin.func(function(self) {\n            return self.theScreen.turtles();\n        });\n\n\t\t$loc.colormode = new Sk.builtin.func(function(self) {\n\t\t\t//\tEmpty function to emulate compatibility\n\t\t});\n        \n//        $loc.clear = new Sk.builtin.func(function(self) {\n//        \t\n//        });\n\n        var myfunc = function(self, width, height, startx, starty) {\n\t\t\twidth = Sk.builtin.asnum$(width);\n\t\t\theight = Sk.builtin.asnum$(height);\n            self.theScreen.setup(width,height);\n        }\n        // this should allow for named parameters\n        myfunc.co_varnames = [\'self\',\'width\',\'height\',\'startx\',\'starty\'];\n        myfunc.$defaults = [null,500,500,0,0];\n        $loc.setup = new Sk.builtin.func(myfunc);\n    }\n\n    mod.Screen = Sk.misceval.buildClass(mod, screen, \'Screen\', []);\n\n    mod.tracer = new Sk.builtin.func(function(t, d) {\n\t\tt = Sk.builtin.asnum$(t);\n\t\td = Sk.builtin.asnum$(d);\n\t\tfor (var i in Sk.tg.canvasLib)\n\t\t\tSk.tg.canvasLib[i].tracer(t, d);\n    });\n\n\tmod.update = new Sk.builtin.func(function(self) {\n\t\t//\tDummy function to emulate update... when not animating, we don\'t save the drawing operations, so this is pointless for us\n\t});\n\n\n    return mod\n}\n',
    'src/lib/webgl/math.js': 'var $builtinmodule = function(name)\n{\n    var mod = {};\n\n    // todo; should probably put this in a math package\n    mod.Mat44 = Sk.misceval.buildClass(mod, function($gbl, $loc)\n            {\n                $loc.__init__ = new Sk.builtin.func(function(self)\n                    {\n                        Sk.misceval.callsim($loc.loadIdentity, self);\n                        self.stack = [];\n                    });\n\n                $loc.push = new Sk.builtin.func(function(self)\n                    {\n                        self.stack.push(self.elements.slice(0));\n                    });\n\n                $loc.pop = new Sk.builtin.func(function(self)\n                    {\n                        self.elements = self.stack.pop();\n                    });\n\n                $loc.loadIdentity = new Sk.builtin.func(function(self)\n                    {\n                        self.elements = [1.0, 0.0, 0.0, 0.0,\n                                         0.0, 1.0, 0.0, 0.0,\n                                         0.0, 0.0, 1.0, 0.0,\n                                         0.0, 0.0, 0.0, 1.0];\n                    });\n\n                $loc.transform3 = new Sk.builtin.func(function(self, v)\n                    {\n                        var e = self.elements;\n                        return Sk.misceval.callsim(mod.Vec3,\n                            e[0] * v.x + e[4] * v.y + e[8] * v.z,\n                            e[1] * v.x + e[5] * v.y + e[9] * v.z,\n                            e[2] * v.x + e[6] * v.y + e[10] * v.z);\n                    });\n\n                $loc.scale = new Sk.builtin.func(function(self, sx, sy, sz)\n                        {\n                            self.elements[0*4+0] *= sx;\n                            self.elements[0*4+1] *= sx;\n                            self.elements[0*4+2] *= sx;\n                            self.elements[0*4+3] *= sx;\n\n                            self.elements[1*4+0] *= sy;\n                            self.elements[1*4+1] *= sy;\n                            self.elements[1*4+2] *= sy;\n                            self.elements[1*4+3] *= sy;\n\n                            self.elements[2*4+0] *= sz;\n                            self.elements[2*4+1] *= sz;\n                            self.elements[2*4+2] *= sz;\n                            self.elements[2*4+3] *= sz;\n\n                            return self;\n                        });\n\n                $loc.translate = new Sk.builtin.func(function(self, tx, ty, tz)\n                        {\n                            self.elements[3*4+0] += self.elements[0*4+0] * tx + self.elements[1*4+0] * ty + self.elements[2*4+0] * tz;\n                            self.elements[3*4+1] += self.elements[0*4+1] * tx + self.elements[1*4+1] * ty + self.elements[2*4+1] * tz;\n                            self.elements[3*4+2] += self.elements[0*4+2] * tx + self.elements[1*4+2] * ty + self.elements[2*4+2] * tz;\n                            self.elements[3*4+3] += self.elements[0*4+3] * tx + self.elements[1*4+3] * ty + self.elements[2*4+3] * tz;\n                            return self;\n                        });\n\n                $loc.rotate = new Sk.builtin.func(function(self, angle, x, y, z)\n                        {\n                            var mag = Math.sqrt(x*x + y*y + z*z);\n                            var sinAngle = Math.sin(angle * Math.PI / 180.0);\n                            var cosAngle = Math.cos(angle * Math.PI / 180.0);\n\n                            if (mag > 0)\n                            {\n                                var xx, yy, zz, xy, yz, zx, xs, ys, zs;\n                                var oneMinusCos;\n                                var rotMat;\n\n                                x /= mag;\n                                y /= mag;\n                                z /= mag;\n\n                                xx = x * x;\n                                yy = y * y;\n                                zz = z * z;\n                                xy = x * y;\n                                yz = y * z;\n                                zx = z * x;\n                                xs = x * sinAngle;\n                                ys = y * sinAngle;\n                                zs = z * sinAngle;\n                                oneMinusCos = 1.0 - cosAngle;\n\n                                rotMat = Sk.misceval.callsim(mod.Mat44);\n\n                                rotMat.elements[0*4+0] = (oneMinusCos * xx) + cosAngle;\n                                rotMat.elements[0*4+1] = (oneMinusCos * xy) - zs;\n                                rotMat.elements[0*4+2] = (oneMinusCos * zx) + ys;\n                                rotMat.elements[0*4+3] = 0.0;\n\n                                rotMat.elements[1*4+0] = (oneMinusCos * xy) + zs;\n                                rotMat.elements[1*4+1] = (oneMinusCos * yy) + cosAngle;\n                                rotMat.elements[1*4+2] = (oneMinusCos * yz) - xs;\n                                rotMat.elements[1*4+3] = 0.0;\n\n                                rotMat.elements[2*4+0] = (oneMinusCos * zx) - ys;\n                                rotMat.elements[2*4+1] = (oneMinusCos * yz) + xs;\n                                rotMat.elements[2*4+2] = (oneMinusCos * zz) + cosAngle;\n                                rotMat.elements[2*4+3] = 0.0;\n\n                                rotMat.elements[3*4+0] = 0.0;\n                                rotMat.elements[3*4+1] = 0.0;\n                                rotMat.elements[3*4+2] = 0.0;\n                                rotMat.elements[3*4+3] = 1.0;\n\n                                rotMat = rotMat.multiply(self);\n                                self.elements = rotMat.elements;\n                            }\n                            return self;\n                        });\n\n                $loc.multiply = new Sk.builtin.func(function(self, right)\n                        {\n                            var tmp = Sk.misceval.callsim(mod.Mat44);\n\n                            for (var i = 0; i < 4; i++)\n                            {\n                                tmp.elements[i*4+0] =\n                                (self.elements[i*4+0] * right.elements[0*4+0]) +\n                                (self.elements[i*4+1] * right.elements[1*4+0]) +\n                                (self.elements[i*4+2] * right.elements[2*4+0]) +\n                                (self.elements[i*4+3] * right.elements[3*4+0]) ;\n\n                                tmp.elements[i*4+1] =\n                                (self.elements[i*4+0] * right.elements[0*4+1]) +\n                                (self.elements[i*4+1] * right.elements[1*4+1]) +\n                                (self.elements[i*4+2] * right.elements[2*4+1]) +\n                                (self.elements[i*4+3] * right.elements[3*4+1]) ;\n\n                                tmp.elements[i*4+2] =\n                                (self.elements[i*4+0] * right.elements[0*4+2]) +\n                                (self.elements[i*4+1] * right.elements[1*4+2]) +\n                                (self.elements[i*4+2] * right.elements[2*4+2]) +\n                                (self.elements[i*4+3] * right.elements[3*4+2]) ;\n\n                                tmp.elements[i*4+3] =\n                                (self.elements[i*4+0] * right.elements[0*4+3]) +\n                                (self.elements[i*4+1] * right.elements[1*4+3]) +\n                                (self.elements[i*4+2] * right.elements[2*4+3]) +\n                                (self.elements[i*4+3] * right.elements[3*4+3]) ;\n                            }\n\n                            self.elements = tmp.elements;\n                            return self;\n                        });\n\n                /* Following gluLookAt implementation is adapted from\n                 * the Mesa 3D Graphics library. http://www.mesa3d.org\n                 */\n                // todo; rewrite this with proper vec/mat ops\n                $loc.lookAt = new Sk.builtin.func(function(self, eyeX, eyeY, eyeZ,\n                                                                 centerX, centerY, centerZ,\n                                                                 upX, upY, upZ)\n                        {\n                            /* Z vector */\n                            var z = [\n                                eyeX - centerX,\n                                eyeY - centerY,\n                                eyeZ - centerZ\n                            ];\n                            var mag = Math.sqrt(z[0] * z[0] + z[1] * z[1] + z[2] * z[2]);\n                            if (mag)\n                            {\n                                z[0] /= mag;\n                                z[1] /= mag;\n                                z[2] /= mag;\n                            }\n\n                            /* Y vector */\n                            var y = [ upX, upY, upZ ];\n\n                            /* X vector = Y cross Z */\n                            var x = [];\n                            x[0] = y[1] * z[2] - y[2] * z[1];\n                            x[1] = -y[0] * z[2] + y[2] * z[0];\n                            x[2] = y[0] * z[1] - y[1] * z[0];\n\n                            /* Recompute Y = Z cross X */\n                            y[0] = z[1] * x[2] - z[2] * x[1];\n                            y[1] = -z[0] * x[2] + z[2] * x[0];\n                            y[2] = z[0] * x[1] - z[1] * x[0];\n\n                            /* mpichler, 19950515 */\n                            /* cross product gives area of parallelogram, which is < 1.0 for\n                            * non-perpendicular unit-length vectors; so normalize x, y here\n                            */\n\n                            mag = Math.sqrt(x[0] * x[0] + x[1] * x[1] + x[2] * x[2]);\n                            if (mag) {\n                                x[0] /= mag;\n                                x[1] /= mag;\n                                x[2] /= mag;\n                            }\n\n                            mag = Math.sqrt(y[0] * y[0] + y[1] * y[1] + y[2] * y[2]);\n                            if (mag) {\n                                y[0] /= mag;\n                                y[1] /= mag;\n                                y[2] /= mag;\n                            }\n\n                            var lookAt = Sk.misceval.callsim(mod.Mat44);\n                            lookAt.elements[0 * 4 + 0] = x[0];\n                            lookAt.elements[1 * 4 + 0] = x[1];\n                            lookAt.elements[2 * 4 + 0] = x[2];\n                            lookAt.elements[3 * 4 + 0] = 0.;\n                            lookAt.elements[0 * 4 + 1] = y[0];\n                            lookAt.elements[1 * 4 + 1] = y[1];\n                            lookAt.elements[2 * 4 + 1] = y[2];\n                            lookAt.elements[3 * 4 + 1] = 0.;\n                            lookAt.elements[0 * 4 + 2] = z[0];\n                            lookAt.elements[1 * 4 + 2] = z[1];\n                            lookAt.elements[2 * 4 + 2] = z[2];\n                            lookAt.elements[3 * 4 + 2] = 0.;\n                            lookAt.elements[0 * 4 + 3] = 0.;\n                            lookAt.elements[1 * 4 + 3] = 0.;\n                            lookAt.elements[2 * 4 + 3] = 0.;\n                            lookAt.elements[3 * 4 + 3] = 1.;\n\n                            // log(lookAt.elements);\n\n                            lookAt = lookAt.multiply(self);\n                            self.elements = lookAt.elements;\n                            self.translate(-eyeX, -eyeY, -eyeZ);\n\n                            // log(this.elements);\n\n                            return self;\n                        });\n            },\n            \'Mat44\', []);\n\n    // todo; should probably put this in a math package\n    mod.Mat33 = Sk.misceval.buildClass(mod, function($gbl, $loc)\n            {\n                $loc.__init__ = new Sk.builtin.func(function(self)\n                    {\n                        Sk.misceval.callsim($loc.loadIdentity, self);\n                    });\n\n                $loc.loadIdentity = new Sk.builtin.func(function(self)\n                    {\n                        self.elements = [1.0, 0.0, 0.0,\n                                         0.0, 1.0, 0.0,\n                                         0.0, 0.0, 1.0];\n                    });\n            },\n            \'Mat33\', []);\n\n    mod.Vec3 = Sk.misceval.buildClass(mod, function($gbl, $loc)\n            {\n                $loc.__init__ = new Sk.builtin.func(function(self, x, y, z)\n                    {\n                        self.x = x;\n                        self.y = y;\n                        self.z = z;\n                    });\n                $loc.__sub__ = new Sk.builtin.func(function(self, other)\n                    {\n                        return Sk.misceval.callsim(mod.Vec3, self.x - other.x, self.y - other.y, self.z - other.z);\n                    });\n            },\n            \'Vec3\', []);\n    \n    mod.cross = new Sk.builtin.func(function(v1, v2)\n            {\n                goog.asserts.assert(v1 instanceof mod.Vec3 && v2 instanceof mod.Vec3);\n                return Sk.misceval.callsim(mod.Vec3,\n                    v1.y * v2.z - v1.z * v2.y,\n                    v1.z * v2.x - v1.x * v2.z,\n                    v1.x * v2.y - v1.y * v2.x);\n            });\n\n    return mod;\n};\n',
    'src/builtin/unittest.py': '#!/usr/bin/env python\n\'\'\'\nPython unit testing framework, based on Erich Gamma\'s JUnit and Kent Beck\'s\nSmalltalk testing framework.\n\nThis module contains the core framework classes that form the basis of\nspecific test cases and suites (TestCase, TestSuite etc.), and also a\ntext-based utility class for running the tests and reporting the results\n (TextTestRunner).\n\nSimple usage:\n\n    import unittest\n\n    class IntegerArithmenticTestCase(unittest.TestCase):\n        def testAdd(self):  ## test method names begin \'test*\'\n            self.assertEquals((1 + 2), 3)\n            self.assertEquals(0 + 1, 1)\n        def testMultiply(self):\n            self.assertEquals((0 * 10), 0)\n            self.assertEquals((5 * 8), 40)\n\n    if __name__ == \'__main__\':\n        unittest.main()\n\nFurther information is available in the bundled documentation, and from\n\n  http://docs.python.org/lib/module-unittest.html\n\nCopyright (c) 1999-2003 Steve Purcell\nThis module is free software, and you may redistribute it and/or modify\nit under the same terms as Python itself, so long as this copyright message\nand disclaimer are retained in their original form.\n\nIN NO EVENT SHALL THE AUTHOR BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,\nSPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OF\nTHIS CODE, EVEN IF THE AUTHOR HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\nDAMAGE.\n\nTHE AUTHOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\nPARTICULAR PURPOSE.  THE CODE PROVIDED HEREUNDER IS ON AN "AS IS" BASIS,\nAND THERE IS NO OBLIGATION WHATSOEVER TO PROVIDE MAINTENANCE,\nSUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n\'\'\'\n\n__author__ = "Steve Purcell"\n__email__ = "stephen_purcell at yahoo dot com"\n__version__ = "#Revision: 1.63 $"[11:-2]\n\nimport time\nimport sys\nimport traceback\nimport os\nimport types\n\n##############################################################################\n# Exported classes and functions\n##############################################################################\n__all__ = [\'TestResult\', \'TestCase\', \'TestSuite\', \'TextTestRunner\',\n           \'TestLoader\', \'FunctionTestCase\', \'main\', \'defaultTestLoader\']\n\n# Expose obsolete functions for backwards compatibility\n__all__.extend([\'getTestCaseNames\', \'makeSuite\', \'findTestCases\'])\n\n\n##############################################################################\n# Backward compatibility\n##############################################################################\nif sys.version_info[:2] < (2, 2):\n    def isinstance(obj, clsinfo):\n        import __builtin__\n        if type(clsinfo) in (tuple, list):\n            for cls in clsinfo:\n                if cls is type: cls = types.ClassType\n                if __builtin__.isinstance(obj, cls):\n                    return 1\n            return 0\n        else: return __builtin__.isinstance(obj, clsinfo)\n\ndef _CmpToKey(mycmp):\n    \'Convert a cmp= function into a key= function\'\n    class K(object):\n        def __init__(self, obj):\n            self.obj = obj\n        def __lt__(self, other):\n            return mycmp(self.obj, other.obj) == -1\n    return K\n\n##############################################################################\n# Test framework core\n##############################################################################\n\n# All classes defined herein are \'new-style\' classes, allowing use of \'super()\'\n__metaclass__ = type\n\ndef _strclass(cls):\n    return "%s.%s" % (cls.__module__, cls.__name__)\n\n__unittest = 1\n\nclass TestResult:\n    """Holder for test result information.\n\n    Test results are automatically managed by the TestCase and TestSuite\n    classes, and do not need to be explicitly manipulated by writers of tests.\n\n    Each instance holds the total number of tests run, and collections of\n    failures and errors that occurred among those test runs. The collections\n    contain tuples of (testcase, exceptioninfo), where exceptioninfo is the\n    formatted traceback of the error that occurred.\n    """\n    def __init__(self):\n        self.failures = []\n        self.errors = []\n        self.testsRun = 0\n        self.shouldStop = False\n\n    def startTest(self, test):\n        "Called when the given test is about to be run"\n        self.testsRun = self.testsRun + 1\n\n    def stopTest(self, test):\n        "Called when the given test has been run"\n        pass\n\n    def addError(self, test, err):\n        """Called when an error has occurred. \'err\' is a tuple of values as\n        returned by sys.exc_info().\n        """\n        self.errors.append((test, self._exc_info_to_string(err, test)))\n\n    def addFailure(self, test, err):\n        """Called when an error has occurred. \'err\' is a tuple of values as\n        returned by sys.exc_info()."""\n        self.failures.append((test, self._exc_info_to_string(err, test)))\n\n    def addSuccess(self, test):\n        "Called when a test has completed successfully"\n        pass\n\n    def wasSuccessful(self):\n        "Tells whether or not this result was a success"\n        return len(self.failures) == len(self.errors) == 0\n\n    def stop(self):\n        "Indicates that the tests should be aborted"\n        self.shouldStop = True\n\n    def _exc_info_to_string(self, err, test):\n        """Converts a sys.exc_info()-style tuple of values into a string."""\n        exctype, value, tb = err\n        # Skip test runner traceback levels\n        while tb and self._is_relevant_tb_level(tb):\n            tb = tb.tb_next\n        if exctype is test.failureException:\n            # Skip assert*() traceback levels\n            length = self._count_relevant_tb_levels(tb)\n            return \'\'.join(traceback.format_exception(exctype, value, tb, length))\n        return \'\'.join(traceback.format_exception(exctype, value, tb))\n\n    def _is_relevant_tb_level(self, tb):\n        return \'__unittest\' in tb.tb_frame.f_globals\n\n    def _count_relevant_tb_levels(self, tb):\n        length = 0\n        while tb and not self._is_relevant_tb_level(tb):\n            length += 1\n            tb = tb.tb_next\n        return length\n\n    def __repr__(self):\n        return "<%s run=%i errors=%i failures=%i>" % \\\n               (_strclass(self.__class__), self.testsRun, len(self.errors),\n                len(self.failures))\n\nclass TestCase:\n    """A class whose instances are single test cases.\n\n    By default, the test code itself should be placed in a method named\n    \'runTest\'.\n\n    If the fixture may be used for many test cases, create as\n    many test methods as are needed. When instantiating such a TestCase\n    subclass, specify in the constructor arguments the name of the test method\n    that the instance is to execute.\n\n    Test authors should subclass TestCase for their own tests. Construction\n    and deconstruction of the test\'s environment (\'fixture\') can be\n    implemented by overriding the \'setUp\' and \'tearDown\' methods respectively.\n\n    If it is necessary to override the __init__ method, the base class\n    __init__ method must always be called. It is important that subclasses\n    should not change the signature of their __init__ method, since instances\n    of the classes are instantiated automatically by parts of the framework\n    in order to be run.\n    """\n\n    # This attribute determines which exception will be raised when\n    # the instance\'s assertion methods fail; test methods raising this\n    # exception will be deemed to have \'failed\' rather than \'errored\'\n\n    failureException = AssertionError\n\n    def __init__(self, methodName=\'runTest\'):\n        """Create an instance of the class that will use the named test\n           method when executed. Raises a ValueError if the instance does\n           not have a method with the specified name.\n        """\n        try:\n            self._testMethodName = methodName\n            testMethod = getattr(self, methodName)\n            self._testMethodDoc = testMethod.__doc__\n        except AttributeError:\n            raise ValueError, "no such test method in %s: %s" % \\\n                  (self.__class__, methodName)\n\n    def setUp(self):\n        "Hook method for setting up the test fixture before exercising it."\n        pass\n\n    def tearDown(self):\n        "Hook method for deconstructing the test fixture after testing it."\n        pass\n\n    def countTestCases(self):\n        return 1\n\n    def defaultTestResult(self):\n        return TestResult()\n\n    def shortDescription(self):\n        """Returns a one-line description of the test, or None if no\n        description has been provided.\n\n        The default implementation of this method returns the first line of\n        the specified test method\'s docstring.\n        """\n        doc = self._testMethodDoc\n        return doc and doc.split("\\n")[0].strip() or None\n\n    def id(self):\n        return "%s.%s" % (_strclass(self.__class__), self._testMethodName)\n\n    def __eq__(self, other):\n        if type(self) is not type(other):\n            return False\n\n        return self._testMethodName == other._testMethodName\n\n    def __ne__(self, other):\n        return not self == other\n\n    def __hash__(self):\n        return hash((type(self), self._testMethodName))\n\n    def __str__(self):\n        return "%s (%s)" % (self._testMethodName, _strclass(self.__class__))\n\n    def __repr__(self):\n        return "<%s testMethod=%s>" % \\\n               (_strclass(self.__class__), self._testMethodName)\n\n    def run(self, result=None):\n        if result is None: result = self.defaultTestResult()\n        result.startTest(self)\n        testMethod = getattr(self, self._testMethodName)\n        try:\n            try:\n                self.setUp()\n            except KeyboardInterrupt:\n                raise\n            except:\n                result.addError(self, self._exc_info())\n                return\n\n            ok = False\n            try:\n                testMethod()\n                ok = True\n            except self.failureException:\n                result.addFailure(self, self._exc_info())\n            except KeyboardInterrupt:\n                raise\n            except:\n                result.addError(self, self._exc_info())\n\n            try:\n                self.tearDown()\n            except KeyboardInterrupt:\n                raise\n            except:\n                result.addError(self, self._exc_info())\n                ok = False\n            if ok: result.addSuccess(self)\n        finally:\n            result.stopTest(self)\n\n    def __call__(self, *args, **kwds):\n        return self.run(*args, **kwds)\n\n    def debug(self):\n        """Run the test without collecting errors in a TestResult"""\n        self.setUp()\n        getattr(self, self._testMethodName)()\n        self.tearDown()\n\n    def _exc_info(self):\n        """Return a version of sys.exc_info() with the traceback frame\n           minimised; usually the top level of the traceback frame is not\n           needed.\n        """\n        return sys.exc_info()\n\n    def fail(self, msg=None):\n        """Fail immediately, with the given message."""\n        raise self.failureException, msg\n\n    def failIf(self, expr, msg=None):\n        "Fail the test if the expression is true."\n        if expr: raise self.failureException, msg\n\n    def failUnless(self, expr, msg=None):\n        """Fail the test unless the expression is true."""\n        if not expr: raise self.failureException, msg\n\n    def failUnlessRaises(self, excClass, callableObj, *args, **kwargs):\n        """Fail unless an exception of class excClass is thrown\n           by callableObj when invoked with arguments args and keyword\n           arguments kwargs. If a different type of exception is\n           thrown, it will not be caught, and the test case will be\n           deemed to have suffered an error, exactly as for an\n           unexpected exception.\n        """\n        try:\n            callableObj(*args, **kwargs)\n        except excClass:\n            return\n        else:\n            if hasattr(excClass,\'__name__\'): excName = excClass.__name__\n            else: excName = str(excClass)\n            raise self.failureException, "%s not raised" % excName\n\n    def failUnlessEqual(self, first, second, msg=None):\n        """Fail if the two objects are unequal as determined by the \'==\'\n           operator.\n        """\n        if not first == second:\n            raise self.failureException, \\\n                  (msg or \'%r != %r\' % (first, second))\n\n    def failIfEqual(self, first, second, msg=None):\n        """Fail if the two objects are equal as determined by the \'==\'\n           operator.\n        """\n        if first == second:\n            raise self.failureException, \\\n                  (msg or \'%r == %r\' % (first, second))\n\n    def failUnlessAlmostEqual(self, first, second, places=7, msg=None):\n        """Fail if the two objects are unequal as determined by their\n           difference rounded to the given number of decimal places\n           (default 7) and comparing to zero.\n\n           Note that decimal places (from zero) are usually not the same\n           as significant digits (measured from the most signficant digit).\n        """\n        if round(abs(second-first), places) != 0:\n            raise self.failureException, \\\n                  (msg or \'%r != %r within %r places\' % (first, second, places))\n\n    def failIfAlmostEqual(self, first, second, places=7, msg=None):\n        """Fail if the two objects are equal as determined by their\n           difference rounded to the given number of decimal places\n           (default 7) and comparing to zero.\n\n           Note that decimal places (from zero) are usually not the same\n           as significant digits (measured from the most signficant digit).\n        """\n        if round(abs(second-first), places) == 0:\n            raise self.failureException, \\\n                  (msg or \'%r == %r within %r places\' % (first, second, places))\n\n    # Synonyms for assertion methods\n\n    assertEqual = assertEquals = failUnlessEqual\n\n    assertNotEqual = assertNotEquals = failIfEqual\n\n    assertAlmostEqual = assertAlmostEquals = failUnlessAlmostEqual\n\n    assertNotAlmostEqual = assertNotAlmostEquals = failIfAlmostEqual\n\n    assertRaises = failUnlessRaises\n\n    assert_ = assertTrue = failUnless\n\n    assertFalse = failIf\n\n\n\nclass TestSuite:\n    """A test suite is a composite test consisting of a number of TestCases.\n\n    For use, create an instance of TestSuite, then add test case instances.\n    When all tests have been added, the suite can be passed to a test\n    runner, such as TextTestRunner. It will run the individual test cases\n    in the order in which they were added, aggregating the results. When\n    subclassing, do not forget to call the base class constructor.\n    """\n    def __init__(self, tests=()):\n        self._tests = []\n        self.addTests(tests)\n\n    def __repr__(self):\n        return "<%s tests=%s>" % (_strclass(self.__class__), self._tests)\n\n    __str__ = __repr__\n\n    def __eq__(self, other):\n        if type(self) is not type(other):\n            return False\n        return self._tests == other._tests\n\n    def __ne__(self, other):\n        return not self == other\n\n    # Can\'t guarantee hash invariant, so flag as unhashable\n    __hash__ = None\n\n    def __iter__(self):\n        return iter(self._tests)\n\n    def countTestCases(self):\n        cases = 0\n        for test in self._tests:\n            cases += test.countTestCases()\n        return cases\n\n    def addTest(self, test):\n        # sanity checks\n        if not hasattr(test, \'__call__\'):\n            raise TypeError("the test to add must be callable")\n        if (isinstance(test, (type, types.ClassType)) and\n            issubclass(test, (TestCase, TestSuite))):\n            raise TypeError("TestCases and TestSuites must be instantiated "\n                            "before passing them to addTest()")\n        self._tests.append(test)\n\n    def addTests(self, tests):\n        if isinstance(tests, basestring):\n            raise TypeError("tests must be an iterable of tests, not a string")\n        for test in tests:\n            self.addTest(test)\n\n    def run(self, result):\n        for test in self._tests:\n            if result.shouldStop:\n                break\n            test(result)\n        return result\n\n    def __call__(self, *args, **kwds):\n        return self.run(*args, **kwds)\n\n    def debug(self):\n        """Run the tests without collecting errors in a TestResult"""\n        for test in self._tests: test.debug()\n\n\nclass FunctionTestCase(TestCase):\n    """A test case that wraps a test function.\n\n    This is useful for slipping pre-existing test functions into the\n    unittest framework. Optionally, set-up and tidy-up functions can be\n    supplied. As with TestCase, the tidy-up (\'tearDown\') function will\n    always be called if the set-up (\'setUp\') function ran successfully.\n    """\n\n    def __init__(self, testFunc, setUp=None, tearDown=None,\n                 description=None):\n        TestCase.__init__(self)\n        self.__setUpFunc = setUp\n        self.__tearDownFunc = tearDown\n        self.__testFunc = testFunc\n        self.__description = description\n\n    def setUp(self):\n        if self.__setUpFunc is not None:\n            self.__setUpFunc()\n\n    def tearDown(self):\n        if self.__tearDownFunc is not None:\n            self.__tearDownFunc()\n\n    def runTest(self):\n        self.__testFunc()\n\n    def id(self):\n        return self.__testFunc.__name__\n\n    def __eq__(self, other):\n        if type(self) is not type(other):\n            return False\n\n        return self.__setUpFunc == other.__setUpFunc and \\\n               self.__tearDownFunc == other.__tearDownFunc and \\\n               self.__testFunc == other.__testFunc and \\\n               self.__description == other.__description\n\n    def __ne__(self, other):\n        return not self == other\n\n    def __hash__(self):\n        return hash((type(self), self.__setUpFunc, self.__tearDownFunc,\n                                           self.__testFunc, self.__description))\n\n    def __str__(self):\n        return "%s (%s)" % (_strclass(self.__class__), self.__testFunc.__name__)\n\n    def __repr__(self):\n        return "<%s testFunc=%s>" % (_strclass(self.__class__), self.__testFunc)\n\n    def shortDescription(self):\n        if self.__description is not None: return self.__description\n        doc = self.__testFunc.__doc__\n        return doc and doc.split("\\n")[0].strip() or None\n\n\n\n##############################################################################\n# Locating and loading tests\n##############################################################################\n\nclass TestLoader:\n    """This class is responsible for loading tests according to various\n    criteria and returning them wrapped in a TestSuite\n    """\n    testMethodPrefix = \'test\'\n    sortTestMethodsUsing = cmp\n    suiteClass = TestSuite\n\n    def loadTestsFromTestCase(self, testCaseClass):\n        """Return a suite of all tests cases contained in testCaseClass"""\n        if issubclass(testCaseClass, TestSuite):\n            raise TypeError("Test cases should not be derived from TestSuite. Maybe you meant to derive from TestCase?")\n        testCaseNames = self.getTestCaseNames(testCaseClass)\n        if not testCaseNames and hasattr(testCaseClass, \'runTest\'):\n            testCaseNames = [\'runTest\']\n        return self.suiteClass(map(testCaseClass, testCaseNames))\n\n    def loadTestsFromModule(self, module):\n        """Return a suite of all tests cases contained in the given module"""\n        tests = []\n        for name in dir(module):\n            obj = getattr(module, name)\n            if (isinstance(obj, (type, types.ClassType)) and\n                issubclass(obj, TestCase)):\n                tests.append(self.loadTestsFromTestCase(obj))\n        return self.suiteClass(tests)\n\n    def loadTestsFromName(self, name, module=None):\n        """Return a suite of all tests cases given a string specifier.\n\n        The name may resolve either to a module, a test case class, a\n        test method within a test case class, or a callable object which\n        returns a TestCase or TestSuite instance.\n\n        The method optionally resolves the names relative to a given module.\n        """\n        parts = name.split(\'.\')\n        if module is None:\n            parts_copy = parts[:]\n            while parts_copy:\n                try:\n                    module = __import__(\'.\'.join(parts_copy))\n                    break\n                except ImportError:\n                    del parts_copy[-1]\n                    if not parts_copy: raise\n            parts = parts[1:]\n        obj = module\n        for part in parts:\n            parent, obj = obj, getattr(obj, part)\n\n        if type(obj) == types.ModuleType:\n            return self.loadTestsFromModule(obj)\n        elif (isinstance(obj, (type, types.ClassType)) and\n              issubclass(obj, TestCase)):\n            return self.loadTestsFromTestCase(obj)\n        elif (type(obj) == types.UnboundMethodType and\n              isinstance(parent, (type, types.ClassType)) and\n              issubclass(parent, TestCase)):\n            return TestSuite([parent(obj.__name__)])\n        elif isinstance(obj, TestSuite):\n            return obj\n        elif hasattr(obj, \'__call__\'):\n            test = obj()\n            if isinstance(test, TestSuite):\n                return test\n            elif isinstance(test, TestCase):\n                return TestSuite([test])\n            else:\n                raise TypeError("calling %s returned %s, not a test" %\n                                (obj, test))\n        else:\n            raise TypeError("don\'t know how to make test from: %s" % obj)\n\n    def loadTestsFromNames(self, names, module=None):\n        """Return a suite of all tests cases found using the given sequence\n        of string specifiers. See \'loadTestsFromName()\'.\n        """\n        suites = [self.loadTestsFromName(name, module) for name in names]\n        return self.suiteClass(suites)\n\n    def getTestCaseNames(self, testCaseClass):\n        """Return a sorted sequence of method names found within testCaseClass\n        """\n        def isTestMethod(attrname, testCaseClass=testCaseClass, prefix=self.testMethodPrefix):\n            return attrname.startswith(prefix) and hasattr(getattr(testCaseClass, attrname), \'__call__\')\n        testFnNames = filter(isTestMethod, dir(testCaseClass))\n        if self.sortTestMethodsUsing:\n            testFnNames.sort(key=_CmpToKey(self.sortTestMethodsUsing))\n        return testFnNames\n\n\n\ndefaultTestLoader = TestLoader()\n\n\n##############################################################################\n# Patches for old functions: these functions should be considered obsolete\n##############################################################################\n\ndef _makeLoader(prefix, sortUsing, suiteClass=None):\n    loader = TestLoader()\n    loader.sortTestMethodsUsing = sortUsing\n    loader.testMethodPrefix = prefix\n    if suiteClass: loader.suiteClass = suiteClass\n    return loader\n\ndef getTestCaseNames(testCaseClass, prefix, sortUsing=cmp):\n    return _makeLoader(prefix, sortUsing).getTestCaseNames(testCaseClass)\n\ndef makeSuite(testCaseClass, prefix=\'test\', sortUsing=cmp, suiteClass=TestSuite):\n    return _makeLoader(prefix, sortUsing, suiteClass).loadTestsFromTestCase(testCaseClass)\n\ndef findTestCases(module, prefix=\'test\', sortUsing=cmp, suiteClass=TestSuite):\n    return _makeLoader(prefix, sortUsing, suiteClass).loadTestsFromModule(module)\n\n\n##############################################################################\n# Text UI\n##############################################################################\n\nclass _WritelnDecorator:\n    """Used to decorate file-like objects with a handy \'writeln\' method"""\n    def __init__(self,stream):\n        self.stream = stream\n\n    def __getattr__(self, attr):\n        return getattr(self.stream,attr)\n\n    def writeln(self, arg=None):\n        if arg: self.write(arg)\n        self.write(\'\\n\') # text-mode streams translate to \\r\\n if needed\n\n\nclass _TextTestResult(TestResult):\n    """A test result class that can print formatted text results to a stream.\n\n    Used by TextTestRunner.\n    """\n    separator1 = \'=\' * 70\n    separator2 = \'-\' * 70\n\n    def __init__(self, stream, descriptions, verbosity):\n        TestResult.__init__(self)\n        self.stream = stream\n        self.showAll = verbosity > 1\n        self.dots = verbosity == 1\n        self.descriptions = descriptions\n\n    def getDescription(self, test):\n        if self.descriptions:\n            return test.shortDescription() or str(test)\n        else:\n            return str(test)\n\n    def startTest(self, test):\n        TestResult.startTest(self, test)\n        if self.showAll:\n            self.stream.write(self.getDescription(test))\n            self.stream.write(" ... ")\n            self.stream.flush()\n\n    def addSuccess(self, test):\n        TestResult.addSuccess(self, test)\n        if self.showAll:\n            self.stream.writeln("ok")\n        elif self.dots:\n            self.stream.write(\'.\')\n            self.stream.flush()\n\n    def addError(self, test, err):\n        TestResult.addError(self, test, err)\n        if self.showAll:\n            self.stream.writeln("ERROR")\n        elif self.dots:\n            self.stream.write(\'E\')\n            self.stream.flush()\n\n    def addFailure(self, test, err):\n        TestResult.addFailure(self, test, err)\n        if self.showAll:\n            self.stream.writeln("FAIL")\n        elif self.dots:\n            self.stream.write(\'F\')\n            self.stream.flush()\n\n    def printErrors(self):\n        if self.dots or self.showAll:\n            self.stream.writeln()\n        self.printErrorList(\'ERROR\', self.errors)\n        self.printErrorList(\'FAIL\', self.failures)\n\n    def printErrorList(self, flavour, errors):\n        for test, err in errors:\n            self.stream.writeln(self.separator1)\n            self.stream.writeln("%s: %s" % (flavour,self.getDescription(test)))\n            self.stream.writeln(self.separator2)\n            self.stream.writeln("%s" % err)\n\n\nclass TextTestRunner:\n    """A test runner class that displays results in textual form.\n\n    It prints out the names of tests as they are run, errors as they\n    occur, and a summary of the results at the end of the test run.\n    """\n    def __init__(self, stream=sys.stderr, descriptions=1, verbosity=1):\n        self.stream = _WritelnDecorator(stream)\n        self.descriptions = descriptions\n        self.verbosity = verbosity\n\n    def _makeResult(self):\n        return _TextTestResult(self.stream, self.descriptions, self.verbosity)\n\n    def run(self, test):\n        "Run the given test case or test suite."\n        result = self._makeResult()\n        startTime = time.time()\n        test(result)\n        stopTime = time.time()\n        timeTaken = stopTime - startTime\n        result.printErrors()\n        self.stream.writeln(result.separator2)\n        run = result.testsRun\n        self.stream.writeln("Ran %d test%s in %.3fs" %\n                            (run, run != 1 and "s" or "", timeTaken))\n        self.stream.writeln()\n        if not result.wasSuccessful():\n            self.stream.write("FAILED (")\n            failed, errored = map(len, (result.failures, result.errors))\n            if failed:\n                self.stream.write("failures=%d" % failed)\n            if errored:\n                if failed: self.stream.write(", ")\n                self.stream.write("errors=%d" % errored)\n            self.stream.writeln(")")\n        else:\n            self.stream.writeln("OK")\n        return result\n\n\n\n##############################################################################\n# Facilities for running tests from the command line\n##############################################################################\n\nclass TestProgram:\n    """A command-line program that runs a set of tests; this is primarily\n       for making test modules conveniently executable.\n    """\n    USAGE = """\\\nUsage: %(progName)s [options] [test] [...]\n\nOptions:\n  -h, --help       Show this message\n  -v, --verbose    Verbose output\n  -q, --quiet      Minimal output\n\nExamples:\n  %(progName)s                               - run default set of tests\n  %(progName)s MyTestSuite                   - run suite \'MyTestSuite\'\n  %(progName)s MyTestCase.testSomething      - run MyTestCase.testSomething\n  %(progName)s MyTestCase                    - run all \'test*\' test methods\n                                               in MyTestCase\n"""\n    def __init__(self, module=\'__main__\', defaultTest=None,\n                 argv=None, testRunner=None,\n                 testLoader=defaultTestLoader):\n        if type(module) == type(\'\'):\n            self.module = __import__(module)\n            for part in module.split(\'.\')[1:]:\n                self.module = getattr(self.module, part)\n        else:\n            self.module = module\n        if argv is None:\n            argv = sys.argv\n        self.verbosity = 1\n        self.defaultTest = defaultTest\n        self.testRunner = testRunner\n        self.testLoader = testLoader\n        self.progName = os.path.basename(argv[0])\n        self.parseArgs(argv)\n        self.runTests()\n\n    def usageExit(self, msg=None):\n        if msg: print msg\n        print self.USAGE % self.__dict__\n        sys.exit(2)\n\n    def parseArgs(self, argv):\n        import getopt\n        try:\n            options, args = getopt.getopt(argv[1:], \'hHvq\',\n                                          [\'help\',\'verbose\',\'quiet\'])\n            for opt, value in options:\n                if opt in (\'-h\',\'-H\',\'--help\'):\n                    self.usageExit()\n                if opt in (\'-q\',\'--quiet\'):\n                    self.verbosity = 0\n                if opt in (\'-v\',\'--verbose\'):\n                    self.verbosity = 2\n            if len(args) == 0 and self.defaultTest is None:\n                self.test = self.testLoader.loadTestsFromModule(self.module)\n                return\n            if len(args) > 0:\n                self.testNames = args\n            else:\n                self.testNames = (self.defaultTest,)\n            self.createTests()\n        except getopt.error, msg:\n            self.usageExit(msg)\n\n    def createTests(self):\n        self.test = self.testLoader.loadTestsFromNames(self.testNames,\n                                                       self.module)\n\n    def runTests(self):\n        if self.testRunner is None:\n            self.testRunner = TextTestRunner\n\n        if isinstance(self.testRunner, (type, types.ClassType)):\n            try:\n                testRunner = self.testRunner(verbosity=self.verbosity)\n            except TypeError:\n                # didn\'t accept the verbosity argument\n                testRunner = self.testRunner()\n        else:\n            # it is assumed to be a TestRunner instance\n            testRunner = self.testRunner\n        result = testRunner.run(self.test)\n        sys.exit(not result.wasSuccessful())\n\nmain = TestProgram\n\n\n##############################################################################\n# Executing this module from the command line\n##############################################################################\n\nif __name__ == "__main__":\n    main(module=None)\n',
    'src/lib/pythonds/graphs/__init__.py': '\n\nfrom .adjGraph import Graph\nfrom .adjGraph import Vertex\nfrom .priorityQueue import PriorityQueue\n',
    'src/lib/pythonds/graphs/priorityQueue.py': '# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005\n# \nimport unittest\n\n# this implementation of binary heap takes key value pairs,\n# we will assume that the keys are all comparable\n\nclass PriorityQueue:\n    def __init__(self):\n        self.heapArray = [(0,0)]\n        self.currentSize = 0\n\n    def buildHeap(self,alist):\n        self.currentSize = len(alist)\n        self.heapArray = [(0,0)]\n        for i in alist:\n            self.heapArray.append(i)\n        i = len(alist) // 2            \n        while (i > 0):\n            self.percDown(i)\n            i = i - 1\n                        \n    def percDown(self,i):\n        while (i * 2) <= self.currentSize:\n            mc = self.minChild(i)\n            if self.heapArray[i][0] > self.heapArray[mc][0]:\n                tmp = self.heapArray[i]\n                self.heapArray[i] = self.heapArray[mc]\n                self.heapArray[mc] = tmp\n            i = mc\n                \n    def minChild(self,i):\n        if i*2 > self.currentSize:\n            return -1\n        else:\n            if i*2 + 1 > self.currentSize:\n                return i*2\n            else:\n                if self.heapArray[i*2][0] < self.heapArray[i*2+1][0]:\n                    return i*2\n                else:\n                    return i*2+1\n\n    def percUp(self,i):\n        while i // 2 > 0:\n            if self.heapArray[i][0] < self.heapArray[i//2][0]:\n               tmp = self.heapArray[i//2]\n               self.heapArray[i//2] = self.heapArray[i]\n               self.heapArray[i] = tmp\n            i = i//2\n \n    def add(self,k):\n        self.heapArray.append(k)\n        self.currentSize = self.currentSize + 1\n        self.percUp(self.currentSize)\n\n    def delMin(self):\n        retval = self.heapArray[1][1]\n        self.heapArray[1] = self.heapArray[self.currentSize]\n        self.currentSize = self.currentSize - 1\n        self.heapArray.pop()\n        self.percDown(1)\n        return retval\n        \n    def isEmpty(self):\n        if self.currentSize == 0:\n            return True\n        else:\n            return False\n\n    def decreaseKey(self,val,amt):\n        # this is a little wierd, but we need to find the heap thing to decrease by\n        # looking at its value\n        done = False\n        i = 1\n        myKey = 0\n        while not done and i <= self.currentSize:\n            if self.heapArray[i][1] == val:\n                done = True\n                myKey = i\n            else:\n                i = i + 1\n        if myKey > 0:\n            self.heapArray[myKey] = (amt,self.heapArray[myKey][1])\n            self.percUp(myKey)\n            \n    def __contains__(self,vtx):\n        for pair in self.heapArray:\n            if pair[1] == vtx:\n                return True\n        return False\n        \nclass TestBinHeap(unittest.TestCase):\n    def setUp(self):\n        self.theHeap = PriorityQueue()\n        self.theHeap.add((2,\'x\'))\n        self.theHeap.add((3,\'y\'))\n        self.theHeap.add((5,\'z\'))\n        self.theHeap.add((6,\'a\'))\n        self.theHeap.add((4,\'d\'))\n\n\n    def testInsert(self):\n        assert self.theHeap.currentSize == 5\n\n    def testDelmin(self):\n        assert self.theHeap.delMin() == \'x\'\n        assert self.theHeap.delMin() == \'y\'\n    \n    def testDecKey(self):\n        self.theHeap.decreaseKey(\'d\',1)\n        assert self.theHeap.delMin() == \'d\'\n        \nif __name__ == \'__main__\':\n    unittest.main()\n',
    'src/lib/pythonds/__init__.py': '',
    'src/lib/cmath/__init__.js': 'var $builtinmodule = function(name) {\n\n  function isNumber(x) {return typeof x === \'number\';}\n  function isUndefined(x) {return typeof x === \'undefined\';}\n\n  function phase(x, y) {\n    return Math.atan2(y, x);\n  }\n\n  function norm(x, y) {\n    return Math.sqrt(x * x + y * y);\n  }\n\n  function stringFromCoordinates(coordinates, labels, multiplier) {\n    var append, i, sb, str, _i, _ref;\n    sb = [];\n    append = function(number, label) {\n      var n;\n      if (number !== 0) {\n        if (number >= 0) {\n          if (sb.length > 0) {\n            sb.push("+");\n          }\n        } else {\n          sb.push("-");\n        }\n        n = Math.abs(number);\n        if (n === 1) {\n          return sb.push(label);\n        } else {\n          sb.push(n.toString());\n          if (label !== "1") {\n            sb.push(multiplier);\n            return sb.push(label);\n          }\n        }\n      }\n    };\n    for (i = _i = 0, _ref = coordinates.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {\n      append(coordinates[i], labels[i]);\n    }\n    if (sb.length > 0) {\n      str = sb.join("");\n    } else {\n      str = "0";\n    }\n    return str;\n  }\n\n  // This is what you would use in code. e.g. i = complex(0.0, 1.0)\n  var COMPLEX_CONSTRUCTOR_NAME = "complex";\n  var PROP_REAL = "real";\n  var PROP_IMAG = "imag";\n\n  var mod = {};\n\n  mod[COMPLEX_CONSTRUCTOR_NAME] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self, re, im) {\n      self.tp$name = COMPLEX_CONSTRUCTOR_NAME;\n      self.v = {"x": Sk.ffi.remapToJs(re), "y": Sk.ffi.remapToJs(im)};\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(z, name) {\n      z = Sk.ffi.remapToJs(z);\n      switch(name) {\n        case PROP_REAL: {\n          return Sk.builtin.assk$(z.x, Sk.builtin.nmber.float$);\n        }\n        case PROP_IMAG: {\n          return Sk.builtin.assk$(z.y, Sk.builtin.nmber.float$);\n        }\n      }\n    });\n    $loc.__add__ = new Sk.builtin.func(function(a, b) {\n      var x, y;\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(b)) {\n        x = a.x + b;\n        y = a.y;\n      }\n      else {\n        x = a.x + b.x;\n        y = a.y + b.y;\n      }\n      return Sk.misceval.callsim(\n        mod[COMPLEX_CONSTRUCTOR_NAME],\n        Sk.builtin.assk$(x, Sk.builtin.nmber.float$),\n        Sk.builtin.assk$(y, Sk.builtin.nmber.float$));\n    });\n    $loc.__radd__ = new Sk.builtin.func(function(b, a) {\n      var x, y;\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(a)) {\n        x = a + b.x;\n        y = b.y;\n        return Sk.misceval.callsim(\n          mod[COMPLEX_CONSTRUCTOR_NAME],\n          Sk.builtin.assk$(x, Sk.builtin.nmber.float$),\n          Sk.builtin.assk$(y, Sk.builtin.nmber.float$));\n      }\n      else {\n        throw new Sk.builtin.AssertionError();\n      }\n    });\n    $loc.__iadd__ = new Sk.builtin.func(function(aPy, b) {\n      var a = Sk.ffi.remapToJs(aPy);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(b)) {\n        a.x += b;\n      }\n      else {\n        a.x += b.x;\n        a.y += b.y;\n      }\n      return aPy;\n    });\n    $loc.__sub__ = new Sk.builtin.func(function(a, b) {\n      var x, y;\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(b)) {\n        x = a.x - b;\n        y = a.y;\n      }\n      else {\n        x = a.x - b.x;\n        y = a.y - b.y;\n      }\n      return Sk.misceval.callsim(\n        mod[COMPLEX_CONSTRUCTOR_NAME],\n        Sk.builtin.assk$(x, Sk.builtin.nmber.float$),\n        Sk.builtin.assk$(y, Sk.builtin.nmber.float$));\n    });\n    $loc.__rsub__ = new Sk.builtin.func(function(b, a) {\n      var x, y;\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(a)) {\n        x = a - b.x;\n        y = -b.y;\n        return Sk.misceval.callsim(\n          mod[COMPLEX_CONSTRUCTOR_NAME],\n          Sk.builtin.assk$(x, Sk.builtin.nmber.float$),\n          Sk.builtin.assk$(y, Sk.builtin.nmber.float$));\n      }\n      else {\n        throw new Sk.builtin.AssertionError();\n      }\n    });\n    $loc.__isub__ = new Sk.builtin.func(function(aPy, b) {\n      var a = Sk.ffi.remapToJs(aPy);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(b)) {\n        a.x -= b;\n      }\n      else {\n        a.x -= b.x;\n        a.y -= b.y;\n      }\n      return aPy;\n    });\n    $loc.__mul__ = new Sk.builtin.func(function(a, b) {\n      var x, y;\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(b)) {\n        x = a.x * b;\n        y = a.y * b;\n      }\n      else {\n        x = a.x * b.x - a.y * b.y;\n        y = a.y * b.x + a.x * b.y;\n      }\n      return Sk.misceval.callsim(\n        mod[COMPLEX_CONSTRUCTOR_NAME],\n        Sk.builtin.assk$(x, Sk.builtin.nmber.float$),\n        Sk.builtin.assk$(y, Sk.builtin.nmber.float$));\n    });\n    $loc.__rmul__ = new Sk.builtin.func(function(b, a) {\n      var x, y;\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(a)) {\n        x = a * b.x;\n        y = a * b.y;\n        return Sk.misceval.callsim(\n          mod[COMPLEX_CONSTRUCTOR_NAME],\n          Sk.builtin.assk$(x, Sk.builtin.nmber.float$),\n          Sk.builtin.assk$(y, Sk.builtin.nmber.float$));\n      }\n      else {\n        throw new Sk.builtin.AssertionError();\n      }\n    });\n    $loc.__imul__ = new Sk.builtin.func(function(aPy, b) {\n      var a = Sk.ffi.remapToJs(aPy);\n      var aX = a.x;\n      var aY = a.y;\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(b)) {\n        a.x *= b;\n        a.y *= b;\n      }\n      else {\n        a.x = aX * b.x - aY * b.y;\n        a.y = aY * b.x + aX * b.y;\n      }\n      return aPy;\n    });\n    $loc.__div__ = new Sk.builtin.func(function(a, b) {\n      var x, y;\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(b)) {\n        x = a.x / b;\n        y = a.y / b;\n      }\n      else {\n        var factor = b.x * b.x + b.y * b.y;\n        x = (a.x * b.x + a.y * b.y) / factor;\n        y = (a.y * b.x - a.x * b.y) / factor;\n      }\n      return Sk.misceval.callsim(\n        mod[COMPLEX_CONSTRUCTOR_NAME],\n        Sk.builtin.assk$(x, Sk.builtin.nmber.float$),\n        Sk.builtin.assk$(y, Sk.builtin.nmber.float$));\n    });\n    $loc.__rdiv__ = new Sk.builtin.func(function(b, a) {\n      var x, y;\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(a)) {\n        var factor = b.x * b.x + b.y * b.y;\n        x = (a * b.x) / factor;\n        y = (-a * b.y) / factor;\n        return Sk.misceval.callsim(\n          mod[COMPLEX_CONSTRUCTOR_NAME],\n          Sk.builtin.assk$(x, Sk.builtin.nmber.float$),\n          Sk.builtin.assk$(y, Sk.builtin.nmber.float$));\n      }\n      else {\n        throw new Sk.builtin.AssertionError();\n      }\n    });\n    $loc.__idiv__ = new Sk.builtin.func(function(aPy, b) {\n      var a = Sk.ffi.remapToJs(aPy);\n      var aX = a.x;\n      var aY = a.y;\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(b)) {\n        a.x /= b;\n        a.y /= b;\n      }\n      else {\n        var factor = b.x * b.x + b.y * b.y;\n        a.x = (aX * b.x + aY * b.y) / factor;\n        a.y = (aY * b.x - aX * b.y) / factor;\n      }\n      return aPy;\n    });\n    $loc.__str__ = new Sk.builtin.func(function(z) {\n      z = Sk.ffi.remapToJs(z);\n      if (!isUndefined(z)) {\n        return new Sk.builtin.str("(" + stringFromCoordinates([z.x, z.y], ["1", "j"], "") + ")");\n      }\n      else {\n        return new Sk.builtin.str("<type \'" + COMPLEX_CONSTRUCTOR_NAME + "\'>");\n      }\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(z) {\n      z = Sk.ffi.remapToJs(z);\n      if (!isUndefined(z)) {\n        return new Sk.builtin.str(COMPLEX_CONSTRUCTOR_NAME + \'(\' + z.x + \', \' + z.y + \')\');\n      }\n      else {\n        return new Sk.builtin.str("__repr__(z)");\n      }\n    });\n    $loc.__eq__ = new Sk.builtin.func(function(a, b) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      return (a.x === b.x) && (a.y === b.y);\n    });\n    $loc.__ne__ = new Sk.builtin.func(function(a, b) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      return (a.x !== b.x) || (a.y !== b.y);\n    });\n  }, COMPLEX_CONSTRUCTOR_NAME, []);\n\n  // Conversions to and from polar coordinates\n  mod.phase = new Sk.builtin.func(function(z) {\n    z = Sk.ffi.remapToJs(z);\n    if (isNumber(z.x) && isNumber(z.y)) {\n      // The argument is a complex number.\n      return Sk.builtin.assk$(phase(z.x, z.y), Sk.builtin.nmber.float$)\n    }\n    else if (isNumber(z)) {\n      // The argument should be considered as a real number with no imaginary part.\n      return Math.atan2(0, z);\n    }\n    else {\n      return z;\n    }\n  });\n\n  mod.polar = new Sk.builtin.func(function(z) {\n    z = Sk.ffi.remapToJs(z);\n    if (isNumber(z.x) && isNumber(z.y)) {\n      return new Sk.builtin.tuple([norm(z.x, z.y), phase(z.x, z.y)]);\n    }\n    else if (isNumber(z)) {\n      // The argument should be considered as a real number with no imaginary part.\n      return Math.atan2(0, z);\n    }\n    else {\n      // What do we do with illegal arguments?\n    }\n  });\n\n  // Constants\n  mod.pi = Sk.builtin.assk$(Math.PI, Sk.builtin.nmber.float$);\n  mod.e =  Sk.builtin.assk$(Math.E, Sk.builtin.nmber.float$);\n\n  return mod;\n};\n',
    'src/lib/pythonds/basic/deque.py': '# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005\n# \n#deque.py\r\n\r\n\r\nclass Deque:\r\n    def __init__(self):\r\n        self.items = []\r\n\r\n    def isEmpty(self):\r\n        return self.items == []\r\n\r\n    def addFront(self, item):\r\n        self.items.append(item)\r\n\r\n    def addRear(self, item):\r\n        self.items.insert(0,item)\r\n\r\n    def removeFront(self):\r\n        return self.items.pop()\r\n\r\n    def removeRear(self):\r\n        return self.items.pop(0)\r\n\r\n    def size(self):\r\n        return len(self.items)\r\n',
    'src/lib/processing/__init__.js': 'var $builtinmodule = function(name)\n{\n    var mod = {};\n    var imList = [];\n    var looping = true;\n\n    // We need this to store a reference to the actual processing object which is not created\n    // until the run function is called.  Even then the processing object is passed by the\n    // processing-js sytem as a parameter to the sketchProc function.  Why not set it to None here\n    //\n\n    // See:  http://processingjs.org/reference/\n\n    mod.processing = null\n    mod.p = null\n\n    mod.CENTER = Sk.builtin.assk$(3, Sk.builtin.nmber.int$);\n    mod.RADIUS = Sk.builtin.assk$(2, Sk.builtin.nmber.int$);\n    mod.CORNERS = Sk.builtin.assk$(1, Sk.builtin.nmber.int$);\n    mod.CORNER = Sk.builtin.assk$(0, Sk.builtin.nmber.int$);\n    mod.RGB = Sk.builtin.assk$(1, Sk.builtin.nmber.int$);\n    mod.HSB = Sk.builtin.assk$(3, Sk.builtin.nmber.int$);\n    mod.CMYK = Sk.builtin.assk$(5, Sk.builtin.nmber.int$);\n    mod.MITER = new Sk.builtin.str(\'miter\');\n    mod.BEVEL = new Sk.builtin.str(\'bevel\');\n    mod.ROUND = new Sk.builtin.str(\'round\');\n    mod.SQUARE = new Sk.builtin.str(\'butt\');\n    mod.PROJECT = new Sk.builtin.str(\'square\');\n\n// 2D - Primitives\n    mod.line = new Sk.builtin.func(function(x1, y1, x2, y2) {\n        mod.processing.line(x1.v, y1.v, x2.v, y2.v);\n    });\n    \n    mod.ellipse = new Sk.builtin.func(function(x,y,r1,r2) {\n        mod.processing.ellipse(x.v,y.v,r1.v,r2.v)\n        \n    });\n\n    mod.point = new Sk.builtin.func(function(x1,y1) {\n        mod.processing.point(x1.v,y1.v)\n    });\n        \n    mod.arc = new Sk.builtin.func(function(x, y, width, height, start, stop) {\n        mod.processing.arc(x.v, y.v, width.v, height.v, start.v, stop.v)\n    });\n\n    mod.quad = new Sk.builtin.func(function(x1, y1, x2, y2, x3, y3, x4, y4) {\n        mod.processing.quad(x1.v, y1.v, x2.v, y2.v, x3.v, y3.v, x4.v, y4.v)\n    });\n            \n    mod.rect = new Sk.builtin.func(function(x, y, width, height, radius) {\n        if (typeof(radius) == \'undefined\') {\n            var rad = 0\n        } else {\n            var rad = radius.v\n        }\n        mod.processing.rect(x.v, y.v, width.v, height.v, rad)\n    });\n    \n    mod.triangle = new Sk.builtin.func(function(x1, y1, x2, y2, x3, y3) {\n            mod.processing.triangle(x1.v, y1.v, x2.v, y2.v, x3.v, y3.v)\n        });\n            \n\n    // 3D Primitives\n\n    // todo:  box, sphere, sphereDetail\n\n    // Color\n    mod.background = new Sk.builtin.func(function(r,g,b) {\n\n        if (typeof(g) !== \'undefined\')\n            g = g.v\n        if (typeof(b) !== \'undefined\')\n            b = b.v\n\n        mod.processing.background(r.v,g,b)\n        \n    });\n\n    mod.fill = new Sk.builtin.func(function(r,g,b) {\n        // r will be either:\n        //      a number in which case the fill will be grayscale\n        //      a color object\n        // g, and b may be undefined.  If they hold values it will\n        // be assumed that we have an r,g,b color tuple\n        if (typeof(g) !== \'undefined\')\n            g = g.v\n        if (typeof(b) !== \'undefined\')\n            b = b.v\n    \n        mod.processing.fill(r.v,g,b)\n        \n    });\n\n\n    mod.stroke = new Sk.builtin.func(function(r,g,b) {\n\n        if (typeof(g) !== \'undefined\')\n            g = g.v\n        if (typeof(b) !== \'undefined\')\n            b = b.v\n\n        mod.processing.stroke(r.v,g,b)\n        \n    });\n\n    mod.noStroke = new Sk.builtin.func(function() {\n        mod.processing.noStroke()\n    });\n    \n\n    mod.colorMode = new Sk.builtin.func(function(model, maxV) {\n        if (typeof(maxV) === \'undefined\')\n            maxV = 255\n        else\n            maxV = maxV.v\n        mod.processing.colorMode(model.v, maxV)\n    });\n\n    mod.noFill = new Sk.builtin.func(function() {\n            mod.processing.noFill()\n        });\n            \n\n    // Environment\n\n    mod.loop = new Sk.builtin.func(function() {\n            if (mod.processing === null) {\n                throw new Sk.builtin.Exception("Loop should be called in setup")\n            }\n            looping = true;\n            mod.processing.loop()\n        });\n            \n    mod.noLoop = new Sk.builtin.func(function() {\n        if (mod.processing === null) {\n            throw new Sk.builtin.Exception("noLoop should be called in setup")\n        }\n        looping = false;\n        mod.processing.noLoop()\n    });\n    \n    mod.frameRate = new Sk.builtin.func(function(fr) {\n        mod.processing.frameRate(fr.v)\n        \n    });\n\n    mod.size = new Sk.builtin.func(function(h,w) {\n        mod.processing.size(h.v,w.v)\n        \n    });\n\n    mod.exitp = new Sk.builtin.func(function(h,w) {\n        mod.processing.exit()\n    });\n\n\n    mod.mouseX = new Sk.builtin.func(function() {\n        return Sk.builtin.assk$(mod.processing.mouseX, Sk.builtin.nmber.int$);\n        \n    });\n\n    mod.mouseY = new Sk.builtin.func(function() {\n        return Sk.builtin.assk$(mod.processing.mouseY, Sk.builtin.nmber.int$);\n        \n    });\n\n    // Attributes\n    mod.rectMode = new Sk.builtin.func(function(mode) {\n        mod.processing.rectMode(mode.v)\n    });\n\n    mod.strokeWeight = new Sk.builtin.func(function(wt) {\n        mod.processing.strokeWeight(wt.v)\n        \n    });\n\n    mod.smooth = new Sk.builtin.func(function() {\n        mod.processing.smooth()\n    });\n\n    mod.noSmooth = new Sk.builtin.func(function() {\n        mod.processing.noSmooth()\n        });\n            \n    mod.ellipseMode = new Sk.builtin.func(function(mode) {\n        mod.processing.ellipseMode(mode.v)\n        });\n\n    mod.strokeCap = new Sk.builtin.func(function(mode) {\n        mod.processing.strokeCap(mode.v)\n        });\n\n    mod.strokeJoin = new Sk.builtin.func(function(mode) {\n        mod.processing.strokeJoin(mode.v)\n    });\n    \n\n\n    // Transforms\n\n    mod.rotate = new Sk.builtin.func(function(rads) {\n        // rotation in radians\n        mod.processing.rotate(rads.v)\n        \n    });\n\n    mod.scale = new Sk.builtin.func(function(sx, sy, sz) {\n        if (typeof(sy) == \'undefined\') {\n            sy = 1.0\n        } else \n            sy = sy.v\n        if (typeof(sz) == \'undefined\') {\n            sz = 1.0\n        } else\n            sz = sz.v\n        mod.processing.scale(sx.v, sy, sz)\n    });\n\n    mod.translate = new Sk.builtin.func(function(sx, sy, sz) {\n        if (typeof(sy) == \'undefined\') {\n            sy = 1.0\n        } else \n            sy = sy.v\n        if (typeof(sz) == \'undefined\') {\n            sz = 1.0\n        } else\n            sz = sz.v\n        mod.processing.translate(sx.v, sy, sz)\n    });\n\n    // todo:  applyMatrix, popMatrix, printMatrix??, pushMatrix, resetMatrix, rotate{X,Y,Z}\n    \n\n    //  //////////////////////////////////////////////////////////////////////\n    //  Run\n    // \n    //  Create the processing context and setup of calls to setup, draw etc.\n    //\n    //\n    //  //////////////////////////////////////////////////////////////////////    \n    mod.run = new Sk.builtin.func(function() {\n        function sketchProc(processing) {\n            mod.processing = processing\n\n            // processing.setup = function() {\n            //     if Sk.globals[\'setup\']\n            //         Sk.misceval.callsim(Sk.globals[\'setup\'])\n            // }\n\n            \n            processing.draw = function() {\n                // if there are pending image loads then just use the natural looping calls to \n                // retry until all the images are loaded.  If noLoop was called in setup then make\n                // sure to revert to that after all the images in hand.\n                var wait = false\n                for (var i in imList) {\n                    if (imList[i].width == 0) {\n                        wait = true\n                    }\n                }\n                if (wait == true) {\n                    if (looping == true) \n                        return\n                    else {\n                        processing.loop()\n                        return\n                    }\n\n                } else {\n                    if (looping == false)\n                        processing.noLoop()\n                }\n\n                mod.frameCount = processing.frameCount  \n                if (Sk.globals[\'draw\'])\n                    Sk.misceval.callsim(Sk.globals[\'draw\'])\n            }\n            \n            var callBacks = [\'setup\', \'mouseMoved\',\'mouseClicked\', \'mouseDragged\', \'mouseMoved\', \'mouseOut\',\n             \'mouseOver\', \'mousePressed\', \'mouseReleased\', \'keyPressed\', \'keyReleased\', \'keyTyped\'\n             ];\n\n             for(var cb in callBacks) {\n                if (Sk.globals[callBacks[cb]]) {\n                    console.log(\'defining \' + callBacks[cb])                    \n                    processing[callBacks[cb]] = new Function("Sk.misceval.callsim(Sk.globals[\'"+callBacks[cb]+"\']);")\n                }\n            }\n        }\n        \n        var canvas = document.getElementById(Sk.canvas)\n        $(canvas).show()\n        mod.p = new Processing(canvas, sketchProc)\n\n        \n    });\n\n    var mouseClass = function($gbl, $loc) {\n\n        $loc.__getattr__ = new Sk.builtin.func(function(self,key) {\n            if (key == \'x\') \n                return mod.processing.mouseX;\n            else if (key == \'y\') \n                return mod.processing.mouseY;\n            else if (key == \'px\')\n                return mod.processing.pmouseX;\n            else if (key == \'py\')\n                return mod.processing.pmouseY;\n            else if (key == \'pressed\')\n                return mod.processing.mousePressed;\n            else if (key == \'button\')\n                return mod.processing.mouseButton\n        });\n\n\n    }\n\n\n    mod.Mouse = Sk.misceval.buildClass(mod, mouseClass, \'Mouse\', []);\n\n    mod.mouse = Sk.misceval.callsim(mod.Mouse)\n\n    var keyboardClass = function($gbl, $loc) {\n\n        $loc.__getattr__ = new Sk.builtin.func(function(self,key) {\n            if (key == \'key\') {\n                console.log(mod.processing.key)\n                return new Sk.builtin.str(mod.processing.key.toString())\n            }\n            else if (key == \'keyCode\') \n                return mod.processing.keyCode\n            else if (key == \'keyPressed\')\n                return new Sk.builtin.str(mod.processing.keyPressed) // todo bool\n        });\n\n\n    }\n\n    mod.Keyboard = Sk.misceval.buildClass(mod,keyboardClass,\'Keyboard\', [])\n\n    mod.keyboard = Sk.misceval.callsim(mod.Keyboard)\n\n\n\n    var environmentClass = function($gbl, $loc) {\n\n        $loc.__getattr__ = new Sk.builtin.func(function(self,key) {\n            if (key == \'frameCount\') \n                return mod.processing.frameCount\n            else if (key == \'frameRate\') \n                return mod.processing.frameRate\n            else if (key == \'height\')\n                return mod.processing.height\n            else if (key == \'width\')\n                return mod.processing.width\n            else if (key == \'online\')\n                return mod.processing.online\n            else if (key == \'focused\')\n                return mod.processing.focused\n        });\n\n\n    }\n\n    mod.Environment = Sk.misceval.buildClass(mod,environmentClass,\'Environment\', [])\n\n    mod.environment = Sk.misceval.callsim(mod.Environment)\n\n    var screenClass = function($gbl, $loc) {\n\n        $loc.__init__ = new Sk.builtin.func(function(self) {\n            self.pixels = null;\n        });\n\n        $loc.__getattr__ = new Sk.builtin.func(function(self,key) {\n            if (key == \'height\')\n                return mod.processing.height\n            else if (key == \'width\')\n                return mod.processing.width\n            else if (key == \'pixels\')\n                if (self.pixels == null) {\n                    self.pixels = new Sk.builtin.list(mod.processing.pixels.toArray())\n                }\n                return self.pixels\n        });\n\n    }\n\n    mod.Screen = Sk.misceval.buildClass(mod,screenClass,\'Screen\', [])\n\n    mod.screen = Sk.misceval.callsim(mod.Screen)\n\n    mod.loadPixels = new Sk.builtin.func(function() {\n        mod.processing.loadPixels()\n        console.log(mod.processing.pixels)\n    });\n    \n\n    var colorClass = function($gbl, $loc) {\n        /* images are loaded async.. so its best to preload them */\n        $loc.__init__ = new Sk.builtin.func(function(self, val1, val2, val3, alpha) {\n            if (typeof(val2) !== \'undefined\')\n                val2 = val2.v\n            if (typeof(val3) !== \'undefined\')\n                val3 = val3.v\n            if (typeof(alpha) !== \'undefined\')\n                alpha = alpha.v\n            self.v = mod.processing.color(val1.v, val2, val3, alpha)\n        })\n    \n    }\n\n    mod.color = Sk.misceval.buildClass(mod,colorClass,\'color\', [])\n\n    mod.red = new Sk.builtin.func(function(clr) {\n        return Sk.builtin.assk$(mod.processing.red(clr.v), Sk.builtin.nmber.int$);\n    });\n    \n    mod.green = new Sk.builtin.func(function(clr) {\n        return Sk.builtin.assk$(mod.processing.green(clr.v), Sk.builtin.nmber.int$);\n    });\n\n    mod.blue = new Sk.builtin.func(function(clr) {\n        return Sk.builtin.assk$(mod.processing.blue(clr.v), Sk.builtin.nmber.int$);\n    });\n\n    // Image class and functions\n    //\n    var imageClass = function($gbl, $loc) {\n        /* images are loaded async.. so its best to preload them */\n        $loc.__init__ = new Sk.builtin.func(function(self,im) {\n            self.v = im\n            self.width = Sk.builtin.assk$(im.width, Sk.builtin.nmber.int$);\n            self.height = Sk.builtin.assk$(im.height, Sk.builtin.nmber.int$);\n        })\n\n        $loc.__getattr__ = new Sk.builtin.func(function(self,key) {\n            if (key == \'width\') return self.v.width;\n            if (key == \'height\') return self.v.height;\n        });\n    \n    }\n\n    mod.PImage = Sk.misceval.buildClass(mod,imageClass,\'PImage\', [])\n\n    mod.loadImage = new Sk.builtin.func(function(imfile) {\n        var i = mod.processing.loadImage(imfile.v);\n        imList.push(i);\n        return Sk.misceval.callsim(mod.PImage,i);\n    });\n    \n\n    mod.image = new Sk.builtin.func(function(im,x,y) {\n        if (im.v.width > 0)\n            mod.processing.image(im.v,x.v,y.v,im.v.width,im.v.height)\n    });\n\n    mod.get = new Sk.builtin.func(function(x,y) {\n        var clr = mod.processing.get(x.v,y.v)\n        return Sk.misceval.callsim(mod.color,\n            Sk.builtin.assk$(mod.processing.red(clr), Sk.builtin.nmber.int$),\n            Sk.builtin.assk$(mod.processing.green(clr), Sk.builtin.nmber.int$),\n            Sk.builtin.assk$(mod.processing.blue(clr), Sk.builtin.nmber.int$));\n    });\n\n    mod.set = new Sk.builtin.func(function(x, y, color) {\n        mod.processing.set(x.v, y.v, color.v)\n    });\n    \n// todo  -- add a color class for creating color objects.\n\n\n    return mod;\n}\n',
    'src/lib/webgl/models.js': '// most of this file is from/based on \'tdl\'\n\nvar $builtinmodule = function(name)\n{\n    var mod = {};\n\n    var Buffer = function(array, opt_target) {\n        var target = opt_target || gl.ARRAY_BUFFER;\n        var buf = gl.createBuffer();\n        this.target = target;\n        this.buf = buf;\n        this.set(array);\n        this.numComponents_ = array.numComponents;\n        this.numElements_ = array.numElements;\n        this.totalComponents_ = this.numComponents_ * this.numElements_;\n        if (array.buffer instanceof Float32Array) {\n            this.type_ = gl.FLOAT;\n        } else if (array.buffer instanceof Uint8Array) {\n            this.type_ = gl.UNSIGNED_BYTE;\n        } else if (array.buffer instanceof Int8Array) {\n            this.type_ = gl._BYTE;\n        } else if (array.buffer instanceof Uint16Array) {\n            this.type_ = gl.UNSIGNED_SHORT;\n        } else if (array.buffer instanceof Int16Array) {\n            this.type_ = gl.SHORT;\n        } else {\n            throw("unhandled type:" + (typeof array.buffer));\n        }\n    };\n\n    Buffer.prototype.set = function(array) {\n        gl.bindBuffer(this.target, this.buf);\n        gl.bufferData(this.target, array.buffer, gl.STATIC_DRAW);\n    }\n\n    Buffer.prototype.type = function() {\n        return this.type_;\n    };\n\n    Buffer.prototype.numComponents = function() {\n        return this.numComponents_;\n    };\n\n    Buffer.prototype.numElements = function() {\n        return this.numElements_;\n    };\n\n    Buffer.prototype.totalComponents = function() {\n        return this.totalComponents_;\n    };\n\n    Buffer.prototype.buffer = function() {\n        return this.buf;\n    };\n\n    Buffer.prototype.stride = function() {\n        return 0;\n    };\n\n    Buffer.prototype.offset = function() {\n        return 0;\n    };\n\n\n\n    mod.Model = Sk.misceval.buildClass(mod, function($gbl, $loc)\n            {\n                $loc.__init__ = new Sk.builtin.func(function(self, shader, arrays, textures)\n                    {\n                        self.buffers = {};\n                        var setBuffer = function(name, array)\n                        {\n                            var target = (name == \'indices\') ? gl.ELEMENT_ARRAY_BUFFER : gl.ARRAY_BUFFER;\n                            b = self.buffers[name];\n                            if (!b)\n                                b = new Buffer(array, target);\n                            else\n                                b.set(array);\n                            self.buffers[name] = b;\n                        };\n                        for (name in arrays)\n                            setBuffer(name, arrays[name]);\n\n                        var textureUnits = {};\n                        var unit = 0;\n                        for (var texture in textures)\n                        {\n                            textureUnits[texture] = unit++;\n                        }\n\n                        self.mode = gl.TRIANGLES;\n                        self.textures = textures.v;\n                        self.textureUnits = textureUnits;\n                        self.shader = shader;\n                    });\n\n                /**\n                * Sets up the shared parts of drawing this model. Uses the\n                * program, binds the buffers, sets the textures.\n                *\n                * @param {!Object.<string, *>} uniforms An object of names to\n                *     values to set on this models uniforms.\n                */\n                $loc.drawPrep = new Sk.builtin.func(function(self, uniforms)\n                    {\n                        var shader = self.shader;\n                        var buffers = self.buffers;\n                        var textures = self.textures;\n\n                        uniforms = Sk.ffi.remapToJs(uniforms);\n\n                        Sk.misceval.callsim(shader.use, shader);\n\n                        for (var buffer in buffers) {\n                            var b = buffers[buffer];\n                            if (buffer == \'indices\') {\n                                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, b.buffer());\n                            } else {\n                                var attrib = shader.attrib[buffer];\n                                if (attrib) {\n                                    attrib(b);\n                                }\n                            }\n                        }\n\n                        for (var texture in textures) {\n                            var unit = self.textureUnits[texture];\n                            shader.setUniform$impl(shader, textuer, unit);\n                            textures[texture].bindToUnit(unit);\n                        }\n\n                        for (var uniform in uniforms) {\n                            shader.setUniform$impl(shader, uniform, uniforms[uniform]);\n                        }\n                    });\n\n                /**\n                * Draws this model.\n                *\n                * After calling tdl.models.Model.drawPrep you can call this\n                * function multiple times to draw this model.\n                *\n                * @param {!Object.<string, *>} uniforms An object of names to\n                *     values to set on this models uniforms.\n                */\n                $loc.draw = new Sk.builtin.func(function(self, uniforms, opt_textures)\n                    {\n                        var shader = self.shader;\n                        uniforms = Sk.ffi.remapToJs(uniforms);\n                        for (uniform in uniforms) {\n                            shader.setUniform$impl(shader, uniform, uniforms[uniform]);\n                        }\n\n                        if (opt_textures) {\n                            for (var texture in opt_textures) {\n                                var unit = self.textureUnits[texture];\n                                shader.setUniform$impl(shader, texture, unit);\n                                opt_textures[texture].bindToUnit(unit);\n                            }\n                        }\n\n                        var buffers = self.buffers;\n                        gl.drawElements(self.mode, buffers.indices.totalComponents(), gl.UNSIGNED_SHORT, 0);\n                    });\n            },\n            \'Model\', []);\n\n    return mod;\n};\n',
    'src/lib/pythonds/trees/__init__.py': '\n# from .binaryTree import BinaryTree\n# from .balance import AVLTree\n# from .bst import BinarySearchTree\n# from .binheap import BinHeap\n\n\n',
    'src/lib/pythonds/trees/binaryTree.py': '# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005\n# \n\nclass BinaryTree:\n    """\n    A recursive implementation of Binary Tree\n    Using links and Nodes approach.\n    """    \n    def __init__(self,rootObj):\n        self.key = rootObj\n        self.leftChild = None\n        self.rightChild = None\n\n    def insertLeft(self,newNode):\n        if self.leftChild == None:\n            self.leftChild = BinaryTree(newNode)\n        else:\n            t = BinaryTree(newNode)\n            t.left = self.leftChild\n            self.leftChild = t\n    \n    def insertRight(self,newNode):\n        if self.rightChild == None:\n            self.rightChild = BinaryTree(newNode)\n        else:\n            t = BinaryTree(newNode)\n            t.right = self.rightChild\n            self.rightChild = t\n\n    def isLeaf(self):\n        return ((not self.leftChild) and (not self.rightChild))\n\n    def getRightChild(self):\n        return self.rightChild\n\n    def getLeftChild(self):\n        return self.leftChild\n\n    def setRootVal(self,obj):\n        self.key = obj\n\n    def getRootVal(self,):\n        return self.key\n\n    def inorder(self):\n        if self.leftChild:\n            self.leftChild.inorder()\n        print(self.key)\n        if self.rightChild:\n            self.rightChild.inorder()\n\n    def postorder(self):\n        if self.leftChild:\n            self.leftChild.postorder()\n        if self.rightChild:\n            self.rightChild.postorder()\n        print(self.key)\n\n\n    def preorder(self):\n        print(self.key)\n        if self.leftChild:\n            self.leftChild.preorder()\n        if self.rightChild:\n            self.rightChild.preorder()\n\n    def printexp(self):\n        if self.leftChild:\n            print(\'(\')\n            self.leftChild.printexp()\n        print(self.key)\n        if self.rightChild:\n            self.rightChild.printexp()\n            print(\')\')\n\n    def postordereval(self):\n        opers = {\'+\':operator.add, \'-\':operator.sub, \'*\':operator.mul, \'/\':operator.truediv}\n        res1 = None\n        res2 = None\n        if self.leftChild:\n            res1 = self.leftChild.postordereval()  #// \\label{peleft}\n        if self.rightChild:\n            res2 = self.rightChild.postordereval() #// \\label{peright}\n        if res1 and res2:\n            return opers[self.key](res1,res2) #// \\label{peeval}\n        else:\n            return self.key\n\ndef inorder(tree):\n    if tree != None:\n        inorder(tree.getLeftChild())\n        print(tree.getRootVal())\n        inorder(tree.getRightChild())\n\ndef printexp(tree):\n    if tree.leftChild:\n        print(\'(\')\n        printexp(tree.getLeftChild())\n    print(tree.getRootVal())\n    if tree.rightChild:\n        printexp(tree.getRightChild())\n        print(\')\') \n\ndef printexp(tree):\n    sVal = ""\n    if tree:\n        sVal = \'(\' + printexp(tree.getLeftChild())\n        sVal = sVal + str(tree.getRootVal())\n        sVal = sVal + printexp(tree.getRightChild()) + \')\'\n    return sVal\n\ndef postordereval(tree):\n    opers = {\'+\':operator.add, \'-\':operator.sub, \'*\':operator.mul, \'/\':operator.truediv}\n    res1 = None\n    res2 = None\n    if tree:\n        res1 = postordereval(tree.getLeftChild())  #// \\label{peleft}\n        res2 = postordereval(tree.getRightChild()) #// \\label{peright}\n        if res1 and res2:\n            return opers[tree.getRootVal()](res1,res2) #// \\label{peeval}\n        else:\n            return tree.getRootVal()\n\ndef height(tree):\n    if tree == None:\n        return -1\n    else:\n        return 1 + max(height(tree.leftChild),height(tree.rightChild))\n\n# t = BinaryTree(7)\n# t.insertLeft(3)\n# t.insertRight(9)\n# inorder(t)\n# import operator\n# x = BinaryTree(\'*\')\n# x.insertLeft(\'+\')\n# l = x.getLeftChild()\n# l.insertLeft(4)\n# l.insertRight(5)\n# x.insertRight(7)\n# print(printexp(x))\n# print(postordereval(x))\n# print(height(x))\n',
    'src/lib/math/__init__.js': 'var $builtinmodule = function(name)\n{\n    var mod = {};\n    mod.pi = Sk.builtin.assk$(Math.PI, Sk.builtin.nmber.float$);\n    mod.e =  Sk.builtin.assk$(Math.E, Sk.builtin.nmber.float$);\n\n//  RNL added\n    mod.fabs = new Sk.builtin.func(function(x) {\n        Sk.builtin.pyCheckArgs("fabs", arguments, 1, 1);\n        Sk.builtin.pyCheckType("x", "number", Sk.builtin.checkNumber(x));\n\n    return new Sk.builtin.nmber(Math.abs(Sk.builtin.asnum$(x)), Sk.builtin.nmber.float$);\n    });\n\n    mod.asin = new Sk.builtin.func(function(rad) {\n        Sk.builtin.pyCheckArgs("asin", arguments, 1, 1);\n        Sk.builtin.pyCheckType("rad", "number", Sk.builtin.checkNumber(rad));\n\n    return new Sk.builtin.nmber(Math.asin(Sk.builtin.asnum$(rad)), Sk.builtin.nmber.float$);\n    });\n\n    mod.acos = new Sk.builtin.func(function(rad) {\n        Sk.builtin.pyCheckArgs("acos", arguments, 1, 1);\n        Sk.builtin.pyCheckType("rad", "number", Sk.builtin.checkNumber(rad));\n\n    return new Sk.builtin.nmber(Math.acos(Sk.builtin.asnum$(rad)), Sk.builtin.nmber.float$);\n    });\n\n    mod.atan = new Sk.builtin.func(function(rad) {\n        Sk.builtin.pyCheckArgs("atan", arguments, 1, 1);\n        Sk.builtin.pyCheckType("rad", "number", Sk.builtin.checkNumber(rad));\n\n    return new Sk.builtin.nmber(Math.atan(Sk.builtin.asnum$(rad)), Sk.builtin.nmber.float$);\n    });\n\n    mod.atan2 = new Sk.builtin.func(function(y, x) {\n        Sk.builtin.pyCheckArgs("atan2", arguments, 2, 2);\n        Sk.builtin.pyCheckType("y", "number", Sk.builtin.checkNumber(y));\n        Sk.builtin.pyCheckType("x", "number", Sk.builtin.checkNumber(x));\n\n    return new Sk.builtin.nmber(Math.atan2(Sk.builtin.asnum$(y), Sk.builtin.asnum$(x)), Sk.builtin.nmber.float$);\n    });\n\n    mod.sin = new Sk.builtin.func(function(rad) {\n        Sk.builtin.pyCheckArgs("sin", arguments, 1, 1);\n        Sk.builtin.pyCheckType("rad", "number", Sk.builtin.checkNumber(rad));\n\n    return new Sk.builtin.nmber(Math.sin(Sk.builtin.asnum$(rad)), Sk.builtin.nmber.float$);\n    });\n\n    mod.cos = new Sk.builtin.func(function(rad) {\n        Sk.builtin.pyCheckArgs("cos", arguments, 1, 1);\n        Sk.builtin.pyCheckType("rad", "number", Sk.builtin.checkNumber(rad));\n\n    return new Sk.builtin.nmber(Math.cos(Sk.builtin.asnum$(rad)), Sk.builtin.nmber.float$);\n    });\n\n    mod.tan = new Sk.builtin.func(function(rad) {\n        Sk.builtin.pyCheckArgs("tan", arguments, 1, 1);\n        Sk.builtin.pyCheckType("rad", "number", Sk.builtin.checkNumber(rad));\n\n    return new Sk.builtin.nmber(Math.tan(Sk.builtin.asnum$(rad)), Sk.builtin.nmber.float$);\n    });\n\n    mod.asinh = new Sk.builtin.func(function(x) {\n    Sk.builtin.pyCheckArgs("asinh", arguments, 1, 1);\n    Sk.builtin.pyCheckType("x", "number", Sk.builtin.checkNumber(x));\n\n    x = Sk.builtin.asnum$(x);\n\n    var L = x + Math.sqrt(x*x+1);\n\n    return new Sk.builtin.nmber(Math.log(L), Sk.builtin.nmber.float$);\n    });\n\n    mod.acosh = new Sk.builtin.func(function(x) {\n    Sk.builtin.pyCheckArgs("acosh", arguments, 1, 1);\n    Sk.builtin.pyCheckType("x", "number", Sk.builtin.checkNumber(x));\n\n    x = Sk.builtin.asnum$(x);\n\n    var L = x + Math.sqrt(x*x-1);\n\n    return new Sk.builtin.nmber(Math.log(L), Sk.builtin.nmber.float$);\n    });\n\n    mod.atanh = new Sk.builtin.func(function(x) {\n    Sk.builtin.pyCheckArgs("atanh", arguments, 1, 1);\n    Sk.builtin.pyCheckType("x", "number", Sk.builtin.checkNumber(x));\n\n    x = Sk.builtin.asnum$(x);\n\n    var L = (1+x)/(1-x);\n\n    return new Sk.builtin.nmber(Math.log(L)/2, Sk.builtin.nmber.float$);\n    });\n\n    mod.sinh = new Sk.builtin.func(function(x) {\n    Sk.builtin.pyCheckArgs("sinh", arguments, 1, 1);\n    Sk.builtin.pyCheckType("x", "number", Sk.builtin.checkNumber(x));\n\n    x = Sk.builtin.asnum$(x);\n\n    var e = Math.E;\n    var p = Math.pow(e, x);\n    var n = 1/p;\n    var result = (p-n)/2;\n\n    return new Sk.builtin.nmber(result, Sk.builtin.nmber.float$);\n    });\n\n    mod.cosh = new Sk.builtin.func(function(x) {\n    Sk.builtin.pyCheckArgs("cosh", arguments, 1, 1);\n    Sk.builtin.pyCheckType("x", "number", Sk.builtin.checkNumber(x));\n\n    x = Sk.builtin.asnum$(x);\n\n    var e = Math.E;\n    var p = Math.pow(e, x);\n    var n = 1/p;\n    var result = (p+n)/2;\n\n    return new Sk.builtin.nmber(result, Sk.builtin.nmber.float$);\n    });\n\n    mod.tanh = new Sk.builtin.func(function(x) {\n    Sk.builtin.pyCheckArgs("tanh", arguments, 1, 1);\n    Sk.builtin.pyCheckType("x", "number", Sk.builtin.checkNumber(x));\n\n    x = Sk.builtin.asnum$(x);\n\n    var e = Math.E;\n    var p = Math.pow(e, x);\n    var n = 1/p;\n    var result = ((p-n)/2)/((p+n)/2);\n\n    return new Sk.builtin.nmber(result, Sk.builtin.nmber.float$);\n    });\n\n    mod.ceil = new Sk.builtin.func(function(x) {\n        Sk.builtin.pyCheckArgs("ceil", arguments, 1, 1);\n        Sk.builtin.pyCheckType("x", "number", Sk.builtin.checkNumber(x));\n\n    return new Sk.builtin.nmber(Math.ceil(Sk.builtin.asnum$(x)), Sk.builtin.nmber.float$);\n    });\n\n    mod.floor = new Sk.builtin.func(function(x) {\n        Sk.builtin.pyCheckArgs("floor", arguments, 1, 1);\n        Sk.builtin.pyCheckType("x", "number", Sk.builtin.checkNumber(x));\n\n    return new Sk.builtin.nmber(Math.floor(Sk.builtin.asnum$(x)), Sk.builtin.nmber.float$);\n    });\n\n    mod.sqrt = new Sk.builtin.func(function(x) {\n        Sk.builtin.pyCheckArgs("sqrt", arguments, 1, 1);\n        Sk.builtin.pyCheckType("x", "number", Sk.builtin.checkNumber(x));\n\n    return new Sk.builtin.nmber(Math.sqrt(Sk.builtin.asnum$(x)), Sk.builtin.nmber.float$);\n    });\n\n    mod.trunc = new Sk.builtin.func(function(x) {\n        Sk.builtin.pyCheckArgs("trunc", arguments, 1, 1);\n        Sk.builtin.pyCheckType("x", "number", Sk.builtin.checkNumber(x));\n\n        return new Sk.builtin.nmber(Sk.builtin.asnum$(x)|0, Sk.builtin.nmber.float$);\n    });\n\n    mod.log = new Sk.builtin.func(function(x, base) {\n        Sk.builtin.pyCheckArgs("log", arguments, 1, 2);\n        Sk.builtin.pyCheckType("x", "number", Sk.builtin.checkNumber(x));\n\n        if (base === undefined) {\n        return new Sk.builtin.nmber(Math.log(Sk.builtin.asnum$(x)), Sk.builtin.nmber.float$);\n        } else {\n            Sk.builtin.pyCheckType("base", "number", Sk.builtin.checkNumber(base));\n            var ret = Math.log(Sk.builtin.asnum$(x)) / Math.log(Sk.builtin.asnum$(base));\n        return new Sk.builtin.nmber(ret, Sk.builtin.nmber.float$);\n        }\n    });\n\n    mod.log10 = new Sk.builtin.func(function(x) {\n        Sk.builtin.pyCheckArgs("log10", arguments, 1, 1);\n        Sk.builtin.pyCheckType("x", "number", Sk.builtin.checkNumber(x));\n\n        var ret = Math.log(Sk.builtin.asnum$(x)) / Math.log(10);\n    return new Sk.builtin.nmber(ret, Sk.builtin.nmber.float$);\n    });\n\n    mod.exp = new Sk.builtin.func(function(x) {\n        Sk.builtin.pyCheckArgs("exp", arguments, 1, 1);\n        Sk.builtin.pyCheckType("x", "number", Sk.builtin.checkNumber(x));\n\n    return new Sk.builtin.nmber(Math.exp(Sk.builtin.asnum$(x)), Sk.builtin.nmber.float$);\n    });\n\n    mod.pow = new Sk.builtin.func(function(x,y) {\n        Sk.builtin.pyCheckArgs("pow", arguments, 2, 2);\n        Sk.builtin.pyCheckType("x", "number", Sk.builtin.checkNumber(x));\n        Sk.builtin.pyCheckType("y", "number", Sk.builtin.checkNumber(y));\n\n    return new Sk.builtin.nmber(Math.pow(Sk.builtin.asnum$(x), Sk.builtin.asnum$(y)), Sk.builtin.nmber.float$);\n    });\n\n    mod.radians = new Sk.builtin.func(function(deg) {\n        Sk.builtin.pyCheckArgs("radians", arguments, 1, 1);\n        Sk.builtin.pyCheckType("deg", "number", Sk.builtin.checkNumber(deg));\n\n    var ret = Math.PI / 180.0 * Sk.builtin.asnum$(deg);\n    return new Sk.builtin.nmber(ret, Sk.builtin.nmber.float$);\n    });\n\n    mod.degrees = new Sk.builtin.func(function(rad) {\n        Sk.builtin.pyCheckArgs("degrees", arguments, 1, 1);\n        Sk.builtin.pyCheckType("rad", "number", Sk.builtin.checkNumber(rad));\n\n    var ret = 180.0 / Math.PI * Sk.builtin.asnum$(rad);\n    return new Sk.builtin.nmber(ret, Sk.builtin.nmber.float$);\n    });\n\n    mod.hypot = new Sk.builtin.func(function(x, y) {\n    Sk.builtin.pyCheckArgs("hypot", arguments, 2, 2);\n        Sk.builtin.pyCheckType("x", "number", Sk.builtin.checkNumber(x));\n    Sk.builtin.pyCheckType("y", "number", Sk.builtin.checkNumber(y));\n\n        x = Sk.builtin.asnum$(x);\n        y = Sk.builtin.asnum$(y);\n    return new Sk.builtin.nmber(Math.sqrt((x*x)+(y*y)), Sk.builtin.nmber.float$);\n    });\n\n    mod.factorial = new Sk.builtin.func(function(x) {\n        Sk.builtin.pyCheckArgs("factorial", arguments, 1, 1);\n            Sk.builtin.pyCheckType("x", "number", Sk.builtin.checkNumber(x));\n\n        x = Math.floor(Sk.builtin.asnum$(x));\n        var r = 1;\n        for (var i = 2; i <= x; i++)\n            r *= i;\n        return new Sk.builtin.nmber(r, Sk.builtin.nmber.int$);\n    });\n\n    return mod;\n}',
    'src/lib/e3ga/__init__.js': '/**\n * Geometric Algebra (e3ga) module.\n *\n * David Holmes (david.geo.holmes@gmail.com)\n */\nvar $builtinmodule = function(name) {\n\n  var mod = {};\n\n  Sk.builtin.defineEuclidean3(mod);\n\n  return mod;\n}\n',
    'src/lib/webgl/primitives.js': '// most of this file is from \'tdl\'\n\nvar $builtinmodule = function(name)\n{\n    var mod = {};\n\n\n\n    /**\n     * AttribBuffer manages a TypedArray as an array of vectors.\n     *\n     * @param {number} numComponents Number of components per\n     *     vector.\n     * @param {number|!Array.<number>} numElements Number of vectors or the data.\n     * @param {string} opt_type The type of the TypedArray to\n     *     create. Default = \'Float32Array\'.\n     * @param {!Array.<number>} opt_data The data for the array.\n     */\n    var AttribBuffer = function(\n            numComponents, numElements, opt_type) {\n        opt_type = opt_type || \'Float32Array\';\n        var type = window[opt_type];\n        if (numElements.length) {\n            this.buffer = new type(numElements);\n            numElements = this.buffer.length / numComponents;\n            this.cursor = numElements;\n        } else {\n            this.buffer = new type(numComponents * numElements);\n            this.cursor = 0;\n        }\n        this.numComponents = numComponents;\n        this.numElements = numElements;\n        this.type = opt_type;\n    };\n\n    AttribBuffer.prototype.stride = function() {\n        return 0;\n    };\n\n    AttribBuffer.prototype.offset = function() {\n        return 0;\n    };\n\n    AttribBuffer.prototype.getElement = function(index) {\n        var offset = index * this.numComponents;\n        var value = [];\n        for (var ii = 0; ii < this.numComponents; ++ii) {\n            value.push(this.buffer[offset + ii]);\n        }\n        return value;\n    };\n\n    AttribBuffer.prototype.setElement = function(index, value) {\n        var offset = index * this.numComponents;\n        for (var ii = 0; ii < this.numComponents; ++ii) {\n            this.buffer[offset + ii] = value[ii];\n        }\n    };\n\n    AttribBuffer.prototype.clone = function() {\n        var copy = new AttribBuffer(\n                this.numComponents, this.numElements, this.type);\n        copy.pushArray(this);\n        return copy;\n    }\n\n    AttribBuffer.prototype.push = function(value) {\n        this.setElement(this.cursor++, value);\n    };\n\n    AttribBuffer.prototype.pushArray = function(array) {\n        //  this.buffer.set(array, this.cursor * this.numComponents);\n        //  this.cursor += array.numElements;\n        for (var ii = 0; ii < array.numElements; ++ii) {\n            this.push(array.getElement(ii));\n        }\n    };\n\n    AttribBuffer.prototype.pushArrayWithOffset =\n    function(array, offset) {\n        for (var ii = 0; ii < array.numElements; ++ii) {\n            var elem = array.getElement(ii);\n            for (var jj = 0; jj < offset.length; ++jj) {\n                elem[jj] += offset[jj];\n            }\n            this.push(elem);\n        }\n    };\n\n    /**\n    * Computes the extents\n    * @param {!AttribBuffer} positions The positions\n    * @return {!{min: !tdl.math.Vector3, max:!tdl.math.Vector3}}\n    *     The min and max extents.\n    */\n    AttribBuffer.prototype.computeExtents = function() {\n        var numElements = this.numElements;\n        var numComponents = this.numComponents;\n        var minExtent = this.getElement(0);\n        var maxExtent = this.getElement(0);\n        for (var ii = 1; ii < numElements; ++ii) {\n            var element = this.getElement(ii);\n            for (var jj = 0; jj < numComponents; ++jj) {\n                minExtent[jj] = Math.min(minExtent[jj], element[jj]);\n                maxExtent[jj] = Math.max(maxExtent[jj], element[jj]);\n            }\n        }\n        return {min: minExtent, max: maxExtent};\n    };\n\n\n    /**\n     * Creates the vertices and indices for a cube. The\n     * cube will be created around the origin. (-size / 2, size / 2)\n     *\n     * @param {number} size Width, height and depth of the cube.\n     * @return {!Object.<string, !tdl.primitives.AttribBuffer>} The\n     *         created plane vertices.\n     */\n    mod.createCube = new Sk.builtin.func(function(size)\n            {\n                var CUBE_FACE_INDICES_ = [\n                    [3, 7, 5, 1],\n                    [0, 4, 6, 2],\n                    [6, 7, 3, 2],\n                    [0, 1, 5, 4],\n                    [5, 7, 6, 4],\n                    [2, 3, 1, 0]\n                ];\n\n                var k = size / 2;\n\n                var cornerVertices = [\n                        [-k, -k, -k],\n                        [+k, -k, -k],\n                        [-k, +k, -k],\n                        [+k, +k, -k],\n                        [-k, -k, +k],\n                        [+k, -k, +k],\n                        [-k, +k, +k],\n                        [+k, +k, +k]\n                    ];\n\n                var faceNormals = [\n                        [+1, +0, +0],\n                        [-1, +0, +0],\n                        [+0, +1, +0],\n                        [+0, -1, +0],\n                        [+0, +0, +1],\n                        [+0, +0, -1]\n                    ];\n\n                var uvCoords = [\n                        [0, 0],\n                        [1, 0],\n                        [1, 1],\n                        [0, 1]\n                    ];\n\n                var numVertices = 6 * 4;\n                var positions = new AttribBuffer(3, numVertices);\n                var normals = new AttribBuffer(3, numVertices);\n                var texCoords = new AttribBuffer(2, numVertices);\n                var indices = new AttribBuffer(3, 6 * 2, \'Uint16Array\');\n\n                for (var f = 0; f < 6; ++f) {\n                    var faceIndices = CUBE_FACE_INDICES_[f];\n                    for (var v = 0; v < 4; ++v) {\n                        var position = cornerVertices[faceIndices[v]];\n                        var normal = faceNormals[f];\n                        var uv = uvCoords[v];\n\n                        // Each face needs all four vertices because the normals and texture\n                        // coordinates are not all the same.\n                        positions.push(position);\n                        normals.push(normal);\n                        texCoords.push(uv);\n\n                    }\n                    // Two triangles make a square face.\n                    var offset = 4 * f;\n                    indices.push([offset + 0, offset + 1, offset + 2]);\n                    indices.push([offset + 0, offset + 2, offset + 3]);\n                }\n\n                return {\n                        position: positions,\n                        normal: normals,\n                        texCoord: texCoords,\n                        indices: indices\n                };\n            });\n\n    return mod;\n};\n',
    'src/lib/document/__init__.js': 'var $builtinmodule = function(name) {\n    var mod = {};\n\n    mod.getElementById = new Sk.builtin.func(function(id) {\n        var result = document.getElementById(id.v);\n        if (result) {\n            return Sk.misceval.callsim(mod.Element,result);\n        }\n        return Sk.builtin.none.none$;\n    });\n\n    mod.createElement = new Sk.builtin.func(function(eName) {\n            var r = document.createElement(eName.v);\n            if (r) {\n                return Sk.misceval.callsim(mod.Element,r);\n            }\n        });\n\n\n    mod.getElementsByTagName = new Sk.builtin.func(function(tag) {\n        var r = document.getElementsByTagName(tag.v)\n        var reslist = [];\n        for (var i = r.length - 1; i >= 0; i--) {\n            reslist.push(Sk.misceval.callsim(mod.Element,r[i]))\n        }\n        return new Sk.builtin.list(reslist)\n    });\n\n    mod.getElementsByClassName = new Sk.builtin.func(function(cname) {\n        var r = document.getElementsByClassName(cname.v);\n        var reslist = [];\n        for (var i = 0; i < r.length; i++) {\n            reslist.push(Sk.misceval.callsim(mod.Element,r[i]));\n        };\n        return new Sk.builtin.list(reslist);\n    });\n    \n    mod.getElementsByName = new Sk.builtin.func(function(cname) {\n        var r = document.getElementsByName(cname.v);\n        var reslist = [];\n        for (var i = 0; i < r.length; i++) {\n            reslist.push(Sk.misceval.callsim(mod.Element,r[i]));\n        };\n        return new Sk.builtin.list(reslist);\n    });\n        \n    mod.currentDiv = new Sk.builtin.func(function() {\n        if (Sk.divid !== undefined) {\n            return new Sk.builtin.str(Sk.divid)\n        }\n        else {\n            throw new Sk.builtin.AttributeError("There is no value set for divid");\n        }\n    })\n    var elementClass = function($gbl, $loc) {\n        /*\n            Notes:  self[\'$d\'] is the dictionary used by the GenericGetAttr mechanism for an object.\n                    for various reasons  if you create a class in Javascript and have self.xxxx instance\n                    variables, you cannot say instance.xxx and get the value of the instance variable unless \n                    it is stored in the self[\'$d\'] object.  This seems like a duplication of storage to me\n                    but that is how it works right now  (5/2013)\n\n                    Writing your own __getattr__ is also an option but this gets very tricky when an attr is \n                    a method...\n        */\n        $loc.__init__ = new Sk.builtin.func(function(self,elem) {\n            self.v = elem\n            self.innerHTML = elem.innerHTML\n            self.innerText = elem.innerText\n            if (elem.value !== undefined) {\n                self.value = elem.value\n                Sk.abstr.objectSetItem(self[\'$d\'], new Sk.builtin.str(\'value\'), new Sk.builtin.str(self.value))                \n            }\n\n            if (elem.checked !== undefined) {\n                self.checked = elem.checked\n                Sk.abstr.objectSetItem(self[\'$d\'], new Sk.builtin.str(\'checked\'), new Sk.builtin.str(self.checked))                \n            }\n\n            Sk.abstr.objectSetItem(self[\'$d\'], new Sk.builtin.str(\'innerHTML\'), new Sk.builtin.str(self.innerHTML))\n            Sk.abstr.objectSetItem(self[\'$d\'], new Sk.builtin.str(\'innerText\'), new Sk.builtin.str(self.innerText))            \n\n        })\n\n        $loc.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;\n\n        $loc.__setattr__ = new Sk.builtin.func(function(self,key,value) {\n            if (key === \'innerHTML\') {\n                self.innerHTML = value\n                self.v.innerHTML = value.v\n                Sk.abstr.objectSetItem(self[\'$d\'], new Sk.builtin.str(\'innerHTML\'), value)                \n            }\n            if (key === \'innerText\') {\n                self.innerText = value\n                self.v.innerText = value.v\n                Sk.abstr.objectSetItem(self[\'$d\'], new Sk.builtin.str(\'innerText\'), value)            \n            }\n        });\n\n\n        $loc.appendChild = new Sk.builtin.func(function(self,ch) {\n            self.v.appendChild(ch.v);\n        });\n\n        $loc.removeChild = new Sk.builtin.func(function(self,node) {\n            self.v.removeChild(node.v)\n        })\n\n        // getCSS\n                    \n        $loc.getCSS = new Sk.builtin.func(function(self,key) {\n            return new Sk.builtin.str(self.v.style[key.v]);\n        });\n    \n\n        $loc.setCSS = new Sk.builtin.func(function(self,attr,value) {\n            self.v.style[attr.v] = value.v\n\n        })\n\n        $loc.getAttribute = new Sk.builtin.func(function(self,key) {\n            var res = self.v.getAttribute(key.v)\n            if (res) {\n                return new Sk.builtin.str(res)\n            } else {\n                return Sk.builtin.none.none$;\n            }\n        });\n\n        $loc.setAttribute = new Sk.builtin.func(function(self,attr,value) {\n                self.v.setAttribute(attr.v,value.v)\n        });\n            \n\n        $loc.__str__ = new Sk.builtin.func(function(self) {\n            console.log(self.v.tagName);\n            return new Sk.builtin.str(self.v.tagName)\n        })\n\n        $loc.__repr__ = new Sk.builtin.func(function(self) {\n            return new Sk.builtin.str(\'[DOM Element]\')\n        })\n\n    \n    };\n\n    mod.Element = Sk.misceval.buildClass(mod,elementClass,\'Element\', []);\n\n    return mod;\n\n}   ',
    'src/lib/re/__init__.js': 'var $builtinmodule = function(name)\n{\n    var mod = {};\n\n    // Constants (mostly unsupported)\n    mod.I = 2;\n    mod.IGNORECASE = 2;\n    // mod.L = 4;\n    // mod.LOCALE = 4;\n    mod.M = 8;\n    mod.MULTILINE = 8;\n    // mod.S = 16;\n    // mod.DOTALL = 16;\n    // mod.U = 32;\n    // mod.UNICODE = 32;\n    // mod.X = 64;\n    // mod.VERBOSE = 64;\n\n    var validGroups = ["(?:", "(?=", "(?!"];\n\n    var convert = function(pattern) {\n        var newpattern;\n        var match;\n        var i;\n\n        // Look for disallowed constructs\n        match = pattern.match(/\\(\\?./g);\n        if (match) {\n            for (i=0; i<match.length; i++) {\n                if (validGroups.indexOf(match[i]) == -1) {\n                    throw new Sk.builtin.ValueError("Disallowed group in pattern: \'"\n                                                    + match[i] + "\'");\n                };\n            };\n        };\n\n        newpattern = pattern.replace(\'/\\\\/g\', \'\\\\\\\\\');\n        newpattern = pattern.replace(/([^\\\\]){,(?![^\\[]*\\])/g, \'$1{0,\');\n\n        return newpattern;\n    };\n\n    var getFlags = function(flags) {\n        var jsflags = "g";\n        if ((flags & mod.IGNORECASE) == mod.IGNORECASE) {\n            jsflags += "i";\n        };\n        if ((flags & mod.MULTILINE) == mod.MULTILINE) {\n            jsflags += "m";\n        }; \n        return jsflags;\n    };\n\n    mod.split = Sk.nativejs.func(function split(pattern, string, maxsplit, flags) {\n        Sk.builtin.pyCheckArgs("split", arguments, 2, 4);\n        if (!Sk.builtin.checkString(pattern)) {\n            throw new Sk.builtin.TypeError("pattern must be a string");\n        };\n        if (!Sk.builtin.checkString(string)) {\n            throw new Sk.builtin.TypeError("string must be a string");\n        };\n        if (maxsplit === undefined) {\n            maxsplit = 0;\n        };\n        if (!Sk.builtin.checkNumber(maxsplit)) {\n            throw new Sk.builtin.TypeError("maxsplit must be a number");\n        };\n        if (flags === undefined) {\n            flags = 0;\n        };\n        if (!Sk.builtin.checkNumber(flags)) {\n            throw new Sk.builtin.TypeError("flags must be a number");\n        };\n\n        maxsplit = Sk.builtin.asnum$(maxsplit);\n        var pat = Sk.ffi.remapToJs(pattern);\n        var str = Sk.ffi.remapToJs(string);\n        \n        // Convert pat from Python to Javascript regex syntax\n        pat = convert(pat);\n        //print("Pat: " + pat);\n        //print("Str: " + str);\n\n        var captured = !(pat.match(/^\\(.*\\)$/) === null);\n        //print("Captured: ", captured);\n\n        var jsflags = getFlags(flags);\n        //print("Flags: ", jsflags);\n\n        var regex = new RegExp(pat, jsflags);\n\n        var result = [];\n        var match;\n        var index = 0;\n        var splits = 0;\n        while ((match = regex.exec(str)) != null) {\n            //print("Matched \'" + match[0] + "\' at position " + match.index + \n            //      "; next search at " + regex.lastIndex);\n            if (match.index === regex.lastIndex) {\n                // empty match\n                break;\n            };\n            result.push(new Sk.builtin.str(str.substring(index, match.index)));\n            if (captured) {\n                // Add matching pattern, too\n                result.push(new Sk.builtin.str(match[0]));\n            };\n            index = regex.lastIndex;\n            splits += 1;\n            if (maxsplit && (splits >= maxsplit)) {\n                break;\n            };\n        };\n        result.push(new Sk.builtin.str(str.substring(index)));\n\n        return new Sk.builtin.list(result);\n    });\n\n    mod.findall = Sk.nativejs.func(function findall(pattern, string, flags) {\n        Sk.builtin.pyCheckArgs("findall", arguments, 2, 3);\n        if (!Sk.builtin.checkString(pattern)) {\n            throw new Sk.builtin.TypeError("pattern must be a string");\n        };\n        if (!Sk.builtin.checkString(string)) {\n            throw new Sk.builtin.TypeError("string must be a string");\n        };\n        if (flags === undefined) {\n            flags = 0;\n        };\n        if (!Sk.builtin.checkNumber(flags)) {\n            throw new Sk.builtin.TypeError("flags must be a number");\n        };\n\n        var pat = Sk.ffi.remapToJs(pattern);\n        var str = Sk.ffi.remapToJs(string);\n        \n        // Convert pat from Python to Javascript regex syntax\n        pat = convert(pat);\n        //print("Pat: " + pat);\n        //print("Str: " + str);\n\n        var jsflags = getFlags(flags);\n        //print("Flags: ", jsflags);\n\n        var regex = new RegExp(pat, jsflags);\n\n    var newline_at_end = new RegExp(/\\n$/);\n    if (str.match(newline_at_end)) {\n        str = str.slice(0,-1);\n    }\n\n        var result = [];\n        var match;\n        while ((match = regex.exec(str)) != null) {\n            //print("Matched \'" + match[0] + "\' at position " + match.index + \n            //      "; next search at " + regex.lastIndex);\n            // print("match: " + JSON.stringify(match));\n            if (match.length < 2) {\n                result.push(new Sk.builtin.str(match[0]));\n            } else if (match.length == 2) {\n                result.push(new Sk.builtin.str(match[1]));\n            } else {\n                var groups = [];\n                for (var i=1; i<match.length; i++) {\n                    groups.push(new Sk.builtin.str(match[i]));  \n                };\n                result.push(new Sk.builtin.tuple(groups));\n            };\n            if (match.index === regex.lastIndex) {\n                regex.lastIndex += 1;\n            };\n        };\n\n        return new Sk.builtin.list(result);\n    });\n\n\n    var matchobj = function($gbl, $loc) {\n        $loc.__init__ = new Sk.builtin.func(function(self,thematch, pattern, string) {\n            self.thematch = thematch;\n        self.re = pattern;\n        self.string = string;\n        });\n\n    $loc.groups = new Sk.builtin.func(function(self) {\n        return new Sk.builtin.tuple(self.thematch.v.slice(1))\n    });\n\n    $loc.group = new Sk.builtin.func(function(self,grpnum) {\n        if (grpnum === undefined) {\n                grpnum = 0;\n            }\n            else {\n                grpnum = Sk.builtin.asnum$(grpnum);\n            }\n        if(grpnum >= self.thematch.v.length) {\n        throw new Sk.builtin.IndexError("Index out of range: " + grpnum);\n        }\n        return self.thematch.v[grpnum]\n    });\n\n    }\n\n    mod.MatchObject = Sk.misceval.buildClass(mod, matchobj, \'MatchObject\', []);\n\n    // Internal function to return a Python list of strings \n    // From a JS regular expression string\n    mod._findre = function(res, string) {\n    res = res.replace(/([^\\\\]){,(?![^\\[]*\\])/g, \'$1{0,\');\n        var re = eval(res);\n    var patt = new RegExp(\'\\n$\');\n    if (string.v.match(patt))\n        var matches = string.v.slice(0,-1).match(re);\n    else\n            var matches = string.v.match(re);\n        retval = new Sk.builtin.list();\n        if ( matches == null ) return retval;\n        for (var i = 0; i < matches.length; ++i) {\n            var sitem = new Sk.builtin.str(matches[i]);\n            retval.v.push(sitem);\n        }\n        return retval;\n    }\n\n    mod.search = new Sk.builtin.func(function(pattern, string, flags) {\n    Sk.builtin.pyCheckArgs(\'search\', arguments, 2, 3);\n        if (!Sk.builtin.checkString(pattern)) {\n            throw new Sk.builtin.TypeError("pattern must be a string");\n        };\n        if (!Sk.builtin.checkString(string)) {\n            throw new Sk.builtin.TypeError("string must be a string");\n        };\n    if (flags === undefined) {\n            flags = 0;\n        };\n        if (!Sk.builtin.checkNumber(flags)) {\n            throw new Sk.builtin.TypeError("flags must be a number");\n        };\n        var res = "/"+pattern.v.replace(/\\//g,"\\\\/")+"/";\n        lst = mod._findre(res,string);\n        if ( lst.v.length < 1 ) return Sk.builtin.none.none$;\n        var mob = Sk.misceval.callsim(mod.MatchObject, lst, pattern, string);\n        return mob;\n    });\n\n    mod.match = new Sk.builtin.func(function(pattern, string, flags) {\n    Sk.builtin.pyCheckArgs(\'match\', arguments, 2, 3);\n        if (!Sk.builtin.checkString(pattern)) {\n            throw new Sk.builtin.TypeError("pattern must be a string");\n        };\n        if (!Sk.builtin.checkString(string)) {\n            throw new Sk.builtin.TypeError("string must be a string");\n        };\n    if (flags === undefined) {\n            flags = 0;\n        };\n        if (!Sk.builtin.checkNumber(flags)) {\n            throw new Sk.builtin.TypeError("flags must be a number");\n        };\n        var res = "/^"+pattern.v.replace(/\\//g,"\\\\/")+"/";\n        lst = mod._findre(res,string);\n        if ( lst.v.length < 1 ) return Sk.builtin.none.none$;\n        var mob = Sk.misceval.callsim(mod.MatchObject, lst, pattern, string);\n        return mob;\n    });\n\n    return mod;\n}\n',
    'src/lib/urllib/__init__.js': 'var $builtinmodule = function(name)\n{\n  var urllib = {};\n\n  return urllib;\n};\n',
    'src/lib/random/__init__.js': '\n/*\n  I\'ve wrapped Makoto Matsumoto and Takuji Nishimura\'s code in a namespace\n  so it\'s better encapsulated. Now you can have multiple random number generators\n  and they won\'t stomp all over eachother\'s state.\n  \n  If you want to use this as a substitute for Math.random(), use the random()\n  method like so:\n  \n  var m = new MersenneTwister();\n  var randomNumber = m.random();\n  \n  You can also call the other genrand_{foo}() methods on the instance.\n\n  If you want to use a specific seed in order to get a repeatable random\n  sequence, pass an integer into the constructor:\n\n  var m = new MersenneTwister(123);\n\n  and that will always produce the same random sequence.\n\n  Sean McCullough (banksean@gmail.com)\n*/\n\n/* \n   A C-program for MT19937, with initialization improved 2002/1/26.\n   Coded by Takuji Nishimura and Makoto Matsumoto.\n \n   Before using, initialize the state by using init_genrand(seed)  \n   or init_by_array(init_key, key_length).\n \n   Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,\n   All rights reserved.                          \n \n   Redistribution and use in source and binary forms, with or without\n   modification, are permitted provided that the following conditions\n   are met:\n \n     1. Redistributions of source code must retain the above copyright\n        notice, this list of conditions and the following disclaimer.\n \n     2. Redistributions in binary form must reproduce the above copyright\n        notice, this list of conditions and the following disclaimer in the\n        documentation and/or other materials provided with the distribution.\n \n     3. The names of its contributors may not be used to endorse or promote \n        products derived from this software without specific prior written \n        permission.\n \n   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n   A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n \n \n   Any feedback is very welcome.\n   http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html\n   email: m-mat @ math.sci.hiroshima-u.ac.jp (remove space)\n*/\n\nvar MersenneTwister = function(seed) {\n  if (seed == undefined) {\n    seed = new Date().getTime();\n  } \n  /* Period parameters */  \n  this.N = 624;\n  this.M = 397;\n  this.MATRIX_A = 0x9908b0df;   /* constant vector a */\n  this.UPPER_MASK = 0x80000000; /* most significant w-r bits */\n  this.LOWER_MASK = 0x7fffffff; /* least significant r bits */\n \n  this.mt = new Array(this.N); /* the array for the state vector */\n  this.mti=this.N+1; /* mti==N+1 means mt[N] is not initialized */\n\n  this.init_genrand(seed);\n}  \n \n/* initializes mt[N] with a seed */\nMersenneTwister.prototype.init_genrand = function(s) {\n  this.mt[0] = s >>> 0;\n  for (this.mti=1; this.mti<this.N; this.mti++) {\n      var s = this.mt[this.mti-1] ^ (this.mt[this.mti-1] >>> 30);\n   this.mt[this.mti] = (((((s & 0xffff0000) >>> 16) * 1812433253) << 16) + (s & 0x0000ffff) * 1812433253)\n  + this.mti;\n      /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */\n      /* In the previous versions, MSBs of the seed affect   */\n      /* only MSBs of the array mt[].                        */\n      /* 2002/01/09 modified by Makoto Matsumoto             */\n      this.mt[this.mti] >>>= 0;\n      /* for >32 bit machines */\n  }\n}\n \n/* initialize by an array with array-length */\n/* init_key is the array for initializing keys */\n/* key_length is its length */\n/* slight change for C++, 2004/2/26 */\nMersenneTwister.prototype.init_by_array = function(init_key, key_length) {\n  var i, j, k;\n  this.init_genrand(19650218);\n  i=1; j=0;\n  k = (this.N>key_length ? this.N : key_length);\n  for (; k; k--) {\n    var s = this.mt[i-1] ^ (this.mt[i-1] >>> 30)\n    this.mt[i] = (this.mt[i] ^ (((((s & 0xffff0000) >>> 16) * 1664525) << 16) + ((s & 0x0000ffff) * 1664525)))\n      + init_key[j] + j; /* non linear */\n    this.mt[i] >>>= 0; /* for WORDSIZE > 32 machines */\n    i++; j++;\n    if (i>=this.N) { this.mt[0] = this.mt[this.N-1]; i=1; }\n    if (j>=key_length) j=0;\n  }\n  for (k=this.N-1; k; k--) {\n    var s = this.mt[i-1] ^ (this.mt[i-1] >>> 30);\n    this.mt[i] = (this.mt[i] ^ (((((s & 0xffff0000) >>> 16) * 1566083941) << 16) + (s & 0x0000ffff) * 1566083941))\n      - i; /* non linear */\n    this.mt[i] >>>= 0; /* for WORDSIZE > 32 machines */\n    i++;\n    if (i>=this.N) { this.mt[0] = this.mt[this.N-1]; i=1; }\n  }\n\n  this.mt[0] = 0x80000000; /* MSB is 1; assuring non-zero initial array */ \n}\n \n/* generates a random number on [0,0xffffffff]-interval */\nMersenneTwister.prototype.genrand_int32 = function() {\n  var y;\n  var mag01 = new Array(0x0, this.MATRIX_A);\n  /* mag01[x] = x * MATRIX_A  for x=0,1 */\n\n  if (this.mti >= this.N) { /* generate N words at one time */\n    var kk;\n\n    if (this.mti == this.N+1)   /* if init_genrand() has not been called, */\n      this.init_genrand(5489); /* a default initial seed is used */\n\n    for (kk=0;kk<this.N-this.M;kk++) {\n      y = (this.mt[kk]&this.UPPER_MASK)|(this.mt[kk+1]&this.LOWER_MASK);\n      this.mt[kk] = this.mt[kk+this.M] ^ (y >>> 1) ^ mag01[y & 0x1];\n    }\n    for (;kk<this.N-1;kk++) {\n      y = (this.mt[kk]&this.UPPER_MASK)|(this.mt[kk+1]&this.LOWER_MASK);\n      this.mt[kk] = this.mt[kk+(this.M-this.N)] ^ (y >>> 1) ^ mag01[y & 0x1];\n    }\n    y = (this.mt[this.N-1]&this.UPPER_MASK)|(this.mt[0]&this.LOWER_MASK);\n    this.mt[this.N-1] = this.mt[this.M-1] ^ (y >>> 1) ^ mag01[y & 0x1];\n\n    this.mti = 0;\n  }\n\n  y = this.mt[this.mti++];\n\n  /* Tempering */\n  y ^= (y >>> 11);\n  y ^= (y << 7) & 0x9d2c5680;\n  y ^= (y << 15) & 0xefc60000;\n  y ^= (y >>> 18);\n\n  return y >>> 0;\n}\n \n/* generates a random number on [0,0x7fffffff]-interval */\nMersenneTwister.prototype.genrand_int31 = function() {\n  return (this.genrand_int32()>>>1);\n}\n \n/* generates a random number on [0,1]-real-interval */\nMersenneTwister.prototype.genrand_real1 = function() {\n  return this.genrand_int32()*(1.0/4294967295.0); \n  /* divided by 2^32-1 */ \n}\n\n/* generates a random number on [0,1)-real-interval */\nMersenneTwister.prototype.random = function() {\n  return this.genrand_int32()*(1.0/4294967296.0); \n  /* divided by 2^32 */\n}\n \n/* generates a random number on (0,1)-real-interval */\nMersenneTwister.prototype.genrand_real3 = function() {\n  return (this.genrand_int32() + 0.5)*(1.0/4294967296.0); \n  /* divided by 2^32 */\n}\n \n/* generates a random number on [0,1) with 53-bit resolution*/\nMersenneTwister.prototype.genrand_res53 = function() { \n  var a=this.genrand_int32()>>>5, b=this.genrand_int32()>>>6; \n  return(a*67108864.0+b)*(1.0/9007199254740992.0); \n} \n\n/* These real versions are due to Isaku Wada, 2002/01/09 added */\n\n\n\nvar $builtinmodule = function(name)\n{\n\n    var mod = {};\n\n    var myGenerator = new MersenneTwister();\n\n    mod.seed = new Sk.builtin.func(function(x) {\n        Sk.builtin.pyCheckArgs("seed", arguments, 0, 1);\n\tx = Sk.builtin.asnum$(x);\n\n        if (arguments.length > 0)\n            myGenerator = new MersenneTwister(x);\n        else\n            myGenerator = new MersenneTwister();\n\n\treturn Sk.builtin.none.none$;\n    });\n\n    mod.random = new Sk.builtin.func(function() {\n        Sk.builtin.pyCheckArgs("random", arguments, 0, 0);\n\n\treturn new Sk.builtin.nmber(myGenerator.genrand_res53(), Sk.builtin.nmber.float$);\n    });\n\n    var toInt = function(num) {\n        return num | 0;\n    };\n\n    var randrange = function(start, stop, step) {\n        // Ported from CPython 2.7\n        var width, n, ret;\n\n        if (!Sk.builtin.checkInt(start)) {\n            throw new Sk.builtin.ValueError("non-integer first argument for randrange()");\n        };\n\n        if (stop === undefined) {\n            // Random in [0, start)\n            return toInt(myGenerator.genrand_res53() * start);\n        };\n\n        if (!Sk.builtin.checkInt(stop)) {\n            throw new Sk.builtin.ValueError("non-integer stop for randrange()");\n        };\n\n        if (step === undefined) {\n            step = 1;\n        };\n\n        width = stop - start;\n\n        if ((step == 1) && (width > 0)) {\n            // Random in [start, stop), must use toInt on product for correct results with negative ranges\n            ret = start + toInt(myGenerator.genrand_res53() * width);\n\t    return new Sk.builtin.nmber(ret, Sk.builtin.nmber.int$);\n        };\n\n        if (step == 1) {\n            throw new Sk.builtin.ValueError("empty range for randrange() (" + start + ", " + stop + ", " + width + ")");\n        };\n\n        if (!Sk.builtin.checkInt(step)) {\n            throw new Sk.builtin.ValueError("non-integer step for randrange()");\n        };\n\n        if (step > 0) {\n            n = toInt((width + step - 1) / step);\n        } else if (step < 0) {\n            n = toInt((width + step + 1) / step);\n        } else {\n            throw new Sk.builtin.ValueError("zero step for randrange()");\n        };\n\n        if (n <= 0) {\n            throw new Sk.builtin.ValueError("empty range for randrange()");\n        };\n\n        // Random in range(start, stop, step)\n        ret = start + (step * toInt(myGenerator.genrand_res53() * n));\n\treturn new Sk.builtin.nmber(ret, Sk.builtin.nmber.int$);\n    };\n\n    mod.randint = new Sk.builtin.func(function(a, b) {\n        Sk.builtin.pyCheckArgs("randint", arguments, 2, 2);\n\n\ta = Sk.builtin.asnum$(a);\n\tb = Sk.builtin.asnum$(b);\n        return randrange(a, b+1);\n    });\n\n    mod.randrange = new Sk.builtin.func(function(start, stop, step) {\n        Sk.builtin.pyCheckArgs("randrange", arguments, 1, 3);\n\n\tstart = Sk.builtin.asnum$(start);\n\tstop = Sk.builtin.asnum$(stop);\n\tstep = Sk.builtin.asnum$(step);\n        return randrange(start, stop, step);\n    });\n\n    mod.choice = new Sk.builtin.func(function(seq) {\n        Sk.builtin.pyCheckArgs("choice", arguments, 1, 1);\n        Sk.builtin.pyCheckType("seq", "sequence", Sk.builtin.checkSequence(seq));\n\n        if (seq.sq$length !== undefined) {\n            var r = toInt(myGenerator.genrand_res53() * seq.sq$length());\n            return seq.mp$subscript(r);\n        } else {\n            throw new Sk.builtin.TypeError("object has no length");\n        }\n    });\n\n    mod.shuffle = new Sk.builtin.func(function(x) {\n        Sk.builtin.pyCheckArgs("shuffle", arguments, 1, 1);\n        Sk.builtin.pyCheckType("x", "sequence", Sk.builtin.checkSequence(x));\n\n        if (x.sq$length !== undefined) {\n            if (x.mp$ass_subscript !== undefined) {\n                for (var i = x.sq$length() - 1; i > 0; i -= 1) {\n                    var r = toInt(myGenerator.genrand_res53() * (i + 1));\n                    var tmp = x.mp$subscript(r);\n                    x.mp$ass_subscript(r, x.mp$subscript(i));\n                    x.mp$ass_subscript(i, tmp);\n                };\n            } else {\n                throw new Sk.builtin.TypeError("object is immutable");\n            };\n        } else {\n            throw new Sk.builtin.TypeError("object has no length");\n        };        \n\n\treturn Sk.builtin.none.none$;\n    });\n\n    return mod;\n}',
    'src/lib/test/__init__.py': '__author__ = \'bmiller\'\n\ndef testEqual(actual, expected):\n    if type(expected) == type(1):\n        if actual == expected:\n            print(\'Pass\')\n            return True\n    elif type(expected) == type(1.11):\n        if abs(actual-expected) < 0.00001:\n            print(\'Pass\')\n            return True\n    else:\n        if actual == expected:\n            print(\'Pass\')\n            return True\n    print(\'Test Failed: expected \' + str(expected) + \' but got \' + str(actual))\n    return False\n\ndef testNotEqual(actual, expected):\n    pass\n\n',
    'src/builtin/this.py': 's = """Gur Mra bs Clguba, ol Gvz Crgref\n\nOrnhgvshy vf orggre guna htyl.\nRkcyvpvg vf orggre guna vzcyvpvg.\nFvzcyr vf orggre guna pbzcyrk.\nPbzcyrk vf orggre guna pbzcyvpngrq.\nSyng vf orggre guna arfgrq.\nFcnefr vf orggre guna qrafr.\nErnqnovyvgl pbhagf.\nFcrpvny pnfrf nera\'g fcrpvny rabhtu gb oernx gur ehyrf.\nNygubhtu cenpgvpnyvgl orngf chevgl.\nReebef fubhyq arire cnff fvyragyl.\nHayrff rkcyvpvgyl fvyraprq.\nVa gur snpr bs nzovthvgl, ershfr gur grzcgngvba gb thrff.\nGurer fubhyq or bar-- naq cersrenoyl bayl bar --boivbhf jnl gb qb vg.\nNygubhtu gung jnl znl abg or boivbhf ng svefg hayrff lbh\'er Qhgpu.\nAbj vf orggre guna arire.\nNygubhtu arire vf bsgra orggre guna *evtug* abj.\nVs gur vzcyrzragngvba vf uneq gb rkcynva, vg\'f n onq vqrn.\nVs gur vzcyrzragngvba vf rnfl gb rkcynva, vg znl or n tbbq vqrn.\nAnzrfcnprf ner bar ubaxvat terng vqrn -- yrg\'f qb zber bs gubfr!"""\n\nd = {}\nfor c in (65, 97):\n    for i in range(26):\n        d[chr(i+c)] = chr((i+13) % 26 + c)\n\nprint "".join([d.get(c, c) for c in s])\n',
    'src/lib/e2ga/__init__.js': '/**\n * Geometric Algebra (e2ga) module.\n *\n * David Holmes (david.geo.holmes@gmail.com)\n */\nvar $builtinmodule = function(name) {\n\n  var mod = {};\n\n  Sk.builtin.defineEuclidean2(mod);\n\n  return mod;\n}\n',
    'src/lib/eight/__init__.js': '/**\n * eight is a foreign function interface over Three.js for the DaVinci Python to JavaScript cross-compiler.\n *\n * The name eight reflects the 2 * 2 * 2 = 8 coordinates required in the Geometric Algebra generated by 3D Euclidean space.\n *\n * The eight module is in most respects API-compatible with the Three.js library except that THREE.Vector3 has\n * been extended in the ffi to Euclidean3.\n *\n * David Holmes (david.geo.holmes@gmail.com)\n */\nvar $builtinmodule = function(name) {\n  \n  var EUCLIDEAN_3           = "Euclidean3";\n  var SCALAR_3              = "Scalar3";\n  var VECTOR_3              = "Vector3";\n  var BIVECTOR_3            = "Bivector3";\n  var PSEUDOSCALAR_3        = "Pseudoscalar3";\n\n  var QUATERNION            = "Quaternion";\n\n  var SCENE                 = "Scene";\n  var CANVAS_RENDERER       = "CanvasRenderer";\n  var WEBGL_RENDERER        = "WebGLRenderer";\n  var COLOR                 = "Color";\n  var ORTHOGRAPHIC_CAMERA   = "OrthographicCamera";\n  var PERSPECTIVE_CAMERA    = "PerspectiveCamera";\n\n  var GEOMETRY              = "Geometry";\n  var OBJECT_3D             = "Object3D";\n\n  var AMBIENT_LIGHT         = "AmbientLight";\n  var DIRECTIONAL_LIGHT     = "DirectionalLight";\n  var POINT_LIGHT           = "PointLight";\n\n  var LINE                  = "Line";\n  var LINE_BASIC_MATERIAL   = "LineBasicMaterial";\n\n  var MESH                  = "Mesh";\n  var MESH_BASIC_MATERIAL   = "MeshBasicMaterial";\n  var MESH_LAMBERT_MATERIAL = "MeshLambertMaterial";\n  var MESH_NORMAL_MATERIAL  = "MeshNormalMaterial";\n  var MESH_PHONG_MATERIAL   = "MeshPhongMaterial";\n\n  var ARROW_GEOMETRY        = "ArrowGeometry";\n  var CIRCLE_GEOMETRY       = "CircleGeometry";\n  var CUBE_GEOMETRY         = "CubeGeometry";\n  var CYLINDER_GEOMETRY     = "CylinderGeometry";\n  var ICOSAHEDRON_GEOMETRY  = "IcosahedronGeometry";\n  var LATHE_GEOMETRY        = "LatheGeometry";\n  var OCTAHEDRON_GEOMETRY   = "OctahedronGeometry";\n  var PLANE_GEOMETRY        = "PlaneGeometry";\n  var SPHERE_GEOMETRY       = "SphereGeometry";\n  var TEXT_GEOMETRY         = "TextGeometry";\n  var TETRAHEDRON_GEOMETRY  = "TetrahedronGeometry";\n  var TORUS_GEOMETRY        = "TorusGeometry";\n\n  var PROP_BOTTOM              = "bottom";\n  var PROP_COLOR               = "color";\n  var PROP_DETAIL              = "detail";\n  var PROP_EULER_ORDER         = "eulerOrder";\n  var PROP_FAR                 = "far";\n  var PROP_GEOMETRY            = "geometry";\n  var PROP_ID                  = "id";\n  var PROP_LEFT                = "left";\n  var PROP_MASS                = "mass";\n  var PROP_MATERIAL            = "material";\n  var PROP_MATRIX_AUTO_UPDATE  = "matrixAutoUpdate";\n  var PROP_NAME                = "name";\n  var PROP_NEAR                = "near";\n  var PROP_NEEDS_UPDATE        = "needsUpdate";\n  var PROP_OPACITY             = "opacity";\n  var PROP_OVERDRAW            = "overdraw";\n  var PROP_POSITION            = "position";\n  var PROP_QUATERNION          = "quaternion";\n  var PROP_RADIUS              = "radius";\n  var PROP_RIGHT               = "right";\n  var PROP_ROTATION            = "rotation";\n  var PROP_SCALE               = "scale";\n  var PROP_SEGMENTS            = "segments";\n  var PROP_THETA_START         = "thetaStart";\n  var PROP_THETA_LENGTH        = "thetaLength";\n  var PROP_TOP                 = "top";\n  var PROP_TRANSPARENT         = "transparent";\n  var PROP_TYPE                = "type";\n  var PROP_UP                  = "up";\n  var PROP_USE_QUATERNION      = "useQuaternion";\n  var PROP_VELOCITY            = "velocity";\n  var PROP_VERTICES            = "vertices";\n  var PROP_VISIBLE             = "visible";\n  var PROP_WIREFRAME           = "wireframe";\n  var PROP_WIREFRAME_LINEWIDTH = "wireframeLinewidth";\n\n  var PROP_W                     = "w";\n  var PROP_X                     = "x";\n  var PROP_Y                     = "y";\n  var PROP_Z                     = "z";\n  var PROP_XY                    = "xy";\n  var PROP_YZ                    = "yz";\n  var PROP_ZX                    = "zx";\n  var PROP_XYZ                   = "xyz";\n  var METHOD_SET_X               = "setX";\n  var METHOD_SET_Y               = "setY";\n  var METHOD_SET_Z               = "setZ";\n  var METHOD_GET_COMPONENT       = "getComponent";\n  var METHOD_SET_COMPONENT       = "setComponent";\n  var METHOD_SET                 = "set";\n  var METHOD_SET_FROM_AXIS_ANGLE = "setFromAxisAngle";\n  var METHOD_SET_FROM_EULER      = "setFromEuler";\n  var METHOD_SET_GEOMETRY        = "setGeometry";\n  var METHOD_UPDATE_MATRIX       = "updateMatrix";\n\n  var METHOD_ADD               = "add";\n  var METHOD_CLONE             = "clone";\n  var METHOD_CONJUGATE         = "conjugate";\n  var METHOD_COPY              = "copy";\n  var METHOD_CROSS             = "cross";\n  var METHOD_DOT               = "dot";\n  var METHOD_INVERSE           = "inverse";\n  var METHOD_LENGTH            = "length";\n  var METHOD_LENGTH_SQ         = "lengthSq";\n  var METHOD_LOOK_AT           = "lookAt";\n  var METHOD_NORMALIZE         = "normalize";\n  var METHOD_REMOVE            = "remove";\n  var METHOD_SET_RGB           = "setRGB";\n\n  var mod = {};\n\n  function isBoolean(x)   { return typeof x === \'boolean\'; }\n  function isFunction(x)  { return typeof x === \'function\'; }\n  function isNumber(x)    { return typeof x === \'number\'; }\n  function isObject(x)    { return typeof x === \'object\'; }\n  function isString(x)    { return typeof x === \'string\'; }\n  function isUndefined(x) { return typeof x === \'undefined\'; }\n\n  function isDefined(x)   { return typeof x !== \'undefined\'; }\n  function isNull(x)      { return typeof x === \'object\' && x === null; }\n\n  function methodAdd(target) {\n    if (!isObject(target)) {\n      throw new Sk.builtin.AssertionError("target must be an object.");\n    }\n    if (!isFunction(target[METHOD_ADD])) {\n      throw new Sk.builtin.AssertionError("target must have an \'add\' function.");\n    }\n    return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n      $loc.__init__ = new Sk.builtin.func(function(self) {\n        self.tp$name = METHOD_ADD;\n      });\n      $loc.__call__ = new Sk.builtin.func(function(self, childPy) {\n        var child = Sk.ffi.remapToJs(childPy);\n        target[METHOD_ADD](child);\n      });\n      $loc.__str__ = new Sk.builtin.func(function(self) {\n        return new Sk.builtin.str(METHOD_ADD)\n      })\n      $loc.__repr__ = new Sk.builtin.func(function(self) {\n        return new Sk.builtin.str(METHOD_ADD)\n      })\n    }, METHOD_ADD, []));\n  }\n\n  function methodRemove(target) {\n    if (!isObject(target)) {\n      throw new Sk.builtin.AssertionError("target must be an object.");\n    }\n    if (!isFunction(target[METHOD_REMOVE])) {\n      throw new Sk.builtin.AssertionError("target must have a \'remove\' function.");\n    }\n    return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n      $loc.__init__ = new Sk.builtin.func(function(self) {\n        self.tp$name = METHOD_REMOVE;\n      });\n      $loc.__call__ = new Sk.builtin.func(function(self, childPy) {\n        var child = Sk.ffi.remapToJs(childPy);\n        target[METHOD_REMOVE](child);\n      });\n      $loc.__str__ = new Sk.builtin.func(function(self) {\n        return new Sk.builtin.str(METHOD_REMOVE)\n      })\n      $loc.__repr__ = new Sk.builtin.func(function(self) {\n        return new Sk.builtin.str(METHOD_REMOVE)\n      })\n    }, METHOD_REMOVE, []));\n  }\n\n  function verticesPy(vertices) {\n    return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n      $loc.__init__ = new Sk.builtin.func(function(self) {\n        self.tp$name = PROP_VERTICES;\n        self.v = vertices;\n      });\n      $loc.__getattr__ = new Sk.builtin.func(function(verticesPy, name) {\n        var METHOD_APPEND = "append";\n        switch(name) {\n          case METHOD_APPEND: {\n            return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n              $loc.__init__ = new Sk.builtin.func(function(self) {\n                self.tp$name = METHOD_APPEND;\n              });\n              $loc.__call__ = new Sk.builtin.func(function(self, vectorPy) {\n                vertices.push(Sk.ffi.remapToJs(vectorPy));\n              });\n              $loc.__str__ = new Sk.builtin.func(function(self) {\n                return new Sk.builtin.str(METHOD_APPEND)\n              });\n              $loc.__repr__ = new Sk.builtin.func(function(self) {\n                return new Sk.builtin.str(METHOD_APPEND)\n              });\n            }, METHOD_APPEND, []));\n          }\n        }\n      });\n      $loc.__getitem__ = new Sk.builtin.func(function(verticesPy, indexPy) {\n        var index = Sk.ffi.remapToJs(indexPy);\n        return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(vertices[index], EUCLIDEAN_3));\n      });\n      $loc.mp$length = function() {return vertices.length;};\n      $loc.__str__ = new Sk.builtin.func(function(self) {\n        return new Sk.builtin.str(PROP_VERTICES)\n      });\n      $loc.__repr__ = new Sk.builtin.func(function(self) {\n        return new Sk.builtin.str(PROP_VERTICES)\n      });\n    }, PROP_VERTICES, []));\n  }\n\n  /*\n   * Deterines whether the argument is a genuine Color reference.\n   */\n  function isColor(x) {\n    if (isDefined(x)) {\n      if (x.hasOwnProperty("r") && x.hasOwnProperty("g") && x.hasOwnProperty("b")) {\n        return isNumber(x["r"]) && isNumber(x["g"]) && isNumber(x["b"]);\n      }\n      else {\n        return false;\n      }\n    }\n    else {\n      return false;\n    }\n  }\n\n  function webGLSupported() {\n    try {\n      if (window.WebGLRenderingContext) {\n        if (document.createElement(\'canvas\').getContext(\'experimental-webgl\')) {\n          return true;\n        }\n        else {\n          return false;\n        }\n      }\n      else {\n        return false;\n      }\n    }\n    catch(e) {\n      return false;\n    }\n  }\n\n  function stringFromCoordinates(coordinates, labels) {\n    var append, i, sb, str, _i, _ref;\n    sb = [];\n    append = function(number, label) {\n      var n;\n      if (number !== 0) {\n        if (number >= 0) {\n          if (sb.length > 0) {\n            sb.push("+");\n          }\n        } else {\n          sb.push("-");\n        }\n        n = Math.abs(number);\n        if (n === 1) {\n          return sb.push(label);\n        } else {\n          sb.push(n.toString());\n          if (label !== "1") {\n            sb.push("*");\n            return sb.push(label);\n          }\n        }\n      }\n    };\n    for (i = _i = 0, _ref = coordinates.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {\n      append(coordinates[i], labels[i]);\n    }\n    if (sb.length > 0) {\n      str = sb.join("");\n    } else {\n      str = "0";\n    }\n    return str;\n  }\n\n  function numberFromArg(arg, argName, functionName, lax) {\n    if (isUndefined(argName)) {\n      throw new Error("argName must be specified")\n    }\n    if (isUndefined(functionName)) {\n      throw new Error("functionName must be specified")\n    }\n    lax = isUndefined(lax) ? true : (isBoolean(lax) ? lax : true);\n    if (isUndefined(arg)) {\n      if (lax) {\n        return arg;\n      }\n      else {\n        throw new Sk.builtin.TypeError(functionName + "." + argName + " must be convertible to a number, but was Missing.");\n      }\n    }\n    else if (isNull(arg)) {\n      if (lax) {\n        return arg;\n      }\n      else {\n        throw new Sk.builtin.TypeError(functionName + "." + argName + " must be convertible to a number, but was None.");\n      }\n    }\n    if (isBoolean(arg)) {\n      throw new Sk.builtin.TypeError(functionName + "." + argName + " must be convertible to a number, but was a Boolean.");\n    }\n\n    if (arg.skType) {\n      switch(arg.skType) {\n        case \'float\': {\n          return arg.v;\n        }\n        case \'int\': {\n          return arg.v;\n        }\n        default: {\n          throw new Sk.builtin.TypeError(functionName + "(" + argName + ": " + arg.skType + ") must be convertible to a number.");\n        }\n      }\n    }\n    else if (arg.v) {\n      if (isString(arg.v)) {\n        throw new Sk.builtin.TypeError(functionName + "." + argName + " must be convertible to a number, but was a String.");\n      }\n      else {\n        throw new Sk.builtin.AssertionError(functionName + "." + argName + " is unknown.");\n      }\n    }\n    else {\n      throw new Sk.builtin.AssertionError(functionName + "." + argName + " is unknown.");\n    }\n  }\n\n  function numberFromIntegerArg(arg, argName, functionName) {\n    // TODO: Maybe need an argument to say whether undefined is acceptable?\n    // TODO: Likewise for whether null is acceptable.\n    if (isUndefined(arg)) {\n      return arg;\n    }\n    else if (isNull(arg)) {\n      return null;\n    }\n    else {\n      if (arg.skType) {\n        switch(arg.skType) {\n          case \'float\': {\n            // TODO: Handle coercion to nearest integer.\n            return arg.v;\n          }\n          case \'int\': {\n            return arg.v;\n          }\n        }\n      }\n      throw new Sk.builtin.AssertionError(functionName + "." + argName + " must be an integer.");\n    }\n  }\n\n  function remapE3ToPy(w, x, y, z, xy, yz, zx, xyz) {\n    w = Sk.builtin.assk$(w, Sk.builtin.nmber.float$);\n    x = Sk.builtin.assk$(x, Sk.builtin.nmber.float$);\n    y = Sk.builtin.assk$(y, Sk.builtin.nmber.float$);\n    z = Sk.builtin.assk$(z, Sk.builtin.nmber.float$);\n    xy = Sk.builtin.assk$(xy, Sk.builtin.nmber.float$);\n    yz = Sk.builtin.assk$(yz, Sk.builtin.nmber.float$);\n    zx = Sk.builtin.assk$(zx, Sk.builtin.nmber.float$);\n    xyz = Sk.builtin.assk$(xyz, Sk.builtin.nmber.float$);\n    return Sk.misceval.callsim(mod[EUCLIDEAN_3], w, x, y, z, xy, yz, zx, xyz);\n  }\n\n  function wxyzToPy(w, x, y, z) {\n    var wPy = Sk.builtin.assk$(w, Sk.builtin.nmber.float$);\n    var xPy = Sk.builtin.assk$(x, Sk.builtin.nmber.float$);\n    var yPy = Sk.builtin.assk$(y, Sk.builtin.nmber.float$);\n    var zPy = Sk.builtin.assk$(z, Sk.builtin.nmber.float$);\n    return Sk.misceval.callsim(mod[QUATERNION], xPy, yPy, zPy, wPy);\n  }\n\n  function multiVector3(w, vector, xy, yz, zx, xyz) {\n    vector.w = w;\n    vector.xy = xy;\n    vector.yz = yz;\n    vector.zx = zx;\n    vector.xyz = xyz;\n    return vector;\n  }\n\n  Sk.builtin.defineEuclidean3(mod);\n\n  mod[QUATERNION] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self, x, y, z, w) {\n      x = Sk.ffi.remapToJs(x);\n      y = Sk.ffi.remapToJs(y);\n      z = Sk.ffi.remapToJs(z);\n      w = Sk.ffi.remapToJs(w);\n      if (isObject(x) && isUndefined(y) && isUndefined(z) && isUndefined(w)) {\n        self.v = x;\n      }\n      else {\n        self.v = new THREE[QUATERNION](x, y, z, w);\n      }\n      self.tp$name = QUATERNION;\n    });\n    $loc.__add__ = new Sk.builtin.func(function(a, b) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(b)) {\n        return wxyzToPy(a.w + b, a.x, a.y, a.z);\n      }\n      else {\n        var w = a.w + b.w;\n        var x = a.x + b.x;\n        var y = a.y + b.y;\n        var z = a.z + b.z;\n        return wxyzToPy(w, x, y, z);\n      }\n    });\n    $loc.__radd__ = new Sk.builtin.func(function(b, a) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(a)) {\n        return wxyzToPy(a + b.w, b.x, b.y, b.z);\n      }\n      else {\n        throw new Sk.builtin.AssertionError();\n      }\n    });\n    $loc.__iadd__ = new Sk.builtin.func(function(selfPy, otherPy) {\n      var self = Sk.ffi.remapToJs(selfPy);\n      var other = Sk.ffi.remapToJs(otherPy);\n      if (isNumber(other)) {\n        self.w += other;\n      }\n      else {\n        self.w += other.w;\n        self.x += other.x;\n        self.y += other.y;\n        self.z += other.z;\n      }\n      return selfPy;\n    });\n    $loc.__sub__ = new Sk.builtin.func(function(a, b) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(b)) {\n        return wxyzToPy(a.w - b, a.x, a.y, a.z);\n      }\n      else {\n        var w = a.w - b.w;\n        var x = a.x - b.x;\n        var y = a.y - b.y;\n        var z = a.z - b.z;\n        return wxyzToPy(w, x, y, z);\n      }\n    });\n    $loc.__rsub__ = new Sk.builtin.func(function(b, a) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(a)) {\n        return wxyzToPy(a - b.w, -b.x, -b.y, -b.z);\n      }\n      else {\n        throw new Sk.builtin.AssertionError();\n      }\n    });\n    $loc.__isub__ = new Sk.builtin.func(function(selfPy, otherPy) {\n      var self = Sk.ffi.remapToJs(selfPy);\n      var other = Sk.ffi.remapToJs(otherPy);\n      if (isNumber(other)) {\n        self.w -= other;\n      }\n      else {\n        self.w -= other.w;\n        self.x -= other.x;\n        self.y -= other.y;\n        self.z -= other.z;\n      }\n      return selfPy;\n    });\n    $loc.__mul__ = new Sk.builtin.func(function(a, b) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(b)) {\n        return wxyzToPy(a.w * b, a.x * b, a.y * b, a.z * b);\n      }\n      else {\n        var ab = new THREE[QUATERNION]().multiplyQuaternions(a, b);\n        return Sk.misceval.callsim(mod[QUATERNION], Sk.ffi.referenceToPy(ab, QUATERNION));\n      }\n    });\n    $loc.__rmul__ = new Sk.builtin.func(function(b, a) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(a)) {\n        return quaternionToPy(a * b.w, a * b.x, a * b.y, a * b.z);\n      }\n      else {\n        throw new Sk.builtin.AssertionError();\n      }\n    });\n    $loc.__imul__ = new Sk.builtin.func(function(selfPy, otherPy) {\n      var a = Sk.ffi.remapToJs(selfPy);\n      var b = Sk.ffi.remapToJs(otherPy);\n      var a0 = a.w;\n      var a1 = a.x;\n      var a2 = a.y;\n      var a3 = a.z;\n      var b0, b1, b2, b3, b4, b5, b6, b7;\n      if (isNumber(b)) {\n        a.w *= b;\n        a.x *= b;\n        a.y *= b;\n        a.z *= b;\n      }\n      else {\n        a.multiply(b);\n      }\n      return selfPy;\n    });\n    $loc.nb$positive = function() {\n      return this;\n    };\n    $loc.nb$negative = function() {\n      var mv = Sk.ffi.remapToJs(this);\n      return quaternionToPy(-mv.x, -mv.y, -mv.z, -mv.w);\n    };\n    $loc.nb$invert = function() {\n      var mv = Sk.ffi.remapToJs(this);\n      return remapE3ToPy(mv.w, mv.x, mv.y, mv.z, -mv.xy, -mv.yz, -mv.zx, -mv.xyz);\n    };\n    $loc.__eq__ = new Sk.builtin.func(function(a, b) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      return a.w === b.w && a.x === b.x && a.y === b.y && a.z === b.z;\n    });\n    $loc.__ne__ = new Sk.builtin.func(function(a, b) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      return a.w !== b.w || a.x !== b.x || a.y !== b.y || a.z !== b.z;\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(quaternionPy, name) {\n      var quaternion = Sk.ffi.remapToJs(quaternionPy);\n      switch(name) {\n        case PROP_X: {\n          return Sk.builtin.assk$(quaternion.x, Sk.builtin.nmber.float$);\n        }\n        case PROP_Y: {\n          return Sk.builtin.assk$(quaternion.y, Sk.builtin.nmber.float$);\n        }\n        case PROP_Z: {\n          return Sk.builtin.assk$(quaternion.z, Sk.builtin.nmber.float$);\n        }\n        case PROP_W: {\n          return Sk.builtin.assk$(quaternion.w, Sk.builtin.nmber.float$);\n        }\n        case METHOD_COPY: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_COPY;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, qPy) {\n              var q  = Sk.ffi.remapToJs(qPy);\n              quaternion.x = q.x;\n              quaternion.y = q.y;\n              quaternion.z = q.z;\n              quaternion.w = q.w;\n              return quaternionPy;\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_COPY);\n            });\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_COPY);\n            });\n          }, METHOD_COPY, []));\n        }\n        case METHOD_SET_FROM_AXIS_ANGLE: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_SET_FROM_AXIS_ANGLE;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, axisPy, anglePy) {\n              var axis = Sk.ffi.remapToJs(axisPy);\n              var angle = Sk.ffi.remapToJs(anglePy);\n              quaternion[METHOD_SET_FROM_AXIS_ANGLE](axis, angle);\n              return quaternionPy;\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_SET_FROM_AXIS_ANGLE);\n            });\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_SET_FROM_AXIS_ANGLE);\n            });\n          }, METHOD_SET_FROM_AXIS_ANGLE, []));\n        }\n        case METHOD_SET_FROM_EULER: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_SET_FROM_EULER;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, vectorPy, orderPy) {\n              var vector = Sk.ffi.remapToJs(vectorPy);\n              var order = Sk.ffi.remapToJs(orderPy);\n              quaternion[METHOD_SET_FROM_EULER](vector, order);\n              return quaternionPy;\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_SET_FROM_EULER);\n            });\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_SET_FROM_EULER);\n            });\n          }, METHOD_SET_FROM_EULER, []));\n        }\n        case METHOD_SET: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_SET;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, x, y, z, w) {\n              quaternion.x = Sk.ffi.remapToJs(x);\n              quaternion.y = Sk.ffi.remapToJs(y);\n              quaternion.z = Sk.ffi.remapToJs(z);\n              quaternion.w = Sk.ffi.remapToJs(w);\n              return quaternionPy;\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_SET);\n            });\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_SET);\n            });\n          }, METHOD_SET, []));\n        }\n        case METHOD_CLONE: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_CLONE;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self) {\n              return wxyzToPy(quaternion.w, quaternion.x, quaternion.y, quaternion.z);\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_CLONE);\n            });\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_CLONE);\n            });\n          }, METHOD_CLONE, []));\n        }\n        case METHOD_CONJUGATE: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_CONJUGATE;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self) {\n              quaternion[METHOD_CONJUGATE]();\n              return quaternionPy;\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_CONJUGATE);\n            });\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_CONJUGATE);\n            });\n          }, METHOD_CONJUGATE, []));\n        }\n        case METHOD_INVERSE: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_INVERSE;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self) {\n              var k = 1.0 / quaternion.lengthSq();\n              quaternion[METHOD_CONJUGATE]();\n              quaternion.w *= k;\n              quaternion.x *= k;\n              quaternion.y *= k;\n              quaternion.z *= k;\n              return quaternionPy;\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_INVERSE);\n            });\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_INVERSE);\n            });\n          }, METHOD_INVERSE, []));\n        }\n        case METHOD_LENGTH: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_LENGTH;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self) {\n              return Sk.builtin.assk$(quaternion[METHOD_LENGTH](), Sk.builtin.nmber.float$);\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_LENGTH);\n            });\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_LENGTH);\n            });\n          }, METHOD_LENGTH, []));\n        }\n        case METHOD_LENGTH_SQ: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_LENGTH_SQ;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self) {\n              return Sk.builtin.assk$(quaternion[METHOD_LENGTH_SQ](), Sk.builtin.nmber.float$);\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_LENGTH_SQ);\n            });\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_LENGTH_SQ);\n            });\n          }, METHOD_LENGTH_SQ, []));\n        }\n        case METHOD_NORMALIZE: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_NORMALIZE;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self) {\n              quaternion[METHOD_NORMALIZE]();\n              return quaternionPy;\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_NORMALIZE);\n            });\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_NORMALIZE);\n            });\n          }, METHOD_NORMALIZE, []));\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(quaternionPy, name, valuePy) {\n      var quaternion = Sk.ffi.remapToJs(quaternionPy);\n      var value = Sk.ffi.remapToJs(valuePy);\n      switch(name) {\n        case PROP_X: {\n          quaternion.x = value;\n        }\n        break;\n        case PROP_Y: {\n          quaternion.y = value;\n        }\n        break;\n        case PROP_Z: {\n          quaternion.z = value;\n        }\n        break;\n        case PROP_W: {\n          quaternion.w = value;\n        }\n        break;\n        default: {\n          throw new Sk.builtin.AttributeError(name + " is not an attribute of " + QUATERNION);\n        }\n      }\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(quaternionPy) {\n      var quaternion = Sk.ffi.remapToJs(quaternionPy);\n      var args = [quaternion.x, quaternion.y, quaternion.z, quaternion.w];\n      return new Sk.builtin.str(QUATERNION + "(" + args.join(", ") + ")");\n    });\n    $loc.__str__ = new Sk.builtin.func(function(quaternionPy) {\n      var quaternion = Sk.ffi.remapToJs(quaternionPy);\n      if (isDefined(quaternion)) {\n        return new Sk.builtin.str(stringFromCoordinates([quaternion.w, quaternion.x, quaternion.y, quaternion.z], ["1", "i", "j", "k"]));\n      }\n      else {\n        return new Sk.builtin.str("<type \'" + QUATERNION + "\'>");\n      }\n    });\n  }, QUATERNION, []);\n\n  // Erik Moller\'s requestAnimationFrame for smart(er) animating\n  // Minor formatting changes and use of braces for if conditions.\n  // http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating\n  // The purpose of this enhanced shim is to \n  (function(scope) {\n    if (isDefined(scope)) {\n      var lastTime = 0;\n      var vendors = [\'ms\', \'moz\', \'webkit\', \'o\'];\n      for(var x = 0; x < vendors.length && !scope.requestAnimationFrame; ++x) {\n        scope.requestAnimationFrame = scope[vendors[x]+\'RequestAnimationFrame\'];\n        scope.cancelRequestAnimationFrame = scope[vendors[x]+\'CancelRequestAnimationFrame\'];\n      }\n\n      if (!scope.requestAnimationFrame) {\n        scope.requestAnimationFrame = function(callback, element) {\n          var currTime = new Date().getTime();\n          var timeToCall = Math.max(0, 16 - (currTime - lastTime));\n          var id = scope.setTimeout(function() { callback(currTime + timeToCall); }, timeToCall);\n          lastTime = currTime + timeToCall;\n          return id;\n        };\n      }\n\n      if (!scope.cancelAnimationFrame) {\n        scope.cancelAnimationFrame = function(id) {\n          clearTimeout(id);\n        };\n      }\n    }\n  }((typeof window === \'object\') ? window : void 0));\n\n   mod[SCENE] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self) {\n      self.v = new THREE[SCENE]();\n      self.tp$name = SCENE;\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(scenePy, name) {\n      var scene = Sk.ffi.remapToJs(scenePy);\n      switch(name) {\n        case PROP_POSITION: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(scene[PROP_POSITION], EUCLIDEAN_3));\n        }\n        case PROP_QUATERNION: {\n          return Sk.misceval.callsim(mod[QUATERNION], Sk.ffi.referenceToPy(scene[PROP_QUATERNION], QUATERNION));\n        }\n        case PROP_ROTATION: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(scene[PROP_ROTATION], EUCLIDEAN_3));\n        }\n        case PROP_EULER_ORDER: {\n          return new Sk.builtin.str(scene[PROP_EULER_ORDER]);\n        }\n        case PROP_SCALE: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(scene[PROP_SCALE], EUCLIDEAN_3));\n        }\n        case PROP_UP: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(scene[PROP_UP], EUCLIDEAN_3));\n        }\n        case PROP_USE_QUATERNION: {\n          return scene[PROP_USE_QUATERNION];\n        }\n        case METHOD_LOOK_AT: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_LOOK_AT;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, vectorPy) {\n              scene.lookAt(Sk.ffi.remapToJs(vectorPy));\n              return scenePy;\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_LOOK_AT);\n            })\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_LOOK_AT);\n            })\n          }, METHOD_LOOK_AT, []));\n        }\n        case METHOD_ADD: {\n          return methodAdd(scene);\n        }\n        case METHOD_REMOVE: {\n          return methodRemove(scene);\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(scenePy, name, valuePy) {\n      var scene = Sk.ffi.remapToJs(scenePy);\n      var value = Sk.ffi.remapToJs(valuePy);\n      switch(name) {\n        case PROP_POSITION: {\n          scene[PROP_POSITION] = value;\n        }\n        break;\n        case PROP_QUATERNION: {\n          scene[PROP_QUATERNION] = value;\n        }\n        break;\n        case PROP_ROTATION: {\n          scene[PROP_ROTATION] = value;\n        }\n        break;\n        case PROP_EULER_ORDER: {\n          if (isString(value)) {\n            scene[PROP_EULER_ORDER] = value;\n          }\n          else {\n            throw new Error(name + " must be a string");\n          }\n        }\n        break;\n        case PROP_SCALE: {\n          scene[PROP_SCALE] = value;\n        }\n        break;\n        case PROP_UP: {\n          scene[PROP_UP] = value;\n        }\n        break;\n        case PROP_USE_QUATERNION: {\n          scene[PROP_USE_QUATERNION] = value;\n        }\n        break;\n        default: {\n          throw new Error(name + " is not a write attribute of " + SCENE);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(self) {\n      return new Sk.builtin.str(SCENE);\n    });\n  }, SCENE, []);\n\n  mod[CANVAS_RENDERER] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    var PROP_AUTO_CLEAR   = "autoClear";\n    var PROP_CLEAR_COLOR  = "clearColor";\n    var PROP_DOM_ELEMENT  = "domElement";\n    var PROP_GAMMA_INPUT  = "gammaInput";\n    var PROP_GAMMA_OUTPUT = "gammaOutput";\n    var PROP_SORT_OBJECTS = "sortObjects";\n    $loc.__init__ = new Sk.builtin.func(function(self, parameters) {\n      self.tp$name = CANVAS_RENDERER;\n      parameters = Sk.ffi.remapToJs(parameters);\n      self.v = new THREE[CANVAS_RENDERER](parameters);\n    });\n    $loc.setSize = new Sk.builtin.func(function(self, width, height) {\n      self.v.setSize(Sk.builtin.asnum$(width), Sk.builtin.asnum$(height));\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(self, name) {\n      var METHOD_RENDER = "render";\n      var METHOD_GET_CLEAR_COLOR = "getClearColor";\n      var METHOD_SET_CLEAR_COLOR = "setClearColor";\n      var METHOD_SET_SIZE        = "setSize";\n      var renderer  = Sk.ffi.remapToJs(self);\n      switch(name) {\n        case PROP_AUTO_CLEAR: {\n          return renderer[PROP_AUTO_CLEAR];\n        }\n        case PROP_GAMMA_INPUT: {\n          return renderer[PROP_GAMMA_INPUT];\n        }\n        case PROP_GAMMA_OUTPUT: {\n          return renderer[PROP_GAMMA_OUTPUT];\n        }\n        case PROP_SORT_OBJECTS: {\n          return renderer[PROP_SORT_OBJECTS];\n        }\n        case PROP_DOM_ELEMENT: {\n          // TODO: I think duck-typing means that this will work as long as we don\'t\n          // try to do anything more ambitious.\n          return {v: renderer.domElement};\n        }\n        case METHOD_RENDER: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_RENDER;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, scene, camera) {\n              scene  = Sk.ffi.remapToJs(scene);\n              camera = Sk.ffi.remapToJs(camera);\n              renderer.render(scene, camera);\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_RENDER);\n            })\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_RENDER);\n            })\n          }, METHOD_RENDER, []));\n        }\n        case METHOD_GET_CLEAR_COLOR: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_GET_CLEAR_COLOR;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self) {\n              return Sk.misceval.callsim(mod[COLOR], Sk.ffi.referenceToPy(renderer.getClearColor(), COLOR));\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_GET_CLEAR_COLOR);\n            });\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_GET_CLEAR_COLOR);\n            });\n          }, METHOD_GET_CLEAR_COLOR, []));\n        }\n        case METHOD_SET_CLEAR_COLOR: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_SET_CLEAR_COLOR;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, color, alpha) {\n              color  = Sk.ffi.remapToJs(color);\n              alpha = Sk.ffi.remapToJs(alpha);\n              renderer.setClearColor(color, alpha);\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_SET_CLEAR_COLOR);\n            });\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_SET_CLEAR_COLOR);\n            });\n          }, METHOD_SET_CLEAR_COLOR, []));\n        }\n        case METHOD_SET_SIZE: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_SET_SIZE;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, width, height, updateStyle) {\n              width  = Sk.ffi.remapToJs(width);\n              height = Sk.ffi.remapToJs(height);\n              updateStyle = Sk.ffi.remapToJs(updateStyle);\n              renderer.setSize(width, height, updateStyle);\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_SET_SIZE);\n            });\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_SET_SIZE);\n            });\n          }, METHOD_SET_SIZE, []));\n        }\n        default: {\n          // The framework will raise an AttributeError exception.\n          return /* undefined */;\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(self, name, value) {\n      var renderer  = Sk.ffi.remapToJs(self);\n      value = Sk.ffi.remapToJs(value);\n      switch(name) {\n        case PROP_AUTO_CLEAR: {\n          if (isBoolean(value)) {\n            renderer[PROP_AUTO_CLEAR] = value;\n          }\n          else {\n            throw new Sk.builtin.TypeError("\'" + PROP_AUTO_CLEAR + "\' attribute must be a <type \'bool\'>.");\n          }\n        }\n        break;\n        case PROP_GAMMA_INPUT: {\n          if (isBoolean(value)) {\n            renderer[PROP_GAMMA_INPUT] = value;\n          }\n          else {\n            throw new Sk.builtin.TypeError("\'" + PROP_GAMMA_INPUT + "\' attribute must be a <type \'bool\'>.");\n          }\n        }\n        break;\n        case PROP_GAMMA_OUTPUT: {\n          if (isBoolean(value)) {\n            renderer[PROP_GAMMA_OUTPUT] = value;\n          }\n          else {\n            throw new Sk.builtin.TypeError("\'" + PROP_GAMMA_OUTPUT + "\' attribute must be a <type \'bool\'>.");\n          }\n        }\n        break;\n        case PROP_SORT_OBJECTS: {\n          if (isBoolean(value)) {\n            renderer[PROP_SORT_OBJECTS] = value;\n          }\n          else {\n            throw new Sk.builtin.TypeError("\'" + PROP_SORT_OBJECTS + "\' attribute must be a <type \'bool\'>.");\n          }\n        }\n        break;\n        case "size": {\n          var width  = Sk.builtin.asnum$(value[0]);\n          var height = Sk.builtin.asnum$(value[1]);\n          renderer.setSize(width, height);\n        }\n        break;\n        default: {\n          throw new Error(name + " is not an attribute of " + CANVAS_RENDERER);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(self) {\n      var renderer = self.v;\n      var args = {};\n      args[PROP_AUTO_CLEAR] = renderer[PROP_AUTO_CLEAR];\n      args[PROP_GAMMA_INPUT] = renderer[PROP_GAMMA_INPUT];\n      args[PROP_GAMMA_OUTPUT] = renderer[PROP_GAMMA_OUTPUT];\n      return new Sk.builtin.str(CANVAS_RENDERER + "(" + JSON.stringify(args) + ")");\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(self) {\n      var renderer = self.v;\n      var autoClear = renderer[PROP_AUTO_CLEAR];\n      // Note: The WebGLRenderer takes only one argument, but it is a dictionary.\n      var args = [{"autoClear": autoClear}];\n      return new Sk.builtin.str(CANVAS_RENDERER + "(" + args.map(function(x) {return JSON.stringify(x);}).join(", ") + ")");\n    });\n  }, CANVAS_RENDERER, []);\n\n  mod[WEBGL_RENDERER] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    var PROP_AUTO_CLEAR   = "autoClear";\n    var PROP_CLEAR_COLOR  = "clearColor";\n    var PROP_DOM_ELEMENT  = "domElement";\n    var PROP_GAMMA_INPUT  = "gammaInput";\n    var PROP_GAMMA_OUTPUT = "gammaOutput";\n    var PROP_SORT_OBJECTS = "sortObjects";\n    $loc.__init__ = new Sk.builtin.func(function(self, parameters) {\n      self.tp$name = WEBGL_RENDERER;\n      parameters = Sk.ffi.remapToJs(parameters);\n      self.v = new THREE[WEBGL_RENDERER](parameters);\n    });\n    $loc.setSize = new Sk.builtin.func(function(self, width, height) {\n      self.v.setSize(Sk.builtin.asnum$(width), Sk.builtin.asnum$(height));\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(self, name) {\n      var METHOD_RENDER = "render";\n      var METHOD_GET_CLEAR_COLOR = "getClearColor";\n      var METHOD_SET_CLEAR_COLOR = "setClearColor";\n      var METHOD_SET_SIZE        = "setSize";\n      var renderer  = Sk.ffi.remapToJs(self);\n      switch(name) {\n        case PROP_AUTO_CLEAR: {\n          return renderer[PROP_AUTO_CLEAR];\n        }\n        case PROP_GAMMA_INPUT: {\n          return renderer[PROP_GAMMA_INPUT];\n        }\n        case PROP_GAMMA_OUTPUT: {\n          return renderer[PROP_GAMMA_OUTPUT];\n        }\n        case PROP_SORT_OBJECTS: {\n          return renderer[PROP_SORT_OBJECTS];\n        }\n        case PROP_DOM_ELEMENT: {\n          // TODO: I think duck-typing means that this will work as long as we don\'t\n          // try to do anything more ambitious.\n          return {v: renderer.domElement};\n        }\n        case METHOD_RENDER: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_RENDER;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, scene, camera) {\n              scene  = Sk.ffi.remapToJs(scene);\n              camera = Sk.ffi.remapToJs(camera);\n              renderer.render(scene, camera);\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_RENDER);\n            })\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_RENDER);\n            })\n          }, METHOD_RENDER, []));\n        }\n        case METHOD_GET_CLEAR_COLOR: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_GET_CLEAR_COLOR;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self) {\n              return Sk.misceval.callsim(mod[COLOR], Sk.ffi.referenceToPy(renderer.getClearColor(), COLOR));\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_GET_CLEAR_COLOR);\n            });\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_GET_CLEAR_COLOR);\n            });\n          }, METHOD_GET_CLEAR_COLOR, []));\n        }\n        case METHOD_SET_CLEAR_COLOR: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_SET_CLEAR_COLOR;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, color, alpha) {\n              color  = Sk.ffi.remapToJs(color);\n              alpha = Sk.ffi.remapToJs(alpha);\n              renderer.setClearColor(color, alpha);\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_SET_CLEAR_COLOR);\n            });\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_SET_CLEAR_COLOR);\n            });\n          }, METHOD_SET_CLEAR_COLOR, []));\n        }\n        case METHOD_SET_SIZE: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_SET_SIZE;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, width, height, updateStyle) {\n              width  = Sk.ffi.remapToJs(width);\n              height = Sk.ffi.remapToJs(height);\n              updateStyle = Sk.ffi.remapToJs(updateStyle);\n              renderer.setSize(width, height, updateStyle);\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_SET_SIZE);\n            });\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_SET_SIZE);\n            });\n          }, METHOD_SET_SIZE, []));\n        }\n        default: {\n          // The framework will raise an AttributeError exception.\n          return /* undefined */;\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(self, name, value) {\n      var renderer  = Sk.ffi.remapToJs(self);\n      value = Sk.ffi.remapToJs(value);\n      switch(name) {\n        case PROP_AUTO_CLEAR: {\n          if (isBoolean(value)) {\n            renderer[PROP_AUTO_CLEAR] = value;\n          }\n          else {\n            throw new Sk.builtin.TypeError("\'" + PROP_AUTO_CLEAR + "\' attribute must be a <type \'bool\'>.");\n          }\n        }\n        break;\n        case PROP_GAMMA_INPUT: {\n          if (isBoolean(value)) {\n            renderer[PROP_GAMMA_INPUT] = value;\n          }\n          else {\n            throw new Sk.builtin.TypeError("\'" + PROP_GAMMA_INPUT + "\' attribute must be a <type \'bool\'>.");\n          }\n        }\n        break;\n        case PROP_GAMMA_OUTPUT: {\n          if (isBoolean(value)) {\n            renderer[PROP_GAMMA_OUTPUT] = value;\n          }\n          else {\n            throw new Sk.builtin.TypeError("\'" + PROP_GAMMA_OUTPUT + "\' attribute must be a <type \'bool\'>.");\n          }\n        }\n        break;\n        case PROP_SORT_OBJECTS: {\n          if (isBoolean(value)) {\n            renderer[PROP_SORT_OBJECTS] = value;\n          }\n          else {\n            throw new Sk.builtin.TypeError("\'" + PROP_SORT_OBJECTS + "\' attribute must be a <type \'bool\'>.");\n          }\n        }\n        break;\n        case "size": {\n          var width  = Sk.builtin.asnum$(value[0]);\n          var height = Sk.builtin.asnum$(value[1]);\n          renderer.setSize(width, height);\n        }\n        break;\n        default: {\n          throw new Error(name + " is not an attribute of " + WEBGL_RENDERER);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(self) {\n      var renderer = self.v;\n      var args = {};\n      args[PROP_AUTO_CLEAR] = renderer[PROP_AUTO_CLEAR];\n      args[PROP_GAMMA_INPUT] = renderer[PROP_GAMMA_INPUT];\n      args[PROP_GAMMA_OUTPUT] = renderer[PROP_GAMMA_OUTPUT];\n      return new Sk.builtin.str(WEBGL_RENDERER + "(" + JSON.stringify(args) + ")");\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(self) {\n      var renderer = self.v;\n      var autoClear = renderer[PROP_AUTO_CLEAR];\n      // Note: The WebGLRenderer takes only one argument, but it is a dictionary.\n      var args = [{"autoClear": autoClear}];\n      return new Sk.builtin.str(WEBGL_RENDERER + "(" + args.map(function(x) {return JSON.stringify(x);}).join(", ") + ")");\n    });\n  }, WEBGL_RENDERER, []);\n\n  mod[COLOR] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    var PROP_R = "r";\n    var PROP_G = "g";\n    var PROP_B = "b";\n    $loc.__init__ = new Sk.builtin.func(function(self, value) {\n      value = Sk.ffi.remapToJs(value);\n      self.tp$name = COLOR;\n      if (isUndefined(value)) {\n        self.v = new THREE.Color();\n      }\n      else {\n        if (isNumber(value) || isString(value)) {\n          self.v = new THREE.Color(value);\n        }\n        else if (isColor(value)) {\n          self.v = new THREE.Color(value);\n        }\n        else {\n          throw new Sk.builtin.AssertionError("value must be either a number, string or Color.");\n        }\n      }\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(colorPy, name) {\n      var color = Sk.ffi.remapToJs(colorPy);\n      switch(name) {\n        case PROP_R: {\n          return Sk.builtin.assk$(color[PROP_R], Sk.builtin.nmber.float$);\n        }\n        case PROP_G: {\n          return Sk.builtin.assk$(color[PROP_G], Sk.builtin.nmber.float$);\n        }\n        case PROP_B: {\n          return Sk.builtin.assk$(color[PROP_B], Sk.builtin.nmber.float$);\n        }\n        case METHOD_SET_RGB: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_SET_RGB;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, rPy, gPy, bPy) {\n              var r  = Sk.ffi.remapToJs(rPy);\n              var g  = Sk.ffi.remapToJs(gPy);\n              var b  = Sk.ffi.remapToJs(bPy);\n              color.setRGB(r, g, b);\n              return colorPy;\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_SET_RGB);\n            });\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_SET_RGB);\n            });\n          }, METHOD_SET_RGB, []));\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(colorPy, name, valuePy) {\n      var color = Sk.ffi.remapToJs(colorPy);\n      var value = Sk.ffi.remapToJs(valuePy);\n      switch(name) {\n        case PROP_R: {\n          color[PROP_R] = value;\n        }\n        break;\n        case PROP_G: {\n          color[PROP_G] = value;\n        }\n        break;\n        case PROP_B: {\n          color[PROP_B] = value;\n        }\n        break;\n        default: {\n          throw new Sk.builtin.AttributeError(name + " is not an attribute of " + COLOR);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(self) {\n      var color = self.v;\n      var args = {};\n      args[PROP_R] = color[PROP_R];\n      args[PROP_G] = color[PROP_G];\n      args[PROP_B] = color[PROP_B];\n      return new Sk.builtin.str(COLOR + "(" + JSON.stringify(args) + ")");\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(self) {\n      var color = self.v;\n      var r = color[PROP_R];\n      var g = color[PROP_G];\n      var b = color[PROP_B];\n      var args = [r, g, b];\n      return new Sk.builtin.str(COLOR + "(" + args.map(function(x) {return JSON.stringify(x);}).join(", ") + ")");\n    });\n  }, COLOR, []);\n\n  mod[PERSPECTIVE_CAMERA] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self, fov, aspect, near, far) {\n      var fieldOfView = Sk.builtin.asnum$(fov)\n      var aspectRatio = Sk.builtin.asnum$(aspect)\n      var nearPlane = Sk.builtin.asnum$(near)\n      var farPlane = Sk.builtin.asnum$(far)\n      self.v = new THREE[PERSPECTIVE_CAMERA](fieldOfView, aspectRatio, nearPlane, farPlane);\n      self.tp$name = PERSPECTIVE_CAMERA;\n    });\n\n    $loc.__getattr__ = new Sk.builtin.func(function(cameraPy, name) {\n      camera = Sk.ffi.remapToJs(cameraPy);\n      var UPDATE_PROJECTION_MATRIX = "updateProjectionMatrix"\n      switch(name) {\n        case "aspect": {\n          return Sk.builtin.assk$(camera.aspect, Sk.builtin.nmber.float$);\n        }\n        case PROP_POSITION: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(camera[PROP_POSITION], EUCLIDEAN_3));\n        }\n        case PROP_QUATERNION: {\n          return Sk.misceval.callsim(mod[QUATERNION], Sk.ffi.referenceToPy(camera[PROP_QUATERNION], QUATERNION));\n        }\n        case PROP_ROTATION: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(camera[PROP_ROTATION], EUCLIDEAN_3));\n        }\n        case PROP_EULER_ORDER: {\n          return new Sk.builtin.str(camera[PROP_EULER_ORDER]);\n        }\n        case PROP_SCALE: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(camera[PROP_SCALE], EUCLIDEAN_3));\n        }\n        case PROP_UP: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(camera[PROP_UP], EUCLIDEAN_3));\n        }\n        case PROP_USE_QUATERNION: {\n          return camera[PROP_USE_QUATERNION];\n        }\n        case METHOD_LOOK_AT: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_LOOK_AT;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, vectorPy) {\n              camera.lookAt(Sk.ffi.remapToJs(vectorPy));\n              return cameraPy;\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_LOOK_AT);\n            })\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_LOOK_AT);\n            })\n          }, METHOD_LOOK_AT, []));\n        }\n        case UPDATE_PROJECTION_MATRIX: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = UPDATE_PROJECTION_MATRIX;\n            });\n\n            $loc.__call__ = new Sk.builtin.func(function(self) {\n              camera[name]();\n            });\n\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(UPDATE_PROJECTION_MATRIX)\n            })\n\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(UPDATE_PROJECTION_MATRIX)\n            })\n\n          }, UPDATE_PROJECTION_MATRIX, []));\n        }\n        default: {\n          return;\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(cameraPy, name, valuePy) {\n      var camera = Sk.ffi.remapToJs(cameraPy);\n      var value = Sk.ffi.remapToJs(valuePy);\n      switch(name) {\n        case "aspect": {\n          camera.aspect = value;\n        }\n        break;\n        case PROP_POSITION: {\n          camera[PROP_POSITION] = value;\n        }\n        break;\n        case PROP_QUATERNION: {\n          camera[PROP_QUATERNION] = value;\n        }\n        break;\n        case PROP_ROTATION: {\n          camera[PROP_ROTATION] = value;\n        }\n        break;\n        case PROP_EULER_ORDER: {\n          if (isString(value)) {\n            camera[PROP_EULER_ORDER] = value;\n          }\n          else {\n            throw new Error(name + " must be a string");\n          }\n        }\n        break;\n        case PROP_SCALE: {\n          camera[PROP_SCALE] = value;\n        }\n        break;\n        case PROP_UP: {\n          camera[PROP_UP] = value;\n        }\n        break;\n        case PROP_USE_QUATERNION: {\n          camera[PROP_USE_QUATERNION] = value;\n        }\n        break;\n        default: {\n          throw new Sk.builtin.AssertionError(name + " is not an attribute of " + PERSPECTIVE_CAMERA);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(self) {\n      return new Sk.builtin.str(PERSPECTIVE_CAMERA);\n    });\n  }, PERSPECTIVE_CAMERA, []);\n\n  mod[ORTHOGRAPHIC_CAMERA] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self, leftPy, rightPy, topPy, bottomPy, nearPy, farPy) {\n      var left = Sk.builtin.asnum$(leftPy)\n      var right = Sk.builtin.asnum$(rightPy)\n      var top = Sk.builtin.asnum$(topPy)\n      var bottom = Sk.builtin.asnum$(bottomPy)\n      var near = Sk.builtin.asnum$(nearPy)\n      var far = Sk.builtin.asnum$(farPy)\n      self.v = new THREE[ORTHOGRAPHIC_CAMERA](left, right, top, bottom, near, far);\n      self.tp$name = ORTHOGRAPHIC_CAMERA;\n    });\n\n    $loc.__getattr__ = new Sk.builtin.func(function(cameraPy, name) {\n      camera = Sk.ffi.remapToJs(cameraPy);\n      var UPDATE_PROJECTION_MATRIX = "updateProjectionMatrix"\n      switch(name) {\n        case "aspect": {\n          return Sk.builtin.assk$(camera.aspect, Sk.builtin.nmber.float$);\n        }\n        case PROP_POSITION: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(camera[PROP_POSITION], EUCLIDEAN_3));\n        }\n        case PROP_QUATERNION: {\n          return Sk.misceval.callsim(mod[QUATERNION], Sk.ffi.referenceToPy(camera[PROP_QUATERNION], QUATERNION));\n        }\n        case PROP_ROTATION: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(camera[PROP_ROTATION], EUCLIDEAN_3));\n        }\n        case PROP_EULER_ORDER: {\n          return new Sk.builtin.str(camera[PROP_EULER_ORDER]);\n        }\n        case PROP_SCALE: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(camera[PROP_SCALE], EUCLIDEAN_3));\n        }\n        case PROP_UP: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(camera[PROP_UP], EUCLIDEAN_3));\n        }\n        case PROP_USE_QUATERNION: {\n          return camera[PROP_USE_QUATERNION];\n        }\n        case METHOD_LOOK_AT: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_LOOK_AT;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, vectorPy) {\n              camera.lookAt(Sk.ffi.remapToJs(vectorPy));\n              return cameraPy;\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_LOOK_AT);\n            })\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_LOOK_AT);\n            })\n          }, METHOD_LOOK_AT, []));\n        }\n        case UPDATE_PROJECTION_MATRIX: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = UPDATE_PROJECTION_MATRIX;\n            });\n\n            $loc.__call__ = new Sk.builtin.func(function(self) {\n              camera[name]();\n            });\n\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(UPDATE_PROJECTION_MATRIX)\n            })\n\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(UPDATE_PROJECTION_MATRIX)\n            })\n\n          }, UPDATE_PROJECTION_MATRIX, []));\n        }\n        default: {\n          return;\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(cameraPy, name, valuePy) {\n      var camera = Sk.ffi.remapToJs(cameraPy);\n      var value = Sk.ffi.remapToJs(valuePy);\n      switch(name) {\n        case PROP_LEFT: {\n          camera[PROP_LEFT] = value;\n        }\n        break;\n        case PROP_RIGHT: {\n          camera[PROP_RIGHT] = value;\n        }\n        break;\n        case PROP_TOP: {\n          camera[PROP_TOP] = value;\n        }\n        break;\n        case PROP_BOTTOM: {\n          camera[PROP_BOTTOM] = value;\n        }\n        break;\n        case PROP_POSITION: {\n          camera[PROP_POSITION] = value;\n        }\n        break;\n        case PROP_QUATERNION: {\n          camera[PROP_QUATERNION] = value;\n        }\n        break;\n        case PROP_ROTATION: {\n          camera[PROP_ROTATION] = value;\n        }\n        break;\n        case PROP_EULER_ORDER: {\n          if (isString(value)) {\n            camera[PROP_EULER_ORDER] = value;\n          }\n          else {\n            throw new Error(name + " must be a string");\n          }\n        }\n        break;\n        case PROP_SCALE: {\n          camera[PROP_SCALE] = value;\n        }\n        break;\n        case PROP_UP: {\n          camera[PROP_UP] = value;\n        }\n        break;\n        case PROP_USE_QUATERNION: {\n          camera[PROP_USE_QUATERNION] = value;\n        }\n        break;\n        default: {\n          throw new Sk.builtin.AssertionError(name + " is not an attribute of " + ORTHOGRAPHIC_CAMERA);\n        }\n      }\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(cameraPy) {\n      var camera = Sk.ffi.remapToJs(cameraPy);\n      var args = [camera[PROP_LEFT], camera[PROP_RIGHT], camera[PROP_TOP], camera[PROP_BOTTOM], camera[PROP_NEAR], camera[PROP_FAR]];\n      return new Sk.builtin.str(ORTHOGRAPHIC_CAMERA + "(" + args.map(function(x) {return JSON.stringify(x);}).join(", ") + ")");\n    });\n    $loc.__str__ = new Sk.builtin.func(function(self) {\n      return new Sk.builtin.str(ORTHOGRAPHIC_CAMERA);\n    });\n  }, ORTHOGRAPHIC_CAMERA, []);\n\n  mod[ARROW_GEOMETRY] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self, length, segments, radiusShaft, radiusCone, lengthCone) {\n      length = Sk.ffi.remapToJs(length) || 1;\n      segments = Sk.ffi.remapToJs(segments);\n      radiusShaft = Sk.ffi.remapToJs(radiusShaft) || 0.01;\n      radiusCone = Sk.ffi.remapToJs(radiusCone) || 0.08;\n      lengthCone = Sk.ffi.remapToJs(lengthCone) || 0.2;\n      var lengthShaft = 1 - lengthCone;\n      var a = new THREE.Vector3(0, 0, length);\n      var b = new THREE.Vector3(radiusCone, 0, lengthShaft);\n      var c = new THREE.Vector3(radiusShaft, 0, lengthShaft);\n      var d = new THREE.Vector3(radiusShaft, 0, 0);\n      var e = new THREE.Vector3(0, 0, 0);\n      var points = [a, b, c, d, e];\n      self.v = new THREE.LatheGeometry(points, segments);\n      self.tp$name = ARROW_GEOMETRY;\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(geometryPy, name) {\n      var geometry = Sk.ffi.remapToJs(geometryPy);\n      switch(name) {\n        case PROP_ID: {\n          return Sk.builtin.nmber(geometry[PROP_ID], Sk.builtin.nmber.int$);\n        }\n        case PROP_NAME: {\n          return new Sk.builtin.str(geometry[PROP_NAME]);\n        }\n        case PROP_VERTICES: {\n          return verticesPy(geometry.vertices);\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(geometryPy, name, valuePy) {\n      var geometry = Sk.ffi.remapToJs(geometryPy);\n      var value = Sk.ffi.remapToJs(valuePy);\n      switch(name) {\n        case PROP_NAME: {\n          if (isString(value)) {\n            geometry[PROP_NAME] = value;\n          }\n          else {\n            throw new Error(name + " must be a string");\n          }\n        }\n        break;\n        default: {\n          throw new Error(name + " is not an attribute of " + ARROW_GEOMETRY);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(self) {\n      var geometry = Sk.ffi.remapToJs(self);\n      var args = {};\n      return new Sk.builtin.str(ARROW_GEOMETRY + "(" + JSON.stringify(args) + ")");\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(self) {\n      var geometry = Sk.ffi.remapToJs(self);\n      var args = [];\n      return new Sk.builtin.str(ARROW_GEOMETRY + "(" + args.map(function(x) {return JSON.stringify(x);}).join(", ") + ")");\n    });\n  }, ARROW_GEOMETRY, []);\n\n   mod[CIRCLE_GEOMETRY] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self, radius, segments, thetaStart, thetaLength) {\n      radius      = numberFromArg(radius,          PROP_RADIUS,       CIRCLE_GEOMETRY);\n      segments    = numberFromIntegerArg(segments, PROP_SEGMENTS,     CIRCLE_GEOMETRY);\n      thetaStart  = numberFromArg(thetaStart,      PROP_THETA_START,  CIRCLE_GEOMETRY);\n      thetaLength = numberFromArg(thetaLength,     PROP_THETA_LENGTH, CIRCLE_GEOMETRY);\n      self.v = new THREE[CIRCLE_GEOMETRY](radius, segments, thetaStart, thetaLength);\n      self.tp$name = CIRCLE_GEOMETRY;\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(self, name) {\n      switch(name) {\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(geometryPy, name, valuePy) {\n      var geometry = Sk.ffi.remapToJs(geometryPy);\n      var value = Sk.ffi.remapToJs(valuePy);\n      switch(name) {\n        default: {\n          throw new Error(name + " is not an attribute of " + CIRCLE_GEOMETRY);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(self) {\n      var sphere = self.v;\n      var args = {};\n      return new Sk.builtin.str(CIRCLE_GEOMETRY + "(" + JSON.stringify(args) + ")");\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(self) {\n      var sphere = self.v;\n      var args = [];\n      return new Sk.builtin.str(CIRCLE_GEOMETRY + "(" + args.map(function(x) {return JSON.stringify(x);}).join(", ") + ")");\n    });\n  }, CIRCLE_GEOMETRY, []);\n\n   mod[CUBE_GEOMETRY] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    var PROP_WIDTH           = "width";\n    var PROP_HEIGHT          = "height";\n    var PROP_DEPTH           = "depth";\n    var PROP_WIDTH_SEGMENTS  = "widthSegments";\n    var PROP_HEIGHT_SEGMENTS = "heightSegments";\n    var PROP_DEPTH_SEGMENTS  = "depthSegments";\n    $loc.__init__ = new Sk.builtin.func(function(self, width, height, depth, widthSegments, heightSegments, depthSegments) {\n      width          = numberFromArg(width,                 PROP_WIDTH,           CUBE_GEOMETRY);\n      height         = numberFromArg(height,                PROP_HEIGHT,          CUBE_GEOMETRY);\n      depth          = numberFromArg(depth,                 PROP_DEPTH,           CUBE_GEOMETRY);\n      widthSegments  = numberFromIntegerArg(widthSegments,  PROP_WIDTH_SEGMENTS,  CUBE_GEOMETRY);\n      heightSegments = numberFromIntegerArg(heightSegments, PROP_HEIGHT_SEGMENTS, CUBE_GEOMETRY);\n      depthSegments  = numberFromIntegerArg(depthSegments,  PROP_DEPTH_SEGMENTS,  CUBE_GEOMETRY);\n      self.v = new THREE[CUBE_GEOMETRY](width, height, depth, widthSegments, heightSegments, depthSegments);\n      self.tp$name = CUBE_GEOMETRY;\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(self, name) {\n      switch(name) {\n        case PROP_WIDTH: {\n          return Sk.builtin.assk$(self.v[PROP_WIDTH], Sk.builtin.nmber.float$);\n        }\n        case PROP_HEIGHT: {\n          return Sk.builtin.assk$(self.v[PROP_HEIGHT], Sk.builtin.nmber.float$);\n        }\n        case PROP_DEPTH: {\n          return Sk.builtin.assk$(self.v[PROP_DEPTH], Sk.builtin.nmber.float$);\n        }\n        case PROP_WIDTH_SEGMENTS: {\n          return Sk.builtin.assk$(self.v[PROP_WIDTH_SEGMENTS], Sk.builtin.nmber.int$);\n        }\n        case PROP_HEIGHT_SEGMENTS: {\n          return Sk.builtin.assk$(self.v[PROP_HEIGHT_SEGMENTS], Sk.builtin.nmber.int$);\n        }\n        case PROP_DEPTH_SEGMENTS: {\n          return Sk.builtin.assk$(self.v[PROP_DEPTH_SEGMENTS], Sk.builtin.nmber.int$);\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(geometryPy, name, valuePy) {\n      var geometry = Sk.ffi.remapToJs(geometryPy);\n      var value = Sk.ffi.remapToJs(valuePy);\n      switch(name) {\n        default: {\n          throw new Error(name + " is not an attribute of " + CUBE_GEOMETRY);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(self) {\n      var cube = self.v;\n      var args = {};\n      args[PROP_WIDTH]  = cube[PROP_WIDTH];\n      args[PROP_HEIGHT] = cube[PROP_HEIGHT];\n      args[PROP_DEPTH]  = cube[PROP_DEPTH];\n      return new Sk.builtin.str(CUBE_GEOMETRY + "(" + JSON.stringify(args) + ")");\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(self) {\n      var cube = self.v;\n      var width          = cube[PROP_WIDTH];\n      var height         = cube[PROP_HEIGHT];\n      var depth          = cube[PROP_DEPTH];\n      var widthSegments  = cube[PROP_WIDTH_SEGMENTS];\n      var heightSegments = cube[PROP_HEIGHT_SEGMENTS];\n      var depthSegments  = cube[PROP_DEPTH_SEGMENTS];\n      var args = [width, height, depth, widthSegments, heightSegments, depthSegments];\n      return new Sk.builtin.str(CUBE_GEOMETRY + "(" + args.map(function(x) {return JSON.stringify(x);}).join(", ") + ")");\n    });\n  }, CUBE_GEOMETRY, []);\n\n  mod[CYLINDER_GEOMETRY] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    var PROP_RADIUS_TOP      = "radiusTop";\n    var PROP_RADIUS_BOTTOM   = "radiusBottom";\n    var PROP_HEIGHT          = "height";\n    var PROP_RADIUS_SEGMENTS = "radiusSegments";\n    var PROP_HEIGHT_SEGMENTS = "heightSegments";\n    var PROP_OPEN_ENDED      = "openEnded";\n    $loc.__init__ = new Sk.builtin.func(function(self, radiusTop, radiusBottom, height, radiusSegments, heightSegments, openEnded) {\n      radiusTop      = numberFromArg(radiusTop,             PROP_RADIUS_TOP,      CYLINDER_GEOMETRY);\n      radiusBottom   = numberFromArg(radiusBottom,          PROP_RADIUS_BOTTOM,   CYLINDER_GEOMETRY);\n      height         = numberFromArg(height,                PROP_HEIGHT,          CYLINDER_GEOMETRY);\n      radiusSegments = numberFromIntegerArg(radiusSegments, PROP_RADIUS_SEGMENTS, CYLINDER_GEOMETRY);\n      heightSegments = numberFromIntegerArg(heightSegments, PROP_HEIGHT_SEGMENTS, CYLINDER_GEOMETRY);\n      openEnded      = Sk.ffi.remapToJs(openEnded);\n      self.v = new THREE[CYLINDER_GEOMETRY](radiusTop, radiusBottom, height, radiusSegments, heightSegments, openEnded);\n      self.tp$name = CYLINDER_GEOMETRY;\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(self, name) {\n      switch(name) {\n        case PROP_RADIUS_TOP: {\n          return Sk.builtin.assk$(self.v[PROP_RADIUS_TOP], Sk.builtin.nmber.float$);\n        }\n        case PROP_RADIUS_BOTTOM: {\n          return Sk.builtin.assk$(self.v[PROP_RADIUS_BOTTOM], Sk.builtin.nmber.float$);\n        }\n        case PROP_HEIGHT: {\n          return Sk.builtin.assk$(self.v[PROP_HEIGHT], Sk.builtin.nmber.float$);\n        }\n        case PROP_RADIUS_SEGMENTS: {\n          return Sk.builtin.assk$(self.v[PROP_RADIUS_SEGMENTS], Sk.builtin.nmber.int$);\n        }\n        case PROP_HEIGHT_SEGMENTS: {\n          return Sk.builtin.assk$(self.v[PROP_HEIGHT_SEGMENTS], Sk.builtin.nmber.int$);\n        }\n        case PROP_OPEN_ENDED: {\n          return self.v[PROP_OPEN_ENDED];\n        }\n        default: {\n          // Framework will take care of the error message.\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(geometryPy, name, valuePy) {\n      var geometry = Sk.ffi.remapToJs(geometryPy);\n      var value = Sk.ffi.remapToJs(valuePy);\n      switch(name) {\n        default: {\n          throw new Error(name + " is not an attribute of " + CYLINDER_GEOMETRY);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(self) {\n      var cylinder = self.v;\n      var args = {};\n      args[PROP_RADIUS_TOP] = cylinder[PROP_RADIUS_TOP];\n      args[PROP_RADIUS_BOTTOM] = cylinder[PROP_RADIUS_BOTTOM];\n      args[PROP_HEIGHT] = cylinder[PROP_HEIGHT];\n      args[PROP_OPEN_ENDED] = cylinder[PROP_OPEN_ENDED];\n      // TODO: Need a Python.stringify because Boolean is {True, False} etc.\n      return new Sk.builtin.str(CYLINDER_GEOMETRY + "(" + JSON.stringify(args) + ")");\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(self) {\n      var cylinder = self.v;\n      var radiusTop      = cylinder[PROP_RADIUS_TOP];\n      var radiusBottom   = cylinder[PROP_RADIUS_BOTTOM];\n      var height         = cylinder[PROP_HEIGHT];\n      var radiusSegments = cylinder[PROP_RADIUS_SEGMENTS];\n      var heightSegments = cylinder[PROP_HEIGHT_SEGMENTS];\n      var openEnded      = cylinder[PROP_OPEN_ENDED];\n      var args = [radiusTop, radiusBottom, height, radiusSegments, heightSegments, openEnded];\n      return new Sk.builtin.str(CYLINDER_GEOMETRY + "(" + args.map(function(x) {return JSON.stringify(x);}).join(", ") + ")");\n    });\n  }, CYLINDER_GEOMETRY, []);\n\n  mod[LATHE_GEOMETRY] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self, pointsPy, segmentsPy, phiStart, phiLength) {\n      var points = Sk.ffi.remapToJs(pointsPy);\n      var segments = Sk.ffi.remapToJs(segmentsPy);\n      phiStart = Sk.ffi.remapToJs(phiStart);\n      phiLength = Sk.ffi.remapToJs(phiLength);\n      self.v = new THREE[LATHE_GEOMETRY](points, segments, phiStart, phiLength);\n      self.tp$name = LATHE_GEOMETRY;\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(geometryPy, name) {\n      var geometry = Sk.ffi.remapToJs(geometryPy);\n      switch(name) {\n        case PROP_ID: {\n          return Sk.builtin.nmber(geometry[PROP_ID], Sk.builtin.nmber.int$);\n        }\n        case PROP_NAME: {\n          return new Sk.builtin.str(geometry[PROP_NAME]);\n        }\n        case PROP_VERTICES: {\n          return verticesPy(geometry.vertices);\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(geometryPy, name, valuePy) {\n      var geometry = Sk.ffi.remapToJs(geometryPy);\n      var value = Sk.ffi.remapToJs(valuePy);\n      switch(name) {\n        case PROP_NAME: {\n          if (isString(value)) {\n            geometry[PROP_NAME] = value;\n          }\n          else {\n            throw new Error(name + " must be a string");\n          }\n        }\n        break;\n        default: {\n          throw new Error(name + " is not an attribute of " + LATHE_GEOMETRY);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(self) {\n      var latheGeometry = self.v;\n      var args = {};\n      return new Sk.builtin.str(LATHE_GEOMETRY + "(" + JSON.stringify(args) + ")");\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(self) {\n      var latheGeometry = self.v;\n      var args = [];\n      return new Sk.builtin.str(LATHE_GEOMETRY + "(" + args.map(function(x) {return JSON.stringify(x);}).join(", ") + ")");\n    });\n  }, LATHE_GEOMETRY, []);\n\n  mod[ICOSAHEDRON_GEOMETRY] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self, radius, detail) {\n      radius = numberFromArg(radius,        PROP_RADIUS, ICOSAHEDRON_GEOMETRY);\n      detail = numberFromIntegerArg(detail, PROP_DETAIL, ICOSAHEDRON_GEOMETRY);\n      self.v = new THREE[ICOSAHEDRON_GEOMETRY](radius, detail);\n      self.tp$name = ICOSAHEDRON_GEOMETRY;\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(self, name) {\n      switch(name) {\n        case PROP_RADIUS: {\n          return Sk.builtin.assk$(self.v[PROP_RADIUS], Sk.builtin.nmber.float$);\n        }\n        case PROP_DETAIL: {\n          return Sk.builtin.assk$(self.v[PROP_DETAIL], Sk.builtin.nmber.int$);\n        }\n        default: {\n          // Framework will take care of the error message.\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(geometryPy, name, valuePy) {\n      var geometry = Sk.ffi.remapToJs(geometryPy);\n      var value = Sk.ffi.remapToJs(valuePy);\n      switch(name) {\n        default: {\n          throw new Error(name + " is not an attribute of " + ICOSAHEDRON_GEOMETRY);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(self) {\n      var icosahedron = self.v;\n      var args = {};\n      args[PROP_RADIUS] = icosahedron[PROP_RADIUS];\n      args[PROP_DETAIL] = icosahedron[PROP_DETAIL];\n      return new Sk.builtin.str(ICOSAHEDRON_GEOMETRY + "(" + JSON.stringify(args) + ")");\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(self) {\n      var icosahedron = self.v;\n      var radius = icosahedron[PROP_RADIUS];\n      var detail = icosahedron[PROP_DETAIL];\n      var args = [radius, detail];\n      return new Sk.builtin.str(ICOSAHEDRON_GEOMETRY + "(" + args.map(function(x) {return JSON.stringify(x);}).join(", ") + ")");\n    });\n  }, ICOSAHEDRON_GEOMETRY, []);\n\n  mod[OCTAHEDRON_GEOMETRY] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    var PROP_DETAIL = "detail";\n    $loc.__init__ = new Sk.builtin.func(function(self, radius, detail) {\n      radius = numberFromArg(radius,        PROP_RADIUS, OCTAHEDRON_GEOMETRY);\n      detail = numberFromIntegerArg(detail, PROP_DETAIL, OCTAHEDRON_GEOMETRY);\n      self.v = new THREE[OCTAHEDRON_GEOMETRY](radius, detail);\n      self.v.radius = radius; // workaround for THREE not caching radius.\n      self.v.detail = detail; // workaround for THREE not caching detail.\n      self.tp$name = OCTAHEDRON_GEOMETRY;\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(self, name) {\n      switch(name) {\n        case PROP_RADIUS: {\n          return Sk.builtin.assk$(self.v[PROP_RADIUS], Sk.builtin.nmber.float$);\n        }\n        case PROP_DETAIL: {\n          return Sk.builtin.assk$(self.v[PROP_DETAIL], Sk.builtin.nmber.int$);\n        }\n        default: {\n          // Framework will take care of the error message.\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(geometryPy, name, valuePy) {\n      var geometry = Sk.ffi.remapToJs(geometryPy);\n      var value = Sk.ffi.remapToJs(valuePy);\n      switch(name) {\n        default: {\n          throw new Error(name + " is not an attribute of " + OCTAHEDRON_GEOMETRY);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(self) {\n      var octahedron = self.v;\n      var args = {};\n      args[PROP_RADIUS] = octahedron[PROP_RADIUS];\n      args[PROP_DETAIL] = octahedron[PROP_DETAIL];\n      return new Sk.builtin.str(OCTAHEDRON_GEOMETRY + "(" + JSON.stringify(args) + ")");\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(self) {\n      var octahedron = self.v;\n      var radius = octahedron[PROP_RADIUS];\n      var detail = octahedron[PROP_DETAIL];\n      var args = [radius, detail];\n      return new Sk.builtin.str(OCTAHEDRON_GEOMETRY + "(" + args.map(function(x) {return JSON.stringify(x);}).join(", ") + ")");\n    });\n  }, OCTAHEDRON_GEOMETRY, []);\n\n   mod[PLANE_GEOMETRY] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    var PROP_WIDTH           = "width";\n    var PROP_HEIGHT          = "height";\n    var PROP_WIDTH_SEGMENTS  = "widthSegments";\n    var PROP_HEIGHT_SEGMENTS = "heightSegments";\n    $loc.__init__ = new Sk.builtin.func(function(self, width, height, widthSegments, heightSegments) {\n      width          = numberFromArg(width,                 PROP_WIDTH,           PLANE_GEOMETRY);\n      height         = numberFromArg(height,                PROP_HEIGHT,          PLANE_GEOMETRY);\n      widthSegments  = numberFromIntegerArg(widthSegments,  PROP_WIDTH_SEGMENTS,  PLANE_GEOMETRY);\n      heightSegments = numberFromIntegerArg(heightSegments, PROP_HEIGHT_SEGMENTS, PLANE_GEOMETRY);\n      self.v = new THREE[PLANE_GEOMETRY](width, height, widthSegments, heightSegments);\n      self.tp$name = PLANE_GEOMETRY;\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(self, name) {\n      switch(name) {\n        case PROP_WIDTH: {\n          return Sk.builtin.assk$(self.v[PROP_WIDTH], Sk.builtin.nmber.float$);\n        }\n        case PROP_HEIGHT: {\n          return Sk.builtin.assk$(self.v[PROP_HEIGHT], Sk.builtin.nmber.float$);\n        }\n        case PROP_WIDTH_SEGMENTS: {\n          return Sk.builtin.assk$(self.v[PROP_WIDTH_SEGMENTS], Sk.builtin.nmber.int$);\n        }\n        case PROP_HEIGHT_SEGMENTS: {\n          return Sk.builtin.assk$(self.v[PROP_HEIGHT_SEGMENTS], Sk.builtin.nmber.int$);\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(geometryPy, name, valuePy) {\n      var geometry = Sk.ffi.remapToJs(geometryPy);\n      var value = Sk.ffi.remapToJs(valuePy);\n      switch(name) {\n        default: {\n          throw new Error(name + " is not an attribute of " + PLANE_GEOMETRY);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(self) {\n      var plane = self.v;\n      var args = {};\n      args[PROP_WIDTH]  = plane[PROP_WIDTH];\n      args[PROP_HEIGHT] = plane[PROP_HEIGHT];\n      return new Sk.builtin.str(PLANE_GEOMETRY + "(" + JSON.stringify(args) + ")");\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(self) {\n      var plane = self.v;\n      var width          = plane[PROP_WIDTH];\n      var height         = plane[PROP_HEIGHT];\n      var widthSegments  = plane[PROP_WIDTH_SEGMENTS];\n      var heightSegments = plane[PROP_HEIGHT_SEGMENTS];\n      var args = [width, height, widthSegments, heightSegments];\n      return new Sk.builtin.str(PLANE_GEOMETRY + "(" + args.map(function(x) {return JSON.stringify(x);}).join(", ") + ")");\n    });\n  }, PLANE_GEOMETRY, []);\n\n   mod[SPHERE_GEOMETRY] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    var PROP_WIDTH_SEGMENTS  = "widthSegments";\n    var PROP_HEIGHT_SEGMENTS = "heightSegments";\n    var PROP_PHI_START       = "phiStart";\n    var PROP_PHI_LENGTH      = "phiLength";\n    $loc.__init__ = new Sk.builtin.func(function(self, radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {\n      radius         = numberFromArg(radius,                PROP_RADIUS,          SPHERE_GEOMETRY);\n      widthSegments  = numberFromIntegerArg(widthSegments,  PROP_WIDTH_SEGMENTS,  SPHERE_GEOMETRY);\n      heightSegments = numberFromIntegerArg(heightSegments, PROP_HEIGHT_SEGMENTS, SPHERE_GEOMETRY);\n      phiStart       = numberFromArg(phiStart,              PROP_PHI_START,       SPHERE_GEOMETRY);\n      phiLength      = numberFromArg(phiLength,             PROP_PHI_LENGTH,      SPHERE_GEOMETRY);\n      thetaStart     = numberFromArg(thetaStart,            PROP_THETA_START,     SPHERE_GEOMETRY);\n      thetaLength    = numberFromArg(thetaLength,           PROP_THETA_LENGTH,    SPHERE_GEOMETRY);\n      self.v = new THREE[SPHERE_GEOMETRY](radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength);\n      self.tp$name = SPHERE_GEOMETRY;\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(self, name) {\n      switch(name) {\n        case PROP_RADIUS: {\n          return Sk.builtin.assk$(self.v[PROP_RADIUS], Sk.builtin.nmber.float$);\n        }\n        case PROP_WIDTH_SEGMENTS: {\n          return Sk.builtin.assk$(self.v[PROP_WIDTH_SEGMENTS], Sk.builtin.nmber.int$);\n        }\n        case PROP_HEIGHT_SEGMENTS: {\n          return Sk.builtin.assk$(self.v[PROP_HEIGHT_SEGMENTS], Sk.builtin.nmber.int$);\n        }\n        case PROP_PHI_START: {\n          return Sk.builtin.assk$(self.v[PROP_PHI_START], Sk.builtin.nmber.float$);\n        }\n        case PROP_PHI_LENGTH: {\n          return Sk.builtin.assk$(self.v[PROP_PHI_LENGTH], Sk.builtin.nmber.float$);\n        }\n        case PROP_THETA_START: {\n          return Sk.builtin.assk$(self.v[PROP_THETA_START], Sk.builtin.nmber.float$);\n        }\n        case PROP_THETA_LENGTH: {\n          return Sk.builtin.assk$(self.v[PROP_THETA_LENGTH], Sk.builtin.nmber.float$);\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(geometryPy, name, valuePy) {\n      var geometry = Sk.ffi.remapToJs(geometryPy);\n      var value = Sk.ffi.remapToJs(valuePy);\n      switch(name) {\n        default: {\n          throw new Error(name + " is not an attribute of " + SPHERE_GEOMETRY);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(self) {\n      var sphere = self.v;\n      var radius = sphere[PROP_RADIUS];\n      var args = {};\n      args[PROP_RADIUS] = radius;\n      return new Sk.builtin.str(SPHERE_GEOMETRY + "(" + JSON.stringify(args) + ")");\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(self) {\n      var sphere = self.v;\n      var radius         = sphere[PROP_RADIUS];\n      var widthSegments  = sphere[PROP_WIDTH_SEGMENTS];\n      var heightSegments = sphere[PROP_HEIGHT_SEGMENTS];\n      var phiStart       = sphere[PROP_PHI_START];\n      var phiLength      = sphere[PROP_PHI_LENGTH];\n      var thetaStart     = sphere[PROP_THETA_START];\n      var thetaLength    = sphere[PROP_THETA_LENGTH];\n      var args = [radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength];\n      return new Sk.builtin.str(SPHERE_GEOMETRY + "(" + args.map(function(x) {return JSON.stringify(x);}).join(", ") + ")");\n    });\n  }, SPHERE_GEOMETRY, []);\n\n  mod[TETRAHEDRON_GEOMETRY] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    var PROP_DETAIL = "detail";\n    $loc.__init__ = new Sk.builtin.func(function(self, radius, detail) {\n      radius = numberFromArg(radius,        PROP_RADIUS, TETRAHEDRON_GEOMETRY);\n      detail = numberFromIntegerArg(detail, PROP_DETAIL, TETRAHEDRON_GEOMETRY);\n      self.v = new THREE[TETRAHEDRON_GEOMETRY](radius, detail);\n      self.v.radius = radius; // workaround for THREE not caching radius.\n      self.v.detail = detail; // workaround for THREE not caching detail.\n      self.tp$name = TETRAHEDRON_GEOMETRY;\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(self, name) {\n      switch(name) {\n        case PROP_RADIUS: {\n          return Sk.builtin.assk$(self.v[PROP_RADIUS], Sk.builtin.nmber.float$);\n        }\n        case PROP_DETAIL: {\n          return Sk.builtin.assk$(self.v[PROP_DETAIL], Sk.builtin.nmber.int$);\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(geometryPy, name, valuePy) {\n      var geometry = Sk.ffi.remapToJs(geometryPy);\n      var value = Sk.ffi.remapToJs(valuePy);\n      switch(name) {\n        default: {\n          throw new Error(name + " is not an attribute of " + TETRAHEDRON_GEOMETRY);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(self) {\n      var tetrahedron = self.v;\n      var args = {};\n      args[PROP_RADIUS] = tetrahedron[PROP_RADIUS];\n      args[PROP_DETAIL] = tetrahedron[PROP_DETAIL];\n      return new Sk.builtin.str(TETRAHEDRON_GEOMETRY + "(" + JSON.stringify(args) + ")");\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(self) {\n      var tetrahedron = self.v;\n      var radius = tetrahedron[PROP_RADIUS];\n      var detail = tetrahedron[PROP_DETAIL];\n      var args = [radius, detail];\n      return new Sk.builtin.str(TETRAHEDRON_GEOMETRY + "(" + args.map(function(x) {return JSON.stringify(x);}).join(", ") + ")");\n    });\n  }, TETRAHEDRON_GEOMETRY, []);\n\n   mod[TEXT_GEOMETRY] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self, text, parameters) {\n      text = Sk.ffi.remapToJs(text);\n      parameters = Sk.ffi.remapToJs(parameters);\n      self.v = new THREE[TEXT_GEOMETRY](text, parameters);\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(self, name) {\n      switch(name) {\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(geometryPy, name, valuePy) {\n      var geometry = Sk.ffi.remapToJs(geometryPy);\n      var value = Sk.ffi.remapToJs(valuePy);\n      switch(name) {\n        default: {\n          throw new Error(name + " is not an attribute of " + TEXT_GEOMETRY);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(self) {\n      var text = Sk.ffi.remapToJs(self);\n      var args = {};\n      return new Sk.builtin.str(TEXT_GEOMETRY + "(" + JSON.stringify(args) + ")");\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(self) {\n      var text = Sk.ffi.remapToJs(self);\n      var args = [];\n      return new Sk.builtin.str(TEXT_GEOMETRY + "(" + args.map(function(x) {return JSON.stringify(x);}).join(", ") + ")");\n    });\n  }, TEXT_GEOMETRY, []);\n\n   mod[TORUS_GEOMETRY] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    var PROP_TUBE             = "tube";\n    var PROP_RADIAL_SEGMENTS  = "radialSegments";\n    var PROP_TUBULAR_SEGMENTS = "tubularSegments";\n    var PROP_ARC              = "arc";\n    $loc.__init__ = new Sk.builtin.func(function(self, radius, tube, radialSegments, tubularSegments, arc) {\n      radius = numberFromArg(radius,                          PROP_RADIUS,           TORUS_GEOMETRY);\n      tube = numberFromArg(tube,                              PROP_TUBE,             TORUS_GEOMETRY);\n      radialSegments = numberFromIntegerArg(radialSegments,   PROP_RADIAL_SEGMENTS,  TORUS_GEOMETRY);\n      tubularSegments = numberFromIntegerArg(tubularSegments, PROP_TUBULAR_SEGMENTS, TORUS_GEOMETRY);\n      arc = numberFromArg(arc,                                PROP_ARC,              TORUS_GEOMETRY);\n      self.v = new THREE[TORUS_GEOMETRY](radius, tube, radialSegments, tubularSegments, arc);\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(self, name) {\n      switch(name) {\n        case PROP_RADIUS: {\n          return Sk.builtin.assk$(self.v[PROP_RADIUS], Sk.builtin.nmber.float$);\n        }\n        case PROP_TUBE: {\n          return Sk.builtin.assk$(self.v[PROP_TUBE], Sk.builtin.nmber.float$);\n        }\n        case PROP_RADIAL_SEGMENTS: {\n          return Sk.builtin.assk$(self.v[PROP_RADIAL_SEGMENTS], Sk.builtin.nmber.int$);\n        }\n        case PROP_TUBULAR_SEGMENTS: {\n          return Sk.builtin.assk$(self.v[PROP_TUBULAR_SEGMENTS], Sk.builtin.nmber.int$);\n        }\n        case PROP_ARC: {\n          return Sk.builtin.assk$(self.v[PROP_ARC], Sk.builtin.nmber.float$);\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(geometryPy, name, valuePy) {\n      var geometry = Sk.ffi.remapToJs(geometryPy);\n      var value = Sk.ffi.remapToJs(valuePy);\n      switch(name) {\n        default: {\n          throw new Error(name + " is not an attribute of " + TORUS_GEOMETRY);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(self) {\n      var torus = self.v;\n      var args = {};\n      args[PROP_RADIUS] = torus[PROP_RADIUS];\n      args[PROP_TUBE]   = torus[PROP_TUBE];\n      args[PROP_ARC]    = torus[PROP_ARC];\n      return new Sk.builtin.str(TORUS_GEOMETRY + "(" + JSON.stringify(args) + ")");\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(self) {\n      var torus = self.v;\n      var radius          = torus[PROP_RADIUS];\n      var tube            = torus[PROP_TUBE];\n      var radialSegments  = torus[PROP_RADIAL_SEGMENTS];\n      var tubularSegments = torus[PROP_TUBULAR_SEGMENTS];\n      var arc             = torus[PROP_ARC];\n      var args = [radius, tube, radialSegments, tubularSegments, arc];\n      return new Sk.builtin.str(TORUS_GEOMETRY + "(" + args.map(function(x) {return JSON.stringify(x);}).join(", ") + ")");\n    });\n  }, TORUS_GEOMETRY, []);\n\n   mod[GEOMETRY] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self, geometryPy) {\n      if (isDefined(geometryPy)) {\n        self.v = Sk.ffi.remapToJs(geometryPy);\n        self.tp$name = geometryPy.tp$name;\n      }\n      else {\n        self.v = new THREE[GEOMETRY]();\n        self.tp$name = GEOMETRY;\n      }\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(geometryPy, name) {\n      var geometry = Sk.ffi.remapToJs(geometryPy);\n      switch(name) {\n        case PROP_ID: {\n          return Sk.builtin.nmber(geometry[PROP_ID], Sk.builtin.nmber.int$);\n        }\n        case PROP_NAME: {\n          return new Sk.builtin.str(geometry[PROP_NAME]);\n        }\n        case PROP_VERTICES: {\n          return verticesPy(geometry.vertices);\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(geometryPy, name, valuePy) {\n      var geometry = Sk.ffi.remapToJs(geometryPy);\n      var value = Sk.ffi.remapToJs(valuePy);\n      switch(name) {\n        default: {\n          throw new Error(name + " is not an attribute of " + GEOMETRY);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(geometryPy) {\n      var geometry = Sk.ffi.remapToJs(geometryPy);\n      if (isDefined(geometry)) {\n        var args = {};\n        return new Sk.builtin.str(GEOMETRY + "(" + JSON.stringify(args) + ")");\n      }\n      else {\n        return new Sk.builtin.str("<type \'" + GEOMETRY + "\'>");\n      }\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(geometry) {\n      geometry = Sk.ffi.remapToJs(geometry);\n      var args = [];\n      return new Sk.builtin.str(GEOMETRY + "(" + args.map(function(x) {return JSON.stringify(x);}).join(", ") + ")");\n    });\n  }, GEOMETRY, []);\n\n  mod[OBJECT_3D] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self) {\n      self.tp$name = OBJECT_3D;\n      self.v = new THREE[OBJECT_3D]();\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(objPy, name) {\n      var obj = Sk.ffi.remapToJs(objPy);\n      switch(name) {\n        case PROP_POSITION: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(obj[PROP_POSITION], EUCLIDEAN_3));\n        }\n        case PROP_QUATERNION: {\n          return Sk.misceval.callsim(mod[QUATERNION], Sk.ffi.referenceToPy(obj[PROP_QUATERNION], QUATERNION));\n        }\n        case PROP_ROTATION: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(obj[PROP_ROTATION], EUCLIDEAN_3));\n        }\n        case PROP_EULER_ORDER: {\n          return new Sk.builtin.str(obj[PROP_EULER_ORDER]);\n        }\n        case PROP_SCALE: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(obj[PROP_SCALE], EUCLIDEAN_3));\n        }\n        case PROP_UP: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(obj[PROP_UP], EUCLIDEAN_3));\n        }\n        case PROP_USE_QUATERNION: {\n          return obj[PROP_USE_QUATERNION];\n        }\n        case METHOD_ADD: {\n          return methodAdd(obj);\n        }\n        case METHOD_REMOVE: {\n          return methodRemove(obj);\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(obj, name, value) {\n      obj = Sk.ffi.remapToJs(obj);\n      value = Sk.ffi.remapToJs(value);\n      switch(name) {\n        case PROP_POSITION: {\n          obj[PROP_POSITION] = value;\n        }\n        break;\n        case PROP_QUATERNION: {\n          obj[PROP_QUATERNION] = value;\n        }\n        break;\n        case PROP_ROTATION: {\n          obj[PROP_ROTATION] = value;\n        }\n        break;\n        case PROP_EULER_ORDER: {\n          if (isString(value)) {\n            obj[PROP_EULER_ORDER] = value;\n          }\n          else {\n            throw new Error(name + " must be a string");\n          }\n        }\n        break;\n        case PROP_SCALE: {\n          obj[PROP_SCALE] = value;\n        }\n        break;\n        case PROP_UP: {\n          obj[PROP_UP] = value;\n        }\n        break;\n        case PROP_USE_QUATERNION: {\n          obj[PROP_USE_QUATERNION] = value;\n        }\n        break;\n        default: {\n          throw new Error(name + " is not an settable attribute of " + OBJECT_3D);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(obj) {\n      obj = Sk.ffi.remapToJs(obj);\n      if (isDefined(obj)) {\n        var args = {};\n        return new Sk.builtin.str(OBJECT_3D + "(" + JSON.stringify(args) + ")");\n      }\n      else {\n        return new Sk.builtin.str("<type \'" + OBJECT_3D + "\'>");\n      }\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(obj) {\n      obj = Sk.ffi.remapToJs(obj);\n      var args = [];\n      return new Sk.builtin.str(OBJECT_3D + "(" + args.map(function(x) {return JSON.stringify(x);}).join(", ") + ")");\n    });\n  }, OBJECT_3D, []);\n\n  mod[AMBIENT_LIGHT] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self, color) {\n      self.tp$name = AMBIENT_LIGHT;\n      color = Sk.ffi.remapToJs(color);\n      self.v = new THREE[AMBIENT_LIGHT](color);\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(lightPy, name) {\n      var light = Sk.ffi.remapToJs(lightPy);\n      switch(name) {\n        case PROP_COLOR: {\n          return Sk.misceval.callsim(mod[COLOR], Sk.ffi.referenceToPy(light[PROP_COLOR], COLOR));\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(lightPy, name, valuePy) {\n      var light = Sk.ffi.remapToJs(lightPy);\n      var value = Sk.ffi.remapToJs(valuePy);\n      switch(name) {\n        case PROP_COLOR: {\n          light[PROP_COLOR] = new THREE.Color(value);\n        }\n        break;\n        default: {\n          throw new Error(name + " is not an settable attribute of " + AMBIENT_LIGHT);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(light) {\n      light = Sk.ffi.remapToJs(light);\n      if (isDefined(light)) {\n        var args = {};\n        args[PROP_COLOR] = light[PROP_COLOR];\n        return new Sk.builtin.str(AMBIENT_LIGHT + "(" + JSON.stringify(args) + ")");\n      }\n      else {\n        return new Sk.builtin.str("<type \'" + AMBIENT_LIGHT + "\'>");\n      }\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(light) {\n      light = Sk.ffi.remapToJs(light);\n      var args = [light[PROP_COLOR]];\n      return new Sk.builtin.str(AMBIENT_LIGHT + "(" + args.map(function(x) {return JSON.stringify(x);}).join(", ") + ")");\n    });\n  }, AMBIENT_LIGHT, []);\n\n  mod[DIRECTIONAL_LIGHT] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    var PROP_INTENSITY = "intensity";\n    var PROP_DISTANCE = "distance";\n    $loc.__init__ = new Sk.builtin.func(function(self, color, intensity, distance) {\n      self.tp$name = DIRECTIONAL_LIGHT;\n      color = Sk.ffi.remapToJs(color);\n      intensity = Sk.ffi.remapToJs(intensity);\n      distance = Sk.ffi.remapToJs(distance);\n      self.v = new THREE[DIRECTIONAL_LIGHT](color, intensity, distance);\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(lightPy, name) {\n      var light = Sk.ffi.remapToJs(lightPy);\n      switch(name) {\n        case PROP_COLOR: {\n          return Sk.misceval.callsim(mod[COLOR], Sk.ffi.referenceToPy(light[PROP_COLOR], COLOR));\n        }\n        case PROP_DISTANCE: {\n          return Sk.builtin.nmber(light[PROP_DISTANCE], Sk.builtin.nmber.float$);\n        }\n        case PROP_INTENSITY: {\n          return Sk.builtin.nmber(light[PROP_INTENSITY], Sk.builtin.nmber.float$);\n        }\n        case PROP_POSITION: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(light[PROP_POSITION], EUCLIDEAN_3));\n        }\n        case PROP_QUATERNION: {\n          return Sk.misceval.callsim(mod[QUATERNION], Sk.ffi.referenceToPy(light[PROP_QUATERNION], QUATERNION));\n        }\n        case PROP_ROTATION: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(light[PROP_ROTATION], EUCLIDEAN_3));\n        }\n        case PROP_EULER_ORDER: {\n          return new Sk.builtin.str(light[PROP_EULER_ORDER]);\n        }\n        case PROP_SCALE: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(light[PROP_SCALE], EUCLIDEAN_3));\n        }\n        case PROP_UP: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(light[PROP_UP], EUCLIDEAN_3));\n        }\n        case PROP_USE_QUATERNION: {\n          return light[PROP_USE_QUATERNION];\n        }\n        case METHOD_LOOK_AT: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_LOOK_AT;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, vectorPy) {\n              light.lookAt(Sk.ffi.remapToJs(vectorPy));\n              return lightPy;\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_LOOK_AT);\n            })\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_LOOK_AT);\n            })\n          }, METHOD_LOOK_AT, []));\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(light, name, value) {\n      light = Sk.ffi.remapToJs(light);\n      value = Sk.ffi.remapToJs(value);\n      switch(name) {\n        case PROP_COLOR: {\n          light[PROP_COLOR] = new THREE.Color(value);\n        }\n        break;\n        case PROP_DISTANCE: {\n          if (isNumber(value)) {\n            light[PROP_DISTANCE] = value;\n          }\n          else {\n            throw new Sk.builtin.TypeError("\'" + PROP_DISTANCE + "\' attribute must be a <type \'float\'>.");\n          }\n        }\n        break;\n        case PROP_INTENSITY: {\n          if (isNumber(value)) {\n            light[PROP_INTENSITY] = value;\n          }\n          else {\n            throw new Sk.builtin.TypeError("\'" + PROP_INTENSITY + "\' attribute must be a <type \'float\'>.");\n          }\n        }\n        break;\n        case PROP_POSITION: {\n          light[PROP_POSITION] = value;\n        }\n        break;\n        case PROP_QUATERNION: {\n          light[PROP_QUATERNION] = value;\n        }\n        break;\n        case PROP_ROTATION: {\n          light[PROP_ROTATION] = value;\n        }\n        break;\n        case PROP_EULER_ORDER: {\n          if (isString(value)) {\n            light[PROP_EULER_ORDER] = value;\n          }\n          else {\n            throw new Error(name + " must be a string");\n          }\n        }\n        break;\n        case PROP_SCALE: {\n          light[PROP_SCALE] = value;\n        }\n        break;\n        case PROP_UP: {\n          light[PROP_UP] = value;\n        }\n        break;\n        case PROP_USE_QUATERNION: {\n          light[PROP_USE_QUATERNION] = value;\n        }\n        break;\n        default: {\n          throw new Error(name + " is not an settable attribute of " + DIRECTIONAL_LIGHT);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(light) {\n      light = Sk.ffi.remapToJs(light);\n      if (isDefined(light)) {\n        var args = {};\n        args[PROP_COLOR] = light[PROP_COLOR];\n        args[PROP_INTENSITY] = light[PROP_INTENSITY];\n        args[PROP_DISTANCE] = light[PROP_DISTANCE];\n        return new Sk.builtin.str(DIRECTIONAL_LIGHT + "(" + JSON.stringify(args) + ")");\n      }\n      else {\n        return new Sk.builtin.str("<type \'" + DIRECTIONAL_LIGHT + "\'>");\n      }\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(light) {\n      light = Sk.ffi.remapToJs(light);\n      var args = [light[PROP_COLOR], light[PROP_INTENSITY], light[PROP_DISTANCE]];\n      return new Sk.builtin.str(DIRECTIONAL_LIGHT + "(" + args.map(function(x) {return JSON.stringify(x);}).join(", ") + ")");\n    });\n  }, DIRECTIONAL_LIGHT, []);\n\n  mod[POINT_LIGHT] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    var PROP_INTENSITY = "intensity";\n    var PROP_DISTANCE = "distance";\n    $loc.__init__ = new Sk.builtin.func(function(self, color, intensity, distance) {\n      self.tp$name = POINT_LIGHT;\n      color = Sk.ffi.remapToJs(color);\n      intensity = Sk.ffi.remapToJs(intensity);\n      distance = Sk.ffi.remapToJs(distance);\n      self.v = new THREE[POINT_LIGHT](color, intensity, distance);\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(lightPy, name) {\n      var light = Sk.ffi.remapToJs(lightPy);\n      switch(name) {\n        case PROP_COLOR: {\n          return Sk.misceval.callsim(mod[COLOR], Sk.ffi.referenceToPy(light[PROP_COLOR], COLOR));\n        }\n        case PROP_DISTANCE: {\n          return Sk.builtin.nmber(light[PROP_DISTANCE], Sk.builtin.nmber.float$);\n        }\n        case PROP_INTENSITY: {\n          return Sk.builtin.nmber(light[PROP_INTENSITY], Sk.builtin.nmber.float$);\n        }\n        case PROP_POSITION: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(light[PROP_POSITION], EUCLIDEAN_3));\n        }\n        case PROP_QUATERNION: {\n          return Sk.misceval.callsim(mod[QUATERNION], Sk.ffi.referenceToPy(light[PROP_QUATERNION], QUATERNION));\n        }\n        case PROP_ROTATION: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(light[PROP_ROTATION], EUCLIDEAN_3));\n        }\n        case PROP_EULER_ORDER: {\n          return new Sk.builtin.str(light[PROP_EULER_ORDER]);\n        }\n        case PROP_SCALE: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(light[PROP_SCALE], EUCLIDEAN_3));\n        }\n        case PROP_UP: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(light[PROP_UP], EUCLIDEAN_3));\n        }\n        case PROP_USE_QUATERNION: {\n          return light[PROP_USE_QUATERNION];\n        }\n        case METHOD_LOOK_AT: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_LOOK_AT;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, vectorPy) {\n              light.lookAt(Sk.ffi.remapToJs(vectorPy));\n              return lightPy;\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_LOOK_AT);\n            })\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_LOOK_AT);\n            })\n          }, METHOD_LOOK_AT, []));\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(light, name, value) {\n      light = Sk.ffi.remapToJs(light);\n      value = Sk.ffi.remapToJs(value);\n      switch(name) {\n        case PROP_COLOR: {\n          light[PROP_COLOR] = new THREE.Color(value);\n        }\n        break;\n        case PROP_DISTANCE: {\n          if (isNumber(value)) {\n            light[PROP_DISTANCE] = value;\n          }\n          else {\n            throw new Sk.builtin.TypeError("\'" + PROP_DISTANCE + "\' attribute must be a <type \'float\'>.");\n          }\n        }\n        break;\n        case PROP_INTENSITY: {\n          if (isNumber(value)) {\n            light[PROP_INTENSITY] = value;\n          }\n          else {\n            throw new Sk.builtin.TypeError("\'" + PROP_INTENSITY + "\' attribute must be a <type \'float\'>.");\n          }\n        }\n        break;\n        case PROP_POSITION: {\n          light[PROP_POSITION] = value;\n        }\n        break;\n        case PROP_QUATERNION: {\n          light[PROP_QUATERNION] = value;\n        }\n        break;\n        case PROP_ROTATION: {\n          light[PROP_ROTATION] = value;\n        }\n        break;\n        case PROP_EULER_ORDER: {\n          if (isString(value)) {\n            light[PROP_EULER_ORDER] = value;\n          }\n          else {\n            throw new Error(name + " must be a string");\n          }\n        }\n        break;\n        case PROP_SCALE: {\n          light[PROP_SCALE] = value;\n        }\n        break;\n        case PROP_UP: {\n          light[PROP_UP] = value;\n        }\n        break;\n        case PROP_USE_QUATERNION: {\n          light[PROP_USE_QUATERNION] = value;\n        }\n        break;\n        default: {\n          throw new Error(name + " is not an settable attribute of " + POINT_LIGHT);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(light) {\n      light = Sk.ffi.remapToJs(light);\n      if (isDefined(light)) {\n        var args = {};\n        args[PROP_COLOR] = light[PROP_COLOR];\n        args[PROP_INTENSITY] = light[PROP_INTENSITY];\n        args[PROP_DISTANCE] = light[PROP_DISTANCE];\n        return new Sk.builtin.str(POINT_LIGHT + "(" + JSON.stringify(args) + ")");\n      }\n      else {\n        return new Sk.builtin.str("<type \'" + POINT_LIGHT + "\'>");\n      }\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(light) {\n      light = Sk.ffi.remapToJs(light);\n      var args = [light[PROP_COLOR], light[PROP_INTENSITY], light[PROP_DISTANCE]];\n      return new Sk.builtin.str(POINT_LIGHT + "(" + args.map(function(x) {return JSON.stringify(x);}).join(", ") + ")");\n    });\n  }, POINT_LIGHT, []);\n\n  mod[LINE] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self, geometryPy, materialPy, typePy) {\n      var geometry = Sk.ffi.remapToJs(geometryPy)\n      var material = Sk.ffi.remapToJs(materialPy)\n      var type = Sk.ffi.remapToJs(typePy)\n      self.v = new THREE[LINE](geometry, material, type);\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(linePy, name) {\n      var line = Sk.ffi.remapToJs(linePy);\n      switch(name) {\n        case PROP_POSITION: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(line[PROP_POSITION], EUCLIDEAN_3));\n        }\n        case PROP_QUATERNION: {\n          return Sk.misceval.callsim(mod[QUATERNION], Sk.ffi.referenceToPy(line[PROP_QUATERNION], QUATERNION));\n        }\n        case PROP_ROTATION: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(line[PROP_ROTATION], EUCLIDEAN_3));\n        }\n        case PROP_EULER_ORDER: {\n          return new Sk.builtin.str(line[PROP_EULER_ORDER]);\n        }\n        case PROP_SCALE: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(line[PROP_SCALE], EUCLIDEAN_3));\n        }\n        case PROP_UP: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(line[PROP_UP], EUCLIDEAN_3));\n        }\n        case PROP_USE_QUATERNION: {\n          return line[PROP_USE_QUATERNION];\n        }\n        case METHOD_LOOK_AT: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_LOOK_AT;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, vectorPy) {\n              line.lookAt(Sk.ffi.remapToJs(vectorPy));\n              return linePy;\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_LOOK_AT);\n            })\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_LOOK_AT);\n            })\n          }, METHOD_LOOK_AT, []));\n        }\n        case PROP_TYPE: {\n          return Sk.builtin.nmber(line[PROP_TYPE], Sk.builtin.nmber.int$);\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(linePy, name, value) {\n      var line = Sk.ffi.remapToJs(linePy);\n      value = Sk.ffi.remapToJs(value);\n      switch(name) {\n        case PROP_TYPE: {\n          if (isNumber(value)) {\n            line[PROP_TYPE] = value;\n          }\n          else {\n            throw new Error(PROP_TYPE + " must be either LineStrip or LinePieces");\n          }\n        }\n        break;\n        default: {\n          throw new Error(name + " is not an attribute of " + LINE);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(self) {\n      return new Sk.builtin.str(LINE);\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(self) {\n      return new Sk.builtin.str(LINE);\n    });\n  }, LINE, []);\n\n  mod[LINE_BASIC_MATERIAL] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self, parameters) {\n      self.tp$name = LINE_BASIC_MATERIAL;\n      parameters = Sk.ffi.remapToJs(parameters);\n      self.v = new THREE[LINE_BASIC_MATERIAL](parameters);\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(material, name) {\n      material = Sk.ffi.remapToJs(material);\n      switch(name) {\n        case PROP_COLOR: {\n          return Sk.misceval.callsim(mod[COLOR], Sk.ffi.referenceToPy(material[PROP_COLOR], COLOR));\n        }\n        case PROP_OPACITY: {\n          return Sk.builtin.nmber(material[PROP_OPACITY], Sk.builtin.nmber.float$);\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(material, name, value) {\n      material = Sk.ffi.remapToJs(material);\n      value = Sk.ffi.remapToJs(value);\n      switch(name) {\n        case PROP_COLOR: {\n          if (isColor(value)) {\n            material.color = value;\n          }\n          else {\n            throw new Sk.builtin.TypeError("\'" + PROP_OPACITY + "\' attribute must be a <type \'" + COLOR + "\'>.");\n          }\n        }\n        break;\n        case PROP_OPACITY: {\n          if (isNumber(value)) {\n            material.opacity = value;\n          }\n          else {\n            throw new Sk.builtin.TypeError("\'" + PROP_OPACITY + "\' attribute must be a <type \'float\'>.");\n          }\n        }\n        break;\n        default: {\n          throw new Error(name + " is not an attribute of " + LINE_BASIC_MATERIAL);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(material) {\n      material = Sk.ffi.remapToJs(material);\n      var args = {};\n      args[PROP_COLOR] = material[PROP_COLOR];\n      args[PROP_OPACITY] = material[PROP_OPACITY];\n      return new Sk.builtin.str(LINE_BASIC_MATERIAL + "(" + JSON.stringify(args) + ")");\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(material) {\n      material = Sk.ffi.remapToJs(material);\n      var args = [{}];\n      return new Sk.builtin.str(LINE_BASIC_MATERIAL + "(" + args.map(function(x) {return JSON.stringify(x);}).join(", ") + ")");\n    });\n  }, LINE_BASIC_MATERIAL, []);\n\n  mod[MESH] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self, geometryPy, materialPy) {\n      self.tp$name = MESH;\n      self.v = new THREE[MESH](Sk.ffi.remapToJs(geometryPy), Sk.ffi.remapToJs(materialPy));\n      self.v[PROP_MASS] = multiVector3(0, new THREE.Vector3(0, 0, 0), 0, 0, 0, 0);\n      self.v[PROP_VELOCITY] = multiVector3(0, new THREE.Vector3(0, 0, 0), 0, 0, 0, 0);\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(meshPy, name) {\n      var mesh = Sk.ffi.remapToJs(meshPy);\n      switch(name) {\n        case PROP_ID: {\n          return Sk.builtin.nmber(mesh[PROP_ID], Sk.builtin.nmber.int$);\n        }\n        case PROP_GEOMETRY: {\n          var geometry = mesh[PROP_GEOMETRY];\n          return Sk.misceval.callsim(mod[GEOMETRY], Sk.ffi.referenceToPy(mesh[PROP_GEOMETRY], GEOMETRY));\n        }\n        case PROP_MASS: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(mesh[PROP_MASS], EUCLIDEAN_3));\n        }\n        case PROP_MATRIX_AUTO_UPDATE: {\n          return mesh[PROP_MATRIX_AUTO_UPDATE];\n        }\n        case PROP_NAME: {\n          return new Sk.builtin.str(mesh[PROP_NAME]);\n        }\n        case PROP_OVERDRAW: {\n          if (isBoolean(mesh[PROP_OVERDRAW])) {\n            return mesh[PROP_OVERDRAW];\n          }\n          else {\n            return null;\n          }\n        }\n        case PROP_POSITION: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(mesh[PROP_POSITION], EUCLIDEAN_3));\n        }\n        case PROP_QUATERNION: {\n          return Sk.misceval.callsim(mod[QUATERNION], Sk.ffi.referenceToPy(mesh[PROP_QUATERNION], QUATERNION));\n        }\n        case PROP_ROTATION: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(mesh[PROP_ROTATION], EUCLIDEAN_3));\n        }\n        case PROP_EULER_ORDER: {\n          return new Sk.builtin.str(mesh[PROP_EULER_ORDER]);\n        }\n        case PROP_SCALE: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(mesh[PROP_SCALE], EUCLIDEAN_3));\n        }\n        case PROP_UP: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(mesh[PROP_UP], EUCLIDEAN_3));\n        }\n        case PROP_USE_QUATERNION: {\n          return mesh[PROP_USE_QUATERNION];\n        }\n        case PROP_VELOCITY: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(mesh[PROP_VELOCITY], EUCLIDEAN_3));\n        }\n        case PROP_VISIBLE: {\n          return mesh[PROP_VISIBLE];\n        }\n        case METHOD_LOOK_AT: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_LOOK_AT;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, vectorPy) {\n              mesh.lookAt(Sk.ffi.remapToJs(vectorPy));\n              return meshPy;\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_LOOK_AT);\n            })\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_LOOK_AT);\n            })\n          }, METHOD_LOOK_AT, []));\n        }\n        case METHOD_SET_GEOMETRY: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_SET_GEOMETRY;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, geometryPy) {\n              var geometry = Sk.ffi.remapToJs(geometryPy);\n              mesh[METHOD_SET_GEOMETRY](geometry);\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_SET_GEOMETRY)\n            })\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_SET_GEOMETRY)\n            })\n          }, METHOD_SET_GEOMETRY, []));\n        }\n        case METHOD_UPDATE_MATRIX: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_UPDATE_MATRIX;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self) {\n              mesh[METHOD_UPDATE_MATRIX]();\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_UPDATE_MATRIX)\n            })\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_UPDATE_MATRIX)\n            })\n          }, METHOD_UPDATE_MATRIX, []));\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(mesh, name, value) {\n      mesh = Sk.ffi.remapToJs(mesh);\n      value = Sk.ffi.remapToJs(value);\n      switch(name) {\n        case PROP_MASS: {\n          if (isNumber(value)) {\n            mesh[PROP_MASS] = multiVector3(value, new THREE.Vector3(0, 0, 0), 0, 0, 0, 0);\n          }\n          else {\n            mesh[PROP_MASS] = value;\n          }\n        }\n        break;\n        case PROP_MATRIX_AUTO_UPDATE: {\n          if (isBoolean(value)) {\n            mesh[PROP_MATRIX_AUTO_UPDATE] = value;\n          }\n          else {\n            throw new Error(PROP_MATRIX_AUTO_UPDATE + " must be Boolean");\n          }\n        }\n        break;\n        case PROP_NAME: {\n          if (isString(value)) {\n            mesh[PROP_NAME] = value;\n          }\n          else {\n            throw new Error(name + " must be a string");\n          }\n        }\n        break;\n        case PROP_OVERDRAW: {\n          if (isBoolean(value)) {\n            mesh[PROP_OVERDRAW] = value;\n          }\n          else if (isNull(value)) {\n            mesh[PROP_OVERDRAW] = null;\n          }\n          else {\n            throw new Error(name + " must be either Boolean or None");\n          }\n        }\n        break;\n        case PROP_POSITION: {\n          mesh[PROP_POSITION] = value;\n        }\n        break;\n        case PROP_QUATERNION: {\n          mesh[PROP_QUATERNION] = value;\n        }\n        break;\n        case PROP_ROTATION: {\n          mesh[PROP_ROTATION] = value;\n        }\n        break;\n        case PROP_EULER_ORDER: {\n          if (isString(value)) {\n            mesh[PROP_EULER_ORDER] = value;\n          }\n          else {\n            throw new Error(name + " must be a string");\n          }\n        }\n        break;\n        case PROP_SCALE: {\n          mesh[PROP_SCALE] = value;\n        }\n        break;\n        case PROP_UP: {\n          mesh[PROP_UP] = value;\n        }\n        break;\n        case PROP_USE_QUATERNION: {\n          mesh[PROP_USE_QUATERNION] = value;\n        }\n        break;\n        case PROP_VELOCITY: {\n          mesh[PROP_VELOCITY] = value;\n        }\n        break;\n        case PROP_VISIBLE: {\n          if (isBoolean(value)) {\n            mesh[PROP_VISIBLE] = value;\n          }\n          else {\n            throw new Error(PROP_VISIBLE + " must be Boolean");\n          }\n        }\n        break;\n        default: {\n          throw new Error(name + " is not an attribute of " + MESH);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(mesh) {\n      mesh = Sk.ffi.remapToJs(mesh);\n      var args = {};\n      args[PROP_ID] = mesh[PROP_ID];\n      args[PROP_NAME] = mesh[PROP_NAME];\n      return new Sk.builtin.str(MESH + "(" + JSON.stringify(args) + ")");\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(mesh) {\n      mesh = Sk.ffi.remapToJs(mesh);\n      var args = [/*mesh[PROP_GEOMETRY], mesh[PROP_MATERIAL]*/];\n      return new Sk.builtin.str(MESH + "(" + args.map(function(x) {return JSON.stringify(x);}).join(", ") + ")");\n    });\n  }, MESH, []);\n\n  mod[MESH_BASIC_MATERIAL] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self, parameters) {\n      self.tp$name = MESH_BASIC_MATERIAL;\n      parameters = Sk.ffi.remapToJs(parameters);\n      self.v = new THREE[MESH_BASIC_MATERIAL](parameters);\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(materialPy, name) {\n      var material = Sk.ffi.remapToJs(materialPy);\n      switch(name) {\n        case PROP_ID: {\n          return Sk.builtin.nmber(material[PROP_ID], Sk.builtin.nmber.int$);\n        }\n        case PROP_NAME: {\n          return new Sk.builtin.str(material[PROP_NAME]);\n        }\n        case PROP_COLOR: {\n          return Sk.misceval.callsim(mod[COLOR], Sk.ffi.referenceToPy(material[PROP_COLOR], COLOR));\n        }\n        case PROP_NEEDS_UPDATE: {\n          return material[PROP_NEEDS_UPDATE];\n        }\n        case PROP_OPACITY: {\n          return Sk.builtin.nmber(material[PROP_OPACITY], Sk.builtin.nmber.float$);\n        }\n        case PROP_OVERDRAW: {\n          return material[PROP_OVERDRAW];\n        }\n        case PROP_TRANSPARENT: {\n          return material[PROP_TRANSPARENT];\n        }\n        case PROP_WIREFRAME: {\n          return material[PROP_WIREFRAME];\n        }\n        case PROP_WIREFRAME_LINEWIDTH: {\n          return Sk.builtin.nmber(material[PROP_WIREFRAME_LINEWIDTH], Sk.builtin.nmber.float$);\n        }\n        case PROP_VISIBLE: {\n          return material[PROP_VISIBLE];\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(materialPy, name, valuePy) {\n      var material = Sk.ffi.remapToJs(materialPy);\n      var value = Sk.ffi.remapToJs(valuePy);\n      switch(name) {\n        case PROP_COLOR: {\n          material[PROP_COLOR] = new THREE.Color(value);\n        }\n        break;\n        case PROP_NAME: {\n          if (isString(value)) {\n            material[PROP_NAME] = value;\n          }\n          else {\n            throw new Error(name + " must be a string");\n          }\n        }\n        break;\n        case PROP_NEEDS_UPDATE: {\n          if (isBoolean(value)) {\n            material[PROP_NEEDS_UPDATE] = value;\n          }\n          else {\n            throw new Error(name + " must be Boolean");\n          }\n        }\n        break;\n        case PROP_OPACITY: {\n          if (isNumber(value)) {\n            material.opacity = value;\n          }\n          else {\n            throw new Sk.builtin.TypeError("\'" + PROP_OPACITY + "\' attribute must be a <type \'float\'>.");\n          }\n        }\n        break;\n        case PROP_OVERDRAW: {\n          if (isBoolean(value)) {\n            material[PROP_OVERDRAW] = value;\n          }\n          else {\n            throw new Error(name + " must be Boolean");\n          }\n        }\n        break;\n        case PROP_TRANSPARENT: {\n          if (isBoolean(value)) {\n            material[PROP_TRANSPARENT] = value;\n          }\n          else {\n            throw new Error(name + " must be Boolean");\n          }\n        }\n        break;\n        case PROP_WIREFRAME: {\n          if (isBoolean(value)) {\n            material[PROP_WIREFRAME] = value;\n          }\n          else {\n            throw new Error(name + " must be Boolean");\n          }\n        }\n        break;\n        case PROP_WIREFRAME_LINEWIDTH: {\n          if (isNumber(value)) {\n            material[PROP_WIREFRAME_LINEWIDTH] = value;\n          }\n          else {\n            throw new Error(name + " must be a number");\n          }\n        }\n        break;\n        case PROP_VISIBLE: {\n          if (isBoolean(value)) {\n            material[PROP_VISIBLE] = value;\n          }\n          else {\n            throw new Error(name + " must be Boolean");\n          }\n        }\n        break;\n        default: {\n          throw new Error(name + " is not an attribute of " + MESH_BASIC_MATERIAL);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(materialPy) {\n      var material = Sk.ffi.remapToJs(materialPy);\n      var args = {};\n      args[PROP_COLOR] = material[PROP_COLOR];\n      args[PROP_WIREFRAME] = material[PROP_WIREFRAME];\n      args[PROP_WIREFRAME_LINEWIDTH] = material[PROP_WIREFRAME_LINEWIDTH];\n      return new Sk.builtin.str(MESH_BASIC_MATERIAL + "(" + JSON.stringify(args) + ")");\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(material) {\n      material = Sk.ffi.remapToJs(material);\n      var parameters = {};\n      parameters[PROP_COLOR] = material[PROP_COLOR];\n      parameters[PROP_WIREFRAME] = material[PROP_WIREFRAME];\n      parameters[PROP_WIREFRAME_LINEWIDTH] = material[PROP_WIREFRAME_LINEWIDTH];\n      var args = [parameters];\n      return new Sk.builtin.str(MESH_BASIC_MATERIAL + "(" + args.map(function(x) {return JSON.stringify(x);}).join(", ") + ")");\n    });\n  }, MESH_BASIC_MATERIAL, []);\n\n  mod[MESH_LAMBERT_MATERIAL] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self, parameters) {\n      self.tp$name = MESH_LAMBERT_MATERIAL;\n      parameters = Sk.ffi.remapToJs(parameters);\n      self.v = new THREE[MESH_LAMBERT_MATERIAL](parameters);\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(materialPy, name) {\n      var material = Sk.ffi.remapToJs(materialPy);\n      switch(name) {\n        case PROP_ID: {\n          return Sk.builtin.nmber(material[PROP_ID], Sk.builtin.nmber.int$);\n        }\n        case PROP_COLOR: {\n          return Sk.misceval.callsim(mod[COLOR], Sk.ffi.referenceToPy(material[PROP_COLOR], COLOR));\n        }\n        case PROP_NAME: {\n          return new Sk.builtin.str(material[PROP_NAME]);\n        }\n        case PROP_NEEDS_UPDATE: {\n          return material[PROP_NEEDS_UPDATE];\n        }\n        case PROP_OPACITY: {\n          return Sk.builtin.nmber(material[PROP_OPACITY], Sk.builtin.nmber.float$);\n        }\n        case PROP_OVERDRAW: {\n          return material[PROP_OVERDRAW];\n        }\n        case PROP_TRANSPARENT: {\n          return material[PROP_TRANSPARENT];\n        }\n        case PROP_VISIBLE: {\n          return material[PROP_VISIBLE];\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(materialPy, name, valuePy) {\n      var material = Sk.ffi.remapToJs(materialPy);\n      var value = Sk.ffi.remapToJs(valuePy);\n      switch(name) {\n        case PROP_COLOR: {\n          material[PROP_COLOR] = new THREE.Color(value);\n        }\n        break;\n        case PROP_NAME: {\n          if (isString(value)) {\n            material[PROP_NAME] = value;\n          }\n          else {\n            throw new Error(name + " must be a string");\n          }\n        }\n        break;\n        case PROP_NEEDS_UPDATE: {\n          if (isBoolean(value)) {\n            material[PROP_NEEDS_UPDATE] = value;\n          }\n          else {\n            throw new Error(name + " must be Boolean");\n          }\n        }\n        break;\n        case PROP_OPACITY: {\n          if (isNumber(value)) {\n            material.opacity = value;\n          }\n          else {\n            throw new Sk.builtin.TypeError("\'" + PROP_OPACITY + "\' attribute must be a <type \'float\'>.");\n          }\n        }\n        break;\n        case PROP_OVERDRAW: {\n          if (isBoolean(value)) {\n            material[PROP_OVERDRAW] = value;\n          }\n          else {\n            throw new Error(name + " must be Boolean");\n          }\n        }\n        break;\n        case PROP_TRANSPARENT: {\n          if (isBoolean(value)) {\n            material[PROP_TRANSPARENT] = value;\n          }\n          else {\n            throw new Error(name + " must be Boolean");\n          }\n        }\n        break;\n        case PROP_WIREFRAME: {\n          if (isBoolean(value)) {\n            material[PROP_WIREFRAME] = value;\n          }\n          else {\n            throw new Error(name + " must be Boolean");\n          }\n        }\n        break;\n        case PROP_WIREFRAME_LINEWIDTH: {\n          if (isNumber(value)) {\n            material[PROP_WIREFRAME_LINEWIDTH] = value;\n          }\n          else {\n            throw new Error(name + " must be a number");\n          }\n        }\n        break;\n        case PROP_VISIBLE: {\n          if (isBoolean(value)) {\n            material[PROP_VISIBLE] = value;\n          }\n          else {\n            throw new Error(name + " must be Boolean");\n          }\n        }\n        break;\n        default: {\n          throw new Error(name + " is not an attribute of " + MESH_LAMBERT_MATERIAL);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(material) {\n      material = Sk.ffi.remapToJs(material);\n      var args = {};\n      return new Sk.builtin.str(MESH_LAMBERT_MATERIAL + "(" + JSON.stringify(args) + ")");\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(material) {\n      material = Sk.ffi.remapToJs(material);\n      var parameters = {};\n      parameters[PROP_COLOR] = material[PROP_COLOR];\n      var args = [parameters];\n      return new Sk.builtin.str(MESH_LAMBERT_MATERIAL + "(" + args.map(function(x) {return JSON.stringify(x);}).join(", ") + ")");\n    });\n  }, MESH_LAMBERT_MATERIAL, []);\n\n  mod[MESH_NORMAL_MATERIAL] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self, parameters) {\n      self.tp$name = MESH_NORMAL_MATERIAL;\n      parameters = Sk.ffi.remapToJs(parameters);\n      self.v = new THREE[MESH_NORMAL_MATERIAL](parameters);\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(self, name) {\n      switch(name) {\n        default: {\n          throw new Error(name + " is not an attribute of " + MESH_NORMAL_MATERIAL);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(material) {\n      material = Sk.ffi.remapToJs(material);\n      var args = {};\n      return new Sk.builtin.str(MESH_NORMAL_MATERIAL + "(" + JSON.stringify(args) + ")");\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(material) {\n      material = Sk.ffi.remapToJs(material);\n      var args = [{}];\n      return new Sk.builtin.str(MESH_NORMAL_MATERIAL + "(" + args.map(function(x) {return JSON.stringify(x);}).join(", ") + ")");\n    });\n  }, MESH_NORMAL_MATERIAL, []);\n\n  mod[MESH_PHONG_MATERIAL] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self, parameters) {\n      self.tp$name = MESH_PHONG_MATERIAL;\n      parameters = Sk.ffi.remapToJs(parameters);\n      self.v = new THREE[MESH_PHONG_MATERIAL](parameters);\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(self, name) {\n      switch(name) {\n        default: {\n          throw new Error(name + " is not an attribute of " + MESH_PHONG_MATERIAL);\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(materialPy, name, valuePy) {\n      var material = Sk.ffi.remapToJs(materialPy);\n      var value = Sk.ffi.remapToJs(valuePy);\n      switch(name) {\n        default: {\n          throw new Error(name + " is not an attribute of " + MESH_PHONG_MATERIAL);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(material) {\n      material = Sk.ffi.remapToJs(material);\n      var args = {};\n      return new Sk.builtin.str(MESH_PHONG_MATERIAL + "(" + JSON.stringify(args) + ")");\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(material) {\n      material = Sk.ffi.remapToJs(material);\n      var args = [{}];\n      return new Sk.builtin.str(MESH_PHONG_MATERIAL + "(" + args.map(function(x) {return JSON.stringify(x);}).join(", ") + ")");\n    });\n  }, MESH_PHONG_MATERIAL, []);\n\n  if (typeof THREE !== \'undefined\') {\n    mod.LineStrip  = Sk.builtin.assk$(THREE.LineStrip,  Sk.builtin.nmber.int$);\n    mod.LinePieces = Sk.builtin.assk$(THREE.LinePieces, Sk.builtin.nmber.int$);\n\n    mod.FlatShading   = Sk.builtin.assk$(THREE.FlatShading,   Sk.builtin.nmber.int$);\n    mod.NoShading     = Sk.builtin.assk$(THREE.NoShading,     Sk.builtin.nmber.int$);\n    mod.SmoothShading = Sk.builtin.assk$(THREE.SmoothShading, Sk.builtin.nmber.int$);\n  }\n\n  return mod;\n}\n'
  }
};
!function ($) {
  'use strict';
  var Carousel = function (element, options) {
    this.$element = $(element);
    this.$indicators = this.$element.find('.carousel-indicators');
    this.options = options;
    this.options.pause == 'hover' && this.$element.on('mouseenter', $.proxy(this.pause, this)).on('mouseleave', $.proxy(this.cycle, this));
  };
  Carousel.prototype = {
    cycle: function (e) {
      if (!e)
        this.paused = false;
      if (this.interval)
        clearInterval(this.interval);
      this.options.interval && !this.paused && (this.interval = setInterval($.proxy(this.next, this), this.options.interval));
      return this;
    },
    getActiveIndex: function () {
      this.$active = this.$element.find('.item.active');
      this.$items = this.$active.parent().children();
      return this.$items.index(this.$active);
    },
    to: function (pos) {
      var activeIndex = this.getActiveIndex(), that = this;
      if (pos > this.$items.length - 1 || pos < 0)
        return;
      if (this.sliding) {
        return this.$element.one('slid', function () {
          that.to(pos);
        });
      }
      if (activeIndex == pos) {
        return this.pause().cycle();
      }
      return this.slide(pos > activeIndex ? 'next' : 'prev', $(this.$items[pos]));
    },
    pause: function (e) {
      if (!e)
        this.paused = true;
      if (this.$element.find('.next, .prev').length && $.support.transition.end) {
        this.$element.trigger($.support.transition.end);
        this.cycle(true);
      }
      clearInterval(this.interval);
      this.interval = null;
      return this;
    },
    next: function () {
      if (this.sliding)
        return;
      return this.slide('next');
    },
    prev: function () {
      if (this.sliding)
        return;
      return this.slide('prev');
    },
    slide: function (type, next) {
      var $active = this.$element.find('.item.active'), $next = next || $active[type](), isCycling = this.interval, direction = type == 'next' ? 'left' : 'right', fallback = type == 'next' ? 'first' : 'last', that = this, e;
      this.sliding = true;
      isCycling && this.pause();
      $next = $next.length ? $next : this.$element.find('.item')[fallback]();
      e = $.Event('slide', {
        relatedTarget: $next[0],
        direction: direction
      });
      if ($next.hasClass('active'))
        return;
      if (this.$indicators.length) {
        this.$indicators.find('.active').removeClass('active');
        this.$element.one('slid', function () {
          var $nextIndicator = $(that.$indicators.children()[that.getActiveIndex()]);
          $nextIndicator && $nextIndicator.addClass('active');
        });
      }
      if ($.support.transition && this.$element.hasClass('slide')) {
        this.$element.trigger(e);
        if (e.isDefaultPrevented())
          return;
        $next.addClass(type);
        $next[0].offsetWidth;
        $active.addClass(direction);
        $next.addClass(direction);
        this.$element.one($.support.transition.end, function () {
          $next.removeClass([
            type,
            direction
          ].join(' ')).addClass('active');
          $active.removeClass([
            'active',
            direction
          ].join(' '));
          that.sliding = false;
          setTimeout(function () {
            that.$element.trigger('slid');
          }, 0);
        });
      } else {
        this.$element.trigger(e);
        if (e.isDefaultPrevented())
          return;
        $active.removeClass('active');
        $next.addClass('active');
        this.sliding = false;
        this.$element.trigger('slid');
      }
      isCycling && this.cycle();
      return this;
    }
  };
  var old = $.fn.carousel;
  $.fn.carousel = function (option) {
    return this.each(function () {
      var $this = $(this), data = $this.data('carousel'), options = $.extend({}, $.fn.carousel.defaults, typeof option == 'object' && option), action = typeof option == 'string' ? option : options.slide;
      if (!data)
        $this.data('carousel', data = new Carousel(this, options));
      if (typeof option == 'number')
        data.to(option);
      else if (action)
        data[action]();
      else if (options.interval)
        data.pause().cycle();
    });
  };
  $.fn.carousel.defaults = {
    interval: 5000,
    pause: 'hover'
  };
  $.fn.carousel.Constructor = Carousel;
  $.fn.carousel.noConflict = function () {
    $.fn.carousel = old;
    return this;
  };
  $(document).on('click.carousel.data-api', '[data-slide], [data-slide-to]', function (e) {
    var $this = $(this), href, $target = $($this.attr('data-target') || (href = $this.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '')), options = $.extend({}, $target.data(), $this.data()), slideIndex;
    $target.carousel(options);
    if (slideIndex = $this.attr('data-slide-to')) {
      $target.data('carousel').pause().to(slideIndex).cycle();
    }
    e.preventDefault();
  });
}(window.jQuery);
!function ($) {
  'use strict';
  var Collapse = function (element, options) {
    this.$element = $(element);
    this.options = $.extend({}, $.fn.collapse.defaults, options);
    if (this.options.parent) {
      this.$parent = $(this.options.parent);
    }
    this.options.toggle && this.toggle();
  };
  Collapse.prototype = {
    constructor: Collapse,
    dimension: function () {
      var hasWidth = this.$element.hasClass('width');
      return hasWidth ? 'width' : 'height';
    },
    show: function () {
      var dimension, scroll, actives, hasData;
      if (this.transitioning || this.$element.hasClass('in'))
        return;
      dimension = this.dimension();
      scroll = $.camelCase([
        'scroll',
        dimension
      ].join('-'));
      actives = this.$parent && this.$parent.find('> .accordion-group > .in');
      if (actives && actives.length) {
        hasData = actives.data('collapse');
        if (hasData && hasData.transitioning)
          return;
        actives.collapse('hide');
        hasData || actives.data('collapse', null);
      }
      this.$element[dimension](0);
      this.transition('addClass', $.Event('show'), 'shown');
      $.support.transition && this.$element[dimension](this.$element[0][scroll]);
    },
    hide: function () {
      var dimension;
      if (this.transitioning || !this.$element.hasClass('in'))
        return;
      dimension = this.dimension();
      this.reset(this.$element[dimension]());
      this.transition('removeClass', $.Event('hide'), 'hidden');
      this.$element[dimension](0);
    },
    reset: function (size) {
      var dimension = this.dimension();
      this.$element.removeClass('collapse')[dimension](size || 'auto')[0].offsetWidth;
      this.$element[size !== null ? 'addClass' : 'removeClass']('collapse');
      return this;
    },
    transition: function (method, startEvent, completeEvent) {
      var that = this, complete = function () {
          if (startEvent.type == 'show')
            that.reset();
          that.transitioning = 0;
          that.$element.trigger(completeEvent);
        };
      this.$element.trigger(startEvent);
      if (startEvent.isDefaultPrevented())
        return;
      this.transitioning = 1;
      this.$element[method]('in');
      $.support.transition && this.$element.hasClass('collapse') ? this.$element.one($.support.transition.end, complete) : complete();
    },
    toggle: function () {
      this[this.$element.hasClass('in') ? 'hide' : 'show']();
    }
  };
  var old = $.fn.collapse;
  $.fn.collapse = function (option) {
    return this.each(function () {
      var $this = $(this), data = $this.data('collapse'), options = $.extend({}, $.fn.collapse.defaults, $this.data(), typeof option == 'object' && option);
      if (!data)
        $this.data('collapse', data = new Collapse(this, options));
      if (typeof option == 'string')
        data[option]();
    });
  };
  $.fn.collapse.defaults = { toggle: true };
  $.fn.collapse.Constructor = Collapse;
  $.fn.collapse.noConflict = function () {
    $.fn.collapse = old;
    return this;
  };
  $(document).on('click.collapse.data-api', '[data-toggle=collapse]', function (e) {
    var $this = $(this), href, target = $this.attr('data-target') || e.preventDefault() || (href = $this.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, ''), option = $(target).data('collapse') ? 'toggle' : $this.data();
    $this[$(target).hasClass('in') ? 'addClass' : 'removeClass']('collapsed');
    $(target).collapse(option);
  });
}(window.jQuery);
!function ($) {
  'use strict';
  var toggle = '[data-toggle=dropdown]', Dropdown = function (element) {
      var $el = $(element).on('click.dropdown.data-api', this.toggle);
      $('html').on('click.dropdown.data-api', function () {
        $el.parent().removeClass('open');
      });
    };
  Dropdown.prototype = {
    constructor: Dropdown,
    toggle: function (e) {
      var $this = $(this), $parent, isActive;
      if ($this.is('.disabled, :disabled'))
        return;
      $parent = getParent($this);
      isActive = $parent.hasClass('open');
      clearMenus();
      if (!isActive) {
        if ('ontouchstart' in document.documentElement) {
          $('<div class="dropdown-backdrop"/>').insertBefore($(this)).on('click', clearMenus);
        }
        $parent.toggleClass('open');
      }
      $this.focus();
      return false;
    },
    keydown: function (e) {
      var $this, $items, $active, $parent, isActive, index;
      if (!/(38|40|27)/.test(e.keyCode))
        return;
      $this = $(this);
      e.preventDefault();
      e.stopPropagation();
      if ($this.is('.disabled, :disabled'))
        return;
      $parent = getParent($this);
      isActive = $parent.hasClass('open');
      if (!isActive || isActive && e.keyCode == 27) {
        if (e.which == 27)
          $parent.find(toggle).focus();
        return $this.click();
      }
      $items = $('[role=menu] li:not(.divider):visible a', $parent);
      if (!$items.length)
        return;
      index = $items.index($items.filter(':focus'));
      if (e.keyCode == 38 && index > 0)
        index--;
      if (e.keyCode == 40 && index < $items.length - 1)
        index++;
      if (!~index)
        index = 0;
      $items.eq(index).focus();
    }
  };
  function clearMenus() {
    $('.dropdown-backdrop').remove();
    $(toggle).each(function () {
      getParent($(this)).removeClass('open');
    });
  }
  function getParent($this) {
    var selector = $this.attr('data-target'), $parent;
    if (!selector) {
      selector = $this.attr('href');
      selector = selector && /#/.test(selector) && selector.replace(/.*(?=#[^\s]*$)/, '');
    }
    $parent = selector && $(selector);
    if (!$parent || !$parent.length)
      $parent = $this.parent();
    return $parent;
  }
  var old = $.fn.dropdown;
  $.fn.dropdown = function (option) {
    return this.each(function () {
      var $this = $(this), data = $this.data('dropdown');
      if (!data)
        $this.data('dropdown', data = new Dropdown(this));
      if (typeof option == 'string')
        data[option].call($this);
    });
  };
  $.fn.dropdown.Constructor = Dropdown;
  $.fn.dropdown.noConflict = function () {
    $.fn.dropdown = old;
    return this;
  };
  $(document).on('click.dropdown.data-api', clearMenus).on('click.dropdown.data-api', '.dropdown form', function (e) {
    e.stopPropagation();
  }).on('click.dropdown.data-api', toggle, Dropdown.prototype.toggle).on('keydown.dropdown.data-api', toggle + ', [role=menu]', Dropdown.prototype.keydown);
}(window.jQuery);
!function ($) {
  'use strict';
  var Modal = function (element, options) {
    this.options = options;
    this.$element = $(element).delegate('[data-dismiss="modal"]', 'click.dismiss.modal', $.proxy(this.hide, this));
    this.options.remote && this.$element.find('.modal-body').load(this.options.remote);
  };
  Modal.prototype = {
    constructor: Modal,
    toggle: function () {
      return this[!this.isShown ? 'show' : 'hide']();
    },
    show: function () {
      var that = this, e = $.Event('show');
      this.$element.trigger(e);
      if (this.isShown || e.isDefaultPrevented())
        return;
      this.isShown = true;
      this.escape();
      this.backdrop(function () {
        var transition = $.support.transition && that.$element.hasClass('fade');
        if (!that.$element.parent().length) {
          that.$element.appendTo(document.body);
        }
        that.$element.show();
        if (transition) {
          that.$element[0].offsetWidth;
        }
        that.$element.addClass('in').attr('aria-hidden', false);
        that.enforceFocus();
        transition ? that.$element.one($.support.transition.end, function () {
          that.$element.focus().trigger('shown');
        }) : that.$element.focus().trigger('shown');
      });
    },
    hide: function (e) {
      e && e.preventDefault();
      var that = this;
      e = $.Event('hide');
      this.$element.trigger(e);
      if (!this.isShown || e.isDefaultPrevented())
        return;
      this.isShown = false;
      this.escape();
      $(document).off('focusin.modal');
      this.$element.removeClass('in').attr('aria-hidden', true);
      $.support.transition && this.$element.hasClass('fade') ? this.hideWithTransition() : this.hideModal();
    },
    enforceFocus: function () {
      var that = this;
      $(document).on('focusin.modal', function (e) {
        if (that.$element[0] !== e.target && !that.$element.has(e.target).length) {
          that.$element.focus();
        }
      });
    },
    escape: function () {
      var that = this;
      if (this.isShown && this.options.keyboard) {
        this.$element.on('keyup.dismiss.modal', function (e) {
          e.which == 27 && that.hide();
        });
      } else if (!this.isShown) {
        this.$element.off('keyup.dismiss.modal');
      }
    },
    hideWithTransition: function () {
      var that = this, timeout = setTimeout(function () {
          that.$element.off($.support.transition.end);
          that.hideModal();
        }, 500);
      this.$element.one($.support.transition.end, function () {
        clearTimeout(timeout);
        that.hideModal();
      });
    },
    hideModal: function () {
      var that = this;
      this.$element.hide();
      this.backdrop(function () {
        that.removeBackdrop();
        that.$element.trigger('hidden');
      });
    },
    removeBackdrop: function () {
      this.$backdrop && this.$backdrop.remove();
      this.$backdrop = null;
    },
    backdrop: function (callback) {
      var that = this, animate = this.$element.hasClass('fade') ? 'fade' : '';
      if (this.isShown && this.options.backdrop) {
        var doAnimate = $.support.transition && animate;
        this.$backdrop = $('<div class="modal-backdrop ' + animate + '" />').appendTo(document.body);
        this.$backdrop.click(this.options.backdrop == 'static' ? $.proxy(this.$element[0].focus, this.$element[0]) : $.proxy(this.hide, this));
        if (doAnimate)
          this.$backdrop[0].offsetWidth;
        this.$backdrop.addClass('in');
        if (!callback)
          return;
        doAnimate ? this.$backdrop.one($.support.transition.end, callback) : callback();
      } else if (!this.isShown && this.$backdrop) {
        this.$backdrop.removeClass('in');
        $.support.transition && this.$element.hasClass('fade') ? this.$backdrop.one($.support.transition.end, callback) : callback();
      } else if (callback) {
        callback();
      }
    }
  };
  var old = $.fn.modal;
  $.fn.modal = function (option) {
    return this.each(function () {
      var $this = $(this), data = $this.data('modal'), options = $.extend({}, $.fn.modal.defaults, $this.data(), typeof option == 'object' && option);
      if (!data)
        $this.data('modal', data = new Modal(this, options));
      if (typeof option == 'string')
        data[option]();
      else if (options.show)
        data.show();
    });
  };
  $.fn.modal.defaults = {
    backdrop: true,
    keyboard: true,
    show: true
  };
  $.fn.modal.Constructor = Modal;
  $.fn.modal.noConflict = function () {
    $.fn.modal = old;
    return this;
  };
  $(document).on('click.modal.data-api', '[data-toggle="modal"]', function (e) {
    var $this = $(this), href = $this.attr('href'), $target = $($this.attr('data-target') || href && href.replace(/.*(?=#[^\s]+$)/, '')), option = $target.data('modal') ? 'toggle' : $.extend({ remote: !/#/.test(href) && href }, $target.data(), $this.data());
    e.preventDefault();
    $target.modal(option).one('hide', function () {
      $this.focus();
    });
  });
}(window.jQuery);
!function ($) {
  'use strict';
  var Tab = function (element) {
    this.element = $(element);
  };
  Tab.prototype = {
    constructor: Tab,
    show: function () {
      var $this = this.element, $ul = $this.closest('ul:not(.dropdown-menu)'), selector = $this.attr('data-target'), previous, $target, e;
      if (!selector) {
        selector = $this.attr('href');
        selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '');
      }
      if ($this.parent('li').hasClass('active'))
        return;
      previous = $ul.find('.active:last a')[0];
      e = $.Event('show', { relatedTarget: previous });
      $this.trigger(e);
      if (e.isDefaultPrevented())
        return;
      $target = $(selector);
      this.activate($this.parent('li'), $ul);
      this.activate($target, $target.parent(), function () {
        $this.trigger({
          type: 'shown',
          relatedTarget: previous
        });
      });
    },
    activate: function (element, container, callback) {
      var $active = container.find('> .active'), transition = callback && $.support.transition && $active.hasClass('fade');
      function next() {
        $active.removeClass('active').find('> .dropdown-menu > .active').removeClass('active');
        element.addClass('active');
        if (transition) {
          element[0].offsetWidth;
          element.addClass('in');
        } else {
          element.removeClass('fade');
        }
        if (element.parent('.dropdown-menu')) {
          element.closest('li.dropdown').addClass('active');
        }
        callback && callback();
      }
      transition ? $active.one($.support.transition.end, next) : next();
      $active.removeClass('in');
    }
  };
  var old = $.fn.tab;
  $.fn.tab = function (option) {
    return this.each(function () {
      var $this = $(this), data = $this.data('tab');
      if (!data)
        $this.data('tab', data = new Tab(this));
      if (typeof option == 'string')
        data[option]();
    });
  };
  $.fn.tab.Constructor = Tab;
  $.fn.tab.noConflict = function () {
    $.fn.tab = old;
    return this;
  };
  $(document).on('click.tab.data-api', '[data-toggle="tab"], [data-toggle="pill"]', function (e) {
    e.preventDefault();
    $(this).tab('show');
  });
}(window.jQuery);
!function ($) {
  'use strict';
  $(function () {
    $.support.transition = function () {
      var transitionEnd = function () {
          var el = document.createElement('bootstrap'), transEndEventNames = {
              'WebkitTransition': 'webkitTransitionEnd',
              'MozTransition': 'transitionend',
              'OTransition': 'oTransitionEnd otransitionend',
              'transition': 'transitionend'
            }, name;
          for (name in transEndEventNames) {
            if (el.style[name] !== undefined) {
              return transEndEventNames[name];
            }
          }
        }();
      return transitionEnd && { end: transitionEnd };
    }();
  });
}(window.jQuery);
(function (window, document, undefined) {
  'use strict';
  var lowercase = function (string) {
    return isString(string) ? string.toLowerCase() : string;
  };
  var uppercase = function (string) {
    return isString(string) ? string.toUpperCase() : string;
  };
  var manualLowercase = function (s) {
    return isString(s) ? s.replace(/[A-Z]/g, function (ch) {
      return String.fromCharCode(ch.charCodeAt(0) | 32);
    }) : s;
  };
  var manualUppercase = function (s) {
    return isString(s) ? s.replace(/[a-z]/g, function (ch) {
      return String.fromCharCode(ch.charCodeAt(0) & ~32);
    }) : s;
  };
  if ('i' !== 'I'.toLowerCase()) {
    lowercase = manualLowercase;
    uppercase = manualUppercase;
  }
  var msie = int((/msie (\d+)/.exec(lowercase(navigator.userAgent)) || [])[1]), jqLite, jQuery, slice = [].slice, push = [].push, toString = Object.prototype.toString, angular = window.angular || (window.angular = {}), angularModule, nodeName_, uid = [
      '0',
      '0',
      '0'
    ];
  function isArrayLike(obj) {
    if (!obj || typeof obj.length !== 'number')
      return false;
    if (typeof obj.hasOwnProperty != 'function' && typeof obj.constructor != 'function') {
      return true;
    } else {
      return obj instanceof JQLite || jQuery && obj instanceof jQuery || toString.call(obj) !== '[object Object]' || typeof obj.callee === 'function';
    }
  }
  function forEach(obj, iterator, context) {
    var key;
    if (obj) {
      if (isFunction(obj)) {
        for (key in obj) {
          if (key != 'prototype' && key != 'length' && key != 'name' && obj.hasOwnProperty(key)) {
            iterator.call(context, obj[key], key);
          }
        }
      } else if (obj.forEach && obj.forEach !== forEach) {
        obj.forEach(iterator, context);
      } else if (isArrayLike(obj)) {
        for (key = 0; key < obj.length; key++)
          iterator.call(context, obj[key], key);
      } else {
        for (key in obj) {
          if (obj.hasOwnProperty(key)) {
            iterator.call(context, obj[key], key);
          }
        }
      }
    }
    return obj;
  }
  function sortedKeys(obj) {
    var keys = [];
    for (var key in obj) {
      if (obj.hasOwnProperty(key)) {
        keys.push(key);
      }
    }
    return keys.sort();
  }
  function forEachSorted(obj, iterator, context) {
    var keys = sortedKeys(obj);
    for (var i = 0; i < keys.length; i++) {
      iterator.call(context, obj[keys[i]], keys[i]);
    }
    return keys;
  }
  function reverseParams(iteratorFn) {
    return function (value, key) {
      iteratorFn(key, value);
    };
  }
  function nextUid() {
    var index = uid.length;
    var digit;
    while (index) {
      index--;
      digit = uid[index].charCodeAt(0);
      if (digit == 57) {
        uid[index] = 'A';
        return uid.join('');
      }
      if (digit == 90) {
        uid[index] = '0';
      } else {
        uid[index] = String.fromCharCode(digit + 1);
        return uid.join('');
      }
    }
    uid.unshift('0');
    return uid.join('');
  }
  function setHashKey(obj, h) {
    if (h) {
      obj.$$hashKey = h;
    } else {
      delete obj.$$hashKey;
    }
  }
  function extend(dst) {
    var h = dst.$$hashKey;
    forEach(arguments, function (obj) {
      if (obj !== dst) {
        forEach(obj, function (value, key) {
          dst[key] = value;
        });
      }
    });
    setHashKey(dst, h);
    return dst;
  }
  function int(str) {
    return parseInt(str, 10);
  }
  function inherit(parent, extra) {
    return extend(new (extend(function () {
    }, { prototype: parent }))(), extra);
  }
  function noop() {
  }
  noop.$inject = [];
  function identity($) {
    return $;
  }
  identity.$inject = [];
  function valueFn(value) {
    return function () {
      return value;
    };
  }
  function isUndefined(value) {
    return typeof value == 'undefined';
  }
  function isDefined(value) {
    return typeof value != 'undefined';
  }
  function isObject(value) {
    return value != null && typeof value == 'object';
  }
  function isString(value) {
    return typeof value == 'string';
  }
  function isNumber(value) {
    return typeof value == 'number';
  }
  function isDate(value) {
    return toString.apply(value) == '[object Date]';
  }
  function isArray(value) {
    return toString.apply(value) == '[object Array]';
  }
  function isFunction(value) {
    return typeof value == 'function';
  }
  function isWindow(obj) {
    return obj && obj.document && obj.location && obj.alert && obj.setInterval;
  }
  function isScope(obj) {
    return obj && obj.$evalAsync && obj.$watch;
  }
  function isFile(obj) {
    return toString.apply(obj) === '[object File]';
  }
  function isBoolean(value) {
    return typeof value == 'boolean';
  }
  function trim(value) {
    return isString(value) ? value.replace(/^\s*/, '').replace(/\s*$/, '') : value;
  }
  function isElement(node) {
    return node && (node.nodeName || node.bind && node.find);
  }
  function makeMap(str) {
    var obj = {}, items = str.split(','), i;
    for (i = 0; i < items.length; i++)
      obj[items[i]] = true;
    return obj;
  }
  if (msie < 9) {
    nodeName_ = function (element) {
      element = element.nodeName ? element : element[0];
      return element.scopeName && element.scopeName != 'HTML' ? uppercase(element.scopeName + ':' + element.nodeName) : element.nodeName;
    };
  } else {
    nodeName_ = function (element) {
      return element.nodeName ? element.nodeName : element[0].nodeName;
    };
  }
  function map(obj, iterator, context) {
    var results = [];
    forEach(obj, function (value, index, list) {
      results.push(iterator.call(context, value, index, list));
    });
    return results;
  }
  function size(obj, ownPropsOnly) {
    var size = 0, key;
    if (isArray(obj) || isString(obj)) {
      return obj.length;
    } else if (isObject(obj)) {
      for (key in obj)
        if (!ownPropsOnly || obj.hasOwnProperty(key))
          size++;
    }
    return size;
  }
  function includes(array, obj) {
    return indexOf(array, obj) != -1;
  }
  function indexOf(array, obj) {
    if (array.indexOf)
      return array.indexOf(obj);
    for (var i = 0; i < array.length; i++) {
      if (obj === array[i])
        return i;
    }
    return -1;
  }
  function arrayRemove(array, value) {
    var index = indexOf(array, value);
    if (index >= 0)
      array.splice(index, 1);
    return value;
  }
  function isLeafNode(node) {
    if (node) {
      switch (node.nodeName) {
      case 'OPTION':
      case 'PRE':
      case 'TITLE':
        return true;
      }
    }
    return false;
  }
  function copy(source, destination) {
    if (isWindow(source) || isScope(source))
      throw Error('Can\'t copy Window or Scope');
    if (!destination) {
      destination = source;
      if (source) {
        if (isArray(source)) {
          destination = copy(source, []);
        } else if (isDate(source)) {
          destination = new Date(source.getTime());
        } else if (isObject(source)) {
          destination = copy(source, {});
        }
      }
    } else {
      if (source === destination)
        throw Error('Can\'t copy equivalent objects or arrays');
      if (isArray(source)) {
        destination.length = 0;
        for (var i = 0; i < source.length; i++) {
          destination.push(copy(source[i]));
        }
      } else {
        var h = destination.$$hashKey;
        forEach(destination, function (value, key) {
          delete destination[key];
        });
        for (var key in source) {
          destination[key] = copy(source[key]);
        }
        setHashKey(destination, h);
      }
    }
    return destination;
  }
  function shallowCopy(src, dst) {
    dst = dst || {};
    for (var key in src) {
      if (src.hasOwnProperty(key) && key.substr(0, 2) !== '$$') {
        dst[key] = src[key];
      }
    }
    return dst;
  }
  function equals(o1, o2) {
    if (o1 === o2)
      return true;
    if (o1 === null || o2 === null)
      return false;
    if (o1 !== o1 && o2 !== o2)
      return true;
    var t1 = typeof o1, t2 = typeof o2, length, key, keySet;
    if (t1 == t2) {
      if (t1 == 'object') {
        if (isArray(o1)) {
          if ((length = o1.length) == o2.length) {
            for (key = 0; key < length; key++) {
              if (!equals(o1[key], o2[key]))
                return false;
            }
            return true;
          }
        } else if (isDate(o1)) {
          return isDate(o2) && o1.getTime() == o2.getTime();
        } else {
          if (isScope(o1) || isScope(o2) || isWindow(o1) || isWindow(o2))
            return false;
          keySet = {};
          for (key in o1) {
            if (key.charAt(0) === '$' || isFunction(o1[key]))
              continue;
            if (!equals(o1[key], o2[key]))
              return false;
            keySet[key] = true;
          }
          for (key in o2) {
            if (!keySet[key] && key.charAt(0) !== '$' && o2[key] !== undefined && !isFunction(o2[key]))
              return false;
          }
          return true;
        }
      }
    }
    return false;
  }
  function concat(array1, array2, index) {
    return array1.concat(slice.call(array2, index));
  }
  function sliceArgs(args, startIndex) {
    return slice.call(args, startIndex || 0);
  }
  function bind(self, fn) {
    var curryArgs = arguments.length > 2 ? sliceArgs(arguments, 2) : [];
    if (isFunction(fn) && !(fn instanceof RegExp)) {
      return curryArgs.length ? function () {
        return arguments.length ? fn.apply(self, curryArgs.concat(slice.call(arguments, 0))) : fn.apply(self, curryArgs);
      } : function () {
        return arguments.length ? fn.apply(self, arguments) : fn.call(self);
      };
    } else {
      return fn;
    }
  }
  function toJsonReplacer(key, value) {
    var val = value;
    if (/^\$+/.test(key)) {
      val = undefined;
    } else if (isWindow(value)) {
      val = '$WINDOW';
    } else if (value && document === value) {
      val = '$DOCUMENT';
    } else if (isScope(value)) {
      val = '$SCOPE';
    }
    return val;
  }
  function toJson(obj, pretty) {
    return JSON.stringify(obj, toJsonReplacer, pretty ? '  ' : null);
  }
  function fromJson(json) {
    return isString(json) ? JSON.parse(json) : json;
  }
  function toBoolean(value) {
    if (value && value.length !== 0) {
      var v = lowercase('' + value);
      value = !(v == 'f' || v == '0' || v == 'false' || v == 'no' || v == 'n' || v == '[]');
    } else {
      value = false;
    }
    return value;
  }
  function startingTag(element) {
    element = jqLite(element).clone();
    try {
      element.html('');
    } catch (e) {
    }
    var TEXT_NODE = 3;
    var elemHtml = jqLite('<div>').append(element).html();
    try {
      return element[0].nodeType === TEXT_NODE ? lowercase(elemHtml) : elemHtml.match(/^(<[^>]+>)/)[1].replace(/^<([\w\-]+)/, function (match, nodeName) {
        return '<' + lowercase(nodeName);
      });
    } catch (e) {
      return lowercase(elemHtml);
    }
  }
  function parseKeyValue(keyValue) {
    var obj = {}, key_value, key;
    forEach((keyValue || '').split('&'), function (keyValue) {
      if (keyValue) {
        key_value = keyValue.split('=');
        key = decodeURIComponent(key_value[0]);
        obj[key] = isDefined(key_value[1]) ? decodeURIComponent(key_value[1]) : true;
      }
    });
    return obj;
  }
  function toKeyValue(obj) {
    var parts = [];
    forEach(obj, function (value, key) {
      parts.push(encodeUriQuery(key, true) + (value === true ? '' : '=' + encodeUriQuery(value, true)));
    });
    return parts.length ? parts.join('&') : '';
  }
  function encodeUriSegment(val) {
    return encodeUriQuery(val, true).replace(/%26/gi, '&').replace(/%3D/gi, '=').replace(/%2B/gi, '+');
  }
  function encodeUriQuery(val, pctEncodeSpaces) {
    return encodeURIComponent(val).replace(/%40/gi, '@').replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%20/g, pctEncodeSpaces ? '%20' : '+');
  }
  function angularInit(element, bootstrap) {
    var elements = [element], appElement, module, names = [
        'ng:app',
        'ng-app',
        'x-ng-app',
        'data-ng-app'
      ], NG_APP_CLASS_REGEXP = /\sng[:\-]app(:\s*([\w\d_]+);?)?\s/;
    function append(element) {
      element && elements.push(element);
    }
    forEach(names, function (name) {
      names[name] = true;
      append(document.getElementById(name));
      name = name.replace(':', '\\:');
      if (element.querySelectorAll) {
        forEach(element.querySelectorAll('.' + name), append);
        forEach(element.querySelectorAll('.' + name + '\\:'), append);
        forEach(element.querySelectorAll('[' + name + ']'), append);
      }
    });
    forEach(elements, function (element) {
      if (!appElement) {
        var className = ' ' + element.className + ' ';
        var match = NG_APP_CLASS_REGEXP.exec(className);
        if (match) {
          appElement = element;
          module = (match[2] || '').replace(/\s+/g, ',');
        } else {
          forEach(element.attributes, function (attr) {
            if (!appElement && names[attr.name]) {
              appElement = element;
              module = attr.value;
            }
          });
        }
      }
    });
    if (appElement) {
      bootstrap(appElement, module ? [module] : []);
    }
  }
  function bootstrap(element, modules) {
    var resumeBootstrapInternal = function () {
      element = jqLite(element);
      modules = modules || [];
      modules.unshift([
        '$provide',
        function ($provide) {
          $provide.value('$rootElement', element);
        }
      ]);
      modules.unshift('ng');
      var injector = createInjector(modules);
      injector.invoke([
        '$rootScope',
        '$rootElement',
        '$compile',
        '$injector',
        function (scope, element, compile, injector) {
          scope.$apply(function () {
            element.data('$injector', injector);
            compile(element)(scope);
          });
        }
      ]);
      return injector;
    };
    var NG_DEFER_BOOTSTRAP = /^NG_DEFER_BOOTSTRAP!/;
    if (window && !NG_DEFER_BOOTSTRAP.test(window.name)) {
      return resumeBootstrapInternal();
    }
    window.name = window.name.replace(NG_DEFER_BOOTSTRAP, '');
    angular.resumeBootstrap = function (extraModules) {
      forEach(extraModules, function (module) {
        modules.push(module);
      });
      resumeBootstrapInternal();
    };
  }
  var SNAKE_CASE_REGEXP = /[A-Z]/g;
  function snake_case(name, separator) {
    separator = separator || '_';
    return name.replace(SNAKE_CASE_REGEXP, function (letter, pos) {
      return (pos ? separator : '') + letter.toLowerCase();
    });
  }
  function bindJQuery() {
    jQuery = window.jQuery;
    if (jQuery) {
      jqLite = jQuery;
      extend(jQuery.fn, {
        scope: JQLitePrototype.scope,
        controller: JQLitePrototype.controller,
        injector: JQLitePrototype.injector,
        inheritedData: JQLitePrototype.inheritedData
      });
      JQLitePatchJQueryRemove('remove', true);
      JQLitePatchJQueryRemove('empty');
      JQLitePatchJQueryRemove('html');
    } else {
      jqLite = JQLite;
    }
    angular.element = jqLite;
  }
  function assertArg(arg, name, reason) {
    if (!arg) {
      throw new Error('Argument \'' + (name || '?') + '\' is ' + (reason || 'required'));
    }
    return arg;
  }
  function assertArgFn(arg, name, acceptArrayAnnotation) {
    if (acceptArrayAnnotation && isArray(arg)) {
      arg = arg[arg.length - 1];
    }
    assertArg(isFunction(arg), name, 'not a function, got ' + (arg && typeof arg == 'object' ? arg.constructor.name || 'Object' : typeof arg));
    return arg;
  }
  function setupModuleLoader(window) {
    function ensure(obj, name, factory) {
      return obj[name] || (obj[name] = factory());
    }
    return ensure(ensure(window, 'angular', Object), 'module', function () {
      var modules = {};
      return function module(name, requires, configFn) {
        if (requires && modules.hasOwnProperty(name)) {
          modules[name] = null;
        }
        return ensure(modules, name, function () {
          if (!requires) {
            throw Error('No module: ' + name);
          }
          var invokeQueue = [];
          var runBlocks = [];
          var config = invokeLater('$injector', 'invoke');
          var moduleInstance = {
              _invokeQueue: invokeQueue,
              _runBlocks: runBlocks,
              requires: requires,
              name: name,
              provider: invokeLater('$provide', 'provider'),
              factory: invokeLater('$provide', 'factory'),
              service: invokeLater('$provide', 'service'),
              value: invokeLater('$provide', 'value'),
              constant: invokeLater('$provide', 'constant', 'unshift'),
              filter: invokeLater('$filterProvider', 'register'),
              controller: invokeLater('$controllerProvider', 'register'),
              directive: invokeLater('$compileProvider', 'directive'),
              config: config,
              run: function (block) {
                runBlocks.push(block);
                return this;
              }
            };
          if (configFn) {
            config(configFn);
          }
          return moduleInstance;
          function invokeLater(provider, method, insertMethod) {
            return function () {
              invokeQueue[insertMethod || 'push']([
                provider,
                method,
                arguments
              ]);
              return moduleInstance;
            };
          }
        });
      };
    });
  }
  var version = {
      full: '1.0.7',
      major: 1,
      minor: 0,
      dot: 7,
      codeName: 'monochromatic-rainbow'
    };
  function publishExternalAPI(angular) {
    extend(angular, {
      'bootstrap': bootstrap,
      'copy': copy,
      'extend': extend,
      'equals': equals,
      'element': jqLite,
      'forEach': forEach,
      'injector': createInjector,
      'noop': noop,
      'bind': bind,
      'toJson': toJson,
      'fromJson': fromJson,
      'identity': identity,
      'isUndefined': isUndefined,
      'isDefined': isDefined,
      'isString': isString,
      'isFunction': isFunction,
      'isObject': isObject,
      'isNumber': isNumber,
      'isElement': isElement,
      'isArray': isArray,
      'version': version,
      'isDate': isDate,
      'lowercase': lowercase,
      'uppercase': uppercase,
      'callbacks': { counter: 0 }
    });
    angularModule = setupModuleLoader(window);
    try {
      angularModule('ngLocale');
    } catch (e) {
      angularModule('ngLocale', []).provider('$locale', $LocaleProvider);
    }
    angularModule('ng', ['ngLocale'], [
      '$provide',
      function ngModule($provide) {
        $provide.provider('$compile', $CompileProvider).directive({
          a: htmlAnchorDirective,
          input: inputDirective,
          textarea: inputDirective,
          form: formDirective,
          script: scriptDirective,
          select: selectDirective,
          style: styleDirective,
          option: optionDirective,
          ngBind: ngBindDirective,
          ngBindHtmlUnsafe: ngBindHtmlUnsafeDirective,
          ngBindTemplate: ngBindTemplateDirective,
          ngClass: ngClassDirective,
          ngClassEven: ngClassEvenDirective,
          ngClassOdd: ngClassOddDirective,
          ngCsp: ngCspDirective,
          ngCloak: ngCloakDirective,
          ngController: ngControllerDirective,
          ngForm: ngFormDirective,
          ngHide: ngHideDirective,
          ngInclude: ngIncludeDirective,
          ngInit: ngInitDirective,
          ngNonBindable: ngNonBindableDirective,
          ngPluralize: ngPluralizeDirective,
          ngRepeat: ngRepeatDirective,
          ngShow: ngShowDirective,
          ngSubmit: ngSubmitDirective,
          ngStyle: ngStyleDirective,
          ngSwitch: ngSwitchDirective,
          ngSwitchWhen: ngSwitchWhenDirective,
          ngSwitchDefault: ngSwitchDefaultDirective,
          ngOptions: ngOptionsDirective,
          ngView: ngViewDirective,
          ngTransclude: ngTranscludeDirective,
          ngModel: ngModelDirective,
          ngList: ngListDirective,
          ngChange: ngChangeDirective,
          required: requiredDirective,
          ngRequired: requiredDirective,
          ngValue: ngValueDirective
        }).directive(ngAttributeAliasDirectives).directive(ngEventDirectives);
        $provide.provider({
          $anchorScroll: $AnchorScrollProvider,
          $browser: $BrowserProvider,
          $cacheFactory: $CacheFactoryProvider,
          $controller: $ControllerProvider,
          $document: $DocumentProvider,
          $exceptionHandler: $ExceptionHandlerProvider,
          $filter: $FilterProvider,
          $interpolate: $InterpolateProvider,
          $http: $HttpProvider,
          $httpBackend: $HttpBackendProvider,
          $location: $LocationProvider,
          $log: $LogProvider,
          $parse: $ParseProvider,
          $route: $RouteProvider,
          $routeParams: $RouteParamsProvider,
          $rootScope: $RootScopeProvider,
          $q: $QProvider,
          $sniffer: $SnifferProvider,
          $templateCache: $TemplateCacheProvider,
          $timeout: $TimeoutProvider,
          $window: $WindowProvider
        });
      }
    ]);
  }
  var jqCache = JQLite.cache = {}, jqName = JQLite.expando = 'ng-' + new Date().getTime(), jqId = 1, addEventListenerFn = window.document.addEventListener ? function (element, type, fn) {
      element.addEventListener(type, fn, false);
    } : function (element, type, fn) {
      element.attachEvent('on' + type, fn);
    }, removeEventListenerFn = window.document.removeEventListener ? function (element, type, fn) {
      element.removeEventListener(type, fn, false);
    } : function (element, type, fn) {
      element.detachEvent('on' + type, fn);
    };
  function jqNextId() {
    return ++jqId;
  }
  var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g;
  var MOZ_HACK_REGEXP = /^moz([A-Z])/;
  function camelCase(name) {
    return name.replace(SPECIAL_CHARS_REGEXP, function (_, separator, letter, offset) {
      return offset ? letter.toUpperCase() : letter;
    }).replace(MOZ_HACK_REGEXP, 'Moz$1');
  }
  function JQLitePatchJQueryRemove(name, dispatchThis) {
    var originalJqFn = jQuery.fn[name];
    originalJqFn = originalJqFn.$original || originalJqFn;
    removePatch.$original = originalJqFn;
    jQuery.fn[name] = removePatch;
    function removePatch() {
      var list = [this], fireEvent = dispatchThis, set, setIndex, setLength, element, childIndex, childLength, children, fns, events;
      while (list.length) {
        set = list.shift();
        for (setIndex = 0, setLength = set.length; setIndex < setLength; setIndex++) {
          element = jqLite(set[setIndex]);
          if (fireEvent) {
            element.triggerHandler('$destroy');
          } else {
            fireEvent = !fireEvent;
          }
          for (childIndex = 0, childLength = (children = element.children()).length; childIndex < childLength; childIndex++) {
            list.push(jQuery(children[childIndex]));
          }
        }
      }
      return originalJqFn.apply(this, arguments);
    }
  }
  function JQLite(element) {
    if (element instanceof JQLite) {
      return element;
    }
    if (!(this instanceof JQLite)) {
      if (isString(element) && element.charAt(0) != '<') {
        throw Error('selectors not implemented');
      }
      return new JQLite(element);
    }
    if (isString(element)) {
      var div = document.createElement('div');
      div.innerHTML = '<div>&#160;</div>' + element;
      div.removeChild(div.firstChild);
      JQLiteAddNodes(this, div.childNodes);
      this.remove();
    } else {
      JQLiteAddNodes(this, element);
    }
  }
  function JQLiteClone(element) {
    return element.cloneNode(true);
  }
  function JQLiteDealoc(element) {
    JQLiteRemoveData(element);
    for (var i = 0, children = element.childNodes || []; i < children.length; i++) {
      JQLiteDealoc(children[i]);
    }
  }
  function JQLiteUnbind(element, type, fn) {
    var events = JQLiteExpandoStore(element, 'events'), handle = JQLiteExpandoStore(element, 'handle');
    if (!handle)
      return;
    if (isUndefined(type)) {
      forEach(events, function (eventHandler, type) {
        removeEventListenerFn(element, type, eventHandler);
        delete events[type];
      });
    } else {
      if (isUndefined(fn)) {
        removeEventListenerFn(element, type, events[type]);
        delete events[type];
      } else {
        arrayRemove(events[type], fn);
      }
    }
  }
  function JQLiteRemoveData(element) {
    var expandoId = element[jqName], expandoStore = jqCache[expandoId];
    if (expandoStore) {
      if (expandoStore.handle) {
        expandoStore.events.$destroy && expandoStore.handle({}, '$destroy');
        JQLiteUnbind(element);
      }
      delete jqCache[expandoId];
      element[jqName] = undefined;
    }
  }
  function JQLiteExpandoStore(element, key, value) {
    var expandoId = element[jqName], expandoStore = jqCache[expandoId || -1];
    if (isDefined(value)) {
      if (!expandoStore) {
        element[jqName] = expandoId = jqNextId();
        expandoStore = jqCache[expandoId] = {};
      }
      expandoStore[key] = value;
    } else {
      return expandoStore && expandoStore[key];
    }
  }
  function JQLiteData(element, key, value) {
    var data = JQLiteExpandoStore(element, 'data'), isSetter = isDefined(value), keyDefined = !isSetter && isDefined(key), isSimpleGetter = keyDefined && !isObject(key);
    if (!data && !isSimpleGetter) {
      JQLiteExpandoStore(element, 'data', data = {});
    }
    if (isSetter) {
      data[key] = value;
    } else {
      if (keyDefined) {
        if (isSimpleGetter) {
          return data && data[key];
        } else {
          extend(data, key);
        }
      } else {
        return data;
      }
    }
  }
  function JQLiteHasClass(element, selector) {
    return (' ' + element.className + ' ').replace(/[\n\t]/g, ' ').indexOf(' ' + selector + ' ') > -1;
  }
  function JQLiteRemoveClass(element, cssClasses) {
    if (cssClasses) {
      forEach(cssClasses.split(' '), function (cssClass) {
        element.className = trim((' ' + element.className + ' ').replace(/[\n\t]/g, ' ').replace(' ' + trim(cssClass) + ' ', ' '));
      });
    }
  }
  function JQLiteAddClass(element, cssClasses) {
    if (cssClasses) {
      forEach(cssClasses.split(' '), function (cssClass) {
        if (!JQLiteHasClass(element, cssClass)) {
          element.className = trim(element.className + ' ' + trim(cssClass));
        }
      });
    }
  }
  function JQLiteAddNodes(root, elements) {
    if (elements) {
      elements = !elements.nodeName && isDefined(elements.length) && !isWindow(elements) ? elements : [elements];
      for (var i = 0; i < elements.length; i++) {
        root.push(elements[i]);
      }
    }
  }
  function JQLiteController(element, name) {
    return JQLiteInheritedData(element, '$' + (name || 'ngController') + 'Controller');
  }
  function JQLiteInheritedData(element, name, value) {
    element = jqLite(element);
    if (element[0].nodeType == 9) {
      element = element.find('html');
    }
    while (element.length) {
      if (value = element.data(name))
        return value;
      element = element.parent();
    }
  }
  var JQLitePrototype = JQLite.prototype = {
      ready: function (fn) {
        var fired = false;
        function trigger() {
          if (fired)
            return;
          fired = true;
          fn();
        }
        this.bind('DOMContentLoaded', trigger);
        JQLite(window).bind('load', trigger);
      },
      toString: function () {
        var value = [];
        forEach(this, function (e) {
          value.push('' + e);
        });
        return '[' + value.join(', ') + ']';
      },
      eq: function (index) {
        return index >= 0 ? jqLite(this[index]) : jqLite(this[this.length + index]);
      },
      length: 0,
      push: push,
      sort: [].sort,
      splice: [].splice
    };
  var BOOLEAN_ATTR = {};
  forEach('multiple,selected,checked,disabled,readOnly,required'.split(','), function (value) {
    BOOLEAN_ATTR[lowercase(value)] = value;
  });
  var BOOLEAN_ELEMENTS = {};
  forEach('input,select,option,textarea,button,form'.split(','), function (value) {
    BOOLEAN_ELEMENTS[uppercase(value)] = true;
  });
  function getBooleanAttrName(element, name) {
    var booleanAttr = BOOLEAN_ATTR[name.toLowerCase()];
    return booleanAttr && BOOLEAN_ELEMENTS[element.nodeName] && booleanAttr;
  }
  forEach({
    data: JQLiteData,
    inheritedData: JQLiteInheritedData,
    scope: function (element) {
      return JQLiteInheritedData(element, '$scope');
    },
    controller: JQLiteController,
    injector: function (element) {
      return JQLiteInheritedData(element, '$injector');
    },
    removeAttr: function (element, name) {
      element.removeAttribute(name);
    },
    hasClass: JQLiteHasClass,
    css: function (element, name, value) {
      name = camelCase(name);
      if (isDefined(value)) {
        element.style[name] = value;
      } else {
        var val;
        if (msie <= 8) {
          val = element.currentStyle && element.currentStyle[name];
          if (val === '')
            val = 'auto';
        }
        val = val || element.style[name];
        if (msie <= 8) {
          val = val === '' ? undefined : val;
        }
        return val;
      }
    },
    attr: function (element, name, value) {
      var lowercasedName = lowercase(name);
      if (BOOLEAN_ATTR[lowercasedName]) {
        if (isDefined(value)) {
          if (!!value) {
            element[name] = true;
            element.setAttribute(name, lowercasedName);
          } else {
            element[name] = false;
            element.removeAttribute(lowercasedName);
          }
        } else {
          return element[name] || (element.attributes.getNamedItem(name) || noop).specified ? lowercasedName : undefined;
        }
      } else if (isDefined(value)) {
        element.setAttribute(name, value);
      } else if (element.getAttribute) {
        var ret = element.getAttribute(name, 2);
        return ret === null ? undefined : ret;
      }
    },
    prop: function (element, name, value) {
      if (isDefined(value)) {
        element[name] = value;
      } else {
        return element[name];
      }
    },
    text: extend(msie < 9 ? function (element, value) {
      if (element.nodeType == 1) {
        if (isUndefined(value))
          return element.innerText;
        element.innerText = value;
      } else {
        if (isUndefined(value))
          return element.nodeValue;
        element.nodeValue = value;
      }
    } : function (element, value) {
      if (isUndefined(value)) {
        return element.textContent;
      }
      element.textContent = value;
    }, { $dv: '' }),
    val: function (element, value) {
      if (isUndefined(value)) {
        return element.value;
      }
      element.value = value;
    },
    html: function (element, value) {
      if (isUndefined(value)) {
        return element.innerHTML;
      }
      for (var i = 0, childNodes = element.childNodes; i < childNodes.length; i++) {
        JQLiteDealoc(childNodes[i]);
      }
      element.innerHTML = value;
    }
  }, function (fn, name) {
    JQLite.prototype[name] = function (arg1, arg2) {
      var i, key;
      if ((fn.length == 2 && (fn !== JQLiteHasClass && fn !== JQLiteController) ? arg1 : arg2) === undefined) {
        if (isObject(arg1)) {
          for (i = 0; i < this.length; i++) {
            if (fn === JQLiteData) {
              fn(this[i], arg1);
            } else {
              for (key in arg1) {
                fn(this[i], key, arg1[key]);
              }
            }
          }
          return this;
        } else {
          if (this.length)
            return fn(this[0], arg1, arg2);
        }
      } else {
        for (i = 0; i < this.length; i++) {
          fn(this[i], arg1, arg2);
        }
        return this;
      }
      return fn.$dv;
    };
  });
  function createEventHandler(element, events) {
    var eventHandler = function (event, type) {
      if (!event.preventDefault) {
        event.preventDefault = function () {
          event.returnValue = false;
        };
      }
      if (!event.stopPropagation) {
        event.stopPropagation = function () {
          event.cancelBubble = true;
        };
      }
      if (!event.target) {
        event.target = event.srcElement || document;
      }
      if (isUndefined(event.defaultPrevented)) {
        var prevent = event.preventDefault;
        event.preventDefault = function () {
          event.defaultPrevented = true;
          prevent.call(event);
        };
        event.defaultPrevented = false;
      }
      event.isDefaultPrevented = function () {
        return event.defaultPrevented;
      };
      forEach(events[type || event.type], function (fn) {
        fn.call(element, event);
      });
      if (msie <= 8) {
        event.preventDefault = null;
        event.stopPropagation = null;
        event.isDefaultPrevented = null;
      } else {
        delete event.preventDefault;
        delete event.stopPropagation;
        delete event.isDefaultPrevented;
      }
    };
    eventHandler.elem = element;
    return eventHandler;
  }
  forEach({
    removeData: JQLiteRemoveData,
    dealoc: JQLiteDealoc,
    bind: function bindFn(element, type, fn) {
      var events = JQLiteExpandoStore(element, 'events'), handle = JQLiteExpandoStore(element, 'handle');
      if (!events)
        JQLiteExpandoStore(element, 'events', events = {});
      if (!handle)
        JQLiteExpandoStore(element, 'handle', handle = createEventHandler(element, events));
      forEach(type.split(' '), function (type) {
        var eventFns = events[type];
        if (!eventFns) {
          if (type == 'mouseenter' || type == 'mouseleave') {
            var contains = document.body.contains || document.body.compareDocumentPosition ? function (a, b) {
                var adown = a.nodeType === 9 ? a.documentElement : a, bup = b && b.parentNode;
                return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
              } : function (a, b) {
                if (b) {
                  while (b = b.parentNode) {
                    if (b === a) {
                      return true;
                    }
                  }
                }
                return false;
              };
            events[type] = [];
            var eventmap = {
                mouseleave: 'mouseout',
                mouseenter: 'mouseover'
              };
            bindFn(element, eventmap[type], function (event) {
              var ret, target = this, related = event.relatedTarget;
              if (!related || related !== target && !contains(target, related)) {
                handle(event, type);
              }
            });
          } else {
            addEventListenerFn(element, type, handle);
            events[type] = [];
          }
          eventFns = events[type];
        }
        eventFns.push(fn);
      });
    },
    unbind: JQLiteUnbind,
    replaceWith: function (element, replaceNode) {
      var index, parent = element.parentNode;
      JQLiteDealoc(element);
      forEach(new JQLite(replaceNode), function (node) {
        if (index) {
          parent.insertBefore(node, index.nextSibling);
        } else {
          parent.replaceChild(node, element);
        }
        index = node;
      });
    },
    children: function (element) {
      var children = [];
      forEach(element.childNodes, function (element) {
        if (element.nodeType === 1)
          children.push(element);
      });
      return children;
    },
    contents: function (element) {
      return element.childNodes || [];
    },
    append: function (element, node) {
      forEach(new JQLite(node), function (child) {
        if (element.nodeType === 1)
          element.appendChild(child);
      });
    },
    prepend: function (element, node) {
      if (element.nodeType === 1) {
        var index = element.firstChild;
        forEach(new JQLite(node), function (child) {
          if (index) {
            element.insertBefore(child, index);
          } else {
            element.appendChild(child);
            index = child;
          }
        });
      }
    },
    wrap: function (element, wrapNode) {
      wrapNode = jqLite(wrapNode)[0];
      var parent = element.parentNode;
      if (parent) {
        parent.replaceChild(wrapNode, element);
      }
      wrapNode.appendChild(element);
    },
    remove: function (element) {
      JQLiteDealoc(element);
      var parent = element.parentNode;
      if (parent)
        parent.removeChild(element);
    },
    after: function (element, newElement) {
      var index = element, parent = element.parentNode;
      forEach(new JQLite(newElement), function (node) {
        parent.insertBefore(node, index.nextSibling);
        index = node;
      });
    },
    addClass: JQLiteAddClass,
    removeClass: JQLiteRemoveClass,
    toggleClass: function (element, selector, condition) {
      if (isUndefined(condition)) {
        condition = !JQLiteHasClass(element, selector);
      }
      (condition ? JQLiteAddClass : JQLiteRemoveClass)(element, selector);
    },
    parent: function (element) {
      var parent = element.parentNode;
      return parent && parent.nodeType !== 11 ? parent : null;
    },
    next: function (element) {
      if (element.nextElementSibling) {
        return element.nextElementSibling;
      }
      var elm = element.nextSibling;
      while (elm != null && elm.nodeType !== 1) {
        elm = elm.nextSibling;
      }
      return elm;
    },
    find: function (element, selector) {
      return element.getElementsByTagName(selector);
    },
    clone: JQLiteClone,
    triggerHandler: function (element, eventName) {
      var eventFns = (JQLiteExpandoStore(element, 'events') || {})[eventName];
      forEach(eventFns, function (fn) {
        fn.call(element, null);
      });
    }
  }, function (fn, name) {
    JQLite.prototype[name] = function (arg1, arg2) {
      var value;
      for (var i = 0; i < this.length; i++) {
        if (value == undefined) {
          value = fn(this[i], arg1, arg2);
          if (value !== undefined) {
            value = jqLite(value);
          }
        } else {
          JQLiteAddNodes(value, fn(this[i], arg1, arg2));
        }
      }
      return value == undefined ? this : value;
    };
  });
  function hashKey(obj) {
    var objType = typeof obj, key;
    if (objType == 'object' && obj !== null) {
      if (typeof (key = obj.$$hashKey) == 'function') {
        key = obj.$$hashKey();
      } else if (key === undefined) {
        key = obj.$$hashKey = nextUid();
      }
    } else {
      key = obj;
    }
    return objType + ':' + key;
  }
  function HashMap(array) {
    forEach(array, this.put, this);
  }
  HashMap.prototype = {
    put: function (key, value) {
      this[hashKey(key)] = value;
    },
    get: function (key) {
      return this[hashKey(key)];
    },
    remove: function (key) {
      var value = this[key = hashKey(key)];
      delete this[key];
      return value;
    }
  };
  function HashQueueMap() {
  }
  HashQueueMap.prototype = {
    push: function (key, value) {
      var array = this[key = hashKey(key)];
      if (!array) {
        this[key] = [value];
      } else {
        array.push(value);
      }
    },
    shift: function (key) {
      var array = this[key = hashKey(key)];
      if (array) {
        if (array.length == 1) {
          delete this[key];
          return array[0];
        } else {
          return array.shift();
        }
      }
    },
    peek: function (key) {
      var array = this[hashKey(key)];
      if (array) {
        return array[0];
      }
    }
  };
  var FN_ARGS = /^function\s*[^\(]*\(\s*([^\)]*)\)/m;
  var FN_ARG_SPLIT = /,/;
  var FN_ARG = /^\s*(_?)(\S+?)\1\s*$/;
  var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm;
  function annotate(fn) {
    var $inject, fnText, argDecl, last;
    if (typeof fn == 'function') {
      if (!($inject = fn.$inject)) {
        $inject = [];
        fnText = fn.toString().replace(STRIP_COMMENTS, '');
        argDecl = fnText.match(FN_ARGS);
        forEach(argDecl[1].split(FN_ARG_SPLIT), function (arg) {
          arg.replace(FN_ARG, function (all, underscore, name) {
            $inject.push(name);
          });
        });
        fn.$inject = $inject;
      }
    } else if (isArray(fn)) {
      last = fn.length - 1;
      assertArgFn(fn[last], 'fn');
      $inject = fn.slice(0, last);
    } else {
      assertArgFn(fn, 'fn', true);
    }
    return $inject;
  }
  function createInjector(modulesToLoad) {
    var INSTANTIATING = {}, providerSuffix = 'Provider', path = [], loadedModules = new HashMap(), providerCache = {
        $provide: {
          provider: supportObject(provider),
          factory: supportObject(factory),
          service: supportObject(service),
          value: supportObject(value),
          constant: supportObject(constant),
          decorator: decorator
        }
      }, providerInjector = createInternalInjector(providerCache, function () {
        throw Error('Unknown provider: ' + path.join(' <- '));
      }), instanceCache = {}, instanceInjector = instanceCache.$injector = createInternalInjector(instanceCache, function (servicename) {
        var provider = providerInjector.get(servicename + providerSuffix);
        return instanceInjector.invoke(provider.$get, provider);
      });
    forEach(loadModules(modulesToLoad), function (fn) {
      instanceInjector.invoke(fn || noop);
    });
    return instanceInjector;
    function supportObject(delegate) {
      return function (key, value) {
        if (isObject(key)) {
          forEach(key, reverseParams(delegate));
        } else {
          return delegate(key, value);
        }
      };
    }
    function provider(name, provider_) {
      if (isFunction(provider_) || isArray(provider_)) {
        provider_ = providerInjector.instantiate(provider_);
      }
      if (!provider_.$get) {
        throw Error('Provider ' + name + ' must define $get factory method.');
      }
      return providerCache[name + providerSuffix] = provider_;
    }
    function factory(name, factoryFn) {
      return provider(name, { $get: factoryFn });
    }
    function service(name, constructor) {
      return factory(name, [
        '$injector',
        function ($injector) {
          return $injector.instantiate(constructor);
        }
      ]);
    }
    function value(name, value) {
      return factory(name, valueFn(value));
    }
    function constant(name, value) {
      providerCache[name] = value;
      instanceCache[name] = value;
    }
    function decorator(serviceName, decorFn) {
      var origProvider = providerInjector.get(serviceName + providerSuffix), orig$get = origProvider.$get;
      origProvider.$get = function () {
        var origInstance = instanceInjector.invoke(orig$get, origProvider);
        return instanceInjector.invoke(decorFn, null, { $delegate: origInstance });
      };
    }
    function loadModules(modulesToLoad) {
      var runBlocks = [];
      forEach(modulesToLoad, function (module) {
        if (loadedModules.get(module))
          return;
        loadedModules.put(module, true);
        if (isString(module)) {
          var moduleFn = angularModule(module);
          runBlocks = runBlocks.concat(loadModules(moduleFn.requires)).concat(moduleFn._runBlocks);
          try {
            for (var invokeQueue = moduleFn._invokeQueue, i = 0, ii = invokeQueue.length; i < ii; i++) {
              var invokeArgs = invokeQueue[i], provider = invokeArgs[0] == '$injector' ? providerInjector : providerInjector.get(invokeArgs[0]);
              provider[invokeArgs[1]].apply(provider, invokeArgs[2]);
            }
          } catch (e) {
            if (e.message)
              e.message += ' from ' + module;
            throw e;
          }
        } else if (isFunction(module)) {
          try {
            runBlocks.push(providerInjector.invoke(module));
          } catch (e) {
            if (e.message)
              e.message += ' from ' + module;
            throw e;
          }
        } else if (isArray(module)) {
          try {
            runBlocks.push(providerInjector.invoke(module));
          } catch (e) {
            if (e.message)
              e.message += ' from ' + String(module[module.length - 1]);
            throw e;
          }
        } else {
          assertArgFn(module, 'module');
        }
      });
      return runBlocks;
    }
    function createInternalInjector(cache, factory) {
      function getService(serviceName) {
        if (typeof serviceName !== 'string') {
          throw Error('Service name expected');
        }
        if (cache.hasOwnProperty(serviceName)) {
          if (cache[serviceName] === INSTANTIATING) {
            throw Error('Circular dependency: ' + path.join(' <- '));
          }
          return cache[serviceName];
        } else {
          try {
            path.unshift(serviceName);
            cache[serviceName] = INSTANTIATING;
            return cache[serviceName] = factory(serviceName);
          } finally {
            path.shift();
          }
        }
      }
      function invoke(fn, self, locals) {
        var args = [], $inject = annotate(fn), length, i, key;
        for (i = 0, length = $inject.length; i < length; i++) {
          key = $inject[i];
          args.push(locals && locals.hasOwnProperty(key) ? locals[key] : getService(key));
        }
        if (!fn.$inject) {
          fn = fn[length];
        }
        switch (self ? -1 : args.length) {
        case 0:
          return fn();
        case 1:
          return fn(args[0]);
        case 2:
          return fn(args[0], args[1]);
        case 3:
          return fn(args[0], args[1], args[2]);
        case 4:
          return fn(args[0], args[1], args[2], args[3]);
        case 5:
          return fn(args[0], args[1], args[2], args[3], args[4]);
        case 6:
          return fn(args[0], args[1], args[2], args[3], args[4], args[5]);
        case 7:
          return fn(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
        case 8:
          return fn(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7]);
        case 9:
          return fn(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8]);
        case 10:
          return fn(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9]);
        default:
          return fn.apply(self, args);
        }
      }
      function instantiate(Type, locals) {
        var Constructor = function () {
          }, instance, returnedValue;
        Constructor.prototype = (isArray(Type) ? Type[Type.length - 1] : Type).prototype;
        instance = new Constructor();
        returnedValue = invoke(Type, instance, locals);
        return isObject(returnedValue) ? returnedValue : instance;
      }
      return {
        invoke: invoke,
        instantiate: instantiate,
        get: getService,
        annotate: annotate
      };
    }
  }
  function $AnchorScrollProvider() {
    var autoScrollingEnabled = true;
    this.disableAutoScrolling = function () {
      autoScrollingEnabled = false;
    };
    this.$get = [
      '$window',
      '$location',
      '$rootScope',
      function ($window, $location, $rootScope) {
        var document = $window.document;
        function getFirstAnchor(list) {
          var result = null;
          forEach(list, function (element) {
            if (!result && lowercase(element.nodeName) === 'a')
              result = element;
          });
          return result;
        }
        function scroll() {
          var hash = $location.hash(), elm;
          if (!hash)
            $window.scrollTo(0, 0);
          else if (elm = document.getElementById(hash))
            elm.scrollIntoView();
          else if (elm = getFirstAnchor(document.getElementsByName(hash)))
            elm.scrollIntoView();
          else if (hash === 'top')
            $window.scrollTo(0, 0);
        }
        if (autoScrollingEnabled) {
          $rootScope.$watch(function autoScrollWatch() {
            return $location.hash();
          }, function autoScrollWatchAction() {
            $rootScope.$evalAsync(scroll);
          });
        }
        return scroll;
      }
    ];
  }
  function Browser(window, document, $log, $sniffer) {
    var self = this, rawDocument = document[0], location = window.location, history = window.history, setTimeout = window.setTimeout, clearTimeout = window.clearTimeout, pendingDeferIds = {};
    self.isMock = false;
    var outstandingRequestCount = 0;
    var outstandingRequestCallbacks = [];
    self.$$completeOutstandingRequest = completeOutstandingRequest;
    self.$$incOutstandingRequestCount = function () {
      outstandingRequestCount++;
    };
    function completeOutstandingRequest(fn) {
      try {
        fn.apply(null, sliceArgs(arguments, 1));
      } finally {
        outstandingRequestCount--;
        if (outstandingRequestCount === 0) {
          while (outstandingRequestCallbacks.length) {
            try {
              outstandingRequestCallbacks.pop()();
            } catch (e) {
              $log.error(e);
            }
          }
        }
      }
    }
    self.notifyWhenNoOutstandingRequests = function (callback) {
      forEach(pollFns, function (pollFn) {
        pollFn();
      });
      if (outstandingRequestCount === 0) {
        callback();
      } else {
        outstandingRequestCallbacks.push(callback);
      }
    };
    var pollFns = [], pollTimeout;
    self.addPollFn = function (fn) {
      if (isUndefined(pollTimeout))
        startPoller(100, setTimeout);
      pollFns.push(fn);
      return fn;
    };
    function startPoller(interval, setTimeout) {
      (function check() {
        forEach(pollFns, function (pollFn) {
          pollFn();
        });
        pollTimeout = setTimeout(check, interval);
      }());
    }
    var lastBrowserUrl = location.href, baseElement = document.find('base');
    self.url = function (url, replace) {
      if (url) {
        if (lastBrowserUrl == url)
          return;
        lastBrowserUrl = url;
        if ($sniffer.history) {
          if (replace)
            history.replaceState(null, '', url);
          else {
            history.pushState(null, '', url);
            baseElement.attr('href', baseElement.attr('href'));
          }
        } else {
          if (replace)
            location.replace(url);
          else
            location.href = url;
        }
        return self;
      } else {
        return location.href.replace(/%27/g, '\'');
      }
    };
    var urlChangeListeners = [], urlChangeInit = false;
    function fireUrlChange() {
      if (lastBrowserUrl == self.url())
        return;
      lastBrowserUrl = self.url();
      forEach(urlChangeListeners, function (listener) {
        listener(self.url());
      });
    }
    self.onUrlChange = function (callback) {
      if (!urlChangeInit) {
        if ($sniffer.history)
          jqLite(window).bind('popstate', fireUrlChange);
        if ($sniffer.hashchange)
          jqLite(window).bind('hashchange', fireUrlChange);
        else
          self.addPollFn(fireUrlChange);
        urlChangeInit = true;
      }
      urlChangeListeners.push(callback);
      return callback;
    };
    self.baseHref = function () {
      var href = baseElement.attr('href');
      return href ? href.replace(/^https?\:\/\/[^\/]*/, '') : '';
    };
    var lastCookies = {};
    var lastCookieString = '';
    var cookiePath = self.baseHref();
    self.cookies = function (name, value) {
      var cookieLength, cookieArray, cookie, i, index;
      if (name) {
        if (value === undefined) {
          rawDocument.cookie = escape(name) + '=;path=' + cookiePath + ';expires=Thu, 01 Jan 1970 00:00:00 GMT';
        } else {
          if (isString(value)) {
            cookieLength = (rawDocument.cookie = escape(name) + '=' + escape(value) + ';path=' + cookiePath).length + 1;
            if (cookieLength > 4096) {
              $log.warn('Cookie \'' + name + '\' possibly not set or overflowed because it was too large (' + cookieLength + ' > 4096 bytes)!');
            }
          }
        }
      } else {
        if (rawDocument.cookie !== lastCookieString) {
          lastCookieString = rawDocument.cookie;
          cookieArray = lastCookieString.split('; ');
          lastCookies = {};
          for (i = 0; i < cookieArray.length; i++) {
            cookie = cookieArray[i];
            index = cookie.indexOf('=');
            if (index > 0) {
              var name = unescape(cookie.substring(0, index));
              if (lastCookies[name] === undefined) {
                lastCookies[name] = unescape(cookie.substring(index + 1));
              }
            }
          }
        }
        return lastCookies;
      }
    };
    self.defer = function (fn, delay) {
      var timeoutId;
      outstandingRequestCount++;
      timeoutId = setTimeout(function () {
        delete pendingDeferIds[timeoutId];
        completeOutstandingRequest(fn);
      }, delay || 0);
      pendingDeferIds[timeoutId] = true;
      return timeoutId;
    };
    self.defer.cancel = function (deferId) {
      if (pendingDeferIds[deferId]) {
        delete pendingDeferIds[deferId];
        clearTimeout(deferId);
        completeOutstandingRequest(noop);
        return true;
      }
      return false;
    };
  }
  function $BrowserProvider() {
    this.$get = [
      '$window',
      '$log',
      '$sniffer',
      '$document',
      function ($window, $log, $sniffer, $document) {
        return new Browser($window, $document, $log, $sniffer);
      }
    ];
  }
  function $CacheFactoryProvider() {
    this.$get = function () {
      var caches = {};
      function cacheFactory(cacheId, options) {
        if (cacheId in caches) {
          throw Error('cacheId ' + cacheId + ' taken');
        }
        var size = 0, stats = extend({}, options, { id: cacheId }), data = {}, capacity = options && options.capacity || Number.MAX_VALUE, lruHash = {}, freshEnd = null, staleEnd = null;
        return caches[cacheId] = {
          put: function (key, value) {
            var lruEntry = lruHash[key] || (lruHash[key] = { key: key });
            refresh(lruEntry);
            if (isUndefined(value))
              return;
            if (!(key in data))
              size++;
            data[key] = value;
            if (size > capacity) {
              this.remove(staleEnd.key);
            }
          },
          get: function (key) {
            var lruEntry = lruHash[key];
            if (!lruEntry)
              return;
            refresh(lruEntry);
            return data[key];
          },
          remove: function (key) {
            var lruEntry = lruHash[key];
            if (!lruEntry)
              return;
            if (lruEntry == freshEnd)
              freshEnd = lruEntry.p;
            if (lruEntry == staleEnd)
              staleEnd = lruEntry.n;
            link(lruEntry.n, lruEntry.p);
            delete lruHash[key];
            delete data[key];
            size--;
          },
          removeAll: function () {
            data = {};
            size = 0;
            lruHash = {};
            freshEnd = staleEnd = null;
          },
          destroy: function () {
            data = null;
            stats = null;
            lruHash = null;
            delete caches[cacheId];
          },
          info: function () {
            return extend({}, stats, { size: size });
          }
        };
        function refresh(entry) {
          if (entry != freshEnd) {
            if (!staleEnd) {
              staleEnd = entry;
            } else if (staleEnd == entry) {
              staleEnd = entry.n;
            }
            link(entry.n, entry.p);
            link(entry, freshEnd);
            freshEnd = entry;
            freshEnd.n = null;
          }
        }
        function link(nextEntry, prevEntry) {
          if (nextEntry != prevEntry) {
            if (nextEntry)
              nextEntry.p = prevEntry;
            if (prevEntry)
              prevEntry.n = nextEntry;
          }
        }
      }
      cacheFactory.info = function () {
        var info = {};
        forEach(caches, function (cache, cacheId) {
          info[cacheId] = cache.info();
        });
        return info;
      };
      cacheFactory.get = function (cacheId) {
        return caches[cacheId];
      };
      return cacheFactory;
    };
  }
  function $TemplateCacheProvider() {
    this.$get = [
      '$cacheFactory',
      function ($cacheFactory) {
        return $cacheFactory('templates');
      }
    ];
  }
  var NON_ASSIGNABLE_MODEL_EXPRESSION = 'Non-assignable model expression: ';
  $CompileProvider.$inject = ['$provide'];
  function $CompileProvider($provide) {
    var hasDirectives = {}, Suffix = 'Directive', COMMENT_DIRECTIVE_REGEXP = /^\s*directive\:\s*([\d\w\-_]+)\s+(.*)$/, CLASS_DIRECTIVE_REGEXP = /(([\d\w\-_]+)(?:\:([^;]+))?;?)/, MULTI_ROOT_TEMPLATE_ERROR = 'Template must have exactly one root element. was: ', urlSanitizationWhitelist = /^\s*(https?|ftp|mailto|file):/;
    this.directive = function registerDirective(name, directiveFactory) {
      if (isString(name)) {
        assertArg(directiveFactory, 'directive');
        if (!hasDirectives.hasOwnProperty(name)) {
          hasDirectives[name] = [];
          $provide.factory(name + Suffix, [
            '$injector',
            '$exceptionHandler',
            function ($injector, $exceptionHandler) {
              var directives = [];
              forEach(hasDirectives[name], function (directiveFactory) {
                try {
                  var directive = $injector.invoke(directiveFactory);
                  if (isFunction(directive)) {
                    directive = { compile: valueFn(directive) };
                  } else if (!directive.compile && directive.link) {
                    directive.compile = valueFn(directive.link);
                  }
                  directive.priority = directive.priority || 0;
                  directive.name = directive.name || name;
                  directive.require = directive.require || directive.controller && directive.name;
                  directive.restrict = directive.restrict || 'A';
                  directives.push(directive);
                } catch (e) {
                  $exceptionHandler(e);
                }
              });
              return directives;
            }
          ]);
        }
        hasDirectives[name].push(directiveFactory);
      } else {
        forEach(name, reverseParams(registerDirective));
      }
      return this;
    };
    this.urlSanitizationWhitelist = function (regexp) {
      if (isDefined(regexp)) {
        urlSanitizationWhitelist = regexp;
        return this;
      }
      return urlSanitizationWhitelist;
    };
    this.$get = [
      '$injector',
      '$interpolate',
      '$exceptionHandler',
      '$http',
      '$templateCache',
      '$parse',
      '$controller',
      '$rootScope',
      '$document',
      function ($injector, $interpolate, $exceptionHandler, $http, $templateCache, $parse, $controller, $rootScope, $document) {
        var Attributes = function (element, attr) {
          this.$$element = element;
          this.$attr = attr || {};
        };
        Attributes.prototype = {
          $normalize: directiveNormalize,
          $set: function (key, value, writeAttr, attrName) {
            var booleanKey = getBooleanAttrName(this.$$element[0], key), $$observers = this.$$observers, normalizedVal;
            if (booleanKey) {
              this.$$element.prop(key, value);
              attrName = booleanKey;
            }
            this[key] = value;
            if (attrName) {
              this.$attr[key] = attrName;
            } else {
              attrName = this.$attr[key];
              if (!attrName) {
                this.$attr[key] = attrName = snake_case(key, '-');
              }
            }
            if (nodeName_(this.$$element[0]) === 'A' && key === 'href') {
              urlSanitizationNode.setAttribute('href', value);
              normalizedVal = urlSanitizationNode.href;
              if (!normalizedVal.match(urlSanitizationWhitelist)) {
                this[key] = value = 'unsafe:' + normalizedVal;
              }
            }
            if (writeAttr !== false) {
              if (value === null || value === undefined) {
                this.$$element.removeAttr(attrName);
              } else {
                this.$$element.attr(attrName, value);
              }
            }
            $$observers && forEach($$observers[key], function (fn) {
              try {
                fn(value);
              } catch (e) {
                $exceptionHandler(e);
              }
            });
          },
          $observe: function (key, fn) {
            var attrs = this, $$observers = attrs.$$observers || (attrs.$$observers = {}), listeners = $$observers[key] || ($$observers[key] = []);
            listeners.push(fn);
            $rootScope.$evalAsync(function () {
              if (!listeners.$$inter) {
                fn(attrs[key]);
              }
            });
            return fn;
          }
        };
        var urlSanitizationNode = $document[0].createElement('a'), startSymbol = $interpolate.startSymbol(), endSymbol = $interpolate.endSymbol(), denormalizeTemplate = startSymbol == '{{' || endSymbol == '}}' ? identity : function denormalizeTemplate(template) {
            return template.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol);
          };
        return compile;
        function compile($compileNodes, transcludeFn, maxPriority) {
          if (!($compileNodes instanceof jqLite)) {
            $compileNodes = jqLite($compileNodes);
          }
          forEach($compileNodes, function (node, index) {
            if (node.nodeType == 3 && node.nodeValue.match(/\S+/)) {
              $compileNodes[index] = jqLite(node).wrap('<span></span>').parent()[0];
            }
          });
          var compositeLinkFn = compileNodes($compileNodes, transcludeFn, $compileNodes, maxPriority);
          return function publicLinkFn(scope, cloneConnectFn) {
            assertArg(scope, 'scope');
            var $linkNode = cloneConnectFn ? JQLitePrototype.clone.call($compileNodes) : $compileNodes;
            for (var i = 0, ii = $linkNode.length; i < ii; i++) {
              var node = $linkNode[i];
              if (node.nodeType == 1 || node.nodeType == 9) {
                $linkNode.eq(i).data('$scope', scope);
              }
            }
            safeAddClass($linkNode, 'ng-scope');
            if (cloneConnectFn)
              cloneConnectFn($linkNode, scope);
            if (compositeLinkFn)
              compositeLinkFn(scope, $linkNode, $linkNode);
            return $linkNode;
          };
        }
        function wrongMode(localName, mode) {
          throw Error('Unsupported \'' + mode + '\' for \'' + localName + '\'.');
        }
        function safeAddClass($element, className) {
          try {
            $element.addClass(className);
          } catch (e) {
          }
        }
        function compileNodes(nodeList, transcludeFn, $rootElement, maxPriority) {
          var linkFns = [], nodeLinkFn, childLinkFn, directives, attrs, linkFnFound;
          for (var i = 0; i < nodeList.length; i++) {
            attrs = new Attributes();
            directives = collectDirectives(nodeList[i], [], attrs, maxPriority);
            nodeLinkFn = directives.length ? applyDirectivesToNode(directives, nodeList[i], attrs, transcludeFn, $rootElement) : null;
            childLinkFn = nodeLinkFn && nodeLinkFn.terminal || !nodeList[i].childNodes || !nodeList[i].childNodes.length ? null : compileNodes(nodeList[i].childNodes, nodeLinkFn ? nodeLinkFn.transclude : transcludeFn);
            linkFns.push(nodeLinkFn);
            linkFns.push(childLinkFn);
            linkFnFound = linkFnFound || nodeLinkFn || childLinkFn;
          }
          return linkFnFound ? compositeLinkFn : null;
          function compositeLinkFn(scope, nodeList, $rootElement, boundTranscludeFn) {
            var nodeLinkFn, childLinkFn, node, childScope, childTranscludeFn, i, ii, n;
            var stableNodeList = [];
            for (i = 0, ii = nodeList.length; i < ii; i++) {
              stableNodeList.push(nodeList[i]);
            }
            for (i = 0, n = 0, ii = linkFns.length; i < ii; n++) {
              node = stableNodeList[n];
              nodeLinkFn = linkFns[i++];
              childLinkFn = linkFns[i++];
              if (nodeLinkFn) {
                if (nodeLinkFn.scope) {
                  childScope = scope.$new(isObject(nodeLinkFn.scope));
                  jqLite(node).data('$scope', childScope);
                } else {
                  childScope = scope;
                }
                childTranscludeFn = nodeLinkFn.transclude;
                if (childTranscludeFn || !boundTranscludeFn && transcludeFn) {
                  nodeLinkFn(childLinkFn, childScope, node, $rootElement, function (transcludeFn) {
                    return function (cloneFn) {
                      var transcludeScope = scope.$new();
                      transcludeScope.$$transcluded = true;
                      return transcludeFn(transcludeScope, cloneFn).bind('$destroy', bind(transcludeScope, transcludeScope.$destroy));
                    };
                  }(childTranscludeFn || transcludeFn));
                } else {
                  nodeLinkFn(childLinkFn, childScope, node, undefined, boundTranscludeFn);
                }
              } else if (childLinkFn) {
                childLinkFn(scope, node.childNodes, undefined, boundTranscludeFn);
              }
            }
          }
        }
        function collectDirectives(node, directives, attrs, maxPriority) {
          var nodeType = node.nodeType, attrsMap = attrs.$attr, match, className;
          switch (nodeType) {
          case 1:
            addDirective(directives, directiveNormalize(nodeName_(node).toLowerCase()), 'E', maxPriority);
            for (var attr, name, nName, value, nAttrs = node.attributes, j = 0, jj = nAttrs && nAttrs.length; j < jj; j++) {
              attr = nAttrs[j];
              if (attr.specified) {
                name = attr.name;
                nName = directiveNormalize(name.toLowerCase());
                attrsMap[nName] = name;
                attrs[nName] = value = trim(msie && name == 'href' ? decodeURIComponent(node.getAttribute(name, 2)) : attr.value);
                if (getBooleanAttrName(node, nName)) {
                  attrs[nName] = true;
                }
                addAttrInterpolateDirective(node, directives, value, nName);
                addDirective(directives, nName, 'A', maxPriority);
              }
            }
            className = node.className;
            if (isString(className) && className !== '') {
              while (match = CLASS_DIRECTIVE_REGEXP.exec(className)) {
                nName = directiveNormalize(match[2]);
                if (addDirective(directives, nName, 'C', maxPriority)) {
                  attrs[nName] = trim(match[3]);
                }
                className = className.substr(match.index + match[0].length);
              }
            }
            break;
          case 3:
            addTextInterpolateDirective(directives, node.nodeValue);
            break;
          case 8:
            try {
              match = COMMENT_DIRECTIVE_REGEXP.exec(node.nodeValue);
              if (match) {
                nName = directiveNormalize(match[1]);
                if (addDirective(directives, nName, 'M', maxPriority)) {
                  attrs[nName] = trim(match[2]);
                }
              }
            } catch (e) {
            }
            break;
          }
          directives.sort(byPriority);
          return directives;
        }
        function applyDirectivesToNode(directives, compileNode, templateAttrs, transcludeFn, jqCollection) {
          var terminalPriority = -Number.MAX_VALUE, preLinkFns = [], postLinkFns = [], newScopeDirective = null, newIsolateScopeDirective = null, templateDirective = null, $compileNode = templateAttrs.$$element = jqLite(compileNode), directive, directiveName, $template, transcludeDirective, childTranscludeFn = transcludeFn, controllerDirectives, linkFn, directiveValue;
          for (var i = 0, ii = directives.length; i < ii; i++) {
            directive = directives[i];
            $template = undefined;
            if (terminalPriority > directive.priority) {
              break;
            }
            if (directiveValue = directive.scope) {
              assertNoDuplicate('isolated scope', newIsolateScopeDirective, directive, $compileNode);
              if (isObject(directiveValue)) {
                safeAddClass($compileNode, 'ng-isolate-scope');
                newIsolateScopeDirective = directive;
              }
              safeAddClass($compileNode, 'ng-scope');
              newScopeDirective = newScopeDirective || directive;
            }
            directiveName = directive.name;
            if (directiveValue = directive.controller) {
              controllerDirectives = controllerDirectives || {};
              assertNoDuplicate('\'' + directiveName + '\' controller', controllerDirectives[directiveName], directive, $compileNode);
              controllerDirectives[directiveName] = directive;
            }
            if (directiveValue = directive.transclude) {
              assertNoDuplicate('transclusion', transcludeDirective, directive, $compileNode);
              transcludeDirective = directive;
              terminalPriority = directive.priority;
              if (directiveValue == 'element') {
                $template = jqLite(compileNode);
                $compileNode = templateAttrs.$$element = jqLite(document.createComment(' ' + directiveName + ': ' + templateAttrs[directiveName] + ' '));
                compileNode = $compileNode[0];
                replaceWith(jqCollection, jqLite($template[0]), compileNode);
                childTranscludeFn = compile($template, transcludeFn, terminalPriority);
              } else {
                $template = jqLite(JQLiteClone(compileNode)).contents();
                $compileNode.html('');
                childTranscludeFn = compile($template, transcludeFn);
              }
            }
            if (directiveValue = directive.template) {
              assertNoDuplicate('template', templateDirective, directive, $compileNode);
              templateDirective = directive;
              directiveValue = denormalizeTemplate(directiveValue);
              if (directive.replace) {
                $template = jqLite('<div>' + trim(directiveValue) + '</div>').contents();
                compileNode = $template[0];
                if ($template.length != 1 || compileNode.nodeType !== 1) {
                  throw new Error(MULTI_ROOT_TEMPLATE_ERROR + directiveValue);
                }
                replaceWith(jqCollection, $compileNode, compileNode);
                var newTemplateAttrs = { $attr: {} };
                directives = directives.concat(collectDirectives(compileNode, directives.splice(i + 1, directives.length - (i + 1)), newTemplateAttrs));
                mergeTemplateAttributes(templateAttrs, newTemplateAttrs);
                ii = directives.length;
              } else {
                $compileNode.html(directiveValue);
              }
            }
            if (directive.templateUrl) {
              assertNoDuplicate('template', templateDirective, directive, $compileNode);
              templateDirective = directive;
              nodeLinkFn = compileTemplateUrl(directives.splice(i, directives.length - i), nodeLinkFn, $compileNode, templateAttrs, jqCollection, directive.replace, childTranscludeFn);
              ii = directives.length;
            } else if (directive.compile) {
              try {
                linkFn = directive.compile($compileNode, templateAttrs, childTranscludeFn);
                if (isFunction(linkFn)) {
                  addLinkFns(null, linkFn);
                } else if (linkFn) {
                  addLinkFns(linkFn.pre, linkFn.post);
                }
              } catch (e) {
                $exceptionHandler(e, startingTag($compileNode));
              }
            }
            if (directive.terminal) {
              nodeLinkFn.terminal = true;
              terminalPriority = Math.max(terminalPriority, directive.priority);
            }
          }
          nodeLinkFn.scope = newScopeDirective && newScopeDirective.scope;
          nodeLinkFn.transclude = transcludeDirective && childTranscludeFn;
          return nodeLinkFn;
          function addLinkFns(pre, post) {
            if (pre) {
              pre.require = directive.require;
              preLinkFns.push(pre);
            }
            if (post) {
              post.require = directive.require;
              postLinkFns.push(post);
            }
          }
          function getControllers(require, $element) {
            var value, retrievalMethod = 'data', optional = false;
            if (isString(require)) {
              while ((value = require.charAt(0)) == '^' || value == '?') {
                require = require.substr(1);
                if (value == '^') {
                  retrievalMethod = 'inheritedData';
                }
                optional = optional || value == '?';
              }
              value = $element[retrievalMethod]('$' + require + 'Controller');
              if (!value && !optional) {
                throw Error('No controller: ' + require);
              }
              return value;
            } else if (isArray(require)) {
              value = [];
              forEach(require, function (require) {
                value.push(getControllers(require, $element));
              });
            }
            return value;
          }
          function nodeLinkFn(childLinkFn, scope, linkNode, $rootElement, boundTranscludeFn) {
            var attrs, $element, i, ii, linkFn, controller;
            if (compileNode === linkNode) {
              attrs = templateAttrs;
            } else {
              attrs = shallowCopy(templateAttrs, new Attributes(jqLite(linkNode), templateAttrs.$attr));
            }
            $element = attrs.$$element;
            if (newIsolateScopeDirective) {
              var LOCAL_REGEXP = /^\s*([@=&])\s*(\w*)\s*$/;
              var parentScope = scope.$parent || scope;
              forEach(newIsolateScopeDirective.scope, function (definiton, scopeName) {
                var match = definiton.match(LOCAL_REGEXP) || [], attrName = match[2] || scopeName, mode = match[1], lastValue, parentGet, parentSet;
                scope.$$isolateBindings[scopeName] = mode + attrName;
                switch (mode) {
                case '@': {
                    attrs.$observe(attrName, function (value) {
                      scope[scopeName] = value;
                    });
                    attrs.$$observers[attrName].$$scope = parentScope;
                    break;
                  }
                case '=': {
                    parentGet = $parse(attrs[attrName]);
                    parentSet = parentGet.assign || function () {
                      lastValue = scope[scopeName] = parentGet(parentScope);
                      throw Error(NON_ASSIGNABLE_MODEL_EXPRESSION + attrs[attrName] + ' (directive: ' + newIsolateScopeDirective.name + ')');
                    };
                    lastValue = scope[scopeName] = parentGet(parentScope);
                    scope.$watch(function parentValueWatch() {
                      var parentValue = parentGet(parentScope);
                      if (parentValue !== scope[scopeName]) {
                        if (parentValue !== lastValue) {
                          lastValue = scope[scopeName] = parentValue;
                        } else {
                          parentSet(parentScope, parentValue = lastValue = scope[scopeName]);
                        }
                      }
                      return parentValue;
                    });
                    break;
                  }
                case '&': {
                    parentGet = $parse(attrs[attrName]);
                    scope[scopeName] = function (locals) {
                      return parentGet(parentScope, locals);
                    };
                    break;
                  }
                default: {
                    throw Error('Invalid isolate scope definition for directive ' + newIsolateScopeDirective.name + ': ' + definiton);
                  }
                }
              });
            }
            if (controllerDirectives) {
              forEach(controllerDirectives, function (directive) {
                var locals = {
                    $scope: scope,
                    $element: $element,
                    $attrs: attrs,
                    $transclude: boundTranscludeFn
                  };
                controller = directive.controller;
                if (controller == '@') {
                  controller = attrs[directive.name];
                }
                $element.data('$' + directive.name + 'Controller', $controller(controller, locals));
              });
            }
            for (i = 0, ii = preLinkFns.length; i < ii; i++) {
              try {
                linkFn = preLinkFns[i];
                linkFn(scope, $element, attrs, linkFn.require && getControllers(linkFn.require, $element));
              } catch (e) {
                $exceptionHandler(e, startingTag($element));
              }
            }
            childLinkFn && childLinkFn(scope, linkNode.childNodes, undefined, boundTranscludeFn);
            for (i = 0, ii = postLinkFns.length; i < ii; i++) {
              try {
                linkFn = postLinkFns[i];
                linkFn(scope, $element, attrs, linkFn.require && getControllers(linkFn.require, $element));
              } catch (e) {
                $exceptionHandler(e, startingTag($element));
              }
            }
          }
        }
        function addDirective(tDirectives, name, location, maxPriority) {
          var match = false;
          if (hasDirectives.hasOwnProperty(name)) {
            for (var directive, directives = $injector.get(name + Suffix), i = 0, ii = directives.length; i < ii; i++) {
              try {
                directive = directives[i];
                if ((maxPriority === undefined || maxPriority > directive.priority) && directive.restrict.indexOf(location) != -1) {
                  tDirectives.push(directive);
                  match = true;
                }
              } catch (e) {
                $exceptionHandler(e);
              }
            }
          }
          return match;
        }
        function mergeTemplateAttributes(dst, src) {
          var srcAttr = src.$attr, dstAttr = dst.$attr, $element = dst.$$element;
          forEach(dst, function (value, key) {
            if (key.charAt(0) != '$') {
              if (src[key]) {
                value += (key === 'style' ? ';' : ' ') + src[key];
              }
              dst.$set(key, value, true, srcAttr[key]);
            }
          });
          forEach(src, function (value, key) {
            if (key == 'class') {
              safeAddClass($element, value);
              dst['class'] = (dst['class'] ? dst['class'] + ' ' : '') + value;
            } else if (key == 'style') {
              $element.attr('style', $element.attr('style') + ';' + value);
            } else if (key.charAt(0) != '$' && !dst.hasOwnProperty(key)) {
              dst[key] = value;
              dstAttr[key] = srcAttr[key];
            }
          });
        }
        function compileTemplateUrl(directives, beforeTemplateNodeLinkFn, $compileNode, tAttrs, $rootElement, replace, childTranscludeFn) {
          var linkQueue = [], afterTemplateNodeLinkFn, afterTemplateChildLinkFn, beforeTemplateCompileNode = $compileNode[0], origAsyncDirective = directives.shift(), derivedSyncDirective = extend({}, origAsyncDirective, {
              controller: null,
              templateUrl: null,
              transclude: null,
              scope: null
            });
          $compileNode.html('');
          $http.get(origAsyncDirective.templateUrl, { cache: $templateCache }).success(function (content) {
            var compileNode, tempTemplateAttrs, $template;
            content = denormalizeTemplate(content);
            if (replace) {
              $template = jqLite('<div>' + trim(content) + '</div>').contents();
              compileNode = $template[0];
              if ($template.length != 1 || compileNode.nodeType !== 1) {
                throw new Error(MULTI_ROOT_TEMPLATE_ERROR + content);
              }
              tempTemplateAttrs = { $attr: {} };
              replaceWith($rootElement, $compileNode, compileNode);
              collectDirectives(compileNode, directives, tempTemplateAttrs);
              mergeTemplateAttributes(tAttrs, tempTemplateAttrs);
            } else {
              compileNode = beforeTemplateCompileNode;
              $compileNode.html(content);
            }
            directives.unshift(derivedSyncDirective);
            afterTemplateNodeLinkFn = applyDirectivesToNode(directives, compileNode, tAttrs, childTranscludeFn);
            afterTemplateChildLinkFn = compileNodes($compileNode[0].childNodes, childTranscludeFn);
            while (linkQueue.length) {
              var controller = linkQueue.pop(), linkRootElement = linkQueue.pop(), beforeTemplateLinkNode = linkQueue.pop(), scope = linkQueue.pop(), linkNode = compileNode;
              if (beforeTemplateLinkNode !== beforeTemplateCompileNode) {
                linkNode = JQLiteClone(compileNode);
                replaceWith(linkRootElement, jqLite(beforeTemplateLinkNode), linkNode);
              }
              afterTemplateNodeLinkFn(function () {
                beforeTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, linkNode, $rootElement, controller);
              }, scope, linkNode, $rootElement, controller);
            }
            linkQueue = null;
          }).error(function (response, code, headers, config) {
            throw Error('Failed to load template: ' + config.url);
          });
          return function delayedNodeLinkFn(ignoreChildLinkFn, scope, node, rootElement, controller) {
            if (linkQueue) {
              linkQueue.push(scope);
              linkQueue.push(node);
              linkQueue.push(rootElement);
              linkQueue.push(controller);
            } else {
              afterTemplateNodeLinkFn(function () {
                beforeTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, node, rootElement, controller);
              }, scope, node, rootElement, controller);
            }
          };
        }
        function byPriority(a, b) {
          return b.priority - a.priority;
        }
        function assertNoDuplicate(what, previousDirective, directive, element) {
          if (previousDirective) {
            throw Error('Multiple directives [' + previousDirective.name + ', ' + directive.name + '] asking for ' + what + ' on: ' + startingTag(element));
          }
        }
        function addTextInterpolateDirective(directives, text) {
          var interpolateFn = $interpolate(text, true);
          if (interpolateFn) {
            directives.push({
              priority: 0,
              compile: valueFn(function textInterpolateLinkFn(scope, node) {
                var parent = node.parent(), bindings = parent.data('$binding') || [];
                bindings.push(interpolateFn);
                safeAddClass(parent.data('$binding', bindings), 'ng-binding');
                scope.$watch(interpolateFn, function interpolateFnWatchAction(value) {
                  node[0].nodeValue = value;
                });
              })
            });
          }
        }
        function addAttrInterpolateDirective(node, directives, value, name) {
          var interpolateFn = $interpolate(value, true);
          if (!interpolateFn)
            return;
          directives.push({
            priority: 100,
            compile: valueFn(function attrInterpolateLinkFn(scope, element, attr) {
              var $$observers = attr.$$observers || (attr.$$observers = {});
              if (name === 'class') {
                interpolateFn = $interpolate(attr[name], true);
              }
              attr[name] = undefined;
              ($$observers[name] || ($$observers[name] = [])).$$inter = true;
              (attr.$$observers && attr.$$observers[name].$$scope || scope).$watch(interpolateFn, function interpolateFnWatchAction(value) {
                attr.$set(name, value);
              });
            })
          });
        }
        function replaceWith($rootElement, $element, newNode) {
          var oldNode = $element[0], parent = oldNode.parentNode, i, ii;
          if ($rootElement) {
            for (i = 0, ii = $rootElement.length; i < ii; i++) {
              if ($rootElement[i] == oldNode) {
                $rootElement[i] = newNode;
                break;
              }
            }
          }
          if (parent) {
            parent.replaceChild(newNode, oldNode);
          }
          newNode[jqLite.expando] = oldNode[jqLite.expando];
          $element[0] = newNode;
        }
      }
    ];
  }
  var PREFIX_REGEXP = /^(x[\:\-_]|data[\:\-_])/i;
  function directiveNormalize(name) {
    return camelCase(name.replace(PREFIX_REGEXP, ''));
  }
  function nodesetLinkingFn(scope, nodeList, rootElement, boundTranscludeFn) {
  }
  function directiveLinkingFn(nodesetLinkingFn, scope, node, rootElement, boundTranscludeFn) {
  }
  function $ControllerProvider() {
    var controllers = {};
    this.register = function (name, constructor) {
      if (isObject(name)) {
        extend(controllers, name);
      } else {
        controllers[name] = constructor;
      }
    };
    this.$get = [
      '$injector',
      '$window',
      function ($injector, $window) {
        return function (constructor, locals) {
          if (isString(constructor)) {
            var name = constructor;
            constructor = controllers.hasOwnProperty(name) ? controllers[name] : getter(locals.$scope, name, true) || getter($window, name, true);
            assertArgFn(constructor, name, true);
          }
          return $injector.instantiate(constructor, locals);
        };
      }
    ];
  }
  function $DocumentProvider() {
    this.$get = [
      '$window',
      function (window) {
        return jqLite(window.document);
      }
    ];
  }
  function $ExceptionHandlerProvider() {
    this.$get = [
      '$log',
      function ($log) {
        return function (exception, cause) {
          $log.error.apply($log, arguments);
        };
      }
    ];
  }
  function $InterpolateProvider() {
    var startSymbol = '{{';
    var endSymbol = '}}';
    this.startSymbol = function (value) {
      if (value) {
        startSymbol = value;
        return this;
      } else {
        return startSymbol;
      }
    };
    this.endSymbol = function (value) {
      if (value) {
        endSymbol = value;
        return this;
      } else {
        return endSymbol;
      }
    };
    this.$get = [
      '$parse',
      function ($parse) {
        var startSymbolLength = startSymbol.length, endSymbolLength = endSymbol.length;
        function $interpolate(text, mustHaveExpression) {
          var startIndex, endIndex, index = 0, parts = [], length = text.length, hasInterpolation = false, fn, exp, concat = [];
          while (index < length) {
            if ((startIndex = text.indexOf(startSymbol, index)) != -1 && (endIndex = text.indexOf(endSymbol, startIndex + startSymbolLength)) != -1) {
              index != startIndex && parts.push(text.substring(index, startIndex));
              parts.push(fn = $parse(exp = text.substring(startIndex + startSymbolLength, endIndex)));
              fn.exp = exp;
              index = endIndex + endSymbolLength;
              hasInterpolation = true;
            } else {
              index != length && parts.push(text.substring(index));
              index = length;
            }
          }
          if (!(length = parts.length)) {
            parts.push('');
            length = 1;
          }
          if (!mustHaveExpression || hasInterpolation) {
            concat.length = length;
            fn = function (context) {
              for (var i = 0, ii = length, part; i < ii; i++) {
                if (typeof (part = parts[i]) == 'function') {
                  part = part(context);
                  if (part == null || part == undefined) {
                    part = '';
                  } else if (typeof part != 'string') {
                    part = toJson(part);
                  }
                }
                concat[i] = part;
              }
              return concat.join('');
            };
            fn.exp = text;
            fn.parts = parts;
            return fn;
          }
        }
        $interpolate.startSymbol = function () {
          return startSymbol;
        };
        $interpolate.endSymbol = function () {
          return endSymbol;
        };
        return $interpolate;
      }
    ];
  }
  var URL_MATCH = /^([^:]+):\/\/(\w+:{0,1}\w*@)?(\{?[\w\.-]*\}?)(:([0-9]+))?(\/[^\?#]*)?(\?([^#]*))?(#(.*))?$/, PATH_MATCH = /^([^\?#]*)?(\?([^#]*))?(#(.*))?$/, HASH_MATCH = PATH_MATCH, DEFAULT_PORTS = {
      'http': 80,
      'https': 443,
      'ftp': 21
    };
  function encodePath(path) {
    var segments = path.split('/'), i = segments.length;
    while (i--) {
      segments[i] = encodeUriSegment(segments[i]);
    }
    return segments.join('/');
  }
  function stripHash(url) {
    return url.split('#')[0];
  }
  function matchUrl(url, obj) {
    var match = URL_MATCH.exec(url);
    match = {
      protocol: match[1],
      host: match[3],
      port: int(match[5]) || DEFAULT_PORTS[match[1]] || null,
      path: match[6] || '/',
      search: match[8],
      hash: match[10]
    };
    if (obj) {
      obj.$$protocol = match.protocol;
      obj.$$host = match.host;
      obj.$$port = match.port;
    }
    return match;
  }
  function composeProtocolHostPort(protocol, host, port) {
    return protocol + '://' + host + (port == DEFAULT_PORTS[protocol] ? '' : ':' + port);
  }
  function pathPrefixFromBase(basePath) {
    return basePath.substr(0, basePath.lastIndexOf('/'));
  }
  function convertToHtml5Url(url, basePath, hashPrefix) {
    var match = matchUrl(url);
    if (decodeURIComponent(match.path) != basePath || isUndefined(match.hash) || match.hash.indexOf(hashPrefix) !== 0) {
      return url;
    } else {
      return composeProtocolHostPort(match.protocol, match.host, match.port) + pathPrefixFromBase(basePath) + match.hash.substr(hashPrefix.length);
    }
  }
  function convertToHashbangUrl(url, basePath, hashPrefix) {
    var match = matchUrl(url);
    if (decodeURIComponent(match.path) == basePath && !isUndefined(match.hash) && match.hash.indexOf(hashPrefix) === 0) {
      return url;
    } else {
      var search = match.search && '?' + match.search || '', hash = match.hash && '#' + match.hash || '', pathPrefix = pathPrefixFromBase(basePath), path = match.path.substr(pathPrefix.length);
      if (match.path.indexOf(pathPrefix) !== 0) {
        throw Error('Invalid url "' + url + '", missing path prefix "' + pathPrefix + '" !');
      }
      return composeProtocolHostPort(match.protocol, match.host, match.port) + basePath + '#' + hashPrefix + path + search + hash;
    }
  }
  function LocationUrl(url, pathPrefix, appBaseUrl) {
    pathPrefix = pathPrefix || '';
    this.$$parse = function (newAbsoluteUrl) {
      var match = matchUrl(newAbsoluteUrl, this);
      if (match.path.indexOf(pathPrefix) !== 0) {
        throw Error('Invalid url "' + newAbsoluteUrl + '", missing path prefix "' + pathPrefix + '" !');
      }
      this.$$path = decodeURIComponent(match.path.substr(pathPrefix.length));
      this.$$search = parseKeyValue(match.search);
      this.$$hash = match.hash && decodeURIComponent(match.hash) || '';
      this.$$compose();
    };
    this.$$compose = function () {
      var search = toKeyValue(this.$$search), hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
      this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
      this.$$absUrl = composeProtocolHostPort(this.$$protocol, this.$$host, this.$$port) + pathPrefix + this.$$url;
    };
    this.$$rewriteAppUrl = function (absoluteLinkUrl) {
      if (absoluteLinkUrl.indexOf(appBaseUrl) == 0) {
        return absoluteLinkUrl;
      }
    };
    this.$$parse(url);
  }
  function LocationHashbangUrl(url, hashPrefix, appBaseUrl) {
    var basePath;
    this.$$parse = function (url) {
      var match = matchUrl(url, this);
      if (match.hash && match.hash.indexOf(hashPrefix) !== 0) {
        throw Error('Invalid url "' + url + '", missing hash prefix "' + hashPrefix + '" !');
      }
      basePath = match.path + (match.search ? '?' + match.search : '');
      match = HASH_MATCH.exec((match.hash || '').substr(hashPrefix.length));
      if (match[1]) {
        this.$$path = (match[1].charAt(0) == '/' ? '' : '/') + decodeURIComponent(match[1]);
      } else {
        this.$$path = '';
      }
      this.$$search = parseKeyValue(match[3]);
      this.$$hash = match[5] && decodeURIComponent(match[5]) || '';
      this.$$compose();
    };
    this.$$compose = function () {
      var search = toKeyValue(this.$$search), hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
      this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
      this.$$absUrl = composeProtocolHostPort(this.$$protocol, this.$$host, this.$$port) + basePath + (this.$$url ? '#' + hashPrefix + this.$$url : '');
    };
    this.$$rewriteAppUrl = function (absoluteLinkUrl) {
      if (absoluteLinkUrl.indexOf(appBaseUrl) == 0) {
        return absoluteLinkUrl;
      }
    };
    this.$$parse(url);
  }
  LocationUrl.prototype = {
    $$replace: false,
    absUrl: locationGetter('$$absUrl'),
    url: function (url, replace) {
      if (isUndefined(url))
        return this.$$url;
      var match = PATH_MATCH.exec(url);
      if (match[1])
        this.path(decodeURIComponent(match[1]));
      if (match[2] || match[1])
        this.search(match[3] || '');
      this.hash(match[5] || '', replace);
      return this;
    },
    protocol: locationGetter('$$protocol'),
    host: locationGetter('$$host'),
    port: locationGetter('$$port'),
    path: locationGetterSetter('$$path', function (path) {
      return path.charAt(0) == '/' ? path : '/' + path;
    }),
    search: function (search, paramValue) {
      if (isUndefined(search))
        return this.$$search;
      if (isDefined(paramValue)) {
        if (paramValue === null) {
          delete this.$$search[search];
        } else {
          this.$$search[search] = paramValue;
        }
      } else {
        this.$$search = isString(search) ? parseKeyValue(search) : search;
      }
      this.$$compose();
      return this;
    },
    hash: locationGetterSetter('$$hash', identity),
    replace: function () {
      this.$$replace = true;
      return this;
    }
  };
  LocationHashbangUrl.prototype = inherit(LocationUrl.prototype);
  function LocationHashbangInHtml5Url(url, hashPrefix, appBaseUrl, baseExtra) {
    LocationHashbangUrl.apply(this, arguments);
    this.$$rewriteAppUrl = function (absoluteLinkUrl) {
      if (absoluteLinkUrl.indexOf(appBaseUrl) == 0) {
        return appBaseUrl + baseExtra + '#' + hashPrefix + absoluteLinkUrl.substr(appBaseUrl.length);
      }
    };
  }
  LocationHashbangInHtml5Url.prototype = inherit(LocationHashbangUrl.prototype);
  function locationGetter(property) {
    return function () {
      return this[property];
    };
  }
  function locationGetterSetter(property, preprocess) {
    return function (value) {
      if (isUndefined(value))
        return this[property];
      this[property] = preprocess(value);
      this.$$compose();
      return this;
    };
  }
  function $LocationProvider() {
    var hashPrefix = '', html5Mode = false;
    this.hashPrefix = function (prefix) {
      if (isDefined(prefix)) {
        hashPrefix = prefix;
        return this;
      } else {
        return hashPrefix;
      }
    };
    this.html5Mode = function (mode) {
      if (isDefined(mode)) {
        html5Mode = mode;
        return this;
      } else {
        return html5Mode;
      }
    };
    this.$get = [
      '$rootScope',
      '$browser',
      '$sniffer',
      '$rootElement',
      function ($rootScope, $browser, $sniffer, $rootElement) {
        var $location, basePath, pathPrefix, initUrl = $browser.url(), initUrlParts = matchUrl(initUrl), appBaseUrl;
        if (html5Mode) {
          basePath = $browser.baseHref() || '/';
          pathPrefix = pathPrefixFromBase(basePath);
          appBaseUrl = composeProtocolHostPort(initUrlParts.protocol, initUrlParts.host, initUrlParts.port) + pathPrefix + '/';
          if ($sniffer.history) {
            $location = new LocationUrl(convertToHtml5Url(initUrl, basePath, hashPrefix), pathPrefix, appBaseUrl);
          } else {
            $location = new LocationHashbangInHtml5Url(convertToHashbangUrl(initUrl, basePath, hashPrefix), hashPrefix, appBaseUrl, basePath.substr(pathPrefix.length + 1));
          }
        } else {
          appBaseUrl = composeProtocolHostPort(initUrlParts.protocol, initUrlParts.host, initUrlParts.port) + (initUrlParts.path || '') + (initUrlParts.search ? '?' + initUrlParts.search : '') + '#' + hashPrefix + '/';
          $location = new LocationHashbangUrl(initUrl, hashPrefix, appBaseUrl);
        }
        $rootElement.bind('click', function (event) {
          if (event.ctrlKey || event.metaKey || event.which == 2)
            return;
          var elm = jqLite(event.target);
          while (lowercase(elm[0].nodeName) !== 'a') {
            if (elm[0] === $rootElement[0] || !(elm = elm.parent())[0])
              return;
          }
          var absHref = elm.prop('href'), rewrittenUrl = $location.$$rewriteAppUrl(absHref);
          if (absHref && !elm.attr('target') && rewrittenUrl) {
            $location.$$parse(rewrittenUrl);
            $rootScope.$apply();
            event.preventDefault();
            window.angular['ff-684208-preventDefault'] = true;
          }
        });
        if ($location.absUrl() != initUrl) {
          $browser.url($location.absUrl(), true);
        }
        $browser.onUrlChange(function (newUrl) {
          if ($location.absUrl() != newUrl) {
            if ($rootScope.$broadcast('$locationChangeStart', newUrl, $location.absUrl()).defaultPrevented) {
              $browser.url($location.absUrl());
              return;
            }
            $rootScope.$evalAsync(function () {
              var oldUrl = $location.absUrl();
              $location.$$parse(newUrl);
              afterLocationChange(oldUrl);
            });
            if (!$rootScope.$$phase)
              $rootScope.$digest();
          }
        });
        var changeCounter = 0;
        $rootScope.$watch(function $locationWatch() {
          var oldUrl = $browser.url();
          var currentReplace = $location.$$replace;
          if (!changeCounter || oldUrl != $location.absUrl()) {
            changeCounter++;
            $rootScope.$evalAsync(function () {
              if ($rootScope.$broadcast('$locationChangeStart', $location.absUrl(), oldUrl).defaultPrevented) {
                $location.$$parse(oldUrl);
              } else {
                $browser.url($location.absUrl(), currentReplace);
                afterLocationChange(oldUrl);
              }
            });
          }
          $location.$$replace = false;
          return changeCounter;
        });
        return $location;
        function afterLocationChange(oldUrl) {
          $rootScope.$broadcast('$locationChangeSuccess', $location.absUrl(), oldUrl);
        }
      }
    ];
  }
  function $LogProvider() {
    this.$get = [
      '$window',
      function ($window) {
        return {
          log: consoleLog('log'),
          warn: consoleLog('warn'),
          info: consoleLog('info'),
          error: consoleLog('error')
        };
        function formatError(arg) {
          if (arg instanceof Error) {
            if (arg.stack) {
              arg = arg.message && arg.stack.indexOf(arg.message) === -1 ? 'Error: ' + arg.message + '\n' + arg.stack : arg.stack;
            } else if (arg.sourceURL) {
              arg = arg.message + '\n' + arg.sourceURL + ':' + arg.line;
            }
          }
          return arg;
        }
        function consoleLog(type) {
          var console = $window.console || {}, logFn = console[type] || console.log || noop;
          if (logFn.apply) {
            return function () {
              var args = [];
              forEach(arguments, function (arg) {
                args.push(formatError(arg));
              });
              return logFn.apply(console, args);
            };
          }
          return function (arg1, arg2) {
            logFn(arg1, arg2);
          };
        }
      }
    ];
  }
  var OPERATORS = {
      'null': function () {
        return null;
      },
      'true': function () {
        return true;
      },
      'false': function () {
        return false;
      },
      undefined: noop,
      '+': function (self, locals, a, b) {
        a = a(self, locals);
        b = b(self, locals);
        if (isDefined(a)) {
          if (isDefined(b)) {
            return a + b;
          }
          return a;
        }
        return isDefined(b) ? b : undefined;
      },
      '-': function (self, locals, a, b) {
        a = a(self, locals);
        b = b(self, locals);
        return (isDefined(a) ? a : 0) - (isDefined(b) ? b : 0);
      },
      '*': function (self, locals, a, b) {
        return a(self, locals) * b(self, locals);
      },
      '/': function (self, locals, a, b) {
        return a(self, locals) / b(self, locals);
      },
      '%': function (self, locals, a, b) {
        return a(self, locals) % b(self, locals);
      },
      '^': function (self, locals, a, b) {
        return a(self, locals) ^ b(self, locals);
      },
      '=': noop,
      '==': function (self, locals, a, b) {
        return a(self, locals) == b(self, locals);
      },
      '!=': function (self, locals, a, b) {
        return a(self, locals) != b(self, locals);
      },
      '<': function (self, locals, a, b) {
        return a(self, locals) < b(self, locals);
      },
      '>': function (self, locals, a, b) {
        return a(self, locals) > b(self, locals);
      },
      '<=': function (self, locals, a, b) {
        return a(self, locals) <= b(self, locals);
      },
      '>=': function (self, locals, a, b) {
        return a(self, locals) >= b(self, locals);
      },
      '&&': function (self, locals, a, b) {
        return a(self, locals) && b(self, locals);
      },
      '||': function (self, locals, a, b) {
        return a(self, locals) || b(self, locals);
      },
      '&': function (self, locals, a, b) {
        return a(self, locals) & b(self, locals);
      },
      '|': function (self, locals, a, b) {
        return b(self, locals)(self, locals, a(self, locals));
      },
      '!': function (self, locals, a) {
        return !a(self, locals);
      }
    };
  var ESCAPE = {
      'n': '\n',
      'f': '\f',
      'r': '\r',
      't': '\t',
      'v': '\x0B',
      '\'': '\'',
      '"': '"'
    };
  function lex(text, csp) {
    var tokens = [], token, index = 0, json = [], ch, lastCh = ':';
    while (index < text.length) {
      ch = text.charAt(index);
      if (is('"\'')) {
        readString(ch);
      } else if (isNumber(ch) || is('.') && isNumber(peek())) {
        readNumber();
      } else if (isIdent(ch)) {
        readIdent();
        if (was('{,') && json[0] == '{' && (token = tokens[tokens.length - 1])) {
          token.json = token.text.indexOf('.') == -1;
        }
      } else if (is('(){}[].,;:')) {
        tokens.push({
          index: index,
          text: ch,
          json: was(':[,') && is('{[') || is('}]:,')
        });
        if (is('{['))
          json.unshift(ch);
        if (is('}]'))
          json.shift();
        index++;
      } else if (isWhitespace(ch)) {
        index++;
        continue;
      } else {
        var ch2 = ch + peek(), fn = OPERATORS[ch], fn2 = OPERATORS[ch2];
        if (fn2) {
          tokens.push({
            index: index,
            text: ch2,
            fn: fn2
          });
          index += 2;
        } else if (fn) {
          tokens.push({
            index: index,
            text: ch,
            fn: fn,
            json: was('[,:') && is('+-')
          });
          index += 1;
        } else {
          throwError('Unexpected next character ', index, index + 1);
        }
      }
      lastCh = ch;
    }
    return tokens;
    function is(chars) {
      return chars.indexOf(ch) != -1;
    }
    function was(chars) {
      return chars.indexOf(lastCh) != -1;
    }
    function peek() {
      return index + 1 < text.length ? text.charAt(index + 1) : false;
    }
    function isNumber(ch) {
      return '0' <= ch && ch <= '9';
    }
    function isWhitespace(ch) {
      return ch == ' ' || ch == '\r' || ch == '\t' || ch == '\n' || ch == '\x0B' || ch == '\xa0';
    }
    function isIdent(ch) {
      return 'a' <= ch && ch <= 'z' || 'A' <= ch && ch <= 'Z' || '_' == ch || ch == '$';
    }
    function isExpOperator(ch) {
      return ch == '-' || ch == '+' || isNumber(ch);
    }
    function throwError(error, start, end) {
      end = end || index;
      throw Error('Lexer Error: ' + error + ' at column' + (isDefined(start) ? 's ' + start + '-' + index + ' [' + text.substring(start, end) + ']' : ' ' + end) + ' in expression [' + text + '].');
    }
    function readNumber() {
      var number = '';
      var start = index;
      while (index < text.length) {
        var ch = lowercase(text.charAt(index));
        if (ch == '.' || isNumber(ch)) {
          number += ch;
        } else {
          var peekCh = peek();
          if (ch == 'e' && isExpOperator(peekCh)) {
            number += ch;
          } else if (isExpOperator(ch) && peekCh && isNumber(peekCh) && number.charAt(number.length - 1) == 'e') {
            number += ch;
          } else if (isExpOperator(ch) && (!peekCh || !isNumber(peekCh)) && number.charAt(number.length - 1) == 'e') {
            throwError('Invalid exponent');
          } else {
            break;
          }
        }
        index++;
      }
      number = 1 * number;
      tokens.push({
        index: start,
        text: number,
        json: true,
        fn: function () {
          return number;
        }
      });
    }
    function readIdent() {
      var ident = '', start = index, lastDot, peekIndex, methodName, ch;
      while (index < text.length) {
        ch = text.charAt(index);
        if (ch == '.' || isIdent(ch) || isNumber(ch)) {
          if (ch == '.')
            lastDot = index;
          ident += ch;
        } else {
          break;
        }
        index++;
      }
      if (lastDot) {
        peekIndex = index;
        while (peekIndex < text.length) {
          ch = text.charAt(peekIndex);
          if (ch == '(') {
            methodName = ident.substr(lastDot - start + 1);
            ident = ident.substr(0, lastDot - start);
            index = peekIndex;
            break;
          }
          if (isWhitespace(ch)) {
            peekIndex++;
          } else {
            break;
          }
        }
      }
      var token = {
          index: start,
          text: ident
        };
      if (OPERATORS.hasOwnProperty(ident)) {
        token.fn = token.json = OPERATORS[ident];
      } else {
        var getter = getterFn(ident, csp);
        token.fn = extend(function (self, locals) {
          return getter(self, locals);
        }, {
          assign: function (self, value) {
            return setter(self, ident, value);
          }
        });
      }
      tokens.push(token);
      if (methodName) {
        tokens.push({
          index: lastDot,
          text: '.',
          json: false
        });
        tokens.push({
          index: lastDot + 1,
          text: methodName,
          json: false
        });
      }
    }
    function readString(quote) {
      var start = index;
      index++;
      var string = '';
      var rawString = quote;
      var escape = false;
      while (index < text.length) {
        var ch = text.charAt(index);
        rawString += ch;
        if (escape) {
          if (ch == 'u') {
            var hex = text.substring(index + 1, index + 5);
            if (!hex.match(/[\da-f]{4}/i))
              throwError('Invalid unicode escape [\\u' + hex + ']');
            index += 4;
            string += String.fromCharCode(parseInt(hex, 16));
          } else {
            var rep = ESCAPE[ch];
            if (rep) {
              string += rep;
            } else {
              string += ch;
            }
          }
          escape = false;
        } else if (ch == '\\') {
          escape = true;
        } else if (ch == quote) {
          index++;
          tokens.push({
            index: start,
            text: rawString,
            string: string,
            json: true,
            fn: function () {
              return string;
            }
          });
          return;
        } else {
          string += ch;
        }
        index++;
      }
      throwError('Unterminated quote', start);
    }
  }
  function parser(text, json, $filter, csp) {
    var ZERO = valueFn(0), value, tokens = lex(text, csp), assignment = _assignment, functionCall = _functionCall, fieldAccess = _fieldAccess, objectIndex = _objectIndex, filterChain = _filterChain;
    if (json) {
      assignment = logicalOR;
      functionCall = fieldAccess = objectIndex = filterChain = function () {
        throwError('is not valid json', {
          text: text,
          index: 0
        });
      };
      value = primary();
    } else {
      value = statements();
    }
    if (tokens.length !== 0) {
      throwError('is an unexpected token', tokens[0]);
    }
    return value;
    function throwError(msg, token) {
      throw Error('Syntax Error: Token \'' + token.text + '\' ' + msg + ' at column ' + (token.index + 1) + ' of the expression [' + text + '] starting at [' + text.substring(token.index) + '].');
    }
    function peekToken() {
      if (tokens.length === 0)
        throw Error('Unexpected end of expression: ' + text);
      return tokens[0];
    }
    function peek(e1, e2, e3, e4) {
      if (tokens.length > 0) {
        var token = tokens[0];
        var t = token.text;
        if (t == e1 || t == e2 || t == e3 || t == e4 || !e1 && !e2 && !e3 && !e4) {
          return token;
        }
      }
      return false;
    }
    function expect(e1, e2, e3, e4) {
      var token = peek(e1, e2, e3, e4);
      if (token) {
        if (json && !token.json) {
          throwError('is not valid json', token);
        }
        tokens.shift();
        return token;
      }
      return false;
    }
    function consume(e1) {
      if (!expect(e1)) {
        throwError('is unexpected, expecting [' + e1 + ']', peek());
      }
    }
    function unaryFn(fn, right) {
      return function (self, locals) {
        return fn(self, locals, right);
      };
    }
    function binaryFn(left, fn, right) {
      return function (self, locals) {
        return fn(self, locals, left, right);
      };
    }
    function statements() {
      var statements = [];
      while (true) {
        if (tokens.length > 0 && !peek('}', ')', ';', ']'))
          statements.push(filterChain());
        if (!expect(';')) {
          return statements.length == 1 ? statements[0] : function (self, locals) {
            var value;
            for (var i = 0; i < statements.length; i++) {
              var statement = statements[i];
              if (statement)
                value = statement(self, locals);
            }
            return value;
          };
        }
      }
    }
    function _filterChain() {
      var left = expression();
      var token;
      while (true) {
        if (token = expect('|')) {
          left = binaryFn(left, token.fn, filter());
        } else {
          return left;
        }
      }
    }
    function filter() {
      var token = expect();
      var fn = $filter(token.text);
      var argsFn = [];
      while (true) {
        if (token = expect(':')) {
          argsFn.push(expression());
        } else {
          var fnInvoke = function (self, locals, input) {
            var args = [input];
            for (var i = 0; i < argsFn.length; i++) {
              args.push(argsFn[i](self, locals));
            }
            return fn.apply(self, args);
          };
          return function () {
            return fnInvoke;
          };
        }
      }
    }
    function expression() {
      return assignment();
    }
    function _assignment() {
      var left = logicalOR();
      var right;
      var token;
      if (token = expect('=')) {
        if (!left.assign) {
          throwError('implies assignment but [' + text.substring(0, token.index) + '] can not be assigned to', token);
        }
        right = logicalOR();
        return function (scope, locals) {
          return left.assign(scope, right(scope, locals), locals);
        };
      } else {
        return left;
      }
    }
    function logicalOR() {
      var left = logicalAND();
      var token;
      while (true) {
        if (token = expect('||')) {
          left = binaryFn(left, token.fn, logicalAND());
        } else {
          return left;
        }
      }
    }
    function logicalAND() {
      var left = equality();
      var token;
      if (token = expect('&&')) {
        left = binaryFn(left, token.fn, logicalAND());
      }
      return left;
    }
    function equality() {
      var left = relational();
      var token;
      if (token = expect('==', '!=')) {
        left = binaryFn(left, token.fn, equality());
      }
      return left;
    }
    function relational() {
      var left = additive();
      var token;
      if (token = expect('<', '>', '<=', '>=')) {
        left = binaryFn(left, token.fn, relational());
      }
      return left;
    }
    function additive() {
      var left = multiplicative();
      var token;
      while (token = expect('+', '-')) {
        left = binaryFn(left, token.fn, multiplicative());
      }
      return left;
    }
    function multiplicative() {
      var left = unary();
      var token;
      while (token = expect('*', '/', '%')) {
        left = binaryFn(left, token.fn, unary());
      }
      return left;
    }
    function unary() {
      var token;
      if (expect('+')) {
        return primary();
      } else if (token = expect('-')) {
        return binaryFn(ZERO, token.fn, unary());
      } else if (token = expect('!')) {
        return unaryFn(token.fn, unary());
      } else {
        return primary();
      }
    }
    function primary() {
      var primary;
      if (expect('(')) {
        primary = filterChain();
        consume(')');
      } else if (expect('[')) {
        primary = arrayDeclaration();
      } else if (expect('{')) {
        primary = object();
      } else {
        var token = expect();
        primary = token.fn;
        if (!primary) {
          throwError('not a primary expression', token);
        }
      }
      var next, context;
      while (next = expect('(', '[', '.')) {
        if (next.text === '(') {
          primary = functionCall(primary, context);
          context = null;
        } else if (next.text === '[') {
          context = primary;
          primary = objectIndex(primary);
        } else if (next.text === '.') {
          context = primary;
          primary = fieldAccess(primary);
        } else {
          throwError('IMPOSSIBLE');
        }
      }
      return primary;
    }
    function _fieldAccess(object) {
      var field = expect().text;
      var getter = getterFn(field, csp);
      return extend(function (scope, locals, self) {
        return getter(self || object(scope, locals), locals);
      }, {
        assign: function (scope, value, locals) {
          return setter(object(scope, locals), field, value);
        }
      });
    }
    function _objectIndex(obj) {
      var indexFn = expression();
      consume(']');
      return extend(function (self, locals) {
        var o = obj(self, locals), i = indexFn(self, locals), v, p;
        if (!o)
          return undefined;
        v = o[i];
        if (v && v.then) {
          p = v;
          if (!('$$v' in v)) {
            p.$$v = undefined;
            p.then(function (val) {
              p.$$v = val;
            });
          }
          v = v.$$v;
        }
        return v;
      }, {
        assign: function (self, value, locals) {
          return obj(self, locals)[indexFn(self, locals)] = value;
        }
      });
    }
    function _functionCall(fn, contextGetter) {
      var argsFn = [];
      if (peekToken().text != ')') {
        do {
          argsFn.push(expression());
        } while (expect(','));
      }
      consume(')');
      return function (scope, locals) {
        var args = [], context = contextGetter ? contextGetter(scope, locals) : scope;
        for (var i = 0; i < argsFn.length; i++) {
          args.push(argsFn[i](scope, locals));
        }
        var fnPtr = fn(scope, locals, context) || noop;
        return fnPtr.apply ? fnPtr.apply(context, args) : fnPtr(args[0], args[1], args[2], args[3], args[4]);
      };
    }
    function arrayDeclaration() {
      var elementFns = [];
      if (peekToken().text != ']') {
        do {
          elementFns.push(expression());
        } while (expect(','));
      }
      consume(']');
      return function (self, locals) {
        var array = [];
        for (var i = 0; i < elementFns.length; i++) {
          array.push(elementFns[i](self, locals));
        }
        return array;
      };
    }
    function object() {
      var keyValues = [];
      if (peekToken().text != '}') {
        do {
          var token = expect(), key = token.string || token.text;
          consume(':');
          var value = expression();
          keyValues.push({
            key: key,
            value: value
          });
        } while (expect(','));
      }
      consume('}');
      return function (self, locals) {
        var object = {};
        for (var i = 0; i < keyValues.length; i++) {
          var keyValue = keyValues[i];
          object[keyValue.key] = keyValue.value(self, locals);
        }
        return object;
      };
    }
  }
  function setter(obj, path, setValue) {
    var element = path.split('.');
    for (var i = 0; element.length > 1; i++) {
      var key = element.shift();
      var propertyObj = obj[key];
      if (!propertyObj) {
        propertyObj = {};
        obj[key] = propertyObj;
      }
      obj = propertyObj;
    }
    obj[element.shift()] = setValue;
    return setValue;
  }
  function getter(obj, path, bindFnToScope) {
    if (!path)
      return obj;
    var keys = path.split('.');
    var key;
    var lastInstance = obj;
    var len = keys.length;
    for (var i = 0; i < len; i++) {
      key = keys[i];
      if (obj) {
        obj = (lastInstance = obj)[key];
      }
    }
    if (!bindFnToScope && isFunction(obj)) {
      return bind(lastInstance, obj);
    }
    return obj;
  }
  var getterFnCache = {};
  function cspSafeGetterFn(key0, key1, key2, key3, key4) {
    return function (scope, locals) {
      var pathVal = locals && locals.hasOwnProperty(key0) ? locals : scope, promise;
      if (pathVal === null || pathVal === undefined)
        return pathVal;
      pathVal = pathVal[key0];
      if (pathVal && pathVal.then) {
        if (!('$$v' in pathVal)) {
          promise = pathVal;
          promise.$$v = undefined;
          promise.then(function (val) {
            promise.$$v = val;
          });
        }
        pathVal = pathVal.$$v;
      }
      if (!key1 || pathVal === null || pathVal === undefined)
        return pathVal;
      pathVal = pathVal[key1];
      if (pathVal && pathVal.then) {
        if (!('$$v' in pathVal)) {
          promise = pathVal;
          promise.$$v = undefined;
          promise.then(function (val) {
            promise.$$v = val;
          });
        }
        pathVal = pathVal.$$v;
      }
      if (!key2 || pathVal === null || pathVal === undefined)
        return pathVal;
      pathVal = pathVal[key2];
      if (pathVal && pathVal.then) {
        if (!('$$v' in pathVal)) {
          promise = pathVal;
          promise.$$v = undefined;
          promise.then(function (val) {
            promise.$$v = val;
          });
        }
        pathVal = pathVal.$$v;
      }
      if (!key3 || pathVal === null || pathVal === undefined)
        return pathVal;
      pathVal = pathVal[key3];
      if (pathVal && pathVal.then) {
        if (!('$$v' in pathVal)) {
          promise = pathVal;
          promise.$$v = undefined;
          promise.then(function (val) {
            promise.$$v = val;
          });
        }
        pathVal = pathVal.$$v;
      }
      if (!key4 || pathVal === null || pathVal === undefined)
        return pathVal;
      pathVal = pathVal[key4];
      if (pathVal && pathVal.then) {
        if (!('$$v' in pathVal)) {
          promise = pathVal;
          promise.$$v = undefined;
          promise.then(function (val) {
            promise.$$v = val;
          });
        }
        pathVal = pathVal.$$v;
      }
      return pathVal;
    };
  }
  function getterFn(path, csp) {
    if (getterFnCache.hasOwnProperty(path)) {
      return getterFnCache[path];
    }
    var pathKeys = path.split('.'), pathKeysLength = pathKeys.length, fn;
    if (csp) {
      fn = pathKeysLength < 6 ? cspSafeGetterFn(pathKeys[0], pathKeys[1], pathKeys[2], pathKeys[3], pathKeys[4]) : function (scope, locals) {
        var i = 0, val;
        do {
          val = cspSafeGetterFn(pathKeys[i++], pathKeys[i++], pathKeys[i++], pathKeys[i++], pathKeys[i++])(scope, locals);
          locals = undefined;
          scope = val;
        } while (i < pathKeysLength);
        return val;
      };
    } else {
      var code = 'var l, fn, p;\n';
      forEach(pathKeys, function (key, index) {
        code += 'if(s === null || s === undefined) return s;\n' + 'l=s;\n' + 's=' + (index ? 's' : '((k&&k.hasOwnProperty("' + key + '"))?k:s)') + '["' + key + '"]' + ';\n' + 'if (s && s.then) {\n' + ' if (!("$$v" in s)) {\n' + ' p=s;\n' + ' p.$$v = undefined;\n' + ' p.then(function(v) {p.$$v=v;});\n' + '}\n' + ' s=s.$$v\n' + '}\n';
      });
      code += 'return s;';
      fn = Function('s', 'k', code);
      fn.toString = function () {
        return code;
      };
    }
    return getterFnCache[path] = fn;
  }
  function $ParseProvider() {
    var cache = {};
    this.$get = [
      '$filter',
      '$sniffer',
      function ($filter, $sniffer) {
        return function (exp) {
          switch (typeof exp) {
          case 'string':
            return cache.hasOwnProperty(exp) ? cache[exp] : cache[exp] = parser(exp, false, $filter, $sniffer.csp);
          case 'function':
            return exp;
          default:
            return noop;
          }
        };
      }
    ];
  }
  function $QProvider() {
    this.$get = [
      '$rootScope',
      '$exceptionHandler',
      function ($rootScope, $exceptionHandler) {
        return qFactory(function (callback) {
          $rootScope.$evalAsync(callback);
        }, $exceptionHandler);
      }
    ];
  }
  function qFactory(nextTick, exceptionHandler) {
    var defer = function () {
      var pending = [], value, deferred;
      deferred = {
        resolve: function (val) {
          if (pending) {
            var callbacks = pending;
            pending = undefined;
            value = ref(val);
            if (callbacks.length) {
              nextTick(function () {
                var callback;
                for (var i = 0, ii = callbacks.length; i < ii; i++) {
                  callback = callbacks[i];
                  value.then(callback[0], callback[1]);
                }
              });
            }
          }
        },
        reject: function (reason) {
          deferred.resolve(reject(reason));
        },
        promise: {
          then: function (callback, errback) {
            var result = defer();
            var wrappedCallback = function (value) {
              try {
                result.resolve((callback || defaultCallback)(value));
              } catch (e) {
                exceptionHandler(e);
                result.reject(e);
              }
            };
            var wrappedErrback = function (reason) {
              try {
                result.resolve((errback || defaultErrback)(reason));
              } catch (e) {
                exceptionHandler(e);
                result.reject(e);
              }
            };
            if (pending) {
              pending.push([
                wrappedCallback,
                wrappedErrback
              ]);
            } else {
              value.then(wrappedCallback, wrappedErrback);
            }
            return result.promise;
          }
        }
      };
      return deferred;
    };
    var ref = function (value) {
      if (value && value.then)
        return value;
      return {
        then: function (callback) {
          var result = defer();
          nextTick(function () {
            result.resolve(callback(value));
          });
          return result.promise;
        }
      };
    };
    var reject = function (reason) {
      return {
        then: function (callback, errback) {
          var result = defer();
          nextTick(function () {
            result.resolve((errback || defaultErrback)(reason));
          });
          return result.promise;
        }
      };
    };
    var when = function (value, callback, errback) {
      var result = defer(), done;
      var wrappedCallback = function (value) {
        try {
          return (callback || defaultCallback)(value);
        } catch (e) {
          exceptionHandler(e);
          return reject(e);
        }
      };
      var wrappedErrback = function (reason) {
        try {
          return (errback || defaultErrback)(reason);
        } catch (e) {
          exceptionHandler(e);
          return reject(e);
        }
      };
      nextTick(function () {
        ref(value).then(function (value) {
          if (done)
            return;
          done = true;
          result.resolve(ref(value).then(wrappedCallback, wrappedErrback));
        }, function (reason) {
          if (done)
            return;
          done = true;
          result.resolve(wrappedErrback(reason));
        });
      });
      return result.promise;
    };
    function defaultCallback(value) {
      return value;
    }
    function defaultErrback(reason) {
      return reject(reason);
    }
    function all(promises) {
      var deferred = defer(), counter = promises.length, results = [];
      if (counter) {
        forEach(promises, function (promise, index) {
          ref(promise).then(function (value) {
            if (index in results)
              return;
            results[index] = value;
            if (!--counter)
              deferred.resolve(results);
          }, function (reason) {
            if (index in results)
              return;
            deferred.reject(reason);
          });
        });
      } else {
        deferred.resolve(results);
      }
      return deferred.promise;
    }
    return {
      defer: defer,
      reject: reject,
      when: when,
      all: all
    };
  }
  function $RouteProvider() {
    var routes = {};
    this.when = function (path, route) {
      routes[path] = extend({ reloadOnSearch: true }, route);
      if (path) {
        var redirectPath = path[path.length - 1] == '/' ? path.substr(0, path.length - 1) : path + '/';
        routes[redirectPath] = { redirectTo: path };
      }
      return this;
    };
    this.otherwise = function (params) {
      this.when(null, params);
      return this;
    };
    this.$get = [
      '$rootScope',
      '$location',
      '$routeParams',
      '$q',
      '$injector',
      '$http',
      '$templateCache',
      function ($rootScope, $location, $routeParams, $q, $injector, $http, $templateCache) {
        var forceReload = false, $route = {
            routes: routes,
            reload: function () {
              forceReload = true;
              $rootScope.$evalAsync(updateRoute);
            }
          };
        $rootScope.$on('$locationChangeSuccess', updateRoute);
        return $route;
        function switchRouteMatcher(on, when) {
          when = '^' + when.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&') + '$';
          var regex = '', params = [], dst = {};
          var re = /:(\w+)/g, paramMatch, lastMatchedIndex = 0;
          while ((paramMatch = re.exec(when)) !== null) {
            regex += when.slice(lastMatchedIndex, paramMatch.index);
            regex += '([^\\/]*)';
            params.push(paramMatch[1]);
            lastMatchedIndex = re.lastIndex;
          }
          regex += when.substr(lastMatchedIndex);
          var match = on.match(new RegExp(regex));
          if (match) {
            forEach(params, function (name, index) {
              dst[name] = match[index + 1];
            });
          }
          return match ? dst : null;
        }
        function updateRoute() {
          var next = parseRoute(), last = $route.current;
          if (next && last && next.$$route === last.$$route && equals(next.pathParams, last.pathParams) && !next.reloadOnSearch && !forceReload) {
            last.params = next.params;
            copy(last.params, $routeParams);
            $rootScope.$broadcast('$routeUpdate', last);
          } else if (next || last) {
            forceReload = false;
            $rootScope.$broadcast('$routeChangeStart', next, last);
            $route.current = next;
            if (next) {
              if (next.redirectTo) {
                if (isString(next.redirectTo)) {
                  $location.path(interpolate(next.redirectTo, next.params)).search(next.params).replace();
                } else {
                  $location.url(next.redirectTo(next.pathParams, $location.path(), $location.search())).replace();
                }
              }
            }
            $q.when(next).then(function () {
              if (next) {
                var keys = [], values = [], template;
                forEach(next.resolve || {}, function (value, key) {
                  keys.push(key);
                  values.push(isString(value) ? $injector.get(value) : $injector.invoke(value));
                });
                if (isDefined(template = next.template)) {
                } else if (isDefined(template = next.templateUrl)) {
                  template = $http.get(template, { cache: $templateCache }).then(function (response) {
                    return response.data;
                  });
                }
                if (isDefined(template)) {
                  keys.push('$template');
                  values.push(template);
                }
                return $q.all(values).then(function (values) {
                  var locals = {};
                  forEach(values, function (value, index) {
                    locals[keys[index]] = value;
                  });
                  return locals;
                });
              }
            }).then(function (locals) {
              if (next == $route.current) {
                if (next) {
                  next.locals = locals;
                  copy(next.params, $routeParams);
                }
                $rootScope.$broadcast('$routeChangeSuccess', next, last);
              }
            }, function (error) {
              if (next == $route.current) {
                $rootScope.$broadcast('$routeChangeError', next, last, error);
              }
            });
          }
        }
        function parseRoute() {
          var params, match;
          forEach(routes, function (route, path) {
            if (!match && (params = switchRouteMatcher($location.path(), path))) {
              match = inherit(route, {
                params: extend({}, $location.search(), params),
                pathParams: params
              });
              match.$$route = route;
            }
          });
          return match || routes[null] && inherit(routes[null], {
            params: {},
            pathParams: {}
          });
        }
        function interpolate(string, params) {
          var result = [];
          forEach((string || '').split(':'), function (segment, i) {
            if (i == 0) {
              result.push(segment);
            } else {
              var segmentMatch = segment.match(/(\w+)(.*)/);
              var key = segmentMatch[1];
              result.push(params[key]);
              result.push(segmentMatch[2] || '');
              delete params[key];
            }
          });
          return result.join('');
        }
      }
    ];
  }
  function $RouteParamsProvider() {
    this.$get = valueFn({});
  }
  function $RootScopeProvider() {
    var TTL = 10;
    this.digestTtl = function (value) {
      if (arguments.length) {
        TTL = value;
      }
      return TTL;
    };
    this.$get = [
      '$injector',
      '$exceptionHandler',
      '$parse',
      function ($injector, $exceptionHandler, $parse) {
        function Scope() {
          this.$id = nextUid();
          this.$$phase = this.$parent = this.$$watchers = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = null;
          this['this'] = this.$root = this;
          this.$$destroyed = false;
          this.$$asyncQueue = [];
          this.$$listeners = {};
          this.$$isolateBindings = {};
        }
        Scope.prototype = {
          $new: function (isolate) {
            var Child, child;
            if (isFunction(isolate)) {
              throw Error('API-CHANGE: Use $controller to instantiate controllers.');
            }
            if (isolate) {
              child = new Scope();
              child.$root = this.$root;
            } else {
              Child = function () {
              };
              Child.prototype = this;
              child = new Child();
              child.$id = nextUid();
            }
            child['this'] = child;
            child.$$listeners = {};
            child.$parent = this;
            child.$$asyncQueue = [];
            child.$$watchers = child.$$nextSibling = child.$$childHead = child.$$childTail = null;
            child.$$prevSibling = this.$$childTail;
            if (this.$$childHead) {
              this.$$childTail.$$nextSibling = child;
              this.$$childTail = child;
            } else {
              this.$$childHead = this.$$childTail = child;
            }
            return child;
          },
          $watch: function (watchExp, listener, objectEquality) {
            var scope = this, get = compileToFn(watchExp, 'watch'), array = scope.$$watchers, watcher = {
                fn: listener,
                last: initWatchVal,
                get: get,
                exp: watchExp,
                eq: !!objectEquality
              };
            if (!isFunction(listener)) {
              var listenFn = compileToFn(listener || noop, 'listener');
              watcher.fn = function (newVal, oldVal, scope) {
                listenFn(scope);
              };
            }
            if (!array) {
              array = scope.$$watchers = [];
            }
            array.unshift(watcher);
            return function () {
              arrayRemove(array, watcher);
            };
          },
          $digest: function () {
            var watch, value, last, watchers, asyncQueue, length, dirty, ttl = TTL, next, current, target = this, watchLog = [], logIdx, logMsg;
            beginPhase('$digest');
            do {
              dirty = false;
              current = target;
              do {
                asyncQueue = current.$$asyncQueue;
                while (asyncQueue.length) {
                  try {
                    current.$eval(asyncQueue.shift());
                  } catch (e) {
                    $exceptionHandler(e);
                  }
                }
                if (watchers = current.$$watchers) {
                  length = watchers.length;
                  while (length--) {
                    try {
                      watch = watchers[length];
                      if ((value = watch.get(current)) !== (last = watch.last) && !(watch.eq ? equals(value, last) : typeof value == 'number' && typeof last == 'number' && isNaN(value) && isNaN(last))) {
                        dirty = true;
                        watch.last = watch.eq ? copy(value) : value;
                        watch.fn(value, last === initWatchVal ? value : last, current);
                        if (ttl < 5) {
                          logIdx = 4 - ttl;
                          if (!watchLog[logIdx])
                            watchLog[logIdx] = [];
                          logMsg = isFunction(watch.exp) ? 'fn: ' + (watch.exp.name || watch.exp.toString()) : watch.exp;
                          logMsg += '; newVal: ' + toJson(value) + '; oldVal: ' + toJson(last);
                          watchLog[logIdx].push(logMsg);
                        }
                      }
                    } catch (e) {
                      $exceptionHandler(e);
                    }
                  }
                }
                if (!(next = current.$$childHead || current !== target && current.$$nextSibling)) {
                  while (current !== target && !(next = current.$$nextSibling)) {
                    current = current.$parent;
                  }
                }
              } while (current = next);
              if (dirty && !ttl--) {
                clearPhase();
                throw Error(TTL + ' $digest() iterations reached. Aborting!\n' + 'Watchers fired in the last 5 iterations: ' + toJson(watchLog));
              }
            } while (dirty || asyncQueue.length);
            clearPhase();
          },
          $destroy: function () {
            if ($rootScope == this || this.$$destroyed)
              return;
            var parent = this.$parent;
            this.$broadcast('$destroy');
            this.$$destroyed = true;
            if (parent.$$childHead == this)
              parent.$$childHead = this.$$nextSibling;
            if (parent.$$childTail == this)
              parent.$$childTail = this.$$prevSibling;
            if (this.$$prevSibling)
              this.$$prevSibling.$$nextSibling = this.$$nextSibling;
            if (this.$$nextSibling)
              this.$$nextSibling.$$prevSibling = this.$$prevSibling;
            this.$parent = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = null;
          },
          $eval: function (expr, locals) {
            return $parse(expr)(this, locals);
          },
          $evalAsync: function (expr) {
            this.$$asyncQueue.push(expr);
          },
          $apply: function (expr) {
            try {
              beginPhase('$apply');
              return this.$eval(expr);
            } catch (e) {
              $exceptionHandler(e);
            } finally {
              clearPhase();
              try {
                $rootScope.$digest();
              } catch (e) {
                $exceptionHandler(e);
                throw e;
              }
            }
          },
          $on: function (name, listener) {
            var namedListeners = this.$$listeners[name];
            if (!namedListeners) {
              this.$$listeners[name] = namedListeners = [];
            }
            namedListeners.push(listener);
            return function () {
              namedListeners[indexOf(namedListeners, listener)] = null;
            };
          },
          $emit: function (name, args) {
            var empty = [], namedListeners, scope = this, stopPropagation = false, event = {
                name: name,
                targetScope: scope,
                stopPropagation: function () {
                  stopPropagation = true;
                },
                preventDefault: function () {
                  event.defaultPrevented = true;
                },
                defaultPrevented: false
              }, listenerArgs = concat([event], arguments, 1), i, length;
            do {
              namedListeners = scope.$$listeners[name] || empty;
              event.currentScope = scope;
              for (i = 0, length = namedListeners.length; i < length; i++) {
                if (!namedListeners[i]) {
                  namedListeners.splice(i, 1);
                  i--;
                  length--;
                  continue;
                }
                try {
                  namedListeners[i].apply(null, listenerArgs);
                  if (stopPropagation)
                    return event;
                } catch (e) {
                  $exceptionHandler(e);
                }
              }
              scope = scope.$parent;
            } while (scope);
            return event;
          },
          $broadcast: function (name, args) {
            var target = this, current = target, next = target, event = {
                name: name,
                targetScope: target,
                preventDefault: function () {
                  event.defaultPrevented = true;
                },
                defaultPrevented: false
              }, listenerArgs = concat([event], arguments, 1), listeners, i, length;
            do {
              current = next;
              event.currentScope = current;
              listeners = current.$$listeners[name] || [];
              for (i = 0, length = listeners.length; i < length; i++) {
                if (!listeners[i]) {
                  listeners.splice(i, 1);
                  i--;
                  length--;
                  continue;
                }
                try {
                  listeners[i].apply(null, listenerArgs);
                } catch (e) {
                  $exceptionHandler(e);
                }
              }
              if (!(next = current.$$childHead || current !== target && current.$$nextSibling)) {
                while (current !== target && !(next = current.$$nextSibling)) {
                  current = current.$parent;
                }
              }
            } while (current = next);
            return event;
          }
        };
        var $rootScope = new Scope();
        return $rootScope;
        function beginPhase(phase) {
          if ($rootScope.$$phase) {
            throw Error($rootScope.$$phase + ' already in progress');
          }
          $rootScope.$$phase = phase;
        }
        function clearPhase() {
          $rootScope.$$phase = null;
        }
        function compileToFn(exp, name) {
          var fn = $parse(exp);
          assertArgFn(fn, name);
          return fn;
        }
        function initWatchVal() {
        }
      }
    ];
  }
  function $SnifferProvider() {
    this.$get = [
      '$window',
      function ($window) {
        var eventSupport = {}, android = int((/android (\d+)/.exec(lowercase($window.navigator.userAgent)) || [])[1]);
        return {
          history: !!($window.history && $window.history.pushState && !(android < 4)),
          hashchange: 'onhashchange' in $window && (!$window.document.documentMode || $window.document.documentMode > 7),
          hasEvent: function (event) {
            if (event == 'input' && msie == 9)
              return false;
            if (isUndefined(eventSupport[event])) {
              var divElm = $window.document.createElement('div');
              eventSupport[event] = 'on' + event in divElm;
            }
            return eventSupport[event];
          },
          csp: false
        };
      }
    ];
  }
  function $WindowProvider() {
    this.$get = valueFn(window);
  }
  function parseHeaders(headers) {
    var parsed = {}, key, val, i;
    if (!headers)
      return parsed;
    forEach(headers.split('\n'), function (line) {
      i = line.indexOf(':');
      key = lowercase(trim(line.substr(0, i)));
      val = trim(line.substr(i + 1));
      if (key) {
        if (parsed[key]) {
          parsed[key] += ', ' + val;
        } else {
          parsed[key] = val;
        }
      }
    });
    return parsed;
  }
  function headersGetter(headers) {
    var headersObj = isObject(headers) ? headers : undefined;
    return function (name) {
      if (!headersObj)
        headersObj = parseHeaders(headers);
      if (name) {
        return headersObj[lowercase(name)] || null;
      }
      return headersObj;
    };
  }
  function transformData(data, headers, fns) {
    if (isFunction(fns))
      return fns(data, headers);
    forEach(fns, function (fn) {
      data = fn(data, headers);
    });
    return data;
  }
  function isSuccess(status) {
    return 200 <= status && status < 300;
  }
  function $HttpProvider() {
    var JSON_START = /^\s*(\[|\{[^\{])/, JSON_END = /[\}\]]\s*$/, PROTECTION_PREFIX = /^\)\]\}',?\n/;
    var $config = this.defaults = {
        transformResponse: [function (data) {
            if (isString(data)) {
              data = data.replace(PROTECTION_PREFIX, '');
              if (JSON_START.test(data) && JSON_END.test(data))
                data = fromJson(data, true);
            }
            return data;
          }],
        transformRequest: [function (d) {
            return isObject(d) && !isFile(d) ? toJson(d) : d;
          }],
        headers: {
          common: {
            'Accept': 'application/json, text/plain, */*',
            'X-Requested-With': 'XMLHttpRequest'
          },
          post: { 'Content-Type': 'application/json;charset=utf-8' },
          put: { 'Content-Type': 'application/json;charset=utf-8' }
        }
      };
    var providerResponseInterceptors = this.responseInterceptors = [];
    this.$get = [
      '$httpBackend',
      '$browser',
      '$cacheFactory',
      '$rootScope',
      '$q',
      '$injector',
      function ($httpBackend, $browser, $cacheFactory, $rootScope, $q, $injector) {
        var defaultCache = $cacheFactory('$http'), responseInterceptors = [];
        forEach(providerResponseInterceptors, function (interceptor) {
          responseInterceptors.push(isString(interceptor) ? $injector.get(interceptor) : $injector.invoke(interceptor));
        });
        function $http(config) {
          config.method = uppercase(config.method);
          var reqTransformFn = config.transformRequest || $config.transformRequest, respTransformFn = config.transformResponse || $config.transformResponse, defHeaders = $config.headers, reqHeaders = extend({ 'X-XSRF-TOKEN': $browser.cookies()['XSRF-TOKEN'] }, defHeaders.common, defHeaders[lowercase(config.method)], config.headers), reqData = transformData(config.data, headersGetter(reqHeaders), reqTransformFn), promise;
          if (isUndefined(config.data)) {
            delete reqHeaders['Content-Type'];
          }
          promise = sendReq(config, reqData, reqHeaders);
          promise = promise.then(transformResponse, transformResponse);
          forEach(responseInterceptors, function (interceptor) {
            promise = interceptor(promise);
          });
          promise.success = function (fn) {
            promise.then(function (response) {
              fn(response.data, response.status, response.headers, config);
            });
            return promise;
          };
          promise.error = function (fn) {
            promise.then(null, function (response) {
              fn(response.data, response.status, response.headers, config);
            });
            return promise;
          };
          return promise;
          function transformResponse(response) {
            var resp = extend({}, response, { data: transformData(response.data, response.headers, respTransformFn) });
            return isSuccess(response.status) ? resp : $q.reject(resp);
          }
        }
        $http.pendingRequests = [];
        createShortMethods('get', 'delete', 'head', 'jsonp');
        createShortMethodsWithData('post', 'put');
        $http.defaults = $config;
        return $http;
        function createShortMethods(names) {
          forEach(arguments, function (name) {
            $http[name] = function (url, config) {
              return $http(extend(config || {}, {
                method: name,
                url: url
              }));
            };
          });
        }
        function createShortMethodsWithData(name) {
          forEach(arguments, function (name) {
            $http[name] = function (url, data, config) {
              return $http(extend(config || {}, {
                method: name,
                url: url,
                data: data
              }));
            };
          });
        }
        function sendReq(config, reqData, reqHeaders) {
          var deferred = $q.defer(), promise = deferred.promise, cache, cachedResp, url = buildUrl(config.url, config.params);
          $http.pendingRequests.push(config);
          promise.then(removePendingReq, removePendingReq);
          if (config.cache && config.method == 'GET') {
            cache = isObject(config.cache) ? config.cache : defaultCache;
          }
          if (cache) {
            cachedResp = cache.get(url);
            if (cachedResp) {
              if (cachedResp.then) {
                cachedResp.then(removePendingReq, removePendingReq);
                return cachedResp;
              } else {
                if (isArray(cachedResp)) {
                  resolvePromise(cachedResp[1], cachedResp[0], copy(cachedResp[2]));
                } else {
                  resolvePromise(cachedResp, 200, {});
                }
              }
            } else {
              cache.put(url, promise);
            }
          }
          if (!cachedResp) {
            $httpBackend(config.method, url, reqData, done, reqHeaders, config.timeout, config.withCredentials);
          }
          return promise;
          function done(status, response, headersString) {
            if (cache) {
              if (isSuccess(status)) {
                cache.put(url, [
                  status,
                  response,
                  parseHeaders(headersString)
                ]);
              } else {
                cache.remove(url);
              }
            }
            resolvePromise(response, status, headersString);
            $rootScope.$apply();
          }
          function resolvePromise(response, status, headers) {
            status = Math.max(status, 0);
            (isSuccess(status) ? deferred.resolve : deferred.reject)({
              data: response,
              status: status,
              headers: headersGetter(headers),
              config: config
            });
          }
          function removePendingReq() {
            var idx = indexOf($http.pendingRequests, config);
            if (idx !== -1)
              $http.pendingRequests.splice(idx, 1);
          }
        }
        function buildUrl(url, params) {
          if (!params)
            return url;
          var parts = [];
          forEachSorted(params, function (value, key) {
            if (value == null || value == undefined)
              return;
            if (isObject(value)) {
              value = toJson(value);
            }
            parts.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));
          });
          return url + (url.indexOf('?') == -1 ? '?' : '&') + parts.join('&');
        }
      }
    ];
  }
  var XHR = window.XMLHttpRequest || function () {
      try {
        return new ActiveXObject('Msxml2.XMLHTTP.6.0');
      } catch (e1) {
      }
      try {
        return new ActiveXObject('Msxml2.XMLHTTP.3.0');
      } catch (e2) {
      }
      try {
        return new ActiveXObject('Msxml2.XMLHTTP');
      } catch (e3) {
      }
      throw new Error('This browser does not support XMLHttpRequest.');
    };
  function $HttpBackendProvider() {
    this.$get = [
      '$browser',
      '$window',
      '$document',
      function ($browser, $window, $document) {
        return createHttpBackend($browser, XHR, $browser.defer, $window.angular.callbacks, $document[0], $window.location.protocol.replace(':', ''));
      }
    ];
  }
  function createHttpBackend($browser, XHR, $browserDefer, callbacks, rawDocument, locationProtocol) {
    return function (method, url, post, callback, headers, timeout, withCredentials) {
      $browser.$$incOutstandingRequestCount();
      url = url || $browser.url();
      if (lowercase(method) == 'jsonp') {
        var callbackId = '_' + (callbacks.counter++).toString(36);
        callbacks[callbackId] = function (data) {
          callbacks[callbackId].data = data;
        };
        jsonpReq(url.replace('JSON_CALLBACK', 'angular.callbacks.' + callbackId), function () {
          if (callbacks[callbackId].data) {
            completeRequest(callback, 200, callbacks[callbackId].data);
          } else {
            completeRequest(callback, -2);
          }
          delete callbacks[callbackId];
        });
      } else {
        var xhr = new XHR();
        xhr.open(method, url, true);
        forEach(headers, function (value, key) {
          if (value)
            xhr.setRequestHeader(key, value);
        });
        var status;
        xhr.onreadystatechange = function () {
          if (xhr.readyState == 4) {
            var responseHeaders = xhr.getAllResponseHeaders();
            var value, simpleHeaders = [
                'Cache-Control',
                'Content-Language',
                'Content-Type',
                'Expires',
                'Last-Modified',
                'Pragma'
              ];
            if (!responseHeaders) {
              responseHeaders = '';
              forEach(simpleHeaders, function (header) {
                var value = xhr.getResponseHeader(header);
                if (value) {
                  responseHeaders += header + ': ' + value + '\n';
                }
              });
            }
            completeRequest(callback, status || xhr.status, xhr.responseText, responseHeaders);
          }
        };
        if (withCredentials) {
          xhr.withCredentials = true;
        }
        xhr.send(post || '');
        if (timeout > 0) {
          $browserDefer(function () {
            status = -1;
            xhr.abort();
          }, timeout);
        }
      }
      function completeRequest(callback, status, response, headersString) {
        var protocol = (url.match(URL_MATCH) || [
            '',
            locationProtocol
          ])[1];
        status = protocol == 'file' ? response ? 200 : 404 : status;
        status = status == 1223 ? 204 : status;
        callback(status, response, headersString);
        $browser.$$completeOutstandingRequest(noop);
      }
    };
    function jsonpReq(url, done) {
      var script = rawDocument.createElement('script'), doneWrapper = function () {
          rawDocument.body.removeChild(script);
          if (done)
            done();
        };
      script.type = 'text/javascript';
      script.src = url;
      if (msie) {
        script.onreadystatechange = function () {
          if (/loaded|complete/.test(script.readyState))
            doneWrapper();
        };
      } else {
        script.onload = script.onerror = doneWrapper;
      }
      rawDocument.body.appendChild(script);
    }
  }
  function $LocaleProvider() {
    this.$get = function () {
      return {
        id: 'en-us',
        NUMBER_FORMATS: {
          DECIMAL_SEP: '.',
          GROUP_SEP: ',',
          PATTERNS: [
            {
              minInt: 1,
              minFrac: 0,
              maxFrac: 3,
              posPre: '',
              posSuf: '',
              negPre: '-',
              negSuf: '',
              gSize: 3,
              lgSize: 3
            },
            {
              minInt: 1,
              minFrac: 2,
              maxFrac: 2,
              posPre: '\xa4',
              posSuf: '',
              negPre: '(\xa4',
              negSuf: ')',
              gSize: 3,
              lgSize: 3
            }
          ],
          CURRENCY_SYM: '$'
        },
        DATETIME_FORMATS: {
          MONTH: 'January,February,March,April,May,June,July,August,September,October,November,December'.split(','),
          SHORTMONTH: 'Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec'.split(','),
          DAY: 'Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday'.split(','),
          SHORTDAY: 'Sun,Mon,Tue,Wed,Thu,Fri,Sat'.split(','),
          AMPMS: [
            'AM',
            'PM'
          ],
          medium: 'MMM d, y h:mm:ss a',
          short: 'M/d/yy h:mm a',
          fullDate: 'EEEE, MMMM d, y',
          longDate: 'MMMM d, y',
          mediumDate: 'MMM d, y',
          shortDate: 'M/d/yy',
          mediumTime: 'h:mm:ss a',
          shortTime: 'h:mm a'
        },
        pluralCat: function (num) {
          if (num === 1) {
            return 'one';
          }
          return 'other';
        }
      };
    };
  }
  function $TimeoutProvider() {
    this.$get = [
      '$rootScope',
      '$browser',
      '$q',
      '$exceptionHandler',
      function ($rootScope, $browser, $q, $exceptionHandler) {
        var deferreds = {};
        function timeout(fn, delay, invokeApply) {
          var deferred = $q.defer(), promise = deferred.promise, skipApply = isDefined(invokeApply) && !invokeApply, timeoutId, cleanup;
          timeoutId = $browser.defer(function () {
            try {
              deferred.resolve(fn());
            } catch (e) {
              deferred.reject(e);
              $exceptionHandler(e);
            }
            if (!skipApply)
              $rootScope.$apply();
          }, delay);
          cleanup = function () {
            delete deferreds[promise.$$timeoutId];
          };
          promise.$$timeoutId = timeoutId;
          deferreds[timeoutId] = deferred;
          promise.then(cleanup, cleanup);
          return promise;
        }
        timeout.cancel = function (promise) {
          if (promise && promise.$$timeoutId in deferreds) {
            deferreds[promise.$$timeoutId].reject('canceled');
            return $browser.defer.cancel(promise.$$timeoutId);
          }
          return false;
        };
        return timeout;
      }
    ];
  }
  $FilterProvider.$inject = ['$provide'];
  function $FilterProvider($provide) {
    var suffix = 'Filter';
    function register(name, factory) {
      return $provide.factory(name + suffix, factory);
    }
    this.register = register;
    this.$get = [
      '$injector',
      function ($injector) {
        return function (name) {
          return $injector.get(name + suffix);
        };
      }
    ];
    register('currency', currencyFilter);
    register('date', dateFilter);
    register('filter', filterFilter);
    register('json', jsonFilter);
    register('limitTo', limitToFilter);
    register('lowercase', lowercaseFilter);
    register('number', numberFilter);
    register('orderBy', orderByFilter);
    register('uppercase', uppercaseFilter);
  }
  function filterFilter() {
    return function (array, expression) {
      if (!isArray(array))
        return array;
      var predicates = [];
      predicates.check = function (value) {
        for (var j = 0; j < predicates.length; j++) {
          if (!predicates[j](value)) {
            return false;
          }
        }
        return true;
      };
      var search = function (obj, text) {
        if (text.charAt(0) === '!') {
          return !search(obj, text.substr(1));
        }
        switch (typeof obj) {
        case 'boolean':
        case 'number':
        case 'string':
          return ('' + obj).toLowerCase().indexOf(text) > -1;
        case 'object':
          for (var objKey in obj) {
            if (objKey.charAt(0) !== '$' && search(obj[objKey], text)) {
              return true;
            }
          }
          return false;
        case 'array':
          for (var i = 0; i < obj.length; i++) {
            if (search(obj[i], text)) {
              return true;
            }
          }
          return false;
        default:
          return false;
        }
      };
      switch (typeof expression) {
      case 'boolean':
      case 'number':
      case 'string':
        expression = { $: expression };
      case 'object':
        for (var key in expression) {
          if (key == '$') {
            (function () {
              var text = ('' + expression[key]).toLowerCase();
              if (!text)
                return;
              predicates.push(function (value) {
                return search(value, text);
              });
            }());
          } else {
            (function () {
              var path = key;
              var text = ('' + expression[key]).toLowerCase();
              if (!text)
                return;
              predicates.push(function (value) {
                return search(getter(value, path), text);
              });
            }());
          }
        }
        break;
      case 'function':
        predicates.push(expression);
        break;
      default:
        return array;
      }
      var filtered = [];
      for (var j = 0; j < array.length; j++) {
        var value = array[j];
        if (predicates.check(value)) {
          filtered.push(value);
        }
      }
      return filtered;
    };
  }
  currencyFilter.$inject = ['$locale'];
  function currencyFilter($locale) {
    var formats = $locale.NUMBER_FORMATS;
    return function (amount, currencySymbol) {
      if (isUndefined(currencySymbol))
        currencySymbol = formats.CURRENCY_SYM;
      return formatNumber(amount, formats.PATTERNS[1], formats.GROUP_SEP, formats.DECIMAL_SEP, 2).replace(/\u00A4/g, currencySymbol);
    };
  }
  numberFilter.$inject = ['$locale'];
  function numberFilter($locale) {
    var formats = $locale.NUMBER_FORMATS;
    return function (number, fractionSize) {
      return formatNumber(number, formats.PATTERNS[0], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize);
    };
  }
  var DECIMAL_SEP = '.';
  function formatNumber(number, pattern, groupSep, decimalSep, fractionSize) {
    if (isNaN(number) || !isFinite(number))
      return '';
    var isNegative = number < 0;
    number = Math.abs(number);
    var numStr = number + '', formatedText = '', parts = [];
    var hasExponent = false;
    if (numStr.indexOf('e') !== -1) {
      var match = numStr.match(/([\d\.]+)e(-?)(\d+)/);
      if (match && match[2] == '-' && match[3] > fractionSize + 1) {
        numStr = '0';
      } else {
        formatedText = numStr;
        hasExponent = true;
      }
    }
    if (!hasExponent) {
      var fractionLen = (numStr.split(DECIMAL_SEP)[1] || '').length;
      if (isUndefined(fractionSize)) {
        fractionSize = Math.min(Math.max(pattern.minFrac, fractionLen), pattern.maxFrac);
      }
      var pow = Math.pow(10, fractionSize);
      number = Math.round(number * pow) / pow;
      var fraction = ('' + number).split(DECIMAL_SEP);
      var whole = fraction[0];
      fraction = fraction[1] || '';
      var pos = 0, lgroup = pattern.lgSize, group = pattern.gSize;
      if (whole.length >= lgroup + group) {
        pos = whole.length - lgroup;
        for (var i = 0; i < pos; i++) {
          if ((pos - i) % group === 0 && i !== 0) {
            formatedText += groupSep;
          }
          formatedText += whole.charAt(i);
        }
      }
      for (i = pos; i < whole.length; i++) {
        if ((whole.length - i) % lgroup === 0 && i !== 0) {
          formatedText += groupSep;
        }
        formatedText += whole.charAt(i);
      }
      while (fraction.length < fractionSize) {
        fraction += '0';
      }
      if (fractionSize && fractionSize !== '0')
        formatedText += decimalSep + fraction.substr(0, fractionSize);
    }
    parts.push(isNegative ? pattern.negPre : pattern.posPre);
    parts.push(formatedText);
    parts.push(isNegative ? pattern.negSuf : pattern.posSuf);
    return parts.join('');
  }
  function padNumber(num, digits, trim) {
    var neg = '';
    if (num < 0) {
      neg = '-';
      num = -num;
    }
    num = '' + num;
    while (num.length < digits)
      num = '0' + num;
    if (trim)
      num = num.substr(num.length - digits);
    return neg + num;
  }
  function dateGetter(name, size, offset, trim) {
    offset = offset || 0;
    return function (date) {
      var value = date['get' + name]();
      if (offset > 0 || value > -offset)
        value += offset;
      if (value === 0 && offset == -12)
        value = 12;
      return padNumber(value, size, trim);
    };
  }
  function dateStrGetter(name, shortForm) {
    return function (date, formats) {
      var value = date['get' + name]();
      var get = uppercase(shortForm ? 'SHORT' + name : name);
      return formats[get][value];
    };
  }
  function timeZoneGetter(date) {
    var zone = -1 * date.getTimezoneOffset();
    var paddedZone = zone >= 0 ? '+' : '';
    paddedZone += padNumber(Math[zone > 0 ? 'floor' : 'ceil'](zone / 60), 2) + padNumber(Math.abs(zone % 60), 2);
    return paddedZone;
  }
  function ampmGetter(date, formats) {
    return date.getHours() < 12 ? formats.AMPMS[0] : formats.AMPMS[1];
  }
  var DATE_FORMATS = {
      yyyy: dateGetter('FullYear', 4),
      yy: dateGetter('FullYear', 2, 0, true),
      y: dateGetter('FullYear', 1),
      MMMM: dateStrGetter('Month'),
      MMM: dateStrGetter('Month', true),
      MM: dateGetter('Month', 2, 1),
      M: dateGetter('Month', 1, 1),
      dd: dateGetter('Date', 2),
      d: dateGetter('Date', 1),
      HH: dateGetter('Hours', 2),
      H: dateGetter('Hours', 1),
      hh: dateGetter('Hours', 2, -12),
      h: dateGetter('Hours', 1, -12),
      mm: dateGetter('Minutes', 2),
      m: dateGetter('Minutes', 1),
      ss: dateGetter('Seconds', 2),
      s: dateGetter('Seconds', 1),
      EEEE: dateStrGetter('Day'),
      EEE: dateStrGetter('Day', true),
      a: ampmGetter,
      Z: timeZoneGetter
    };
  var DATE_FORMATS_SPLIT = /((?:[^yMdHhmsaZE']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|d+|H+|h+|m+|s+|a|Z))(.*)/, NUMBER_STRING = /^\d+$/;
  dateFilter.$inject = ['$locale'];
  function dateFilter($locale) {
    var R_ISO8601_STR = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
    function jsonStringToDate(string) {
      var match;
      if (match = string.match(R_ISO8601_STR)) {
        var date = new Date(0), tzHour = 0, tzMin = 0;
        if (match[9]) {
          tzHour = int(match[9] + match[10]);
          tzMin = int(match[9] + match[11]);
        }
        date.setUTCFullYear(int(match[1]), int(match[2]) - 1, int(match[3]));
        date.setUTCHours(int(match[4] || 0) - tzHour, int(match[5] || 0) - tzMin, int(match[6] || 0), int(match[7] || 0));
        return date;
      }
      return string;
    }
    return function (date, format) {
      var text = '', parts = [], fn, match;
      format = format || 'mediumDate';
      format = $locale.DATETIME_FORMATS[format] || format;
      if (isString(date)) {
        if (NUMBER_STRING.test(date)) {
          date = int(date);
        } else {
          date = jsonStringToDate(date);
        }
      }
      if (isNumber(date)) {
        date = new Date(date);
      }
      if (!isDate(date)) {
        return date;
      }
      while (format) {
        match = DATE_FORMATS_SPLIT.exec(format);
        if (match) {
          parts = concat(parts, match, 1);
          format = parts.pop();
        } else {
          parts.push(format);
          format = null;
        }
      }
      forEach(parts, function (value) {
        fn = DATE_FORMATS[value];
        text += fn ? fn(date, $locale.DATETIME_FORMATS) : value.replace(/(^'|'$)/g, '').replace(/''/g, '\'');
      });
      return text;
    };
  }
  function jsonFilter() {
    return function (object) {
      return toJson(object, true);
    };
  }
  var lowercaseFilter = valueFn(lowercase);
  var uppercaseFilter = valueFn(uppercase);
  function limitToFilter() {
    return function (array, limit) {
      if (!(array instanceof Array))
        return array;
      limit = int(limit);
      var out = [], i, n;
      if (!array || !(array instanceof Array))
        return out;
      if (limit > array.length)
        limit = array.length;
      else if (limit < -array.length)
        limit = -array.length;
      if (limit > 0) {
        i = 0;
        n = limit;
      } else {
        i = array.length + limit;
        n = array.length;
      }
      for (; i < n; i++) {
        out.push(array[i]);
      }
      return out;
    };
  }
  orderByFilter.$inject = ['$parse'];
  function orderByFilter($parse) {
    return function (array, sortPredicate, reverseOrder) {
      if (!isArray(array))
        return array;
      if (!sortPredicate)
        return array;
      sortPredicate = isArray(sortPredicate) ? sortPredicate : [sortPredicate];
      sortPredicate = map(sortPredicate, function (predicate) {
        var descending = false, get = predicate || identity;
        if (isString(predicate)) {
          if (predicate.charAt(0) == '+' || predicate.charAt(0) == '-') {
            descending = predicate.charAt(0) == '-';
            predicate = predicate.substring(1);
          }
          get = $parse(predicate);
        }
        return reverseComparator(function (a, b) {
          return compare(get(a), get(b));
        }, descending);
      });
      var arrayCopy = [];
      for (var i = 0; i < array.length; i++) {
        arrayCopy.push(array[i]);
      }
      return arrayCopy.sort(reverseComparator(comparator, reverseOrder));
      function comparator(o1, o2) {
        for (var i = 0; i < sortPredicate.length; i++) {
          var comp = sortPredicate[i](o1, o2);
          if (comp !== 0)
            return comp;
        }
        return 0;
      }
      function reverseComparator(comp, descending) {
        return toBoolean(descending) ? function (a, b) {
          return comp(b, a);
        } : comp;
      }
      function compare(v1, v2) {
        var t1 = typeof v1;
        var t2 = typeof v2;
        if (t1 == t2) {
          if (t1 == 'string')
            v1 = v1.toLowerCase();
          if (t1 == 'string')
            v2 = v2.toLowerCase();
          if (v1 === v2)
            return 0;
          return v1 < v2 ? -1 : 1;
        } else {
          return t1 < t2 ? -1 : 1;
        }
      }
    };
  }
  function ngDirective(directive) {
    if (isFunction(directive)) {
      directive = { link: directive };
    }
    directive.restrict = directive.restrict || 'AC';
    return valueFn(directive);
  }
  var htmlAnchorDirective = valueFn({
      restrict: 'E',
      compile: function (element, attr) {
        if (msie <= 8) {
          if (!attr.href && !attr.name) {
            attr.$set('href', '');
          }
          element.append(document.createComment('IE fix'));
        }
        return function (scope, element) {
          element.bind('click', function (event) {
            if (!element.attr('href')) {
              event.preventDefault();
            }
          });
        };
      }
    });
  var ngAttributeAliasDirectives = {};
  forEach(BOOLEAN_ATTR, function (propName, attrName) {
    var normalized = directiveNormalize('ng-' + attrName);
    ngAttributeAliasDirectives[normalized] = function () {
      return {
        priority: 100,
        compile: function () {
          return function (scope, element, attr) {
            scope.$watch(attr[normalized], function ngBooleanAttrWatchAction(value) {
              attr.$set(attrName, !!value);
            });
          };
        }
      };
    };
  });
  forEach([
    'src',
    'href'
  ], function (attrName) {
    var normalized = directiveNormalize('ng-' + attrName);
    ngAttributeAliasDirectives[normalized] = function () {
      return {
        priority: 99,
        link: function (scope, element, attr) {
          attr.$observe(normalized, function (value) {
            if (!value)
              return;
            attr.$set(attrName, value);
            if (msie)
              element.prop(attrName, attr[attrName]);
          });
        }
      };
    };
  });
  var nullFormCtrl = {
      $addControl: noop,
      $removeControl: noop,
      $setValidity: noop,
      $setDirty: noop
    };
  FormController.$inject = [
    '$element',
    '$attrs',
    '$scope'
  ];
  function FormController(element, attrs) {
    var form = this, parentForm = element.parent().controller('form') || nullFormCtrl, invalidCount = 0, errors = form.$error = {};
    form.$name = attrs.name;
    form.$dirty = false;
    form.$pristine = true;
    form.$valid = true;
    form.$invalid = false;
    parentForm.$addControl(form);
    element.addClass(PRISTINE_CLASS);
    toggleValidCss(true);
    function toggleValidCss(isValid, validationErrorKey) {
      validationErrorKey = validationErrorKey ? '-' + snake_case(validationErrorKey, '-') : '';
      element.removeClass((isValid ? INVALID_CLASS : VALID_CLASS) + validationErrorKey).addClass((isValid ? VALID_CLASS : INVALID_CLASS) + validationErrorKey);
    }
    form.$addControl = function (control) {
      if (control.$name && !form.hasOwnProperty(control.$name)) {
        form[control.$name] = control;
      }
    };
    form.$removeControl = function (control) {
      if (control.$name && form[control.$name] === control) {
        delete form[control.$name];
      }
      forEach(errors, function (queue, validationToken) {
        form.$setValidity(validationToken, true, control);
      });
    };
    form.$setValidity = function (validationToken, isValid, control) {
      var queue = errors[validationToken];
      if (isValid) {
        if (queue) {
          arrayRemove(queue, control);
          if (!queue.length) {
            invalidCount--;
            if (!invalidCount) {
              toggleValidCss(isValid);
              form.$valid = true;
              form.$invalid = false;
            }
            errors[validationToken] = false;
            toggleValidCss(true, validationToken);
            parentForm.$setValidity(validationToken, true, form);
          }
        }
      } else {
        if (!invalidCount) {
          toggleValidCss(isValid);
        }
        if (queue) {
          if (includes(queue, control))
            return;
        } else {
          errors[validationToken] = queue = [];
          invalidCount++;
          toggleValidCss(false, validationToken);
          parentForm.$setValidity(validationToken, false, form);
        }
        queue.push(control);
        form.$valid = false;
        form.$invalid = true;
      }
    };
    form.$setDirty = function () {
      element.removeClass(PRISTINE_CLASS).addClass(DIRTY_CLASS);
      form.$dirty = true;
      form.$pristine = false;
      parentForm.$setDirty();
    };
  }
  var formDirectiveFactory = function (isNgForm) {
    return [
      '$timeout',
      function ($timeout) {
        var formDirective = {
            name: 'form',
            restrict: 'E',
            controller: FormController,
            compile: function () {
              return {
                pre: function (scope, formElement, attr, controller) {
                  if (!attr.action) {
                    var preventDefaultListener = function (event) {
                      event.preventDefault ? event.preventDefault() : event.returnValue = false;
                    };
                    addEventListenerFn(formElement[0], 'submit', preventDefaultListener);
                    formElement.bind('$destroy', function () {
                      $timeout(function () {
                        removeEventListenerFn(formElement[0], 'submit', preventDefaultListener);
                      }, 0, false);
                    });
                  }
                  var parentFormCtrl = formElement.parent().controller('form'), alias = attr.name || attr.ngForm;
                  if (alias) {
                    scope[alias] = controller;
                  }
                  if (parentFormCtrl) {
                    formElement.bind('$destroy', function () {
                      parentFormCtrl.$removeControl(controller);
                      if (alias) {
                        scope[alias] = undefined;
                      }
                      extend(controller, nullFormCtrl);
                    });
                  }
                }
              };
            }
          };
        return isNgForm ? extend(copy(formDirective), { restrict: 'EAC' }) : formDirective;
      }
    ];
  };
  var formDirective = formDirectiveFactory();
  var ngFormDirective = formDirectiveFactory(true);
  var URL_REGEXP = /^(ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-\/]))?$/;
  var EMAIL_REGEXP = /^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,4}$/;
  var NUMBER_REGEXP = /^\s*(\-|\+)?(\d+|(\d*(\.\d*)))\s*$/;
  var inputType = {
      'text': textInputType,
      'number': numberInputType,
      'url': urlInputType,
      'email': emailInputType,
      'radio': radioInputType,
      'checkbox': checkboxInputType,
      'hidden': noop,
      'button': noop,
      'submit': noop,
      'reset': noop
    };
  function isEmpty(value) {
    return isUndefined(value) || value === '' || value === null || value !== value;
  }
  function textInputType(scope, element, attr, ctrl, $sniffer, $browser) {
    var listener = function () {
      var value = trim(element.val());
      if (ctrl.$viewValue !== value) {
        scope.$apply(function () {
          ctrl.$setViewValue(value);
        });
      }
    };
    if ($sniffer.hasEvent('input')) {
      element.bind('input', listener);
    } else {
      var timeout;
      var deferListener = function () {
        if (!timeout) {
          timeout = $browser.defer(function () {
            listener();
            timeout = null;
          });
        }
      };
      element.bind('keydown', function (event) {
        var key = event.keyCode;
        if (key === 91 || 15 < key && key < 19 || 37 <= key && key <= 40)
          return;
        deferListener();
      });
      element.bind('change', listener);
      if ($sniffer.hasEvent('paste')) {
        element.bind('paste cut', deferListener);
      }
    }
    ctrl.$render = function () {
      element.val(isEmpty(ctrl.$viewValue) ? '' : ctrl.$viewValue);
    };
    var pattern = attr.ngPattern, patternValidator;
    var validate = function (regexp, value) {
      if (isEmpty(value) || regexp.test(value)) {
        ctrl.$setValidity('pattern', true);
        return value;
      } else {
        ctrl.$setValidity('pattern', false);
        return undefined;
      }
    };
    if (pattern) {
      if (pattern.match(/^\/(.*)\/$/)) {
        pattern = new RegExp(pattern.substr(1, pattern.length - 2));
        patternValidator = function (value) {
          return validate(pattern, value);
        };
      } else {
        patternValidator = function (value) {
          var patternObj = scope.$eval(pattern);
          if (!patternObj || !patternObj.test) {
            throw new Error('Expected ' + pattern + ' to be a RegExp but was ' + patternObj);
          }
          return validate(patternObj, value);
        };
      }
      ctrl.$formatters.push(patternValidator);
      ctrl.$parsers.push(patternValidator);
    }
    if (attr.ngMinlength) {
      var minlength = int(attr.ngMinlength);
      var minLengthValidator = function (value) {
        if (!isEmpty(value) && value.length < minlength) {
          ctrl.$setValidity('minlength', false);
          return undefined;
        } else {
          ctrl.$setValidity('minlength', true);
          return value;
        }
      };
      ctrl.$parsers.push(minLengthValidator);
      ctrl.$formatters.push(minLengthValidator);
    }
    if (attr.ngMaxlength) {
      var maxlength = int(attr.ngMaxlength);
      var maxLengthValidator = function (value) {
        if (!isEmpty(value) && value.length > maxlength) {
          ctrl.$setValidity('maxlength', false);
          return undefined;
        } else {
          ctrl.$setValidity('maxlength', true);
          return value;
        }
      };
      ctrl.$parsers.push(maxLengthValidator);
      ctrl.$formatters.push(maxLengthValidator);
    }
  }
  function numberInputType(scope, element, attr, ctrl, $sniffer, $browser) {
    textInputType(scope, element, attr, ctrl, $sniffer, $browser);
    ctrl.$parsers.push(function (value) {
      var empty = isEmpty(value);
      if (empty || NUMBER_REGEXP.test(value)) {
        ctrl.$setValidity('number', true);
        return value === '' ? null : empty ? value : parseFloat(value);
      } else {
        ctrl.$setValidity('number', false);
        return undefined;
      }
    });
    ctrl.$formatters.push(function (value) {
      return isEmpty(value) ? '' : '' + value;
    });
    if (attr.min) {
      var min = parseFloat(attr.min);
      var minValidator = function (value) {
        if (!isEmpty(value) && value < min) {
          ctrl.$setValidity('min', false);
          return undefined;
        } else {
          ctrl.$setValidity('min', true);
          return value;
        }
      };
      ctrl.$parsers.push(minValidator);
      ctrl.$formatters.push(minValidator);
    }
    if (attr.max) {
      var max = parseFloat(attr.max);
      var maxValidator = function (value) {
        if (!isEmpty(value) && value > max) {
          ctrl.$setValidity('max', false);
          return undefined;
        } else {
          ctrl.$setValidity('max', true);
          return value;
        }
      };
      ctrl.$parsers.push(maxValidator);
      ctrl.$formatters.push(maxValidator);
    }
    ctrl.$formatters.push(function (value) {
      if (isEmpty(value) || isNumber(value)) {
        ctrl.$setValidity('number', true);
        return value;
      } else {
        ctrl.$setValidity('number', false);
        return undefined;
      }
    });
  }
  function urlInputType(scope, element, attr, ctrl, $sniffer, $browser) {
    textInputType(scope, element, attr, ctrl, $sniffer, $browser);
    var urlValidator = function (value) {
      if (isEmpty(value) || URL_REGEXP.test(value)) {
        ctrl.$setValidity('url', true);
        return value;
      } else {
        ctrl.$setValidity('url', false);
        return undefined;
      }
    };
    ctrl.$formatters.push(urlValidator);
    ctrl.$parsers.push(urlValidator);
  }
  function emailInputType(scope, element, attr, ctrl, $sniffer, $browser) {
    textInputType(scope, element, attr, ctrl, $sniffer, $browser);
    var emailValidator = function (value) {
      if (isEmpty(value) || EMAIL_REGEXP.test(value)) {
        ctrl.$setValidity('email', true);
        return value;
      } else {
        ctrl.$setValidity('email', false);
        return undefined;
      }
    };
    ctrl.$formatters.push(emailValidator);
    ctrl.$parsers.push(emailValidator);
  }
  function radioInputType(scope, element, attr, ctrl) {
    if (isUndefined(attr.name)) {
      element.attr('name', nextUid());
    }
    element.bind('click', function () {
      if (element[0].checked) {
        scope.$apply(function () {
          ctrl.$setViewValue(attr.value);
        });
      }
    });
    ctrl.$render = function () {
      var value = attr.value;
      element[0].checked = value == ctrl.$viewValue;
    };
    attr.$observe('value', ctrl.$render);
  }
  function checkboxInputType(scope, element, attr, ctrl) {
    var trueValue = attr.ngTrueValue, falseValue = attr.ngFalseValue;
    if (!isString(trueValue))
      trueValue = true;
    if (!isString(falseValue))
      falseValue = false;
    element.bind('click', function () {
      scope.$apply(function () {
        ctrl.$setViewValue(element[0].checked);
      });
    });
    ctrl.$render = function () {
      element[0].checked = ctrl.$viewValue;
    };
    ctrl.$formatters.push(function (value) {
      return value === trueValue;
    });
    ctrl.$parsers.push(function (value) {
      return value ? trueValue : falseValue;
    });
  }
  var inputDirective = [
      '$browser',
      '$sniffer',
      function ($browser, $sniffer) {
        return {
          restrict: 'E',
          require: '?ngModel',
          link: function (scope, element, attr, ctrl) {
            if (ctrl) {
              (inputType[lowercase(attr.type)] || inputType.text)(scope, element, attr, ctrl, $sniffer, $browser);
            }
          }
        };
      }
    ];
  var VALID_CLASS = 'ng-valid', INVALID_CLASS = 'ng-invalid', PRISTINE_CLASS = 'ng-pristine', DIRTY_CLASS = 'ng-dirty';
  var NgModelController = [
      '$scope',
      '$exceptionHandler',
      '$attrs',
      '$element',
      '$parse',
      function ($scope, $exceptionHandler, $attr, $element, $parse) {
        this.$viewValue = Number.NaN;
        this.$modelValue = Number.NaN;
        this.$parsers = [];
        this.$formatters = [];
        this.$viewChangeListeners = [];
        this.$pristine = true;
        this.$dirty = false;
        this.$valid = true;
        this.$invalid = false;
        this.$name = $attr.name;
        var ngModelGet = $parse($attr.ngModel), ngModelSet = ngModelGet.assign;
        if (!ngModelSet) {
          throw Error(NON_ASSIGNABLE_MODEL_EXPRESSION + $attr.ngModel + ' (' + startingTag($element) + ')');
        }
        this.$render = noop;
        var parentForm = $element.inheritedData('$formController') || nullFormCtrl, invalidCount = 0, $error = this.$error = {};
        $element.addClass(PRISTINE_CLASS);
        toggleValidCss(true);
        function toggleValidCss(isValid, validationErrorKey) {
          validationErrorKey = validationErrorKey ? '-' + snake_case(validationErrorKey, '-') : '';
          $element.removeClass((isValid ? INVALID_CLASS : VALID_CLASS) + validationErrorKey).addClass((isValid ? VALID_CLASS : INVALID_CLASS) + validationErrorKey);
        }
        this.$setValidity = function (validationErrorKey, isValid) {
          if ($error[validationErrorKey] === !isValid)
            return;
          if (isValid) {
            if ($error[validationErrorKey])
              invalidCount--;
            if (!invalidCount) {
              toggleValidCss(true);
              this.$valid = true;
              this.$invalid = false;
            }
          } else {
            toggleValidCss(false);
            this.$invalid = true;
            this.$valid = false;
            invalidCount++;
          }
          $error[validationErrorKey] = !isValid;
          toggleValidCss(isValid, validationErrorKey);
          parentForm.$setValidity(validationErrorKey, isValid, this);
        };
        this.$setViewValue = function (value) {
          this.$viewValue = value;
          if (this.$pristine) {
            this.$dirty = true;
            this.$pristine = false;
            $element.removeClass(PRISTINE_CLASS).addClass(DIRTY_CLASS);
            parentForm.$setDirty();
          }
          forEach(this.$parsers, function (fn) {
            value = fn(value);
          });
          if (this.$modelValue !== value) {
            this.$modelValue = value;
            ngModelSet($scope, value);
            forEach(this.$viewChangeListeners, function (listener) {
              try {
                listener();
              } catch (e) {
                $exceptionHandler(e);
              }
            });
          }
        };
        var ctrl = this;
        $scope.$watch(function ngModelWatch() {
          var value = ngModelGet($scope);
          if (ctrl.$modelValue !== value) {
            var formatters = ctrl.$formatters, idx = formatters.length;
            ctrl.$modelValue = value;
            while (idx--) {
              value = formatters[idx](value);
            }
            if (ctrl.$viewValue !== value) {
              ctrl.$viewValue = value;
              ctrl.$render();
            }
          }
        });
      }
    ];
  var ngModelDirective = function () {
    return {
      require: [
        'ngModel',
        '^?form'
      ],
      controller: NgModelController,
      link: function (scope, element, attr, ctrls) {
        var modelCtrl = ctrls[0], formCtrl = ctrls[1] || nullFormCtrl;
        formCtrl.$addControl(modelCtrl);
        element.bind('$destroy', function () {
          formCtrl.$removeControl(modelCtrl);
        });
      }
    };
  };
  var ngChangeDirective = valueFn({
      require: 'ngModel',
      link: function (scope, element, attr, ctrl) {
        ctrl.$viewChangeListeners.push(function () {
          scope.$eval(attr.ngChange);
        });
      }
    });
  var requiredDirective = function () {
    return {
      require: '?ngModel',
      link: function (scope, elm, attr, ctrl) {
        if (!ctrl)
          return;
        attr.required = true;
        var validator = function (value) {
          if (attr.required && (isEmpty(value) || value === false)) {
            ctrl.$setValidity('required', false);
            return;
          } else {
            ctrl.$setValidity('required', true);
            return value;
          }
        };
        ctrl.$formatters.push(validator);
        ctrl.$parsers.unshift(validator);
        attr.$observe('required', function () {
          validator(ctrl.$viewValue);
        });
      }
    };
  };
  var ngListDirective = function () {
    return {
      require: 'ngModel',
      link: function (scope, element, attr, ctrl) {
        var match = /\/(.*)\//.exec(attr.ngList), separator = match && new RegExp(match[1]) || attr.ngList || ',';
        var parse = function (viewValue) {
          var list = [];
          if (viewValue) {
            forEach(viewValue.split(separator), function (value) {
              if (value)
                list.push(trim(value));
            });
          }
          return list;
        };
        ctrl.$parsers.push(parse);
        ctrl.$formatters.push(function (value) {
          if (isArray(value)) {
            return value.join(', ');
          }
          return undefined;
        });
      }
    };
  };
  var CONSTANT_VALUE_REGEXP = /^(true|false|\d+)$/;
  var ngValueDirective = function () {
    return {
      priority: 100,
      compile: function (tpl, tplAttr) {
        if (CONSTANT_VALUE_REGEXP.test(tplAttr.ngValue)) {
          return function (scope, elm, attr) {
            attr.$set('value', scope.$eval(attr.ngValue));
          };
        } else {
          return function (scope, elm, attr) {
            scope.$watch(attr.ngValue, function valueWatchAction(value) {
              attr.$set('value', value, false);
            });
          };
        }
      }
    };
  };
  var ngBindDirective = ngDirective(function (scope, element, attr) {
      element.addClass('ng-binding').data('$binding', attr.ngBind);
      scope.$watch(attr.ngBind, function ngBindWatchAction(value) {
        element.text(value == undefined ? '' : value);
      });
    });
  var ngBindTemplateDirective = [
      '$interpolate',
      function ($interpolate) {
        return function (scope, element, attr) {
          var interpolateFn = $interpolate(element.attr(attr.$attr.ngBindTemplate));
          element.addClass('ng-binding').data('$binding', interpolateFn);
          attr.$observe('ngBindTemplate', function (value) {
            element.text(value);
          });
        };
      }
    ];
  var ngBindHtmlUnsafeDirective = [function () {
        return function (scope, element, attr) {
          element.addClass('ng-binding').data('$binding', attr.ngBindHtmlUnsafe);
          scope.$watch(attr.ngBindHtmlUnsafe, function ngBindHtmlUnsafeWatchAction(value) {
            element.html(value || '');
          });
        };
      }];
  function classDirective(name, selector) {
    name = 'ngClass' + name;
    return ngDirective(function (scope, element, attr) {
      var oldVal = undefined;
      scope.$watch(attr[name], ngClassWatchAction, true);
      attr.$observe('class', function (value) {
        var ngClass = scope.$eval(attr[name]);
        ngClassWatchAction(ngClass, ngClass);
      });
      if (name !== 'ngClass') {
        scope.$watch('$index', function ($index, old$index) {
          var mod = $index & 1;
          if (mod !== old$index & 1) {
            if (mod === selector) {
              addClass(scope.$eval(attr[name]));
            } else {
              removeClass(scope.$eval(attr[name]));
            }
          }
        });
      }
      function ngClassWatchAction(newVal) {
        if (selector === true || scope.$index % 2 === selector) {
          if (oldVal && !equals(newVal, oldVal)) {
            removeClass(oldVal);
          }
          addClass(newVal);
        }
        oldVal = copy(newVal);
      }
      function removeClass(classVal) {
        if (isObject(classVal) && !isArray(classVal)) {
          classVal = map(classVal, function (v, k) {
            if (v)
              return k;
          });
        }
        element.removeClass(isArray(classVal) ? classVal.join(' ') : classVal);
      }
      function addClass(classVal) {
        if (isObject(classVal) && !isArray(classVal)) {
          classVal = map(classVal, function (v, k) {
            if (v)
              return k;
          });
        }
        if (classVal) {
          element.addClass(isArray(classVal) ? classVal.join(' ') : classVal);
        }
      }
    });
  }
  var ngClassDirective = classDirective('', true);
  var ngClassOddDirective = classDirective('Odd', 0);
  var ngClassEvenDirective = classDirective('Even', 1);
  var ngCloakDirective = ngDirective({
      compile: function (element, attr) {
        attr.$set('ngCloak', undefined);
        element.removeClass('ng-cloak');
      }
    });
  var ngControllerDirective = [function () {
        return {
          scope: true,
          controller: '@'
        };
      }];
  var ngCspDirective = [
      '$sniffer',
      function ($sniffer) {
        return {
          priority: 1000,
          compile: function () {
            $sniffer.csp = true;
          }
        };
      }
    ];
  var ngEventDirectives = {};
  forEach('click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave'.split(' '), function (name) {
    var directiveName = directiveNormalize('ng-' + name);
    ngEventDirectives[directiveName] = [
      '$parse',
      function ($parse) {
        return function (scope, element, attr) {
          var fn = $parse(attr[directiveName]);
          element.bind(lowercase(name), function (event) {
            scope.$apply(function () {
              fn(scope, { $event: event });
            });
          });
        };
      }
    ];
  });
  var ngSubmitDirective = ngDirective(function (scope, element, attrs) {
      element.bind('submit', function () {
        scope.$apply(attrs.ngSubmit);
      });
    });
  var ngIncludeDirective = [
      '$http',
      '$templateCache',
      '$anchorScroll',
      '$compile',
      function ($http, $templateCache, $anchorScroll, $compile) {
        return {
          restrict: 'ECA',
          terminal: true,
          compile: function (element, attr) {
            var srcExp = attr.ngInclude || attr.src, onloadExp = attr.onload || '', autoScrollExp = attr.autoscroll;
            return function (scope, element) {
              var changeCounter = 0, childScope;
              var clearContent = function () {
                if (childScope) {
                  childScope.$destroy();
                  childScope = null;
                }
                element.html('');
              };
              scope.$watch(srcExp, function ngIncludeWatchAction(src) {
                var thisChangeId = ++changeCounter;
                if (src) {
                  $http.get(src, { cache: $templateCache }).success(function (response) {
                    if (thisChangeId !== changeCounter)
                      return;
                    if (childScope)
                      childScope.$destroy();
                    childScope = scope.$new();
                    element.html(response);
                    $compile(element.contents())(childScope);
                    if (isDefined(autoScrollExp) && (!autoScrollExp || scope.$eval(autoScrollExp))) {
                      $anchorScroll();
                    }
                    childScope.$emit('$includeContentLoaded');
                    scope.$eval(onloadExp);
                  }).error(function () {
                    if (thisChangeId === changeCounter)
                      clearContent();
                  });
                } else
                  clearContent();
              });
            };
          }
        };
      }
    ];
  var ngInitDirective = ngDirective({
      compile: function () {
        return {
          pre: function (scope, element, attrs) {
            scope.$eval(attrs.ngInit);
          }
        };
      }
    });
  var ngNonBindableDirective = ngDirective({
      terminal: true,
      priority: 1000
    });
  var ngPluralizeDirective = [
      '$locale',
      '$interpolate',
      function ($locale, $interpolate) {
        var BRACE = /{}/g;
        return {
          restrict: 'EA',
          link: function (scope, element, attr) {
            var numberExp = attr.count, whenExp = element.attr(attr.$attr.when), offset = attr.offset || 0, whens = scope.$eval(whenExp), whensExpFns = {}, startSymbol = $interpolate.startSymbol(), endSymbol = $interpolate.endSymbol();
            forEach(whens, function (expression, key) {
              whensExpFns[key] = $interpolate(expression.replace(BRACE, startSymbol + numberExp + '-' + offset + endSymbol));
            });
            scope.$watch(function ngPluralizeWatch() {
              var value = parseFloat(scope.$eval(numberExp));
              if (!isNaN(value)) {
                if (!(value in whens))
                  value = $locale.pluralCat(value - offset);
                return whensExpFns[value](scope, element, true);
              } else {
                return '';
              }
            }, function ngPluralizeWatchAction(newVal) {
              element.text(newVal);
            });
          }
        };
      }
    ];
  var ngRepeatDirective = ngDirective({
      transclude: 'element',
      priority: 1000,
      terminal: true,
      compile: function (element, attr, linker) {
        return function (scope, iterStartElement, attr) {
          var expression = attr.ngRepeat;
          var match = expression.match(/^\s*(.+)\s+in\s+(.*)\s*$/), lhs, rhs, valueIdent, keyIdent;
          if (!match) {
            throw Error('Expected ngRepeat in form of \'_item_ in _collection_\' but got \'' + expression + '\'.');
          }
          lhs = match[1];
          rhs = match[2];
          match = lhs.match(/^(?:([\$\w]+)|\(([\$\w]+)\s*,\s*([\$\w]+)\))$/);
          if (!match) {
            throw Error('\'item\' in \'item in collection\' should be identifier or (key, value) but got \'' + lhs + '\'.');
          }
          valueIdent = match[3] || match[1];
          keyIdent = match[2];
          var lastOrder = new HashQueueMap();
          scope.$watch(function ngRepeatWatch(scope) {
            var index, length, collection = scope.$eval(rhs), cursor = iterStartElement, nextOrder = new HashQueueMap(), arrayBound, childScope, key, value, array, last;
            if (!isArray(collection)) {
              array = [];
              for (key in collection) {
                if (collection.hasOwnProperty(key) && key.charAt(0) != '$') {
                  array.push(key);
                }
              }
              array.sort();
            } else {
              array = collection || [];
            }
            arrayBound = array.length - 1;
            for (index = 0, length = array.length; index < length; index++) {
              key = collection === array ? index : array[index];
              value = collection[key];
              last = lastOrder.shift(value);
              if (last) {
                childScope = last.scope;
                nextOrder.push(value, last);
                if (index === last.index) {
                  cursor = last.element;
                } else {
                  last.index = index;
                  cursor.after(last.element);
                  cursor = last.element;
                }
              } else {
                childScope = scope.$new();
              }
              childScope[valueIdent] = value;
              if (keyIdent)
                childScope[keyIdent] = key;
              childScope.$index = index;
              childScope.$first = index === 0;
              childScope.$last = index === arrayBound;
              childScope.$middle = !(childScope.$first || childScope.$last);
              if (!last) {
                linker(childScope, function (clone) {
                  cursor.after(clone);
                  last = {
                    scope: childScope,
                    element: cursor = clone,
                    index: index
                  };
                  nextOrder.push(value, last);
                });
              }
            }
            for (key in lastOrder) {
              if (lastOrder.hasOwnProperty(key)) {
                array = lastOrder[key];
                while (array.length) {
                  value = array.pop();
                  value.element.remove();
                  value.scope.$destroy();
                }
              }
            }
            lastOrder = nextOrder;
          });
        };
      }
    });
  var ngShowDirective = ngDirective(function (scope, element, attr) {
      scope.$watch(attr.ngShow, function ngShowWatchAction(value) {
        element.css('display', toBoolean(value) ? '' : 'none');
      });
    });
  var ngHideDirective = ngDirective(function (scope, element, attr) {
      scope.$watch(attr.ngHide, function ngHideWatchAction(value) {
        element.css('display', toBoolean(value) ? 'none' : '');
      });
    });
  var ngStyleDirective = ngDirective(function (scope, element, attr) {
      scope.$watch(attr.ngStyle, function ngStyleWatchAction(newStyles, oldStyles) {
        if (oldStyles && newStyles !== oldStyles) {
          forEach(oldStyles, function (val, style) {
            element.css(style, '');
          });
        }
        if (newStyles)
          element.css(newStyles);
      }, true);
    });
  var NG_SWITCH = 'ng-switch';
  var ngSwitchDirective = valueFn({
      restrict: 'EA',
      require: 'ngSwitch',
      controller: [
        '$scope',
        function ngSwitchController() {
          this.cases = {};
        }
      ],
      link: function (scope, element, attr, ctrl) {
        var watchExpr = attr.ngSwitch || attr.on, selectedTransclude, selectedElement, selectedScope;
        scope.$watch(watchExpr, function ngSwitchWatchAction(value) {
          if (selectedElement) {
            selectedScope.$destroy();
            selectedElement.remove();
            selectedElement = selectedScope = null;
          }
          if (selectedTransclude = ctrl.cases['!' + value] || ctrl.cases['?']) {
            scope.$eval(attr.change);
            selectedScope = scope.$new();
            selectedTransclude(selectedScope, function (caseElement) {
              selectedElement = caseElement;
              element.append(caseElement);
            });
          }
        });
      }
    });
  var ngSwitchWhenDirective = ngDirective({
      transclude: 'element',
      priority: 500,
      require: '^ngSwitch',
      compile: function (element, attrs, transclude) {
        return function (scope, element, attr, ctrl) {
          ctrl.cases['!' + attrs.ngSwitchWhen] = transclude;
        };
      }
    });
  var ngSwitchDefaultDirective = ngDirective({
      transclude: 'element',
      priority: 500,
      require: '^ngSwitch',
      compile: function (element, attrs, transclude) {
        return function (scope, element, attr, ctrl) {
          ctrl.cases['?'] = transclude;
        };
      }
    });
  var ngTranscludeDirective = ngDirective({
      controller: [
        '$transclude',
        '$element',
        function ($transclude, $element) {
          $transclude(function (clone) {
            $element.append(clone);
          });
        }
      ]
    });
  var ngViewDirective = [
      '$http',
      '$templateCache',
      '$route',
      '$anchorScroll',
      '$compile',
      '$controller',
      function ($http, $templateCache, $route, $anchorScroll, $compile, $controller) {
        return {
          restrict: 'ECA',
          terminal: true,
          link: function (scope, element, attr) {
            var lastScope, onloadExp = attr.onload || '';
            scope.$on('$routeChangeSuccess', update);
            update();
            function destroyLastScope() {
              if (lastScope) {
                lastScope.$destroy();
                lastScope = null;
              }
            }
            function clearContent() {
              element.html('');
              destroyLastScope();
            }
            function update() {
              var locals = $route.current && $route.current.locals, template = locals && locals.$template;
              if (template) {
                element.html(template);
                destroyLastScope();
                var link = $compile(element.contents()), current = $route.current, controller;
                lastScope = current.scope = scope.$new();
                if (current.controller) {
                  locals.$scope = lastScope;
                  controller = $controller(current.controller, locals);
                  element.children().data('$ngControllerController', controller);
                }
                link(lastScope);
                lastScope.$emit('$viewContentLoaded');
                lastScope.$eval(onloadExp);
                $anchorScroll();
              } else {
                clearContent();
              }
            }
          }
        };
      }
    ];
  var scriptDirective = [
      '$templateCache',
      function ($templateCache) {
        return {
          restrict: 'E',
          terminal: true,
          compile: function (element, attr) {
            if (attr.type == 'text/ng-template') {
              var templateUrl = attr.id, text = element[0].text;
              $templateCache.put(templateUrl, text);
            }
          }
        };
      }
    ];
  var ngOptionsDirective = valueFn({ terminal: true });
  var selectDirective = [
      '$compile',
      '$parse',
      function ($compile, $parse) {
        var NG_OPTIONS_REGEXP = /^\s*(.*?)(?:\s+as\s+(.*?))?(?:\s+group\s+by\s+(.*))?\s+for\s+(?:([\$\w][\$\w\d]*)|(?:\(\s*([\$\w][\$\w\d]*)\s*,\s*([\$\w][\$\w\d]*)\s*\)))\s+in\s+(.*)$/, nullModelCtrl = { $setViewValue: noop };
        return {
          restrict: 'E',
          require: [
            'select',
            '?ngModel'
          ],
          controller: [
            '$element',
            '$scope',
            '$attrs',
            function ($element, $scope, $attrs) {
              var self = this, optionsMap = {}, ngModelCtrl = nullModelCtrl, nullOption, unknownOption;
              self.databound = $attrs.ngModel;
              self.init = function (ngModelCtrl_, nullOption_, unknownOption_) {
                ngModelCtrl = ngModelCtrl_;
                nullOption = nullOption_;
                unknownOption = unknownOption_;
              };
              self.addOption = function (value) {
                optionsMap[value] = true;
                if (ngModelCtrl.$viewValue == value) {
                  $element.val(value);
                  if (unknownOption.parent())
                    unknownOption.remove();
                }
              };
              self.removeOption = function (value) {
                if (this.hasOption(value)) {
                  delete optionsMap[value];
                  if (ngModelCtrl.$viewValue == value) {
                    this.renderUnknownOption(value);
                  }
                }
              };
              self.renderUnknownOption = function (val) {
                var unknownVal = '? ' + hashKey(val) + ' ?';
                unknownOption.val(unknownVal);
                $element.prepend(unknownOption);
                $element.val(unknownVal);
                unknownOption.prop('selected', true);
              };
              self.hasOption = function (value) {
                return optionsMap.hasOwnProperty(value);
              };
              $scope.$on('$destroy', function () {
                self.renderUnknownOption = noop;
              });
            }
          ],
          link: function (scope, element, attr, ctrls) {
            if (!ctrls[1])
              return;
            var selectCtrl = ctrls[0], ngModelCtrl = ctrls[1], multiple = attr.multiple, optionsExp = attr.ngOptions, nullOption = false, emptyOption, optionTemplate = jqLite(document.createElement('option')), optGroupTemplate = jqLite(document.createElement('optgroup')), unknownOption = optionTemplate.clone();
            for (var i = 0, children = element.children(), ii = children.length; i < ii; i++) {
              if (children[i].value == '') {
                emptyOption = nullOption = children.eq(i);
                break;
              }
            }
            selectCtrl.init(ngModelCtrl, nullOption, unknownOption);
            if (multiple && (attr.required || attr.ngRequired)) {
              var requiredValidator = function (value) {
                ngModelCtrl.$setValidity('required', !attr.required || value && value.length);
                return value;
              };
              ngModelCtrl.$parsers.push(requiredValidator);
              ngModelCtrl.$formatters.unshift(requiredValidator);
              attr.$observe('required', function () {
                requiredValidator(ngModelCtrl.$viewValue);
              });
            }
            if (optionsExp)
              Options(scope, element, ngModelCtrl);
            else if (multiple)
              Multiple(scope, element, ngModelCtrl);
            else
              Single(scope, element, ngModelCtrl, selectCtrl);
            function Single(scope, selectElement, ngModelCtrl, selectCtrl) {
              ngModelCtrl.$render = function () {
                var viewValue = ngModelCtrl.$viewValue;
                if (selectCtrl.hasOption(viewValue)) {
                  if (unknownOption.parent())
                    unknownOption.remove();
                  selectElement.val(viewValue);
                  if (viewValue === '')
                    emptyOption.prop('selected', true);
                } else {
                  if (isUndefined(viewValue) && emptyOption) {
                    selectElement.val('');
                  } else {
                    selectCtrl.renderUnknownOption(viewValue);
                  }
                }
              };
              selectElement.bind('change', function () {
                scope.$apply(function () {
                  if (unknownOption.parent())
                    unknownOption.remove();
                  ngModelCtrl.$setViewValue(selectElement.val());
                });
              });
            }
            function Multiple(scope, selectElement, ctrl) {
              var lastView;
              ctrl.$render = function () {
                var items = new HashMap(ctrl.$viewValue);
                forEach(selectElement.find('option'), function (option) {
                  option.selected = isDefined(items.get(option.value));
                });
              };
              scope.$watch(function selectMultipleWatch() {
                if (!equals(lastView, ctrl.$viewValue)) {
                  lastView = copy(ctrl.$viewValue);
                  ctrl.$render();
                }
              });
              selectElement.bind('change', function () {
                scope.$apply(function () {
                  var array = [];
                  forEach(selectElement.find('option'), function (option) {
                    if (option.selected) {
                      array.push(option.value);
                    }
                  });
                  ctrl.$setViewValue(array);
                });
              });
            }
            function Options(scope, selectElement, ctrl) {
              var match;
              if (!(match = optionsExp.match(NG_OPTIONS_REGEXP))) {
                throw Error('Expected ngOptions in form of \'_select_ (as _label_)? for (_key_,)?_value_ in _collection_\'' + ' but got \'' + optionsExp + '\'.');
              }
              var displayFn = $parse(match[2] || match[1]), valueName = match[4] || match[6], keyName = match[5], groupByFn = $parse(match[3] || ''), valueFn = $parse(match[2] ? match[1] : valueName), valuesFn = $parse(match[7]), optionGroupsCache = [[{
                      element: selectElement,
                      label: ''
                    }]];
              if (nullOption) {
                $compile(nullOption)(scope);
                nullOption.removeClass('ng-scope');
                nullOption.remove();
              }
              selectElement.html('');
              selectElement.bind('change', function () {
                scope.$apply(function () {
                  var optionGroup, collection = valuesFn(scope) || [], locals = {}, key, value, optionElement, index, groupIndex, length, groupLength;
                  if (multiple) {
                    value = [];
                    for (groupIndex = 0, groupLength = optionGroupsCache.length; groupIndex < groupLength; groupIndex++) {
                      optionGroup = optionGroupsCache[groupIndex];
                      for (index = 1, length = optionGroup.length; index < length; index++) {
                        if ((optionElement = optionGroup[index].element)[0].selected) {
                          key = optionElement.val();
                          if (keyName)
                            locals[keyName] = key;
                          locals[valueName] = collection[key];
                          value.push(valueFn(scope, locals));
                        }
                      }
                    }
                  } else {
                    key = selectElement.val();
                    if (key == '?') {
                      value = undefined;
                    } else if (key == '') {
                      value = null;
                    } else {
                      locals[valueName] = collection[key];
                      if (keyName)
                        locals[keyName] = key;
                      value = valueFn(scope, locals);
                    }
                  }
                  ctrl.$setViewValue(value);
                });
              });
              ctrl.$render = render;
              scope.$watch(render);
              function render() {
                var optionGroups = { '': [] }, optionGroupNames = [''], optionGroupName, optionGroup, option, existingParent, existingOptions, existingOption, modelValue = ctrl.$modelValue, values = valuesFn(scope) || [], keys = keyName ? sortedKeys(values) : values, groupLength, length, groupIndex, index, locals = {}, selected, selectedSet = false, lastElement, element, label;
                if (multiple) {
                  selectedSet = new HashMap(modelValue);
                }
                for (index = 0; length = keys.length, index < length; index++) {
                  locals[valueName] = values[keyName ? locals[keyName] = keys[index] : index];
                  optionGroupName = groupByFn(scope, locals) || '';
                  if (!(optionGroup = optionGroups[optionGroupName])) {
                    optionGroup = optionGroups[optionGroupName] = [];
                    optionGroupNames.push(optionGroupName);
                  }
                  if (multiple) {
                    selected = selectedSet.remove(valueFn(scope, locals)) != undefined;
                  } else {
                    selected = modelValue === valueFn(scope, locals);
                    selectedSet = selectedSet || selected;
                  }
                  label = displayFn(scope, locals);
                  label = label === undefined ? '' : label;
                  optionGroup.push({
                    id: keyName ? keys[index] : index,
                    label: label,
                    selected: selected
                  });
                }
                if (!multiple) {
                  if (nullOption || modelValue === null) {
                    optionGroups[''].unshift({
                      id: '',
                      label: '',
                      selected: !selectedSet
                    });
                  } else if (!selectedSet) {
                    optionGroups[''].unshift({
                      id: '?',
                      label: '',
                      selected: true
                    });
                  }
                }
                for (groupIndex = 0, groupLength = optionGroupNames.length; groupIndex < groupLength; groupIndex++) {
                  optionGroupName = optionGroupNames[groupIndex];
                  optionGroup = optionGroups[optionGroupName];
                  if (optionGroupsCache.length <= groupIndex) {
                    existingParent = {
                      element: optGroupTemplate.clone().attr('label', optionGroupName),
                      label: optionGroup.label
                    };
                    existingOptions = [existingParent];
                    optionGroupsCache.push(existingOptions);
                    selectElement.append(existingParent.element);
                  } else {
                    existingOptions = optionGroupsCache[groupIndex];
                    existingParent = existingOptions[0];
                    if (existingParent.label != optionGroupName) {
                      existingParent.element.attr('label', existingParent.label = optionGroupName);
                    }
                  }
                  lastElement = null;
                  for (index = 0, length = optionGroup.length; index < length; index++) {
                    option = optionGroup[index];
                    if (existingOption = existingOptions[index + 1]) {
                      lastElement = existingOption.element;
                      if (existingOption.label !== option.label) {
                        lastElement.text(existingOption.label = option.label);
                      }
                      if (existingOption.id !== option.id) {
                        lastElement.val(existingOption.id = option.id);
                      }
                      if (lastElement[0].selected !== option.selected) {
                        lastElement.prop('selected', existingOption.selected = option.selected);
                      }
                    } else {
                      if (option.id === '' && nullOption) {
                        element = nullOption;
                      } else {
                        (element = optionTemplate.clone()).val(option.id).attr('selected', option.selected).text(option.label);
                      }
                      existingOptions.push(existingOption = {
                        element: element,
                        label: option.label,
                        id: option.id,
                        selected: option.selected
                      });
                      if (lastElement) {
                        lastElement.after(element);
                      } else {
                        existingParent.element.append(element);
                      }
                      lastElement = element;
                    }
                  }
                  index++;
                  while (existingOptions.length > index) {
                    existingOptions.pop().element.remove();
                  }
                }
                while (optionGroupsCache.length > groupIndex) {
                  optionGroupsCache.pop()[0].element.remove();
                }
              }
            }
          }
        };
      }
    ];
  var optionDirective = [
      '$interpolate',
      function ($interpolate) {
        var nullSelectCtrl = {
            addOption: noop,
            removeOption: noop
          };
        return {
          restrict: 'E',
          priority: 100,
          compile: function (element, attr) {
            if (isUndefined(attr.value)) {
              var interpolateFn = $interpolate(element.text(), true);
              if (!interpolateFn) {
                attr.$set('value', element.text());
              }
            }
            return function (scope, element, attr) {
              var selectCtrlName = '$selectController', parent = element.parent(), selectCtrl = parent.data(selectCtrlName) || parent.parent().data(selectCtrlName);
              if (selectCtrl && selectCtrl.databound) {
                element.prop('selected', false);
              } else {
                selectCtrl = nullSelectCtrl;
              }
              if (interpolateFn) {
                scope.$watch(interpolateFn, function interpolateWatchAction(newVal, oldVal) {
                  attr.$set('value', newVal);
                  if (newVal !== oldVal)
                    selectCtrl.removeOption(oldVal);
                  selectCtrl.addOption(newVal);
                });
              } else {
                selectCtrl.addOption(attr.value);
              }
              element.bind('$destroy', function () {
                selectCtrl.removeOption(attr.value);
              });
            };
          }
        };
      }
    ];
  var styleDirective = valueFn({
      restrict: 'E',
      terminal: true
    });
  bindJQuery();
  publishExternalAPI(angular);
  jqLite(document).ready(function () {
    angularInit(document, bootstrap);
  });
}(window, document));
angular.element(document).find('head').append('<style type="text/css">@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak{display:none;}ng\\:form{display:block;}</style>');
(function () {
  var root = this;
  var previousUnderscore = root._;
  var breaker = {};
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;
  var push = ArrayProto.push, slice = ArrayProto.slice, concat = ArrayProto.concat, toString = ObjProto.toString, hasOwnProperty = ObjProto.hasOwnProperty;
  var nativeForEach = ArrayProto.forEach, nativeMap = ArrayProto.map, nativeReduce = ArrayProto.reduce, nativeReduceRight = ArrayProto.reduceRight, nativeFilter = ArrayProto.filter, nativeEvery = ArrayProto.every, nativeSome = ArrayProto.some, nativeIndexOf = ArrayProto.indexOf, nativeLastIndexOf = ArrayProto.lastIndexOf, nativeIsArray = Array.isArray, nativeKeys = Object.keys, nativeBind = FuncProto.bind;
  var _ = function (obj) {
    if (obj instanceof _)
      return obj;
    if (!(this instanceof _))
      return new _(obj);
    this._wrapped = obj;
  };
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }
  _.VERSION = '1.5.1';
  var each = _.each = _.forEach = function (obj, iterator, context) {
      if (obj == null)
        return;
      if (nativeForEach && obj.forEach === nativeForEach) {
        obj.forEach(iterator, context);
      } else if (obj.length === +obj.length) {
        for (var i = 0, l = obj.length; i < l; i++) {
          if (iterator.call(context, obj[i], i, obj) === breaker)
            return;
        }
      } else {
        for (var key in obj) {
          if (_.has(obj, key)) {
            if (iterator.call(context, obj[key], key, obj) === breaker)
              return;
          }
        }
      }
    };
  _.map = _.collect = function (obj, iterator, context) {
    var results = [];
    if (obj == null)
      return results;
    if (nativeMap && obj.map === nativeMap)
      return obj.map(iterator, context);
    each(obj, function (value, index, list) {
      results.push(iterator.call(context, value, index, list));
    });
    return results;
  };
  var reduceError = 'Reduce of empty array with no initial value';
  _.reduce = _.foldl = _.inject = function (obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null)
      obj = [];
    if (nativeReduce && obj.reduce === nativeReduce) {
      if (context)
        iterator = _.bind(iterator, context);
      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
    }
    each(obj, function (value, index, list) {
      if (!initial) {
        memo = value;
        initial = true;
      } else {
        memo = iterator.call(context, memo, value, index, list);
      }
    });
    if (!initial)
      throw new TypeError(reduceError);
    return memo;
  };
  _.reduceRight = _.foldr = function (obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null)
      obj = [];
    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
      if (context)
        iterator = _.bind(iterator, context);
      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
    }
    var length = obj.length;
    if (length !== +length) {
      var keys = _.keys(obj);
      length = keys.length;
    }
    each(obj, function (value, index, list) {
      index = keys ? keys[--length] : --length;
      if (!initial) {
        memo = obj[index];
        initial = true;
      } else {
        memo = iterator.call(context, memo, obj[index], index, list);
      }
    });
    if (!initial)
      throw new TypeError(reduceError);
    return memo;
  };
  _.find = _.detect = function (obj, iterator, context) {
    var result;
    any(obj, function (value, index, list) {
      if (iterator.call(context, value, index, list)) {
        result = value;
        return true;
      }
    });
    return result;
  };
  _.filter = _.select = function (obj, iterator, context) {
    var results = [];
    if (obj == null)
      return results;
    if (nativeFilter && obj.filter === nativeFilter)
      return obj.filter(iterator, context);
    each(obj, function (value, index, list) {
      if (iterator.call(context, value, index, list))
        results.push(value);
    });
    return results;
  };
  _.reject = function (obj, iterator, context) {
    return _.filter(obj, function (value, index, list) {
      return !iterator.call(context, value, index, list);
    }, context);
  };
  _.every = _.all = function (obj, iterator, context) {
    iterator || (iterator = _.identity);
    var result = true;
    if (obj == null)
      return result;
    if (nativeEvery && obj.every === nativeEvery)
      return obj.every(iterator, context);
    each(obj, function (value, index, list) {
      if (!(result = result && iterator.call(context, value, index, list)))
        return breaker;
    });
    return !!result;
  };
  var any = _.some = _.any = function (obj, iterator, context) {
      iterator || (iterator = _.identity);
      var result = false;
      if (obj == null)
        return result;
      if (nativeSome && obj.some === nativeSome)
        return obj.some(iterator, context);
      each(obj, function (value, index, list) {
        if (result || (result = iterator.call(context, value, index, list)))
          return breaker;
      });
      return !!result;
    };
  _.contains = _.include = function (obj, target) {
    if (obj == null)
      return false;
    if (nativeIndexOf && obj.indexOf === nativeIndexOf)
      return obj.indexOf(target) != -1;
    return any(obj, function (value) {
      return value === target;
    });
  };
  _.invoke = function (obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function (value) {
      return (isFunc ? method : value[method]).apply(value, args);
    });
  };
  _.pluck = function (obj, key) {
    return _.map(obj, function (value) {
      return value[key];
    });
  };
  _.where = function (obj, attrs, first) {
    if (_.isEmpty(attrs))
      return first ? void 0 : [];
    return _[first ? 'find' : 'filter'](obj, function (value) {
      for (var key in attrs) {
        if (attrs[key] !== value[key])
          return false;
      }
      return true;
    });
  };
  _.findWhere = function (obj, attrs) {
    return _.where(obj, attrs, true);
  };
  _.max = function (obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.max.apply(Math, obj);
    }
    if (!iterator && _.isEmpty(obj))
      return -Infinity;
    var result = {
        computed: -Infinity,
        value: -Infinity
      };
    each(obj, function (value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed > result.computed && (result = {
        value: value,
        computed: computed
      });
    });
    return result.value;
  };
  _.min = function (obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.min.apply(Math, obj);
    }
    if (!iterator && _.isEmpty(obj))
      return Infinity;
    var result = {
        computed: Infinity,
        value: Infinity
      };
    each(obj, function (value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed < result.computed && (result = {
        value: value,
        computed: computed
      });
    });
    return result.value;
  };
  _.shuffle = function (obj) {
    var rand;
    var index = 0;
    var shuffled = [];
    each(obj, function (value) {
      rand = _.random(index++);
      shuffled[index - 1] = shuffled[rand];
      shuffled[rand] = value;
    });
    return shuffled;
  };
  var lookupIterator = function (value) {
    return _.isFunction(value) ? value : function (obj) {
      return obj[value];
    };
  };
  _.sortBy = function (obj, value, context) {
    var iterator = lookupIterator(value);
    return _.pluck(_.map(obj, function (value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iterator.call(context, value, index, list)
      };
    }).sort(function (left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0)
          return 1;
        if (a < b || b === void 0)
          return -1;
      }
      return left.index < right.index ? -1 : 1;
    }), 'value');
  };
  var group = function (obj, value, context, behavior) {
    var result = {};
    var iterator = lookupIterator(value == null ? _.identity : value);
    each(obj, function (value, index) {
      var key = iterator.call(context, value, index, obj);
      behavior(result, key, value);
    });
    return result;
  };
  _.groupBy = function (obj, value, context) {
    return group(obj, value, context, function (result, key, value) {
      (_.has(result, key) ? result[key] : result[key] = []).push(value);
    });
  };
  _.countBy = function (obj, value, context) {
    return group(obj, value, context, function (result, key) {
      if (!_.has(result, key))
        result[key] = 0;
      result[key]++;
    });
  };
  _.sortedIndex = function (array, obj, iterator, context) {
    iterator = iterator == null ? _.identity : lookupIterator(iterator);
    var value = iterator.call(context, obj);
    var low = 0, high = array.length;
    while (low < high) {
      var mid = low + high >>> 1;
      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;
    }
    return low;
  };
  _.toArray = function (obj) {
    if (!obj)
      return [];
    if (_.isArray(obj))
      return slice.call(obj);
    if (obj.length === +obj.length)
      return _.map(obj, _.identity);
    return _.values(obj);
  };
  _.size = function (obj) {
    if (obj == null)
      return 0;
    return obj.length === +obj.length ? obj.length : _.keys(obj).length;
  };
  _.first = _.head = _.take = function (array, n, guard) {
    if (array == null)
      return void 0;
    return n != null && !guard ? slice.call(array, 0, n) : array[0];
  };
  _.initial = function (array, n, guard) {
    return slice.call(array, 0, array.length - (n == null || guard ? 1 : n));
  };
  _.last = function (array, n, guard) {
    if (array == null)
      return void 0;
    if (n != null && !guard) {
      return slice.call(array, Math.max(array.length - n, 0));
    } else {
      return array[array.length - 1];
    }
  };
  _.rest = _.tail = _.drop = function (array, n, guard) {
    return slice.call(array, n == null || guard ? 1 : n);
  };
  _.compact = function (array) {
    return _.filter(array, _.identity);
  };
  var flatten = function (input, shallow, output) {
    if (shallow && _.every(input, _.isArray)) {
      return concat.apply(output, input);
    }
    each(input, function (value) {
      if (_.isArray(value) || _.isArguments(value)) {
        shallow ? push.apply(output, value) : flatten(value, shallow, output);
      } else {
        output.push(value);
      }
    });
    return output;
  };
  _.flatten = function (array, shallow) {
    return flatten(array, shallow, []);
  };
  _.without = function (array) {
    return _.difference(array, slice.call(arguments, 1));
  };
  _.uniq = _.unique = function (array, isSorted, iterator, context) {
    if (_.isFunction(isSorted)) {
      context = iterator;
      iterator = isSorted;
      isSorted = false;
    }
    var initial = iterator ? _.map(array, iterator, context) : array;
    var results = [];
    var seen = [];
    each(initial, function (value, index) {
      if (isSorted ? !index || seen[seen.length - 1] !== value : !_.contains(seen, value)) {
        seen.push(value);
        results.push(array[index]);
      }
    });
    return results;
  };
  _.union = function () {
    return _.uniq(_.flatten(arguments, true));
  };
  _.intersection = function (array) {
    var rest = slice.call(arguments, 1);
    return _.filter(_.uniq(array), function (item) {
      return _.every(rest, function (other) {
        return _.indexOf(other, item) >= 0;
      });
    });
  };
  _.difference = function (array) {
    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));
    return _.filter(array, function (value) {
      return !_.contains(rest, value);
    });
  };
  _.zip = function () {
    var length = _.max(_.pluck(arguments, 'length').concat(0));
    var results = new Array(length);
    for (var i = 0; i < length; i++) {
      results[i] = _.pluck(arguments, '' + i);
    }
    return results;
  };
  _.object = function (list, values) {
    if (list == null)
      return {};
    var result = {};
    for (var i = 0, l = list.length; i < l; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };
  _.indexOf = function (array, item, isSorted) {
    if (array == null)
      return -1;
    var i = 0, l = array.length;
    if (isSorted) {
      if (typeof isSorted == 'number') {
        i = isSorted < 0 ? Math.max(0, l + isSorted) : isSorted;
      } else {
        i = _.sortedIndex(array, item);
        return array[i] === item ? i : -1;
      }
    }
    if (nativeIndexOf && array.indexOf === nativeIndexOf)
      return array.indexOf(item, isSorted);
    for (; i < l; i++)
      if (array[i] === item)
        return i;
    return -1;
  };
  _.lastIndexOf = function (array, item, from) {
    if (array == null)
      return -1;
    var hasIndex = from != null;
    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {
      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);
    }
    var i = hasIndex ? from : array.length;
    while (i--)
      if (array[i] === item)
        return i;
    return -1;
  };
  _.range = function (start, stop, step) {
    if (arguments.length <= 1) {
      stop = start || 0;
      start = 0;
    }
    step = arguments[2] || 1;
    var len = Math.max(Math.ceil((stop - start) / step), 0);
    var idx = 0;
    var range = new Array(len);
    while (idx < len) {
      range[idx++] = start;
      start += step;
    }
    return range;
  };
  var ctor = function () {
  };
  _.bind = function (func, context) {
    var args, bound;
    if (nativeBind && func.bind === nativeBind)
      return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func))
      throw new TypeError();
    args = slice.call(arguments, 2);
    return bound = function () {
      if (!(this instanceof bound))
        return func.apply(context, args.concat(slice.call(arguments)));
      ctor.prototype = func.prototype;
      var self = new ctor();
      ctor.prototype = null;
      var result = func.apply(self, args.concat(slice.call(arguments)));
      if (Object(result) === result)
        return result;
      return self;
    };
  };
  _.partial = function (func) {
    var args = slice.call(arguments, 1);
    return function () {
      return func.apply(this, args.concat(slice.call(arguments)));
    };
  };
  _.bindAll = function (obj) {
    var funcs = slice.call(arguments, 1);
    if (funcs.length === 0)
      throw new Error('bindAll must be passed function names');
    each(funcs, function (f) {
      obj[f] = _.bind(obj[f], obj);
    });
    return obj;
  };
  _.memoize = function (func, hasher) {
    var memo = {};
    hasher || (hasher = _.identity);
    return function () {
      var key = hasher.apply(this, arguments);
      return _.has(memo, key) ? memo[key] : memo[key] = func.apply(this, arguments);
    };
  };
  _.delay = function (func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function () {
      return func.apply(null, args);
    }, wait);
  };
  _.defer = function (func) {
    return _.delay.apply(_, [
      func,
      1
    ].concat(slice.call(arguments, 1)));
  };
  _.throttle = function (func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    options || (options = {});
    var later = function () {
      previous = options.leading === false ? 0 : new Date();
      timeout = null;
      result = func.apply(context, args);
    };
    return function () {
      var now = new Date();
      if (!previous && options.leading === false)
        previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0) {
        clearTimeout(timeout);
        timeout = null;
        previous = now;
        result = func.apply(context, args);
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };
  _.debounce = function (func, wait, immediate) {
    var result;
    var timeout = null;
    return function () {
      var context = this, args = arguments;
      var later = function () {
        timeout = null;
        if (!immediate)
          result = func.apply(context, args);
      };
      var callNow = immediate && !timeout;
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
      if (callNow)
        result = func.apply(context, args);
      return result;
    };
  };
  _.once = function (func) {
    var ran = false, memo;
    return function () {
      if (ran)
        return memo;
      ran = true;
      memo = func.apply(this, arguments);
      func = null;
      return memo;
    };
  };
  _.wrap = function (func, wrapper) {
    return function () {
      var args = [func];
      push.apply(args, arguments);
      return wrapper.apply(this, args);
    };
  };
  _.compose = function () {
    var funcs = arguments;
    return function () {
      var args = arguments;
      for (var i = funcs.length - 1; i >= 0; i--) {
        args = [funcs[i].apply(this, args)];
      }
      return args[0];
    };
  };
  _.after = function (times, func) {
    return function () {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };
  _.keys = nativeKeys || function (obj) {
    if (obj !== Object(obj))
      throw new TypeError('Invalid object');
    var keys = [];
    for (var key in obj)
      if (_.has(obj, key))
        keys.push(key);
    return keys;
  };
  _.values = function (obj) {
    var values = [];
    for (var key in obj)
      if (_.has(obj, key))
        values.push(obj[key]);
    return values;
  };
  _.pairs = function (obj) {
    var pairs = [];
    for (var key in obj)
      if (_.has(obj, key))
        pairs.push([
          key,
          obj[key]
        ]);
    return pairs;
  };
  _.invert = function (obj) {
    var result = {};
    for (var key in obj)
      if (_.has(obj, key))
        result[obj[key]] = key;
    return result;
  };
  _.functions = _.methods = function (obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key]))
        names.push(key);
    }
    return names.sort();
  };
  _.extend = function (obj) {
    each(slice.call(arguments, 1), function (source) {
      if (source) {
        for (var prop in source) {
          obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };
  _.pick = function (obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    each(keys, function (key) {
      if (key in obj)
        copy[key] = obj[key];
    });
    return copy;
  };
  _.omit = function (obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    for (var key in obj) {
      if (!_.contains(keys, key))
        copy[key] = obj[key];
    }
    return copy;
  };
  _.defaults = function (obj) {
    each(slice.call(arguments, 1), function (source) {
      if (source) {
        for (var prop in source) {
          if (obj[prop] === void 0)
            obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };
  _.clone = function (obj) {
    if (!_.isObject(obj))
      return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };
  _.tap = function (obj, interceptor) {
    interceptor(obj);
    return obj;
  };
  var eq = function (a, b, aStack, bStack) {
    if (a === b)
      return a !== 0 || 1 / a == 1 / b;
    if (a == null || b == null)
      return a === b;
    if (a instanceof _)
      a = a._wrapped;
    if (b instanceof _)
      b = b._wrapped;
    var className = toString.call(a);
    if (className != toString.call(b))
      return false;
    switch (className) {
    case '[object String]':
      return a == String(b);
    case '[object Number]':
      return a != +a ? b != +b : a == 0 ? 1 / a == 1 / b : a == +b;
    case '[object Date]':
    case '[object Boolean]':
      return +a == +b;
    case '[object RegExp]':
      return a.source == b.source && a.global == b.global && a.multiline == b.multiline && a.ignoreCase == b.ignoreCase;
    }
    if (typeof a != 'object' || typeof b != 'object')
      return false;
    var length = aStack.length;
    while (length--) {
      if (aStack[length] == a)
        return bStack[length] == b;
    }
    var aCtor = a.constructor, bCtor = b.constructor;
    if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor && _.isFunction(bCtor) && bCtor instanceof bCtor)) {
      return false;
    }
    aStack.push(a);
    bStack.push(b);
    var size = 0, result = true;
    if (className == '[object Array]') {
      size = a.length;
      result = size == b.length;
      if (result) {
        while (size--) {
          if (!(result = eq(a[size], b[size], aStack, bStack)))
            break;
        }
      }
    } else {
      for (var key in a) {
        if (_.has(a, key)) {
          size++;
          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack)))
            break;
        }
      }
      if (result) {
        for (key in b) {
          if (_.has(b, key) && !size--)
            break;
        }
        result = !size;
      }
    }
    aStack.pop();
    bStack.pop();
    return result;
  };
  _.isEqual = function (a, b) {
    return eq(a, b, [], []);
  };
  _.isEmpty = function (obj) {
    if (obj == null)
      return true;
    if (_.isArray(obj) || _.isString(obj))
      return obj.length === 0;
    for (var key in obj)
      if (_.has(obj, key))
        return false;
    return true;
  };
  _.isElement = function (obj) {
    return !!(obj && obj.nodeType === 1);
  };
  _.isArray = nativeIsArray || function (obj) {
    return toString.call(obj) == '[object Array]';
  };
  _.isObject = function (obj) {
    return obj === Object(obj);
  };
  each([
    'Arguments',
    'Function',
    'String',
    'Number',
    'Date',
    'RegExp'
  ], function (name) {
    _['is' + name] = function (obj) {
      return toString.call(obj) == '[object ' + name + ']';
    };
  });
  if (!_.isArguments(arguments)) {
    _.isArguments = function (obj) {
      return !!(obj && _.has(obj, 'callee'));
    };
  }
  if (typeof /./ !== 'function') {
    _.isFunction = function (obj) {
      return typeof obj === 'function';
    };
  }
  _.isFinite = function (obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };
  _.isNaN = function (obj) {
    return _.isNumber(obj) && obj != +obj;
  };
  _.isBoolean = function (obj) {
    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
  };
  _.isNull = function (obj) {
    return obj === null;
  };
  _.isUndefined = function (obj) {
    return obj === void 0;
  };
  _.has = function (obj, key) {
    return hasOwnProperty.call(obj, key);
  };
  _.noConflict = function () {
    root._ = previousUnderscore;
    return this;
  };
  _.identity = function (value) {
    return value;
  };
  _.times = function (n, iterator, context) {
    var accum = Array(Math.max(0, n));
    for (var i = 0; i < n; i++)
      accum[i] = iterator.call(context, i);
    return accum;
  };
  _.random = function (min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };
  var entityMap = {
      escape: {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        '\'': '&#x27;',
        '/': '&#x2F;'
      }
    };
  entityMap.unescape = _.invert(entityMap.escape);
  var entityRegexes = {
      escape: new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),
      unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')
    };
  _.each([
    'escape',
    'unescape'
  ], function (method) {
    _[method] = function (string) {
      if (string == null)
        return '';
      return ('' + string).replace(entityRegexes[method], function (match) {
        return entityMap[method][match];
      });
    };
  });
  _.result = function (object, property) {
    if (object == null)
      return void 0;
    var value = object[property];
    return _.isFunction(value) ? value.call(object) : value;
  };
  _.mixin = function (obj) {
    each(_.functions(obj), function (name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function () {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result.call(this, func.apply(_, args));
      };
    });
  };
  var idCounter = 0;
  _.uniqueId = function (prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };
  _.templateSettings = {
    evaluate: /<%([\s\S]+?)%>/g,
    interpolate: /<%=([\s\S]+?)%>/g,
    escape: /<%-([\s\S]+?)%>/g
  };
  var noMatch = /(.)^/;
  var escapes = {
      '\'': '\'',
      '\\': '\\',
      '\r': 'r',
      '\n': 'n',
      '\t': 't',
      '\u2028': 'u2028',
      '\u2029': 'u2029'
    };
  var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;
  _.template = function (text, data, settings) {
    var render;
    settings = _.defaults({}, settings, _.templateSettings);
    var matcher = new RegExp([
        (settings.escape || noMatch).source,
        (settings.interpolate || noMatch).source,
        (settings.evaluate || noMatch).source
      ].join('|') + '|$', 'g');
    var index = 0;
    var source = '__p+=\'';
    text.replace(matcher, function (match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escaper, function (match) {
        return '\\' + escapes[match];
      });
      if (escape) {
        source += '\'+\n((__t=(' + escape + '))==null?\'\':_.escape(__t))+\n\'';
      }
      if (interpolate) {
        source += '\'+\n((__t=(' + interpolate + '))==null?\'\':__t)+\n\'';
      }
      if (evaluate) {
        source += '\';\n' + evaluate + '\n__p+=\'';
      }
      index = offset + match.length;
      return match;
    });
    source += '\';\n';
    if (!settings.variable)
      source = 'with(obj||{}){\n' + source + '}\n';
    source = 'var __t,__p=\'\',__j=Array.prototype.join,' + 'print=function(){__p+=__j.call(arguments,\'\');};\n' + source + 'return __p;\n';
    try {
      render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }
    if (data)
      return render(data, _);
    var template = function (data) {
      return render.call(this, data, _);
    };
    template.source = 'function(' + (settings.variable || 'obj') + '){\n' + source + '}';
    return template;
  };
  _.chain = function (obj) {
    return _(obj).chain();
  };
  var result = function (obj) {
    return this._chain ? _(obj).chain() : obj;
  };
  _.mixin(_);
  each([
    'pop',
    'push',
    'reverse',
    'shift',
    'sort',
    'splice',
    'unshift'
  ], function (name) {
    var method = ArrayProto[name];
    _.prototype[name] = function () {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name == 'shift' || name == 'splice') && obj.length === 0)
        delete obj[0];
      return result.call(this, obj);
    };
  });
  each([
    'concat',
    'join',
    'slice'
  ], function (name) {
    var method = ArrayProto[name];
    _.prototype[name] = function () {
      return result.call(this, method.apply(this._wrapped, arguments));
    };
  });
  _.extend(_.prototype, {
    chain: function () {
      this._chain = true;
      return this;
    },
    value: function () {
      return this._wrapped;
    }
  });
}.call(this));
(function (root, undef) {
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, slice = ArrayProto.slice, hasOwnProp = ObjProto.hasOwnProperty, nativeForEach = ArrayProto.forEach, breaker = {};
  var _ = {
      forEach: function (obj, iterator, context) {
        var i, l, key;
        if (obj === null) {
          return;
        }
        if (nativeForEach && obj.forEach === nativeForEach) {
          obj.forEach(iterator, context);
        } else if (obj.length === +obj.length) {
          for (i = 0, l = obj.length; i < l; i++) {
            if (i in obj && iterator.call(context, obj[i], i, obj) === breaker) {
              return;
            }
          }
        } else {
          for (key in obj) {
            if (hasOwnProp.call(obj, key)) {
              if (iterator.call(context, obj[key], key, obj) === breaker) {
                return;
              }
            }
          }
        }
      },
      extend: function (obj) {
        this.forEach(slice.call(arguments, 1), function (source) {
          for (var prop in source) {
            obj[prop] = source[prop];
          }
        });
        return obj;
      }
    };
  var Jed = function (options) {
    this.defaults = {
      'locale_data': {
        'messages': {
          '': {
            'domain': 'messages',
            'lang': 'en',
            'plural_forms': 'nplurals=2; plural=(n != 1);'
          }
        }
      },
      'domain': 'messages'
    };
    this.options = _.extend({}, this.defaults, options);
    this.textdomain(this.options.domain);
    if (options.domain && !this.options.locale_data[this.options.domain]) {
      throw new Error('Text domain set to non-existent domain: `' + options.domain + '`');
    }
  };
  Jed.context_delimiter = String.fromCharCode(4);
  function getPluralFormFunc(plural_form_string) {
    return Jed.PF.compile(plural_form_string || 'nplurals=2; plural=(n != 1);');
  }
  function Chain(key, i18n) {
    this._key = key;
    this._i18n = i18n;
  }
  _.extend(Chain.prototype, {
    onDomain: function (domain) {
      this._domain = domain;
      return this;
    },
    withContext: function (context) {
      this._context = context;
      return this;
    },
    ifPlural: function (num, pkey) {
      this._val = num;
      this._pkey = pkey;
      return this;
    },
    fetch: function (sArr) {
      if ({}.toString.call(sArr) != '[object Array]') {
        sArr = [].slice.call(arguments);
      }
      return (sArr && sArr.length ? Jed.sprintf : function (x) {
        return x;
      })(this._i18n.dcnpgettext(this._domain, this._context, this._key, this._pkey, this._val), sArr);
    }
  });
  _.extend(Jed.prototype, {
    translate: function (key) {
      return new Chain(key, this);
    },
    textdomain: function (domain) {
      if (!domain) {
        return this._textdomain;
      }
      this._textdomain = domain;
    },
    gettext: function (key) {
      return this.dcnpgettext.call(this, undef, undef, key);
    },
    dgettext: function (domain, key) {
      return this.dcnpgettext.call(this, domain, undef, key);
    },
    dcgettext: function (domain, key) {
      return this.dcnpgettext.call(this, domain, undef, key);
    },
    ngettext: function (skey, pkey, val) {
      return this.dcnpgettext.call(this, undef, undef, skey, pkey, val);
    },
    dngettext: function (domain, skey, pkey, val) {
      return this.dcnpgettext.call(this, domain, undef, skey, pkey, val);
    },
    dcngettext: function (domain, skey, pkey, val) {
      return this.dcnpgettext.call(this, domain, undef, skey, pkey, val);
    },
    pgettext: function (context, key) {
      return this.dcnpgettext.call(this, undef, context, key);
    },
    dpgettext: function (domain, context, key) {
      return this.dcnpgettext.call(this, domain, context, key);
    },
    dcpgettext: function (domain, context, key) {
      return this.dcnpgettext.call(this, domain, context, key);
    },
    npgettext: function (context, skey, pkey, val) {
      return this.dcnpgettext.call(this, undef, context, skey, pkey, val);
    },
    dnpgettext: function (domain, context, skey, pkey, val) {
      return this.dcnpgettext.call(this, domain, context, skey, pkey, val);
    },
    dcnpgettext: function (domain, context, singular_key, plural_key, val) {
      plural_key = plural_key || singular_key;
      domain = domain || this._textdomain;
      val = typeof val == 'undefined' ? 1 : val;
      var fallback;
      if (!this.options) {
        fallback = new Jed();
        return fallback.dcnpgettext.call(fallback, undefined, undefined, singular_key, plural_key, val);
      }
      if (!this.options.locale_data) {
        throw new Error('No locale data provided.');
      }
      if (!this.options.locale_data[domain]) {
        throw new Error('Domain `' + domain + '` was not found.');
      }
      if (!this.options.locale_data[domain]['']) {
        throw new Error('No locale meta information provided.');
      }
      if (!singular_key) {
        throw new Error('No translation key found.');
      }
      if (typeof val != 'number') {
        val = parseInt(val, 10);
        if (isNaN(val)) {
          throw new Error('The number that was passed in is not a number.');
        }
      }
      var key = context ? context + Jed.context_delimiter + singular_key : singular_key, locale_data = this.options.locale_data, dict = locale_data[domain], pluralForms = dict[''].plural_forms || (locale_data.messages || this.defaults.locale_data.messages)[''].plural_forms, val_idx = getPluralFormFunc(pluralForms)(val) + 1, val_list, res;
      if (!dict) {
        throw new Error('No domain named `' + domain + '` could be found.');
      }
      val_list = dict[key];
      if (!val_list || val_idx >= val_list.length) {
        if (this.options.missing_key_callback) {
          this.options.missing_key_callback(key);
        }
        res = [
          null,
          singular_key,
          plural_key
        ];
        return res[getPluralFormFunc(pluralForms)(val) + 1];
      }
      res = val_list[val_idx];
      if (!res) {
        res = [
          null,
          singular_key,
          plural_key
        ];
        return res[getPluralFormFunc(pluralForms)(val) + 1];
      }
      return res;
    }
  });
  var sprintf = function () {
      function get_type(variable) {
        return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase();
      }
      function str_repeat(input, multiplier) {
        for (var output = []; multiplier > 0; output[--multiplier] = input) {
        }
        return output.join('');
      }
      var str_format = function () {
        if (!str_format.cache.hasOwnProperty(arguments[0])) {
          str_format.cache[arguments[0]] = str_format.parse(arguments[0]);
        }
        return str_format.format.call(null, str_format.cache[arguments[0]], arguments);
      };
      str_format.format = function (parse_tree, argv) {
        var cursor = 1, tree_length = parse_tree.length, node_type = '', arg, output = [], i, k, match, pad, pad_character, pad_length;
        for (i = 0; i < tree_length; i++) {
          node_type = get_type(parse_tree[i]);
          if (node_type === 'string') {
            output.push(parse_tree[i]);
          } else if (node_type === 'array') {
            match = parse_tree[i];
            if (match[2]) {
              arg = argv[cursor];
              for (k = 0; k < match[2].length; k++) {
                if (!arg.hasOwnProperty(match[2][k])) {
                  throw sprintf('[sprintf] property "%s" does not exist', match[2][k]);
                }
                arg = arg[match[2][k]];
              }
            } else if (match[1]) {
              arg = argv[match[1]];
            } else {
              arg = argv[cursor++];
            }
            if (/[^s]/.test(match[8]) && get_type(arg) != 'number') {
              throw sprintf('[sprintf] expecting number but found %s', get_type(arg));
            }
            if (typeof arg == 'undefined' || arg === null) {
              arg = '';
            }
            switch (match[8]) {
            case 'b':
              arg = arg.toString(2);
              break;
            case 'c':
              arg = String.fromCharCode(arg);
              break;
            case 'd':
              arg = parseInt(arg, 10);
              break;
            case 'e':
              arg = match[7] ? arg.toExponential(match[7]) : arg.toExponential();
              break;
            case 'f':
              arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg);
              break;
            case 'o':
              arg = arg.toString(8);
              break;
            case 's':
              arg = (arg = String(arg)) && match[7] ? arg.substring(0, match[7]) : arg;
              break;
            case 'u':
              arg = Math.abs(arg);
              break;
            case 'x':
              arg = arg.toString(16);
              break;
            case 'X':
              arg = arg.toString(16).toUpperCase();
              break;
            }
            arg = /[def]/.test(match[8]) && match[3] && arg >= 0 ? '+' + arg : arg;
            pad_character = match[4] ? match[4] == '0' ? '0' : match[4].charAt(1) : ' ';
            pad_length = match[6] - String(arg).length;
            pad = match[6] ? str_repeat(pad_character, pad_length) : '';
            output.push(match[5] ? arg + pad : pad + arg);
          }
        }
        return output.join('');
      };
      str_format.cache = {};
      str_format.parse = function (fmt) {
        var _fmt = fmt, match = [], parse_tree = [], arg_names = 0;
        while (_fmt) {
          if ((match = /^[^\x25]+/.exec(_fmt)) !== null) {
            parse_tree.push(match[0]);
          } else if ((match = /^\x25{2}/.exec(_fmt)) !== null) {
            parse_tree.push('%');
          } else if ((match = /^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-fosuxX])/.exec(_fmt)) !== null) {
            if (match[2]) {
              arg_names |= 1;
              var field_list = [], replacement_field = match[2], field_match = [];
              if ((field_match = /^([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
                field_list.push(field_match[1]);
                while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {
                  if ((field_match = /^\.([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
                    field_list.push(field_match[1]);
                  } else if ((field_match = /^\[(\d+)\]/.exec(replacement_field)) !== null) {
                    field_list.push(field_match[1]);
                  } else {
                    throw '[sprintf] huh?';
                  }
                }
              } else {
                throw '[sprintf] huh?';
              }
              match[2] = field_list;
            } else {
              arg_names |= 2;
            }
            if (arg_names === 3) {
              throw '[sprintf] mixing positional and named placeholders is not (yet) supported';
            }
            parse_tree.push(match);
          } else {
            throw '[sprintf] huh?';
          }
          _fmt = _fmt.substring(match[0].length);
        }
        return parse_tree;
      };
      return str_format;
    }();
  var vsprintf = function (fmt, argv) {
    argv.unshift(fmt);
    return sprintf.apply(null, argv);
  };
  Jed.parse_plural = function (plural_forms, n) {
    plural_forms = plural_forms.replace(/n/g, n);
    return Jed.parse_expression(plural_forms);
  };
  Jed.sprintf = function (fmt, args) {
    if ({}.toString.call(args) == '[object Array]') {
      return vsprintf(fmt, [].slice.call(args));
    }
    return sprintf.apply(this, [].slice.call(arguments));
  };
  Jed.prototype.sprintf = function () {
    return Jed.sprintf.apply(this, arguments);
  };
  Jed.PF = {};
  Jed.PF.parse = function (p) {
    var plural_str = Jed.PF.extractPluralExpr(p);
    return Jed.PF.parser.parse.call(Jed.PF.parser, plural_str);
  };
  Jed.PF.compile = function (p) {
    function imply(val) {
      return val === true ? 1 : val ? val : 0;
    }
    var ast = Jed.PF.parse(p);
    return function (n) {
      return imply(Jed.PF.interpreter(ast)(n));
    };
  };
  Jed.PF.interpreter = function (ast) {
    return function (n) {
      var res;
      switch (ast.type) {
      case 'GROUP':
        return Jed.PF.interpreter(ast.expr)(n);
      case 'TERNARY':
        if (Jed.PF.interpreter(ast.expr)(n)) {
          return Jed.PF.interpreter(ast.truthy)(n);
        }
        return Jed.PF.interpreter(ast.falsey)(n);
      case 'OR':
        return Jed.PF.interpreter(ast.left)(n) || Jed.PF.interpreter(ast.right)(n);
      case 'AND':
        return Jed.PF.interpreter(ast.left)(n) && Jed.PF.interpreter(ast.right)(n);
      case 'LT':
        return Jed.PF.interpreter(ast.left)(n) < Jed.PF.interpreter(ast.right)(n);
      case 'GT':
        return Jed.PF.interpreter(ast.left)(n) > Jed.PF.interpreter(ast.right)(n);
      case 'LTE':
        return Jed.PF.interpreter(ast.left)(n) <= Jed.PF.interpreter(ast.right)(n);
      case 'GTE':
        return Jed.PF.interpreter(ast.left)(n) >= Jed.PF.interpreter(ast.right)(n);
      case 'EQ':
        return Jed.PF.interpreter(ast.left)(n) == Jed.PF.interpreter(ast.right)(n);
      case 'NEQ':
        return Jed.PF.interpreter(ast.left)(n) != Jed.PF.interpreter(ast.right)(n);
      case 'MOD':
        return Jed.PF.interpreter(ast.left)(n) % Jed.PF.interpreter(ast.right)(n);
      case 'VAR':
        return n;
      case 'NUM':
        return ast.val;
      default:
        throw new Error('Invalid Token found.');
      }
    };
  };
  Jed.PF.extractPluralExpr = function (p) {
    p = p.replace(/^\s\s*/, '').replace(/\s\s*$/, '');
    if (!/;\s*$/.test(p)) {
      p = p.concat(';');
    }
    var nplurals_re = /nplurals\=(\d+);/, plural_re = /plural\=(.*);/, nplurals_matches = p.match(nplurals_re), res = {}, plural_matches;
    if (nplurals_matches.length > 1) {
      res.nplurals = nplurals_matches[1];
    } else {
      throw new Error('nplurals not found in plural_forms string: ' + p);
    }
    p = p.replace(nplurals_re, '');
    plural_matches = p.match(plural_re);
    if (!(plural_matches && plural_matches.length > 1)) {
      throw new Error('`plural` expression not found: ' + p);
    }
    return plural_matches[1];
  };
  Jed.PF.parser = function () {
    var parser = {
        trace: function trace() {
        },
        yy: {},
        symbols_: {
          'error': 2,
          'expressions': 3,
          'e': 4,
          'EOF': 5,
          '?': 6,
          ':': 7,
          '||': 8,
          '&&': 9,
          '<': 10,
          '<=': 11,
          '>': 12,
          '>=': 13,
          '!=': 14,
          '==': 15,
          '%': 16,
          '(': 17,
          ')': 18,
          'n': 19,
          'NUMBER': 20,
          '$accept': 0,
          '$end': 1
        },
        terminals_: {
          2: 'error',
          5: 'EOF',
          6: '?',
          7: ':',
          8: '||',
          9: '&&',
          10: '<',
          11: '<=',
          12: '>',
          13: '>=',
          14: '!=',
          15: '==',
          16: '%',
          17: '(',
          18: ')',
          19: 'n',
          20: 'NUMBER'
        },
        productions_: [
          0,
          [
            3,
            2
          ],
          [
            4,
            5
          ],
          [
            4,
            3
          ],
          [
            4,
            3
          ],
          [
            4,
            3
          ],
          [
            4,
            3
          ],
          [
            4,
            3
          ],
          [
            4,
            3
          ],
          [
            4,
            3
          ],
          [
            4,
            3
          ],
          [
            4,
            3
          ],
          [
            4,
            3
          ],
          [
            4,
            1
          ],
          [
            4,
            1
          ]
        ],
        performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
          var $0 = $$.length - 1;
          switch (yystate) {
          case 1:
            return {
              type: 'GROUP',
              expr: $$[$0 - 1]
            };
            break;
          case 2:
            this.$ = {
              type: 'TERNARY',
              expr: $$[$0 - 4],
              truthy: $$[$0 - 2],
              falsey: $$[$0]
            };
            break;
          case 3:
            this.$ = {
              type: 'OR',
              left: $$[$0 - 2],
              right: $$[$0]
            };
            break;
          case 4:
            this.$ = {
              type: 'AND',
              left: $$[$0 - 2],
              right: $$[$0]
            };
            break;
          case 5:
            this.$ = {
              type: 'LT',
              left: $$[$0 - 2],
              right: $$[$0]
            };
            break;
          case 6:
            this.$ = {
              type: 'LTE',
              left: $$[$0 - 2],
              right: $$[$0]
            };
            break;
          case 7:
            this.$ = {
              type: 'GT',
              left: $$[$0 - 2],
              right: $$[$0]
            };
            break;
          case 8:
            this.$ = {
              type: 'GTE',
              left: $$[$0 - 2],
              right: $$[$0]
            };
            break;
          case 9:
            this.$ = {
              type: 'NEQ',
              left: $$[$0 - 2],
              right: $$[$0]
            };
            break;
          case 10:
            this.$ = {
              type: 'EQ',
              left: $$[$0 - 2],
              right: $$[$0]
            };
            break;
          case 11:
            this.$ = {
              type: 'MOD',
              left: $$[$0 - 2],
              right: $$[$0]
            };
            break;
          case 12:
            this.$ = {
              type: 'GROUP',
              expr: $$[$0 - 1]
            };
            break;
          case 13:
            this.$ = { type: 'VAR' };
            break;
          case 14:
            this.$ = {
              type: 'NUM',
              val: Number(yytext)
            };
            break;
          }
        },
        table: [
          {
            3: 1,
            4: 2,
            17: [
              1,
              3
            ],
            19: [
              1,
              4
            ],
            20: [
              1,
              5
            ]
          },
          { 1: [3] },
          {
            5: [
              1,
              6
            ],
            6: [
              1,
              7
            ],
            8: [
              1,
              8
            ],
            9: [
              1,
              9
            ],
            10: [
              1,
              10
            ],
            11: [
              1,
              11
            ],
            12: [
              1,
              12
            ],
            13: [
              1,
              13
            ],
            14: [
              1,
              14
            ],
            15: [
              1,
              15
            ],
            16: [
              1,
              16
            ]
          },
          {
            4: 17,
            17: [
              1,
              3
            ],
            19: [
              1,
              4
            ],
            20: [
              1,
              5
            ]
          },
          {
            5: [
              2,
              13
            ],
            6: [
              2,
              13
            ],
            7: [
              2,
              13
            ],
            8: [
              2,
              13
            ],
            9: [
              2,
              13
            ],
            10: [
              2,
              13
            ],
            11: [
              2,
              13
            ],
            12: [
              2,
              13
            ],
            13: [
              2,
              13
            ],
            14: [
              2,
              13
            ],
            15: [
              2,
              13
            ],
            16: [
              2,
              13
            ],
            18: [
              2,
              13
            ]
          },
          {
            5: [
              2,
              14
            ],
            6: [
              2,
              14
            ],
            7: [
              2,
              14
            ],
            8: [
              2,
              14
            ],
            9: [
              2,
              14
            ],
            10: [
              2,
              14
            ],
            11: [
              2,
              14
            ],
            12: [
              2,
              14
            ],
            13: [
              2,
              14
            ],
            14: [
              2,
              14
            ],
            15: [
              2,
              14
            ],
            16: [
              2,
              14
            ],
            18: [
              2,
              14
            ]
          },
          {
            1: [
              2,
              1
            ]
          },
          {
            4: 18,
            17: [
              1,
              3
            ],
            19: [
              1,
              4
            ],
            20: [
              1,
              5
            ]
          },
          {
            4: 19,
            17: [
              1,
              3
            ],
            19: [
              1,
              4
            ],
            20: [
              1,
              5
            ]
          },
          {
            4: 20,
            17: [
              1,
              3
            ],
            19: [
              1,
              4
            ],
            20: [
              1,
              5
            ]
          },
          {
            4: 21,
            17: [
              1,
              3
            ],
            19: [
              1,
              4
            ],
            20: [
              1,
              5
            ]
          },
          {
            4: 22,
            17: [
              1,
              3
            ],
            19: [
              1,
              4
            ],
            20: [
              1,
              5
            ]
          },
          {
            4: 23,
            17: [
              1,
              3
            ],
            19: [
              1,
              4
            ],
            20: [
              1,
              5
            ]
          },
          {
            4: 24,
            17: [
              1,
              3
            ],
            19: [
              1,
              4
            ],
            20: [
              1,
              5
            ]
          },
          {
            4: 25,
            17: [
              1,
              3
            ],
            19: [
              1,
              4
            ],
            20: [
              1,
              5
            ]
          },
          {
            4: 26,
            17: [
              1,
              3
            ],
            19: [
              1,
              4
            ],
            20: [
              1,
              5
            ]
          },
          {
            4: 27,
            17: [
              1,
              3
            ],
            19: [
              1,
              4
            ],
            20: [
              1,
              5
            ]
          },
          {
            6: [
              1,
              7
            ],
            8: [
              1,
              8
            ],
            9: [
              1,
              9
            ],
            10: [
              1,
              10
            ],
            11: [
              1,
              11
            ],
            12: [
              1,
              12
            ],
            13: [
              1,
              13
            ],
            14: [
              1,
              14
            ],
            15: [
              1,
              15
            ],
            16: [
              1,
              16
            ],
            18: [
              1,
              28
            ]
          },
          {
            6: [
              1,
              7
            ],
            7: [
              1,
              29
            ],
            8: [
              1,
              8
            ],
            9: [
              1,
              9
            ],
            10: [
              1,
              10
            ],
            11: [
              1,
              11
            ],
            12: [
              1,
              12
            ],
            13: [
              1,
              13
            ],
            14: [
              1,
              14
            ],
            15: [
              1,
              15
            ],
            16: [
              1,
              16
            ]
          },
          {
            5: [
              2,
              3
            ],
            6: [
              2,
              3
            ],
            7: [
              2,
              3
            ],
            8: [
              2,
              3
            ],
            9: [
              1,
              9
            ],
            10: [
              1,
              10
            ],
            11: [
              1,
              11
            ],
            12: [
              1,
              12
            ],
            13: [
              1,
              13
            ],
            14: [
              1,
              14
            ],
            15: [
              1,
              15
            ],
            16: [
              1,
              16
            ],
            18: [
              2,
              3
            ]
          },
          {
            5: [
              2,
              4
            ],
            6: [
              2,
              4
            ],
            7: [
              2,
              4
            ],
            8: [
              2,
              4
            ],
            9: [
              2,
              4
            ],
            10: [
              1,
              10
            ],
            11: [
              1,
              11
            ],
            12: [
              1,
              12
            ],
            13: [
              1,
              13
            ],
            14: [
              1,
              14
            ],
            15: [
              1,
              15
            ],
            16: [
              1,
              16
            ],
            18: [
              2,
              4
            ]
          },
          {
            5: [
              2,
              5
            ],
            6: [
              2,
              5
            ],
            7: [
              2,
              5
            ],
            8: [
              2,
              5
            ],
            9: [
              2,
              5
            ],
            10: [
              2,
              5
            ],
            11: [
              2,
              5
            ],
            12: [
              2,
              5
            ],
            13: [
              2,
              5
            ],
            14: [
              2,
              5
            ],
            15: [
              2,
              5
            ],
            16: [
              1,
              16
            ],
            18: [
              2,
              5
            ]
          },
          {
            5: [
              2,
              6
            ],
            6: [
              2,
              6
            ],
            7: [
              2,
              6
            ],
            8: [
              2,
              6
            ],
            9: [
              2,
              6
            ],
            10: [
              2,
              6
            ],
            11: [
              2,
              6
            ],
            12: [
              2,
              6
            ],
            13: [
              2,
              6
            ],
            14: [
              2,
              6
            ],
            15: [
              2,
              6
            ],
            16: [
              1,
              16
            ],
            18: [
              2,
              6
            ]
          },
          {
            5: [
              2,
              7
            ],
            6: [
              2,
              7
            ],
            7: [
              2,
              7
            ],
            8: [
              2,
              7
            ],
            9: [
              2,
              7
            ],
            10: [
              2,
              7
            ],
            11: [
              2,
              7
            ],
            12: [
              2,
              7
            ],
            13: [
              2,
              7
            ],
            14: [
              2,
              7
            ],
            15: [
              2,
              7
            ],
            16: [
              1,
              16
            ],
            18: [
              2,
              7
            ]
          },
          {
            5: [
              2,
              8
            ],
            6: [
              2,
              8
            ],
            7: [
              2,
              8
            ],
            8: [
              2,
              8
            ],
            9: [
              2,
              8
            ],
            10: [
              2,
              8
            ],
            11: [
              2,
              8
            ],
            12: [
              2,
              8
            ],
            13: [
              2,
              8
            ],
            14: [
              2,
              8
            ],
            15: [
              2,
              8
            ],
            16: [
              1,
              16
            ],
            18: [
              2,
              8
            ]
          },
          {
            5: [
              2,
              9
            ],
            6: [
              2,
              9
            ],
            7: [
              2,
              9
            ],
            8: [
              2,
              9
            ],
            9: [
              2,
              9
            ],
            10: [
              2,
              9
            ],
            11: [
              2,
              9
            ],
            12: [
              2,
              9
            ],
            13: [
              2,
              9
            ],
            14: [
              2,
              9
            ],
            15: [
              2,
              9
            ],
            16: [
              1,
              16
            ],
            18: [
              2,
              9
            ]
          },
          {
            5: [
              2,
              10
            ],
            6: [
              2,
              10
            ],
            7: [
              2,
              10
            ],
            8: [
              2,
              10
            ],
            9: [
              2,
              10
            ],
            10: [
              2,
              10
            ],
            11: [
              2,
              10
            ],
            12: [
              2,
              10
            ],
            13: [
              2,
              10
            ],
            14: [
              2,
              10
            ],
            15: [
              2,
              10
            ],
            16: [
              1,
              16
            ],
            18: [
              2,
              10
            ]
          },
          {
            5: [
              2,
              11
            ],
            6: [
              2,
              11
            ],
            7: [
              2,
              11
            ],
            8: [
              2,
              11
            ],
            9: [
              2,
              11
            ],
            10: [
              2,
              11
            ],
            11: [
              2,
              11
            ],
            12: [
              2,
              11
            ],
            13: [
              2,
              11
            ],
            14: [
              2,
              11
            ],
            15: [
              2,
              11
            ],
            16: [
              2,
              11
            ],
            18: [
              2,
              11
            ]
          },
          {
            5: [
              2,
              12
            ],
            6: [
              2,
              12
            ],
            7: [
              2,
              12
            ],
            8: [
              2,
              12
            ],
            9: [
              2,
              12
            ],
            10: [
              2,
              12
            ],
            11: [
              2,
              12
            ],
            12: [
              2,
              12
            ],
            13: [
              2,
              12
            ],
            14: [
              2,
              12
            ],
            15: [
              2,
              12
            ],
            16: [
              2,
              12
            ],
            18: [
              2,
              12
            ]
          },
          {
            4: 30,
            17: [
              1,
              3
            ],
            19: [
              1,
              4
            ],
            20: [
              1,
              5
            ]
          },
          {
            5: [
              2,
              2
            ],
            6: [
              1,
              7
            ],
            7: [
              2,
              2
            ],
            8: [
              1,
              8
            ],
            9: [
              1,
              9
            ],
            10: [
              1,
              10
            ],
            11: [
              1,
              11
            ],
            12: [
              1,
              12
            ],
            13: [
              1,
              13
            ],
            14: [
              1,
              14
            ],
            15: [
              1,
              15
            ],
            16: [
              1,
              16
            ],
            18: [
              2,
              2
            ]
          }
        ],
        defaultActions: {
          6: [
            2,
            1
          ]
        },
        parseError: function parseError(str, hash) {
          throw new Error(str);
        },
        parse: function parse(input) {
          var self = this, stack = [0], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
          this.lexer.setInput(input);
          this.lexer.yy = this.yy;
          this.yy.lexer = this.lexer;
          if (typeof this.lexer.yylloc == 'undefined')
            this.lexer.yylloc = {};
          var yyloc = this.lexer.yylloc;
          lstack.push(yyloc);
          if (typeof this.yy.parseError === 'function')
            this.parseError = this.yy.parseError;
          function popStack(n) {
            stack.length = stack.length - 2 * n;
            vstack.length = vstack.length - n;
            lstack.length = lstack.length - n;
          }
          function lex() {
            var token;
            token = self.lexer.lex() || 1;
            if (typeof token !== 'number') {
              token = self.symbols_[token] || token;
            }
            return token;
          }
          var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
          while (true) {
            state = stack[stack.length - 1];
            if (this.defaultActions[state]) {
              action = this.defaultActions[state];
            } else {
              if (symbol == null)
                symbol = lex();
              action = table[state] && table[state][symbol];
            }
            _handle_error:
              if (typeof action === 'undefined' || !action.length || !action[0]) {
                if (!recovering) {
                  expected = [];
                  for (p in table[state])
                    if (this.terminals_[p] && p > 2) {
                      expected.push('\'' + this.terminals_[p] + '\'');
                    }
                  var errStr = '';
                  if (this.lexer.showPosition) {
                    errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + this.lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ', got \'' + this.terminals_[symbol] + '\'';
                  } else {
                    errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == 1 ? 'end of input' : '\'' + (this.terminals_[symbol] || symbol) + '\'');
                  }
                  this.parseError(errStr, {
                    text: this.lexer.match,
                    token: this.terminals_[symbol] || symbol,
                    line: this.lexer.yylineno,
                    loc: yyloc,
                    expected: expected
                  });
                }
                if (recovering == 3) {
                  if (symbol == EOF) {
                    throw new Error(errStr || 'Parsing halted.');
                  }
                  yyleng = this.lexer.yyleng;
                  yytext = this.lexer.yytext;
                  yylineno = this.lexer.yylineno;
                  yyloc = this.lexer.yylloc;
                  symbol = lex();
                }
                while (1) {
                  if (TERROR.toString() in table[state]) {
                    break;
                  }
                  if (state == 0) {
                    throw new Error(errStr || 'Parsing halted.');
                  }
                  popStack(1);
                  state = stack[stack.length - 1];
                }
                preErrorSymbol = symbol;
                symbol = TERROR;
                state = stack[stack.length - 1];
                action = table[state] && table[state][TERROR];
                recovering = 3;
              }
            if (action[0] instanceof Array && action.length > 1) {
              throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
            }
            switch (action[0]) {
            case 1:
              stack.push(symbol);
              vstack.push(this.lexer.yytext);
              lstack.push(this.lexer.yylloc);
              stack.push(action[1]);
              symbol = null;
              if (!preErrorSymbol) {
                yyleng = this.lexer.yyleng;
                yytext = this.lexer.yytext;
                yylineno = this.lexer.yylineno;
                yyloc = this.lexer.yylloc;
                if (recovering > 0)
                  recovering--;
              } else {
                symbol = preErrorSymbol;
                preErrorSymbol = null;
              }
              break;
            case 2:
              len = this.productions_[action[1]][1];
              yyval.$ = vstack[vstack.length - len];
              yyval._$ = {
                first_line: lstack[lstack.length - (len || 1)].first_line,
                last_line: lstack[lstack.length - 1].last_line,
                first_column: lstack[lstack.length - (len || 1)].first_column,
                last_column: lstack[lstack.length - 1].last_column
              };
              r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);
              if (typeof r !== 'undefined') {
                return r;
              }
              if (len) {
                stack = stack.slice(0, -1 * len * 2);
                vstack = vstack.slice(0, -1 * len);
                lstack = lstack.slice(0, -1 * len);
              }
              stack.push(this.productions_[action[1]][0]);
              vstack.push(yyval.$);
              lstack.push(yyval._$);
              newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
              stack.push(newState);
              break;
            case 3:
              return true;
            }
          }
          return true;
        }
      };
    var lexer = function () {
        var lexer = {
            EOF: 1,
            parseError: function parseError(str, hash) {
              if (this.yy.parseError) {
                this.yy.parseError(str, hash);
              } else {
                throw new Error(str);
              }
            },
            setInput: function (input) {
              this._input = input;
              this._more = this._less = this.done = false;
              this.yylineno = this.yyleng = 0;
              this.yytext = this.matched = this.match = '';
              this.conditionStack = ['INITIAL'];
              this.yylloc = {
                first_line: 1,
                first_column: 0,
                last_line: 1,
                last_column: 0
              };
              return this;
            },
            input: function () {
              var ch = this._input[0];
              this.yytext += ch;
              this.yyleng++;
              this.match += ch;
              this.matched += ch;
              var lines = ch.match(/\n/);
              if (lines)
                this.yylineno++;
              this._input = this._input.slice(1);
              return ch;
            },
            unput: function (ch) {
              this._input = ch + this._input;
              return this;
            },
            more: function () {
              this._more = true;
              return this;
            },
            pastInput: function () {
              var past = this.matched.substr(0, this.matched.length - this.match.length);
              return (past.length > 20 ? '...' : '') + past.substr(-20).replace(/\n/g, '');
            },
            upcomingInput: function () {
              var next = this.match;
              if (next.length < 20) {
                next += this._input.substr(0, 20 - next.length);
              }
              return (next.substr(0, 20) + (next.length > 20 ? '...' : '')).replace(/\n/g, '');
            },
            showPosition: function () {
              var pre = this.pastInput();
              var c = new Array(pre.length + 1).join('-');
              return pre + this.upcomingInput() + '\n' + c + '^';
            },
            next: function () {
              if (this.done) {
                return this.EOF;
              }
              if (!this._input)
                this.done = true;
              var token, match, col, lines;
              if (!this._more) {
                this.yytext = '';
                this.match = '';
              }
              var rules = this._currentRules();
              for (var i = 0; i < rules.length; i++) {
                match = this._input.match(this.rules[rules[i]]);
                if (match) {
                  lines = match[0].match(/\n.*/g);
                  if (lines)
                    this.yylineno += lines.length;
                  this.yylloc = {
                    first_line: this.yylloc.last_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.last_column,
                    last_column: lines ? lines[lines.length - 1].length - 1 : this.yylloc.last_column + match[0].length
                  };
                  this.yytext += match[0];
                  this.match += match[0];
                  this.matches = match;
                  this.yyleng = this.yytext.length;
                  this._more = false;
                  this._input = this._input.slice(match[0].length);
                  this.matched += match[0];
                  token = this.performAction.call(this, this.yy, this, rules[i], this.conditionStack[this.conditionStack.length - 1]);
                  if (token)
                    return token;
                  else
                    return;
                }
              }
              if (this._input === '') {
                return this.EOF;
              } else {
                this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
                  text: '',
                  token: null,
                  line: this.yylineno
                });
              }
            },
            lex: function lex() {
              var r = this.next();
              if (typeof r !== 'undefined') {
                return r;
              } else {
                return this.lex();
              }
            },
            begin: function begin(condition) {
              this.conditionStack.push(condition);
            },
            popState: function popState() {
              return this.conditionStack.pop();
            },
            _currentRules: function _currentRules() {
              return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
            },
            topState: function () {
              return this.conditionStack[this.conditionStack.length - 2];
            },
            pushState: function begin(condition) {
              this.begin(condition);
            }
          };
        lexer.performAction = function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
          var YYSTATE = YY_START;
          switch ($avoiding_name_collisions) {
          case 0:
            break;
          case 1:
            return 20;
            break;
          case 2:
            return 19;
            break;
          case 3:
            return 8;
            break;
          case 4:
            return 9;
            break;
          case 5:
            return 6;
            break;
          case 6:
            return 7;
            break;
          case 7:
            return 11;
            break;
          case 8:
            return 13;
            break;
          case 9:
            return 10;
            break;
          case 10:
            return 12;
            break;
          case 11:
            return 14;
            break;
          case 12:
            return 15;
            break;
          case 13:
            return 16;
            break;
          case 14:
            return 17;
            break;
          case 15:
            return 18;
            break;
          case 16:
            return 5;
            break;
          case 17:
            return 'INVALID';
            break;
          }
        };
        lexer.rules = [
          /^\s+/,
          /^[0-9]+(\.[0-9]+)?\b/,
          /^n\b/,
          /^\|\|/,
          /^&&/,
          /^\?/,
          /^:/,
          /^<=/,
          /^>=/,
          /^</,
          /^>/,
          /^!=/,
          /^==/,
          /^%/,
          /^\(/,
          /^\)/,
          /^$/,
          /^./
        ];
        lexer.conditions = {
          'INITIAL': {
            'rules': [
              0,
              1,
              2,
              3,
              4,
              5,
              6,
              7,
              8,
              9,
              10,
              11,
              12,
              13,
              14,
              15,
              16,
              17
            ],
            'inclusive': true
          }
        };
        return lexer;
      }();
    parser.lexer = lexer;
    return parser;
  }();
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = Jed;
    }
    exports.Jed = Jed;
  } else {
    if (typeof define === 'function' && define.amd) {
      define('jed', function () {
        return Jed;
      });
    }
    root['Jed'] = Jed;
  }
}(this));
window.CodeMirror = function () {
  'use strict';
  var gecko = /gecko\/\d/i.test(navigator.userAgent);
  var ie = /MSIE \d/.test(navigator.userAgent);
  var ie_lt8 = ie && (document.documentMode == null || document.documentMode < 8);
  var ie_lt9 = ie && (document.documentMode == null || document.documentMode < 9);
  var webkit = /WebKit\//.test(navigator.userAgent);
  var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(navigator.userAgent);
  var chrome = /Chrome\//.test(navigator.userAgent);
  var opera = /Opera\//.test(navigator.userAgent);
  var safari = /Apple Computer/.test(navigator.vendor);
  var khtml = /KHTML\//.test(navigator.userAgent);
  var mac_geLion = /Mac OS X 1\d\D([7-9]|\d\d)\D/.test(navigator.userAgent);
  var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(navigator.userAgent);
  var phantom = /PhantomJS/.test(navigator.userAgent);
  var ios = /AppleWebKit/.test(navigator.userAgent) && /Mobile\/\w+/.test(navigator.userAgent);
  var mobile = ios || /Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(navigator.userAgent);
  var mac = ios || /Mac/.test(navigator.platform);
  var windows = /windows/i.test(navigator.platform);
  var opera_version = opera && navigator.userAgent.match(/Version\/(\d*\.\d*)/);
  if (opera_version)
    opera_version = Number(opera_version[1]);
  var flipCtrlCmd = mac && (qtwebkit || opera && (opera_version == null || opera_version < 12.11));
  var captureMiddleClick = gecko || ie && !ie_lt9;
  var sawReadOnlySpans = false, sawCollapsedSpans = false;
  function CodeMirror(place, options) {
    if (!(this instanceof CodeMirror))
      return new CodeMirror(place, options);
    this.options = options = options || {};
    for (var opt in defaults)
      if (!options.hasOwnProperty(opt) && defaults.hasOwnProperty(opt))
        options[opt] = defaults[opt];
    setGuttersForLineNumbers(options);
    var docStart = typeof options.value == 'string' ? 0 : options.value.first;
    var display = this.display = makeDisplay(place, docStart);
    display.wrapper.CodeMirror = this;
    updateGutters(this);
    if (options.autofocus && !mobile)
      focusInput(this);
    this.state = {
      keyMaps: [],
      overlays: [],
      modeGen: 0,
      overwrite: false,
      focused: false,
      suppressEdits: false,
      pasteIncoming: false,
      draggingText: false,
      highlight: new Delayed()
    };
    themeChanged(this);
    if (options.lineWrapping)
      this.display.wrapper.className += ' CodeMirror-wrap';
    var doc = options.value;
    if (typeof doc == 'string')
      doc = new Doc(options.value, options.mode);
    operation(this, attachDoc)(this, doc);
    if (ie)
      setTimeout(bind(resetInput, this, true), 20);
    registerEventHandlers(this);
    var hasFocus;
    try {
      hasFocus = document.activeElement == display.input;
    } catch (e) {
    }
    if (hasFocus || options.autofocus && !mobile)
      setTimeout(bind(onFocus, this), 20);
    else
      onBlur(this);
    operation(this, function () {
      for (var opt in optionHandlers)
        if (optionHandlers.propertyIsEnumerable(opt))
          optionHandlers[opt](this, options[opt], Init);
      for (var i = 0; i < initHooks.length; ++i)
        initHooks[i](this);
    })();
  }
  function makeDisplay(place, docStart) {
    var d = {};
    var input = d.input = elt('textarea', null, null, 'position: absolute; padding: 0; width: 1px; height: 1em; outline: none; font-size: 4px;');
    if (webkit)
      input.style.width = '1000px';
    else
      input.setAttribute('wrap', 'off');
    if (ios)
      input.style.border = '1px solid black';
    input.setAttribute('autocorrect', 'off');
    input.setAttribute('autocapitalize', 'off');
    d.inputDiv = elt('div', [input], null, 'overflow: hidden; position: relative; width: 3px; height: 0px;');
    d.scrollbarH = elt('div', [elt('div', null, null, 'height: 1px')], 'CodeMirror-hscrollbar');
    d.scrollbarV = elt('div', [elt('div', null, null, 'width: 1px')], 'CodeMirror-vscrollbar');
    d.scrollbarFiller = elt('div', null, 'CodeMirror-scrollbar-filler');
    d.lineDiv = elt('div');
    d.selectionDiv = elt('div', null, null, 'position: relative; z-index: 1');
    d.cursor = elt('div', '\xa0', 'CodeMirror-cursor');
    d.otherCursor = elt('div', '\xa0', 'CodeMirror-cursor CodeMirror-secondarycursor');
    d.measure = elt('div', null, 'CodeMirror-measure');
    d.lineSpace = elt('div', [
      d.measure,
      d.selectionDiv,
      d.lineDiv,
      d.cursor,
      d.otherCursor
    ], null, 'position: relative; outline: none');
    d.mover = elt('div', [elt('div', [d.lineSpace], 'CodeMirror-lines')], null, 'position: relative');
    d.sizer = elt('div', [d.mover], 'CodeMirror-sizer');
    d.heightForcer = elt('div', null, null, 'position: absolute; height: ' + scrollerCutOff + 'px; width: 1px;');
    d.gutters = elt('div', null, 'CodeMirror-gutters');
    d.lineGutter = null;
    var scrollerInner = elt('div', [
        d.sizer,
        d.heightForcer,
        d.gutters
      ], null, 'position: relative; min-height: 100%');
    d.scroller = elt('div', [scrollerInner], 'CodeMirror-scroll');
    d.scroller.setAttribute('tabIndex', '-1');
    d.wrapper = elt('div', [
      d.inputDiv,
      d.scrollbarH,
      d.scrollbarV,
      d.scrollbarFiller,
      d.scroller
    ], 'CodeMirror');
    if (ie_lt8) {
      d.gutters.style.zIndex = -1;
      d.scroller.style.paddingRight = 0;
    }
    if (place.appendChild)
      place.appendChild(d.wrapper);
    else
      place(d.wrapper);
    if (ios)
      input.style.width = '0px';
    if (!webkit)
      d.scroller.draggable = true;
    if (khtml) {
      d.inputDiv.style.height = '1px';
      d.inputDiv.style.position = 'absolute';
    } else if (ie_lt8)
      d.scrollbarH.style.minWidth = d.scrollbarV.style.minWidth = '18px';
    d.viewOffset = d.lastSizeC = 0;
    d.showingFrom = d.showingTo = docStart;
    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;
    d.prevInput = '';
    d.alignWidgets = false;
    d.pollingFast = false;
    d.poll = new Delayed();
    d.cachedCharWidth = d.cachedTextHeight = null;
    d.measureLineCache = [];
    d.measureLineCachePos = 0;
    d.inaccurateSelection = false;
    d.maxLine = null;
    d.maxLineLength = 0;
    d.maxLineChanged = false;
    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;
    return d;
  }
  function loadMode(cm) {
    cm.doc.mode = CodeMirror.getMode(cm.options, cm.doc.modeOption);
    cm.doc.iter(function (line) {
      if (line.stateAfter)
        line.stateAfter = null;
      if (line.styles)
        line.styles = null;
    });
    cm.doc.frontier = cm.doc.first;
    startWorker(cm, 100);
    cm.state.modeGen++;
    if (cm.curOp)
      regChange(cm);
  }
  function wrappingChanged(cm) {
    if (cm.options.lineWrapping) {
      cm.display.wrapper.className += ' CodeMirror-wrap';
      cm.display.sizer.style.minWidth = '';
    } else {
      cm.display.wrapper.className = cm.display.wrapper.className.replace(' CodeMirror-wrap', '');
      computeMaxLength(cm);
    }
    estimateLineHeights(cm);
    regChange(cm);
    clearCaches(cm);
    setTimeout(function () {
      updateScrollbars(cm.display, cm.doc.height);
    }, 100);
  }
  function estimateHeight(cm) {
    var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;
    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
    return function (line) {
      if (lineIsHidden(cm.doc, line))
        return 0;
      else if (wrapping)
        return (Math.ceil(line.text.length / perLine) || 1) * th;
      else
        return th;
    };
  }
  function estimateLineHeights(cm) {
    var doc = cm.doc, est = estimateHeight(cm);
    doc.iter(function (line) {
      var estHeight = est(line);
      if (estHeight != line.height)
        updateLineHeight(line, estHeight);
    });
  }
  function keyMapChanged(cm) {
    var style = keyMap[cm.options.keyMap].style;
    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-keymap-\S+/g, '') + (style ? ' cm-keymap-' + style : '');
  }
  function themeChanged(cm) {
    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, '') + cm.options.theme.replace(/(^|\s)\s*/g, ' cm-s-');
    clearCaches(cm);
  }
  function guttersChanged(cm) {
    updateGutters(cm);
    regChange(cm);
  }
  function updateGutters(cm) {
    var gutters = cm.display.gutters, specs = cm.options.gutters;
    removeChildren(gutters);
    for (var i = 0; i < specs.length; ++i) {
      var gutterClass = specs[i];
      var gElt = gutters.appendChild(elt('div', null, 'CodeMirror-gutter ' + gutterClass));
      if (gutterClass == 'CodeMirror-linenumbers') {
        cm.display.lineGutter = gElt;
        gElt.style.width = (cm.display.lineNumWidth || 1) + 'px';
      }
    }
    gutters.style.display = i ? '' : 'none';
  }
  function lineLength(doc, line) {
    if (line.height == 0)
      return 0;
    var len = line.text.length, merged, cur = line;
    while (merged = collapsedSpanAtStart(cur)) {
      var found = merged.find();
      cur = getLine(doc, found.from.line);
      len += found.from.ch - found.to.ch;
    }
    cur = line;
    while (merged = collapsedSpanAtEnd(cur)) {
      var found = merged.find();
      len -= cur.text.length - found.from.ch;
      cur = getLine(doc, found.to.line);
      len += cur.text.length - found.to.ch;
    }
    return len;
  }
  function computeMaxLength(cm) {
    var d = cm.display, doc = cm.doc;
    d.maxLine = getLine(doc, doc.first);
    d.maxLineLength = lineLength(doc, d.maxLine);
    d.maxLineChanged = true;
    doc.iter(function (line) {
      var len = lineLength(doc, line);
      if (len > d.maxLineLength) {
        d.maxLineLength = len;
        d.maxLine = line;
      }
    });
  }
  function setGuttersForLineNumbers(options) {
    var found = false;
    for (var i = 0; i < options.gutters.length; ++i) {
      if (options.gutters[i] == 'CodeMirror-linenumbers') {
        if (options.lineNumbers)
          found = true;
        else
          options.gutters.splice(i--, 1);
      }
    }
    if (!found && options.lineNumbers)
      options.gutters.push('CodeMirror-linenumbers');
  }
  function updateScrollbars(d, docHeight) {
    var totalHeight = docHeight + paddingVert(d);
    d.sizer.style.minHeight = d.heightForcer.style.top = totalHeight + 'px';
    var scrollHeight = Math.max(totalHeight, d.scroller.scrollHeight);
    var needsH = d.scroller.scrollWidth > d.scroller.clientWidth;
    var needsV = scrollHeight > d.scroller.clientHeight;
    if (needsV) {
      d.scrollbarV.style.display = 'block';
      d.scrollbarV.style.bottom = needsH ? scrollbarWidth(d.measure) + 'px' : '0';
      d.scrollbarV.firstChild.style.height = scrollHeight - d.scroller.clientHeight + d.scrollbarV.clientHeight + 'px';
    } else
      d.scrollbarV.style.display = '';
    if (needsH) {
      d.scrollbarH.style.display = 'block';
      d.scrollbarH.style.right = needsV ? scrollbarWidth(d.measure) + 'px' : '0';
      d.scrollbarH.firstChild.style.width = d.scroller.scrollWidth - d.scroller.clientWidth + d.scrollbarH.clientWidth + 'px';
    } else
      d.scrollbarH.style.display = '';
    if (needsH && needsV) {
      d.scrollbarFiller.style.display = 'block';
      d.scrollbarFiller.style.height = d.scrollbarFiller.style.width = scrollbarWidth(d.measure) + 'px';
    } else
      d.scrollbarFiller.style.display = '';
    if (mac_geLion && scrollbarWidth(d.measure) === 0)
      d.scrollbarV.style.minWidth = d.scrollbarH.style.minHeight = mac_geMountainLion ? '18px' : '12px';
  }
  function visibleLines(display, doc, viewPort) {
    var top = display.scroller.scrollTop, height = display.wrapper.clientHeight;
    if (typeof viewPort == 'number')
      top = viewPort;
    else if (viewPort) {
      top = viewPort.top;
      height = viewPort.bottom - viewPort.top;
    }
    top = Math.floor(top - paddingTop(display));
    var bottom = Math.ceil(top + height);
    return {
      from: lineAtHeight(doc, top),
      to: lineAtHeight(doc, bottom)
    };
  }
  function alignHorizontally(cm) {
    var display = cm.display;
    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter))
      return;
    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
    var gutterW = display.gutters.offsetWidth, l = comp + 'px';
    for (var n = display.lineDiv.firstChild; n; n = n.nextSibling)
      if (n.alignable) {
        for (var i = 0, a = n.alignable; i < a.length; ++i)
          a[i].style.left = l;
      }
    if (cm.options.fixedGutter)
      display.gutters.style.left = comp + gutterW + 'px';
  }
  function maybeUpdateLineNumberWidth(cm) {
    if (!cm.options.lineNumbers)
      return false;
    var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;
    if (last.length != display.lineNumChars) {
      var test = display.measure.appendChild(elt('div', [elt('div', last)], 'CodeMirror-linenumber CodeMirror-gutter-elt'));
      var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;
      display.lineGutter.style.width = '';
      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding);
      display.lineNumWidth = display.lineNumInnerWidth + padding;
      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
      display.lineGutter.style.width = display.lineNumWidth + 'px';
      return true;
    }
    return false;
  }
  function lineNumberFor(options, i) {
    return String(options.lineNumberFormatter(i + options.firstLineNumber));
  }
  function compensateForHScroll(display) {
    return getRect(display.scroller).left - getRect(display.sizer).left;
  }
  function updateDisplay(cm, changes, viewPort) {
    var oldFrom = cm.display.showingFrom, oldTo = cm.display.showingTo, updated;
    var visible = visibleLines(cm.display, cm.doc, viewPort);
    for (;;) {
      if (updateDisplayInner(cm, changes, visible)) {
        updated = true;
        signalLater(cm, 'update', cm);
        if (cm.display.showingFrom != oldFrom || cm.display.showingTo != oldTo)
          signalLater(cm, 'viewportChange', cm, cm.display.showingFrom, cm.display.showingTo);
      } else
        break;
      updateSelection(cm);
      updateScrollbars(cm.display, cm.doc.height);
      if (viewPort)
        viewPort = Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, typeof viewPort == 'number' ? viewPort : viewPort.top);
      visible = visibleLines(cm.display, cm.doc, viewPort);
      if (visible.from >= cm.display.showingFrom && visible.to <= cm.display.showingTo)
        break;
      changes = [];
    }
    return updated;
  }
  function updateDisplayInner(cm, changes, visible) {
    var display = cm.display, doc = cm.doc;
    if (!display.wrapper.clientWidth) {
      display.showingFrom = display.showingTo = doc.first;
      display.viewOffset = 0;
      return;
    }
    if (changes.length == 0 && visible.from > display.showingFrom && visible.to < display.showingTo)
      return;
    if (maybeUpdateLineNumberWidth(cm))
      changes = [{
          from: doc.first,
          to: doc.first + doc.size
        }];
    var gutterW = display.sizer.style.marginLeft = display.gutters.offsetWidth + 'px';
    display.scrollbarH.style.left = cm.options.fixedGutter ? gutterW : '0';
    var positionsChangedFrom = Infinity;
    if (cm.options.lineNumbers)
      for (var i = 0; i < changes.length; ++i)
        if (changes[i].diff) {
          positionsChangedFrom = changes[i].from;
          break;
        }
    var end = doc.first + doc.size;
    var from = Math.max(visible.from - cm.options.viewportMargin, doc.first);
    var to = Math.min(end, visible.to + cm.options.viewportMargin);
    if (display.showingFrom < from && from - display.showingFrom < 20)
      from = Math.max(doc.first, display.showingFrom);
    if (display.showingTo > to && display.showingTo - to < 20)
      to = Math.min(end, display.showingTo);
    if (sawCollapsedSpans) {
      from = lineNo(visualLine(doc, getLine(doc, from)));
      while (to < end && lineIsHidden(doc, getLine(doc, to)))
        ++to;
    }
    var intact = [{
          from: Math.max(display.showingFrom, doc.first),
          to: Math.min(display.showingTo, end)
        }];
    if (intact[0].from >= intact[0].to)
      intact = [];
    else
      intact = computeIntact(intact, changes);
    if (sawCollapsedSpans)
      for (var i = 0; i < intact.length; ++i) {
        var range = intact[i], merged;
        while (merged = collapsedSpanAtEnd(getLine(doc, range.to - 1))) {
          var newTo = merged.find().from.line;
          if (newTo > range.from)
            range.to = newTo;
          else {
            intact.splice(i--, 1);
            break;
          }
        }
      }
    var intactLines = 0;
    for (var i = 0; i < intact.length; ++i) {
      var range = intact[i];
      if (range.from < from)
        range.from = from;
      if (range.to > to)
        range.to = to;
      if (range.from >= range.to)
        intact.splice(i--, 1);
      else
        intactLines += range.to - range.from;
    }
    if (intactLines == to - from && from == display.showingFrom && to == display.showingTo) {
      updateViewOffset(cm);
      return;
    }
    intact.sort(function (a, b) {
      return a.from - b.from;
    });
    try {
      var focused = document.activeElement;
    } catch (e) {
    }
    if (intactLines < (to - from) * 0.7)
      display.lineDiv.style.display = 'none';
    patchDisplay(cm, from, to, intact, positionsChangedFrom);
    display.lineDiv.style.display = '';
    if (focused && document.activeElement != focused && focused.offsetHeight)
      focused.focus();
    var different = from != display.showingFrom || to != display.showingTo || display.lastSizeC != display.wrapper.clientHeight;
    if (different)
      display.lastSizeC = display.wrapper.clientHeight;
    display.showingFrom = from;
    display.showingTo = to;
    startWorker(cm, 100);
    var prevBottom = display.lineDiv.offsetTop;
    for (var node = display.lineDiv.firstChild, height; node; node = node.nextSibling)
      if (node.lineObj) {
        if (ie_lt8) {
          var bot = node.offsetTop + node.offsetHeight;
          height = bot - prevBottom;
          prevBottom = bot;
        } else {
          var box = getRect(node);
          height = box.bottom - box.top;
        }
        var diff = node.lineObj.height - height;
        if (height < 2)
          height = textHeight(display);
        if (diff > 0.001 || diff < -0.001) {
          updateLineHeight(node.lineObj, height);
          var widgets = node.lineObj.widgets;
          if (widgets)
            for (var i = 0; i < widgets.length; ++i)
              widgets[i].height = widgets[i].node.offsetHeight;
        }
      }
    updateViewOffset(cm);
    return true;
  }
  function updateViewOffset(cm) {
    var off = cm.display.viewOffset = heightAtLine(cm, getLine(cm.doc, cm.display.showingFrom));
    cm.display.mover.style.top = off + 'px';
  }
  function computeIntact(intact, changes) {
    for (var i = 0, l = changes.length || 0; i < l; ++i) {
      var change = changes[i], intact2 = [], diff = change.diff || 0;
      for (var j = 0, l2 = intact.length; j < l2; ++j) {
        var range = intact[j];
        if (change.to <= range.from && change.diff) {
          intact2.push({
            from: range.from + diff,
            to: range.to + diff
          });
        } else if (change.to <= range.from || change.from >= range.to) {
          intact2.push(range);
        } else {
          if (change.from > range.from)
            intact2.push({
              from: range.from,
              to: change.from
            });
          if (change.to < range.to)
            intact2.push({
              from: change.to + diff,
              to: range.to + diff
            });
        }
      }
      intact = intact2;
    }
    return intact;
  }
  function getDimensions(cm) {
    var d = cm.display, left = {}, width = {};
    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {
      left[cm.options.gutters[i]] = n.offsetLeft;
      width[cm.options.gutters[i]] = n.offsetWidth;
    }
    return {
      fixedPos: compensateForHScroll(d),
      gutterTotalWidth: d.gutters.offsetWidth,
      gutterLeft: left,
      gutterWidth: width,
      wrapperWidth: d.wrapper.clientWidth
    };
  }
  function patchDisplay(cm, from, to, intact, updateNumbersFrom) {
    var dims = getDimensions(cm);
    var display = cm.display, lineNumbers = cm.options.lineNumbers;
    if (!intact.length && (!webkit || !cm.display.currentWheelTarget))
      removeChildren(display.lineDiv);
    var container = display.lineDiv, cur = container.firstChild;
    function rm(node) {
      var next = node.nextSibling;
      if (webkit && mac && cm.display.currentWheelTarget == node) {
        node.style.display = 'none';
        node.lineObj = null;
      } else {
        node.parentNode.removeChild(node);
      }
      return next;
    }
    var nextIntact = intact.shift(), lineN = from;
    cm.doc.iter(from, to, function (line) {
      if (nextIntact && nextIntact.to == lineN)
        nextIntact = intact.shift();
      if (lineIsHidden(cm.doc, line)) {
        if (line.height != 0)
          updateLineHeight(line, 0);
        if (line.widgets && cur.previousSibling)
          for (var i = 0; i < line.widgets.length; ++i)
            if (line.widgets[i].showIfHidden) {
              var prev = cur.previousSibling;
              if (/pre/i.test(prev.nodeName)) {
                var wrap = elt('div', null, null, 'position: relative');
                prev.parentNode.replaceChild(wrap, prev);
                wrap.appendChild(prev);
                prev = wrap;
              }
              var wnode = prev.appendChild(elt('div', [line.widgets[i].node], 'CodeMirror-linewidget'));
              positionLineWidget(line.widgets[i], wnode, prev, dims);
            }
      } else if (nextIntact && nextIntact.from <= lineN && nextIntact.to > lineN) {
        while (cur.lineObj != line)
          cur = rm(cur);
        if (lineNumbers && updateNumbersFrom <= lineN && cur.lineNumber)
          setTextContent(cur.lineNumber, lineNumberFor(cm.options, lineN));
        cur = cur.nextSibling;
      } else {
        if (line.widgets)
          for (var j = 0, search = cur, reuse; search && j < 20; ++j, search = search.nextSibling)
            if (search.lineObj == line && /div/i.test(search.nodeName)) {
              reuse = search;
              break;
            }
        var lineNode = buildLineElement(cm, line, lineN, dims, reuse);
        if (lineNode != reuse) {
          container.insertBefore(lineNode, cur);
        } else {
          while (cur != reuse)
            cur = rm(cur);
          cur = cur.nextSibling;
        }
        lineNode.lineObj = line;
      }
      ++lineN;
    });
    while (cur)
      cur = rm(cur);
  }
  function buildLineElement(cm, line, lineNo, dims, reuse) {
    var lineElement = lineContent(cm, line);
    var markers = line.gutterMarkers, display = cm.display, wrap;
    if (!cm.options.lineNumbers && !markers && !line.bgClass && !line.wrapClass && !line.widgets)
      return lineElement;
    if (reuse) {
      reuse.alignable = null;
      var isOk = true, widgetsSeen = 0;
      for (var n = reuse.firstChild, next; n; n = next) {
        next = n.nextSibling;
        if (!/\bCodeMirror-linewidget\b/.test(n.className)) {
          reuse.removeChild(n);
        } else {
          for (var i = 0, first = true; i < line.widgets.length; ++i) {
            var widget = line.widgets[i], isFirst = false;
            if (!widget.above) {
              isFirst = first;
              first = false;
            }
            if (widget.node == n.firstChild) {
              positionLineWidget(widget, n, reuse, dims);
              ++widgetsSeen;
              if (isFirst)
                reuse.insertBefore(lineElement, n);
              break;
            }
          }
          if (i == line.widgets.length) {
            isOk = false;
            break;
          }
        }
      }
      if (isOk && widgetsSeen == line.widgets.length) {
        wrap = reuse;
        reuse.className = line.wrapClass || '';
      }
    }
    if (!wrap) {
      wrap = elt('div', null, line.wrapClass, 'position: relative');
      wrap.appendChild(lineElement);
    }
    if (line.bgClass)
      wrap.insertBefore(elt('div', null, line.bgClass + ' CodeMirror-linebackground'), wrap.firstChild);
    if (cm.options.lineNumbers || markers) {
      var gutterWrap = wrap.insertBefore(elt('div', null, null, 'position: absolute; left: ' + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + 'px'), wrap.firstChild);
      if (cm.options.fixedGutter)
        (wrap.alignable || (wrap.alignable = [])).push(gutterWrap);
      if (cm.options.lineNumbers && (!markers || !markers['CodeMirror-linenumbers']))
        wrap.lineNumber = gutterWrap.appendChild(elt('div', lineNumberFor(cm.options, lineNo), 'CodeMirror-linenumber CodeMirror-gutter-elt', 'left: ' + dims.gutterLeft['CodeMirror-linenumbers'] + 'px; width: ' + display.lineNumInnerWidth + 'px'));
      if (markers)
        for (var k = 0; k < cm.options.gutters.length; ++k) {
          var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];
          if (found)
            gutterWrap.appendChild(elt('div', [found], 'CodeMirror-gutter-elt', 'left: ' + dims.gutterLeft[id] + 'px; width: ' + dims.gutterWidth[id] + 'px'));
        }
    }
    if (ie_lt8)
      wrap.style.zIndex = 2;
    if (line.widgets && wrap != reuse)
      for (var i = 0, ws = line.widgets; i < ws.length; ++i) {
        var widget = ws[i], node = elt('div', [widget.node], 'CodeMirror-linewidget');
        positionLineWidget(widget, node, wrap, dims);
        if (widget.above)
          wrap.insertBefore(node, cm.options.lineNumbers && line.height != 0 ? gutterWrap : lineElement);
        else
          wrap.appendChild(node);
        signalLater(widget, 'redraw');
      }
    return wrap;
  }
  function positionLineWidget(widget, node, wrap, dims) {
    if (widget.noHScroll) {
      (wrap.alignable || (wrap.alignable = [])).push(node);
      var width = dims.wrapperWidth;
      node.style.left = dims.fixedPos + 'px';
      if (!widget.coverGutter) {
        width -= dims.gutterTotalWidth;
        node.style.paddingLeft = dims.gutterTotalWidth + 'px';
      }
      node.style.width = width + 'px';
    }
    if (widget.coverGutter) {
      node.style.zIndex = 5;
      node.style.position = 'relative';
      if (!widget.noHScroll)
        node.style.marginLeft = -dims.gutterTotalWidth + 'px';
    }
  }
  function updateSelection(cm) {
    var display = cm.display;
    var collapsed = posEq(cm.doc.sel.from, cm.doc.sel.to);
    if (collapsed || cm.options.showCursorWhenSelecting)
      updateSelectionCursor(cm);
    else
      display.cursor.style.display = display.otherCursor.style.display = 'none';
    if (!collapsed)
      updateSelectionRange(cm);
    else
      display.selectionDiv.style.display = 'none';
    if (cm.options.moveInputWithCursor) {
      var headPos = cursorCoords(cm, cm.doc.sel.head, 'div');
      var wrapOff = getRect(display.wrapper), lineOff = getRect(display.lineDiv);
      display.inputDiv.style.top = Math.max(0, Math.min(display.wrapper.clientHeight - 10, headPos.top + lineOff.top - wrapOff.top)) + 'px';
      display.inputDiv.style.left = Math.max(0, Math.min(display.wrapper.clientWidth - 10, headPos.left + lineOff.left - wrapOff.left)) + 'px';
    }
  }
  function updateSelectionCursor(cm) {
    var display = cm.display, pos = cursorCoords(cm, cm.doc.sel.head, 'div');
    display.cursor.style.left = pos.left + 'px';
    display.cursor.style.top = pos.top + 'px';
    display.cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + 'px';
    display.cursor.style.display = '';
    if (pos.other) {
      display.otherCursor.style.display = '';
      display.otherCursor.style.left = pos.other.left + 'px';
      display.otherCursor.style.top = pos.other.top + 'px';
      display.otherCursor.style.height = (pos.other.bottom - pos.other.top) * 0.85 + 'px';
    } else {
      display.otherCursor.style.display = 'none';
    }
  }
  function updateSelectionRange(cm) {
    var display = cm.display, doc = cm.doc, sel = cm.doc.sel;
    var fragment = document.createDocumentFragment();
    var clientWidth = display.lineSpace.offsetWidth, pl = paddingLeft(cm.display);
    function add(left, top, width, bottom) {
      if (top < 0)
        top = 0;
      fragment.appendChild(elt('div', null, 'CodeMirror-selected', 'position: absolute; left: ' + left + 'px; top: ' + top + 'px; width: ' + (width == null ? clientWidth - left : width) + 'px; height: ' + (bottom - top) + 'px'));
    }
    function drawForLine(line, fromArg, toArg, retTop) {
      var lineObj = getLine(doc, line);
      var lineLen = lineObj.text.length, rVal = retTop ? Infinity : -Infinity;
      function coords(ch) {
        return charCoords(cm, Pos(line, ch), 'div', lineObj);
      }
      iterateBidiSections(getOrder(lineObj), fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir) {
        var leftPos = coords(from), rightPos, left, right;
        if (from == to) {
          rightPos = leftPos;
          left = right = leftPos.left;
        } else {
          rightPos = coords(to - 1);
          if (dir == 'rtl') {
            var tmp = leftPos;
            leftPos = rightPos;
            rightPos = tmp;
          }
          left = leftPos.left;
          right = rightPos.right;
        }
        if (rightPos.top - leftPos.top > 3) {
          add(left, leftPos.top, null, leftPos.bottom);
          left = pl;
          if (leftPos.bottom < rightPos.top)
            add(left, leftPos.bottom, null, rightPos.top);
        }
        if (toArg == null && to == lineLen)
          right = clientWidth;
        if (fromArg == null && from == 0)
          left = pl;
        rVal = retTop ? Math.min(rightPos.top, rVal) : Math.max(rightPos.bottom, rVal);
        if (left < pl + 1)
          left = pl;
        add(left, rightPos.top, right - left, rightPos.bottom);
      });
      return rVal;
    }
    if (sel.from.line == sel.to.line) {
      drawForLine(sel.from.line, sel.from.ch, sel.to.ch);
    } else {
      var fromObj = getLine(doc, sel.from.line);
      var cur = fromObj, merged, path = [
          sel.from.line,
          sel.from.ch
        ], singleLine;
      while (merged = collapsedSpanAtEnd(cur)) {
        var found = merged.find();
        path.push(found.from.ch, found.to.line, found.to.ch);
        if (found.to.line == sel.to.line) {
          path.push(sel.to.ch);
          singleLine = true;
          break;
        }
        cur = getLine(doc, found.to.line);
      }
      if (singleLine) {
        for (var i = 0; i < path.length; i += 3)
          drawForLine(path[i], path[i + 1], path[i + 2]);
      } else {
        var middleTop, middleBot, toObj = getLine(doc, sel.to.line);
        if (sel.from.ch)
          middleTop = drawForLine(sel.from.line, sel.from.ch, null, false);
        else
          middleTop = heightAtLine(cm, fromObj) - display.viewOffset;
        if (!sel.to.ch)
          middleBot = heightAtLine(cm, toObj) - display.viewOffset;
        else
          middleBot = drawForLine(sel.to.line, collapsedSpanAtStart(toObj) ? null : 0, sel.to.ch, true);
        if (middleTop < middleBot)
          add(pl, middleTop, null, middleBot);
      }
    }
    removeChildrenAndAdd(display.selectionDiv, fragment);
    display.selectionDiv.style.display = '';
  }
  function restartBlink(cm) {
    if (!cm.state.focused)
      return;
    var display = cm.display;
    clearInterval(display.blinker);
    var on = true;
    display.cursor.style.visibility = display.otherCursor.style.visibility = '';
    display.blinker = setInterval(function () {
      display.cursor.style.visibility = display.otherCursor.style.visibility = (on = !on) ? '' : 'hidden';
    }, cm.options.cursorBlinkRate);
  }
  function startWorker(cm, time) {
    if (cm.doc.mode.startState && cm.doc.frontier < cm.display.showingTo)
      cm.state.highlight.set(time, bind(highlightWorker, cm));
  }
  function highlightWorker(cm) {
    var doc = cm.doc;
    if (doc.frontier < doc.first)
      doc.frontier = doc.first;
    if (doc.frontier >= cm.display.showingTo)
      return;
    var end = +new Date() + cm.options.workTime;
    var state = copyState(doc.mode, getStateBefore(cm, doc.frontier));
    var changed = [], prevChange;
    doc.iter(doc.frontier, Math.min(doc.first + doc.size, cm.display.showingTo + 500), function (line) {
      if (doc.frontier >= cm.display.showingFrom) {
        var oldStyles = line.styles;
        line.styles = highlightLine(cm, line, state);
        var ischange = !oldStyles || oldStyles.length != line.styles.length;
        for (var i = 0; !ischange && i < oldStyles.length; ++i)
          ischange = oldStyles[i] != line.styles[i];
        if (ischange) {
          if (prevChange && prevChange.end == doc.frontier)
            prevChange.end++;
          else
            changed.push(prevChange = {
              start: doc.frontier,
              end: doc.frontier + 1
            });
        }
        line.stateAfter = copyState(doc.mode, state);
      } else {
        processLine(cm, line, state);
        line.stateAfter = doc.frontier % 5 == 0 ? copyState(doc.mode, state) : null;
      }
      ++doc.frontier;
      if (+new Date() > end) {
        startWorker(cm, cm.options.workDelay);
        return true;
      }
    });
    if (changed.length)
      operation(cm, function () {
        for (var i = 0; i < changed.length; ++i)
          regChange(this, changed[i].start, changed[i].end);
      })();
  }
  function findStartLine(cm, n) {
    var minindent, minline, doc = cm.doc;
    for (var search = n, lim = n - 100; search > lim; --search) {
      if (search <= doc.first)
        return doc.first;
      var line = getLine(doc, search - 1);
      if (line.stateAfter)
        return search;
      var indented = countColumn(line.text, null, cm.options.tabSize);
      if (minline == null || minindent > indented) {
        minline = search - 1;
        minindent = indented;
      }
    }
    return minline;
  }
  function getStateBefore(cm, n) {
    var doc = cm.doc, display = cm.display;
    if (!doc.mode.startState)
      return true;
    var pos = findStartLine(cm, n), state = pos > doc.first && getLine(doc, pos - 1).stateAfter;
    if (!state)
      state = startState(doc.mode);
    else
      state = copyState(doc.mode, state);
    doc.iter(pos, n, function (line) {
      processLine(cm, line, state);
      var save = pos == n - 1 || pos % 5 == 0 || pos >= display.showingFrom && pos < display.showingTo;
      line.stateAfter = save ? copyState(doc.mode, state) : null;
      ++pos;
    });
    return state;
  }
  function paddingTop(display) {
    return display.lineSpace.offsetTop;
  }
  function paddingVert(display) {
    return display.mover.offsetHeight - display.lineSpace.offsetHeight;
  }
  function paddingLeft(display) {
    var e = removeChildrenAndAdd(display.measure, elt('pre', null, null, 'text-align: left')).appendChild(elt('span', 'x'));
    return e.offsetLeft;
  }
  function measureChar(cm, line, ch, data) {
    var dir = -1;
    data = data || measureLine(cm, line);
    for (var pos = ch;; pos += dir) {
      var r = data[pos];
      if (r)
        break;
      if (dir < 0 && pos == 0)
        dir = 1;
    }
    return {
      left: pos < ch ? r.right : r.left,
      right: pos > ch ? r.left : r.right,
      top: r.top,
      bottom: r.bottom
    };
  }
  function findCachedMeasurement(cm, line) {
    var cache = cm.display.measureLineCache;
    for (var i = 0; i < cache.length; ++i) {
      var memo = cache[i];
      if (memo.text == line.text && memo.markedSpans == line.markedSpans && cm.display.scroller.clientWidth == memo.width && memo.classes == line.textClass + '|' + line.bgClass + '|' + line.wrapClass)
        return memo.measure;
    }
  }
  function measureLine(cm, line) {
    var measure = findCachedMeasurement(cm, line);
    if (!measure) {
      measure = measureLineInner(cm, line);
      var cache = cm.display.measureLineCache;
      var memo = {
          text: line.text,
          width: cm.display.scroller.clientWidth,
          markedSpans: line.markedSpans,
          measure: measure,
          classes: line.textClass + '|' + line.bgClass + '|' + line.wrapClass
        };
      if (cache.length == 16)
        cache[++cm.display.measureLineCachePos % 16] = memo;
      else
        cache.push(memo);
    }
    return measure;
  }
  function measureLineInner(cm, line) {
    var display = cm.display, measure = emptyArray(line.text.length);
    var pre = lineContent(cm, line, measure);
    if (ie && !ie_lt8 && !cm.options.lineWrapping && pre.childNodes.length > 100) {
      var fragment = document.createDocumentFragment();
      var chunk = 10, n = pre.childNodes.length;
      for (var i = 0, chunks = Math.ceil(n / chunk); i < chunks; ++i) {
        var wrap = elt('div', null, null, 'display: inline-block');
        for (var j = 0; j < chunk && n; ++j) {
          wrap.appendChild(pre.firstChild);
          --n;
        }
        fragment.appendChild(wrap);
      }
      pre.appendChild(fragment);
    }
    removeChildrenAndAdd(display.measure, pre);
    var outer = getRect(display.lineDiv);
    var vranges = [], data = emptyArray(line.text.length), maxBot = pre.offsetHeight;
    if (ie_lt9 && display.measure.first != pre)
      removeChildrenAndAdd(display.measure, pre);
    for (var i = 0, cur; i < measure.length; ++i)
      if (cur = measure[i]) {
        var size = getRect(cur);
        var top = Math.max(0, size.top - outer.top), bot = Math.min(size.bottom - outer.top, maxBot);
        for (var j = 0; j < vranges.length; j += 2) {
          var rtop = vranges[j], rbot = vranges[j + 1];
          if (rtop > bot || rbot < top)
            continue;
          if (rtop <= top && rbot >= bot || top <= rtop && bot >= rbot || Math.min(bot, rbot) - Math.max(top, rtop) >= bot - top >> 1) {
            vranges[j] = Math.min(top, rtop);
            vranges[j + 1] = Math.max(bot, rbot);
            break;
          }
        }
        if (j == vranges.length)
          vranges.push(top, bot);
        var right = size.right;
        if (cur.measureRight)
          right = getRect(cur.measureRight).left;
        data[i] = {
          left: size.left - outer.left,
          right: right - outer.left,
          top: j
        };
      }
    for (var i = 0, cur; i < data.length; ++i)
      if (cur = data[i]) {
        var vr = cur.top;
        cur.top = vranges[vr];
        cur.bottom = vranges[vr + 1];
      }
    return data;
  }
  function measureLineWidth(cm, line) {
    var hasBadSpan = false;
    if (line.markedSpans)
      for (var i = 0; i < line.markedSpans; ++i) {
        var sp = line.markedSpans[i];
        if (sp.collapsed && (sp.to == null || sp.to == line.text.length))
          hasBadSpan = true;
      }
    var cached = !hasBadSpan && findCachedMeasurement(cm, line);
    if (cached)
      return measureChar(cm, line, line.text.length, cached).right;
    var pre = lineContent(cm, line);
    var end = pre.appendChild(zeroWidthElement(cm.display.measure));
    removeChildrenAndAdd(cm.display.measure, pre);
    return getRect(end).right - getRect(cm.display.lineDiv).left;
  }
  function clearCaches(cm) {
    cm.display.measureLineCache.length = cm.display.measureLineCachePos = 0;
    cm.display.cachedCharWidth = cm.display.cachedTextHeight = null;
    if (!cm.options.lineWrapping)
      cm.display.maxLineChanged = true;
    cm.display.lineNumChars = null;
  }
  function intoCoordSystem(cm, lineObj, rect, context) {
    if (lineObj.widgets)
      for (var i = 0; i < lineObj.widgets.length; ++i)
        if (lineObj.widgets[i].above) {
          var size = widgetHeight(lineObj.widgets[i]);
          rect.top += size;
          rect.bottom += size;
        }
    if (context == 'line')
      return rect;
    if (!context)
      context = 'local';
    var yOff = heightAtLine(cm, lineObj);
    if (context != 'local')
      yOff -= cm.display.viewOffset;
    if (context == 'page') {
      var lOff = getRect(cm.display.lineSpace);
      yOff += lOff.top + (window.pageYOffset || (document.documentElement || document.body).scrollTop);
      var xOff = lOff.left + (window.pageXOffset || (document.documentElement || document.body).scrollLeft);
      rect.left += xOff;
      rect.right += xOff;
    }
    rect.top += yOff;
    rect.bottom += yOff;
    return rect;
  }
  function fromCoordSystem(cm, coords, context) {
    if (context == 'div')
      return coords;
    var left = coords.left, top = coords.top;
    if (context == 'page') {
      left -= window.pageXOffset || (document.documentElement || document.body).scrollLeft;
      top -= window.pageYOffset || (document.documentElement || document.body).scrollTop;
    }
    var lineSpaceBox = getRect(cm.display.lineSpace);
    left -= lineSpaceBox.left;
    top -= lineSpaceBox.top;
    if (context == 'local' || !context) {
      var editorBox = getRect(cm.display.wrapper);
      left += editorBox.left;
      top += editorBox.top;
    }
    return {
      left: left,
      top: top
    };
  }
  function charCoords(cm, pos, context, lineObj) {
    if (!lineObj)
      lineObj = getLine(cm.doc, pos.line);
    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch), context);
  }
  function cursorCoords(cm, pos, context, lineObj, measurement) {
    lineObj = lineObj || getLine(cm.doc, pos.line);
    if (!measurement)
      measurement = measureLine(cm, lineObj);
    function get(ch, right) {
      var m = measureChar(cm, lineObj, ch, measurement);
      if (right)
        m.left = m.right;
      else
        m.right = m.left;
      return intoCoordSystem(cm, lineObj, m, context);
    }
    var order = getOrder(lineObj), ch = pos.ch;
    if (!order)
      return get(ch);
    var main, other, linedir = order[0].level;
    for (var i = 0; i < order.length; ++i) {
      var part = order[i], rtl = part.level % 2, nb, here;
      if (part.from < ch && part.to > ch)
        return get(ch, rtl);
      var left = rtl ? part.to : part.from, right = rtl ? part.from : part.to;
      if (left == ch) {
        if (i && part.level < (nb = order[i - 1]).level)
          here = get(nb.level % 2 ? nb.from : nb.to - 1, true);
        else
          here = get(rtl && part.from != part.to ? ch - 1 : ch);
        if (rtl == linedir)
          main = here;
        else
          other = here;
      } else if (right == ch) {
        var nb = i < order.length - 1 && order[i + 1];
        if (!rtl && nb && nb.from == nb.to)
          continue;
        if (nb && part.level < nb.level)
          here = get(nb.level % 2 ? nb.to - 1 : nb.from);
        else
          here = get(rtl ? ch : ch - 1, true);
        if (rtl == linedir)
          main = here;
        else
          other = here;
      }
    }
    if (linedir && !ch)
      other = get(order[0].to - 1);
    if (!main)
      return other;
    if (other)
      main.other = other;
    return main;
  }
  function PosMaybeOutside(line, ch, outside) {
    var pos = new Pos(line, ch);
    if (outside)
      pos.outside = true;
    return pos;
  }
  function coordsChar(cm, x, y) {
    var doc = cm.doc;
    y += cm.display.viewOffset;
    if (y < 0)
      return PosMaybeOutside(doc.first, 0, true);
    var lineNo = lineAtHeight(doc, y), last = doc.first + doc.size - 1;
    if (lineNo > last)
      return PosMaybeOutside(doc.first + doc.size - 1, getLine(doc, last).text.length, true);
    if (x < 0)
      x = 0;
    for (;;) {
      var lineObj = getLine(doc, lineNo);
      var found = coordsCharInner(cm, lineObj, lineNo, x, y);
      var merged = collapsedSpanAtEnd(lineObj);
      var mergedPos = merged && merged.find();
      if (merged && found.ch >= mergedPos.from.ch)
        lineNo = mergedPos.to.line;
      else
        return found;
    }
  }
  function coordsCharInner(cm, lineObj, lineNo, x, y) {
    var innerOff = y - heightAtLine(cm, lineObj);
    var wrongLine = false, adjust = 2 * cm.display.wrapper.clientWidth;
    var measurement = measureLine(cm, lineObj);
    function getX(ch) {
      var sp = cursorCoords(cm, Pos(lineNo, ch), 'line', lineObj, measurement);
      wrongLine = true;
      if (innerOff > sp.bottom)
        return sp.left - adjust;
      else if (innerOff < sp.top)
        return sp.left + adjust;
      else
        wrongLine = false;
      return sp.left;
    }
    var bidi = getOrder(lineObj), dist = lineObj.text.length;
    var from = lineLeft(lineObj), to = lineRight(lineObj);
    var fromX = getX(from), fromOutside = wrongLine, toX = getX(to), toOutside = wrongLine;
    if (x > toX)
      return PosMaybeOutside(lineNo, to, toOutside);
    for (;;) {
      if (bidi ? to == from || to == moveVisually(lineObj, from, 1) : to - from <= 1) {
        var after = x - fromX < toX - x, ch = after ? from : to;
        while (isExtendingChar.test(lineObj.text.charAt(ch)))
          ++ch;
        var pos = PosMaybeOutside(lineNo, ch, after ? fromOutside : toOutside);
        pos.after = after;
        return pos;
      }
      var step = Math.ceil(dist / 2), middle = from + step;
      if (bidi) {
        middle = from;
        for (var i = 0; i < step; ++i)
          middle = moveVisually(lineObj, middle, 1);
      }
      var middleX = getX(middle);
      if (middleX > x) {
        to = middle;
        toX = middleX;
        if (toOutside = wrongLine)
          toX += 1000;
        dist = step;
      } else {
        from = middle;
        fromX = middleX;
        fromOutside = wrongLine;
        dist -= step;
      }
    }
  }
  var measureText;
  function textHeight(display) {
    if (display.cachedTextHeight != null)
      return display.cachedTextHeight;
    if (measureText == null) {
      measureText = elt('pre');
      for (var i = 0; i < 49; ++i) {
        measureText.appendChild(document.createTextNode('x'));
        measureText.appendChild(elt('br'));
      }
      measureText.appendChild(document.createTextNode('x'));
    }
    removeChildrenAndAdd(display.measure, measureText);
    var height = measureText.offsetHeight / 50;
    if (height > 3)
      display.cachedTextHeight = height;
    removeChildren(display.measure);
    return height || 1;
  }
  function charWidth(display) {
    if (display.cachedCharWidth != null)
      return display.cachedCharWidth;
    var anchor = elt('span', 'x');
    var pre = elt('pre', [anchor]);
    removeChildrenAndAdd(display.measure, pre);
    var width = anchor.offsetWidth;
    if (width > 2)
      display.cachedCharWidth = width;
    return width || 10;
  }
  var nextOpId = 0;
  function startOperation(cm) {
    cm.curOp = {
      changes: [],
      updateInput: null,
      userSelChange: null,
      textChanged: null,
      selectionChanged: false,
      cursorActivity: false,
      updateMaxLine: false,
      updateScrollPos: false,
      id: ++nextOpId
    };
    if (!delayedCallbackDepth++)
      delayedCallbacks = [];
  }
  function endOperation(cm) {
    var op = cm.curOp, doc = cm.doc, display = cm.display;
    cm.curOp = null;
    if (op.updateMaxLine)
      computeMaxLength(cm);
    if (display.maxLineChanged && !cm.options.lineWrapping && display.maxLine) {
      var width = measureLineWidth(cm, display.maxLine);
      display.sizer.style.minWidth = Math.max(0, width + 3 + scrollerCutOff) + 'px';
      display.maxLineChanged = false;
      var maxScrollLeft = Math.max(0, display.sizer.offsetLeft + display.sizer.offsetWidth - display.scroller.clientWidth);
      if (maxScrollLeft < doc.scrollLeft && !op.updateScrollPos)
        setScrollLeft(cm, Math.min(display.scroller.scrollLeft, maxScrollLeft), true);
    }
    var newScrollPos, updated;
    if (op.updateScrollPos) {
      newScrollPos = op.updateScrollPos;
    } else if (op.selectionChanged && display.scroller.clientHeight) {
      var coords = cursorCoords(cm, doc.sel.head);
      newScrollPos = calculateScrollPos(cm, coords.left, coords.top, coords.left, coords.bottom);
    }
    if (op.changes.length || newScrollPos && newScrollPos.scrollTop != null) {
      updated = updateDisplay(cm, op.changes, newScrollPos && newScrollPos.scrollTop);
      if (cm.display.scroller.offsetHeight)
        cm.doc.scrollTop = cm.display.scroller.scrollTop;
    }
    if (!updated && op.selectionChanged)
      updateSelection(cm);
    if (op.updateScrollPos) {
      display.scroller.scrollTop = display.scrollbarV.scrollTop = doc.scrollTop = newScrollPos.scrollTop;
      display.scroller.scrollLeft = display.scrollbarH.scrollLeft = doc.scrollLeft = newScrollPos.scrollLeft;
      alignHorizontally(cm);
      if (op.scrollToPos)
        scrollPosIntoView(cm, clipPos(cm.doc, op.scrollToPos), op.scrollToPosMargin);
    } else if (newScrollPos) {
      scrollCursorIntoView(cm);
    }
    if (op.selectionChanged)
      restartBlink(cm);
    if (cm.state.focused && op.updateInput)
      resetInput(cm, op.userSelChange);
    var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;
    if (hidden)
      for (var i = 0; i < hidden.length; ++i)
        if (!hidden[i].lines.length)
          signal(hidden[i], 'hide');
    if (unhidden)
      for (var i = 0; i < unhidden.length; ++i)
        if (unhidden[i].lines.length)
          signal(unhidden[i], 'unhide');
    var delayed;
    if (!--delayedCallbackDepth) {
      delayed = delayedCallbacks;
      delayedCallbacks = null;
    }
    if (op.textChanged)
      signal(cm, 'change', cm, op.textChanged);
    if (op.cursorActivity)
      signal(cm, 'cursorActivity', cm);
    if (delayed)
      for (var i = 0; i < delayed.length; ++i)
        delayed[i]();
  }
  function operation(cm1, f) {
    return function () {
      var cm = cm1 || this, withOp = !cm.curOp;
      if (withOp)
        startOperation(cm);
      try {
        var result = f.apply(cm, arguments);
      } finally {
        if (withOp)
          endOperation(cm);
      }
      return result;
    };
  }
  function docOperation(f) {
    return function () {
      var withOp = this.cm && !this.cm.curOp, result;
      if (withOp)
        startOperation(this.cm);
      try {
        result = f.apply(this, arguments);
      } finally {
        if (withOp)
          endOperation(this.cm);
      }
      return result;
    };
  }
  function runInOp(cm, f) {
    var withOp = !cm.curOp, result;
    if (withOp)
      startOperation(cm);
    try {
      result = f();
    } finally {
      if (withOp)
        endOperation(cm);
    }
    return result;
  }
  function regChange(cm, from, to, lendiff) {
    if (from == null)
      from = cm.doc.first;
    if (to == null)
      to = cm.doc.first + cm.doc.size;
    cm.curOp.changes.push({
      from: from,
      to: to,
      diff: lendiff
    });
  }
  function slowPoll(cm) {
    if (cm.display.pollingFast)
      return;
    cm.display.poll.set(cm.options.pollInterval, function () {
      readInput(cm);
      if (cm.state.focused)
        slowPoll(cm);
    });
  }
  function fastPoll(cm) {
    var missed = false;
    cm.display.pollingFast = true;
    function p() {
      var changed = readInput(cm);
      if (!changed && !missed) {
        missed = true;
        cm.display.poll.set(60, p);
      } else {
        cm.display.pollingFast = false;
        slowPoll(cm);
      }
    }
    cm.display.poll.set(20, p);
  }
  function readInput(cm) {
    var input = cm.display.input, prevInput = cm.display.prevInput, doc = cm.doc, sel = doc.sel;
    if (!cm.state.focused || hasSelection(input) || isReadOnly(cm))
      return false;
    var text = input.value;
    if (text == prevInput && posEq(sel.from, sel.to))
      return false;
    if (ie && !ie_lt9 && cm.display.inputHasSelection === text) {
      resetInput(cm, true);
      return false;
    }
    var withOp = !cm.curOp;
    if (withOp)
      startOperation(cm);
    sel.shift = false;
    var same = 0, l = Math.min(prevInput.length, text.length);
    while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same))
      ++same;
    var from = sel.from, to = sel.to;
    if (same < prevInput.length)
      from = Pos(from.line, from.ch - (prevInput.length - same));
    else if (cm.state.overwrite && posEq(from, to) && !cm.state.pasteIncoming)
      to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + (text.length - same)));
    var updateInput = cm.curOp.updateInput;
    makeChange(cm.doc, {
      from: from,
      to: to,
      text: splitLines(text.slice(same)),
      origin: cm.state.pasteIncoming ? 'paste' : '+input'
    }, 'end');
    cm.curOp.updateInput = updateInput;
    if (text.length > 1000 || text.indexOf('\n') > -1)
      input.value = cm.display.prevInput = '';
    else
      cm.display.prevInput = text;
    if (withOp)
      endOperation(cm);
    cm.state.pasteIncoming = false;
    return true;
  }
  function resetInput(cm, user) {
    var minimal, selected, doc = cm.doc;
    if (!posEq(doc.sel.from, doc.sel.to)) {
      cm.display.prevInput = '';
      minimal = hasCopyEvent && (doc.sel.to.line - doc.sel.from.line > 100 || (selected = cm.getSelection()).length > 1000);
      var content = minimal ? '-' : selected || cm.getSelection();
      cm.display.input.value = content;
      if (cm.state.focused)
        selectInput(cm.display.input);
      if (ie && !ie_lt9)
        cm.display.inputHasSelection = content;
    } else if (user) {
      cm.display.prevInput = cm.display.input.value = '';
      if (ie && !ie_lt9)
        cm.display.inputHasSelection = null;
    }
    cm.display.inaccurateSelection = minimal;
  }
  function focusInput(cm) {
    if (cm.options.readOnly != 'nocursor' && (!mobile || document.activeElement != cm.display.input))
      cm.display.input.focus();
  }
  function isReadOnly(cm) {
    return cm.options.readOnly || cm.doc.cantEdit;
  }
  function registerEventHandlers(cm) {
    var d = cm.display;
    on(d.scroller, 'mousedown', operation(cm, onMouseDown));
    if (ie)
      on(d.scroller, 'dblclick', operation(cm, function (e) {
        var pos = posFromMouse(cm, e);
        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e))
          return;
        e_preventDefault(e);
        var word = findWordAt(getLine(cm.doc, pos.line).text, pos);
        extendSelection(cm.doc, word.from, word.to);
      }));
    else
      on(d.scroller, 'dblclick', e_preventDefault);
    on(d.lineSpace, 'selectstart', function (e) {
      if (!eventInWidget(d, e))
        e_preventDefault(e);
    });
    if (!captureMiddleClick)
      on(d.scroller, 'contextmenu', function (e) {
        onContextMenu(cm, e);
      });
    on(d.scroller, 'scroll', function () {
      if (d.scroller.clientHeight) {
        setScrollTop(cm, d.scroller.scrollTop);
        setScrollLeft(cm, d.scroller.scrollLeft, true);
        signal(cm, 'scroll', cm);
      }
    });
    on(d.scrollbarV, 'scroll', function () {
      if (d.scroller.clientHeight)
        setScrollTop(cm, d.scrollbarV.scrollTop);
    });
    on(d.scrollbarH, 'scroll', function () {
      if (d.scroller.clientHeight)
        setScrollLeft(cm, d.scrollbarH.scrollLeft);
    });
    on(d.scroller, 'mousewheel', function (e) {
      onScrollWheel(cm, e);
    });
    on(d.scroller, 'DOMMouseScroll', function (e) {
      onScrollWheel(cm, e);
    });
    function reFocus() {
      if (cm.state.focused)
        setTimeout(bind(focusInput, cm), 0);
    }
    on(d.scrollbarH, 'mousedown', reFocus);
    on(d.scrollbarV, 'mousedown', reFocus);
    on(d.wrapper, 'scroll', function () {
      d.wrapper.scrollTop = d.wrapper.scrollLeft = 0;
    });
    function onResize() {
      d.cachedCharWidth = d.cachedTextHeight = null;
      clearCaches(cm);
      runInOp(cm, bind(regChange, cm));
    }
    on(window, 'resize', onResize);
    function unregister() {
      for (var p = d.wrapper.parentNode; p && p != document.body; p = p.parentNode) {
      }
      if (p)
        setTimeout(unregister, 5000);
      else
        off(window, 'resize', onResize);
    }
    setTimeout(unregister, 5000);
    on(d.input, 'keyup', operation(cm, function (e) {
      if (cm.options.onKeyEvent && cm.options.onKeyEvent(cm, addStop(e)))
        return;
      if (e.keyCode == 16)
        cm.doc.sel.shift = false;
    }));
    on(d.input, 'input', bind(fastPoll, cm));
    on(d.input, 'keydown', operation(cm, onKeyDown));
    on(d.input, 'keypress', operation(cm, onKeyPress));
    on(d.input, 'focus', bind(onFocus, cm));
    on(d.input, 'blur', bind(onBlur, cm));
    function drag_(e) {
      if (cm.options.onDragEvent && cm.options.onDragEvent(cm, addStop(e)))
        return;
      e_stop(e);
    }
    if (cm.options.dragDrop) {
      on(d.scroller, 'dragstart', function (e) {
        onDragStart(cm, e);
      });
      on(d.scroller, 'dragenter', drag_);
      on(d.scroller, 'dragover', drag_);
      on(d.scroller, 'drop', operation(cm, onDrop));
    }
    on(d.scroller, 'paste', function (e) {
      if (eventInWidget(d, e))
        return;
      focusInput(cm);
      fastPoll(cm);
    });
    on(d.input, 'paste', function () {
      cm.state.pasteIncoming = true;
      fastPoll(cm);
    });
    function prepareCopy() {
      if (d.inaccurateSelection) {
        d.prevInput = '';
        d.inaccurateSelection = false;
        d.input.value = cm.getSelection();
        selectInput(d.input);
      }
    }
    on(d.input, 'cut', prepareCopy);
    on(d.input, 'copy', prepareCopy);
    if (khtml)
      on(d.sizer, 'mouseup', function () {
        if (document.activeElement == d.input)
          d.input.blur();
        focusInput(cm);
      });
  }
  function eventInWidget(display, e) {
    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {
      if (!n)
        return true;
      if (/\bCodeMirror-(?:line)?widget\b/.test(n.className) || n.parentNode == display.sizer && n != display.mover)
        return true;
    }
  }
  function posFromMouse(cm, e, liberal) {
    var display = cm.display;
    if (!liberal) {
      var target = e_target(e);
      if (target == display.scrollbarH || target == display.scrollbarH.firstChild || target == display.scrollbarV || target == display.scrollbarV.firstChild || target == display.scrollbarFiller)
        return null;
    }
    var x, y, space = getRect(display.lineSpace);
    try {
      x = e.clientX;
      y = e.clientY;
    } catch (e) {
      return null;
    }
    return coordsChar(cm, x - space.left, y - space.top);
  }
  var lastClick, lastDoubleClick;
  function onMouseDown(e) {
    var cm = this, display = cm.display, doc = cm.doc, sel = doc.sel;
    sel.shift = e.shiftKey;
    if (eventInWidget(display, e)) {
      if (!webkit) {
        display.scroller.draggable = false;
        setTimeout(function () {
          display.scroller.draggable = true;
        }, 100);
      }
      return;
    }
    if (clickInGutter(cm, e))
      return;
    var start = posFromMouse(cm, e);
    switch (e_button(e)) {
    case 3:
      if (captureMiddleClick)
        onContextMenu.call(cm, cm, e);
      return;
    case 2:
      if (start)
        extendSelection(cm.doc, start);
      setTimeout(bind(focusInput, cm), 20);
      e_preventDefault(e);
      return;
    }
    if (!start) {
      if (e_target(e) == display.scroller)
        e_preventDefault(e);
      return;
    }
    if (!cm.state.focused)
      onFocus(cm);
    var now = +new Date(), type = 'single';
    if (lastDoubleClick && lastDoubleClick.time > now - 400 && posEq(lastDoubleClick.pos, start)) {
      type = 'triple';
      e_preventDefault(e);
      setTimeout(bind(focusInput, cm), 20);
      selectLine(cm, start.line);
    } else if (lastClick && lastClick.time > now - 400 && posEq(lastClick.pos, start)) {
      type = 'double';
      lastDoubleClick = {
        time: now,
        pos: start
      };
      e_preventDefault(e);
      var word = findWordAt(getLine(doc, start.line).text, start);
      extendSelection(cm.doc, word.from, word.to);
    } else {
      lastClick = {
        time: now,
        pos: start
      };
    }
    var last = start;
    if (cm.options.dragDrop && dragAndDrop && !isReadOnly(cm) && !posEq(sel.from, sel.to) && !posLess(start, sel.from) && !posLess(sel.to, start) && type == 'single') {
      var dragEnd = operation(cm, function (e2) {
          if (webkit)
            display.scroller.draggable = false;
          cm.state.draggingText = false;
          off(document, 'mouseup', dragEnd);
          off(display.scroller, 'drop', dragEnd);
          if (Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) < 10) {
            e_preventDefault(e2);
            extendSelection(cm.doc, start);
            focusInput(cm);
          }
        });
      if (webkit)
        display.scroller.draggable = true;
      cm.state.draggingText = dragEnd;
      if (display.scroller.dragDrop)
        display.scroller.dragDrop();
      on(document, 'mouseup', dragEnd);
      on(display.scroller, 'drop', dragEnd);
      return;
    }
    e_preventDefault(e);
    if (type == 'single')
      extendSelection(cm.doc, clipPos(doc, start));
    var startstart = sel.from, startend = sel.to, lastPos = start;
    function doSelect(cur) {
      if (posEq(lastPos, cur))
        return;
      lastPos = cur;
      if (type == 'single') {
        extendSelection(cm.doc, clipPos(doc, start), cur);
        return;
      }
      startstart = clipPos(doc, startstart);
      startend = clipPos(doc, startend);
      if (type == 'double') {
        var word = findWordAt(getLine(doc, cur.line).text, cur);
        if (posLess(cur, startstart))
          extendSelection(cm.doc, word.from, startend);
        else
          extendSelection(cm.doc, startstart, word.to);
      } else if (type == 'triple') {
        if (posLess(cur, startstart))
          extendSelection(cm.doc, startend, clipPos(doc, Pos(cur.line, 0)));
        else
          extendSelection(cm.doc, startstart, clipPos(doc, Pos(cur.line + 1, 0)));
      }
    }
    var editorSize = getRect(display.wrapper);
    var counter = 0;
    function extend(e) {
      var curCount = ++counter;
      var cur = posFromMouse(cm, e, true);
      if (!cur)
        return;
      if (!posEq(cur, last)) {
        if (!cm.state.focused)
          onFocus(cm);
        last = cur;
        doSelect(cur);
        var visible = visibleLines(display, doc);
        if (cur.line >= visible.to || cur.line < visible.from)
          setTimeout(operation(cm, function () {
            if (counter == curCount)
              extend(e);
          }), 150);
      } else {
        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
        if (outside)
          setTimeout(operation(cm, function () {
            if (counter != curCount)
              return;
            display.scroller.scrollTop += outside;
            extend(e);
          }), 50);
      }
    }
    function done(e) {
      counter = Infinity;
      var cur = posFromMouse(cm, e);
      if (cur)
        doSelect(cur);
      e_preventDefault(e);
      focusInput(cm);
      off(document, 'mousemove', move);
      off(document, 'mouseup', up);
    }
    var move = operation(cm, function (e) {
        if (!ie && !e_button(e))
          done(e);
        else
          extend(e);
      });
    var up = operation(cm, done);
    on(document, 'mousemove', move);
    on(document, 'mouseup', up);
  }
  function onDrop(e) {
    var cm = this;
    if (eventInWidget(cm.display, e) || cm.options.onDragEvent && cm.options.onDragEvent(cm, addStop(e)))
      return;
    e_preventDefault(e);
    var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;
    if (!pos || isReadOnly(cm))
      return;
    if (files && files.length && window.FileReader && window.File) {
      var n = files.length, text = Array(n), read = 0;
      var loadFile = function (file, i) {
        var reader = new FileReader();
        reader.onload = function () {
          text[i] = reader.result;
          if (++read == n) {
            pos = clipPos(cm.doc, pos);
            makeChange(cm.doc, {
              from: pos,
              to: pos,
              text: splitLines(text.join('\n')),
              origin: 'paste'
            }, 'around');
          }
        };
        reader.readAsText(file);
      };
      for (var i = 0; i < n; ++i)
        loadFile(files[i], i);
    } else {
      if (cm.state.draggingText && !(posLess(pos, cm.doc.sel.from) || posLess(cm.doc.sel.to, pos))) {
        cm.state.draggingText(e);
        setTimeout(bind(focusInput, cm), 20);
        return;
      }
      try {
        var text = e.dataTransfer.getData('Text');
        if (text) {
          var curFrom = cm.doc.sel.from, curTo = cm.doc.sel.to;
          setSelection(cm.doc, pos, pos);
          if (cm.state.draggingText)
            replaceRange(cm.doc, '', curFrom, curTo, 'paste');
          cm.replaceSelection(text, null, 'paste');
          focusInput(cm);
          onFocus(cm);
        }
      } catch (e) {
      }
    }
  }
  function clickInGutter(cm, e) {
    var display = cm.display;
    try {
      var mX = e.clientX, mY = e.clientY;
    } catch (e) {
      return false;
    }
    if (mX >= Math.floor(getRect(display.gutters).right))
      return false;
    e_preventDefault(e);
    if (!hasHandler(cm, 'gutterClick'))
      return true;
    var lineBox = getRect(display.lineDiv);
    if (mY > lineBox.bottom)
      return true;
    mY -= lineBox.top - display.viewOffset;
    for (var i = 0; i < cm.options.gutters.length; ++i) {
      var g = display.gutters.childNodes[i];
      if (g && getRect(g).right >= mX) {
        var line = lineAtHeight(cm.doc, mY);
        var gutter = cm.options.gutters[i];
        signalLater(cm, 'gutterClick', cm, line, gutter, e);
        break;
      }
    }
    return true;
  }
  function onDragStart(cm, e) {
    if (ie && !cm.state.draggingText) {
      e_stop(e);
      return;
    }
    if (eventInWidget(cm.display, e))
      return;
    var txt = cm.getSelection();
    e.dataTransfer.setData('Text', txt);
    if (e.dataTransfer.setDragImage) {
      var img = elt('img', null, null, 'position: fixed; left: 0; top: 0;');
      if (opera) {
        img.width = img.height = 1;
        cm.display.wrapper.appendChild(img);
        img._top = img.offsetTop;
      }
      if (safari) {
        if (cm.display.dragImg) {
          img = cm.display.dragImg;
        } else {
          cm.display.dragImg = img;
          img.src = 'data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==';
          cm.display.wrapper.appendChild(img);
        }
      }
      e.dataTransfer.setDragImage(img, 0, 0);
      if (opera)
        img.parentNode.removeChild(img);
    }
  }
  function setScrollTop(cm, val) {
    if (Math.abs(cm.doc.scrollTop - val) < 2)
      return;
    cm.doc.scrollTop = val;
    if (!gecko)
      updateDisplay(cm, [], val);
    if (cm.display.scroller.scrollTop != val)
      cm.display.scroller.scrollTop = val;
    if (cm.display.scrollbarV.scrollTop != val)
      cm.display.scrollbarV.scrollTop = val;
    if (gecko)
      updateDisplay(cm, []);
  }
  function setScrollLeft(cm, val, isScroller) {
    if (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2)
      return;
    val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);
    cm.doc.scrollLeft = val;
    alignHorizontally(cm);
    if (cm.display.scroller.scrollLeft != val)
      cm.display.scroller.scrollLeft = val;
    if (cm.display.scrollbarH.scrollLeft != val)
      cm.display.scrollbarH.scrollLeft = val;
  }
  var wheelSamples = 0, wheelPixelsPerUnit = null;
  if (ie)
    wheelPixelsPerUnit = -0.53;
  else if (gecko)
    wheelPixelsPerUnit = 15;
  else if (chrome)
    wheelPixelsPerUnit = -0.7;
  else if (safari)
    wheelPixelsPerUnit = -1 / 3;
  function onScrollWheel(cm, e) {
    var dx = e.wheelDeltaX, dy = e.wheelDeltaY;
    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS)
      dx = e.detail;
    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS)
      dy = e.detail;
    else if (dy == null)
      dy = e.wheelDelta;
    var display = cm.display, scroll = display.scroller;
    if (!(dx && scroll.scrollWidth > scroll.clientWidth || dy && scroll.scrollHeight > scroll.clientHeight))
      return;
    if (dy && mac && webkit) {
      for (var cur = e.target; cur != scroll; cur = cur.parentNode) {
        if (cur.lineObj) {
          cm.display.currentWheelTarget = cur;
          break;
        }
      }
    }
    if (dx && !gecko && !opera && wheelPixelsPerUnit != null) {
      if (dy)
        setScrollTop(cm, Math.max(0, Math.min(scroll.scrollTop + dy * wheelPixelsPerUnit, scroll.scrollHeight - scroll.clientHeight)));
      setScrollLeft(cm, Math.max(0, Math.min(scroll.scrollLeft + dx * wheelPixelsPerUnit, scroll.scrollWidth - scroll.clientWidth)));
      e_preventDefault(e);
      display.wheelStartX = null;
      return;
    }
    if (dy && wheelPixelsPerUnit != null) {
      var pixels = dy * wheelPixelsPerUnit;
      var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;
      if (pixels < 0)
        top = Math.max(0, top + pixels - 50);
      else
        bot = Math.min(cm.doc.height, bot + pixels + 50);
      updateDisplay(cm, [], {
        top: top,
        bottom: bot
      });
    }
    if (wheelSamples < 20) {
      if (display.wheelStartX == null) {
        display.wheelStartX = scroll.scrollLeft;
        display.wheelStartY = scroll.scrollTop;
        display.wheelDX = dx;
        display.wheelDY = dy;
        setTimeout(function () {
          if (display.wheelStartX == null)
            return;
          var movedX = scroll.scrollLeft - display.wheelStartX;
          var movedY = scroll.scrollTop - display.wheelStartY;
          var sample = movedY && display.wheelDY && movedY / display.wheelDY || movedX && display.wheelDX && movedX / display.wheelDX;
          display.wheelStartX = display.wheelStartY = null;
          if (!sample)
            return;
          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
          ++wheelSamples;
        }, 200);
      } else {
        display.wheelDX += dx;
        display.wheelDY += dy;
      }
    }
  }
  function doHandleBinding(cm, bound, dropShift) {
    if (typeof bound == 'string') {
      bound = commands[bound];
      if (!bound)
        return false;
    }
    if (cm.display.pollingFast && readInput(cm))
      cm.display.pollingFast = false;
    var doc = cm.doc, prevShift = doc.sel.shift, done = false;
    try {
      if (isReadOnly(cm))
        cm.state.suppressEdits = true;
      if (dropShift)
        doc.sel.shift = false;
      done = bound(cm) != Pass;
    } finally {
      doc.sel.shift = prevShift;
      cm.state.suppressEdits = false;
    }
    return done;
  }
  function allKeyMaps(cm) {
    var maps = cm.state.keyMaps.slice(0);
    if (cm.options.extraKeys)
      maps.push(cm.options.extraKeys);
    maps.push(cm.options.keyMap);
    return maps;
  }
  var maybeTransition;
  function handleKeyBinding(cm, e) {
    var startMap = getKeyMap(cm.options.keyMap), next = startMap.auto;
    clearTimeout(maybeTransition);
    if (next && !isModifierKey(e))
      maybeTransition = setTimeout(function () {
        if (getKeyMap(cm.options.keyMap) == startMap)
          cm.options.keyMap = next.call ? next.call(null, cm) : next;
      }, 50);
    var name = keyName(e, true), handled = false;
    if (!name)
      return false;
    var keymaps = allKeyMaps(cm);
    if (e.shiftKey) {
      handled = lookupKey('Shift-' + name, keymaps, function (b) {
        return doHandleBinding(cm, b, true);
      }) || lookupKey(name, keymaps, function (b) {
        if (typeof b == 'string' && /^go[A-Z]/.test(b))
          return doHandleBinding(cm, b);
      });
    } else {
      handled = lookupKey(name, keymaps, function (b) {
        return doHandleBinding(cm, b);
      });
    }
    if (handled == 'stop')
      handled = false;
    if (handled) {
      e_preventDefault(e);
      restartBlink(cm);
      if (ie_lt9) {
        e.oldKeyCode = e.keyCode;
        e.keyCode = 0;
      }
    }
    return handled;
  }
  function handleCharBinding(cm, e, ch) {
    var handled = lookupKey('\'' + ch + '\'', allKeyMaps(cm), function (b) {
        return doHandleBinding(cm, b, true);
      });
    if (handled) {
      e_preventDefault(e);
      restartBlink(cm);
    }
    return handled;
  }
  var lastStoppedKey = null;
  function onKeyDown(e) {
    var cm = this;
    if (!cm.state.focused)
      onFocus(cm);
    if (ie && e.keyCode == 27) {
      e.returnValue = false;
    }
    if (cm.options.onKeyEvent && cm.options.onKeyEvent(cm, addStop(e)))
      return;
    var code = e.keyCode;
    cm.doc.sel.shift = code == 16 || e.shiftKey;
    var handled = handleKeyBinding(cm, e);
    if (opera) {
      lastStoppedKey = handled ? code : null;
      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))
        cm.replaceSelection('');
    }
  }
  function onKeyPress(e) {
    var cm = this;
    if (cm.options.onKeyEvent && cm.options.onKeyEvent(cm, addStop(e)))
      return;
    var keyCode = e.keyCode, charCode = e.charCode;
    if (opera && keyCode == lastStoppedKey) {
      lastStoppedKey = null;
      e_preventDefault(e);
      return;
    }
    if ((opera && (!e.which || e.which < 10) || khtml) && handleKeyBinding(cm, e))
      return;
    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);
    if (this.options.electricChars && this.doc.mode.electricChars && this.options.smartIndent && !isReadOnly(this) && this.doc.mode.electricChars.indexOf(ch) > -1)
      setTimeout(operation(cm, function () {
        indentLine(cm, cm.doc.sel.to.line, 'smart');
      }), 75);
    if (handleCharBinding(cm, e, ch))
      return;
    if (ie && !ie_lt9)
      cm.display.inputHasSelection = null;
    fastPoll(cm);
  }
  function onFocus(cm) {
    if (cm.options.readOnly == 'nocursor')
      return;
    if (!cm.state.focused) {
      signal(cm, 'focus', cm);
      cm.state.focused = true;
      if (cm.display.wrapper.className.search(/\bCodeMirror-focused\b/) == -1)
        cm.display.wrapper.className += ' CodeMirror-focused';
      resetInput(cm, true);
    }
    slowPoll(cm);
    restartBlink(cm);
  }
  function onBlur(cm) {
    if (cm.state.focused) {
      signal(cm, 'blur', cm);
      cm.state.focused = false;
      cm.display.wrapper.className = cm.display.wrapper.className.replace(' CodeMirror-focused', '');
    }
    clearInterval(cm.display.blinker);
    setTimeout(function () {
      if (!cm.state.focused)
        cm.doc.sel.shift = false;
    }, 150);
  }
  var detectingSelectAll;
  function onContextMenu(cm, e) {
    var display = cm.display, sel = cm.doc.sel;
    if (eventInWidget(display, e))
      return;
    var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;
    if (!pos || opera)
      return;
    if (posEq(sel.from, sel.to) || posLess(pos, sel.from) || !posLess(pos, sel.to))
      operation(cm, setSelection)(cm.doc, pos, pos);
    var oldCSS = display.input.style.cssText;
    display.inputDiv.style.position = 'absolute';
    display.input.style.cssText = 'position: fixed; width: 30px; height: 30px; top: ' + (e.clientY - 5) + 'px; left: ' + (e.clientX - 5) + 'px; z-index: 1000; background: white; outline: none;' + 'border-width: 0; outline: none; overflow: hidden; opacity: .05; -ms-opacity: .05; filter: alpha(opacity=5);';
    focusInput(cm);
    resetInput(cm, true);
    if (posEq(sel.from, sel.to))
      display.input.value = display.prevInput = ' ';
    function rehide() {
      display.inputDiv.style.position = 'relative';
      display.input.style.cssText = oldCSS;
      if (ie_lt9)
        display.scrollbarV.scrollTop = display.scroller.scrollTop = scrollPos;
      slowPoll(cm);
      if (display.input.selectionStart != null && (!ie || ie_lt9)) {
        clearTimeout(detectingSelectAll);
        var extval = display.input.value = ' ' + (posEq(sel.from, sel.to) ? '' : display.input.value), i = 0;
        display.prevInput = ' ';
        display.input.selectionStart = 1;
        display.input.selectionEnd = extval.length;
        var poll = function () {
          if (display.prevInput == ' ' && display.input.selectionStart == 0)
            operation(cm, commands.selectAll)(cm);
          else if (i++ < 10)
            detectingSelectAll = setTimeout(poll, 500);
          else
            resetInput(cm);
        };
        detectingSelectAll = setTimeout(poll, 200);
      }
    }
    if (captureMiddleClick) {
      e_stop(e);
      var mouseup = function () {
        off(window, 'mouseup', mouseup);
        setTimeout(rehide, 20);
      };
      on(window, 'mouseup', mouseup);
    } else {
      setTimeout(rehide, 50);
    }
  }
  function changeEnd(change) {
    if (!change.text)
      return change.to;
    return Pos(change.from.line + change.text.length - 1, lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));
  }
  function clipPostChange(doc, change, pos) {
    if (!posLess(change.from, pos))
      return clipPos(doc, pos);
    var diff = change.text.length - 1 - (change.to.line - change.from.line);
    if (pos.line > change.to.line + diff) {
      var preLine = pos.line - diff, lastLine = doc.first + doc.size - 1;
      if (preLine > lastLine)
        return Pos(lastLine, getLine(doc, lastLine).text.length);
      return clipToLen(pos, getLine(doc, preLine).text.length);
    }
    if (pos.line == change.to.line + diff)
      return clipToLen(pos, lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0) + getLine(doc, change.to.line).text.length - change.to.ch);
    var inside = pos.line - change.from.line;
    return clipToLen(pos, change.text[inside].length + (inside ? 0 : change.from.ch));
  }
  function computeSelAfterChange(doc, change, hint) {
    if (hint && typeof hint == 'object')
      return {
        anchor: clipPostChange(doc, change, hint.anchor),
        head: clipPostChange(doc, change, hint.head)
      };
    if (hint == 'start')
      return {
        anchor: change.from,
        head: change.from
      };
    var end = changeEnd(change);
    if (hint == 'around')
      return {
        anchor: change.from,
        head: end
      };
    if (hint == 'end')
      return {
        anchor: end,
        head: end
      };
    var adjustPos = function (pos) {
      if (posLess(pos, change.from))
        return pos;
      if (!posLess(change.to, pos))
        return end;
      var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;
      if (pos.line == change.to.line)
        ch += end.ch - change.to.ch;
      return Pos(line, ch);
    };
    return {
      anchor: adjustPos(doc.sel.anchor),
      head: adjustPos(doc.sel.head)
    };
  }
  function filterChange(doc, change) {
    var obj = {
        canceled: false,
        from: change.from,
        to: change.to,
        text: change.text,
        origin: change.origin,
        update: function (from, to, text, origin) {
          if (from)
            this.from = clipPos(doc, from);
          if (to)
            this.to = clipPos(doc, to);
          if (text)
            this.text = text;
          if (origin !== undefined)
            this.origin = origin;
        },
        cancel: function () {
          this.canceled = true;
        }
      };
    signal(doc, 'beforeChange', doc, obj);
    if (doc.cm)
      signal(doc.cm, 'beforeChange', doc.cm, obj);
    if (obj.canceled)
      return null;
    return {
      from: obj.from,
      to: obj.to,
      text: obj.text,
      origin: obj.origin
    };
  }
  function makeChange(doc, change, selUpdate, ignoreReadOnly) {
    if (doc.cm) {
      if (!doc.cm.curOp)
        return operation(doc.cm, makeChange)(doc, change, selUpdate, ignoreReadOnly);
      if (doc.cm.state.suppressEdits)
        return;
    }
    if (hasHandler(doc, 'beforeChange') || doc.cm && hasHandler(doc.cm, 'beforeChange')) {
      change = filterChange(doc, change);
      if (!change)
        return;
    }
    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);
    if (split) {
      for (var i = split.length - 1; i >= 1; --i)
        makeChangeNoReadonly(doc, {
          from: split[i].from,
          to: split[i].to,
          text: ['']
        });
      if (split.length)
        makeChangeNoReadonly(doc, {
          from: split[0].from,
          to: split[0].to,
          text: change.text
        }, selUpdate);
    } else {
      makeChangeNoReadonly(doc, change, selUpdate);
    }
  }
  function makeChangeNoReadonly(doc, change, selUpdate) {
    var selAfter = computeSelAfterChange(doc, change, selUpdate);
    addToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);
    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
    var rebased = [];
    linkedDocs(doc, function (doc, sharedHist) {
      if (!sharedHist && indexOf(rebased, doc.history) == -1) {
        rebaseHist(doc.history, change);
        rebased.push(doc.history);
      }
      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));
    });
  }
  function makeChangeFromHistory(doc, type) {
    if (doc.cm && doc.cm.state.suppressEdits)
      return;
    var hist = doc.history;
    var event = (type == 'undo' ? hist.done : hist.undone).pop();
    if (!event)
      return;
    hist.dirtyCounter += type == 'undo' ? -1 : 1;
    var anti = {
        changes: [],
        anchorBefore: event.anchorAfter,
        headBefore: event.headAfter,
        anchorAfter: event.anchorBefore,
        headAfter: event.headBefore
      };
    (type == 'undo' ? hist.undone : hist.done).push(anti);
    for (var i = event.changes.length - 1; i >= 0; --i) {
      var change = event.changes[i];
      change.origin = type;
      anti.changes.push(historyChangeFromChange(doc, change));
      var after = i ? computeSelAfterChange(doc, change, null) : {
          anchor: event.anchorBefore,
          head: event.headBefore
        };
      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));
      var rebased = [];
      linkedDocs(doc, function (doc, sharedHist) {
        if (!sharedHist && indexOf(rebased, doc.history) == -1) {
          rebaseHist(doc.history, change);
          rebased.push(doc.history);
        }
        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));
      });
    }
  }
  function shiftDoc(doc, distance) {
    function shiftPos(pos) {
      return Pos(pos.line + distance, pos.ch);
    }
    doc.first += distance;
    if (doc.cm)
      regChange(doc.cm, doc.first, doc.first, distance);
    doc.sel.head = shiftPos(doc.sel.head);
    doc.sel.anchor = shiftPos(doc.sel.anchor);
    doc.sel.from = shiftPos(doc.sel.from);
    doc.sel.to = shiftPos(doc.sel.to);
  }
  function makeChangeSingleDoc(doc, change, selAfter, spans) {
    if (doc.cm && !doc.cm.curOp)
      return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);
    if (change.to.line < doc.first) {
      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
      return;
    }
    if (change.from.line > doc.lastLine())
      return;
    if (change.from.line < doc.first) {
      var shift = change.text.length - 1 - (doc.first - change.from.line);
      shiftDoc(doc, shift);
      change = {
        from: Pos(doc.first, 0),
        to: Pos(change.to.line + shift, change.to.ch),
        text: [lst(change.text)],
        origin: change.origin
      };
    }
    var last = doc.lastLine();
    if (change.to.line > last) {
      change = {
        from: change.from,
        to: Pos(last, getLine(doc, last).text.length),
        text: [change.text[0]],
        origin: change.origin
      };
    }
    change.removed = getBetween(doc, change.from, change.to);
    if (!selAfter)
      selAfter = computeSelAfterChange(doc, change, null);
    if (doc.cm)
      makeChangeSingleDocInEditor(doc.cm, change, spans, selAfter);
    else
      updateDoc(doc, change, spans, selAfter);
  }
  function makeChangeSingleDocInEditor(cm, change, spans, selAfter) {
    var doc = cm.doc, display = cm.display, from = change.from, to = change.to;
    var recomputeMaxLength = false, checkWidthStart = from.line;
    if (!cm.options.lineWrapping) {
      checkWidthStart = lineNo(visualLine(doc, getLine(doc, from.line)));
      doc.iter(checkWidthStart, to.line + 1, function (line) {
        if (line == display.maxLine) {
          recomputeMaxLength = true;
          return true;
        }
      });
    }
    if (!posLess(doc.sel.head, change.from) && !posLess(change.to, doc.sel.head))
      cm.curOp.cursorActivity = true;
    updateDoc(doc, change, spans, selAfter, estimateHeight(cm));
    if (!cm.options.lineWrapping) {
      doc.iter(checkWidthStart, from.line + change.text.length, function (line) {
        var len = lineLength(doc, line);
        if (len > display.maxLineLength) {
          display.maxLine = line;
          display.maxLineLength = len;
          display.maxLineChanged = true;
          recomputeMaxLength = false;
        }
      });
      if (recomputeMaxLength)
        cm.curOp.updateMaxLine = true;
    }
    doc.frontier = Math.min(doc.frontier, from.line);
    startWorker(cm, 400);
    var lendiff = change.text.length - (to.line - from.line) - 1;
    regChange(cm, from.line, to.line + 1, lendiff);
    if (hasHandler(cm, 'change')) {
      var changeObj = {
          from: from,
          to: to,
          text: change.text,
          removed: change.removed,
          origin: change.origin
        };
      if (cm.curOp.textChanged) {
        for (var cur = cm.curOp.textChanged; cur.next; cur = cur.next) {
        }
        cur.next = changeObj;
      } else
        cm.curOp.textChanged = changeObj;
    }
  }
  function replaceRange(doc, code, from, to, origin) {
    if (!to)
      to = from;
    if (posLess(to, from)) {
      var tmp = to;
      to = from;
      from = tmp;
    }
    if (typeof code == 'string')
      code = splitLines(code);
    makeChange(doc, {
      from: from,
      to: to,
      text: code,
      origin: origin
    }, null);
  }
  function Pos(line, ch) {
    if (!(this instanceof Pos))
      return new Pos(line, ch);
    this.line = line;
    this.ch = ch;
  }
  CodeMirror.Pos = Pos;
  function posEq(a, b) {
    return a.line == b.line && a.ch == b.ch;
  }
  function posLess(a, b) {
    return a.line < b.line || a.line == b.line && a.ch < b.ch;
  }
  function copyPos(x) {
    return Pos(x.line, x.ch);
  }
  function clipLine(doc, n) {
    return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));
  }
  function clipPos(doc, pos) {
    if (pos.line < doc.first)
      return Pos(doc.first, 0);
    var last = doc.first + doc.size - 1;
    if (pos.line > last)
      return Pos(last, getLine(doc, last).text.length);
    return clipToLen(pos, getLine(doc, pos.line).text.length);
  }
  function clipToLen(pos, linelen) {
    var ch = pos.ch;
    if (ch == null || ch > linelen)
      return Pos(pos.line, linelen);
    else if (ch < 0)
      return Pos(pos.line, 0);
    else
      return pos;
  }
  function isLine(doc, l) {
    return l >= doc.first && l < doc.first + doc.size;
  }
  function extendSelection(doc, pos, other, bias) {
    if (doc.sel.shift || doc.sel.extend) {
      var anchor = doc.sel.anchor;
      if (other) {
        var posBefore = posLess(pos, anchor);
        if (posBefore != posLess(other, anchor)) {
          anchor = pos;
          pos = other;
        } else if (posBefore != posLess(pos, other)) {
          pos = other;
        }
      }
      setSelection(doc, anchor, pos, bias);
    } else {
      setSelection(doc, pos, other || pos, bias);
    }
    if (doc.cm)
      doc.cm.curOp.userSelChange = true;
  }
  function filterSelectionChange(doc, anchor, head) {
    var obj = {
        anchor: anchor,
        head: head
      };
    signal(doc, 'beforeSelectionChange', doc, obj);
    if (doc.cm)
      signal(doc.cm, 'beforeSelectionChange', doc.cm, obj);
    obj.anchor = clipPos(doc, obj.anchor);
    obj.head = clipPos(doc, obj.head);
    return obj;
  }
  function setSelection(doc, anchor, head, bias, checkAtomic) {
    if (!checkAtomic && hasHandler(doc, 'beforeSelectionChange') || doc.cm && hasHandler(doc.cm, 'beforeSelectionChange')) {
      var filtered = filterSelectionChange(doc, anchor, head);
      head = filtered.head;
      anchor = filtered.anchor;
    }
    var sel = doc.sel;
    sel.goalColumn = null;
    if (checkAtomic || !posEq(anchor, sel.anchor))
      anchor = skipAtomic(doc, anchor, bias, checkAtomic != 'push');
    if (checkAtomic || !posEq(head, sel.head))
      head = skipAtomic(doc, head, bias, checkAtomic != 'push');
    if (posEq(sel.anchor, anchor) && posEq(sel.head, head))
      return;
    sel.anchor = anchor;
    sel.head = head;
    var inv = posLess(head, anchor);
    sel.from = inv ? head : anchor;
    sel.to = inv ? anchor : head;
    if (doc.cm)
      doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = doc.cm.curOp.cursorActivity = true;
    signalLater(doc, 'cursorActivity', doc);
  }
  function reCheckSelection(cm) {
    setSelection(cm.doc, cm.doc.sel.from, cm.doc.sel.to, null, 'push');
  }
  function skipAtomic(doc, pos, bias, mayClear) {
    var flipped = false, curPos = pos;
    var dir = bias || 1;
    doc.cantEdit = false;
    search:
      for (;;) {
        var line = getLine(doc, curPos.line);
        if (line.markedSpans) {
          for (var i = 0; i < line.markedSpans.length; ++i) {
            var sp = line.markedSpans[i], m = sp.marker;
            if ((sp.from == null || (m.inclusiveLeft ? sp.from <= curPos.ch : sp.from < curPos.ch)) && (sp.to == null || (m.inclusiveRight ? sp.to >= curPos.ch : sp.to > curPos.ch))) {
              if (mayClear) {
                signal(m, 'beforeCursorEnter');
                if (m.explicitlyCleared) {
                  if (!line.markedSpans)
                    break;
                  else {
                    --i;
                    continue;
                  }
                }
              }
              if (!m.atomic)
                continue;
              var newPos = m.find()[dir < 0 ? 'from' : 'to'];
              if (posEq(newPos, curPos)) {
                newPos.ch += dir;
                if (newPos.ch < 0) {
                  if (newPos.line > doc.first)
                    newPos = clipPos(doc, Pos(newPos.line - 1));
                  else
                    newPos = null;
                } else if (newPos.ch > line.text.length) {
                  if (newPos.line < doc.first + doc.size - 1)
                    newPos = Pos(newPos.line + 1, 0);
                  else
                    newPos = null;
                }
                if (!newPos) {
                  if (flipped) {
                    if (!mayClear)
                      return skipAtomic(doc, pos, bias, true);
                    doc.cantEdit = true;
                    return Pos(doc.first, 0);
                  }
                  flipped = true;
                  newPos = pos;
                  dir = -dir;
                }
              }
              curPos = newPos;
              continue search;
            }
          }
        }
        return curPos;
      }
  }
  function scrollCursorIntoView(cm) {
    var coords = scrollPosIntoView(cm, cm.doc.sel.head);
    if (!cm.state.focused)
      return;
    var display = cm.display, box = getRect(display.sizer), doScroll = null, pTop = paddingTop(cm.display);
    if (coords.top + pTop + box.top < 0)
      doScroll = true;
    else if (coords.bottom + pTop + box.top > (window.innerHeight || document.documentElement.clientHeight))
      doScroll = false;
    if (doScroll != null && !phantom) {
      var hidden = display.cursor.style.display == 'none';
      if (hidden) {
        display.cursor.style.display = '';
        display.cursor.style.left = coords.left + 'px';
        display.cursor.style.top = coords.top - display.viewOffset + 'px';
      }
      display.cursor.scrollIntoView(doScroll);
      if (hidden)
        display.cursor.style.display = 'none';
    }
  }
  function scrollPosIntoView(cm, pos, margin) {
    if (margin == null)
      margin = 0;
    for (;;) {
      var changed = false, coords = cursorCoords(cm, pos);
      var scrollPos = calculateScrollPos(cm, coords.left, coords.top - margin, coords.left, coords.bottom + margin);
      var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;
      if (scrollPos.scrollTop != null) {
        setScrollTop(cm, scrollPos.scrollTop);
        if (Math.abs(cm.doc.scrollTop - startTop) > 1)
          changed = true;
      }
      if (scrollPos.scrollLeft != null) {
        setScrollLeft(cm, scrollPos.scrollLeft);
        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1)
          changed = true;
      }
      if (!changed)
        return coords;
    }
  }
  function scrollIntoView(cm, x1, y1, x2, y2) {
    var scrollPos = calculateScrollPos(cm, x1, y1, x2, y2);
    if (scrollPos.scrollTop != null)
      setScrollTop(cm, scrollPos.scrollTop);
    if (scrollPos.scrollLeft != null)
      setScrollLeft(cm, scrollPos.scrollLeft);
  }
  function calculateScrollPos(cm, x1, y1, x2, y2) {
    var display = cm.display, pt = paddingTop(display);
    y1 += pt;
    y2 += pt;
    if (y1 < 0)
      y1 = 0;
    var screen = display.scroller.clientHeight - scrollerCutOff, screentop = display.scroller.scrollTop, result = {};
    var docBottom = cm.doc.height + paddingVert(display);
    var atTop = y1 < pt + 10, atBottom = y2 + pt > docBottom - 10;
    if (y1 < screentop) {
      result.scrollTop = atTop ? 0 : y1;
    } else if (y2 > screentop + screen) {
      var newTop = Math.min(y1, (atBottom ? docBottom : y2) - screen);
      if (newTop != screentop)
        result.scrollTop = newTop;
    }
    var screenw = display.scroller.clientWidth - scrollerCutOff, screenleft = display.scroller.scrollLeft;
    x1 += display.gutters.offsetWidth;
    x2 += display.gutters.offsetWidth;
    var gutterw = display.gutters.offsetWidth;
    var atLeft = x1 < gutterw + 10;
    if (x1 < screenleft + gutterw || atLeft) {
      if (atLeft)
        x1 = 0;
      result.scrollLeft = Math.max(0, x1 - 10 - gutterw);
    } else if (x2 > screenw + screenleft - 3) {
      result.scrollLeft = x2 + 10 - screenw;
    }
    return result;
  }
  function updateScrollPos(cm, left, top) {
    cm.curOp.updateScrollPos = {
      scrollLeft: left == null ? cm.doc.scrollLeft : left,
      scrollTop: top == null ? cm.doc.scrollTop : top
    };
  }
  function addToScrollPos(cm, left, top) {
    var pos = cm.curOp.updateScrollPos || (cm.curOp.updateScrollPos = {
        scrollLeft: cm.doc.scrollLeft,
        scrollTop: cm.doc.scrollTop
      });
    var scroll = cm.display.scroller;
    pos.scrollTop = Math.max(0, Math.min(scroll.scrollHeight - scroll.clientHeight, pos.scrollTop + top));
    pos.scrollLeft = Math.max(0, Math.min(scroll.scrollWidth - scroll.clientWidth, pos.scrollLeft + left));
  }
  function indentLine(cm, n, how, aggressive) {
    var doc = cm.doc;
    if (!how)
      how = 'add';
    if (how == 'smart') {
      if (!cm.doc.mode.indent)
        how = 'prev';
      else
        var state = getStateBefore(cm, n);
    }
    var tabSize = cm.options.tabSize;
    var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);
    var curSpaceString = line.text.match(/^\s*/)[0], indentation;
    if (how == 'smart') {
      indentation = cm.doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);
      if (indentation == Pass) {
        if (!aggressive)
          return;
        how = 'prev';
      }
    }
    if (how == 'prev') {
      if (n > doc.first)
        indentation = countColumn(getLine(doc, n - 1).text, null, tabSize);
      else
        indentation = 0;
    } else if (how == 'add') {
      indentation = curSpace + cm.options.indentUnit;
    } else if (how == 'subtract') {
      indentation = curSpace - cm.options.indentUnit;
    }
    indentation = Math.max(0, indentation);
    var indentString = '', pos = 0;
    if (cm.options.indentWithTabs)
      for (var i = Math.floor(indentation / tabSize); i; --i) {
        pos += tabSize;
        indentString += '\t';
      }
    if (pos < indentation)
      indentString += spaceStr(indentation - pos);
    if (indentString != curSpaceString)
      replaceRange(cm.doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), '+input');
    line.stateAfter = null;
  }
  function changeLine(cm, handle, op) {
    var no = handle, line = handle, doc = cm.doc;
    if (typeof handle == 'number')
      line = getLine(doc, clipLine(doc, handle));
    else
      no = lineNo(handle);
    if (no == null)
      return null;
    if (op(line, no))
      regChange(cm, no, no + 1);
    else
      return null;
    return line;
  }
  function findPosH(doc, pos, dir, unit, visually) {
    var line = pos.line, ch = pos.ch;
    var lineObj = getLine(doc, line);
    var possible = true;
    function findNextLine() {
      var l = line + dir;
      if (l < doc.first || l >= doc.first + doc.size)
        return possible = false;
      line = l;
      return lineObj = getLine(doc, l);
    }
    function moveOnce(boundToLine) {
      var next = (visually ? moveVisually : moveLogically)(lineObj, ch, dir, true);
      if (next == null) {
        if (!boundToLine && findNextLine()) {
          if (visually)
            ch = (dir < 0 ? lineRight : lineLeft)(lineObj);
          else
            ch = dir < 0 ? lineObj.text.length : 0;
        } else
          return possible = false;
      } else
        ch = next;
      return true;
    }
    if (unit == 'char')
      moveOnce();
    else if (unit == 'column')
      moveOnce(true);
    else if (unit == 'word' || unit == 'group') {
      var sawType = null, group = unit == 'group';
      for (var first = true;; first = false) {
        if (dir < 0 && !moveOnce(!first))
          break;
        var cur = lineObj.text.charAt(ch) || '\n';
        var type = isWordChar(cur) ? 'w' : !group ? null : /\s/.test(cur) ? null : 'p';
        if (sawType && sawType != type) {
          if (dir < 0) {
            dir = 1;
            moveOnce();
          }
          break;
        }
        if (type)
          sawType = type;
        if (dir > 0 && !moveOnce(!first))
          break;
      }
    }
    var result = skipAtomic(doc, Pos(line, ch), dir, true);
    if (!possible)
      result.hitSide = true;
    return result;
  }
  function findPosV(cm, pos, dir, unit) {
    var doc = cm.doc, x = pos.left, y;
    if (unit == 'page') {
      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
      y = pos.top + dir * (pageSize - (dir < 0 ? 1.5 : 0.5) * textHeight(cm.display));
    } else if (unit == 'line') {
      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;
    }
    for (;;) {
      var target = coordsChar(cm, x, y);
      if (!target.outside)
        break;
      if (dir < 0 ? y <= 0 : y >= doc.height) {
        target.hitSide = true;
        break;
      }
      y += dir * 5;
    }
    return target;
  }
  function findWordAt(line, pos) {
    var start = pos.ch, end = pos.ch;
    if (line) {
      if (pos.after === false || end == line.length)
        --start;
      else
        ++end;
      var startChar = line.charAt(start);
      var check = isWordChar(startChar) ? isWordChar : /\s/.test(startChar) ? function (ch) {
          return /\s/.test(ch);
        } : function (ch) {
          return !/\s/.test(ch) && !isWordChar(ch);
        };
      while (start > 0 && check(line.charAt(start - 1)))
        --start;
      while (end < line.length && check(line.charAt(end)))
        ++end;
    }
    return {
      from: Pos(pos.line, start),
      to: Pos(pos.line, end)
    };
  }
  function selectLine(cm, line) {
    extendSelection(cm.doc, Pos(line, 0), clipPos(cm.doc, Pos(line + 1, 0)));
  }
  CodeMirror.prototype = {
    focus: function () {
      window.focus();
      focusInput(this);
      onFocus(this);
      fastPoll(this);
    },
    setOption: function (option, value) {
      var options = this.options, old = options[option];
      if (options[option] == value && option != 'mode')
        return;
      options[option] = value;
      if (optionHandlers.hasOwnProperty(option))
        operation(this, optionHandlers[option])(this, value, old);
    },
    getOption: function (option) {
      return this.options[option];
    },
    getDoc: function () {
      return this.doc;
    },
    addKeyMap: function (map, bottom) {
      this.state.keyMaps[bottom ? 'push' : 'unshift'](map);
    },
    removeKeyMap: function (map) {
      var maps = this.state.keyMaps;
      for (var i = 0; i < maps.length; ++i)
        if ((typeof map == 'string' ? maps[i].name : maps[i]) == map) {
          maps.splice(i, 1);
          return true;
        }
    },
    addOverlay: operation(null, function (spec, options) {
      var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);
      if (mode.startState)
        throw new Error('Overlays may not be stateful.');
      this.state.overlays.push({
        mode: mode,
        modeSpec: spec,
        opaque: options && options.opaque
      });
      this.state.modeGen++;
      regChange(this);
    }),
    removeOverlay: operation(null, function (spec) {
      var overlays = this.state.overlays;
      for (var i = 0; i < overlays.length; ++i) {
        if (overlays[i].modeSpec == spec) {
          overlays.splice(i, 1);
          this.state.modeGen++;
          regChange(this);
          return;
        }
      }
    }),
    indentLine: operation(null, function (n, dir, aggressive) {
      if (typeof dir != 'string') {
        if (dir == null)
          dir = this.options.smartIndent ? 'smart' : 'prev';
        else
          dir = dir ? 'add' : 'subtract';
      }
      if (isLine(this.doc, n))
        indentLine(this, n, dir, aggressive);
    }),
    indentSelection: operation(null, function (how) {
      var sel = this.doc.sel;
      if (posEq(sel.from, sel.to))
        return indentLine(this, sel.from.line, how);
      var e = sel.to.line - (sel.to.ch ? 0 : 1);
      for (var i = sel.from.line; i <= e; ++i)
        indentLine(this, i, how);
    }),
    getTokenAt: function (pos) {
      var doc = this.doc;
      pos = clipPos(doc, pos);
      var state = getStateBefore(this, pos.line), mode = this.doc.mode;
      var line = getLine(doc, pos.line);
      var stream = new StringStream(line.text, this.options.tabSize);
      while (stream.pos < pos.ch && !stream.eol()) {
        stream.start = stream.pos;
        var style = mode.token(stream, state);
      }
      return {
        start: stream.start,
        end: stream.pos,
        string: stream.current(),
        className: style || null,
        type: style || null,
        state: state
      };
    },
    getStateAfter: function (line) {
      var doc = this.doc;
      line = clipLine(doc, line == null ? doc.first + doc.size - 1 : line);
      return getStateBefore(this, line + 1);
    },
    cursorCoords: function (start, mode) {
      var pos, sel = this.doc.sel;
      if (start == null)
        pos = sel.head;
      else if (typeof start == 'object')
        pos = clipPos(this.doc, start);
      else
        pos = start ? sel.from : sel.to;
      return cursorCoords(this, pos, mode || 'page');
    },
    charCoords: function (pos, mode) {
      return charCoords(this, clipPos(this.doc, pos), mode || 'page');
    },
    coordsChar: function (coords, mode) {
      coords = fromCoordSystem(this, coords, mode || 'page');
      return coordsChar(this, coords.left, coords.top);
    },
    defaultTextHeight: function () {
      return textHeight(this.display);
    },
    defaultCharWidth: function () {
      return charWidth(this.display);
    },
    setGutterMarker: operation(null, function (line, gutterID, value) {
      return changeLine(this, line, function (line) {
        var markers = line.gutterMarkers || (line.gutterMarkers = {});
        markers[gutterID] = value;
        if (!value && isEmpty(markers))
          line.gutterMarkers = null;
        return true;
      });
    }),
    clearGutter: operation(null, function (gutterID) {
      var cm = this, doc = cm.doc, i = doc.first;
      doc.iter(function (line) {
        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
          line.gutterMarkers[gutterID] = null;
          regChange(cm, i, i + 1);
          if (isEmpty(line.gutterMarkers))
            line.gutterMarkers = null;
        }
        ++i;
      });
    }),
    addLineClass: operation(null, function (handle, where, cls) {
      return changeLine(this, handle, function (line) {
        var prop = where == 'text' ? 'textClass' : where == 'background' ? 'bgClass' : 'wrapClass';
        if (!line[prop])
          line[prop] = cls;
        else if (new RegExp('\\b' + cls + '\\b').test(line[prop]))
          return false;
        else
          line[prop] += ' ' + cls;
        return true;
      });
    }),
    removeLineClass: operation(null, function (handle, where, cls) {
      return changeLine(this, handle, function (line) {
        var prop = where == 'text' ? 'textClass' : where == 'background' ? 'bgClass' : 'wrapClass';
        var cur = line[prop];
        if (!cur)
          return false;
        else if (cls == null)
          line[prop] = null;
        else {
          var upd = cur.replace(new RegExp('^' + cls + '\\b\\s*|\\s*\\b' + cls + '\\b'), '');
          if (upd == cur)
            return false;
          line[prop] = upd || null;
        }
        return true;
      });
    }),
    addLineWidget: operation(null, function (handle, node, options) {
      return addLineWidget(this, handle, node, options);
    }),
    removeLineWidget: function (widget) {
      widget.clear();
    },
    lineInfo: function (line) {
      if (typeof line == 'number') {
        if (!isLine(this.doc, line))
          return null;
        var n = line;
        line = getLine(this.doc, line);
        if (!line)
          return null;
      } else {
        var n = lineNo(line);
        if (n == null)
          return null;
      }
      return {
        line: n,
        handle: line,
        text: line.text,
        gutterMarkers: line.gutterMarkers,
        textClass: line.textClass,
        bgClass: line.bgClass,
        wrapClass: line.wrapClass,
        widgets: line.widgets
      };
    },
    getViewport: function () {
      return {
        from: this.display.showingFrom,
        to: this.display.showingTo
      };
    },
    addWidget: function (pos, node, scroll, vert, horiz) {
      var display = this.display;
      pos = cursorCoords(this, clipPos(this.doc, pos));
      var top = pos.bottom, left = pos.left;
      node.style.position = 'absolute';
      display.sizer.appendChild(node);
      if (vert == 'over') {
        top = pos.top;
      } else if (vert == 'above' || vert == 'near') {
        var vspace = Math.max(display.wrapper.clientHeight, this.doc.height), hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
        if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)
          top = pos.top - node.offsetHeight;
        else if (pos.bottom + node.offsetHeight <= vspace)
          top = pos.bottom;
        if (left + node.offsetWidth > hspace)
          left = hspace - node.offsetWidth;
      }
      node.style.top = top + paddingTop(display) + 'px';
      node.style.left = node.style.right = '';
      if (horiz == 'right') {
        left = display.sizer.clientWidth - node.offsetWidth;
        node.style.right = '0px';
      } else {
        if (horiz == 'left')
          left = 0;
        else if (horiz == 'middle')
          left = (display.sizer.clientWidth - node.offsetWidth) / 2;
        node.style.left = left + 'px';
      }
      if (scroll)
        scrollIntoView(this, left, top, left + node.offsetWidth, top + node.offsetHeight);
    },
    triggerOnKeyDown: operation(null, onKeyDown),
    execCommand: function (cmd) {
      return commands[cmd](this);
    },
    findPosH: function (from, amount, unit, visually) {
      var dir = 1;
      if (amount < 0) {
        dir = -1;
        amount = -amount;
      }
      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {
        cur = findPosH(this.doc, cur, dir, unit, visually);
        if (cur.hitSide)
          break;
      }
      return cur;
    },
    moveH: operation(null, function (dir, unit) {
      var sel = this.doc.sel, pos;
      if (sel.shift || sel.extend || posEq(sel.from, sel.to))
        pos = findPosH(this.doc, sel.head, dir, unit, this.options.rtlMoveVisually);
      else
        pos = dir < 0 ? sel.from : sel.to;
      extendSelection(this.doc, pos, pos, dir);
    }),
    deleteH: operation(null, function (dir, unit) {
      var sel = this.doc.sel;
      if (!posEq(sel.from, sel.to))
        replaceRange(this.doc, '', sel.from, sel.to, '+delete');
      else
        replaceRange(this.doc, '', sel.from, findPosH(this.doc, sel.head, dir, unit, false), '+delete');
      this.curOp.userSelChange = true;
    }),
    findPosV: function (from, amount, unit, goalColumn) {
      var dir = 1, x = goalColumn;
      if (amount < 0) {
        dir = -1;
        amount = -amount;
      }
      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {
        var coords = cursorCoords(this, cur, 'div');
        if (x == null)
          x = coords.left;
        else
          coords.left = x;
        cur = findPosV(this, coords, dir, unit);
        if (cur.hitSide)
          break;
      }
      return cur;
    },
    moveV: operation(null, function (dir, unit) {
      var sel = this.doc.sel;
      var pos = cursorCoords(this, sel.head, 'div');
      if (sel.goalColumn != null)
        pos.left = sel.goalColumn;
      var target = findPosV(this, pos, dir, unit);
      if (unit == 'page')
        addToScrollPos(this, 0, charCoords(this, target, 'div').top - pos.top);
      extendSelection(this.doc, target, target, dir);
      sel.goalColumn = pos.left;
    }),
    toggleOverwrite: function () {
      if (this.state.overwrite = !this.state.overwrite)
        this.display.cursor.className += ' CodeMirror-overwrite';
      else
        this.display.cursor.className = this.display.cursor.className.replace(' CodeMirror-overwrite', '');
    },
    hasFocus: function () {
      return this.state.focused;
    },
    scrollTo: operation(null, function (x, y) {
      updateScrollPos(this, x, y);
    }),
    getScrollInfo: function () {
      var scroller = this.display.scroller, co = scrollerCutOff;
      return {
        left: scroller.scrollLeft,
        top: scroller.scrollTop,
        height: scroller.scrollHeight - co,
        width: scroller.scrollWidth - co,
        clientHeight: scroller.clientHeight - co,
        clientWidth: scroller.clientWidth - co
      };
    },
    scrollIntoView: operation(null, function (pos, margin) {
      if (typeof pos == 'number')
        pos = Pos(pos, 0);
      if (!margin)
        margin = 0;
      var coords = pos;
      if (!pos || pos.line != null) {
        this.curOp.scrollToPos = pos ? clipPos(this.doc, pos) : this.doc.sel.head;
        this.curOp.scrollToPosMargin = margin;
        coords = cursorCoords(this, this.curOp.scrollToPos);
      }
      var sPos = calculateScrollPos(this, coords.left, coords.top - margin, coords.right, coords.bottom + margin);
      updateScrollPos(this, sPos.scrollLeft, sPos.scrollTop);
    }),
    setSize: function (width, height) {
      function interpret(val) {
        return typeof val == 'number' || /^\d+$/.test(String(val)) ? val + 'px' : val;
      }
      if (width != null)
        this.display.wrapper.style.width = interpret(width);
      if (height != null)
        this.display.wrapper.style.height = interpret(height);
      this.refresh();
    },
    on: function (type, f) {
      on(this, type, f);
    },
    off: function (type, f) {
      off(this, type, f);
    },
    operation: function (f) {
      return runInOp(this, f);
    },
    refresh: operation(null, function () {
      clearCaches(this);
      updateScrollPos(this, this.doc.scrollLeft, this.doc.scrollTop);
      regChange(this);
    }),
    swapDoc: operation(null, function (doc) {
      var old = this.doc;
      old.cm = null;
      attachDoc(this, doc);
      clearCaches(this);
      resetInput(this, true);
      updateScrollPos(this, doc.scrollLeft, doc.scrollTop);
      return old;
    }),
    getInputField: function () {
      return this.display.input;
    },
    getWrapperElement: function () {
      return this.display.wrapper;
    },
    getScrollerElement: function () {
      return this.display.scroller;
    },
    getGutterElement: function () {
      return this.display.gutters;
    }
  };
  var optionHandlers = CodeMirror.optionHandlers = {};
  var defaults = CodeMirror.defaults = {};
  function option(name, deflt, handle, notOnInit) {
    CodeMirror.defaults[name] = deflt;
    if (handle)
      optionHandlers[name] = notOnInit ? function (cm, val, old) {
        if (old != Init)
          handle(cm, val, old);
      } : handle;
  }
  var Init = CodeMirror.Init = {
      toString: function () {
        return 'CodeMirror.Init';
      }
    };
  option('value', '', function (cm, val) {
    cm.setValue(val);
  }, true);
  option('mode', null, function (cm, val) {
    cm.doc.modeOption = val;
    loadMode(cm);
  }, true);
  option('indentUnit', 2, loadMode, true);
  option('indentWithTabs', false);
  option('smartIndent', true);
  option('tabSize', 4, function (cm) {
    loadMode(cm);
    clearCaches(cm);
    regChange(cm);
  }, true);
  option('electricChars', true);
  option('rtlMoveVisually', !windows);
  option('theme', 'default', function (cm) {
    themeChanged(cm);
    guttersChanged(cm);
  }, true);
  option('keyMap', 'default', keyMapChanged);
  option('extraKeys', null);
  option('onKeyEvent', null);
  option('onDragEvent', null);
  option('lineWrapping', false, wrappingChanged, true);
  option('gutters', [], function (cm) {
    setGuttersForLineNumbers(cm.options);
    guttersChanged(cm);
  }, true);
  option('fixedGutter', true, function (cm, val) {
    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + 'px' : '0';
    cm.refresh();
  }, true);
  option('lineNumbers', false, function (cm) {
    setGuttersForLineNumbers(cm.options);
    guttersChanged(cm);
  }, true);
  option('firstLineNumber', 1, guttersChanged, true);
  option('lineNumberFormatter', function (integer) {
    return integer;
  }, guttersChanged, true);
  option('showCursorWhenSelecting', false, updateSelection, true);
  option('readOnly', false, function (cm, val) {
    if (val == 'nocursor') {
      onBlur(cm);
      cm.display.input.blur();
    } else if (!val)
      resetInput(cm, true);
  });
  option('dragDrop', true);
  option('cursorBlinkRate', 530);
  option('cursorHeight', 1);
  option('workTime', 100);
  option('workDelay', 100);
  option('flattenSpans', true);
  option('pollInterval', 100);
  option('undoDepth', 40, function (cm, val) {
    cm.doc.history.undoDepth = val;
  });
  option('historyEventDelay', 500);
  option('viewportMargin', 10, function (cm) {
    cm.refresh();
  }, true);
  option('maxHighlightLength', 10000, function (cm) {
    loadMode(cm);
    cm.refresh();
  }, true);
  option('moveInputWithCursor', true, function (cm, val) {
    if (!val)
      cm.display.inputDiv.style.top = cm.display.inputDiv.style.left = 0;
  });
  option('tabindex', null, function (cm, val) {
    cm.display.input.tabIndex = val || '';
  });
  option('autofocus', null);
  var modes = CodeMirror.modes = {}, mimeModes = CodeMirror.mimeModes = {};
  CodeMirror.defineMode = function (name, mode) {
    if (!CodeMirror.defaults.mode && name != 'null')
      CodeMirror.defaults.mode = name;
    if (arguments.length > 2) {
      mode.dependencies = [];
      for (var i = 2; i < arguments.length; ++i)
        mode.dependencies.push(arguments[i]);
    }
    modes[name] = mode;
  };
  CodeMirror.defineMIME = function (mime, spec) {
    mimeModes[mime] = spec;
  };
  CodeMirror.resolveMode = function (spec) {
    if (typeof spec == 'string' && mimeModes.hasOwnProperty(spec))
      spec = mimeModes[spec];
    else if (typeof spec == 'string' && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec))
      return CodeMirror.resolveMode('application/xml');
    if (typeof spec == 'string')
      return { name: spec };
    else
      return spec || { name: 'null' };
  };
  CodeMirror.getMode = function (options, spec) {
    spec = CodeMirror.resolveMode(spec);
    var mfactory = modes[spec.name];
    if (!mfactory)
      return CodeMirror.getMode(options, 'text/plain');
    var modeObj = mfactory(options, spec);
    if (modeExtensions.hasOwnProperty(spec.name)) {
      var exts = modeExtensions[spec.name];
      for (var prop in exts) {
        if (!exts.hasOwnProperty(prop))
          continue;
        if (modeObj.hasOwnProperty(prop))
          modeObj['_' + prop] = modeObj[prop];
        modeObj[prop] = exts[prop];
      }
    }
    modeObj.name = spec.name;
    return modeObj;
  };
  CodeMirror.defineMode('null', function () {
    return {
      token: function (stream) {
        stream.skipToEnd();
      }
    };
  });
  CodeMirror.defineMIME('text/plain', 'null');
  var modeExtensions = CodeMirror.modeExtensions = {};
  CodeMirror.extendMode = function (mode, properties) {
    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : modeExtensions[mode] = {};
    copyObj(properties, exts);
  };
  CodeMirror.defineExtension = function (name, func) {
    CodeMirror.prototype[name] = func;
  };
  CodeMirror.defineDocExtension = function (name, func) {
    Doc.prototype[name] = func;
  };
  CodeMirror.defineOption = option;
  var initHooks = [];
  CodeMirror.defineInitHook = function (f) {
    initHooks.push(f);
  };
  function copyState(mode, state) {
    if (state === true)
      return state;
    if (mode.copyState)
      return mode.copyState(state);
    var nstate = {};
    for (var n in state) {
      var val = state[n];
      if (val instanceof Array)
        val = val.concat([]);
      nstate[n] = val;
    }
    return nstate;
  }
  CodeMirror.copyState = copyState;
  function startState(mode, a1, a2) {
    return mode.startState ? mode.startState(a1, a2) : true;
  }
  CodeMirror.startState = startState;
  CodeMirror.innerMode = function (mode, state) {
    while (mode.innerMode) {
      var info = mode.innerMode(state);
      state = info.state;
      mode = info.mode;
    }
    return info || {
      mode: mode,
      state: state
    };
  };
  var commands = CodeMirror.commands = {
      selectAll: function (cm) {
        cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()));
      },
      killLine: function (cm) {
        var from = cm.getCursor(true), to = cm.getCursor(false), sel = !posEq(from, to);
        if (!sel && cm.getLine(from.line).length == from.ch)
          cm.replaceRange('', from, Pos(from.line + 1, 0), '+delete');
        else
          cm.replaceRange('', from, sel ? to : Pos(from.line), '+delete');
      },
      deleteLine: function (cm) {
        var l = cm.getCursor().line;
        cm.replaceRange('', Pos(l, 0), Pos(l), '+delete');
      },
      undo: function (cm) {
        cm.undo();
      },
      redo: function (cm) {
        cm.redo();
      },
      goDocStart: function (cm) {
        cm.extendSelection(Pos(cm.firstLine(), 0));
      },
      goDocEnd: function (cm) {
        cm.extendSelection(Pos(cm.lastLine()));
      },
      goLineStart: function (cm) {
        cm.extendSelection(lineStart(cm, cm.getCursor().line));
      },
      goLineStartSmart: function (cm) {
        var cur = cm.getCursor(), start = lineStart(cm, cur.line);
        var line = cm.getLineHandle(start.line);
        var order = getOrder(line);
        if (!order || order[0].level == 0) {
          var firstNonWS = Math.max(0, line.text.search(/\S/));
          var inWS = cur.line == start.line && cur.ch <= firstNonWS && cur.ch;
          cm.extendSelection(Pos(start.line, inWS ? 0 : firstNonWS));
        } else
          cm.extendSelection(start);
      },
      goLineEnd: function (cm) {
        cm.extendSelection(lineEnd(cm, cm.getCursor().line));
      },
      goLineRight: function (cm) {
        var top = cm.charCoords(cm.getCursor(), 'div').top + 5;
        cm.extendSelection(cm.coordsChar({
          left: cm.display.lineDiv.offsetWidth + 100,
          top: top
        }, 'div'));
      },
      goLineLeft: function (cm) {
        var top = cm.charCoords(cm.getCursor(), 'div').top + 5;
        cm.extendSelection(cm.coordsChar({
          left: 0,
          top: top
        }, 'div'));
      },
      goLineUp: function (cm) {
        cm.moveV(-1, 'line');
      },
      goLineDown: function (cm) {
        cm.moveV(1, 'line');
      },
      goPageUp: function (cm) {
        cm.moveV(-1, 'page');
      },
      goPageDown: function (cm) {
        cm.moveV(1, 'page');
      },
      goCharLeft: function (cm) {
        cm.moveH(-1, 'char');
      },
      goCharRight: function (cm) {
        cm.moveH(1, 'char');
      },
      goColumnLeft: function (cm) {
        cm.moveH(-1, 'column');
      },
      goColumnRight: function (cm) {
        cm.moveH(1, 'column');
      },
      goWordLeft: function (cm) {
        cm.moveH(-1, 'word');
      },
      goGroupRight: function (cm) {
        cm.moveH(1, 'group');
      },
      goGroupLeft: function (cm) {
        cm.moveH(-1, 'group');
      },
      goWordRight: function (cm) {
        cm.moveH(1, 'word');
      },
      delCharBefore: function (cm) {
        cm.deleteH(-1, 'char');
      },
      delCharAfter: function (cm) {
        cm.deleteH(1, 'char');
      },
      delWordBefore: function (cm) {
        cm.deleteH(-1, 'word');
      },
      delWordAfter: function (cm) {
        cm.deleteH(1, 'word');
      },
      delGroupBefore: function (cm) {
        cm.deleteH(-1, 'group');
      },
      delGroupAfter: function (cm) {
        cm.deleteH(1, 'group');
      },
      indentAuto: function (cm) {
        cm.indentSelection('smart');
      },
      indentMore: function (cm) {
        cm.indentSelection('add');
      },
      indentLess: function (cm) {
        cm.indentSelection('subtract');
      },
      insertTab: function (cm) {
        cm.replaceSelection('\t', 'end', '+input');
      },
      defaultTab: function (cm) {
        if (cm.somethingSelected())
          cm.indentSelection('add');
        else
          cm.replaceSelection('\t', 'end', '+input');
      },
      transposeChars: function (cm) {
        var cur = cm.getCursor(), line = cm.getLine(cur.line);
        if (cur.ch > 0 && cur.ch < line.length - 1)
          cm.replaceRange(line.charAt(cur.ch) + line.charAt(cur.ch - 1), Pos(cur.line, cur.ch - 1), Pos(cur.line, cur.ch + 1));
      },
      newlineAndIndent: function (cm) {
        operation(cm, function () {
          cm.replaceSelection('\n', 'end', '+input');
          cm.indentLine(cm.getCursor().line, null, true);
        })();
      },
      toggleOverwrite: function (cm) {
        cm.toggleOverwrite();
      }
    };
  var keyMap = CodeMirror.keyMap = {};
  keyMap.basic = {
    'Left': 'goCharLeft',
    'Right': 'goCharRight',
    'Up': 'goLineUp',
    'Down': 'goLineDown',
    'End': 'goLineEnd',
    'Home': 'goLineStartSmart',
    'PageUp': 'goPageUp',
    'PageDown': 'goPageDown',
    'Delete': 'delCharAfter',
    'Backspace': 'delCharBefore',
    'Tab': 'defaultTab',
    'Shift-Tab': 'indentAuto',
    'Enter': 'newlineAndIndent',
    'Insert': 'toggleOverwrite'
  };
  keyMap.pcDefault = {
    'Ctrl-A': 'selectAll',
    'Ctrl-D': 'deleteLine',
    'Ctrl-Z': 'undo',
    'Shift-Ctrl-Z': 'redo',
    'Ctrl-Y': 'redo',
    'Ctrl-Home': 'goDocStart',
    'Alt-Up': 'goDocStart',
    'Ctrl-End': 'goDocEnd',
    'Ctrl-Down': 'goDocEnd',
    'Ctrl-Left': 'goGroupLeft',
    'Ctrl-Right': 'goGroupRight',
    'Alt-Left': 'goLineStart',
    'Alt-Right': 'goLineEnd',
    'Ctrl-Backspace': 'delGroupBefore',
    'Ctrl-Delete': 'delGroupAfter',
    'Ctrl-S': 'save',
    'Ctrl-F': 'find',
    'Ctrl-G': 'findNext',
    'Shift-Ctrl-G': 'findPrev',
    'Shift-Ctrl-F': 'replace',
    'Shift-Ctrl-R': 'replaceAll',
    'Ctrl-[': 'indentLess',
    'Ctrl-]': 'indentMore',
    fallthrough: 'basic'
  };
  keyMap.macDefault = {
    'Cmd-A': 'selectAll',
    'Cmd-D': 'deleteLine',
    'Cmd-Z': 'undo',
    'Shift-Cmd-Z': 'redo',
    'Cmd-Y': 'redo',
    'Cmd-Up': 'goDocStart',
    'Cmd-End': 'goDocEnd',
    'Cmd-Down': 'goDocEnd',
    'Alt-Left': 'goGroupLeft',
    'Alt-Right': 'goGroupRight',
    'Cmd-Left': 'goLineStart',
    'Cmd-Right': 'goLineEnd',
    'Alt-Backspace': 'delGroupBefore',
    'Ctrl-Alt-Backspace': 'delGroupAfter',
    'Alt-Delete': 'delGroupAfter',
    'Cmd-S': 'save',
    'Cmd-F': 'find',
    'Cmd-G': 'findNext',
    'Shift-Cmd-G': 'findPrev',
    'Cmd-Alt-F': 'replace',
    'Shift-Cmd-Alt-F': 'replaceAll',
    'Cmd-[': 'indentLess',
    'Cmd-]': 'indentMore',
    fallthrough: [
      'basic',
      'emacsy'
    ]
  };
  keyMap['default'] = mac ? keyMap.macDefault : keyMap.pcDefault;
  keyMap.emacsy = {
    'Ctrl-F': 'goCharRight',
    'Ctrl-B': 'goCharLeft',
    'Ctrl-P': 'goLineUp',
    'Ctrl-N': 'goLineDown',
    'Alt-F': 'goWordRight',
    'Alt-B': 'goWordLeft',
    'Ctrl-A': 'goLineStart',
    'Ctrl-E': 'goLineEnd',
    'Ctrl-V': 'goPageDown',
    'Shift-Ctrl-V': 'goPageUp',
    'Ctrl-D': 'delCharAfter',
    'Ctrl-H': 'delCharBefore',
    'Alt-D': 'delWordAfter',
    'Alt-Backspace': 'delWordBefore',
    'Ctrl-K': 'killLine',
    'Ctrl-T': 'transposeChars'
  };
  function getKeyMap(val) {
    if (typeof val == 'string')
      return keyMap[val];
    else
      return val;
  }
  function lookupKey(name, maps, handle) {
    function lookup(map) {
      map = getKeyMap(map);
      var found = map[name];
      if (found === false)
        return 'stop';
      if (found != null && handle(found))
        return true;
      if (map.nofallthrough)
        return 'stop';
      var fallthrough = map.fallthrough;
      if (fallthrough == null)
        return false;
      if (Object.prototype.toString.call(fallthrough) != '[object Array]')
        return lookup(fallthrough);
      for (var i = 0, e = fallthrough.length; i < e; ++i) {
        var done = lookup(fallthrough[i]);
        if (done)
          return done;
      }
      return false;
    }
    for (var i = 0; i < maps.length; ++i) {
      var done = lookup(maps[i]);
      if (done)
        return done;
    }
  }
  function isModifierKey(event) {
    var name = keyNames[event.keyCode];
    return name == 'Ctrl' || name == 'Alt' || name == 'Shift' || name == 'Mod';
  }
  function keyName(event, noShift) {
    if (opera && event.keyCode == 34 && event['char'])
      return false;
    var name = keyNames[event.keyCode];
    if (name == null || event.altGraphKey)
      return false;
    if (event.altKey)
      name = 'Alt-' + name;
    if (flipCtrlCmd ? event.metaKey : event.ctrlKey)
      name = 'Ctrl-' + name;
    if (flipCtrlCmd ? event.ctrlKey : event.metaKey)
      name = 'Cmd-' + name;
    if (!noShift && event.shiftKey)
      name = 'Shift-' + name;
    return name;
  }
  CodeMirror.lookupKey = lookupKey;
  CodeMirror.isModifierKey = isModifierKey;
  CodeMirror.keyName = keyName;
  CodeMirror.fromTextArea = function (textarea, options) {
    if (!options)
      options = {};
    options.value = textarea.value;
    if (!options.tabindex && textarea.tabindex)
      options.tabindex = textarea.tabindex;
    if (!options.placeholder && textarea.placeholder)
      options.placeholder = textarea.placeholder;
    if (options.autofocus == null) {
      var hasFocus = document.body;
      try {
        hasFocus = document.activeElement;
      } catch (e) {
      }
      options.autofocus = hasFocus == textarea || textarea.getAttribute('autofocus') != null && hasFocus == document.body;
    }
    function save() {
      textarea.value = cm.getValue();
    }
    if (textarea.form) {
      on(textarea.form, 'submit', save);
      if (!options.leaveSubmitMethodAlone) {
        var form = textarea.form, realSubmit = form.submit;
        try {
          var wrappedSubmit = form.submit = function () {
              save();
              form.submit = realSubmit;
              form.submit();
              form.submit = wrappedSubmit;
            };
        } catch (e) {
        }
      }
    }
    textarea.style.display = 'none';
    var cm = CodeMirror(function (node) {
        textarea.parentNode.insertBefore(node, textarea.nextSibling);
      }, options);
    cm.save = save;
    cm.getTextArea = function () {
      return textarea;
    };
    cm.toTextArea = function () {
      save();
      textarea.parentNode.removeChild(cm.getWrapperElement());
      textarea.style.display = '';
      if (textarea.form) {
        off(textarea.form, 'submit', save);
        if (typeof textarea.form.submit == 'function')
          textarea.form.submit = realSubmit;
      }
    };
    return cm;
  };
  function StringStream(string, tabSize) {
    this.pos = this.start = 0;
    this.string = string;
    this.tabSize = tabSize || 8;
    this.lastColumnPos = this.lastColumnValue = 0;
  }
  StringStream.prototype = {
    eol: function () {
      return this.pos >= this.string.length;
    },
    sol: function () {
      return this.pos == 0;
    },
    peek: function () {
      return this.string.charAt(this.pos) || undefined;
    },
    next: function () {
      if (this.pos < this.string.length)
        return this.string.charAt(this.pos++);
    },
    eat: function (match) {
      var ch = this.string.charAt(this.pos);
      if (typeof match == 'string')
        var ok = ch == match;
      else
        var ok = ch && (match.test ? match.test(ch) : match(ch));
      if (ok) {
        ++this.pos;
        return ch;
      }
    },
    eatWhile: function (match) {
      var start = this.pos;
      while (this.eat(match)) {
      }
      return this.pos > start;
    },
    eatSpace: function () {
      var start = this.pos;
      while (/[\s\u00a0]/.test(this.string.charAt(this.pos)))
        ++this.pos;
      return this.pos > start;
    },
    skipToEnd: function () {
      this.pos = this.string.length;
    },
    skipTo: function (ch) {
      var found = this.string.indexOf(ch, this.pos);
      if (found > -1) {
        this.pos = found;
        return true;
      }
    },
    backUp: function (n) {
      this.pos -= n;
    },
    column: function () {
      if (this.lastColumnPos < this.start) {
        this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
        this.lastColumnPos = this.start;
      }
      return this.lastColumnValue;
    },
    indentation: function () {
      return countColumn(this.string, null, this.tabSize);
    },
    match: function (pattern, consume, caseInsensitive) {
      if (typeof pattern == 'string') {
        var cased = function (str) {
          return caseInsensitive ? str.toLowerCase() : str;
        };
        var substr = this.string.substr(this.pos, pattern.length);
        if (cased(substr) == cased(pattern)) {
          if (consume !== false)
            this.pos += pattern.length;
          return true;
        }
      } else {
        var match = this.string.slice(this.pos).match(pattern);
        if (match && match.index > 0)
          return null;
        if (match && consume !== false)
          this.pos += match[0].length;
        return match;
      }
    },
    current: function () {
      return this.string.slice(this.start, this.pos);
    }
  };
  CodeMirror.StringStream = StringStream;
  function TextMarker(doc, type) {
    this.lines = [];
    this.type = type;
    this.doc = doc;
  }
  CodeMirror.TextMarker = TextMarker;
  TextMarker.prototype.clear = function () {
    if (this.explicitlyCleared)
      return;
    var cm = this.doc.cm, withOp = cm && !cm.curOp;
    if (withOp)
      startOperation(cm);
    var min = null, max = null;
    for (var i = 0; i < this.lines.length; ++i) {
      var line = this.lines[i];
      var span = getMarkedSpanFor(line.markedSpans, this);
      if (span.to != null)
        max = lineNo(line);
      line.markedSpans = removeMarkedSpan(line.markedSpans, span);
      if (span.from != null)
        min = lineNo(line);
      else if (this.collapsed && !lineIsHidden(this.doc, line) && cm)
        updateLineHeight(line, textHeight(cm.display));
    }
    if (cm && this.collapsed && !cm.options.lineWrapping)
      for (var i = 0; i < this.lines.length; ++i) {
        var visual = visualLine(cm.doc, this.lines[i]), len = lineLength(cm.doc, visual);
        if (len > cm.display.maxLineLength) {
          cm.display.maxLine = visual;
          cm.display.maxLineLength = len;
          cm.display.maxLineChanged = true;
        }
      }
    if (min != null && cm)
      regChange(cm, min, max + 1);
    this.lines.length = 0;
    this.explicitlyCleared = true;
    if (this.collapsed && this.doc.cantEdit) {
      this.doc.cantEdit = false;
      if (cm)
        reCheckSelection(cm);
    }
    if (withOp)
      endOperation(cm);
    signalLater(this, 'clear');
  };
  TextMarker.prototype.find = function () {
    var from, to;
    for (var i = 0; i < this.lines.length; ++i) {
      var line = this.lines[i];
      var span = getMarkedSpanFor(line.markedSpans, this);
      if (span.from != null || span.to != null) {
        var found = lineNo(line);
        if (span.from != null)
          from = Pos(found, span.from);
        if (span.to != null)
          to = Pos(found, span.to);
      }
    }
    if (this.type == 'bookmark')
      return from;
    return from && {
      from: from,
      to: to
    };
  };
  TextMarker.prototype.getOptions = function (copyWidget) {
    var repl = this.replacedWith;
    return {
      className: this.className,
      inclusiveLeft: this.inclusiveLeft,
      inclusiveRight: this.inclusiveRight,
      atomic: this.atomic,
      collapsed: this.collapsed,
      replacedWith: copyWidget ? repl && repl.cloneNode(true) : repl,
      readOnly: this.readOnly,
      startStyle: this.startStyle,
      endStyle: this.endStyle
    };
  };
  TextMarker.prototype.attachLine = function (line) {
    if (!this.lines.length && this.doc.cm) {
      var op = this.doc.cm.curOp;
      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)
        (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);
    }
    this.lines.push(line);
  };
  TextMarker.prototype.detachLine = function (line) {
    this.lines.splice(indexOf(this.lines, line), 1);
    if (!this.lines.length && this.doc.cm) {
      var op = this.doc.cm.curOp;
      (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
    }
  };
  function markText(doc, from, to, options, type) {
    if (options && options.shared)
      return markTextShared(doc, from, to, options, type);
    if (doc.cm && !doc.cm.curOp)
      return operation(doc.cm, markText)(doc, from, to, options, type);
    var marker = new TextMarker(doc, type);
    if (type == 'range' && !posLess(from, to))
      return marker;
    if (options)
      copyObj(options, marker);
    if (marker.replacedWith) {
      marker.collapsed = true;
      marker.replacedWith = elt('span', [marker.replacedWith], 'CodeMirror-widget');
    }
    if (marker.collapsed)
      sawCollapsedSpans = true;
    if (marker.addToHistory)
      addToHistory(doc, {
        from: from,
        to: to,
        origin: 'markText'
      }, {
        head: doc.sel.head,
        anchor: doc.sel.anchor
      }, NaN);
    var curLine = from.line, size = 0, collapsedAtStart, collapsedAtEnd, cm = doc.cm, updateMaxLine;
    doc.iter(curLine, to.line + 1, function (line) {
      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(doc, line) == cm.display.maxLine)
        updateMaxLine = true;
      var span = {
          from: null,
          to: null,
          marker: marker
        };
      size += line.text.length;
      if (curLine == from.line) {
        span.from = from.ch;
        size -= from.ch;
      }
      if (curLine == to.line) {
        span.to = to.ch;
        size -= line.text.length - to.ch;
      }
      if (marker.collapsed) {
        if (curLine == to.line)
          collapsedAtEnd = collapsedSpanAt(line, to.ch);
        if (curLine == from.line)
          collapsedAtStart = collapsedSpanAt(line, from.ch);
        else
          updateLineHeight(line, 0);
      }
      addMarkedSpan(line, span);
      ++curLine;
    });
    if (marker.collapsed)
      doc.iter(from.line, to.line + 1, function (line) {
        if (lineIsHidden(doc, line))
          updateLineHeight(line, 0);
      });
    if (marker.clearOnEnter)
      on(marker, 'beforeCursorEnter', function () {
        marker.clear();
      });
    if (marker.readOnly) {
      sawReadOnlySpans = true;
      if (doc.history.done.length || doc.history.undone.length)
        doc.clearHistory();
    }
    if (marker.collapsed) {
      if (collapsedAtStart != collapsedAtEnd)
        throw new Error('Inserting collapsed marker overlapping an existing one');
      marker.size = size;
      marker.atomic = true;
    }
    if (cm) {
      if (updateMaxLine)
        cm.curOp.updateMaxLine = true;
      if (marker.className || marker.startStyle || marker.endStyle || marker.collapsed)
        regChange(cm, from.line, to.line + 1);
      if (marker.atomic)
        reCheckSelection(cm);
    }
    return marker;
  }
  function SharedTextMarker(markers, primary) {
    this.markers = markers;
    this.primary = primary;
    for (var i = 0, me = this; i < markers.length; ++i) {
      markers[i].parent = this;
      on(markers[i], 'clear', function () {
        me.clear();
      });
    }
  }
  CodeMirror.SharedTextMarker = SharedTextMarker;
  SharedTextMarker.prototype.clear = function () {
    if (this.explicitlyCleared)
      return;
    this.explicitlyCleared = true;
    for (var i = 0; i < this.markers.length; ++i)
      this.markers[i].clear();
    signalLater(this, 'clear');
  };
  SharedTextMarker.prototype.find = function () {
    return this.primary.find();
  };
  SharedTextMarker.prototype.getOptions = function (copyWidget) {
    var inner = this.primary.getOptions(copyWidget);
    inner.shared = true;
    return inner;
  };
  function markTextShared(doc, from, to, options, type) {
    options = copyObj(options);
    options.shared = false;
    var markers = [markText(doc, from, to, options, type)], primary = markers[0];
    var widget = options.replacedWith;
    linkedDocs(doc, function (doc) {
      if (widget)
        options.replacedWith = widget.cloneNode(true);
      markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));
      for (var i = 0; i < doc.linked.length; ++i)
        if (doc.linked[i].isParent)
          return;
      primary = lst(markers);
    });
    return new SharedTextMarker(markers, primary);
  }
  function getMarkedSpanFor(spans, marker) {
    if (spans)
      for (var i = 0; i < spans.length; ++i) {
        var span = spans[i];
        if (span.marker == marker)
          return span;
      }
  }
  function removeMarkedSpan(spans, span) {
    for (var r, i = 0; i < spans.length; ++i)
      if (spans[i] != span)
        (r || (r = [])).push(spans[i]);
    return r;
  }
  function addMarkedSpan(line, span) {
    line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
    span.marker.attachLine(line);
  }
  function markedSpansBefore(old, startCh, isInsert) {
    if (old)
      for (var i = 0, nw; i < old.length; ++i) {
        var span = old[i], marker = span.marker;
        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
        if (startsBefore || marker.type == 'bookmark' && span.from == startCh && (!isInsert || !span.marker.insertLeft)) {
          var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);
          (nw || (nw = [])).push({
            from: span.from,
            to: endsAfter ? null : span.to,
            marker: marker
          });
        }
      }
    return nw;
  }
  function markedSpansAfter(old, endCh, isInsert) {
    if (old)
      for (var i = 0, nw; i < old.length; ++i) {
        var span = old[i], marker = span.marker;
        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
        if (endsAfter || marker.type == 'bookmark' && span.from == endCh && (!isInsert || span.marker.insertLeft)) {
          var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);
          (nw || (nw = [])).push({
            from: startsBefore ? null : span.from - endCh,
            to: span.to == null ? null : span.to - endCh,
            marker: marker
          });
        }
      }
    return nw;
  }
  function stretchSpansOverChange(doc, change) {
    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;
    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;
    if (!oldFirst && !oldLast)
      return null;
    var startCh = change.from.ch, endCh = change.to.ch, isInsert = posEq(change.from, change.to);
    var first = markedSpansBefore(oldFirst, startCh, isInsert);
    var last = markedSpansAfter(oldLast, endCh, isInsert);
    var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);
    if (first) {
      for (var i = 0; i < first.length; ++i) {
        var span = first[i];
        if (span.to == null) {
          var found = getMarkedSpanFor(last, span.marker);
          if (!found)
            span.to = startCh;
          else if (sameLine)
            span.to = found.to == null ? null : found.to + offset;
        }
      }
    }
    if (last) {
      for (var i = 0; i < last.length; ++i) {
        var span = last[i];
        if (span.to != null)
          span.to += offset;
        if (span.from == null) {
          var found = getMarkedSpanFor(first, span.marker);
          if (!found) {
            span.from = offset;
            if (sameLine)
              (first || (first = [])).push(span);
          }
        } else {
          span.from += offset;
          if (sameLine)
            (first || (first = [])).push(span);
        }
      }
    }
    var newMarkers = [first];
    if (!sameLine) {
      var gap = change.text.length - 2, gapMarkers;
      if (gap > 0 && first)
        for (var i = 0; i < first.length; ++i)
          if (first[i].to == null)
            (gapMarkers || (gapMarkers = [])).push({
              from: null,
              to: null,
              marker: first[i].marker
            });
      for (var i = 0; i < gap; ++i)
        newMarkers.push(gapMarkers);
      newMarkers.push(last);
    }
    return newMarkers;
  }
  function mergeOldSpans(doc, change) {
    var old = getOldSpans(doc, change);
    var stretched = stretchSpansOverChange(doc, change);
    if (!old)
      return stretched;
    if (!stretched)
      return old;
    for (var i = 0; i < old.length; ++i) {
      var oldCur = old[i], stretchCur = stretched[i];
      if (oldCur && stretchCur) {
        spans:
          for (var j = 0; j < stretchCur.length; ++j) {
            var span = stretchCur[j];
            for (var k = 0; k < oldCur.length; ++k)
              if (oldCur[k].marker == span.marker)
                continue spans;
            oldCur.push(span);
          }
      } else if (stretchCur) {
        old[i] = stretchCur;
      }
    }
    return old;
  }
  function removeReadOnlyRanges(doc, from, to) {
    var markers = null;
    doc.iter(from.line, to.line + 1, function (line) {
      if (line.markedSpans)
        for (var i = 0; i < line.markedSpans.length; ++i) {
          var mark = line.markedSpans[i].marker;
          if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))
            (markers || (markers = [])).push(mark);
        }
    });
    if (!markers)
      return null;
    var parts = [{
          from: from,
          to: to
        }];
    for (var i = 0; i < markers.length; ++i) {
      var mk = markers[i], m = mk.find();
      for (var j = 0; j < parts.length; ++j) {
        var p = parts[j];
        if (posLess(p.to, m.from) || posLess(m.to, p.from))
          continue;
        var newParts = [
            j,
            1
          ];
        if (posLess(p.from, m.from) || !mk.inclusiveLeft && posEq(p.from, m.from))
          newParts.push({
            from: p.from,
            to: m.from
          });
        if (posLess(m.to, p.to) || !mk.inclusiveRight && posEq(p.to, m.to))
          newParts.push({
            from: m.to,
            to: p.to
          });
        parts.splice.apply(parts, newParts);
        j += newParts.length - 1;
      }
    }
    return parts;
  }
  function collapsedSpanAt(line, ch) {
    var sps = sawCollapsedSpans && line.markedSpans, found;
    if (sps)
      for (var sp, i = 0; i < sps.length; ++i) {
        sp = sps[i];
        if (!sp.marker.collapsed)
          continue;
        if ((sp.from == null || sp.from < ch) && (sp.to == null || sp.to > ch) && (!found || found.width < sp.marker.width))
          found = sp.marker;
      }
    return found;
  }
  function collapsedSpanAtStart(line) {
    return collapsedSpanAt(line, -1);
  }
  function collapsedSpanAtEnd(line) {
    return collapsedSpanAt(line, line.text.length + 1);
  }
  function visualLine(doc, line) {
    var merged;
    while (merged = collapsedSpanAtStart(line))
      line = getLine(doc, merged.find().from.line);
    return line;
  }
  function lineIsHidden(doc, line) {
    var sps = sawCollapsedSpans && line.markedSpans;
    if (sps)
      for (var sp, i = 0; i < sps.length; ++i) {
        sp = sps[i];
        if (!sp.marker.collapsed)
          continue;
        if (sp.from == null)
          return true;
        if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))
          return true;
      }
  }
  function lineIsHiddenInner(doc, line, span) {
    if (span.to == null) {
      var end = span.marker.find().to, endLine = getLine(doc, end.line);
      return lineIsHiddenInner(doc, endLine, getMarkedSpanFor(endLine.markedSpans, span.marker));
    }
    if (span.marker.inclusiveRight && span.to == line.text.length)
      return true;
    for (var sp, i = 0; i < line.markedSpans.length; ++i) {
      sp = line.markedSpans[i];
      if (sp.marker.collapsed && sp.from == span.to && (sp.marker.inclusiveLeft || span.marker.inclusiveRight) && lineIsHiddenInner(doc, line, sp))
        return true;
    }
  }
  function detachMarkedSpans(line) {
    var spans = line.markedSpans;
    if (!spans)
      return;
    for (var i = 0; i < spans.length; ++i)
      spans[i].marker.detachLine(line);
    line.markedSpans = null;
  }
  function attachMarkedSpans(line, spans) {
    if (!spans)
      return;
    for (var i = 0; i < spans.length; ++i)
      spans[i].marker.attachLine(line);
    line.markedSpans = spans;
  }
  var LineWidget = CodeMirror.LineWidget = function (cm, node, options) {
      for (var opt in options)
        if (options.hasOwnProperty(opt))
          this[opt] = options[opt];
      this.cm = cm;
      this.node = node;
    };
  function widgetOperation(f) {
    return function () {
      var withOp = !this.cm.curOp;
      if (withOp)
        startOperation(this.cm);
      try {
        var result = f.apply(this, arguments);
      } finally {
        if (withOp)
          endOperation(this.cm);
      }
      return result;
    };
  }
  LineWidget.prototype.clear = widgetOperation(function () {
    var ws = this.line.widgets, no = lineNo(this.line);
    if (no == null || !ws)
      return;
    for (var i = 0; i < ws.length; ++i)
      if (ws[i] == this)
        ws.splice(i--, 1);
    if (!ws.length)
      this.line.widgets = null;
    updateLineHeight(this.line, Math.max(0, this.line.height - widgetHeight(this)));
    regChange(this.cm, no, no + 1);
  });
  LineWidget.prototype.changed = widgetOperation(function () {
    var oldH = this.height;
    this.height = null;
    var diff = widgetHeight(this) - oldH;
    if (!diff)
      return;
    updateLineHeight(this.line, this.line.height + diff);
    var no = lineNo(this.line);
    regChange(this.cm, no, no + 1);
  });
  function widgetHeight(widget) {
    if (widget.height != null)
      return widget.height;
    if (!widget.node.parentNode || widget.node.parentNode.nodeType != 1)
      removeChildrenAndAdd(widget.cm.display.measure, elt('div', [widget.node], null, 'position: relative'));
    return widget.height = widget.node.offsetHeight;
  }
  function addLineWidget(cm, handle, node, options) {
    var widget = new LineWidget(cm, node, options);
    if (widget.noHScroll)
      cm.display.alignWidgets = true;
    changeLine(cm, handle, function (line) {
      (line.widgets || (line.widgets = [])).push(widget);
      widget.line = line;
      if (!lineIsHidden(cm.doc, line) || widget.showIfHidden) {
        var aboveVisible = heightAtLine(cm, line) < cm.display.scroller.scrollTop;
        updateLineHeight(line, line.height + widgetHeight(widget));
        if (aboveVisible)
          addToScrollPos(cm, 0, widget.height);
      }
      return true;
    });
    return widget;
  }
  function makeLine(text, markedSpans, estimateHeight) {
    var line = { text: text };
    attachMarkedSpans(line, markedSpans);
    line.height = estimateHeight ? estimateHeight(line) : 1;
    return line;
  }
  function updateLine(line, text, markedSpans, estimateHeight) {
    line.text = text;
    if (line.stateAfter)
      line.stateAfter = null;
    if (line.styles)
      line.styles = null;
    if (line.order != null)
      line.order = null;
    detachMarkedSpans(line);
    attachMarkedSpans(line, markedSpans);
    var estHeight = estimateHeight ? estimateHeight(line) : 1;
    if (estHeight != line.height)
      updateLineHeight(line, estHeight);
  }
  function cleanUpLine(line) {
    line.parent = null;
    detachMarkedSpans(line);
  }
  function runMode(cm, text, mode, state, f) {
    var flattenSpans = mode.flattenSpans;
    if (flattenSpans == null)
      flattenSpans = cm.options.flattenSpans;
    var curText = '', curStyle = null;
    var stream = new StringStream(text, cm.options.tabSize), style;
    if (text == '' && mode.blankLine)
      mode.blankLine(state);
    while (!stream.eol()) {
      if (stream.pos > cm.options.maxHighlightLength) {
        flattenSpans = false;
        stream.pos = Math.min(text.length, stream.start + 50000);
        style = null;
      } else {
        style = mode.token(stream, state);
      }
      var substr = stream.current();
      stream.start = stream.pos;
      if (!flattenSpans || curStyle != style) {
        if (curText)
          f(curText, curStyle);
        curText = substr;
        curStyle = style;
      } else
        curText = curText + substr;
    }
    if (curText)
      f(curText, curStyle);
  }
  function highlightLine(cm, line, state) {
    var st = [cm.state.modeGen];
    runMode(cm, line.text, cm.doc.mode, state, function (txt, style) {
      st.push(txt, style);
    });
    for (var o = 0; o < cm.state.overlays.length; ++o) {
      var overlay = cm.state.overlays[o], i = 1;
      runMode(cm, line.text, overlay.mode, true, function (txt, style) {
        var start = i, len = txt.length;
        while (len) {
          var cur = st[i], len_ = cur.length;
          if (len_ <= len) {
            len -= len_;
          } else {
            st.splice(i, 1, cur.slice(0, len), st[i + 1], cur.slice(len));
            len = 0;
          }
          i += 2;
        }
        if (!style)
          return;
        if (overlay.opaque) {
          st.splice(start, i - start, txt, style);
          i = start + 2;
        } else {
          for (; start < i; start += 2) {
            var cur = st[start + 1];
            st[start + 1] = cur ? cur + ' ' + style : style;
          }
        }
      });
    }
    return st;
  }
  function getLineStyles(cm, line) {
    if (!line.styles || line.styles[0] != cm.state.modeGen)
      line.styles = highlightLine(cm, line, line.stateAfter = getStateBefore(cm, lineNo(line)));
    return line.styles;
  }
  function processLine(cm, line, state) {
    var mode = cm.doc.mode;
    var stream = new StringStream(line.text, cm.options.tabSize);
    if (line.text == '' && mode.blankLine)
      mode.blankLine(state);
    while (!stream.eol() && stream.pos <= cm.options.maxHighlightLength) {
      mode.token(stream, state);
      stream.start = stream.pos;
    }
  }
  var styleToClassCache = {};
  function styleToClass(style) {
    if (!style)
      return null;
    return styleToClassCache[style] || (styleToClassCache[style] = 'cm-' + style.replace(/ +/g, ' cm-'));
  }
  function lineContent(cm, realLine, measure) {
    var merged, line = realLine, lineBefore, sawBefore, simple = true;
    while (merged = collapsedSpanAtStart(line)) {
      simple = false;
      line = getLine(cm.doc, merged.find().from.line);
      if (!lineBefore)
        lineBefore = line;
    }
    var builder = {
        pre: elt('pre'),
        col: 0,
        pos: 0,
        display: !measure,
        measure: null,
        addedOne: false,
        cm: cm
      };
    if (line.textClass)
      builder.pre.className = line.textClass;
    do {
      builder.measure = line == realLine && measure;
      builder.pos = 0;
      builder.addToken = builder.measure ? buildTokenMeasure : buildToken;
      if ((ie || webkit) && cm.getOption('lineWrapping'))
        builder.addToken = buildTokenSplitSpaces(builder.addToken);
      if (measure && sawBefore && line != realLine && !builder.addedOne) {
        measure[0] = builder.pre.appendChild(zeroWidthElement(cm.display.measure));
        builder.addedOne = true;
      }
      var next = insertLineContent(line, builder, getLineStyles(cm, line));
      sawBefore = line == lineBefore;
      if (next) {
        line = getLine(cm.doc, next.to.line);
        simple = false;
      }
    } while (next);
    if (measure && !builder.addedOne)
      measure[0] = builder.pre.appendChild(simple ? elt('span', '\xa0') : zeroWidthElement(cm.display.measure));
    if (!builder.pre.firstChild && !lineIsHidden(cm.doc, realLine))
      builder.pre.appendChild(document.createTextNode('\xa0'));
    var order;
    if (measure && ie && (order = getOrder(line))) {
      var l = order.length - 1;
      if (order[l].from == order[l].to)
        --l;
      var last = order[l], prev = order[l - 1];
      if (last.from + 1 == last.to && prev && last.level < prev.level) {
        var span = measure[builder.pos - 1];
        if (span)
          span.parentNode.insertBefore(span.measureRight = zeroWidthElement(cm.display.measure), span.nextSibling);
      }
    }
    signal(cm, 'renderLine', cm, realLine, builder.pre);
    return builder.pre;
  }
  var tokenSpecialChars = /[\t\u0000-\u0019\u00ad\u200b\u2028\u2029\uFEFF]/g;
  function buildToken(builder, text, style, startStyle, endStyle) {
    if (!text)
      return;
    if (!tokenSpecialChars.test(text)) {
      builder.col += text.length;
      var content = document.createTextNode(text);
    } else {
      var content = document.createDocumentFragment(), pos = 0;
      while (true) {
        tokenSpecialChars.lastIndex = pos;
        var m = tokenSpecialChars.exec(text);
        var skipped = m ? m.index - pos : text.length - pos;
        if (skipped) {
          content.appendChild(document.createTextNode(text.slice(pos, pos + skipped)));
          builder.col += skipped;
        }
        if (!m)
          break;
        pos += skipped + 1;
        if (m[0] == '\t') {
          var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;
          content.appendChild(elt('span', spaceStr(tabWidth), 'cm-tab'));
          builder.col += tabWidth;
        } else {
          var token = elt('span', '\u2022', 'cm-invalidchar');
          token.title = '\\u' + m[0].charCodeAt(0).toString(16);
          content.appendChild(token);
          builder.col += 1;
        }
      }
    }
    if (style || startStyle || endStyle || builder.measure) {
      var fullStyle = style || '';
      if (startStyle)
        fullStyle += startStyle;
      if (endStyle)
        fullStyle += endStyle;
      return builder.pre.appendChild(elt('span', [content], fullStyle));
    }
    builder.pre.appendChild(content);
  }
  function buildTokenMeasure(builder, text, style, startStyle, endStyle) {
    var wrapping = builder.cm.options.lineWrapping;
    for (var i = 0; i < text.length; ++i) {
      var ch = text.charAt(i), start = i == 0;
      if (ch >= '\ud800' && ch < '\udbff' && i < text.length - 1) {
        ch = text.slice(i, i + 2);
        ++i;
      } else if (i && wrapping && spanAffectsWrapping.test(text.slice(i - 1, i + 1))) {
        builder.pre.appendChild(elt('wbr'));
      }
      var span = builder.measure[builder.pos] = buildToken(builder, ch, style, start && startStyle, i == text.length - 1 && endStyle);
      if (ie && wrapping && ch == ' ' && i && !/\s/.test(text.charAt(i - 1)) && i < text.length - 1 && !/\s/.test(text.charAt(i + 1)))
        span.style.whiteSpace = 'normal';
      builder.pos += ch.length;
    }
    if (text.length)
      builder.addedOne = true;
  }
  function buildTokenSplitSpaces(inner) {
    function split(old) {
      var out = ' ';
      for (var i = 0; i < old.length - 2; ++i)
        out += i % 2 ? ' ' : '\xa0';
      out += ' ';
      return out;
    }
    return function (builder, text, style, startStyle, endStyle) {
      return inner(builder, text.replace(/ {3,}/, split), style, startStyle, endStyle);
    };
  }
  function buildCollapsedSpan(builder, size, widget) {
    if (widget) {
      if (!builder.display)
        widget = widget.cloneNode(true);
      builder.pre.appendChild(widget);
      if (builder.measure && size) {
        builder.measure[builder.pos] = widget;
        builder.addedOne = true;
      }
    }
    builder.pos += size;
  }
  function insertLineContent(line, builder, styles) {
    var spans = line.markedSpans;
    if (!spans) {
      for (var i = 1; i < styles.length; i += 2)
        builder.addToken(builder, styles[i], styleToClass(styles[i + 1]));
      return;
    }
    var allText = line.text, len = allText.length;
    var pos = 0, i = 1, text = '', style;
    var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, collapsed;
    for (;;) {
      if (nextChange == pos) {
        spanStyle = spanEndStyle = spanStartStyle = '';
        collapsed = null;
        nextChange = Infinity;
        var foundBookmark = null;
        for (var j = 0; j < spans.length; ++j) {
          var sp = spans[j], m = sp.marker;
          if (sp.from <= pos && (sp.to == null || sp.to > pos)) {
            if (sp.to != null && nextChange > sp.to) {
              nextChange = sp.to;
              spanEndStyle = '';
            }
            if (m.className)
              spanStyle += ' ' + m.className;
            if (m.startStyle && sp.from == pos)
              spanStartStyle += ' ' + m.startStyle;
            if (m.endStyle && sp.to == nextChange)
              spanEndStyle += ' ' + m.endStyle;
            if (m.collapsed && (!collapsed || collapsed.marker.width < m.width))
              collapsed = sp;
          } else if (sp.from > pos && nextChange > sp.from) {
            nextChange = sp.from;
          }
          if (m.type == 'bookmark' && sp.from == pos && m.replacedWith)
            foundBookmark = m.replacedWith;
        }
        if (collapsed && (collapsed.from || 0) == pos) {
          buildCollapsedSpan(builder, (collapsed.to == null ? len : collapsed.to) - pos, collapsed.from != null && collapsed.marker.replacedWith);
          if (collapsed.to == null)
            return collapsed.marker.find();
        }
        if (foundBookmark && !collapsed)
          buildCollapsedSpan(builder, 0, foundBookmark);
      }
      if (pos >= len)
        break;
      var upto = Math.min(len, nextChange);
      while (true) {
        if (text) {
          var end = pos + text.length;
          if (!collapsed) {
            var tokenText = end > upto ? text.slice(0, upto - pos) : text;
            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle, spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : '');
          }
          if (end >= upto) {
            text = text.slice(upto - pos);
            pos = upto;
            break;
          }
          pos = end;
          spanStartStyle = '';
        }
        text = styles[i++];
        style = styleToClass(styles[i++]);
      }
    }
  }
  function updateDoc(doc, change, markedSpans, selAfter, estimateHeight) {
    function spansFor(n) {
      return markedSpans ? markedSpans[n] : null;
    }
    function update(line, text, spans) {
      updateLine(line, text, spans, estimateHeight);
      signalLater(line, 'change', line, change);
    }
    var from = change.from, to = change.to, text = change.text;
    var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);
    var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;
    if (from.ch == 0 && to.ch == 0 && lastText == '') {
      for (var i = 0, e = text.length - 1, added = []; i < e; ++i)
        added.push(makeLine(text[i], spansFor(i), estimateHeight));
      update(lastLine, lastLine.text, lastSpans);
      if (nlines)
        doc.remove(from.line, nlines);
      if (added.length)
        doc.insert(from.line, added);
    } else if (firstLine == lastLine) {
      if (text.length == 1) {
        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
      } else {
        for (var added = [], i = 1, e = text.length - 1; i < e; ++i)
          added.push(makeLine(text[i], spansFor(i), estimateHeight));
        added.push(makeLine(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));
        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
        doc.insert(from.line + 1, added);
      }
    } else if (text.length == 1) {
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));
      doc.remove(from.line + 1, nlines);
    } else {
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
      for (var i = 1, e = text.length - 1, added = []; i < e; ++i)
        added.push(makeLine(text[i], spansFor(i), estimateHeight));
      if (nlines > 1)
        doc.remove(from.line + 1, nlines - 1);
      doc.insert(from.line + 1, added);
    }
    signalLater(doc, 'change', doc, change);
    setSelection(doc, selAfter.anchor, selAfter.head, null, true);
  }
  function LeafChunk(lines) {
    this.lines = lines;
    this.parent = null;
    for (var i = 0, e = lines.length, height = 0; i < e; ++i) {
      lines[i].parent = this;
      height += lines[i].height;
    }
    this.height = height;
  }
  LeafChunk.prototype = {
    chunkSize: function () {
      return this.lines.length;
    },
    removeInner: function (at, n) {
      for (var i = at, e = at + n; i < e; ++i) {
        var line = this.lines[i];
        this.height -= line.height;
        cleanUpLine(line);
        signalLater(line, 'delete');
      }
      this.lines.splice(at, n);
    },
    collapse: function (lines) {
      lines.splice.apply(lines, [
        lines.length,
        0
      ].concat(this.lines));
    },
    insertInner: function (at, lines, height) {
      this.height += height;
      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
      for (var i = 0, e = lines.length; i < e; ++i)
        lines[i].parent = this;
    },
    iterN: function (at, n, op) {
      for (var e = at + n; at < e; ++at)
        if (op(this.lines[at]))
          return true;
    }
  };
  function BranchChunk(children) {
    this.children = children;
    var size = 0, height = 0;
    for (var i = 0, e = children.length; i < e; ++i) {
      var ch = children[i];
      size += ch.chunkSize();
      height += ch.height;
      ch.parent = this;
    }
    this.size = size;
    this.height = height;
    this.parent = null;
  }
  BranchChunk.prototype = {
    chunkSize: function () {
      return this.size;
    },
    removeInner: function (at, n) {
      this.size -= n;
      for (var i = 0; i < this.children.length; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at < sz) {
          var rm = Math.min(n, sz - at), oldHeight = child.height;
          child.removeInner(at, rm);
          this.height -= oldHeight - child.height;
          if (sz == rm) {
            this.children.splice(i--, 1);
            child.parent = null;
          }
          if ((n -= rm) == 0)
            break;
          at = 0;
        } else
          at -= sz;
      }
      if (this.size - n < 25) {
        var lines = [];
        this.collapse(lines);
        this.children = [new LeafChunk(lines)];
        this.children[0].parent = this;
      }
    },
    collapse: function (lines) {
      for (var i = 0, e = this.children.length; i < e; ++i)
        this.children[i].collapse(lines);
    },
    insertInner: function (at, lines, height) {
      this.size += lines.length;
      this.height += height;
      for (var i = 0, e = this.children.length; i < e; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at <= sz) {
          child.insertInner(at, lines, height);
          if (child.lines && child.lines.length > 50) {
            while (child.lines.length > 50) {
              var spilled = child.lines.splice(child.lines.length - 25, 25);
              var newleaf = new LeafChunk(spilled);
              child.height -= newleaf.height;
              this.children.splice(i + 1, 0, newleaf);
              newleaf.parent = this;
            }
            this.maybeSpill();
          }
          break;
        }
        at -= sz;
      }
    },
    maybeSpill: function () {
      if (this.children.length <= 10)
        return;
      var me = this;
      do {
        var spilled = me.children.splice(me.children.length - 5, 5);
        var sibling = new BranchChunk(spilled);
        if (!me.parent) {
          var copy = new BranchChunk(me.children);
          copy.parent = me;
          me.children = [
            copy,
            sibling
          ];
          me = copy;
        } else {
          me.size -= sibling.size;
          me.height -= sibling.height;
          var myIndex = indexOf(me.parent.children, me);
          me.parent.children.splice(myIndex + 1, 0, sibling);
        }
        sibling.parent = me.parent;
      } while (me.children.length > 10);
      me.parent.maybeSpill();
    },
    iterN: function (at, n, op) {
      for (var i = 0, e = this.children.length; i < e; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at < sz) {
          var used = Math.min(n, sz - at);
          if (child.iterN(at, used, op))
            return true;
          if ((n -= used) == 0)
            break;
          at = 0;
        } else
          at -= sz;
      }
    }
  };
  var nextDocId = 0;
  var Doc = CodeMirror.Doc = function (text, mode, firstLine) {
      if (!(this instanceof Doc))
        return new Doc(text, mode, firstLine);
      if (firstLine == null)
        firstLine = 0;
      BranchChunk.call(this, [new LeafChunk([makeLine('', null)])]);
      this.first = firstLine;
      this.scrollTop = this.scrollLeft = 0;
      this.cantEdit = false;
      this.history = makeHistory();
      this.frontier = firstLine;
      var start = Pos(firstLine, 0);
      this.sel = {
        from: start,
        to: start,
        head: start,
        anchor: start,
        shift: false,
        extend: false,
        goalColumn: null
      };
      this.id = ++nextDocId;
      this.modeOption = mode;
      if (typeof text == 'string')
        text = splitLines(text);
      updateDoc(this, {
        from: start,
        to: start,
        text: text
      }, null, {
        head: start,
        anchor: start
      });
    };
  Doc.prototype = createObj(BranchChunk.prototype, {
    iter: function (from, to, op) {
      if (op)
        this.iterN(from - this.first, to - from, op);
      else
        this.iterN(this.first, this.first + this.size, from);
    },
    insert: function (at, lines) {
      var height = 0;
      for (var i = 0, e = lines.length; i < e; ++i)
        height += lines[i].height;
      this.insertInner(at - this.first, lines, height);
    },
    remove: function (at, n) {
      this.removeInner(at - this.first, n);
    },
    getValue: function (lineSep) {
      var lines = getLines(this, this.first, this.first + this.size);
      if (lineSep === false)
        return lines;
      return lines.join(lineSep || '\n');
    },
    setValue: function (code) {
      var top = Pos(this.first, 0), last = this.first + this.size - 1;
      makeChange(this, {
        from: top,
        to: Pos(last, getLine(this, last).text.length),
        text: splitLines(code),
        origin: 'setValue'
      }, {
        head: top,
        anchor: top
      }, true);
    },
    replaceRange: function (code, from, to, origin) {
      from = clipPos(this, from);
      to = to ? clipPos(this, to) : from;
      replaceRange(this, code, from, to, origin);
    },
    getRange: function (from, to, lineSep) {
      var lines = getBetween(this, clipPos(this, from), clipPos(this, to));
      if (lineSep === false)
        return lines;
      return lines.join(lineSep || '\n');
    },
    getLine: function (line) {
      var l = this.getLineHandle(line);
      return l && l.text;
    },
    setLine: function (line, text) {
      if (isLine(this, line))
        replaceRange(this, text, Pos(line, 0), clipPos(this, Pos(line)));
    },
    removeLine: function (line) {
      if (line)
        replaceRange(this, '', clipPos(this, Pos(line - 1)), clipPos(this, Pos(line)));
      else
        replaceRange(this, '', Pos(0, 0), clipPos(this, Pos(1, 0)));
    },
    getLineHandle: function (line) {
      if (isLine(this, line))
        return getLine(this, line);
    },
    getLineNumber: function (line) {
      return lineNo(line);
    },
    lineCount: function () {
      return this.size;
    },
    firstLine: function () {
      return this.first;
    },
    lastLine: function () {
      return this.first + this.size - 1;
    },
    clipPos: function (pos) {
      return clipPos(this, pos);
    },
    getCursor: function (start) {
      var sel = this.sel, pos;
      if (start == null || start == 'head')
        pos = sel.head;
      else if (start == 'anchor')
        pos = sel.anchor;
      else if (start == 'end' || start === false)
        pos = sel.to;
      else
        pos = sel.from;
      return copyPos(pos);
    },
    somethingSelected: function () {
      return !posEq(this.sel.head, this.sel.anchor);
    },
    setCursor: docOperation(function (line, ch, extend) {
      var pos = clipPos(this, typeof line == 'number' ? Pos(line, ch || 0) : line);
      if (extend)
        extendSelection(this, pos);
      else
        setSelection(this, pos, pos);
    }),
    setSelection: docOperation(function (anchor, head) {
      setSelection(this, clipPos(this, anchor), clipPos(this, head || anchor));
    }),
    extendSelection: docOperation(function (from, to) {
      extendSelection(this, clipPos(this, from), to && clipPos(this, to));
    }),
    getSelection: function (lineSep) {
      return this.getRange(this.sel.from, this.sel.to, lineSep);
    },
    replaceSelection: function (code, collapse, origin) {
      makeChange(this, {
        from: this.sel.from,
        to: this.sel.to,
        text: splitLines(code),
        origin: origin
      }, collapse || 'around');
    },
    undo: docOperation(function () {
      makeChangeFromHistory(this, 'undo');
    }),
    redo: docOperation(function () {
      makeChangeFromHistory(this, 'redo');
    }),
    setExtending: function (val) {
      this.sel.extend = val;
    },
    historySize: function () {
      var hist = this.history;
      return {
        undo: hist.done.length,
        redo: hist.undone.length
      };
    },
    clearHistory: function () {
      this.history = makeHistory();
    },
    markClean: function () {
      this.history.dirtyCounter = 0;
      this.history.lastOp = this.history.lastOrigin = null;
    },
    isClean: function () {
      return this.history.dirtyCounter == 0;
    },
    getHistory: function () {
      return {
        done: copyHistoryArray(this.history.done),
        undone: copyHistoryArray(this.history.undone)
      };
    },
    setHistory: function (histData) {
      var hist = this.history = makeHistory();
      hist.done = histData.done.slice(0);
      hist.undone = histData.undone.slice(0);
    },
    markText: function (from, to, options) {
      return markText(this, clipPos(this, from), clipPos(this, to), options, 'range');
    },
    setBookmark: function (pos, options) {
      var realOpts = {
          replacedWith: options && (options.nodeType == null ? options.widget : options),
          insertLeft: options && options.insertLeft
        };
      pos = clipPos(this, pos);
      return markText(this, pos, pos, realOpts, 'bookmark');
    },
    findMarksAt: function (pos) {
      pos = clipPos(this, pos);
      var markers = [], spans = getLine(this, pos.line).markedSpans;
      if (spans)
        for (var i = 0; i < spans.length; ++i) {
          var span = spans[i];
          if ((span.from == null || span.from <= pos.ch) && (span.to == null || span.to >= pos.ch))
            markers.push(span.marker.parent || span.marker);
        }
      return markers;
    },
    getAllMarks: function () {
      var markers = [];
      this.iter(function (line) {
        var sps = line.markedSpans;
        if (sps)
          for (var i = 0; i < sps.length; ++i)
            if (sps[i].from != null)
              markers.push(sps[i].marker);
      });
      return markers;
    },
    posFromIndex: function (off) {
      var ch, lineNo = this.first;
      this.iter(function (line) {
        var sz = line.text.length + 1;
        if (sz > off) {
          ch = off;
          return true;
        }
        off -= sz;
        ++lineNo;
      });
      return clipPos(this, Pos(lineNo, ch));
    },
    indexFromPos: function (coords) {
      coords = clipPos(this, coords);
      var index = coords.ch;
      if (coords.line < this.first || coords.ch < 0)
        return 0;
      this.iter(this.first, coords.line, function (line) {
        index += line.text.length + 1;
      });
      return index;
    },
    copy: function (copyHistory) {
      var doc = new Doc(getLines(this, this.first, this.first + this.size), this.modeOption, this.first);
      doc.scrollTop = this.scrollTop;
      doc.scrollLeft = this.scrollLeft;
      doc.sel = {
        from: this.sel.from,
        to: this.sel.to,
        head: this.sel.head,
        anchor: this.sel.anchor,
        shift: this.sel.shift,
        extend: false,
        goalColumn: this.sel.goalColumn
      };
      if (copyHistory) {
        doc.history.undoDepth = this.history.undoDepth;
        doc.setHistory(this.getHistory());
      }
      return doc;
    },
    linkedDoc: function (options) {
      if (!options)
        options = {};
      var from = this.first, to = this.first + this.size;
      if (options.from != null && options.from > from)
        from = options.from;
      if (options.to != null && options.to < to)
        to = options.to;
      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from);
      if (options.sharedHist)
        copy.history = this.history;
      (this.linked || (this.linked = [])).push({
        doc: copy,
        sharedHist: options.sharedHist
      });
      copy.linked = [{
          doc: this,
          isParent: true,
          sharedHist: options.sharedHist
        }];
      return copy;
    },
    unlinkDoc: function (other) {
      if (other instanceof CodeMirror)
        other = other.doc;
      if (this.linked)
        for (var i = 0; i < this.linked.length; ++i) {
          var link = this.linked[i];
          if (link.doc != other)
            continue;
          this.linked.splice(i, 1);
          other.unlinkDoc(this);
          break;
        }
      if (other.history == this.history) {
        var splitIds = [other.id];
        linkedDocs(other, function (doc) {
          splitIds.push(doc.id);
        }, true);
        other.history = makeHistory();
        other.history.done = copyHistoryArray(this.history.done, splitIds);
        other.history.undone = copyHistoryArray(this.history.undone, splitIds);
      }
    },
    iterLinkedDocs: function (f) {
      linkedDocs(this, f);
    },
    getMode: function () {
      return this.mode;
    },
    getEditor: function () {
      return this.cm;
    }
  });
  Doc.prototype.eachLine = Doc.prototype.iter;
  var dontDelegate = 'iter insert remove copy getEditor'.split(' ');
  for (var prop in Doc.prototype)
    if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)
      CodeMirror.prototype[prop] = function (method) {
        return function () {
          return method.apply(this.doc, arguments);
        };
      }(Doc.prototype[prop]);
  function linkedDocs(doc, f, sharedHistOnly) {
    function propagate(doc, skip, sharedHist) {
      if (doc.linked)
        for (var i = 0; i < doc.linked.length; ++i) {
          var rel = doc.linked[i];
          if (rel.doc == skip)
            continue;
          var shared = sharedHist && rel.sharedHist;
          if (sharedHistOnly && !shared)
            continue;
          f(rel.doc, shared);
          propagate(rel.doc, doc, shared);
        }
    }
    propagate(doc, null, true);
  }
  function attachDoc(cm, doc) {
    if (doc.cm)
      throw new Error('This document is already in use.');
    cm.doc = doc;
    doc.cm = cm;
    estimateLineHeights(cm);
    loadMode(cm);
    if (!cm.options.lineWrapping)
      computeMaxLength(cm);
    cm.options.mode = doc.modeOption;
    regChange(cm);
  }
  function getLine(chunk, n) {
    n -= chunk.first;
    while (!chunk.lines) {
      for (var i = 0;; ++i) {
        var child = chunk.children[i], sz = child.chunkSize();
        if (n < sz) {
          chunk = child;
          break;
        }
        n -= sz;
      }
    }
    return chunk.lines[n];
  }
  function getBetween(doc, start, end) {
    var out = [], n = start.line;
    doc.iter(start.line, end.line + 1, function (line) {
      var text = line.text;
      if (n == end.line)
        text = text.slice(0, end.ch);
      if (n == start.line)
        text = text.slice(start.ch);
      out.push(text);
      ++n;
    });
    return out;
  }
  function getLines(doc, from, to) {
    var out = [];
    doc.iter(from, to, function (line) {
      out.push(line.text);
    });
    return out;
  }
  function updateLineHeight(line, height) {
    var diff = height - line.height;
    for (var n = line; n; n = n.parent)
      n.height += diff;
  }
  function lineNo(line) {
    if (line.parent == null)
      return null;
    var cur = line.parent, no = indexOf(cur.lines, line);
    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
      for (var i = 0;; ++i) {
        if (chunk.children[i] == cur)
          break;
        no += chunk.children[i].chunkSize();
      }
    }
    return no + cur.first;
  }
  function lineAtHeight(chunk, h) {
    var n = chunk.first;
    outer:
      do {
        for (var i = 0, e = chunk.children.length; i < e; ++i) {
          var child = chunk.children[i], ch = child.height;
          if (h < ch) {
            chunk = child;
            continue outer;
          }
          h -= ch;
          n += child.chunkSize();
        }
        return n;
      } while (!chunk.lines);
    for (var i = 0, e = chunk.lines.length; i < e; ++i) {
      var line = chunk.lines[i], lh = line.height;
      if (h < lh)
        break;
      h -= lh;
    }
    return n + i;
  }
  function heightAtLine(cm, lineObj) {
    lineObj = visualLine(cm.doc, lineObj);
    var h = 0, chunk = lineObj.parent;
    for (var i = 0; i < chunk.lines.length; ++i) {
      var line = chunk.lines[i];
      if (line == lineObj)
        break;
      else
        h += line.height;
    }
    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {
      for (var i = 0; i < p.children.length; ++i) {
        var cur = p.children[i];
        if (cur == chunk)
          break;
        else
          h += cur.height;
      }
    }
    return h;
  }
  function getOrder(line) {
    var order = line.order;
    if (order == null)
      order = line.order = bidiOrdering(line.text);
    return order;
  }
  function makeHistory() {
    return {
      done: [],
      undone: [],
      undoDepth: Infinity,
      lastTime: 0,
      lastOp: null,
      lastOrigin: null,
      dirtyCounter: 0
    };
  }
  function attachLocalSpans(doc, change, from, to) {
    var existing = change['spans_' + doc.id], n = 0;
    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {
      if (line.markedSpans)
        (existing || (existing = change['spans_' + doc.id] = {}))[n] = line.markedSpans;
      ++n;
    });
  }
  function historyChangeFromChange(doc, change) {
    var histChange = {
        from: change.from,
        to: changeEnd(change),
        text: getBetween(doc, change.from, change.to)
      };
    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
    linkedDocs(doc, function (doc) {
      attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
    }, true);
    return histChange;
  }
  function addToHistory(doc, change, selAfter, opId) {
    var hist = doc.history;
    hist.undone.length = 0;
    var time = +new Date(), cur = lst(hist.done);
    if (cur && (hist.lastOp == opId || hist.lastOrigin == change.origin && change.origin && (change.origin.charAt(0) == '+' && doc.cm && hist.lastTime > time - doc.cm.options.historyEventDelay || change.origin.charAt(0) == '*'))) {
      var last = lst(cur.changes);
      if (posEq(change.from, change.to) && posEq(change.from, last.to)) {
        last.to = changeEnd(change);
      } else {
        cur.changes.push(historyChangeFromChange(doc, change));
      }
      cur.anchorAfter = selAfter.anchor;
      cur.headAfter = selAfter.head;
    } else {
      cur = {
        changes: [historyChangeFromChange(doc, change)],
        anchorBefore: doc.sel.anchor,
        headBefore: doc.sel.head,
        anchorAfter: selAfter.anchor,
        headAfter: selAfter.head
      };
      hist.done.push(cur);
      while (hist.done.length > hist.undoDepth)
        hist.done.shift();
      if (hist.dirtyCounter < 0)
        hist.dirtyCounter = NaN;
      else
        hist.dirtyCounter++;
    }
    hist.lastTime = time;
    hist.lastOp = opId;
    hist.lastOrigin = change.origin;
  }
  function removeClearedSpans(spans) {
    if (!spans)
      return null;
    for (var i = 0, out; i < spans.length; ++i) {
      if (spans[i].marker.explicitlyCleared) {
        if (!out)
          out = spans.slice(0, i);
      } else if (out)
        out.push(spans[i]);
    }
    return !out ? spans : out.length ? out : null;
  }
  function getOldSpans(doc, change) {
    var found = change['spans_' + doc.id];
    if (!found)
      return null;
    for (var i = 0, nw = []; i < change.text.length; ++i)
      nw.push(removeClearedSpans(found[i]));
    return nw;
  }
  function copyHistoryArray(events, newGroup) {
    for (var i = 0, copy = []; i < events.length; ++i) {
      var event = events[i], changes = event.changes, newChanges = [];
      copy.push({
        changes: newChanges,
        anchorBefore: event.anchorBefore,
        headBefore: event.headBefore,
        anchorAfter: event.anchorAfter,
        headAfter: event.headAfter
      });
      for (var j = 0; j < changes.length; ++j) {
        var change = changes[j], m;
        newChanges.push({
          from: change.from,
          to: change.to,
          text: change.text
        });
        if (newGroup)
          for (var prop in change)
            if (m = prop.match(/^spans_(\d+)$/)) {
              if (indexOf(newGroup, Number(m[1])) > -1) {
                lst(newChanges)[prop] = change[prop];
                delete change[prop];
              }
            }
      }
    }
    return copy;
  }
  function rebaseHistSel(pos, from, to, diff) {
    if (to < pos.line) {
      pos.line += diff;
    } else if (from < pos.line) {
      pos.line = from;
      pos.ch = 0;
    }
  }
  function rebaseHistArray(array, from, to, diff) {
    for (var i = 0; i < array.length; ++i) {
      var sub = array[i], ok = true;
      for (var j = 0; j < sub.changes.length; ++j) {
        var cur = sub.changes[j];
        if (!sub.copied) {
          cur.from = copyPos(cur.from);
          cur.to = copyPos(cur.to);
        }
        if (to < cur.from.line) {
          cur.from.line += diff;
          cur.to.line += diff;
        } else if (from <= cur.to.line) {
          ok = false;
          break;
        }
      }
      if (!sub.copied) {
        sub.anchorBefore = copyPos(sub.anchorBefore);
        sub.headBefore = copyPos(sub.headBefore);
        sub.anchorAfter = copyPos(sub.anchorAfter);
        sub.readAfter = copyPos(sub.headAfter);
        sub.copied = true;
      }
      if (!ok) {
        array.splice(0, i + 1);
        i = 0;
      } else {
        rebaseHistSel(sub.anchorBefore);
        rebaseHistSel(sub.headBefore);
        rebaseHistSel(sub.anchorAfter);
        rebaseHistSel(sub.headAfter);
      }
    }
  }
  function rebaseHist(hist, change) {
    var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;
    rebaseHistArray(hist.done, from, to, diff);
    rebaseHistArray(hist.undone, from, to, diff);
  }
  function stopMethod() {
    e_stop(this);
  }
  function addStop(event) {
    if (!event.stop)
      event.stop = stopMethod;
    return event;
  }
  function e_preventDefault(e) {
    if (e.preventDefault)
      e.preventDefault();
    else
      e.returnValue = false;
  }
  function e_stopPropagation(e) {
    if (e.stopPropagation)
      e.stopPropagation();
    else
      e.cancelBubble = true;
  }
  function e_stop(e) {
    e_preventDefault(e);
    e_stopPropagation(e);
  }
  CodeMirror.e_stop = e_stop;
  CodeMirror.e_preventDefault = e_preventDefault;
  CodeMirror.e_stopPropagation = e_stopPropagation;
  function e_target(e) {
    return e.target || e.srcElement;
  }
  function e_button(e) {
    var b = e.which;
    if (b == null) {
      if (e.button & 1)
        b = 1;
      else if (e.button & 2)
        b = 3;
      else if (e.button & 4)
        b = 2;
    }
    if (mac && e.ctrlKey && b == 1)
      b = 3;
    return b;
  }
  function on(emitter, type, f) {
    if (emitter.addEventListener)
      emitter.addEventListener(type, f, false);
    else if (emitter.attachEvent)
      emitter.attachEvent('on' + type, f);
    else {
      var map = emitter._handlers || (emitter._handlers = {});
      var arr = map[type] || (map[type] = []);
      arr.push(f);
    }
  }
  function off(emitter, type, f) {
    if (emitter.removeEventListener)
      emitter.removeEventListener(type, f, false);
    else if (emitter.detachEvent)
      emitter.detachEvent('on' + type, f);
    else {
      var arr = emitter._handlers && emitter._handlers[type];
      if (!arr)
        return;
      for (var i = 0; i < arr.length; ++i)
        if (arr[i] == f) {
          arr.splice(i, 1);
          break;
        }
    }
  }
  function signal(emitter, type) {
    var arr = emitter._handlers && emitter._handlers[type];
    if (!arr)
      return;
    var args = Array.prototype.slice.call(arguments, 2);
    for (var i = 0; i < arr.length; ++i)
      arr[i].apply(null, args);
  }
  var delayedCallbacks, delayedCallbackDepth = 0;
  function signalLater(emitter, type) {
    var arr = emitter._handlers && emitter._handlers[type];
    if (!arr)
      return;
    var args = Array.prototype.slice.call(arguments, 2);
    if (!delayedCallbacks) {
      ++delayedCallbackDepth;
      delayedCallbacks = [];
      setTimeout(fireDelayed, 0);
    }
    function bnd(f) {
      return function () {
        f.apply(null, args);
      };
    }
    ;
    for (var i = 0; i < arr.length; ++i)
      delayedCallbacks.push(bnd(arr[i]));
  }
  function fireDelayed() {
    --delayedCallbackDepth;
    var delayed = delayedCallbacks;
    delayedCallbacks = null;
    for (var i = 0; i < delayed.length; ++i)
      delayed[i]();
  }
  function hasHandler(emitter, type) {
    var arr = emitter._handlers && emitter._handlers[type];
    return arr && arr.length > 0;
  }
  CodeMirror.on = on;
  CodeMirror.off = off;
  CodeMirror.signal = signal;
  var scrollerCutOff = 30;
  var Pass = CodeMirror.Pass = {
      toString: function () {
        return 'CodeMirror.Pass';
      }
    };
  function Delayed() {
    this.id = null;
  }
  Delayed.prototype = {
    set: function (ms, f) {
      clearTimeout(this.id);
      this.id = setTimeout(f, ms);
    }
  };
  function countColumn(string, end, tabSize, startIndex, startValue) {
    if (end == null) {
      end = string.search(/[^\s\u00a0]/);
      if (end == -1)
        end = string.length;
    }
    for (var i = startIndex || 0, n = startValue || 0; i < end; ++i) {
      if (string.charAt(i) == '\t')
        n += tabSize - n % tabSize;
      else
        ++n;
    }
    return n;
  }
  CodeMirror.countColumn = countColumn;
  var spaceStrs = [''];
  function spaceStr(n) {
    while (spaceStrs.length <= n)
      spaceStrs.push(lst(spaceStrs) + ' ');
    return spaceStrs[n];
  }
  function lst(arr) {
    return arr[arr.length - 1];
  }
  function selectInput(node) {
    if (ios) {
      node.selectionStart = 0;
      node.selectionEnd = node.value.length;
    } else
      node.select();
  }
  function indexOf(collection, elt) {
    if (collection.indexOf)
      return collection.indexOf(elt);
    for (var i = 0, e = collection.length; i < e; ++i)
      if (collection[i] == elt)
        return i;
    return -1;
  }
  function createObj(base, props) {
    function Obj() {
    }
    Obj.prototype = base;
    var inst = new Obj();
    if (props)
      copyObj(props, inst);
    return inst;
  }
  function copyObj(obj, target) {
    if (!target)
      target = {};
    for (var prop in obj)
      if (obj.hasOwnProperty(prop))
        target[prop] = obj[prop];
    return target;
  }
  function emptyArray(size) {
    for (var a = [], i = 0; i < size; ++i)
      a.push(undefined);
    return a;
  }
  function bind(f) {
    var args = Array.prototype.slice.call(arguments, 1);
    return function () {
      return f.apply(null, args);
    };
  }
  var nonASCIISingleCaseWordChar = /[\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc]/;
  function isWordChar(ch) {
    return /\w/.test(ch) || ch > '\x80' && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));
  }
  function isEmpty(obj) {
    for (var n in obj)
      if (obj.hasOwnProperty(n) && obj[n])
        return false;
    return true;
  }
  var isExtendingChar = /[\u0300-\u036F\u0483-\u0487\u0488-\u0489\u0591-\u05BD\u05BF\u05C1-\u05C2\u05C4-\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7-\u06E8\u06EA-\u06ED\uA66F\uA670-\uA672\uA674-\uA67D\uA69F\udc00-\udfff]/;
  function elt(tag, content, className, style) {
    var e = document.createElement(tag);
    if (className)
      e.className = className;
    if (style)
      e.style.cssText = style;
    if (typeof content == 'string')
      setTextContent(e, content);
    else if (content)
      for (var i = 0; i < content.length; ++i)
        e.appendChild(content[i]);
    return e;
  }
  function removeChildren(e) {
    for (var count = e.childNodes.length; count > 0; --count)
      e.removeChild(e.firstChild);
    return e;
  }
  function removeChildrenAndAdd(parent, e) {
    return removeChildren(parent).appendChild(e);
  }
  function setTextContent(e, str) {
    if (ie_lt9) {
      e.innerHTML = '';
      e.appendChild(document.createTextNode(str));
    } else
      e.textContent = str;
  }
  function getRect(node) {
    return node.getBoundingClientRect();
  }
  CodeMirror.replaceGetRect = function (f) {
    getRect = f;
  };
  var dragAndDrop = function () {
      if (ie_lt9)
        return false;
      var div = elt('div');
      return 'draggable' in div || 'dragDrop' in div;
    }();
  var spanAffectsWrapping = /^$/;
  if (gecko)
    spanAffectsWrapping = /$'/;
  else if (safari && !/Version\/([6-9]|\d\d)\b/.test(navigator.userAgent))
    spanAffectsWrapping = /\-[^ \-?]|\?[^ !'\"\),.\-\/:;\?\]\}]/;
  else if (webkit)
    spanAffectsWrapping = /[~!#%&*)=+}\]|\"\.>,:;][({[<]|-[^\-?\.]|\?[\w~`@#$%\^&*(_=+{[|><]/;
  var knownScrollbarWidth;
  function scrollbarWidth(measure) {
    if (knownScrollbarWidth != null)
      return knownScrollbarWidth;
    var test = elt('div', null, null, 'width: 50px; height: 50px; overflow-x: scroll');
    removeChildrenAndAdd(measure, test);
    if (test.offsetWidth)
      knownScrollbarWidth = test.offsetHeight - test.clientHeight;
    return knownScrollbarWidth || 0;
  }
  var zwspSupported;
  function zeroWidthElement(measure) {
    if (zwspSupported == null) {
      var test = elt('span', '\u200b');
      removeChildrenAndAdd(measure, elt('span', [
        test,
        document.createTextNode('x')
      ]));
      if (measure.firstChild.offsetHeight != 0)
        zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !ie_lt8;
    }
    if (zwspSupported)
      return elt('span', '\u200b');
    else
      return elt('span', '\xa0', null, 'display: inline-block; width: 1px; margin-right: -1px');
  }
  var splitLines = '\n\nb'.split(/\n/).length != 3 ? function (string) {
      var pos = 0, result = [], l = string.length;
      while (pos <= l) {
        var nl = string.indexOf('\n', pos);
        if (nl == -1)
          nl = string.length;
        var line = string.slice(pos, string.charAt(nl - 1) == '\r' ? nl - 1 : nl);
        var rt = line.indexOf('\r');
        if (rt != -1) {
          result.push(line.slice(0, rt));
          pos += rt + 1;
        } else {
          result.push(line);
          pos = nl + 1;
        }
      }
      return result;
    } : function (string) {
      return string.split(/\r\n?|\n/);
    };
  CodeMirror.splitLines = splitLines;
  var hasSelection = window.getSelection ? function (te) {
      try {
        return te.selectionStart != te.selectionEnd;
      } catch (e) {
        return false;
      }
    } : function (te) {
      try {
        var range = te.ownerDocument.selection.createRange();
      } catch (e) {
      }
      if (!range || range.parentElement() != te)
        return false;
      return range.compareEndPoints('StartToEnd', range) != 0;
    };
  var hasCopyEvent = function () {
      var e = elt('div');
      if ('oncopy' in e)
        return true;
      e.setAttribute('oncopy', 'return;');
      return typeof e.oncopy == 'function';
    }();
  var keyNames = {
      3: 'Enter',
      8: 'Backspace',
      9: 'Tab',
      13: 'Enter',
      16: 'Shift',
      17: 'Ctrl',
      18: 'Alt',
      19: 'Pause',
      20: 'CapsLock',
      27: 'Esc',
      32: 'Space',
      33: 'PageUp',
      34: 'PageDown',
      35: 'End',
      36: 'Home',
      37: 'Left',
      38: 'Up',
      39: 'Right',
      40: 'Down',
      44: 'PrintScrn',
      45: 'Insert',
      46: 'Delete',
      59: ';',
      91: 'Mod',
      92: 'Mod',
      93: 'Mod',
      109: '-',
      107: '=',
      127: 'Delete',
      186: ';',
      187: '=',
      188: ',',
      189: '-',
      190: '.',
      191: '/',
      192: '`',
      219: '[',
      220: '\\',
      221: ']',
      222: '\'',
      63276: 'PageUp',
      63277: 'PageDown',
      63275: 'End',
      63273: 'Home',
      63234: 'Left',
      63232: 'Up',
      63235: 'Right',
      63233: 'Down',
      63302: 'Insert',
      63272: 'Delete'
    };
  CodeMirror.keyNames = keyNames;
  (function () {
    for (var i = 0; i < 10; i++)
      keyNames[i + 48] = String(i);
    for (var i = 65; i <= 90; i++)
      keyNames[i] = String.fromCharCode(i);
    for (var i = 1; i <= 12; i++)
      keyNames[i + 111] = keyNames[i + 63235] = 'F' + i;
  }());
  function iterateBidiSections(order, from, to, f) {
    if (!order)
      return f(from, to, 'ltr');
    for (var i = 0; i < order.length; ++i) {
      var part = order[i];
      if (part.from < to && part.to > from || from == to && part.to == from)
        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? 'rtl' : 'ltr');
    }
  }
  function bidiLeft(part) {
    return part.level % 2 ? part.to : part.from;
  }
  function bidiRight(part) {
    return part.level % 2 ? part.from : part.to;
  }
  function lineLeft(line) {
    var order = getOrder(line);
    return order ? bidiLeft(order[0]) : 0;
  }
  function lineRight(line) {
    var order = getOrder(line);
    if (!order)
      return line.text.length;
    return bidiRight(lst(order));
  }
  function lineStart(cm, lineN) {
    var line = getLine(cm.doc, lineN);
    var visual = visualLine(cm.doc, line);
    if (visual != line)
      lineN = lineNo(visual);
    var order = getOrder(visual);
    var ch = !order ? 0 : order[0].level % 2 ? lineRight(visual) : lineLeft(visual);
    return Pos(lineN, ch);
  }
  function lineEnd(cm, lineN) {
    var merged, line;
    while (merged = collapsedSpanAtEnd(line = getLine(cm.doc, lineN)))
      lineN = merged.find().to.line;
    var order = getOrder(line);
    var ch = !order ? line.text.length : order[0].level % 2 ? lineLeft(line) : lineRight(line);
    return Pos(lineN, ch);
  }
  function moveVisually(line, start, dir, byUnit) {
    var bidi = getOrder(line);
    if (!bidi)
      return moveLogically(line, start, dir, byUnit);
    var moveOneUnit = byUnit ? function (pos, dir) {
        do
          pos += dir;
        while (pos > 0 && isExtendingChar.test(line.text.charAt(pos)));
        return pos;
      } : function (pos, dir) {
        return pos + dir;
      };
    var linedir = bidi[0].level;
    for (var i = 0; i < bidi.length; ++i) {
      var part = bidi[i], sticky = part.level % 2 == linedir;
      if (part.from < start && part.to > start || sticky && (part.from == start || part.to == start))
        break;
    }
    var target = moveOneUnit(start, part.level % 2 ? -dir : dir);
    while (target != null) {
      if (part.level % 2 == linedir) {
        if (target < part.from || target > part.to) {
          part = bidi[i += dir];
          target = part && (dir > 0 == part.level % 2 ? moveOneUnit(part.to, -1) : moveOneUnit(part.from, 1));
        } else
          break;
      } else {
        if (target == bidiLeft(part)) {
          part = bidi[--i];
          target = part && bidiRight(part);
        } else if (target == bidiRight(part)) {
          part = bidi[++i];
          target = part && bidiLeft(part);
        } else
          break;
      }
    }
    return target < 0 || target > line.text.length ? null : target;
  }
  function moveLogically(line, start, dir, byUnit) {
    var target = start + dir;
    if (byUnit)
      while (target > 0 && isExtendingChar.test(line.text.charAt(target)))
        target += dir;
    return target < 0 || target > line.text.length ? null : target;
  }
  var bidiOrdering = function () {
      var lowTypes = 'bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLL';
      var arabicTypes = 'rrrrrrrrrrrr,rNNmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmrrrrrrrnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmNmmmmrrrrrrrrrrrrrrrrrr';
      function charType(code) {
        if (code <= 255)
          return lowTypes.charAt(code);
        else if (1424 <= code && code <= 1524)
          return 'R';
        else if (1536 <= code && code <= 1791)
          return arabicTypes.charAt(code - 1536);
        else if (1792 <= code && code <= 2220)
          return 'r';
        else
          return 'L';
      }
      var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
      var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;
      var outerType = 'L';
      return function (str) {
        if (!bidiRE.test(str))
          return false;
        var len = str.length, types = [];
        for (var i = 0, type; i < len; ++i)
          types.push(type = charType(str.charCodeAt(i)));
        for (var i = 0, prev = outerType; i < len; ++i) {
          var type = types[i];
          if (type == 'm')
            types[i] = prev;
          else
            prev = type;
        }
        for (var i = 0, cur = outerType; i < len; ++i) {
          var type = types[i];
          if (type == '1' && cur == 'r')
            types[i] = 'n';
          else if (isStrong.test(type)) {
            cur = type;
            if (type == 'r')
              types[i] = 'R';
          }
        }
        for (var i = 1, prev = types[0]; i < len - 1; ++i) {
          var type = types[i];
          if (type == '+' && prev == '1' && types[i + 1] == '1')
            types[i] = '1';
          else if (type == ',' && prev == types[i + 1] && (prev == '1' || prev == 'n'))
            types[i] = prev;
          prev = type;
        }
        for (var i = 0; i < len; ++i) {
          var type = types[i];
          if (type == ',')
            types[i] = 'N';
          else if (type == '%') {
            for (var end = i + 1; end < len && types[end] == '%'; ++end) {
            }
            var replace = i && types[i - 1] == '!' || end < len - 1 && types[end] == '1' ? '1' : 'N';
            for (var j = i; j < end; ++j)
              types[j] = replace;
            i = end - 1;
          }
        }
        for (var i = 0, cur = outerType; i < len; ++i) {
          var type = types[i];
          if (cur == 'L' && type == '1')
            types[i] = 'L';
          else if (isStrong.test(type))
            cur = type;
        }
        for (var i = 0; i < len; ++i) {
          if (isNeutral.test(types[i])) {
            for (var end = i + 1; end < len && isNeutral.test(types[end]); ++end) {
            }
            var before = (i ? types[i - 1] : outerType) == 'L';
            var after = (end < len - 1 ? types[end] : outerType) == 'L';
            var replace = before || after ? 'L' : 'R';
            for (var j = i; j < end; ++j)
              types[j] = replace;
            i = end - 1;
          }
        }
        var order = [], m;
        for (var i = 0; i < len;) {
          if (countsAsLeft.test(types[i])) {
            var start = i;
            for (++i; i < len && countsAsLeft.test(types[i]); ++i) {
            }
            order.push({
              from: start,
              to: i,
              level: 0
            });
          } else {
            var pos = i, at = order.length;
            for (++i; i < len && types[i] != 'L'; ++i) {
            }
            for (var j = pos; j < i;) {
              if (countsAsNum.test(types[j])) {
                if (pos < j)
                  order.splice(at, 0, {
                    from: pos,
                    to: j,
                    level: 1
                  });
                var nstart = j;
                for (++j; j < i && countsAsNum.test(types[j]); ++j) {
                }
                order.splice(at, 0, {
                  from: nstart,
                  to: j,
                  level: 2
                });
                pos = j;
              } else
                ++j;
            }
            if (pos < i)
              order.splice(at, 0, {
                from: pos,
                to: i,
                level: 1
              });
          }
        }
        if (order[0].level == 1 && (m = str.match(/^\s+/))) {
          order[0].from = m[0].length;
          order.unshift({
            from: 0,
            to: m[0].length,
            level: 0
          });
        }
        if (lst(order).level == 1 && (m = str.match(/\s+$/))) {
          lst(order).to -= m[0].length;
          order.push({
            from: len - m[0].length,
            to: len,
            level: 0
          });
        }
        if (order[0].level != lst(order).level)
          order.push({
            from: len,
            to: len,
            level: order[0].level
          });
        return order;
      };
    }();
  CodeMirror.version = '3.11 +';
  return CodeMirror;
}();
CodeMirror.defineMode('python', function (conf, parserConf) {
  var ERRORCLASS = 'error';
  function wordRegexp(words) {
    return new RegExp('^((' + words.join(')|(') + '))\\b');
  }
  var singleOperators = parserConf.singleOperators || new RegExp('^[\\+\\-\\*/%&|\\^~<>!]');
  var singleDelimiters = parserConf.singleDelimiters || new RegExp('^[\\(\\)\\[\\]\\{\\}@,:`=;\\.]');
  var doubleOperators = parserConf.doubleOperators || new RegExp('^((==)|(!=)|(<=)|(>=)|(<>)|(<<)|(>>)|(//)|(\\*\\*))');
  var doubleDelimiters = parserConf.doubleDelimiters || new RegExp('^((\\+=)|(\\-=)|(\\*=)|(%=)|(/=)|(&=)|(\\|=)|(\\^=))');
  var tripleDelimiters = parserConf.tripleDelimiters || new RegExp('^((//=)|(>>=)|(<<=)|(\\*\\*=))');
  var identifiers = parserConf.identifiers || new RegExp('^[_A-Za-z][_A-Za-z0-9]*');
  var wordOperators = wordRegexp([
      'and',
      'or',
      'not',
      'is',
      'in'
    ]);
  var commonkeywords = [
      'as',
      'assert',
      'break',
      'class',
      'continue',
      'def',
      'del',
      'elif',
      'else',
      'except',
      'finally',
      'for',
      'from',
      'global',
      'if',
      'import',
      'lambda',
      'pass',
      'raise',
      'return',
      'try',
      'while',
      'with',
      'yield'
    ];
  var commonBuiltins = [
      'abs',
      'all',
      'any',
      'bin',
      'bool',
      'bytearray',
      'callable',
      'chr',
      'classmethod',
      'compile',
      'complex',
      'delattr',
      'dict',
      'dir',
      'divmod',
      'enumerate',
      'eval',
      'filter',
      'float',
      'format',
      'frozenset',
      'getattr',
      'globals',
      'hasattr',
      'hash',
      'help',
      'hex',
      'id',
      'input',
      'int',
      'isinstance',
      'issubclass',
      'iter',
      'len',
      'list',
      'locals',
      'map',
      'max',
      'memoryview',
      'min',
      'next',
      'object',
      'oct',
      'open',
      'ord',
      'pow',
      'property',
      'range',
      'repr',
      'reversed',
      'round',
      'set',
      'setattr',
      'slice',
      'sorted',
      'staticmethod',
      'str',
      'sum',
      'super',
      'tuple',
      'type',
      'vars',
      'zip',
      '__import__',
      'NotImplemented',
      'Ellipsis',
      '__debug__'
    ];
  var py2 = {
      'builtins': [
        'apply',
        'basestring',
        'buffer',
        'cmp',
        'coerce',
        'execfile',
        'file',
        'intern',
        'long',
        'raw_input',
        'reduce',
        'reload',
        'unichr',
        'unicode',
        'xrange',
        'False',
        'True',
        'None'
      ],
      'keywords': [
        'exec',
        'print'
      ]
    };
  var py3 = {
      'builtins': [
        'ascii',
        'bytes',
        'exec',
        'print'
      ],
      'keywords': [
        'nonlocal',
        'False',
        'True',
        'None'
      ]
    };
  if (!!parserConf.version && parseInt(parserConf.version, 10) === 3) {
    commonkeywords = commonkeywords.concat(py3.keywords);
    commonBuiltins = commonBuiltins.concat(py3.builtins);
    var stringPrefixes = new RegExp('^(([rb]|(br))?(\'{3}|"{3}|[\'"]))', 'i');
  } else {
    commonkeywords = commonkeywords.concat(py2.keywords);
    commonBuiltins = commonBuiltins.concat(py2.builtins);
    var stringPrefixes = new RegExp('^(([rub]|(ur)|(br))?(\'{3}|"{3}|[\'"]))', 'i');
  }
  var keywords = wordRegexp(commonkeywords);
  var builtins = wordRegexp(commonBuiltins);
  var indentInfo = null;
  function tokenBase(stream, state) {
    if (stream.sol()) {
      var scopeOffset = state.scopes[0].offset;
      if (stream.eatSpace()) {
        var lineOffset = stream.indentation();
        if (lineOffset > scopeOffset) {
          indentInfo = 'indent';
        } else if (lineOffset < scopeOffset) {
          indentInfo = 'dedent';
        }
        return null;
      } else {
        if (scopeOffset > 0) {
          dedent(stream, state);
        }
      }
    }
    if (stream.eatSpace()) {
      return null;
    }
    var ch = stream.peek();
    if (ch === '#') {
      stream.skipToEnd();
      return 'comment';
    }
    if (stream.match(/^[0-9\.]/, false)) {
      var floatLiteral = false;
      if (stream.match(/^\d*\.\d+(e[\+\-]?\d+)?/i)) {
        floatLiteral = true;
      }
      if (stream.match(/^\d+\.\d*/)) {
        floatLiteral = true;
      }
      if (stream.match(/^\.\d+/)) {
        floatLiteral = true;
      }
      if (floatLiteral) {
        stream.eat(/J/i);
        return 'number';
      }
      var intLiteral = false;
      if (stream.match(/^0x[0-9a-f]+/i)) {
        intLiteral = true;
      }
      if (stream.match(/^0b[01]+/i)) {
        intLiteral = true;
      }
      if (stream.match(/^0o[0-7]+/i)) {
        intLiteral = true;
      }
      if (stream.match(/^[1-9]\d*(e[\+\-]?\d+)?/)) {
        stream.eat(/J/i);
        intLiteral = true;
      }
      if (stream.match(/^0(?![\dx])/i)) {
        intLiteral = true;
      }
      if (intLiteral) {
        stream.eat(/L/i);
        return 'number';
      }
    }
    if (stream.match(stringPrefixes)) {
      state.tokenize = tokenStringFactory(stream.current());
      return state.tokenize(stream, state);
    }
    if (stream.match(tripleDelimiters) || stream.match(doubleDelimiters)) {
      return null;
    }
    if (stream.match(doubleOperators) || stream.match(singleOperators) || stream.match(wordOperators)) {
      return 'operator';
    }
    if (stream.match(singleDelimiters)) {
      return null;
    }
    if (stream.match(keywords)) {
      return 'keyword';
    }
    if (stream.match(builtins)) {
      return 'builtin';
    }
    if (stream.match(identifiers)) {
      return 'variable';
    }
    stream.next();
    return ERRORCLASS;
  }
  function tokenStringFactory(delimiter) {
    while ('rub'.indexOf(delimiter.charAt(0).toLowerCase()) >= 0) {
      delimiter = delimiter.substr(1);
    }
    var singleline = delimiter.length == 1;
    var OUTCLASS = 'string';
    function tokenString(stream, state) {
      while (!stream.eol()) {
        stream.eatWhile(/[^'"\\]/);
        if (stream.eat('\\')) {
          stream.next();
          if (singleline && stream.eol()) {
            return OUTCLASS;
          }
        } else if (stream.match(delimiter)) {
          state.tokenize = tokenBase;
          return OUTCLASS;
        } else {
          stream.eat(/['"]/);
        }
      }
      if (singleline) {
        if (parserConf.singleLineStringErrors) {
          return ERRORCLASS;
        } else {
          state.tokenize = tokenBase;
        }
      }
      return OUTCLASS;
    }
    tokenString.isString = true;
    return tokenString;
  }
  function indent(stream, state, type) {
    type = type || 'py';
    var indentUnit = 0;
    if (type === 'py') {
      if (state.scopes[0].type !== 'py') {
        state.scopes[0].offset = stream.indentation();
        return;
      }
      for (var i = 0; i < state.scopes.length; ++i) {
        if (state.scopes[i].type === 'py') {
          indentUnit = state.scopes[i].offset + conf.indentUnit;
          break;
        }
      }
    } else {
      indentUnit = stream.column() + stream.current().length;
    }
    state.scopes.unshift({
      offset: indentUnit,
      type: type
    });
  }
  function dedent(stream, state, type) {
    type = type || 'py';
    if (state.scopes.length == 1)
      return;
    if (state.scopes[0].type === 'py') {
      var _indent = stream.indentation();
      var _indent_index = -1;
      for (var i = 0; i < state.scopes.length; ++i) {
        if (_indent === state.scopes[i].offset) {
          _indent_index = i;
          break;
        }
      }
      if (_indent_index === -1) {
        return true;
      }
      while (state.scopes[0].offset !== _indent) {
        state.scopes.shift();
      }
      return false;
    } else {
      if (type === 'py') {
        state.scopes[0].offset = stream.indentation();
        return false;
      } else {
        if (state.scopes[0].type != type) {
          return true;
        }
        state.scopes.shift();
        return false;
      }
    }
  }
  function tokenLexer(stream, state) {
    indentInfo = null;
    var style = state.tokenize(stream, state);
    var current = stream.current();
    if (current === '.') {
      style = stream.match(identifiers, false) ? null : ERRORCLASS;
      if (style === null && state.lastToken === 'meta') {
        style = 'meta';
      }
      return style;
    }
    if (current === '@') {
      return stream.match(identifiers, false) ? 'meta' : ERRORCLASS;
    }
    if ((style === 'variable' || style === 'builtin') && state.lastToken === 'meta') {
      style = 'meta';
    }
    if (current === 'pass' || current === 'return') {
      state.dedent += 1;
    }
    if (current === 'lambda')
      state.lambda = true;
    if (current === ':' && !state.lambda && state.scopes[0].type == 'py' || indentInfo === 'indent') {
      indent(stream, state);
    }
    var delimiter_index = '[({'.indexOf(current);
    if (delimiter_index !== -1) {
      indent(stream, state, '])}'.slice(delimiter_index, delimiter_index + 1));
    }
    if (indentInfo === 'dedent') {
      if (dedent(stream, state)) {
        return ERRORCLASS;
      }
    }
    delimiter_index = '])}'.indexOf(current);
    if (delimiter_index !== -1) {
      if (dedent(stream, state, current)) {
        return ERRORCLASS;
      }
    }
    if (state.dedent > 0 && stream.eol() && state.scopes[0].type == 'py') {
      if (state.scopes.length > 1)
        state.scopes.shift();
      state.dedent -= 1;
    }
    return style;
  }
  var external = {
      startState: function (basecolumn) {
        return {
          tokenize: tokenBase,
          scopes: [{
              offset: basecolumn || 0,
              type: 'py'
            }],
          lastToken: null,
          lambda: false,
          dedent: 0
        };
      },
      token: function (stream, state) {
        var style = tokenLexer(stream, state);
        state.lastToken = style;
        if (stream.eol() && stream.lambda) {
          state.lambda = false;
        }
        return style;
      },
      indent: function (state) {
        if (state.tokenize != tokenBase) {
          return state.tokenize.isString ? CodeMirror.Pass : 0;
        }
        return state.scopes[0].offset;
      }
    };
  return external;
});
CodeMirror.defineMIME('text/x-python', 'python');
this.createjs = this.createjs || {};
(function () {
  var c = function () {
    throw 'UID cannot be instantiated';
  };
  c._nextID = 0;
  c.get = function () {
    return c._nextID++;
  };
  createjs.UID = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function () {
      this.initialize();
    }, b = c.prototype;
  c.initialize = function (a) {
    a.addEventListener = b.addEventListener;
    a.removeEventListener = b.removeEventListener;
    a.removeAllEventListeners = b.removeAllEventListeners;
    a.hasEventListener = b.hasEventListener;
    a.dispatchEvent = b.dispatchEvent;
  };
  b._listeners = null;
  b.initialize = function () {
  };
  b.addEventListener = function (a, m) {
    var b = this._listeners;
    b ? this.removeEventListener(a, m) : b = this._listeners = {};
    var d = b[a];
    d || (d = b[a] = []);
    d.push(m);
    return m;
  };
  b.removeEventListener = function (a, m) {
    var b = this._listeners;
    if (b) {
      var d = b[a];
      if (d)
        for (var e = 0, c = d.length; e < c; e++)
          if (d[e] == m) {
            1 == c ? delete b[a] : d.splice(e, 1);
            break;
          }
    }
  };
  b.removeAllEventListeners = function (a) {
    a ? this._listeners && delete this._listeners[a] : this._listeners = null;
  };
  b.dispatchEvent = function (a, m) {
    var b = !1, d = this._listeners;
    if (a && d) {
      'string' == typeof a && (a = { type: a });
      d = d[a.type];
      if (!d)
        return b;
      a.target = m || this;
      for (var d = d.slice(), e = 0, c = d.length; e < c; e++)
        var h = d[e], b = h.handleEvent ? b || h.handleEvent(a) : b || h(a);
    }
    return !!b;
  };
  b.hasEventListener = function (a) {
    var m = this._listeners;
    return !(!m || !m[a]);
  };
  b.toString = function () {
    return '[EventDispatcher]';
  };
  createjs.EventDispatcher = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function () {
    throw 'Ticker cannot be instantiated.';
  };
  c.useRAF = !1;
  c.addEventListener = null;
  c.removeEventListener = null;
  c.removeAllEventListeners = null;
  c.dispatchEvent = null;
  c.hasEventListener = null;
  c._listeners = null;
  createjs.EventDispatcher.initialize(c);
  c._listeners = null;
  c._pauseable = null;
  c._paused = !1;
  c._inited = !1;
  c._startTime = 0;
  c._pausedTime = 0;
  c._ticks = 0;
  c._pausedTicks = 0;
  c._interval = 50;
  c._lastTime = 0;
  c._times = null;
  c._tickTimes = null;
  c._rafActive = !1;
  c._timeoutID = null;
  c.addListener = function (a, m) {
    null != a && (c.removeListener(a), c._pauseable[c._listeners.length] = null == m ? !0 : m, c._listeners.push(a));
  };
  c.init = function () {
    c._inited = !0;
    c._times = [];
    c._tickTimes = [];
    c._pauseable = [];
    c._listeners = [];
    c._times.push(c._lastTime = c._startTime = c._getTime());
    c.setInterval(c._interval);
  };
  c.removeListener = function (a) {
    var m = c._listeners;
    m && (a = m.indexOf(a), -1 != a && (m.splice(a, 1), c._pauseable.splice(a, 1)));
  };
  c.removeAllListeners = function () {
    c._listeners = [];
    c._pauseable = [];
  };
  c.setInterval = function (a) {
    c._interval = a;
    c._inited && c._setupTick();
  };
  c.getInterval = function () {
    return c._interval;
  };
  c.setFPS = function (a) {
    c.setInterval(1000 / a);
  };
  c.getFPS = function () {
    return 1000 / c._interval;
  };
  c.getMeasuredFPS = function (a) {
    if (2 > c._times.length)
      return -1;
    null == a && (a = c.getFPS() | 0);
    a = Math.min(c._times.length - 1, a);
    return 1000 / ((c._times[0] - c._times[a]) / a);
  };
  c.setPaused = function (a) {
    c._paused = a;
  };
  c.getPaused = function () {
    return c._paused;
  };
  c.getTime = function (a) {
    return c._getTime() - c._startTime - (a ? c._pausedTime : 0);
  };
  c.getTicks = function (a) {
    return c._ticks - (a ? c._pausedTicks : 0);
  };
  c._handleAF = function () {
    c._rafActive = !1;
    c._setupTick();
    c._getTime() - c._lastTime >= 0.97 * (c._interval - 1) && c._tick();
  };
  c._handleTimeout = function () {
    c.timeoutID = null;
    c._setupTick();
    c._tick();
  };
  c._setupTick = function () {
    if (!(c._rafActive || null != c.timeoutID)) {
      if (c.useRAF) {
        var a = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame;
        if (a) {
          a(c._handleAF);
          c._rafActive = !0;
          return;
        }
      }
      c.timeoutID = setTimeout(c._handleTimeout, c._interval);
    }
  };
  c._tick = function () {
    var a = c._getTime();
    c._ticks++;
    var m = a - c._lastTime, b = c._paused;
    b && (c._pausedTicks++, c._pausedTime += m);
    c._lastTime = a;
    for (var d = c._pauseable, e = c._listeners.slice(), f = e ? e.length : 0, h = 0; h < f; h++) {
      var k = e[h];
      null == k || b && d[h] || (k.tick ? k.tick(m, b) : k instanceof Function && k(m, b));
    }
    c.dispatchEvent({
      type: 'tick',
      paused: b,
      delta: m,
      time: a,
      runTime: a - c._pausedTime
    });
    for (c._tickTimes.unshift(c._getTime() - a); 100 < c._tickTimes.length;)
      c._tickTimes.pop();
    for (c._times.unshift(a); 100 < c._times.length;)
      c._times.pop();
  };
  var b = window.performance && (performance.now || performance.mozNow || performance.msNow || performance.oNow || performance.webkitNow);
  c._getTime = function () {
    return b && b.call(performance) || new Date().getTime();
  };
  c.init();
  createjs.Ticker = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function (a, m, b, d, e, c, h, k, j) {
      this.initialize(a, m, b, d, e, c, h, k, j);
    }, b = c.prototype;
  b.stageX = 0;
  b.stageY = 0;
  b.rawX = 0;
  b.rawY = 0;
  b.type = null;
  b.nativeEvent = null;
  b.onMouseMove = null;
  b.onMouseUp = null;
  b.target = null;
  b.pointerID = 0;
  b.primary = !1;
  b.addEventListener = null;
  b.removeEventListener = null;
  b.removeAllEventListeners = null;
  b.dispatchEvent = null;
  b.hasEventListener = null;
  b._listeners = null;
  createjs.EventDispatcher.initialize(b);
  b.initialize = function (a, m, b, d, e, c, h, k, j) {
    this.type = a;
    this.stageX = m;
    this.stageY = b;
    this.target = d;
    this.nativeEvent = e;
    this.pointerID = c;
    this.primary = h;
    this.rawX = null == k ? m : k;
    this.rawY = null == j ? b : j;
  };
  b.clone = function () {
    return new c(this.type, this.stageX, this.stageY, this.target, this.nativeEvent, this.pointerID, this.primary, this.rawX, this.rawY);
  };
  b.toString = function () {
    return '[MouseEvent (type=' + this.type + ' stageX=' + this.stageX + ' stageY=' + this.stageY + ')]';
  };
  createjs.MouseEvent = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function (a, m, b, d, c, f) {
      this.initialize(a, m, b, d, c, f);
    }, b = c.prototype;
  c.identity = null;
  c.DEG_TO_RAD = Math.PI / 180;
  b.a = 1;
  b.b = 0;
  b.c = 0;
  b.d = 1;
  b.tx = 0;
  b.ty = 0;
  b.alpha = 1;
  b.shadow = null;
  b.compositeOperation = null;
  b.initialize = function (a, m, b, d, c, f) {
    null != a && (this.a = a);
    this.b = m || 0;
    this.c = b || 0;
    null != d && (this.d = d);
    this.tx = c || 0;
    this.ty = f || 0;
    return this;
  };
  b.prepend = function (a, b, g, d, c, f) {
    var h = this.tx;
    if (1 != a || 0 != b || 0 != g || 1 != d) {
      var k = this.a, j = this.c;
      this.a = k * a + this.b * g;
      this.b = k * b + this.b * d;
      this.c = j * a + this.d * g;
      this.d = j * b + this.d * d;
    }
    this.tx = h * a + this.ty * g + c;
    this.ty = h * b + this.ty * d + f;
    return this;
  };
  b.append = function (a, b, g, d, c, f) {
    var h = this.a, k = this.b, j = this.c, l = this.d;
    this.a = a * h + b * j;
    this.b = a * k + b * l;
    this.c = g * h + d * j;
    this.d = g * k + d * l;
    this.tx = c * h + f * j + this.tx;
    this.ty = c * k + f * l + this.ty;
    return this;
  };
  b.prependMatrix = function (a) {
    this.prepend(a.a, a.b, a.c, a.d, a.tx, a.ty);
    this.prependProperties(a.alpha, a.shadow, a.compositeOperation);
    return this;
  };
  b.appendMatrix = function (a) {
    this.append(a.a, a.b, a.c, a.d, a.tx, a.ty);
    this.appendProperties(a.alpha, a.shadow, a.compositeOperation);
    return this;
  };
  b.prependTransform = function (a, b, g, d, e, f, h, k, j) {
    if (e % 360) {
      var l = e * c.DEG_TO_RAD;
      e = Math.cos(l);
      l = Math.sin(l);
    } else
      e = 1, l = 0;
    if (k || j)
      this.tx -= k, this.ty -= j;
    f || h ? (f *= c.DEG_TO_RAD, h *= c.DEG_TO_RAD, this.prepend(e * g, l * g, -l * d, e * d, 0, 0), this.prepend(Math.cos(h), Math.sin(h), -Math.sin(f), Math.cos(f), a, b)) : this.prepend(e * g, l * g, -l * d, e * d, a, b);
    return this;
  };
  b.appendTransform = function (a, b, g, d, e, f, h, k, j) {
    if (e % 360) {
      var l = e * c.DEG_TO_RAD;
      e = Math.cos(l);
      l = Math.sin(l);
    } else
      e = 1, l = 0;
    f || h ? (f *= c.DEG_TO_RAD, h *= c.DEG_TO_RAD, this.append(Math.cos(h), Math.sin(h), -Math.sin(f), Math.cos(f), a, b), this.append(e * g, l * g, -l * d, e * d, 0, 0)) : this.append(e * g, l * g, -l * d, e * d, a, b);
    if (k || j)
      this.tx -= k * this.a + j * this.c, this.ty -= k * this.b + j * this.d;
    return this;
  };
  b.rotate = function (a) {
    var b = Math.cos(a);
    a = Math.sin(a);
    var g = this.a, d = this.c, c = this.tx;
    this.a = g * b - this.b * a;
    this.b = g * a + this.b * b;
    this.c = d * b - this.d * a;
    this.d = d * a + this.d * b;
    this.tx = c * b - this.ty * a;
    this.ty = c * a + this.ty * b;
    return this;
  };
  b.skew = function (a, b) {
    a *= c.DEG_TO_RAD;
    b *= c.DEG_TO_RAD;
    this.append(Math.cos(b), Math.sin(b), -Math.sin(a), Math.cos(a), 0, 0);
    return this;
  };
  b.scale = function (a, b) {
    this.a *= a;
    this.d *= b;
    this.c *= a;
    this.b *= b;
    this.tx *= a;
    this.ty *= b;
    return this;
  };
  b.translate = function (a, b) {
    this.tx += a;
    this.ty += b;
    return this;
  };
  b.identity = function () {
    this.alpha = this.a = this.d = 1;
    this.b = this.c = this.tx = this.ty = 0;
    this.shadow = this.compositeOperation = null;
    return this;
  };
  b.invert = function () {
    var a = this.a, b = this.b, g = this.c, d = this.d, c = this.tx, f = a * d - b * g;
    this.a = d / f;
    this.b = -b / f;
    this.c = -g / f;
    this.d = a / f;
    this.tx = (g * this.ty - d * c) / f;
    this.ty = -(a * this.ty - b * c) / f;
    return this;
  };
  b.isIdentity = function () {
    return 0 == this.tx && 0 == this.ty && 1 == this.a && 0 == this.b && 0 == this.c && 1 == this.d;
  };
  b.decompose = function (a) {
    null == a && (a = {});
    a.x = this.tx;
    a.y = this.ty;
    a.scaleX = Math.sqrt(this.a * this.a + this.b * this.b);
    a.scaleY = Math.sqrt(this.c * this.c + this.d * this.d);
    var b = Math.atan2(-this.c, this.d), g = Math.atan2(this.b, this.a);
    b == g ? (a.rotation = g / c.DEG_TO_RAD, 0 > this.a && 0 <= this.d && (a.rotation += 0 >= a.rotation ? 180 : -180), a.skewX = a.skewY = 0) : (a.skewX = b / c.DEG_TO_RAD, a.skewY = g / c.DEG_TO_RAD);
    return a;
  };
  b.reinitialize = function (a, b, g, d, c, f, h, k, j) {
    this.initialize(a, b, g, d, c, f);
    this.alpha = h || 1;
    this.shadow = k;
    this.compositeOperation = j;
    return this;
  };
  b.appendProperties = function (a, b, g) {
    this.alpha *= a;
    this.shadow = b || this.shadow;
    this.compositeOperation = g || this.compositeOperation;
    return this;
  };
  b.prependProperties = function (a, b, g) {
    this.alpha *= a;
    this.shadow = this.shadow || b;
    this.compositeOperation = this.compositeOperation || g;
    return this;
  };
  b.clone = function () {
    var a = new c(this.a, this.b, this.c, this.d, this.tx, this.ty);
    a.shadow = this.shadow;
    a.alpha = this.alpha;
    a.compositeOperation = this.compositeOperation;
    return a;
  };
  b.toString = function () {
    return '[Matrix2D (a=' + this.a + ' b=' + this.b + ' c=' + this.c + ' d=' + this.d + ' tx=' + this.tx + ' ty=' + this.ty + ')]';
  };
  c.identity = new c(1, 0, 0, 1, 0, 0);
  createjs.Matrix2D = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function (a, b) {
      this.initialize(a, b);
    }, b = c.prototype;
  b.x = 0;
  b.y = 0;
  b.initialize = function (a, b) {
    this.x = null == a ? 0 : a;
    this.y = null == b ? 0 : b;
  };
  b.clone = function () {
    return new c(this.x, this.y);
  };
  b.toString = function () {
    return '[Point (x=' + this.x + ' y=' + this.y + ')]';
  };
  createjs.Point = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function (a, b, g, d) {
      this.initialize(a, b, g, d);
    }, b = c.prototype;
  b.x = 0;
  b.y = 0;
  b.width = 0;
  b.height = 0;
  b.initialize = function (a, b, g, d) {
    this.x = null == a ? 0 : a;
    this.y = null == b ? 0 : b;
    this.width = null == g ? 0 : g;
    this.height = null == d ? 0 : d;
  };
  b.clone = function () {
    return new c(this.x, this.y, this.width, this.height);
  };
  b.toString = function () {
    return '[Rectangle (x=' + this.x + ' y=' + this.y + ' width=' + this.width + ' height=' + this.height + ')]';
  };
  createjs.Rectangle = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function (a, b, g, d, c, f, h) {
      this.initialize(a, b, g, d, c, f, h);
    }, b = c.prototype;
  b.target = null;
  b.overLabel = null;
  b.outLabel = null;
  b.downLabel = null;
  b.play = !1;
  b._isPressed = !1;
  b._isOver = !1;
  b.initialize = function (a, b, g, d, c, f, h) {
    a.addEventListener && (this.target = a, a.cursor = 'pointer', this.overLabel = null == g ? 'over' : g, this.outLabel = null == b ? 'out' : b, this.downLabel = null == d ? 'down' : d, this.play = c, this.setEnabled(!0), this.handleEvent({}), f && (h && (f.actionsEnabled = !1, f.gotoAndStop && f.gotoAndStop(h)), a.hitArea = f));
  };
  b.setEnabled = function (a) {
    var b = this.target;
    a ? (b.addEventListener('mouseover', this), b.addEventListener('mouseout', this), b.addEventListener('mousedown', this)) : (b.removeEventListener('mouseover', this), b.removeEventListener('mouseout', this), b.removeEventListener('mousedown', this));
  };
  b.toString = function () {
    return '[ButtonHelper]';
  };
  b.handleEvent = function (a) {
    var b = this.target, g = a.type;
    'mousedown' == g ? (a.addEventListener('mouseup', this), this._isPressed = !0, a = this.downLabel) : 'mouseup' == g ? (this._isPressed = !1, a = this._isOver ? this.overLabel : this.outLabel) : 'mouseover' == g ? (this._isOver = !0, a = this._isPressed ? this.downLabel : this.overLabel) : (this._isOver = !1, a = this._isPressed ? this.overLabel : this.outLabel);
    this.play ? b.gotoAndPlay && b.gotoAndPlay(a) : b.gotoAndStop && b.gotoAndStop(a);
  };
  createjs.ButtonHelper = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function (a, b, g, d) {
      this.initialize(a, b, g, d);
    }, b = c.prototype;
  c.identity = null;
  b.color = null;
  b.offsetX = 0;
  b.offsetY = 0;
  b.blur = 0;
  b.initialize = function (a, b, g, d) {
    this.color = a;
    this.offsetX = b;
    this.offsetY = g;
    this.blur = d;
  };
  b.toString = function () {
    return '[Shadow]';
  };
  b.clone = function () {
    return new c(this.color, this.offsetX, this.offsetY, this.blur);
  };
  c.identity = new c('transparent', 0, 0, 0);
  createjs.Shadow = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function (a) {
      this.initialize(a);
    }, b = c.prototype;
  b.complete = !0;
  b.onComplete = null;
  b.addEventListener = null;
  b.removeEventListener = null;
  b.removeAllEventListeners = null;
  b.dispatchEvent = null;
  b.hasEventListener = null;
  b._listeners = null;
  createjs.EventDispatcher.initialize(b);
  b._animations = null;
  b._frames = null;
  b._images = null;
  b._data = null;
  b._loadCount = 0;
  b._frameHeight = 0;
  b._frameWidth = 0;
  b._numFrames = 0;
  b._regX = 0;
  b._regY = 0;
  b.initialize = function (a) {
    var b, g, d;
    if (null != a) {
      if (a.images && 0 < (g = a.images.length)) {
        d = this._images = [];
        for (b = 0; b < g; b++) {
          var c = a.images[b];
          if ('string' == typeof c) {
            var f = c, c = new Image();
            c.src = f;
          }
          d.push(c);
          !c.getContext && !c.complete && (this._loadCount++, this.complete = !1, function (a) {
            c.onload = function () {
              a._handleImageLoad();
            };
          }(this));
        }
      }
      if (null != a.frames)
        if (a.frames instanceof Array) {
          this._frames = [];
          d = a.frames;
          b = 0;
          for (g = d.length; b < g; b++)
            f = d[b], this._frames.push({
              image: this._images[f[4] ? f[4] : 0],
              rect: new createjs.Rectangle(f[0], f[1], f[2], f[3]),
              regX: f[5] || 0,
              regY: f[6] || 0
            });
        } else
          g = a.frames, this._frameWidth = g.width, this._frameHeight = g.height, this._regX = g.regX || 0, this._regY = g.regY || 0, this._numFrames = g.count, 0 == this._loadCount && this._calculateFrames();
      if (null != (g = a.animations)) {
        this._animations = [];
        this._data = {};
        for (var h in g) {
          a = { name: h };
          f = g[h];
          if ('number' == typeof f)
            d = a.frames = [f];
          else if (f instanceof Array)
            if (1 == f.length)
              a.frames = [f[0]];
            else {
              a.frequency = f[3];
              a.next = f[2];
              d = a.frames = [];
              for (b = f[0]; b <= f[1]; b++)
                d.push(b);
            }
          else
            a.frequency = f.frequency, a.next = f.next, b = f.frames, d = a.frames = 'number' == typeof b ? [b] : b.slice(0);
          a.next = 2 > d.length || !1 == a.next ? null : null == a.next || !0 == a.next ? h : a.next;
          a.frequency || (a.frequency = 1);
          this._animations.push(h);
          this._data[h] = a;
        }
      }
    }
  };
  b.getNumFrames = function (a) {
    if (null == a)
      return this._frames ? this._frames.length : this._numFrames;
    a = this._data[a];
    return null == a ? 0 : a.frames.length;
  };
  b.getAnimations = function () {
    return this._animations.slice(0);
  };
  b.getAnimation = function (a) {
    return this._data[a];
  };
  b.getFrame = function (a) {
    var b;
    return this.complete && this._frames && (b = this._frames[a]) ? b : null;
  };
  b.getFrameBounds = function (a) {
    return (a = this.getFrame(a)) ? new createjs.Rectangle(-a.regX, -a.regY, a.rect.width, a.rect.height) : null;
  };
  b.toString = function () {
    return '[SpriteSheet]';
  };
  b.clone = function () {
    var a = new c();
    a.complete = this.complete;
    a._animations = this._animations;
    a._frames = this._frames;
    a._images = this._images;
    a._data = this._data;
    a._frameHeight = this._frameHeight;
    a._frameWidth = this._frameWidth;
    a._numFrames = this._numFrames;
    a._loadCount = this._loadCount;
    return a;
  };
  b._handleImageLoad = function () {
    0 == --this._loadCount && (this._calculateFrames(), this.complete = !0, this.onComplete && this.onComplete(), this.dispatchEvent('complete'));
  };
  b._calculateFrames = function () {
    if (!(this._frames || 0 == this._frameWidth)) {
      this._frames = [];
      for (var a = 0, b = this._frameWidth, g = this._frameHeight, d = 0, c = this._images; d < c.length; d++) {
        for (var f = c[d], h = (f.width + 1) / b | 0, k = (f.height + 1) / g | 0, k = 0 < this._numFrames ? Math.min(this._numFrames - a, h * k) : h * k, j = 0; j < k; j++)
          this._frames.push({
            image: f,
            rect: new createjs.Rectangle(j % h * b, (j / h | 0) * g, b, g),
            regX: this._regX,
            regY: this._regY
          });
        a += k;
      }
      this._numFrames = a;
    }
  };
  createjs.SpriteSheet = c;
}());
this.createjs = this.createjs || {};
(function () {
  function c(a, b, d) {
    this.f = a;
    this.params = b;
    this.path = null == d ? !0 : d;
  }
  c.prototype.exec = function (a) {
    this.f.apply(a, this.params);
  };
  var b = function () {
      this.initialize();
    }, a = b.prototype;
  b.getRGB = function (a, b, d, c) {
    null != a && null == d && (c = b, d = a & 255, b = a >> 8 & 255, a = a >> 16 & 255);
    return null == c ? 'rgb(' + a + ',' + b + ',' + d + ')' : 'rgba(' + a + ',' + b + ',' + d + ',' + c + ')';
  };
  b.getHSL = function (a, b, d, c) {
    return null == c ? 'hsl(' + a % 360 + ',' + b + '%,' + d + '%)' : 'hsla(' + a % 360 + ',' + b + '%,' + d + '%,' + c + ')';
  };
  b.BASE_64 = {
    A: 0,
    B: 1,
    C: 2,
    D: 3,
    E: 4,
    F: 5,
    G: 6,
    H: 7,
    I: 8,
    J: 9,
    K: 10,
    L: 11,
    M: 12,
    N: 13,
    O: 14,
    P: 15,
    Q: 16,
    R: 17,
    S: 18,
    T: 19,
    U: 20,
    V: 21,
    W: 22,
    X: 23,
    Y: 24,
    Z: 25,
    a: 26,
    b: 27,
    c: 28,
    d: 29,
    e: 30,
    f: 31,
    g: 32,
    h: 33,
    i: 34,
    j: 35,
    k: 36,
    l: 37,
    m: 38,
    n: 39,
    o: 40,
    p: 41,
    q: 42,
    r: 43,
    s: 44,
    t: 45,
    u: 46,
    v: 47,
    w: 48,
    x: 49,
    y: 50,
    z: 51,
    '0': 52,
    1: 53,
    2: 54,
    3: 55,
    4: 56,
    5: 57,
    6: 58,
    7: 59,
    8: 60,
    9: 61,
    '+': 62,
    '/': 63
  };
  b.STROKE_CAPS_MAP = [
    'butt',
    'round',
    'square'
  ];
  b.STROKE_JOINTS_MAP = [
    'miter',
    'round',
    'bevel'
  ];
  b._ctx = (createjs.createCanvas ? createjs.createCanvas() : document.createElement('canvas')).getContext('2d');
  b.beginCmd = new c(b._ctx.beginPath, [], !1);
  b.fillCmd = new c(b._ctx.fill, [], !1);
  b.strokeCmd = new c(b._ctx.stroke, [], !1);
  a._strokeInstructions = null;
  a._strokeStyleInstructions = null;
  a._ignoreScaleStroke = !1;
  a._fillInstructions = null;
  a._instructions = null;
  a._oldInstructions = null;
  a._activeInstructions = null;
  a._active = !1;
  a._dirty = !1;
  a.initialize = function () {
    this.clear();
    this._ctx = b._ctx;
  };
  a.isEmpty = function () {
    return !(this._instructions.length || this._oldInstructions.length || this._activeInstructions.length);
  };
  a.draw = function (a) {
    this._dirty && this._updateInstructions();
    for (var b = this._instructions, d = 0, c = b.length; d < c; d++)
      b[d].exec(a);
  };
  a.drawAsPath = function (a) {
    this._dirty && this._updateInstructions();
    for (var b, d = this._instructions, c = 0, f = d.length; c < f; c++)
      ((b = d[c]).path || 0 == c) && b.exec(a);
  };
  a.moveTo = function (a, b) {
    this._activeInstructions.push(new c(this._ctx.moveTo, [
      a,
      b
    ]));
    return this;
  };
  a.lineTo = function (a, b) {
    this._dirty = this._active = !0;
    this._activeInstructions.push(new c(this._ctx.lineTo, [
      a,
      b
    ]));
    return this;
  };
  a.arcTo = function (a, b, d, e, f) {
    this._dirty = this._active = !0;
    this._activeInstructions.push(new c(this._ctx.arcTo, [
      a,
      b,
      d,
      e,
      f
    ]));
    return this;
  };
  a.arc = function (a, b, d, e, f, h) {
    this._dirty = this._active = !0;
    null == h && (h = !1);
    this._activeInstructions.push(new c(this._ctx.arc, [
      a,
      b,
      d,
      e,
      f,
      h
    ]));
    return this;
  };
  a.quadraticCurveTo = function (a, b, d, e) {
    this._dirty = this._active = !0;
    this._activeInstructions.push(new c(this._ctx.quadraticCurveTo, [
      a,
      b,
      d,
      e
    ]));
    return this;
  };
  a.bezierCurveTo = function (a, b, d, e, f, h) {
    this._dirty = this._active = !0;
    this._activeInstructions.push(new c(this._ctx.bezierCurveTo, [
      a,
      b,
      d,
      e,
      f,
      h
    ]));
    return this;
  };
  a.rect = function (a, b, d, e) {
    this._dirty = this._active = !0;
    this._activeInstructions.push(new c(this._ctx.rect, [
      a,
      b,
      d,
      e
    ]));
    return this;
  };
  a.closePath = function () {
    this._active && (this._dirty = !0, this._activeInstructions.push(new c(this._ctx.closePath, [])));
    return this;
  };
  a.clear = function () {
    this._instructions = [];
    this._oldInstructions = [];
    this._activeInstructions = [];
    this._strokeStyleInstructions = this._strokeInstructions = this._fillInstructions = null;
    this._active = this._dirty = !1;
    return this;
  };
  a.beginFill = function (a) {
    this._active && this._newPath();
    this._fillInstructions = a ? [
      new c(this._setProp, [
        'fillStyle',
        a
      ], !1),
      b.fillCmd
    ] : null;
    return this;
  };
  a.beginLinearGradientFill = function (a, g, d, e, f, h) {
    this._active && this._newPath();
    d = this._ctx.createLinearGradient(d, e, f, h);
    e = 0;
    for (f = a.length; e < f; e++)
      d.addColorStop(g[e], a[e]);
    this._fillInstructions = [
      new c(this._setProp, [
        'fillStyle',
        d
      ], !1),
      b.fillCmd
    ];
    return this;
  };
  a.beginRadialGradientFill = function (a, g, d, e, f, h, k, j) {
    this._active && this._newPath();
    d = this._ctx.createRadialGradient(d, e, f, h, k, j);
    e = 0;
    for (f = a.length; e < f; e++)
      d.addColorStop(g[e], a[e]);
    this._fillInstructions = [
      new c(this._setProp, [
        'fillStyle',
        d
      ], !1),
      b.fillCmd
    ];
    return this;
  };
  a.beginBitmapFill = function (a, g, d) {
    this._active && this._newPath();
    a = this._ctx.createPattern(a, g || '');
    a = new c(this._setProp, [
      'fillStyle',
      a
    ], !1);
    this._fillInstructions = d ? [
      a,
      new c(this._ctx.save, [], !1),
      new c(this._ctx.transform, [
        d.a,
        d.b,
        d.c,
        d.d,
        d.tx,
        d.ty
      ], !1),
      b.fillCmd,
      new c(this._ctx.restore, [], !1)
    ] : [
      a,
      b.fillCmd
    ];
    return this;
  };
  a.endFill = function () {
    return this.beginFill();
  };
  a.setStrokeStyle = function (a, g, d, e, f) {
    this._active && this._newPath();
    this._strokeStyleInstructions = [
      new c(this._setProp, [
        'lineWidth',
        null == a ? '1' : a
      ], !1),
      new c(this._setProp, [
        'lineCap',
        null == g ? 'butt' : isNaN(g) ? g : b.STROKE_CAPS_MAP[g]
      ], !1),
      new c(this._setProp, [
        'lineJoin',
        null == d ? 'miter' : isNaN(d) ? d : b.STROKE_JOINTS_MAP[d]
      ], !1),
      new c(this._setProp, [
        'miterLimit',
        null == e ? '10' : e
      ], !1)
    ];
    this._ignoreScaleStroke = f;
    return this;
  };
  a.beginStroke = function (a) {
    this._active && this._newPath();
    this._strokeInstructions = a ? [new c(this._setProp, [
        'strokeStyle',
        a
      ], !1)] : null;
    return this;
  };
  a.beginLinearGradientStroke = function (a, b, d, e, f, h) {
    this._active && this._newPath();
    d = this._ctx.createLinearGradient(d, e, f, h);
    e = 0;
    for (f = a.length; e < f; e++)
      d.addColorStop(b[e], a[e]);
    this._strokeInstructions = [new c(this._setProp, [
        'strokeStyle',
        d
      ], !1)];
    return this;
  };
  a.beginRadialGradientStroke = function (a, b, d, e, f, h, k, j) {
    this._active && this._newPath();
    d = this._ctx.createRadialGradient(d, e, f, h, k, j);
    e = 0;
    for (f = a.length; e < f; e++)
      d.addColorStop(b[e], a[e]);
    this._strokeInstructions = [new c(this._setProp, [
        'strokeStyle',
        d
      ], !1)];
    return this;
  };
  a.beginBitmapStroke = function (a, b) {
    this._active && this._newPath();
    var d = this._ctx.createPattern(a, b || '');
    this._strokeInstructions = [new c(this._setProp, [
        'strokeStyle',
        d
      ], !1)];
    return this;
  };
  a.endStroke = function () {
    this.beginStroke();
    return this;
  };
  a.curveTo = a.quadraticCurveTo;
  a.drawRect = a.rect;
  a.drawRoundRect = function (a, b, d, c, f) {
    this.drawRoundRectComplex(a, b, d, c, f, f, f, f);
    return this;
  };
  a.drawRoundRectComplex = function (a, b, d, e, f, h, k, j) {
    var l = (d < e ? d : e) / 2, n = 0, q = 0, p = 0, s = 0;
    0 > f && (f *= n = -1);
    f > l && (f = l);
    0 > h && (h *= q = -1);
    h > l && (h = l);
    0 > k && (k *= p = -1);
    k > l && (k = l);
    0 > j && (j *= s = -1);
    j > l && (j = l);
    this._dirty = this._active = !0;
    var l = this._ctx.arcTo, r = this._ctx.lineTo;
    this._activeInstructions.push(new c(this._ctx.moveTo, [
      a + d - h,
      b
    ]), new c(l, [
      a + d + h * q,
      b - h * q,
      a + d,
      b + h,
      h
    ]), new c(r, [
      a + d,
      b + e - k
    ]), new c(l, [
      a + d + k * p,
      b + e + k * p,
      a + d - k,
      b + e,
      k
    ]), new c(r, [
      a + j,
      b + e
    ]), new c(l, [
      a - j * s,
      b + e + j * s,
      a,
      b + e - j,
      j
    ]), new c(r, [
      a,
      b + f
    ]), new c(l, [
      a - f * n,
      b - f * n,
      a + f,
      b,
      f
    ]), new c(this._ctx.closePath));
    return this;
  };
  a.drawCircle = function (a, b, d) {
    this.arc(a, b, d, 0, 2 * Math.PI);
    return this;
  };
  a.drawEllipse = function (a, b, d, e) {
    this._dirty = this._active = !0;
    var f = 0.5522848 * (d / 2), h = 0.5522848 * (e / 2), k = a + d, j = b + e;
    d = a + d / 2;
    e = b + e / 2;
    this._activeInstructions.push(new c(this._ctx.moveTo, [
      a,
      e
    ]), new c(this._ctx.bezierCurveTo, [
      a,
      e - h,
      d - f,
      b,
      d,
      b
    ]), new c(this._ctx.bezierCurveTo, [
      d + f,
      b,
      k,
      e - h,
      k,
      e
    ]), new c(this._ctx.bezierCurveTo, [
      k,
      e + h,
      d + f,
      j,
      d,
      j
    ]), new c(this._ctx.bezierCurveTo, [
      d - f,
      j,
      a,
      e + h,
      a,
      e
    ]));
    return this;
  };
  a.drawPolyStar = function (a, b, d, e, f, h) {
    this._dirty = this._active = !0;
    null == f && (f = 0);
    f = 1 - f;
    h = null == h ? 0 : h / (180 / Math.PI);
    var k = Math.PI / e;
    this._activeInstructions.push(new c(this._ctx.moveTo, [
      a + Math.cos(h) * d,
      b + Math.sin(h) * d
    ]));
    for (var j = 0; j < e; j++)
      h += k, 1 != f && this._activeInstructions.push(new c(this._ctx.lineTo, [
        a + Math.cos(h) * d * f,
        b + Math.sin(h) * d * f
      ])), h += k, this._activeInstructions.push(new c(this._ctx.lineTo, [
        a + Math.cos(h) * d,
        b + Math.sin(h) * d
      ]));
    return this;
  };
  a.decodePath = function (a) {
    for (var g = [
          this.moveTo,
          this.lineTo,
          this.quadraticCurveTo,
          this.bezierCurveTo,
          this.closePath
        ], d = [
          2,
          2,
          4,
          6,
          0
        ], c = 0, f = a.length, h = [], k = 0, j = 0, l = b.BASE_64; c < f;) {
      var n = a.charAt(c), q = l[n], p = q >> 3, s = g[p];
      if (!s || q & 3)
        throw 'bad path data (@' + c + '): ' + n;
      n = d[p];
      p || (k = j = 0);
      h.length = 0;
      c++;
      q = (q >> 2 & 1) + 2;
      for (p = 0; p < n; p++) {
        var r = l[a.charAt(c)], u = r >> 5 ? -1 : 1, r = (r & 31) << 6 | l[a.charAt(c + 1)];
        3 == q && (r = r << 6 | l[a.charAt(c + 2)]);
        r = u * r / 10;
        p % 2 ? k = r += k : j = r += j;
        h[p] = r;
        c += q;
      }
      s.apply(this, h);
    }
    return this;
  };
  a.clone = function () {
    var a = new b();
    a._instructions = this._instructions.slice();
    a._activeInstructions = this._activeInstructions.slice();
    a._oldInstructions = this._oldInstructions.slice();
    this._fillInstructions && (a._fillInstructions = this._fillInstructions.slice());
    this._strokeInstructions && (a._strokeInstructions = this._strokeInstructions.slice());
    this._strokeStyleInstructions && (a._strokeStyleInstructions = this._strokeStyleInstructions.slice());
    a._active = this._active;
    a._dirty = this._dirty;
    return a;
  };
  a.toString = function () {
    return '[Graphics]';
  };
  a.mt = a.moveTo;
  a.lt = a.lineTo;
  a.at = a.arcTo;
  a.bt = a.bezierCurveTo;
  a.qt = a.quadraticCurveTo;
  a.a = a.arc;
  a.r = a.rect;
  a.cp = a.closePath;
  a.c = a.clear;
  a.f = a.beginFill;
  a.lf = a.beginLinearGradientFill;
  a.rf = a.beginRadialGradientFill;
  a.bf = a.beginBitmapFill;
  a.ef = a.endFill;
  a.ss = a.setStrokeStyle;
  a.s = a.beginStroke;
  a.ls = a.beginLinearGradientStroke;
  a.rs = a.beginRadialGradientStroke;
  a.bs = a.beginBitmapStroke;
  a.es = a.endStroke;
  a.dr = a.drawRect;
  a.rr = a.drawRoundRect;
  a.rc = a.drawRoundRectComplex;
  a.dc = a.drawCircle;
  a.de = a.drawEllipse;
  a.dp = a.drawPolyStar;
  a.p = a.decodePath;
  a._updateInstructions = function () {
    this._instructions = this._oldInstructions.slice();
    this._instructions.push(b.beginCmd);
    this._instructions.push.apply(this._instructions, this._activeInstructions);
    this._fillInstructions && this._instructions.push.apply(this._instructions, this._fillInstructions);
    this._strokeInstructions && (this._strokeStyleInstructions && this._instructions.push.apply(this._instructions, this._strokeStyleInstructions), this._instructions.push.apply(this._instructions, this._strokeInstructions), this._ignoreScaleStroke ? this._instructions.push(new c(this._ctx.save, [], !1), new c(this._ctx.setTransform, [
      1,
      0,
      0,
      1,
      0,
      0
    ], !1), b.strokeCmd, new c(this._ctx.restore, [], !1)) : this._instructions.push(b.strokeCmd));
  };
  a._newPath = function () {
    this._dirty && this._updateInstructions();
    this._oldInstructions = this._instructions;
    this._activeInstructions = [];
    this._active = this._dirty = !1;
  };
  a._setProp = function (a, b) {
    this[a] = b;
  };
  createjs.Graphics = b;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function () {
      this.initialize();
    }, b = c.prototype;
  c.suppressCrossDomainErrors = !1;
  c._hitTestCanvas = createjs.createCanvas ? createjs.createCanvas() : document.createElement('canvas');
  c._hitTestCanvas.width = c._hitTestCanvas.height = 1;
  c._hitTestContext = c._hitTestCanvas.getContext('2d');
  c._nextCacheID = 1;
  b.alpha = 1;
  b.cacheCanvas = null;
  b.id = -1;
  b.mouseEnabled = !0;
  b.name = null;
  b.parent = null;
  b.regX = 0;
  b.regY = 0;
  b.rotation = 0;
  b.scaleX = 1;
  b.scaleY = 1;
  b.skewX = 0;
  b.skewY = 0;
  b.shadow = null;
  b.visible = !0;
  b.x = 0;
  b.y = 0;
  b.compositeOperation = null;
  b.snapToPixel = !1;
  b.onPress = null;
  b.onClick = null;
  b.onDoubleClick = null;
  b.onMouseOver = null;
  b.onMouseOut = null;
  b.onTick = null;
  b.filters = null;
  b.cacheID = 0;
  b.mask = null;
  b.hitArea = null;
  b.cursor = null;
  b.addEventListener = null;
  b.removeEventListener = null;
  b.removeAllEventListeners = null;
  b.dispatchEvent = null;
  b.hasEventListener = null;
  b._listeners = null;
  createjs.EventDispatcher.initialize(b);
  b._cacheOffsetX = 0;
  b._cacheOffsetY = 0;
  b._cacheScale = 1;
  b._cacheDataURLID = 0;
  b._cacheDataURL = null;
  b._matrix = null;
  b.initialize = function () {
    this.id = createjs.UID.get();
    this._matrix = new createjs.Matrix2D();
  };
  b.isVisible = function () {
    return !(!this.visible || !(0 < this.alpha && 0 != this.scaleX && 0 != this.scaleY));
  };
  b.draw = function (a, b) {
    var c = this.cacheCanvas;
    if (b || !c)
      return !1;
    var d = this._cacheScale;
    a.drawImage(c, this._cacheOffsetX, this._cacheOffsetY, c.width / d, c.height / d);
    return !0;
  };
  b.updateContext = function (a) {
    var b, c = this.mask;
    c && (c.graphics && !c.graphics.isEmpty()) && (b = c.getMatrix(c._matrix), a.transform(b.a, b.b, b.c, b.d, b.tx, b.ty), c.graphics.drawAsPath(a), a.clip(), b.invert(), a.transform(b.a, b.b, b.c, b.d, b.tx, b.ty));
    b = this._matrix.identity().appendTransform(this.x, this.y, this.scaleX, this.scaleY, this.rotation, this.skewX, this.skewY, this.regX, this.regY);
    createjs.Stage._snapToPixelEnabled && this.snapToPixel ? a.transform(b.a, b.b, b.c, b.d, b.tx + 0.5 | 0, b.ty + 0.5 | 0) : a.transform(b.a, b.b, b.c, b.d, b.tx, b.ty);
    a.globalAlpha *= this.alpha;
    this.compositeOperation && (a.globalCompositeOperation = this.compositeOperation);
    this.shadow && this._applyShadow(a, this.shadow);
  };
  b.cache = function (a, b, c, d, e) {
    e = e || 1;
    this.cacheCanvas || (this.cacheCanvas = createjs.createCanvas ? createjs.createCanvas() : document.createElement('canvas'));
    this.cacheCanvas.width = Math.ceil(c * e);
    this.cacheCanvas.height = Math.ceil(d * e);
    this._cacheOffsetX = a;
    this._cacheOffsetY = b;
    this._cacheScale = e || 1;
    this.updateCache();
  };
  b.updateCache = function (a) {
    var b = this.cacheCanvas, g = this._cacheScale, d = this._cacheOffsetX * g, e = this._cacheOffsetY * g;
    if (!b)
      throw 'cache() must be called before updateCache()';
    var f = b.getContext('2d');
    f.save();
    a || f.clearRect(0, 0, b.width + 1, b.height + 1);
    f.globalCompositeOperation = a;
    f.setTransform(g, 0, 0, g, -d, -e);
    this.draw(f, !0);
    this._applyFilters();
    f.restore();
    this.cacheID = c._nextCacheID++;
  };
  b.uncache = function () {
    this._cacheDataURL = this.cacheCanvas = null;
    this.cacheID = this._cacheOffsetX = this._cacheOffsetY = 0;
    this._cacheScale = 1;
  };
  b.getCacheDataURL = function () {
    if (!this.cacheCanvas)
      return null;
    this.cacheID != this._cacheDataURLID && (this._cacheDataURL = this.cacheCanvas.toDataURL());
    return this._cacheDataURL;
  };
  b.getStage = function () {
    for (var a = this; a.parent;)
      a = a.parent;
    return a instanceof createjs.Stage ? a : null;
  };
  b.localToGlobal = function (a, b) {
    var c = this.getConcatenatedMatrix(this._matrix);
    if (null == c)
      return null;
    c.append(1, 0, 0, 1, a, b);
    return new createjs.Point(c.tx, c.ty);
  };
  b.globalToLocal = function (a, b) {
    var c = this.getConcatenatedMatrix(this._matrix);
    if (null == c)
      return null;
    c.invert();
    c.append(1, 0, 0, 1, a, b);
    return new createjs.Point(c.tx, c.ty);
  };
  b.localToLocal = function (a, b, c) {
    a = this.localToGlobal(a, b);
    return c.globalToLocal(a.x, a.y);
  };
  b.setTransform = function (a, b, c, d, e, f, h, k, j) {
    this.x = a || 0;
    this.y = b || 0;
    this.scaleX = null == c ? 1 : c;
    this.scaleY = null == d ? 1 : d;
    this.rotation = e || 0;
    this.skewX = f || 0;
    this.skewY = h || 0;
    this.regX = k || 0;
    this.regY = j || 0;
    return this;
  };
  b.getMatrix = function (a) {
    return (a ? a.identity() : new createjs.Matrix2D()).appendTransform(this.x, this.y, this.scaleX, this.scaleY, this.rotation, this.skewX, this.skewY, this.regX, this.regY).appendProperties(this.alpha, this.shadow, this.compositeOperation);
  };
  b.getConcatenatedMatrix = function (a) {
    a ? a.identity() : a = new createjs.Matrix2D();
    for (var b = this; null != b;)
      a.prependTransform(b.x, b.y, b.scaleX, b.scaleY, b.rotation, b.skewX, b.skewY, b.regX, b.regY).prependProperties(b.alpha, b.shadow, b.compositeOperation), b = b.parent;
    return a;
  };
  b.hitTest = function (a, b) {
    var g = c._hitTestContext;
    g.setTransform(1, 0, 0, 1, -a, -b);
    this.draw(g);
    var d = this._testHit(g);
    g.setTransform(1, 0, 0, 1, 0, 0);
    g.clearRect(0, 0, 2, 2);
    return d;
  };
  b.set = function (a) {
    for (var b in a)
      this[b] = a[b];
    return this;
  };
  b.clone = function () {
    var a = new c();
    this.cloneProps(a);
    return a;
  };
  b.toString = function () {
    return '[DisplayObject (name=' + this.name + ')]';
  };
  b.cloneProps = function (a) {
    a.alpha = this.alpha;
    a.name = this.name;
    a.regX = this.regX;
    a.regY = this.regY;
    a.rotation = this.rotation;
    a.scaleX = this.scaleX;
    a.scaleY = this.scaleY;
    a.shadow = this.shadow;
    a.skewX = this.skewX;
    a.skewY = this.skewY;
    a.visible = this.visible;
    a.x = this.x;
    a.y = this.y;
    a.mouseEnabled = this.mouseEnabled;
    a.compositeOperation = this.compositeOperation;
    this.cacheCanvas && (a.cacheCanvas = this.cacheCanvas.cloneNode(!0), a.cacheCanvas.getContext('2d').putImageData(this.cacheCanvas.getContext('2d').getImageData(0, 0, this.cacheCanvas.width, this.cacheCanvas.height), 0, 0));
  };
  b._applyShadow = function (a, b) {
    b = b || Shadow.identity;
    a.shadowColor = b.color;
    a.shadowOffsetX = b.offsetX;
    a.shadowOffsetY = b.offsetY;
    a.shadowBlur = b.blur;
  };
  b._tick = function (a) {
    this.onTick && this.onTick.apply(this, a);
    var b = this._listeners;
    b && b.tick && this.dispatchEvent({
      type: 'tick',
      params: a
    });
  };
  b._testHit = function (a) {
    try {
      var b = 1 < a.getImageData(0, 0, 1, 1).data[3];
    } catch (g) {
      if (!c.suppressCrossDomainErrors)
        throw 'An error has occurred. This is most likely due to security restrictions on reading canvas pixel data with local or cross-domain images.';
    }
    return b;
  };
  b._applyFilters = function () {
    if (this.filters && 0 != this.filters.length && this.cacheCanvas)
      for (var a = this.filters.length, b = this.cacheCanvas.getContext('2d'), c = this.cacheCanvas.width, d = this.cacheCanvas.height, e = 0; e < a; e++)
        this.filters[e].applyFilter(b, 0, 0, c, d);
  };
  b._hasMouseHandler = function (a) {
    var b = this._listeners;
    return !!(a & 1 && (this.onPress || this.onClick || this.onDoubleClick || b && (this.hasEventListener('mousedown') || this.hasEventListener('click') || this.hasEventListener('dblclick'))) || a & 2 && (this.onMouseOver || this.onMouseOut || this.cursor || b && (this.hasEventListener('mouseover') || this.hasEventListener('mouseout'))));
  };
  createjs.DisplayObject = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function () {
      this.initialize();
    }, b = c.prototype = new createjs.DisplayObject();
  b.children = null;
  b.DisplayObject_initialize = b.initialize;
  b.initialize = function () {
    this.DisplayObject_initialize();
    this.children = [];
  };
  b.isVisible = function () {
    var a = this.cacheCanvas || this.children.length;
    return !(!this.visible || !(0 < this.alpha && 0 != this.scaleX && 0 != this.scaleY && a));
  };
  b.DisplayObject_draw = b.draw;
  b.draw = function (a, b) {
    if (this.DisplayObject_draw(a, b))
      return !0;
    for (var c = this.children.slice(0), d = 0, e = c.length; d < e; d++) {
      var f = c[d];
      f.isVisible() && (a.save(), f.updateContext(a), f.draw(a), a.restore());
    }
    return !0;
  };
  b.addChild = function (a) {
    if (null == a)
      return a;
    var b = arguments.length;
    if (1 < b) {
      for (var c = 0; c < b; c++)
        this.addChild(arguments[c]);
      return arguments[b - 1];
    }
    a.parent && a.parent.removeChild(a);
    a.parent = this;
    this.children.push(a);
    return a;
  };
  b.addChildAt = function (a, b) {
    var c = arguments.length, d = arguments[c - 1];
    if (0 > d || d > this.children.length)
      return arguments[c - 2];
    if (2 < c) {
      for (var e = 0; e < c - 1; e++)
        this.addChildAt(arguments[e], d + e);
      return arguments[c - 2];
    }
    a.parent && a.parent.removeChild(a);
    a.parent = this;
    this.children.splice(b, 0, a);
    return a;
  };
  b.removeChild = function (a) {
    var b = arguments.length;
    if (1 < b) {
      for (var c = !0, d = 0; d < b; d++)
        c = c && this.removeChild(arguments[d]);
      return c;
    }
    return this.removeChildAt(this.children.indexOf(a));
  };
  b.removeChildAt = function (a) {
    var b = arguments.length;
    if (1 < b) {
      for (var c = [], d = 0; d < b; d++)
        c[d] = arguments[d];
      c.sort(function (a, b) {
        return b - a;
      });
      for (var e = !0, d = 0; d < b; d++)
        e = e && this.removeChildAt(c[d]);
      return e;
    }
    if (0 > a || a > this.children.length - 1)
      return !1;
    if (b = this.children[a])
      b.parent = null;
    this.children.splice(a, 1);
    return !0;
  };
  b.removeAllChildren = function () {
    for (var a = this.children; a.length;)
      a.pop().parent = null;
  };
  b.getChildAt = function (a) {
    return this.children[a];
  };
  b.getChildByName = function (a) {
    for (var b = this.children, c = 0, d = b.length; c < d; c++)
      if (b[c].name == a)
        return b[c];
    return null;
  };
  b.sortChildren = function (a) {
    this.children.sort(a);
  };
  b.getChildIndex = function (a) {
    return this.children.indexOf(a);
  };
  b.getNumChildren = function () {
    return this.children.length;
  };
  b.swapChildrenAt = function (a, b) {
    var c = this.children, d = c[a], e = c[b];
    d && e && (c[a] = e, c[b] = d);
  };
  b.swapChildren = function (a, b) {
    for (var c = this.children, d, e, f = 0, h = c.length; f < h && !(c[f] == a && (d = f), c[f] == b && (e = f), null != d && null != e); f++);
    f != h && (c[d] = b, c[e] = a);
  };
  b.setChildIndex = function (a, b) {
    var c = this.children, d = c.length;
    if (!(a.parent != this || 0 > b || b >= d)) {
      for (var e = 0; e < d && c[e] != a; e++);
      e == d || e == b || (c.splice(e, 1), b < e && b--, c.splice(b, 0, a));
    }
  };
  b.contains = function (a) {
    for (; a;) {
      if (a == this)
        return !0;
      a = a.parent;
    }
    return !1;
  };
  b.hitTest = function (a, b) {
    return null != this.getObjectUnderPoint(a, b);
  };
  b.getObjectsUnderPoint = function (a, b) {
    var c = [], d = this.localToGlobal(a, b);
    this._getObjectsUnderPoint(d.x, d.y, c);
    return c;
  };
  b.getObjectUnderPoint = function (a, b) {
    var c = this.localToGlobal(a, b);
    return this._getObjectsUnderPoint(c.x, c.y);
  };
  b.clone = function (a) {
    var b = new c();
    this.cloneProps(b);
    if (a)
      for (var g = b.children = [], d = 0, e = this.children.length; d < e; d++) {
        var f = this.children[d].clone(a);
        f.parent = b;
        g.push(f);
      }
    return b;
  };
  b.toString = function () {
    return '[Container (name=' + this.name + ')]';
  };
  b.DisplayObject__tick = b._tick;
  b._tick = function (a) {
    for (var b = this.children.length - 1; 0 <= b; b--) {
      var c = this.children[b];
      c._tick && c._tick(a);
    }
    this.DisplayObject__tick(a);
  };
  b._getObjectsUnderPoint = function (a, b, g, d) {
    var e = createjs.DisplayObject._hitTestContext, f = this._matrix, h = this._hasMouseHandler(d);
    if (!this.hitArea && (this.cacheCanvas && h) && (this.getConcatenatedMatrix(f), e.setTransform(f.a, f.b, f.c, f.d, f.tx - a, f.ty - b), e.globalAlpha = f.alpha, this.draw(e), this._testHit(e)))
      return e.setTransform(1, 0, 0, 1, 0, 0), e.clearRect(0, 0, 2, 2), this;
    for (var k = this.children.length - 1; 0 <= k; k--) {
      var j = this.children[k], l = j.hitArea;
      if (j.visible && !(!l && !j.isVisible() || d && !j.mouseEnabled)) {
        var n = d && j._hasMouseHandler(d);
        if (j instanceof c && (!l || !n))
          if (h) {
            if (j = j._getObjectsUnderPoint(a, b))
              return this;
          } else {
            if (j = j._getObjectsUnderPoint(a, b, g, d), !g && j)
              return j;
          }
        else if (!d || h || n)
          if (j.getConcatenatedMatrix(f), l && (f.appendTransform(l.x, l.y, l.scaleX, l.scaleY, l.rotation, l.skewX, l.skewY, l.regX, l.regY), f.alpha = l.alpha), e.globalAlpha = f.alpha, e.setTransform(f.a, f.b, f.c, f.d, f.tx - a, f.ty - b), (l || j).draw(e), this._testHit(e)) {
            e.setTransform(1, 0, 0, 1, 0, 0);
            e.clearRect(0, 0, 2, 2);
            if (h)
              return this;
            if (g)
              g.push(j);
            else
              return j;
          }
      }
    }
    return null;
  };
  createjs.Container = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function (a) {
      this.initialize(a);
    }, b = c.prototype = new createjs.Container();
  c._snapToPixelEnabled = !1;
  b.autoClear = !0;
  b.canvas = null;
  b.mouseX = 0;
  b.mouseY = 0;
  b.onMouseMove = null;
  b.onMouseUp = null;
  b.onMouseDown = null;
  b.snapToPixelEnabled = !1;
  b.mouseInBounds = !1;
  b.tickOnUpdate = !0;
  b.mouseMoveOutside = !1;
  b._pointerData = null;
  b._pointerCount = 0;
  b._primaryPointerID = null;
  b._mouseOverIntervalID = null;
  b.Container_initialize = b.initialize;
  b.initialize = function (a) {
    this.Container_initialize();
    this.canvas = 'string' == typeof a ? document.getElementById(a) : a;
    this._pointerData = {};
    this.enableDOMEvents(!0);
  };
  b.update = function () {
    if (this.canvas) {
      this.autoClear && this.clear();
      c._snapToPixelEnabled = this.snapToPixelEnabled;
      this.tickOnUpdate && this._tick(arguments.length ? arguments : null);
      var a = this.canvas.getContext('2d');
      a.save();
      this.updateContext(a);
      this.draw(a, !1);
      a.restore();
    }
  };
  b.tick = b.update;
  b.handleEvent = function (a) {
    'tick' == a.type && this.update(a);
  };
  b.clear = function () {
    if (this.canvas) {
      var a = this.canvas.getContext('2d');
      a.setTransform(1, 0, 0, 1, 0, 0);
      a.clearRect(0, 0, this.canvas.width + 1, this.canvas.height + 1);
    }
  };
  b.toDataURL = function (a, b) {
    b || (b = 'image/png');
    var c = this.canvas.getContext('2d'), d = this.canvas.width, e = this.canvas.height, f;
    if (a) {
      f = c.getImageData(0, 0, d, e);
      var h = c.globalCompositeOperation;
      c.globalCompositeOperation = 'destination-over';
      c.fillStyle = a;
      c.fillRect(0, 0, d, e);
    }
    var k = this.canvas.toDataURL(b);
    a && (c.clearRect(0, 0, d + 1, e + 1), c.putImageData(f, 0, 0), c.globalCompositeOperation = h);
    return k;
  };
  b.enableMouseOver = function (a) {
    this._mouseOverIntervalID && (clearInterval(this._mouseOverIntervalID), this._mouseOverIntervalID = null);
    if (null == a)
      a = 20;
    else if (0 >= a)
      return;
    var b = this;
    this._mouseOverIntervalID = setInterval(function () {
      b._testMouseOver();
    }, 1000 / Math.min(50, a));
  };
  b.enableDOMEvents = function (a) {
    null == a && (a = !0);
    var b, c = this._eventListeners;
    if (!a && c) {
      for (b in c)
        a = c[b], a.t.removeEventListener(b, a.f);
      this._eventListeners = null;
    } else if (a && !c && this.canvas) {
      a = window.addEventListener ? window : document;
      var d = this, c = this._eventListeners = {};
      c.mouseup = {
        t: a,
        f: function (a) {
          d._handleMouseUp(a);
        }
      };
      c.mousemove = {
        t: a,
        f: function (a) {
          d._handleMouseMove(a);
        }
      };
      c.dblclick = {
        t: a,
        f: function (a) {
          d._handleDoubleClick(a);
        }
      };
      c.mousedown = {
        t: this.canvas,
        f: function (a) {
          d._handleMouseDown(a);
        }
      };
      for (b in c)
        a = c[b], a.t.addEventListener(b, a.f);
    }
  };
  b.clone = function () {
    var a = new c(null);
    this.cloneProps(a);
    return a;
  };
  b.toString = function () {
    return '[Stage (name=' + this.name + ')]';
  };
  b._getPointerData = function (a) {
    var b = this._pointerData[a];
    if (!b && (b = this._pointerData[a] = {
        x: 0,
        y: 0
      }, null == this._primaryPointerID || -1 == this._primaryPointerID))
      this._primaryPointerID = a;
    return b;
  };
  b._handleMouseMove = function (a) {
    a || (a = window.event);
    this._handlePointerMove(-1, a, a.pageX, a.pageY);
  };
  b._handlePointerMove = function (a, b, c, d) {
    if (this.canvas) {
      var e = this._getPointerData(a), f = e.inBounds;
      this._updatePointerPosition(a, c, d);
      if (f || e.inBounds || this.mouseMoveOutside) {
        if (this.onMouseMove || this.hasEventListener('stagemousemove'))
          c = new createjs.MouseEvent('stagemousemove', e.x, e.y, this, b, a, a == this._primaryPointerID, e.rawX, e.rawY), this.onMouseMove && this.onMouseMove(c), this.dispatchEvent(c);
        if ((d = e.event) && (d.onMouseMove || d.hasEventListener('mousemove')))
          c = new createjs.MouseEvent('mousemove', e.x, e.y, d.target, b, a, a == this._primaryPointerID, e.rawX, e.rawY), d.onMouseMove && d.onMouseMove(c), d.dispatchEvent(c, d.target);
      }
    }
  };
  b._updatePointerPosition = function (a, b, c) {
    var d = this._getElementRect(this.canvas);
    b -= d.left;
    c -= d.top;
    var e = this.canvas.width, f = this.canvas.height;
    b /= (d.right - d.left) / e;
    c /= (d.bottom - d.top) / f;
    d = this._getPointerData(a);
    (d.inBounds = 0 <= b && 0 <= c && b <= e - 1 && c <= f - 1) ? (d.x = b, d.y = c) : this.mouseMoveOutside && (d.x = 0 > b ? 0 : b > e - 1 ? e - 1 : b, d.y = 0 > c ? 0 : c > f - 1 ? f - 1 : c);
    d.rawX = b;
    d.rawY = c;
    a == this._primaryPointerID && (this.mouseX = d.x, this.mouseY = d.y, this.mouseInBounds = d.inBounds);
  };
  b._getElementRect = function (a) {
    var b;
    try {
      b = a.getBoundingClientRect();
    } catch (c) {
      b = {
        top: a.offsetTop,
        left: a.offsetLeft,
        width: a.offsetWidth,
        height: a.offsetHeight
      };
    }
    var d = (window.pageXOffset || document.scrollLeft || 0) - (document.clientLeft || document.body.clientLeft || 0), e = (window.pageYOffset || document.scrollTop || 0) - (document.clientTop || document.body.clientTop || 0), f = window.getComputedStyle ? getComputedStyle(a) : a.currentStyle;
    a = parseInt(f.paddingLeft) + parseInt(f.borderLeftWidth);
    var h = parseInt(f.paddingTop) + parseInt(f.borderTopWidth), k = parseInt(f.paddingRight) + parseInt(f.borderRightWidth), f = parseInt(f.paddingBottom) + parseInt(f.borderBottomWidth);
    return {
      left: b.left + d + a,
      right: b.right + d - k,
      top: b.top + e + h,
      bottom: b.bottom + e - f
    };
  };
  b._handleMouseUp = function (a) {
    this._handlePointerUp(-1, a, !1);
  };
  b._handlePointerUp = function (a, b, c) {
    var d = this._getPointerData(a), e;
    if (this.onMouseMove || this.hasEventListener('stagemouseup'))
      e = new createjs.MouseEvent('stagemouseup', d.x, d.y, this, b, a, a == this._primaryPointerID, d.rawX, d.rawY), this.onMouseUp && this.onMouseUp(e), this.dispatchEvent(e);
    var f = d.event;
    if (f && (f.onMouseUp || f.hasEventListener('mouseup')))
      e = new createjs.MouseEvent('mouseup', d.x, d.y, f.target, b, a, a == this._primaryPointerID, d.rawX, d.rawY), f.onMouseUp && f.onMouseUp(e), f.dispatchEvent(e, f.target);
    if ((f = d.target) && (f.onClick || f.hasEventListener('click')) && this._getObjectsUnderPoint(d.x, d.y, null, !0, this._mouseOverIntervalID ? 3 : 1) == f)
      e = new createjs.MouseEvent('click', d.x, d.y, f, b, a, a == this._primaryPointerID, d.rawX, d.rawY), f.onClick && f.onClick(e), f.dispatchEvent(e);
    c ? (a == this._primaryPointerID && (this._primaryPointerID = null), delete this._pointerData[a]) : d.event = d.target = null;
  };
  b._handleMouseDown = function (a) {
    this._handlePointerDown(-1, a, !1);
  };
  b._handlePointerDown = function (a, b, c, d) {
    var e = this._getPointerData(a);
    null != d && this._updatePointerPosition(a, c, d);
    if (this.onMouseDown || this.hasEventListener('stagemousedown'))
      c = new createjs.MouseEvent('stagemousedown', e.x, e.y, this, b, a, a == this._primaryPointerID, e.rawX, e.rawY), this.onMouseDown && this.onMouseDown(c), this.dispatchEvent(c);
    if (d = this._getObjectsUnderPoint(e.x, e.y, null, this._mouseOverIntervalID ? 3 : 1))
      if (e.target = d, d.onPress || d.hasEventListener('mousedown'))
        if (c = new createjs.MouseEvent('mousedown', e.x, e.y, d, b, a, a == this._primaryPointerID, e.rawX, e.rawY), d.onPress && d.onPress(c), d.dispatchEvent(c), c.onMouseMove || c.onMouseUp || c.hasEventListener('mousemove') || c.hasEventListener('mouseup'))
          e.event = c;
  };
  b._testMouseOver = function () {
    if (-1 == this._primaryPointerID && !(this.mouseX == this._mouseOverX && this.mouseY == this._mouseOverY && this.mouseInBounds)) {
      var a = null;
      this.mouseInBounds && (a = this._getObjectsUnderPoint(this.mouseX, this.mouseY, null, 3), this._mouseOverX = this.mouseX, this._mouseOverY = this.mouseY);
      var b = this._mouseOverTarget;
      if (b != a) {
        var c = this._getPointerData(-1);
        if (b && (b.onMouseOut || b.hasEventListener('mouseout'))) {
          var d = new createjs.MouseEvent('mouseout', c.x, c.y, b, null, -1, c.rawX, c.rawY);
          b.onMouseOut && b.onMouseOut(d);
          b.dispatchEvent(d);
        }
        b && (this.canvas.style.cursor = '');
        if (a && (a.onMouseOver || a.hasEventListener('mouseover')))
          d = new createjs.MouseEvent('mouseover', c.x, c.y, a, null, -1, c.rawX, c.rawY), a.onMouseOver && a.onMouseOver(d), a.dispatchEvent(d);
        a && (this.canvas.style.cursor = a.cursor || '');
        this._mouseOverTarget = a;
      }
    }
  };
  b._handleDoubleClick = function (a) {
    var b = this._getPointerData(-1), c = this._getObjectsUnderPoint(b.x, b.y, null, this._mouseOverIntervalID ? 3 : 1);
    if (c && (c.onDoubleClick || c.hasEventListener('dblclick')))
      evt = new createjs.MouseEvent('dblclick', b.x, b.y, c, a, -1, !0, b.rawX, b.rawY), c.onDoubleClick && c.onDoubleClick(evt), c.dispatchEvent(evt);
  };
  createjs.Stage = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function (a) {
      this.initialize(a);
    }, b = c.prototype = new createjs.DisplayObject();
  b.image = null;
  b.snapToPixel = !0;
  b.sourceRect = null;
  b.DisplayObject_initialize = b.initialize;
  b.initialize = function (a) {
    this.DisplayObject_initialize();
    'string' == typeof a ? (this.image = new Image(), this.image.src = a) : this.image = a;
  };
  b.isVisible = function () {
    var a = this.cacheCanvas || this.image && (this.image.complete || this.image.getContext || 2 <= this.image.readyState);
    return !(!this.visible || !(0 < this.alpha && 0 != this.scaleX && 0 != this.scaleY && a));
  };
  b.DisplayObject_draw = b.draw;
  b.draw = function (a, b) {
    if (this.DisplayObject_draw(a, b))
      return !0;
    var c = this.sourceRect;
    c ? a.drawImage(this.image, c.x, c.y, c.width, c.height, 0, 0, c.width, c.height) : a.drawImage(this.image, 0, 0);
    return !0;
  };
  b.clone = function () {
    var a = new c(this.image);
    this.sourceRect && (a.sourceRect = this.sourceRect.clone());
    this.cloneProps(a);
    return a;
  };
  b.toString = function () {
    return '[Bitmap (name=' + this.name + ')]';
  };
  createjs.Bitmap = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function (a) {
      this.initialize(a);
    }, b = c.prototype = new createjs.DisplayObject();
  b.onAnimationEnd = null;
  b.currentFrame = -1;
  b.currentAnimation = null;
  b.paused = !0;
  b.spriteSheet = null;
  b.snapToPixel = !0;
  b.offset = 0;
  b.currentAnimationFrame = 0;
  b.addEventListener = null;
  b.removeEventListener = null;
  b.removeAllEventListeners = null;
  b.dispatchEvent = null;
  b.hasEventListener = null;
  b._listeners = null;
  createjs.EventDispatcher.initialize(b);
  b._advanceCount = 0;
  b._animation = null;
  b.DisplayObject_initialize = b.initialize;
  b.initialize = function (a) {
    this.DisplayObject_initialize();
    this.spriteSheet = a;
  };
  b.isVisible = function () {
    var a = this.cacheCanvas || this.spriteSheet.complete && 0 <= this.currentFrame;
    return !(!this.visible || !(0 < this.alpha && 0 != this.scaleX && 0 != this.scaleY && a));
  };
  b.DisplayObject_draw = b.draw;
  b.draw = function (a, b) {
    if (this.DisplayObject_draw(a, b))
      return !0;
    this._normalizeFrame();
    var c = this.spriteSheet.getFrame(this.currentFrame);
    if (c) {
      var d = c.rect;
      a.drawImage(c.image, d.x, d.y, d.width, d.height, -c.regX, -c.regY, d.width, d.height);
      return !0;
    }
  };
  b.play = function () {
    this.paused = !1;
  };
  b.stop = function () {
    this.paused = !0;
  };
  b.gotoAndPlay = function (a) {
    this.paused = !1;
    this._goto(a);
  };
  b.gotoAndStop = function (a) {
    this.paused = !0;
    this._goto(a);
  };
  b.advance = function () {
    this._animation ? this.currentAnimationFrame++ : this.currentFrame++;
    this._normalizeFrame();
  };
  b.getBounds = function () {
    return this.spriteSheet.getFrameBounds(this.currentFrame);
  };
  b.clone = function () {
    var a = new c(this.spriteSheet);
    this.cloneProps(a);
    return a;
  };
  b.toString = function () {
    return '[BitmapAnimation (name=' + this.name + ')]';
  };
  b.DisplayObject__tick = b._tick;
  b._tick = function (a) {
    var b = this._animation ? this._animation.frequency : 1;
    !this.paused && 0 == (++this._advanceCount + this.offset) % b && this.advance();
    this.DisplayObject__tick(a);
  };
  b._normalizeFrame = function () {
    var a = this._animation, b = this.currentFrame, c = this.paused, d;
    if (a)
      if (d = a.frames.length, this.currentAnimationFrame >= d) {
        var e = a.next;
        this._dispatchAnimationEnd(a, b, c, e, d - 1) || (e ? this._goto(e) : (this.paused = !0, this.currentAnimationFrame = a.frames.length - 1, this.currentFrame = a.frames[this.currentAnimationFrame]));
      } else
        this.currentFrame = a.frames[this.currentAnimationFrame];
    else
      d = this.spriteSheet.getNumFrames(), b >= d && !this._dispatchAnimationEnd(a, b, c, d - 1) && (this.currentFrame = 0);
  };
  b._dispatchAnimationEnd = function (a, b, c, d, e) {
    var f = a ? a.name : null;
    this.onAnimationEnd && this.onAnimationEnd(this, f, d);
    this.dispatchEvent({
      type: 'animationend',
      name: f,
      next: d
    });
    !c && this.paused && (this.currentAnimationFrame = e);
    return this.paused != c || this._animation != a || this.currentFrame != b;
  };
  b.DisplayObject_cloneProps = b.cloneProps;
  b.cloneProps = function (a) {
    this.DisplayObject_cloneProps(a);
    a.onAnimationEnd = this.onAnimationEnd;
    a.currentFrame = this.currentFrame;
    a.currentAnimation = this.currentAnimation;
    a.paused = this.paused;
    a.offset = this.offset;
    a._animation = this._animation;
    a.currentAnimationFrame = this.currentAnimationFrame;
  };
  b._goto = function (a) {
    if (isNaN(a)) {
      var b = this.spriteSheet.getAnimation(a);
      b && (this.currentAnimationFrame = 0, this._animation = b, this.currentAnimation = a, this._normalizeFrame());
    } else
      this.currentAnimation = this._animation = null, this.currentFrame = a;
  };
  createjs.BitmapAnimation = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function (a) {
      this.initialize(a);
    }, b = c.prototype = new createjs.DisplayObject();
  b.graphics = null;
  b.DisplayObject_initialize = b.initialize;
  b.initialize = function (a) {
    this.DisplayObject_initialize();
    this.graphics = a ? a : new createjs.Graphics();
  };
  b.isVisible = function () {
    var a = this.cacheCanvas || this.graphics && !this.graphics.isEmpty();
    return !(!this.visible || !(0 < this.alpha && 0 != this.scaleX && 0 != this.scaleY && a));
  };
  b.DisplayObject_draw = b.draw;
  b.draw = function (a, b) {
    if (this.DisplayObject_draw(a, b))
      return !0;
    this.graphics.draw(a);
    return !0;
  };
  b.clone = function (a) {
    a = new c(a && this.graphics ? this.graphics.clone() : this.graphics);
    this.cloneProps(a);
    return a;
  };
  b.toString = function () {
    return '[Shape (name=' + this.name + ')]';
  };
  createjs.Shape = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function (a, b, c) {
      this.initialize(a, b, c);
    }, b = c.prototype = new createjs.DisplayObject();
  c._workingContext = (createjs.createCanvas ? createjs.createCanvas() : document.createElement('canvas')).getContext('2d');
  b.text = '';
  b.font = null;
  b.color = '#000';
  b.textAlign = 'left';
  b.textBaseline = 'top';
  b.maxWidth = null;
  b.outline = !1;
  b.lineHeight = 0;
  b.lineWidth = null;
  b.DisplayObject_initialize = b.initialize;
  b.initialize = function (a, b, c) {
    this.DisplayObject_initialize();
    this.text = a;
    this.font = b;
    this.color = c ? c : '#000';
  };
  b.isVisible = function () {
    var a = this.cacheCanvas || null != this.text && '' !== this.text;
    return !(!this.visible || !(0 < this.alpha && 0 != this.scaleX && 0 != this.scaleY && a));
  };
  b.DisplayObject_draw = b.draw;
  b.draw = function (a, b) {
    if (this.DisplayObject_draw(a, b))
      return !0;
    this.outline ? a.strokeStyle = this.color : a.fillStyle = this.color;
    a.font = this.font;
    a.textAlign = this.textAlign || 'start';
    a.textBaseline = this.textBaseline || 'alphabetic';
    this._drawText(a);
    return !0;
  };
  b.getMeasuredWidth = function () {
    return this._getWorkingContext().measureText(this.text).width;
  };
  b.getMeasuredLineHeight = function () {
    return 1.2 * this._getWorkingContext().measureText('M').width;
  };
  b.getMeasuredHeight = function () {
    return this._drawText() * (this.lineHeight || this.getMeasuredLineHeight());
  };
  b.clone = function () {
    var a = new c(this.text, this.font, this.color);
    this.cloneProps(a);
    return a;
  };
  b.toString = function () {
    return '[Text (text=' + (20 < this.text.length ? this.text.substr(0, 17) + '...' : this.text) + ')]';
  };
  b.DisplayObject_cloneProps = b.cloneProps;
  b.cloneProps = function (a) {
    this.DisplayObject_cloneProps(a);
    a.textAlign = this.textAlign;
    a.textBaseline = this.textBaseline;
    a.maxWidth = this.maxWidth;
    a.outline = this.outline;
    a.lineHeight = this.lineHeight;
    a.lineWidth = this.lineWidth;
  };
  b._getWorkingContext = function () {
    var a = c._workingContext;
    a.font = this.font;
    a.textAlign = this.textAlign || 'start';
    a.textBaseline = this.textBaseline || 'alphabetic';
    return a;
  };
  b._drawText = function (a) {
    var b = !!a;
    b || (a = this._getWorkingContext());
    for (var c = String(this.text).split(/(?:\r\n|\r|\n)/), d = this.lineHeight || this.getMeasuredLineHeight(), e = 0, f = 0, h = c.length; f < h; f++) {
      var k = a.measureText(c[f]).width;
      if (null == this.lineWidth || k < this.lineWidth)
        b && this._drawTextLine(a, c[f], e * d);
      else {
        for (var k = c[f].split(/(\s)/), j = k[0], l = 1, n = k.length; l < n; l += 2)
          a.measureText(j + k[l] + k[l + 1]).width > this.lineWidth ? (b && this._drawTextLine(a, j, e * d), e++, j = k[l + 1]) : j += k[l] + k[l + 1];
        b && this._drawTextLine(a, j, e * d);
      }
      e++;
    }
    return e;
  };
  b._drawTextLine = function (a, b, c) {
    this.outline ? a.strokeText(b, 0, c, this.maxWidth || 65535) : a.fillText(b, 0, c, this.maxWidth || 65535);
  };
  createjs.Text = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function () {
    throw 'SpriteSheetUtils cannot be instantiated';
  };
  c._workingCanvas = createjs.createCanvas ? createjs.createCanvas() : document.createElement('canvas');
  c._workingContext = c._workingCanvas.getContext('2d');
  c.addFlippedFrames = function (b, a, m, g) {
    if (a || m || g) {
      var d = 0;
      a && c._flip(b, ++d, !0, !1);
      m && c._flip(b, ++d, !1, !0);
      g && c._flip(b, ++d, !0, !0);
    }
  };
  c.extractFrame = function (b, a) {
    isNaN(a) && (a = b.getAnimation(a).frames[0]);
    var m = b.getFrame(a);
    if (!m)
      return null;
    var g = m.rect, d = c._workingCanvas;
    d.width = g.width;
    d.height = g.height;
    c._workingContext.drawImage(m.image, g.x, g.y, g.width, g.height, 0, 0, g.width, g.height);
    m = new Image();
    m.src = d.toDataURL('image/png');
    return m;
  };
  c.mergeAlpha = function (b, a, c) {
    c || (c = createjs.createCanvas ? createjs.createCanvas() : document.createElement('canvas'));
    c.width = Math.max(a.width, b.width);
    c.height = Math.max(a.height, b.height);
    var g = c.getContext('2d');
    g.save();
    g.drawImage(b, 0, 0);
    g.globalCompositeOperation = 'destination-in';
    g.drawImage(a, 0, 0);
    g.restore();
    return c;
  };
  c._flip = function (b, a, m, g) {
    for (var d = b._images, e = c._workingCanvas, f = c._workingContext, h = d.length / a, k = 0; k < h; k++) {
      var j = d[k];
      j.__tmp = k;
      f.setTransform(1, 0, 0, 1, 0, 0);
      f.clearRect(0, 0, e.width + 1, e.height + 1);
      e.width = j.width;
      e.height = j.height;
      f.setTransform(m ? -1 : 1, 0, 0, g ? -1 : 1, m ? j.width : 0, g ? j.height : 0);
      f.drawImage(j, 0, 0);
      var l = new Image();
      l.src = e.toDataURL('image/png');
      l.width = j.width;
      l.height = j.height;
      d.push(l);
    }
    f = b._frames;
    e = f.length / a;
    for (k = 0; k < e; k++) {
      var j = f[k], n = j.rect.clone(), l = d[j.image.__tmp + h * a], q = {
          image: l,
          rect: n,
          regX: j.regX,
          regY: j.regY
        };
      m && (n.x = l.width - n.x - n.width, q.regX = n.width - j.regX);
      g && (n.y = l.height - n.y - n.height, q.regY = n.height - j.regY);
      f.push(q);
    }
    m = '_' + (m ? 'h' : '') + (g ? 'v' : '');
    g = b._animations;
    b = b._data;
    d = g.length / a;
    for (k = 0; k < d; k++) {
      f = g[k];
      j = b[f];
      h = {
        name: f + m,
        frequency: j.frequency,
        next: j.next,
        frames: []
      };
      j.next && (h.next += m);
      f = j.frames;
      j = 0;
      for (l = f.length; j < l; j++)
        h.frames.push(f[j] + e * a);
      b[h.name] = h;
      g.push(h.name);
    }
  };
  createjs.SpriteSheetUtils = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function () {
      this.initialize();
    }, b = c.prototype;
  c.ERR_DIMENSIONS = 'frame dimensions exceed max spritesheet dimensions';
  c.ERR_RUNNING = 'a build is already running';
  b.maxWidth = 2048;
  b.maxHeight = 2048;
  b.spriteSheet = null;
  b.scale = 1;
  b.padding = 1;
  b.timeSlice = 0.3;
  b.progress = -1;
  b.onComplete = null;
  b.onProgress = null;
  b.addEventListener = null;
  b.removeEventListener = null;
  b.removeAllEventListeners = null;
  b.dispatchEvent = null;
  b.hasEventListener = null;
  b._listeners = null;
  createjs.EventDispatcher.initialize(b);
  b._frames = null;
  b._animations = null;
  b._data = null;
  b._nextFrameIndex = 0;
  b._index = 0;
  b._timerID = null;
  b._scale = 1;
  b.initialize = function () {
    this._frames = [];
    this._animations = {};
  };
  b.addFrame = function (a, b, g, d, e, f) {
    if (this._data)
      throw c.ERR_RUNNING;
    b = b || a.bounds || a.nominalBounds;
    !b && a.getBounds && (b = a.getBounds());
    if (!b)
      return null;
    g = g || 1;
    return this._frames.push({
      source: a,
      sourceRect: b,
      scale: g,
      funct: d,
      params: e,
      scope: f,
      index: this._frames.length,
      height: b.height * g
    }) - 1;
  };
  b.addAnimation = function (a, b, g, d) {
    if (this._data)
      throw c.ERR_RUNNING;
    this._animations[a] = {
      frames: b,
      next: g,
      frequency: d
    };
  };
  b.addMovieClip = function (a, b, g) {
    if (this._data)
      throw c.ERR_RUNNING;
    var d = a.frameBounds, e = b || a.bounds || a.nominalBounds;
    !e && a.getBounds && (e = a.getBounds());
    if (!e && !d)
      return null;
    b = this._frames.length;
    for (var f = a.timeline.duration, h = 0; h < f; h++)
      this.addFrame(a, d && d[h] ? d[h] : e, g, function (a) {
        var b = this.actionsEnabled;
        this.actionsEnabled = !1;
        this.gotoAndStop(a);
        this.actionsEnabled = b;
      }, [h], a);
    h = a.timeline._labels;
    a = [];
    for (var k in h)
      a.push({
        index: h[k],
        label: k
      });
    if (a.length) {
      a.sort(function (a, b) {
        return a.index - b.index;
      });
      h = 0;
      for (k = a.length; h < k; h++) {
        g = a[h].label;
        for (var d = b + (h == k - 1 ? f : a[h + 1].index), e = [], j = b + a[h].index; j < d; j++)
          e.push(j);
        this.addAnimation(g, e, !0);
      }
    }
  };
  b.build = function () {
    if (this._data)
      throw c.ERR_RUNNING;
    for (this._startBuild(); this._drawNext(););
    this._endBuild();
    return this.spriteSheet;
  };
  b.buildAsync = function (a) {
    if (this._data)
      throw c.ERR_RUNNING;
    this.timeSlice = a;
    this._startBuild();
    var b = this;
    this._timerID = setTimeout(function () {
      b._run();
    }, 50 - 50 * Math.max(0.01, Math.min(0.99, this.timeSlice || 0.3)));
  };
  b.stopAsync = function () {
    clearTimeout(this._timerID);
    this._data = null;
  };
  b.clone = function () {
    throw 'SpriteSheetBuilder cannot be cloned.';
  };
  b.toString = function () {
    return '[SpriteSheetBuilder]';
  };
  b._startBuild = function () {
    var a = this.padding || 0;
    this.progress = 0;
    this.spriteSheet = null;
    this._index = 0;
    this._scale = this.scale;
    var b = [];
    this._data = {
      images: [],
      frames: b,
      animations: this._animations
    };
    var g = this._frames.slice();
    g.sort(function (a, b) {
      return a.height <= b.height ? -1 : 1;
    });
    if (g[g.length - 1].height + 2 * a > this.maxHeight)
      throw c.ERR_DIMENSIONS;
    for (var d = 0, e = 0, f = 0; g.length;) {
      var h = this._fillRow(g, d, f, b, a);
      h.w > e && (e = h.w);
      d += h.h;
      if (!h.h || !g.length) {
        var k = createjs.createCanvas ? createjs.createCanvas() : document.createElement('canvas');
        k.width = this._getSize(e, this.maxWidth);
        k.height = this._getSize(d, this.maxHeight);
        this._data.images[f] = k;
        h.h || (e = d = 0, f++);
      }
    }
  };
  b._getSize = function (a, b) {
    for (var c = 4; Math.pow(2, ++c) < a;);
    return Math.min(b, Math.pow(2, c));
  };
  b._fillRow = function (a, b, g, d, e) {
    var f = this.maxWidth, h = this.maxHeight;
    b += e;
    for (var h = h - b, k = e, j = 0, l = a.length - 1; 0 <= l; l--) {
      var n = a[l], q = this._scale * n.scale, p = n.sourceRect, s = n.source, r = Math.floor(q * p.x - e), u = Math.floor(q * p.y - e), t = Math.ceil(q * p.height + 2 * e), p = Math.ceil(q * p.width + 2 * e);
      if (p > f)
        throw c.ERR_DIMENSIONS;
      t > h || k + p > f || (n.img = g, n.rect = new createjs.Rectangle(k, b, p, t), j = j || t, a.splice(l, 1), d[n.index] = [
        k,
        b,
        p,
        t,
        g,
        Math.round(-r + q * s.regX - e),
        Math.round(-u + q * s.regY - e)
      ], k += p);
    }
    return {
      w: k,
      h: j
    };
  };
  b._endBuild = function () {
    this.spriteSheet = new createjs.SpriteSheet(this._data);
    this._data = null;
    this.progress = 1;
    this.onComplete && this.onComplete(this);
    this.dispatchEvent('complete');
  };
  b._run = function () {
    for (var a = 50 * Math.max(0.01, Math.min(0.99, this.timeSlice || 0.3)), b = new Date().getTime() + a, c = !1; b > new Date().getTime();)
      if (!this._drawNext()) {
        c = !0;
        break;
      }
    if (c)
      this._endBuild();
    else {
      var d = this;
      this._timerID = setTimeout(function () {
        d._run();
      }, 50 - a);
    }
    a = this.progress = this._index / this._frames.length;
    this.onProgress && this.onProgress(this, a);
    this.dispatchEvent({
      type: 'progress',
      progress: a
    });
  };
  b._drawNext = function () {
    var a = this._frames[this._index], b = a.scale * this._scale, c = a.rect, d = a.sourceRect, e = this._data.images[a.img].getContext('2d');
    a.funct && a.funct.apply(a.scope, a.params);
    e.save();
    e.beginPath();
    e.rect(c.x, c.y, c.width, c.height);
    e.clip();
    e.translate(Math.ceil(c.x - d.x * b), Math.ceil(c.y - d.y * b));
    e.scale(b, b);
    a.source.draw(e);
    e.restore();
    return ++this._index < this._frames.length;
  };
  createjs.SpriteSheetBuilder = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function (a) {
      this.initialize(a);
    }, b = c.prototype = new createjs.DisplayObject();
  b.htmlElement = null;
  b._oldMtx = null;
  b.DisplayObject_initialize = b.initialize;
  b.initialize = function (a) {
    'string' == typeof a && (a = document.getElementById(a));
    this.DisplayObject_initialize();
    this.mouseEnabled = !1;
    this.htmlElement = a;
    a = a.style;
    a.position = 'absolute';
    a.transformOrigin = a.WebkitTransformOrigin = a.msTransformOrigin = a.MozTransformOrigin = a.OTransformOrigin = '0% 0%';
  };
  b.isVisible = function () {
    return null != this.htmlElement;
  };
  b.draw = function () {
    if (null != this.htmlElement) {
      var a = this.getConcatenatedMatrix(this._matrix), b = this.htmlElement.style;
      if (this.visible)
        b.visibility = 'visible';
      else
        return !0;
      var c = this._oldMtx || {};
      c.alpha != a.alpha && (b.opacity = '' + a.alpha, c.alpha = a.alpha);
      if (c.tx != a.tx || c.ty != a.ty || c.a != a.a || c.b != a.b || c.c != a.c || c.d != a.d)
        b.transform = b.WebkitTransform = b.OTransform = b.msTransform = [
          'matrix(' + a.a,
          a.b,
          a.c,
          a.d,
          a.tx + 0.5 | 0,
          (a.ty + 0.5 | 0) + ')'
        ].join(), b.MozTransform = [
          'matrix(' + a.a,
          a.b,
          a.c,
          a.d,
          (a.tx + 0.5 | 0) + 'px',
          (a.ty + 0.5 | 0) + 'px)'
        ].join(), this._oldMtx = a.clone();
      return !0;
    }
  };
  b.cache = function () {
  };
  b.uncache = function () {
  };
  b.updateCache = function () {
  };
  b.hitTest = function () {
  };
  b.localToGlobal = function () {
  };
  b.globalToLocal = function () {
  };
  b.localToLocal = function () {
  };
  b.clone = function () {
    throw 'DOMElement cannot be cloned.';
  };
  b.toString = function () {
    return '[DOMElement (name=' + this.name + ')]';
  };
  b.DisplayObject__tick = b._tick;
  b._tick = function (a) {
    this.htmlElement.style.visibility = 'hidden';
    this.DisplayObject__tick(a);
  };
  createjs.DOMElement = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function () {
      this.initialize();
    }, b = c.prototype;
  b.initialize = function () {
  };
  b.getBounds = function () {
    return new createjs.Rectangle(0, 0, 0, 0);
  };
  b.applyFilter = function () {
  };
  b.toString = function () {
    return '[Filter]';
  };
  b.clone = function () {
    return new c();
  };
  createjs.Filter = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function () {
    throw 'Touch cannot be instantiated';
  };
  c.isSupported = function () {
    return 'ontouchstart' in window || window.navigator.msPointerEnabled;
  };
  c.enable = function (b, a, m) {
    if (!b || !b.canvas || !c.isSupported())
      return !1;
    b.__touch = {
      pointers: {},
      multitouch: !a,
      preventDefault: !m,
      count: 0
    };
    'ontouchstart' in window ? c._IOS_enable(b) : window.navigator.msPointerEnabled && c._IE_enable(b);
    return !0;
  };
  c.disable = function (b) {
    b && ('ontouchstart' in window ? c._IOS_disable(b) : window.navigator.msPointerEnabled && c._IE_disable(b));
  };
  c._IOS_enable = function (b) {
    var a = b.canvas, m = b.__touch.f = function (a) {
        c._IOS_handleEvent(b, a);
      };
    a.addEventListener('touchstart', m, !1);
    a.addEventListener('touchmove', m, !1);
    a.addEventListener('touchend', m, !1);
    a.addEventListener('touchcancel', m, !1);
  };
  c._IOS_disable = function (b) {
    var a = b.canvas;
    a && (b = b.__touch.f, a.removeEventListener('touchstart', b, !1), a.removeEventListener('touchmove', b, !1), a.removeEventListener('touchend', b, !1), a.removeEventListener('touchcancel', b, !1));
  };
  c._IOS_handleEvent = function (b, a) {
    if (b) {
      b.__touch.preventDefault && a.preventDefault && a.preventDefault();
      for (var c = a.changedTouches, g = a.type, d = 0, e = c.length; d < e; d++) {
        var f = c[d], h = f.identifier;
        f.target == b.canvas && ('touchstart' == g ? this._handleStart(b, h, a, f.pageX, f.pageY) : 'touchmove' == g ? this._handleMove(b, h, a, f.pageX, f.pageY) : ('touchend' == g || 'touchcancel' == g) && this._handleEnd(b, h, a));
      }
    }
  };
  c._IE_enable = function (b) {
    var a = b.canvas, m = b.__touch.f = function (a) {
        c._IE_handleEvent(b, a);
      };
    a.addEventListener('MSPointerDown', m, !1);
    window.addEventListener('MSPointerMove', m, !1);
    window.addEventListener('MSPointerUp', m, !1);
    window.addEventListener('MSPointerCancel', m, !1);
    b.__touch.preventDefault && (a.style.msTouchAction = 'none');
    b.__touch.activeIDs = {};
  };
  c._IE_disable = function (b) {
    var a = b.__touch.f;
    window.removeEventListener('MSPointerMove', a, !1);
    window.removeEventListener('MSPointerUp', a, !1);
    window.removeEventListener('MSPointerCancel', a, !1);
    b.canvas && b.canvas.removeEventListener('MSPointerDown', a, !1);
  };
  c._IE_handleEvent = function (b, a) {
    if (b) {
      b.__touch.preventDefault && a.preventDefault && a.preventDefault();
      var c = a.type, g = a.pointerId, d = b.__touch.activeIDs;
      if ('MSPointerDown' == c)
        a.srcElement == b.canvas && (d[g] = !0, this._handleStart(b, g, a, a.pageX, a.pageY));
      else if (d[g])
        if ('MSPointerMove' == c)
          this._handleMove(b, g, a, a.pageX, a.pageY);
        else if ('MSPointerUp' == c || 'MSPointerCancel' == c)
          delete d[g], this._handleEnd(b, g, a);
    }
  };
  c._handleStart = function (b, a, c, g, d) {
    var e = b.__touch;
    if (e.multitouch || !e.count) {
      var f = e.pointers;
      f[a] || (f[a] = !0, e.count++, b._handlePointerDown(a, c, g, d));
    }
  };
  c._handleMove = function (b, a, c, g, d) {
    b.__touch.pointers[a] && b._handlePointerMove(a, c, g, d);
  };
  c._handleEnd = function (b, a, c) {
    var g = b.__touch, d = g.pointers;
    d[a] && (g.count--, b._handlePointerUp(a, c, !0), delete d[a]);
  };
  createjs.Touch = c;
}());
(function () {
  var c = this.createjs = this.createjs || {}, c = c.EaselJS = c.EaselJS || {};
  c.version = '0.6.1';
  c.buildDate = 'Tue, 14 May 2013 21:43:02 GMT';
}());
this.createjs = this.createjs || {};
(function () {
  var b = function () {
      this.initialize();
    }, a = b.prototype;
  b.initialize = function (d) {
    d.addEventListener = a.addEventListener;
    d.removeEventListener = a.removeEventListener;
    d.removeAllEventListeners = a.removeAllEventListeners;
    d.hasEventListener = a.hasEventListener;
    d.dispatchEvent = a.dispatchEvent;
  };
  a._listeners = null;
  a.initialize = function () {
  };
  a.addEventListener = function (d, a) {
    var c = this._listeners;
    c ? this.removeEventListener(d, a) : c = this._listeners = {};
    var b = c[d];
    b || (b = c[d] = []);
    b.push(a);
    return a;
  };
  a.removeEventListener = function (d, a) {
    var c = this._listeners;
    if (c) {
      var b = c[d];
      if (b)
        for (var f = 0, g = b.length; f < g; f++)
          if (b[f] == a) {
            1 == g ? delete c[d] : b.splice(f, 1);
            break;
          }
    }
  };
  a.removeAllEventListeners = function (d) {
    d ? this._listeners && delete this._listeners[d] : this._listeners = null;
  };
  a.dispatchEvent = function (d, a) {
    var c = !1, b = this._listeners;
    if (d && b) {
      'string' == typeof d && (d = { type: d });
      b = b[d.type];
      if (!b)
        return c;
      d.target = a || this;
      for (var b = b.slice(), f = 0, g = b.length; f < g; f++)
        var j = b[f], c = j.handleEvent ? c || j.handleEvent(d) : c || j(d);
    }
    return !!c;
  };
  a.hasEventListener = function (d) {
    var a = this._listeners;
    return !(!a || !a[d]);
  };
  a.toString = function () {
    return '[EventDispatcher]';
  };
  createjs.EventDispatcher = b;
}());
this.createjs = this.createjs || {};
(function () {
  var b = function (d, a, c) {
      this.initialize(d, a, c);
    }, a = b.prototype;
  b.NONE = 0;
  b.LOOP = 1;
  b.REVERSE = 2;
  b.IGNORE = {};
  b._tweens = [];
  b._plugins = {};
  b.get = function (d, a, c, e) {
    e && b.removeTweens(d);
    return new b(d, a, c);
  };
  b.tick = function (d, a) {
    for (var c = b._tweens.slice(), e = c.length - 1; 0 <= e; e--) {
      var f = c[e];
      a && !f.ignoreGlobalPause || f._paused || f.tick(f._useTicks ? 1 : d);
    }
  };
  createjs.Ticker && createjs.Ticker.addListener(b, !1);
  b.removeTweens = function (d) {
    if (d.tweenjs_count) {
      for (var a = b._tweens, c = a.length - 1; 0 <= c; c--)
        a[c]._target == d && (a[c]._paused = !0, a.splice(c, 1));
      d.tweenjs_count = 0;
    }
  };
  b.removeAllTweens = function () {
    for (var d = b._tweens, a = 0, c = d.length; a < c; a++) {
      var e = d[a];
      e.paused = !0;
      e.target.tweenjs_count = 0;
    }
    d.length = 0;
  };
  b.hasActiveTweens = function (d) {
    return d ? d.tweenjs_count : b._tweens && b._tweens.length;
  };
  b.installPlugin = function (d, a) {
    var c = d.priority;
    null == c && (d.priority = c = 0);
    for (var e = 0, f = a.length, g = b._plugins; e < f; e++) {
      var j = a[e];
      if (g[j]) {
        for (var l = g[j], k = 0, p = l.length; k < p && !(c < l[k].priority); k++);
        g[j].splice(k, 0, d);
      } else
        g[j] = [d];
    }
  };
  b._register = function (d, a) {
    var c = d._target;
    a ? (c && (c.tweenjs_count = c.tweenjs_count ? c.tweenjs_count + 1 : 1), b._tweens.push(d)) : (c && c.tweenjs_count--, c = b._tweens.indexOf(d), -1 != c && b._tweens.splice(c, 1));
  };
  a.addEventListener = null;
  a.removeEventListener = null;
  a.removeAllEventListeners = null;
  a.dispatchEvent = null;
  a.hasEventListener = null;
  a._listeners = null;
  createjs.EventDispatcher.initialize(a);
  a.ignoreGlobalPause = !1;
  a.loop = !1;
  a.duration = 0;
  a.pluginData = null;
  a.onChange = null;
  a.change = null;
  a.target = null;
  a.position = null;
  a._paused = !1;
  a._curQueueProps = null;
  a._initQueueProps = null;
  a._steps = null;
  a._actions = null;
  a._prevPosition = 0;
  a._stepPosition = 0;
  a._prevPos = -1;
  a._target = null;
  a._useTicks = !1;
  a.initialize = function (d, a, c) {
    this.target = this._target = d;
    a && (this._useTicks = a.useTicks, this.ignoreGlobalPause = a.ignoreGlobalPause, this.loop = a.loop, this.onChange = a.onChange, a.override && b.removeTweens(d));
    this.pluginData = c || {};
    this._curQueueProps = {};
    this._initQueueProps = {};
    this._steps = [];
    this._actions = [];
    a && a.paused ? this._paused = !0 : b._register(this, !0);
    a && null != a.position && this.setPosition(a.position, b.NONE);
  };
  a.wait = function (a) {
    if (null == a || 0 >= a)
      return this;
    var b = this._cloneProps(this._curQueueProps);
    return this._addStep({
      d: a,
      p0: b,
      e: this._linearEase,
      p1: b
    });
  };
  a.to = function (a, b, c) {
    if (isNaN(b) || 0 > b)
      b = 0;
    return this._addStep({
      d: b || 0,
      p0: this._cloneProps(this._curQueueProps),
      e: c,
      p1: this._cloneProps(this._appendQueueProps(a))
    });
  };
  a.call = function (a, b, c) {
    return this._addAction({
      f: a,
      p: b ? b : [this],
      o: c ? c : this._target
    });
  };
  a.set = function (a, b) {
    return this._addAction({
      f: this._set,
      o: this,
      p: [
        a,
        b ? b : this._target
      ]
    });
  };
  a.play = function (a) {
    return this.call(a.setPaused, [!1], a);
  };
  a.pause = function (a) {
    a || (a = this);
    return this.call(a.setPaused, [!0], a);
  };
  a.setPosition = function (a, b) {
    0 > a && (a = 0);
    null == b && (b = 1);
    var c = a, e = !1;
    c >= this.duration && (this.loop ? c %= this.duration : (c = this.duration, e = !0));
    if (c == this._prevPos)
      return e;
    var f = this._prevPos;
    this.position = this._prevPos = c;
    this._prevPosition = a;
    if (this._target)
      if (e)
        this._updateTargetProps(null, 1);
      else if (0 < this._steps.length) {
        for (var g = 0, j = this._steps.length; g < j && !(this._steps[g].t > c); g++);
        g = this._steps[g - 1];
        this._updateTargetProps(g, (this._stepPosition = c - g.t) / g.d);
      }
    0 != b && 0 < this._actions.length && (this._useTicks ? this._runActions(c, c) : 1 == b && c < f ? (f != this.duration && this._runActions(f, this.duration), this._runActions(0, c, !0)) : this._runActions(f, c));
    e && this.setPaused(!0);
    this.onChange && this.onChange(this);
    this.dispatchEvent('change');
    return e;
  };
  a.tick = function (a) {
    this._paused || this.setPosition(this._prevPosition + a);
  };
  a.setPaused = function (a) {
    this._paused = !!a;
    b._register(this, !a);
    return this;
  };
  a.w = a.wait;
  a.t = a.to;
  a.c = a.call;
  a.s = a.set;
  a.toString = function () {
    return '[Tween]';
  };
  a.clone = function () {
    throw 'Tween can not be cloned.';
  };
  a._updateTargetProps = function (a, h) {
    var c, e, f, g;
    !a && 1 == h ? c = e = this._curQueueProps : (a.e && (h = a.e(h, 0, 1, 1)), c = a.p0, e = a.p1);
    for (n in this._initQueueProps) {
      if (null == (f = c[n]))
        c[n] = f = this._initQueueProps[n];
      if (null == (g = e[n]))
        e[n] = g = f;
      f = f == g || 0 == h || 1 == h || 'number' != typeof f ? 1 == h ? g : f : f + (g - f) * h;
      var j = !1;
      if (g = b._plugins[n])
        for (var l = 0, k = g.length; l < k; l++) {
          var p = g[l].tween(this, n, f, c, e, h, !!a && c == e, !a);
          p == b.IGNORE ? j = !0 : f = p;
        }
      j || (this._target[n] = f);
    }
  };
  a._runActions = function (a, b, c) {
    var e = a, f = b, g = -1, j = this._actions.length, l = 1;
    a > b && (e = b, f = a, g = j, j = l = -1);
    for (; (g += l) != j;) {
      b = this._actions[g];
      var k = b.t;
      (k == f || k > e && k < f || c && k == a) && b.f.apply(b.o, b.p);
    }
  };
  a._appendQueueProps = function (a) {
    var h, c, e, f, g, j;
    for (j in a) {
      if (void 0 === this._initQueueProps[j]) {
        c = this._target[j];
        if (h = b._plugins[j]) {
          e = 0;
          for (f = h.length; e < f; e++)
            c = h[e].init(this, j, c);
        }
        this._initQueueProps[j] = void 0 === c ? null : c;
      } else
        c = this._curQueueProps[j];
      if (h = b._plugins[j]) {
        g = g || {};
        e = 0;
        for (f = h.length; e < f; e++)
          h[e].step && h[e].step(this, j, c, a[j], g);
      }
      this._curQueueProps[j] = a[j];
    }
    g && this._appendQueueProps(g);
    return this._curQueueProps;
  };
  a._cloneProps = function (a) {
    var b = {}, c;
    for (c in a)
      b[c] = a[c];
    return b;
  };
  a._addStep = function (a) {
    0 < a.d && (this._steps.push(a), a.t = this.duration, this.duration += a.d);
    return this;
  };
  a._addAction = function (a) {
    a.t = this.duration;
    this._actions.push(a);
    return this;
  };
  a._set = function (a, b) {
    for (var c in a)
      b[c] = a[c];
  };
  createjs.Tween = b;
}());
this.createjs = this.createjs || {};
(function () {
  var b = function (a, b, c) {
      this.initialize(a, b, c);
    }, a = b.prototype;
  a.ignoreGlobalPause = !1;
  a.duration = 0;
  a.loop = !1;
  a.onChange = null;
  a.position = null;
  a._paused = !1;
  a._tweens = null;
  a._labels = null;
  a._prevPosition = 0;
  a._prevPos = -1;
  a._useTicks = !1;
  a.initialize = function (a, b, c) {
    this._tweens = [];
    c && (this._useTicks = c.useTicks, this.loop = c.loop, this.ignoreGlobalPause = c.ignoreGlobalPause, this.onChange = c.onChange);
    a && this.addTween.apply(this, a);
    this.setLabels(b);
    c && c.paused ? this._paused = !0 : createjs.Tween._register(this, !0);
    c && null != c.position && this.setPosition(c.position, createjs.Tween.NONE);
  };
  a.addTween = function (a) {
    var b = arguments.length;
    if (1 < b) {
      for (var c = 0; c < b; c++)
        this.addTween(arguments[c]);
      return arguments[0];
    }
    if (0 == b)
      return null;
    this.removeTween(a);
    this._tweens.push(a);
    a.setPaused(!0);
    a._paused = !1;
    a._useTicks = this._useTicks;
    a.duration > this.duration && (this.duration = a.duration);
    0 <= this._prevPos && a.setPosition(this._prevPos, createjs.Tween.NONE);
    return a;
  };
  a.removeTween = function (a) {
    var b = arguments.length;
    if (1 < b) {
      for (var c = !0, e = 0; e < b; e++)
        c = c && this.removeTween(arguments[e]);
      return c;
    }
    if (0 == b)
      return !1;
    b = this._tweens.indexOf(a);
    return -1 != b ? (this._tweens.splice(b, 1), a.duration >= this.duration && this.updateDuration(), !0) : !1;
  };
  a.addLabel = function (a, b) {
    this._labels[a] = b;
  };
  a.setLabels = function (a) {
    this._labels = a ? a : {};
  };
  a.gotoAndPlay = function (a) {
    this.setPaused(!1);
    this._goto(a);
  };
  a.gotoAndStop = function (a) {
    this.setPaused(!0);
    this._goto(a);
  };
  a.setPosition = function (a, b) {
    0 > a && (a = 0);
    var c = this.loop ? a % this.duration : a, e = !this.loop && a >= this.duration;
    if (c == this._prevPos)
      return e;
    this._prevPosition = a;
    this.position = this._prevPos = c;
    for (var f = 0, g = this._tweens.length; f < g; f++)
      if (this._tweens[f].setPosition(c, b), c != this._prevPos)
        return !1;
    e && this.setPaused(!0);
    this.onChange && this.onChange(this);
    return e;
  };
  a.setPaused = function (a) {
    this._paused = !!a;
    createjs.Tween._register(this, !a);
  };
  a.updateDuration = function () {
    for (var a = this.duration = 0, b = this._tweens.length; a < b; a++) {
      var c = this._tweens[a];
      c.duration > this.duration && (this.duration = c.duration);
    }
  };
  a.tick = function (a) {
    this.setPosition(this._prevPosition + a);
  };
  a.resolve = function (a) {
    var b = parseFloat(a);
    isNaN(b) && (b = this._labels[a]);
    return b;
  };
  a.toString = function () {
    return '[Timeline]';
  };
  a.clone = function () {
    throw 'Timeline can not be cloned.';
  };
  a._goto = function (a) {
    a = this.resolve(a);
    null != a && this.setPosition(a);
  };
  createjs.Timeline = b;
}());
this.createjs = this.createjs || {};
(function () {
  var b = function () {
    throw 'Ease cannot be instantiated.';
  };
  b.linear = function (a) {
    return a;
  };
  b.none = b.linear;
  b.get = function (a) {
    -1 > a && (a = -1);
    1 < a && (a = 1);
    return function (b) {
      return 0 == a ? b : 0 > a ? b * (b * -a + 1 + a) : b * ((2 - b) * a + (1 - a));
    };
  };
  b.getPowIn = function (a) {
    return function (b) {
      return Math.pow(b, a);
    };
  };
  b.getPowOut = function (a) {
    return function (b) {
      return 1 - Math.pow(1 - b, a);
    };
  };
  b.getPowInOut = function (a) {
    return function (b) {
      return 1 > (b *= 2) ? 0.5 * Math.pow(b, a) : 1 - 0.5 * Math.abs(Math.pow(2 - b, a));
    };
  };
  b.quadIn = b.getPowIn(2);
  b.quadOut = b.getPowOut(2);
  b.quadInOut = b.getPowInOut(2);
  b.cubicIn = b.getPowIn(3);
  b.cubicOut = b.getPowOut(3);
  b.cubicInOut = b.getPowInOut(3);
  b.quartIn = b.getPowIn(4);
  b.quartOut = b.getPowOut(4);
  b.quartInOut = b.getPowInOut(4);
  b.quintIn = b.getPowIn(5);
  b.quintOut = b.getPowOut(5);
  b.quintInOut = b.getPowInOut(5);
  b.sineIn = function (a) {
    return 1 - Math.cos(a * Math.PI / 2);
  };
  b.sineOut = function (a) {
    return Math.sin(a * Math.PI / 2);
  };
  b.sineInOut = function (a) {
    return -0.5 * (Math.cos(Math.PI * a) - 1);
  };
  b.getBackIn = function (a) {
    return function (b) {
      return b * b * ((a + 1) * b - a);
    };
  };
  b.backIn = b.getBackIn(1.7);
  b.getBackOut = function (a) {
    return function (b) {
      return --b * b * ((a + 1) * b + a) + 1;
    };
  };
  b.backOut = b.getBackOut(1.7);
  b.getBackInOut = function (a) {
    a *= 1.525;
    return function (b) {
      return 1 > (b *= 2) ? 0.5 * b * b * ((a + 1) * b - a) : 0.5 * ((b -= 2) * b * ((a + 1) * b + a) + 2);
    };
  };
  b.backInOut = b.getBackInOut(1.7);
  b.circIn = function (a) {
    return -(Math.sqrt(1 - a * a) - 1);
  };
  b.circOut = function (a) {
    return Math.sqrt(1 - --a * a);
  };
  b.circInOut = function (a) {
    return 1 > (a *= 2) ? -0.5 * (Math.sqrt(1 - a * a) - 1) : 0.5 * (Math.sqrt(1 - (a -= 2) * a) + 1);
  };
  b.bounceIn = function (a) {
    return 1 - b.bounceOut(1 - a);
  };
  b.bounceOut = function (a) {
    return a < 1 / 2.75 ? 7.5625 * a * a : a < 2 / 2.75 ? 7.5625 * (a -= 1.5 / 2.75) * a + 0.75 : a < 2.5 / 2.75 ? 7.5625 * (a -= 2.25 / 2.75) * a + 0.9375 : 7.5625 * (a -= 2.625 / 2.75) * a + 0.984375;
  };
  b.bounceInOut = function (a) {
    return 0.5 > a ? 0.5 * b.bounceIn(2 * a) : 0.5 * b.bounceOut(2 * a - 1) + 0.5;
  };
  b.getElasticIn = function (a, b) {
    var h = 2 * Math.PI;
    return function (c) {
      if (0 == c || 1 == c)
        return c;
      var e = b / h * Math.asin(1 / a);
      return -(a * Math.pow(2, 10 * (c -= 1)) * Math.sin((c - e) * h / b));
    };
  };
  b.elasticIn = b.getElasticIn(1, 0.3);
  b.getElasticOut = function (a, b) {
    var h = 2 * Math.PI;
    return function (c) {
      if (0 == c || 1 == c)
        return c;
      var e = b / h * Math.asin(1 / a);
      return a * Math.pow(2, -10 * c) * Math.sin((c - e) * h / b) + 1;
    };
  };
  b.elasticOut = b.getElasticOut(1, 0.3);
  b.getElasticInOut = function (a, b) {
    var h = 2 * Math.PI;
    return function (c) {
      var e = b / h * Math.asin(1 / a);
      return 1 > (c *= 2) ? -0.5 * a * Math.pow(2, 10 * (c -= 1)) * Math.sin((c - e) * h / b) : 0.5 * a * Math.pow(2, -10 * (c -= 1)) * Math.sin((c - e) * h / b) + 1;
    };
  };
  b.elasticInOut = b.getElasticInOut(1, 0.3 * 1.5);
  createjs.Ease = b;
}());
this.createjs = this.createjs || {};
(function () {
  var b = function () {
    throw 'MotionGuidePlugin cannot be instantiated.';
  };
  b.priority = 0;
  b.install = function () {
    createjs.Tween.installPlugin(b, [
      'guide',
      'x',
      'y',
      'rotation'
    ]);
    return createjs.Tween.IGNORE;
  };
  b.init = function (a, b, h) {
    a = a.target;
    a.hasOwnProperty('x') || (a.x = 0);
    a.hasOwnProperty('y') || (a.y = 0);
    a.hasOwnProperty('rotation') || (a.rotation = 0);
    return 'guide' == b ? null : h;
  };
  b.step = function (a, d, h, c, e) {
    if ('guide' != d)
      return c;
    var f;
    c.hasOwnProperty('path') || (c.path = []);
    a = c.path;
    c.hasOwnProperty('end') || (c.end = 1);
    c.hasOwnProperty('start') || (c.start = h && h.hasOwnProperty('end') && h.path === a ? h.end : 0);
    if (c.hasOwnProperty('_segments') && c._length)
      return c;
    h = a.length;
    if (6 <= h && 0 == (h - 2) % 4) {
      c._segments = [];
      c._length = 0;
      for (d = 2; d < h; d += 4) {
        for (var g = a[d - 2], j = a[d - 1], l = a[d + 0], k = a[d + 1], p = a[d + 2], x = a[d + 3], v = g, w = j, s, m, r = 0, t = [], u = 1; 10 >= u; u++) {
          m = u / 10;
          var q = 1 - m;
          s = q * q * g + 2 * q * m * l + m * m * p;
          m = q * q * j + 2 * q * m * k + m * m * x;
          r += t[t.push(Math.sqrt((f = s - v) * f + (f = m - w) * f)) - 1];
          v = s;
          w = m;
        }
        c._segments.push(r);
        c._segments.push(t);
        c._length += r;
      }
    } else
      throw 'invalid \'path\' data, please see documentation for valid paths';
    f = c.orient;
    c.orient = !1;
    b.calc(c, c.end, e);
    c.orient = f;
    return c;
  };
  b.tween = function (a, d, h, c, e, f, g) {
    e = e.guide;
    if (void 0 == e || e === c.guide)
      return h;
    e.lastRatio != f && (b.calc(e, (e.end - e.start) * (g ? e.end : f) + e.start, a.target), e.orient && (a.target.rotation += c.rotation || 0), e.lastRatio = f);
    return !e.orient && 'rotation' == d ? h : a.target[d];
  };
  b.calc = function (a, d, h) {
    void 0 == a._segments && b.validate(a);
    void 0 == h && (h = {
      x: 0,
      y: 0,
      rotation: 0
    });
    var c = a._segments, e = a.path, f = a._length * d, g = c.length - 2;
    for (d = 0; f > c[d] && d < g;)
      f -= c[d], d += 2;
    for (var c = c[d + 1], j = 0, g = c.length - 1; f > c[j] && j < g;)
      f -= c[j], j++;
    f = j / ++g + f / (g * c[j]);
    d = 2 * d + 2;
    g = 1 - f;
    h.x = g * g * e[d - 2] + 2 * g * f * e[d + 0] + f * f * e[d + 2];
    h.y = g * g * e[d - 1] + 2 * g * f * e[d + 1] + f * f * e[d + 3];
    a.orient && (h.rotation = 57.2957795 * Math.atan2((e[d + 1] - e[d - 1]) * g + (e[d + 3] - e[d + 1]) * f, (e[d + 0] - e[d - 2]) * g + (e[d + 2] - e[d + 0]) * f));
    return h;
  };
  createjs.MotionGuidePlugin = b;
}());
(function () {
  var b = this.createjs = this.createjs || {}, b = b.TweenJS = b.TweenJS || {};
  b.version = '0.4.0';
  b.buildDate = 'Tue, 12 Feb 2013 21:08:16 GMT';
}());
this.createjs = this.createjs || {};
(function () {
  var d = function (b, a, c, f) {
      this.initialize(b, a, c, f);
    }, a = d.prototype = new createjs.Container();
  d.INDEPENDENT = 'independent';
  d.SINGLE_FRAME = 'single';
  d.SYNCHED = 'synched';
  a.startPosition = 0;
  a.loop = !0;
  a.currentFrame = 0;
  a.timeline = null;
  a.paused = !1;
  a.actionsEnabled = !0;
  a.autoReset = !0;
  a._synchOffset = 0;
  a._prevPos = -1;
  a._prevPosition = 0;
  a.Container_initialize = a.initialize;
  a.initialize = function (b, a, c, f) {
    this.mode = b || d.INDEPENDENT;
    this.startPosition = a || 0;
    this.loop = c;
    props = {
      paused: !0,
      position: a,
      useTicks: !0
    };
    this.Container_initialize();
    this.timeline = new createjs.Timeline(null, f, props);
    this._managed = {};
  };
  a.isVisible = function () {
    return !(!this.visible || !(0 < this.alpha && 0 != this.scaleX && 0 != this.scaleY));
  };
  a.Container_draw = a.draw;
  a.draw = function (b, a, c) {
    if (this.DisplayObject_draw(b, a))
      return !0;
    this._updateTimeline();
    this.Container_draw(b, a, c);
  };
  a.play = function () {
    this.paused = !1;
  };
  a.stop = function () {
    this.paused = !0;
  };
  a.gotoAndPlay = function (b) {
    this.paused = !1;
    this._goto(b);
  };
  a.gotoAndStop = function (b) {
    this.paused = !0;
    this._goto(b);
  };
  a.clone = function () {
    throw 'MovieClip cannot be cloned.';
  };
  a.toString = function () {
    return '[MovieClip (name=' + this.name + ')]';
  };
  a.Container__tick = a._tick;
  a._tick = function (b) {
    !this.paused && this.mode == d.INDEPENDENT && (this._prevPosition = 0 > this._prevPos ? 0 : this._prevPosition + 1);
    this.Container__tick(b);
  };
  a._goto = function (b) {
    b = this.timeline.resolve(b);
    null != b && (-1 == this._prevPos && (this._prevPos = NaN), this._prevPosition = b, this._updateTimeline());
  };
  a._reset = function () {
    this._prevPos = -1;
    this.currentFrame = 0;
  };
  a._updateTimeline = function () {
    var b = this.timeline, a = b._tweens, c = this.children, f = this.mode != d.INDEPENDENT;
    b.loop = null == this.loop ? !0 : this.loop;
    f ? b.setPosition(this.startPosition + (this.mode == d.SINGLE_FRAME ? 0 : this._synchOffset), createjs.Tween.NONE) : b.setPosition(0 > this._prevPos ? 0 : this._prevPosition, this.actionsEnabled ? null : createjs.Tween.NONE);
    this._prevPosition = b._prevPosition;
    if (this._prevPos != b._prevPos) {
      this.currentFrame = this._prevPos = b._prevPos;
      for (var e in this._managed)
        this._managed[e] = 1;
      for (b = a.length - 1; 0 <= b; b--)
        e = a[b], f = e._target, f != this && (e = e._stepPosition, f instanceof createjs.DisplayObject ? this._addManagedChild(f, e) : this._setState(f.state, e));
      for (b = c.length - 1; 0 <= b; b--)
        a = c[b].id, 1 == this._managed[a] && (this.removeChildAt(b), delete this._managed[a]);
    }
  };
  a._setState = function (b, a) {
    if (b)
      for (var c = 0, f = b.length; c < f; c++) {
        var e = b[c], d = e.t, e = e.p, g;
        for (g in e)
          d[g] = e[g];
        this._addManagedChild(d, a);
      }
  };
  a._addManagedChild = function (b, a) {
    b._off || (this.addChild(b), b instanceof d && (b._synchOffset = a, b.mode == d.INDEPENDENT && (b.autoReset && !this._managed[b.id]) && b._reset()), this._managed[b.id] = 2);
  };
  createjs.MovieClip = d;
  var g = function () {
    throw 'MovieClipPlugin cannot be instantiated.';
  };
  g.priority = 100;
  g.install = function () {
    createjs.Tween.installPlugin(g, ['startPosition']);
  };
  g.init = function (b, a, c) {
    return c;
  };
  g.step = function () {
  };
  g.tween = function (b, a, c, f, e, g) {
    return !(b.target instanceof d) ? c : 1 == g ? e[a] : f[a];
  };
  g.install();
}());
var THREE = THREE || { REVISION: '60' };
self.console = self.console || {
  info: function () {
  },
  log: function () {
  },
  debug: function () {
  },
  warn: function () {
  },
  error: function () {
  }
};
String.prototype.trim = String.prototype.trim || function () {
  return this.replace(/^\s+|\s+$/g, '');
};
THREE.extend = function (obj, source) {
  if (Object.keys) {
    var keys = Object.keys(source);
    for (var i = 0, il = keys.length; i < il; i++) {
      var prop = keys[i];
      Object.defineProperty(obj, prop, Object.getOwnPropertyDescriptor(source, prop));
    }
  } else {
    var safeHasOwnProperty = {}.hasOwnProperty;
    for (var prop in source) {
      if (safeHasOwnProperty.call(source, prop)) {
        obj[prop] = source[prop];
      }
    }
  }
  return obj;
};
(function () {
  var lastTime = 0;
  var vendors = [
      'ms',
      'moz',
      'webkit',
      'o'
    ];
  for (var x = 0; x < vendors.length && !self.requestAnimationFrame; ++x) {
    self.requestAnimationFrame = self[vendors[x] + 'RequestAnimationFrame'];
    self.cancelAnimationFrame = self[vendors[x] + 'CancelAnimationFrame'] || self[vendors[x] + 'CancelRequestAnimationFrame'];
  }
  if (self.requestAnimationFrame === undefined && self['setTimeout'] !== undefined) {
    self.requestAnimationFrame = function (callback) {
      var currTime = Date.now(), timeToCall = Math.max(0, 16 - (currTime - lastTime));
      var id = self.setTimeout(function () {
          callback(currTime + timeToCall);
        }, timeToCall);
      lastTime = currTime + timeToCall;
      return id;
    };
  }
  if (self.cancelAnimationFrame === undefined && self['clearTimeout'] !== undefined) {
    self.cancelAnimationFrame = function (id) {
      self.clearTimeout(id);
    };
  }
}());
THREE.CullFaceNone = 0;
THREE.CullFaceBack = 1;
THREE.CullFaceFront = 2;
THREE.CullFaceFrontBack = 3;
THREE.FrontFaceDirectionCW = 0;
THREE.FrontFaceDirectionCCW = 1;
THREE.BasicShadowMap = 0;
THREE.PCFShadowMap = 1;
THREE.PCFSoftShadowMap = 2;
THREE.FrontSide = 0;
THREE.BackSide = 1;
THREE.DoubleSide = 2;
THREE.NoShading = 0;
THREE.FlatShading = 1;
THREE.SmoothShading = 2;
THREE.NoColors = 0;
THREE.FaceColors = 1;
THREE.VertexColors = 2;
THREE.NoBlending = 0;
THREE.NormalBlending = 1;
THREE.AdditiveBlending = 2;
THREE.SubtractiveBlending = 3;
THREE.MultiplyBlending = 4;
THREE.CustomBlending = 5;
THREE.AddEquation = 100;
THREE.SubtractEquation = 101;
THREE.ReverseSubtractEquation = 102;
THREE.ZeroFactor = 200;
THREE.OneFactor = 201;
THREE.SrcColorFactor = 202;
THREE.OneMinusSrcColorFactor = 203;
THREE.SrcAlphaFactor = 204;
THREE.OneMinusSrcAlphaFactor = 205;
THREE.DstAlphaFactor = 206;
THREE.OneMinusDstAlphaFactor = 207;
THREE.DstColorFactor = 208;
THREE.OneMinusDstColorFactor = 209;
THREE.SrcAlphaSaturateFactor = 210;
THREE.MultiplyOperation = 0;
THREE.MixOperation = 1;
THREE.AddOperation = 2;
THREE.UVMapping = function () {
};
THREE.CubeReflectionMapping = function () {
};
THREE.CubeRefractionMapping = function () {
};
THREE.SphericalReflectionMapping = function () {
};
THREE.SphericalRefractionMapping = function () {
};
THREE.RepeatWrapping = 1000;
THREE.ClampToEdgeWrapping = 1001;
THREE.MirroredRepeatWrapping = 1002;
THREE.NearestFilter = 1003;
THREE.NearestMipMapNearestFilter = 1004;
THREE.NearestMipMapLinearFilter = 1005;
THREE.LinearFilter = 1006;
THREE.LinearMipMapNearestFilter = 1007;
THREE.LinearMipMapLinearFilter = 1008;
THREE.UnsignedByteType = 1009;
THREE.ByteType = 1010;
THREE.ShortType = 1011;
THREE.UnsignedShortType = 1012;
THREE.IntType = 1013;
THREE.UnsignedIntType = 1014;
THREE.FloatType = 1015;
THREE.UnsignedShort4444Type = 1016;
THREE.UnsignedShort5551Type = 1017;
THREE.UnsignedShort565Type = 1018;
THREE.AlphaFormat = 1019;
THREE.RGBFormat = 1020;
THREE.RGBAFormat = 1021;
THREE.LuminanceFormat = 1022;
THREE.LuminanceAlphaFormat = 1023;
THREE.RGB_S3TC_DXT1_Format = 2001;
THREE.RGBA_S3TC_DXT1_Format = 2002;
THREE.RGBA_S3TC_DXT3_Format = 2003;
THREE.RGBA_S3TC_DXT5_Format = 2004;
THREE.Color = function (value) {
  if (value !== undefined)
    this.set(value);
  return this;
};
THREE.Color.prototype = {
  constructor: THREE.Color,
  r: 1,
  g: 1,
  b: 1,
  set: function (value) {
    if (value instanceof THREE.Color) {
      this.copy(value);
    } else if (typeof value === 'number') {
      this.setHex(value);
    } else if (typeof value === 'string') {
      this.setStyle(value);
    }
    return this;
  },
  setHex: function (hex) {
    hex = Math.floor(hex);
    this.r = (hex >> 16 & 255) / 255;
    this.g = (hex >> 8 & 255) / 255;
    this.b = (hex & 255) / 255;
    return this;
  },
  setRGB: function (r, g, b) {
    this.r = r;
    this.g = g;
    this.b = b;
    return this;
  },
  setHSL: function (h, s, l) {
    if (s === 0) {
      this.r = this.g = this.b = l;
    } else {
      var hue2rgb = function (p, q, t) {
        if (t < 0)
          t += 1;
        if (t > 1)
          t -= 1;
        if (t < 1 / 6)
          return p + (q - p) * 6 * t;
        if (t < 1 / 2)
          return q;
        if (t < 2 / 3)
          return p + (q - p) * 6 * (2 / 3 - t);
        return p;
      };
      var p = l <= 0.5 ? l * (1 + s) : l + s - l * s;
      var q = 2 * l - p;
      this.r = hue2rgb(q, p, h + 1 / 3);
      this.g = hue2rgb(q, p, h);
      this.b = hue2rgb(q, p, h - 1 / 3);
    }
    return this;
  },
  setStyle: function (style) {
    if (/^rgb\((\d+),(\d+),(\d+)\)$/i.test(style)) {
      var color = /^rgb\((\d+),(\d+),(\d+)\)$/i.exec(style);
      this.r = Math.min(255, parseInt(color[1], 10)) / 255;
      this.g = Math.min(255, parseInt(color[2], 10)) / 255;
      this.b = Math.min(255, parseInt(color[3], 10)) / 255;
      return this;
    }
    if (/^rgb\((\d+)\%,(\d+)\%,(\d+)\%\)$/i.test(style)) {
      var color = /^rgb\((\d+)\%,(\d+)\%,(\d+)\%\)$/i.exec(style);
      this.r = Math.min(100, parseInt(color[1], 10)) / 100;
      this.g = Math.min(100, parseInt(color[2], 10)) / 100;
      this.b = Math.min(100, parseInt(color[3], 10)) / 100;
      return this;
    }
    if (/^\#([0-9a-f]{6})$/i.test(style)) {
      var color = /^\#([0-9a-f]{6})$/i.exec(style);
      this.setHex(parseInt(color[1], 16));
      return this;
    }
    if (/^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.test(style)) {
      var color = /^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.exec(style);
      this.setHex(parseInt(color[1] + color[1] + color[2] + color[2] + color[3] + color[3], 16));
      return this;
    }
    if (/^(\w+)$/i.test(style)) {
      this.setHex(THREE.ColorKeywords[style]);
      return this;
    }
  },
  copy: function (color) {
    this.r = color.r;
    this.g = color.g;
    this.b = color.b;
    return this;
  },
  copyGammaToLinear: function (color) {
    this.r = color.r * color.r;
    this.g = color.g * color.g;
    this.b = color.b * color.b;
    return this;
  },
  copyLinearToGamma: function (color) {
    this.r = Math.sqrt(color.r);
    this.g = Math.sqrt(color.g);
    this.b = Math.sqrt(color.b);
    return this;
  },
  convertGammaToLinear: function () {
    var r = this.r, g = this.g, b = this.b;
    this.r = r * r;
    this.g = g * g;
    this.b = b * b;
    return this;
  },
  convertLinearToGamma: function () {
    this.r = Math.sqrt(this.r);
    this.g = Math.sqrt(this.g);
    this.b = Math.sqrt(this.b);
    return this;
  },
  getHex: function () {
    return this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0;
  },
  getHexString: function () {
    return ('000000' + this.getHex().toString(16)).slice(-6);
  },
  getHSL: function () {
    var hsl = {
        h: 0,
        s: 0,
        l: 0
      };
    return function () {
      var r = this.r, g = this.g, b = this.b;
      var max = Math.max(r, g, b);
      var min = Math.min(r, g, b);
      var hue, saturation;
      var lightness = (min + max) / 2;
      if (min === max) {
        hue = 0;
        saturation = 0;
      } else {
        var delta = max - min;
        saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
        switch (max) {
        case r:
          hue = (g - b) / delta + (g < b ? 6 : 0);
          break;
        case g:
          hue = (b - r) / delta + 2;
          break;
        case b:
          hue = (r - g) / delta + 4;
          break;
        }
        hue /= 6;
      }
      hsl.h = hue;
      hsl.s = saturation;
      hsl.l = lightness;
      return hsl;
    };
  }(),
  getStyle: function () {
    return 'rgb(' + (this.r * 255 | 0) + ',' + (this.g * 255 | 0) + ',' + (this.b * 255 | 0) + ')';
  },
  offsetHSL: function (h, s, l) {
    var hsl = this.getHSL();
    hsl.h += h;
    hsl.s += s;
    hsl.l += l;
    this.setHSL(hsl.h, hsl.s, hsl.l);
    return this;
  },
  add: function (color) {
    this.r += color.r;
    this.g += color.g;
    this.b += color.b;
    return this;
  },
  addColors: function (color1, color2) {
    this.r = color1.r + color2.r;
    this.g = color1.g + color2.g;
    this.b = color1.b + color2.b;
    return this;
  },
  addScalar: function (s) {
    this.r += s;
    this.g += s;
    this.b += s;
    return this;
  },
  multiply: function (color) {
    this.r *= color.r;
    this.g *= color.g;
    this.b *= color.b;
    return this;
  },
  multiplyScalar: function (s) {
    this.r *= s;
    this.g *= s;
    this.b *= s;
    return this;
  },
  lerp: function (color, alpha) {
    this.r += (color.r - this.r) * alpha;
    this.g += (color.g - this.g) * alpha;
    this.b += (color.b - this.b) * alpha;
    return this;
  },
  equals: function (c) {
    return c.r === this.r && c.g === this.g && c.b === this.b;
  },
  fromArray: function (array) {
    this.r = array[0];
    this.g = array[1];
    this.b = array[2];
    return this;
  },
  toArray: function () {
    return [
      this.r,
      this.g,
      this.b
    ];
  },
  clone: function () {
    return new THREE.Color().setRGB(this.r, this.g, this.b);
  }
};
THREE.ColorKeywords = {
  'aliceblue': 15792383,
  'antiquewhite': 16444375,
  'aqua': 65535,
  'aquamarine': 8388564,
  'azure': 15794175,
  'beige': 16119260,
  'bisque': 16770244,
  'black': 0,
  'blanchedalmond': 16772045,
  'blue': 255,
  'blueviolet': 9055202,
  'brown': 10824234,
  'burlywood': 14596231,
  'cadetblue': 6266528,
  'chartreuse': 8388352,
  'chocolate': 13789470,
  'coral': 16744272,
  'cornflowerblue': 6591981,
  'cornsilk': 16775388,
  'crimson': 14423100,
  'cyan': 65535,
  'darkblue': 139,
  'darkcyan': 35723,
  'darkgoldenrod': 12092939,
  'darkgray': 11119017,
  'darkgreen': 25600,
  'darkgrey': 11119017,
  'darkkhaki': 12433259,
  'darkmagenta': 9109643,
  'darkolivegreen': 5597999,
  'darkorange': 16747520,
  'darkorchid': 10040012,
  'darkred': 9109504,
  'darksalmon': 15308410,
  'darkseagreen': 9419919,
  'darkslateblue': 4734347,
  'darkslategray': 3100495,
  'darkslategrey': 3100495,
  'darkturquoise': 52945,
  'darkviolet': 9699539,
  'deeppink': 16716947,
  'deepskyblue': 49151,
  'dimgray': 6908265,
  'dimgrey': 6908265,
  'dodgerblue': 2003199,
  'firebrick': 11674146,
  'floralwhite': 16775920,
  'forestgreen': 2263842,
  'fuchsia': 16711935,
  'gainsboro': 14474460,
  'ghostwhite': 16316671,
  'gold': 16766720,
  'goldenrod': 14329120,
  'gray': 8421504,
  'green': 32768,
  'greenyellow': 11403055,
  'grey': 8421504,
  'honeydew': 15794160,
  'hotpink': 16738740,
  'indianred': 13458524,
  'indigo': 4915330,
  'ivory': 16777200,
  'khaki': 15787660,
  'lavender': 15132410,
  'lavenderblush': 16773365,
  'lawngreen': 8190976,
  'lemonchiffon': 16775885,
  'lightblue': 11393254,
  'lightcoral': 15761536,
  'lightcyan': 14745599,
  'lightgoldenrodyellow': 16448210,
  'lightgray': 13882323,
  'lightgreen': 9498256,
  'lightgrey': 13882323,
  'lightpink': 16758465,
  'lightsalmon': 16752762,
  'lightseagreen': 2142890,
  'lightskyblue': 8900346,
  'lightslategray': 7833753,
  'lightslategrey': 7833753,
  'lightsteelblue': 11584734,
  'lightyellow': 16777184,
  'lime': 65280,
  'limegreen': 3329330,
  'linen': 16445670,
  'magenta': 16711935,
  'maroon': 8388608,
  'mediumaquamarine': 6737322,
  'mediumblue': 205,
  'mediumorchid': 12211667,
  'mediumpurple': 9662683,
  'mediumseagreen': 3978097,
  'mediumslateblue': 8087790,
  'mediumspringgreen': 64154,
  'mediumturquoise': 4772300,
  'mediumvioletred': 13047173,
  'midnightblue': 1644912,
  'mintcream': 16121850,
  'mistyrose': 16770273,
  'moccasin': 16770229,
  'navajowhite': 16768685,
  'navy': 128,
  'oldlace': 16643558,
  'olive': 8421376,
  'olivedrab': 7048739,
  'orange': 16753920,
  'orangered': 16729344,
  'orchid': 14315734,
  'palegoldenrod': 15657130,
  'palegreen': 10025880,
  'paleturquoise': 11529966,
  'palevioletred': 14381203,
  'papayawhip': 16773077,
  'peachpuff': 16767673,
  'peru': 13468991,
  'pink': 16761035,
  'plum': 14524637,
  'powderblue': 11591910,
  'purple': 8388736,
  'red': 16711680,
  'rosybrown': 12357519,
  'royalblue': 4286945,
  'saddlebrown': 9127187,
  'salmon': 16416882,
  'sandybrown': 16032864,
  'seagreen': 3050327,
  'seashell': 16774638,
  'sienna': 10506797,
  'silver': 12632256,
  'skyblue': 8900331,
  'slateblue': 6970061,
  'slategray': 7372944,
  'slategrey': 7372944,
  'snow': 16775930,
  'springgreen': 65407,
  'steelblue': 4620980,
  'tan': 13808780,
  'teal': 32896,
  'thistle': 14204888,
  'tomato': 16737095,
  'turquoise': 4251856,
  'violet': 15631086,
  'wheat': 16113331,
  'white': 16777215,
  'whitesmoke': 16119285,
  'yellow': 16776960,
  'yellowgreen': 10145074
};
THREE.Quaternion = function (x, y, z, w) {
  this._x = x || 0;
  this._y = y || 0;
  this._z = z || 0;
  this._w = w !== undefined ? w : 1;
};
THREE.Quaternion.prototype = {
  constructor: THREE.Quaternion,
  _x: 0,
  _y: 0,
  _z: 0,
  _w: 0,
  _euler: undefined,
  _updateEuler: function (callback) {
    if (this._euler !== undefined) {
      this._euler.setFromQuaternion(this, undefined, false);
    }
  },
  get x() {
    return this._x;
  },
  set x(value) {
    this._x = value;
    this._updateEuler();
  },
  get y() {
    return this._y;
  },
  set y(value) {
    this._y = value;
    this._updateEuler();
  },
  get z() {
    return this._z;
  },
  set z(value) {
    this._z = value;
    this._updateEuler();
  },
  get w() {
    return this._w;
  },
  set w(value) {
    this._w = value;
    this._updateEuler();
  },
  set: function (x, y, z, w) {
    this._x = x;
    this._y = y;
    this._z = z;
    this._w = w;
    this._updateEuler();
    return this;
  },
  copy: function (quaternion) {
    this._x = quaternion._x;
    this._y = quaternion._y;
    this._z = quaternion._z;
    this._w = quaternion._w;
    this._updateEuler();
    return this;
  },
  setFromEuler: function (euler, update) {
    if (euler instanceof THREE.Euler === false) {
      throw new Error('ERROR: Quaternion\'s .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.  Please update your code.');
    }
    var c1 = Math.cos(euler._x / 2);
    var c2 = Math.cos(euler._y / 2);
    var c3 = Math.cos(euler._z / 2);
    var s1 = Math.sin(euler._x / 2);
    var s2 = Math.sin(euler._y / 2);
    var s3 = Math.sin(euler._z / 2);
    if (euler.order === 'XYZ') {
      this._x = s1 * c2 * c3 + c1 * s2 * s3;
      this._y = c1 * s2 * c3 - s1 * c2 * s3;
      this._z = c1 * c2 * s3 + s1 * s2 * c3;
      this._w = c1 * c2 * c3 - s1 * s2 * s3;
    } else if (euler.order === 'YXZ') {
      this._x = s1 * c2 * c3 + c1 * s2 * s3;
      this._y = c1 * s2 * c3 - s1 * c2 * s3;
      this._z = c1 * c2 * s3 - s1 * s2 * c3;
      this._w = c1 * c2 * c3 + s1 * s2 * s3;
    } else if (euler.order === 'ZXY') {
      this._x = s1 * c2 * c3 - c1 * s2 * s3;
      this._y = c1 * s2 * c3 + s1 * c2 * s3;
      this._z = c1 * c2 * s3 + s1 * s2 * c3;
      this._w = c1 * c2 * c3 - s1 * s2 * s3;
    } else if (euler.order === 'ZYX') {
      this._x = s1 * c2 * c3 - c1 * s2 * s3;
      this._y = c1 * s2 * c3 + s1 * c2 * s3;
      this._z = c1 * c2 * s3 - s1 * s2 * c3;
      this._w = c1 * c2 * c3 + s1 * s2 * s3;
    } else if (euler.order === 'YZX') {
      this._x = s1 * c2 * c3 + c1 * s2 * s3;
      this._y = c1 * s2 * c3 + s1 * c2 * s3;
      this._z = c1 * c2 * s3 - s1 * s2 * c3;
      this._w = c1 * c2 * c3 - s1 * s2 * s3;
    } else if (euler.order === 'XZY') {
      this._x = s1 * c2 * c3 - c1 * s2 * s3;
      this._y = c1 * s2 * c3 - s1 * c2 * s3;
      this._z = c1 * c2 * s3 + s1 * s2 * c3;
      this._w = c1 * c2 * c3 + s1 * s2 * s3;
    }
    if (update !== false)
      this._updateEuler();
    return this;
  },
  setFromAxisAngle: function (axis, angle) {
    var halfAngle = angle / 2, s = Math.sin(halfAngle);
    this._x = axis.x * s;
    this._y = axis.y * s;
    this._z = axis.z * s;
    this._w = Math.cos(halfAngle);
    this._updateEuler();
    return this;
  },
  setFromRotationMatrix: function (m) {
    var te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33, s;
    if (trace > 0) {
      s = 0.5 / Math.sqrt(trace + 1);
      this._w = 0.25 / s;
      this._x = (m32 - m23) * s;
      this._y = (m13 - m31) * s;
      this._z = (m21 - m12) * s;
    } else if (m11 > m22 && m11 > m33) {
      s = 2 * Math.sqrt(1 + m11 - m22 - m33);
      this._w = (m32 - m23) / s;
      this._x = 0.25 * s;
      this._y = (m12 + m21) / s;
      this._z = (m13 + m31) / s;
    } else if (m22 > m33) {
      s = 2 * Math.sqrt(1 + m22 - m11 - m33);
      this._w = (m13 - m31) / s;
      this._x = (m12 + m21) / s;
      this._y = 0.25 * s;
      this._z = (m23 + m32) / s;
    } else {
      s = 2 * Math.sqrt(1 + m33 - m11 - m22);
      this._w = (m21 - m12) / s;
      this._x = (m13 + m31) / s;
      this._y = (m23 + m32) / s;
      this._z = 0.25 * s;
    }
    this._updateEuler();
    return this;
  },
  inverse: function () {
    this.conjugate().normalize();
    return this;
  },
  conjugate: function () {
    this._x *= -1;
    this._y *= -1;
    this._z *= -1;
    this._updateEuler();
    return this;
  },
  lengthSq: function () {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  },
  length: function () {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  },
  normalize: function () {
    var l = this.length();
    if (l === 0) {
      this._x = 0;
      this._y = 0;
      this._z = 0;
      this._w = 1;
    } else {
      l = 1 / l;
      this._x = this._x * l;
      this._y = this._y * l;
      this._z = this._z * l;
      this._w = this._w * l;
    }
    return this;
  },
  multiply: function (q, p) {
    if (p !== undefined) {
      console.warn('DEPRECATED: Quaternion\'s .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.');
      return this.multiplyQuaternions(q, p);
    }
    return this.multiplyQuaternions(this, q);
  },
  multiplyQuaternions: function (a, b) {
    var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
    var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;
    this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
    this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
    this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
    this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
    this._updateEuler();
    return this;
  },
  multiplyVector3: function (vector) {
    console.warn('DEPRECATED: Quaternion\'s .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.');
    return vector.applyQuaternion(this);
  },
  slerp: function (qb, t) {
    var x = this._x, y = this._y, z = this._z, w = this._w;
    var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
    if (cosHalfTheta < 0) {
      this._w = -qb._w;
      this._x = -qb._x;
      this._y = -qb._y;
      this._z = -qb._z;
      cosHalfTheta = -cosHalfTheta;
    } else {
      this.copy(qb);
    }
    if (cosHalfTheta >= 1) {
      this._w = w;
      this._x = x;
      this._y = y;
      this._z = z;
      return this;
    }
    var halfTheta = Math.acos(cosHalfTheta);
    var sinHalfTheta = Math.sqrt(1 - cosHalfTheta * cosHalfTheta);
    if (Math.abs(sinHalfTheta) < 0.001) {
      this._w = 0.5 * (w + this._w);
      this._x = 0.5 * (x + this._x);
      this._y = 0.5 * (y + this._y);
      this._z = 0.5 * (z + this._z);
      return this;
    }
    var ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
    this._w = w * ratioA + this._w * ratioB;
    this._x = x * ratioA + this._x * ratioB;
    this._y = y * ratioA + this._y * ratioB;
    this._z = z * ratioA + this._z * ratioB;
    this._updateEuler();
    return this;
  },
  equals: function (quaternion) {
    return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
  },
  fromArray: function (array) {
    this._x = array[0];
    this._y = array[1];
    this._z = array[2];
    this._w = array[3];
    this._updateEuler();
    return this;
  },
  toArray: function () {
    return [
      this._x,
      this._y,
      this._z,
      this._w
    ];
  },
  clone: function () {
    return new THREE.Quaternion(this._x, this._y, this._z, this._w);
  }
};
THREE.Quaternion.slerp = function (qa, qb, qm, t) {
  return qm.copy(qa).slerp(qb, t);
};
THREE.Vector2 = function (x, y) {
  this.x = x || 0;
  this.y = y || 0;
};
THREE.Vector2.prototype = {
  constructor: THREE.Vector2,
  set: function (x, y) {
    this.x = x;
    this.y = y;
    return this;
  },
  setX: function (x) {
    this.x = x;
    return this;
  },
  setY: function (y) {
    this.y = y;
    return this;
  },
  setComponent: function (index, value) {
    switch (index) {
    case 0:
      this.x = value;
      break;
    case 1:
      this.y = value;
      break;
    default:
      throw new Error('index is out of range: ' + index);
    }
  },
  getComponent: function (index) {
    switch (index) {
    case 0:
      return this.x;
    case 1:
      return this.y;
    default:
      throw new Error('index is out of range: ' + index);
    }
  },
  copy: function (v) {
    this.x = v.x;
    this.y = v.y;
    return this;
  },
  add: function (v, w) {
    if (w !== undefined) {
      console.warn('DEPRECATED: Vector2\'s .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
      return this.addVectors(v, w);
    }
    this.x += v.x;
    this.y += v.y;
    return this;
  },
  addVectors: function (a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    return this;
  },
  addScalar: function (s) {
    this.x += s;
    this.y += s;
    return this;
  },
  sub: function (v, w) {
    if (w !== undefined) {
      console.warn('DEPRECATED: Vector2\'s .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
      return this.subVectors(v, w);
    }
    this.x -= v.x;
    this.y -= v.y;
    return this;
  },
  subVectors: function (a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    return this;
  },
  multiplyScalar: function (s) {
    this.x *= s;
    this.y *= s;
    return this;
  },
  divideScalar: function (scalar) {
    if (scalar !== 0) {
      var invScalar = 1 / scalar;
      this.x *= invScalar;
      this.y *= invScalar;
    } else {
      this.x = 0;
      this.y = 0;
    }
    return this;
  },
  min: function (v) {
    if (this.x > v.x) {
      this.x = v.x;
    }
    if (this.y > v.y) {
      this.y = v.y;
    }
    return this;
  },
  max: function (v) {
    if (this.x < v.x) {
      this.x = v.x;
    }
    if (this.y < v.y) {
      this.y = v.y;
    }
    return this;
  },
  clamp: function (min, max) {
    if (this.x < min.x) {
      this.x = min.x;
    } else if (this.x > max.x) {
      this.x = max.x;
    }
    if (this.y < min.y) {
      this.y = min.y;
    } else if (this.y > max.y) {
      this.y = max.y;
    }
    return this;
  },
  negate: function () {
    return this.multiplyScalar(-1);
  },
  dot: function (v) {
    return this.x * v.x + this.y * v.y;
  },
  lengthSq: function () {
    return this.x * this.x + this.y * this.y;
  },
  length: function () {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  },
  normalize: function () {
    return this.divideScalar(this.length());
  },
  distanceTo: function (v) {
    return Math.sqrt(this.distanceToSquared(v));
  },
  distanceToSquared: function (v) {
    var dx = this.x - v.x, dy = this.y - v.y;
    return dx * dx + dy * dy;
  },
  setLength: function (l) {
    var oldLength = this.length();
    if (oldLength !== 0 && l !== oldLength) {
      this.multiplyScalar(l / oldLength);
    }
    return this;
  },
  lerp: function (v, alpha) {
    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    return this;
  },
  equals: function (v) {
    return v.x === this.x && v.y === this.y;
  },
  fromArray: function (array) {
    this.x = array[0];
    this.y = array[1];
    return this;
  },
  toArray: function () {
    return [
      this.x,
      this.y
    ];
  },
  clone: function () {
    return new THREE.Vector2(this.x, this.y);
  }
};
THREE.Vector3 = function (x, y, z) {
  this.x = x || 0;
  this.y = y || 0;
  this.z = z || 0;
};
THREE.Vector3.prototype = {
  constructor: THREE.Vector3,
  set: function (x, y, z) {
    this.x = x;
    this.y = y;
    this.z = z;
    return this;
  },
  setX: function (x) {
    this.x = x;
    return this;
  },
  setY: function (y) {
    this.y = y;
    return this;
  },
  setZ: function (z) {
    this.z = z;
    return this;
  },
  setComponent: function (index, value) {
    switch (index) {
    case 0:
      this.x = value;
      break;
    case 1:
      this.y = value;
      break;
    case 2:
      this.z = value;
      break;
    default:
      throw new Error('index is out of range: ' + index);
    }
  },
  getComponent: function (index) {
    switch (index) {
    case 0:
      return this.x;
    case 1:
      return this.y;
    case 2:
      return this.z;
    default:
      throw new Error('index is out of range: ' + index);
    }
  },
  copy: function (v) {
    this.x = v.x;
    this.y = v.y;
    this.z = v.z;
    return this;
  },
  add: function (v, w) {
    if (w !== undefined) {
      console.warn('DEPRECATED: Vector3\'s .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
      return this.addVectors(v, w);
    }
    this.x += v.x;
    this.y += v.y;
    this.z += v.z;
    return this;
  },
  addScalar: function (s) {
    this.x += s;
    this.y += s;
    this.z += s;
    return this;
  },
  addVectors: function (a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;
    return this;
  },
  sub: function (v, w) {
    if (w !== undefined) {
      console.warn('DEPRECATED: Vector3\'s .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
      return this.subVectors(v, w);
    }
    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;
    return this;
  },
  subVectors: function (a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;
    return this;
  },
  multiply: function (v, w) {
    if (w !== undefined) {
      console.warn('DEPRECATED: Vector3\'s .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.');
      return this.multiplyVectors(v, w);
    }
    this.x *= v.x;
    this.y *= v.y;
    this.z *= v.z;
    return this;
  },
  multiplyScalar: function (scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    return this;
  },
  multiplyVectors: function (a, b) {
    this.x = a.x * b.x;
    this.y = a.y * b.y;
    this.z = a.z * b.z;
    return this;
  },
  applyMatrix3: function (m) {
    var x = this.x;
    var y = this.y;
    var z = this.z;
    var e = m.elements;
    this.x = e[0] * x + e[3] * y + e[6] * z;
    this.y = e[1] * x + e[4] * y + e[7] * z;
    this.z = e[2] * x + e[5] * y + e[8] * z;
    return this;
  },
  applyMatrix4: function (m) {
    var x = this.x, y = this.y, z = this.z;
    var e = m.elements;
    this.x = e[0] * x + e[4] * y + e[8] * z + e[12];
    this.y = e[1] * x + e[5] * y + e[9] * z + e[13];
    this.z = e[2] * x + e[6] * y + e[10] * z + e[14];
    return this;
  },
  applyProjection: function (m) {
    var x = this.x, y = this.y, z = this.z;
    var e = m.elements;
    var d = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
    this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * d;
    this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * d;
    this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * d;
    return this;
  },
  applyQuaternion: function (q) {
    var x = this.x;
    var y = this.y;
    var z = this.z;
    var qx = q.x;
    var qy = q.y;
    var qz = q.z;
    var qw = q.w;
    var ix = qw * x + qy * z - qz * y;
    var iy = qw * y + qz * x - qx * z;
    var iz = qw * z + qx * y - qy * x;
    var iw = -qx * x - qy * y - qz * z;
    this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return this;
  },
  transformDirection: function (m) {
    var x = this.x, y = this.y, z = this.z;
    var e = m.elements;
    this.x = e[0] * x + e[4] * y + e[8] * z;
    this.y = e[1] * x + e[5] * y + e[9] * z;
    this.z = e[2] * x + e[6] * y + e[10] * z;
    this.normalize();
    return this;
  },
  divide: function (v) {
    this.x /= v.x;
    this.y /= v.y;
    this.z /= v.z;
    return this;
  },
  divideScalar: function (scalar) {
    if (scalar !== 0) {
      var invScalar = 1 / scalar;
      this.x *= invScalar;
      this.y *= invScalar;
      this.z *= invScalar;
    } else {
      this.x = 0;
      this.y = 0;
      this.z = 0;
    }
    return this;
  },
  min: function (v) {
    if (this.x > v.x) {
      this.x = v.x;
    }
    if (this.y > v.y) {
      this.y = v.y;
    }
    if (this.z > v.z) {
      this.z = v.z;
    }
    return this;
  },
  max: function (v) {
    if (this.x < v.x) {
      this.x = v.x;
    }
    if (this.y < v.y) {
      this.y = v.y;
    }
    if (this.z < v.z) {
      this.z = v.z;
    }
    return this;
  },
  clamp: function (min, max) {
    if (this.x < min.x) {
      this.x = min.x;
    } else if (this.x > max.x) {
      this.x = max.x;
    }
    if (this.y < min.y) {
      this.y = min.y;
    } else if (this.y > max.y) {
      this.y = max.y;
    }
    if (this.z < min.z) {
      this.z = min.z;
    } else if (this.z > max.z) {
      this.z = max.z;
    }
    return this;
  },
  negate: function () {
    return this.multiplyScalar(-1);
  },
  dot: function (v) {
    return this.x * v.x + this.y * v.y + this.z * v.z;
  },
  lengthSq: function () {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  },
  length: function () {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  },
  lengthManhattan: function () {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  },
  normalize: function () {
    return this.divideScalar(this.length());
  },
  setLength: function (l) {
    var oldLength = this.length();
    if (oldLength !== 0 && l !== oldLength) {
      this.multiplyScalar(l / oldLength);
    }
    return this;
  },
  lerp: function (v, alpha) {
    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    this.z += (v.z - this.z) * alpha;
    return this;
  },
  cross: function (v, w) {
    if (w !== undefined) {
      console.warn('DEPRECATED: Vector3\'s .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.');
      return this.crossVectors(v, w);
    }
    var x = this.x, y = this.y, z = this.z;
    this.x = y * v.z - z * v.y;
    this.y = z * v.x - x * v.z;
    this.z = x * v.y - y * v.x;
    return this;
  },
  crossVectors: function (a, b) {
    var ax = a.x, ay = a.y, az = a.z;
    var bx = b.x, by = b.y, bz = b.z;
    this.x = ay * bz - az * by;
    this.y = az * bx - ax * bz;
    this.z = ax * by - ay * bx;
    return this;
  },
  angleTo: function (v) {
    var theta = this.dot(v) / (this.length() * v.length());
    return Math.acos(THREE.Math.clamp(theta, -1, 1));
  },
  distanceTo: function (v) {
    return Math.sqrt(this.distanceToSquared(v));
  },
  distanceToSquared: function (v) {
    var dx = this.x - v.x;
    var dy = this.y - v.y;
    var dz = this.z - v.z;
    return dx * dx + dy * dy + dz * dz;
  },
  setEulerFromRotationMatrix: function (m, order) {
    console.error('REMOVED: Vector3\'s setEulerFromRotationMatrix has been removed in favor of Euler.setFromRotationMatrix(), please update your code.');
  },
  setEulerFromQuaternion: function (q, order) {
    console.error('REMOVED: Vector3\'s setEulerFromQuaternion: has been removed in favor of Euler.setFromQuaternion(), please update your code.');
  },
  getPositionFromMatrix: function (m) {
    this.x = m.elements[12];
    this.y = m.elements[13];
    this.z = m.elements[14];
    return this;
  },
  getScaleFromMatrix: function (m) {
    var sx = this.set(m.elements[0], m.elements[1], m.elements[2]).length();
    var sy = this.set(m.elements[4], m.elements[5], m.elements[6]).length();
    var sz = this.set(m.elements[8], m.elements[9], m.elements[10]).length();
    this.x = sx;
    this.y = sy;
    this.z = sz;
    return this;
  },
  getColumnFromMatrix: function (index, matrix) {
    var offset = index * 4;
    var me = matrix.elements;
    this.x = me[offset];
    this.y = me[offset + 1];
    this.z = me[offset + 2];
    return this;
  },
  equals: function (v) {
    return v.x === this.x && v.y === this.y && v.z === this.z;
  },
  fromArray: function (array) {
    this.x = array[0];
    this.y = array[1];
    this.z = array[2];
    return this;
  },
  toArray: function () {
    return [
      this.x,
      this.y,
      this.z
    ];
  },
  clone: function () {
    return new THREE.Vector3(this.x, this.y, this.z);
  }
};
THREE.extend(THREE.Vector3.prototype, {
  applyEuler: function () {
    var quaternion = new THREE.Quaternion();
    return function (euler) {
      if (euler instanceof THREE.Euler === false) {
        console.error('ERROR: Vector3\'s .applyEuler() now expects a Euler rotation rather than a Vector3 and order.  Please update your code.');
      }
      this.applyQuaternion(quaternion.setFromEuler(euler));
      return this;
    };
  }(),
  applyAxisAngle: function () {
    var quaternion = new THREE.Quaternion();
    return function (axis, angle) {
      this.applyQuaternion(quaternion.setFromAxisAngle(axis, angle));
      return this;
    };
  }(),
  projectOnVector: function () {
    var v1 = new THREE.Vector3();
    return function (vector) {
      v1.copy(vector).normalize();
      var d = this.dot(v1);
      return this.copy(v1).multiplyScalar(d);
    };
  }(),
  projectOnPlane: function () {
    var v1 = new THREE.Vector3();
    return function (planeNormal) {
      v1.copy(this).projectOnVector(planeNormal);
      return this.sub(v1);
    };
  }(),
  reflect: function () {
    var v1 = new THREE.Vector3();
    return function (vector) {
      v1.copy(this).projectOnVector(vector).multiplyScalar(2);
      return this.subVectors(v1, this);
    };
  }()
});
THREE.Vector4 = function (x, y, z, w) {
  this.x = x || 0;
  this.y = y || 0;
  this.z = z || 0;
  this.w = w !== undefined ? w : 1;
};
THREE.Vector4.prototype = {
  constructor: THREE.Vector4,
  set: function (x, y, z, w) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
    return this;
  },
  setX: function (x) {
    this.x = x;
    return this;
  },
  setY: function (y) {
    this.y = y;
    return this;
  },
  setZ: function (z) {
    this.z = z;
    return this;
  },
  setW: function (w) {
    this.w = w;
    return this;
  },
  setComponent: function (index, value) {
    switch (index) {
    case 0:
      this.x = value;
      break;
    case 1:
      this.y = value;
      break;
    case 2:
      this.z = value;
      break;
    case 3:
      this.w = value;
      break;
    default:
      throw new Error('index is out of range: ' + index);
    }
  },
  getComponent: function (index) {
    switch (index) {
    case 0:
      return this.x;
    case 1:
      return this.y;
    case 2:
      return this.z;
    case 3:
      return this.w;
    default:
      throw new Error('index is out of range: ' + index);
    }
  },
  copy: function (v) {
    this.x = v.x;
    this.y = v.y;
    this.z = v.z;
    this.w = v.w !== undefined ? v.w : 1;
    return this;
  },
  add: function (v, w) {
    if (w !== undefined) {
      console.warn('DEPRECATED: Vector4\'s .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
      return this.addVectors(v, w);
    }
    this.x += v.x;
    this.y += v.y;
    this.z += v.z;
    this.w += v.w;
    return this;
  },
  addScalar: function (s) {
    this.x += s;
    this.y += s;
    this.z += s;
    this.w += s;
    return this;
  },
  addVectors: function (a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;
    this.w = a.w + b.w;
    return this;
  },
  sub: function (v, w) {
    if (w !== undefined) {
      console.warn('DEPRECATED: Vector4\'s .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
      return this.subVectors(v, w);
    }
    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;
    this.w -= v.w;
    return this;
  },
  subVectors: function (a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;
    this.w = a.w - b.w;
    return this;
  },
  multiplyScalar: function (scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    this.w *= scalar;
    return this;
  },
  applyMatrix4: function (m) {
    var x = this.x;
    var y = this.y;
    var z = this.z;
    var w = this.w;
    var e = m.elements;
    this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
    this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
    this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
    this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
    return this;
  },
  divideScalar: function (scalar) {
    if (scalar !== 0) {
      var invScalar = 1 / scalar;
      this.x *= invScalar;
      this.y *= invScalar;
      this.z *= invScalar;
      this.w *= invScalar;
    } else {
      this.x = 0;
      this.y = 0;
      this.z = 0;
      this.w = 1;
    }
    return this;
  },
  setAxisAngleFromQuaternion: function (q) {
    this.w = 2 * Math.acos(q.w);
    var s = Math.sqrt(1 - q.w * q.w);
    if (s < 0.0001) {
      this.x = 1;
      this.y = 0;
      this.z = 0;
    } else {
      this.x = q.x / s;
      this.y = q.y / s;
      this.z = q.z / s;
    }
    return this;
  },
  setAxisAngleFromRotationMatrix: function (m) {
    var angle, x, y, z, epsilon = 0.01, epsilon2 = 0.1, te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];
    if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
      if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
        this.set(1, 0, 0, 0);
        return this;
      }
      angle = Math.PI;
      var xx = (m11 + 1) / 2;
      var yy = (m22 + 1) / 2;
      var zz = (m33 + 1) / 2;
      var xy = (m12 + m21) / 4;
      var xz = (m13 + m31) / 4;
      var yz = (m23 + m32) / 4;
      if (xx > yy && xx > zz) {
        if (xx < epsilon) {
          x = 0;
          y = 0.707106781;
          z = 0.707106781;
        } else {
          x = Math.sqrt(xx);
          y = xy / x;
          z = xz / x;
        }
      } else if (yy > zz) {
        if (yy < epsilon) {
          x = 0.707106781;
          y = 0;
          z = 0.707106781;
        } else {
          y = Math.sqrt(yy);
          x = xy / y;
          z = yz / y;
        }
      } else {
        if (zz < epsilon) {
          x = 0.707106781;
          y = 0.707106781;
          z = 0;
        } else {
          z = Math.sqrt(zz);
          x = xz / z;
          y = yz / z;
        }
      }
      this.set(x, y, z, angle);
      return this;
    }
    var s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));
    if (Math.abs(s) < 0.001)
      s = 1;
    this.x = (m32 - m23) / s;
    this.y = (m13 - m31) / s;
    this.z = (m21 - m12) / s;
    this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
    return this;
  },
  min: function (v) {
    if (this.x > v.x) {
      this.x = v.x;
    }
    if (this.y > v.y) {
      this.y = v.y;
    }
    if (this.z > v.z) {
      this.z = v.z;
    }
    if (this.w > v.w) {
      this.w = v.w;
    }
    return this;
  },
  max: function (v) {
    if (this.x < v.x) {
      this.x = v.x;
    }
    if (this.y < v.y) {
      this.y = v.y;
    }
    if (this.z < v.z) {
      this.z = v.z;
    }
    if (this.w < v.w) {
      this.w = v.w;
    }
    return this;
  },
  clamp: function (min, max) {
    if (this.x < min.x) {
      this.x = min.x;
    } else if (this.x > max.x) {
      this.x = max.x;
    }
    if (this.y < min.y) {
      this.y = min.y;
    } else if (this.y > max.y) {
      this.y = max.y;
    }
    if (this.z < min.z) {
      this.z = min.z;
    } else if (this.z > max.z) {
      this.z = max.z;
    }
    if (this.w < min.w) {
      this.w = min.w;
    } else if (this.w > max.w) {
      this.w = max.w;
    }
    return this;
  },
  negate: function () {
    return this.multiplyScalar(-1);
  },
  dot: function (v) {
    return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
  },
  lengthSq: function () {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  },
  length: function () {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  },
  lengthManhattan: function () {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  },
  normalize: function () {
    return this.divideScalar(this.length());
  },
  setLength: function (l) {
    var oldLength = this.length();
    if (oldLength !== 0 && l !== oldLength) {
      this.multiplyScalar(l / oldLength);
    }
    return this;
  },
  lerp: function (v, alpha) {
    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    this.z += (v.z - this.z) * alpha;
    this.w += (v.w - this.w) * alpha;
    return this;
  },
  equals: function (v) {
    return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
  },
  fromArray: function (array) {
    this.x = array[0];
    this.y = array[1];
    this.z = array[2];
    this.w = array[3];
    return this;
  },
  toArray: function () {
    return [
      this.x,
      this.y,
      this.z,
      this.w
    ];
  },
  clone: function () {
    return new THREE.Vector4(this.x, this.y, this.z, this.w);
  }
};
THREE.Euler = function (x, y, z, order) {
  this._x = x || 0;
  this._y = y || 0;
  this._z = z || 0;
  this._order = order || THREE.Euler.DefaultOrder;
};
THREE.Euler.RotationOrders = [
  'XYZ',
  'YZX',
  'ZXY',
  'XZY',
  'YXZ',
  'ZYX'
];
THREE.Euler.DefaultOrder = 'XYZ';
THREE.Euler.prototype = {
  constructor: THREE.Euler,
  _x: 0,
  _y: 0,
  _z: 0,
  _order: THREE.Euler.DefaultOrder,
  _quaternion: undefined,
  _updateQuaternion: function () {
    if (this._quaternion !== undefined) {
      this._quaternion.setFromEuler(this, false);
    }
  },
  get x() {
    return this._x;
  },
  set x(value) {
    this._x = value;
    this._updateQuaternion();
  },
  get y() {
    return this._y;
  },
  set y(value) {
    this._y = value;
    this._updateQuaternion();
  },
  get z() {
    return this._z;
  },
  set z(value) {
    this._z = value;
    this._updateQuaternion();
  },
  get order() {
    return this._order;
  },
  set order(value) {
    this._order = value;
    this._updateQuaternion();
  },
  set: function (x, y, z, order) {
    this._x = x;
    this._y = y;
    this._z = z;
    this._order = order || this._order;
    this._updateQuaternion();
    return this;
  },
  copy: function (euler) {
    this._x = euler._x;
    this._y = euler._y;
    this._z = euler._z;
    this._order = euler._order;
    this._updateQuaternion();
    return this;
  },
  setFromRotationMatrix: function (m, order) {
    function clamp(x) {
      return Math.min(Math.max(x, -1), 1);
    }
    var te = m.elements;
    var m11 = te[0], m12 = te[4], m13 = te[8];
    var m21 = te[1], m22 = te[5], m23 = te[9];
    var m31 = te[2], m32 = te[6], m33 = te[10];
    order = order || this._order;
    if (order === 'XYZ') {
      this._y = Math.asin(clamp(m13));
      if (Math.abs(m13) < 0.99999) {
        this._x = Math.atan2(-m23, m33);
        this._z = Math.atan2(-m12, m11);
      } else {
        this._x = Math.atan2(m32, m22);
        this._z = 0;
      }
    } else if (order === 'YXZ') {
      this._x = Math.asin(-clamp(m23));
      if (Math.abs(m23) < 0.99999) {
        this._y = Math.atan2(m13, m33);
        this._z = Math.atan2(m21, m22);
      } else {
        this._y = Math.atan2(-m31, m11);
        this._z = 0;
      }
    } else if (order === 'ZXY') {
      this._x = Math.asin(clamp(m32));
      if (Math.abs(m32) < 0.99999) {
        this._y = Math.atan2(-m31, m33);
        this._z = Math.atan2(-m12, m22);
      } else {
        this._y = 0;
        this._z = Math.atan2(m21, m11);
      }
    } else if (order === 'ZYX') {
      this._y = Math.asin(-clamp(m31));
      if (Math.abs(m31) < 0.99999) {
        this._x = Math.atan2(m32, m33);
        this._z = Math.atan2(m21, m11);
      } else {
        this._x = 0;
        this._z = Math.atan2(-m12, m22);
      }
    } else if (order === 'YZX') {
      this._z = Math.asin(clamp(m21));
      if (Math.abs(m21) < 0.99999) {
        this._x = Math.atan2(-m23, m22);
        this._y = Math.atan2(-m31, m11);
      } else {
        this._x = 0;
        this._y = Math.atan2(m13, m33);
      }
    } else if (order === 'XZY') {
      this._z = Math.asin(-clamp(m12));
      if (Math.abs(m12) < 0.99999) {
        this._x = Math.atan2(m32, m22);
        this._y = Math.atan2(m13, m11);
      } else {
        this._x = Math.atan2(-m23, m33);
        this._y = 0;
      }
    } else {
      console.warn('WARNING: Euler.setFromRotationMatrix() given unsupported order: ' + order);
    }
    this._order = order;
    this._updateQuaternion();
    return this;
  },
  setFromQuaternion: function (q, order, update) {
    function clamp(x) {
      return Math.min(Math.max(x, -1), 1);
    }
    var sqx = q.x * q.x;
    var sqy = q.y * q.y;
    var sqz = q.z * q.z;
    var sqw = q.w * q.w;
    order = order || this._order;
    if (order === 'XYZ') {
      this._x = Math.atan2(2 * (q.x * q.w - q.y * q.z), sqw - sqx - sqy + sqz);
      this._y = Math.asin(clamp(2 * (q.x * q.z + q.y * q.w)));
      this._z = Math.atan2(2 * (q.z * q.w - q.x * q.y), sqw + sqx - sqy - sqz);
    } else if (order === 'YXZ') {
      this._x = Math.asin(clamp(2 * (q.x * q.w - q.y * q.z)));
      this._y = Math.atan2(2 * (q.x * q.z + q.y * q.w), sqw - sqx - sqy + sqz);
      this._z = Math.atan2(2 * (q.x * q.y + q.z * q.w), sqw - sqx + sqy - sqz);
    } else if (order === 'ZXY') {
      this._x = Math.asin(clamp(2 * (q.x * q.w + q.y * q.z)));
      this._y = Math.atan2(2 * (q.y * q.w - q.z * q.x), sqw - sqx - sqy + sqz);
      this._z = Math.atan2(2 * (q.z * q.w - q.x * q.y), sqw - sqx + sqy - sqz);
    } else if (order === 'ZYX') {
      this._x = Math.atan2(2 * (q.x * q.w + q.z * q.y), sqw - sqx - sqy + sqz);
      this._y = Math.asin(clamp(2 * (q.y * q.w - q.x * q.z)));
      this._z = Math.atan2(2 * (q.x * q.y + q.z * q.w), sqw + sqx - sqy - sqz);
    } else if (order === 'YZX') {
      this._x = Math.atan2(2 * (q.x * q.w - q.z * q.y), sqw - sqx + sqy - sqz);
      this._y = Math.atan2(2 * (q.y * q.w - q.x * q.z), sqw + sqx - sqy - sqz);
      this._z = Math.asin(clamp(2 * (q.x * q.y + q.z * q.w)));
    } else if (order === 'XZY') {
      this._x = Math.atan2(2 * (q.x * q.w + q.y * q.z), sqw - sqx + sqy - sqz);
      this._y = Math.atan2(2 * (q.x * q.z + q.y * q.w), sqw + sqx - sqy - sqz);
      this._z = Math.asin(clamp(2 * (q.z * q.w - q.x * q.y)));
    } else {
      console.warn('WARNING: Euler.setFromQuaternion() given unsupported order: ' + order);
    }
    this._order = order;
    if (update !== false)
      this._updateQuaternion();
    return this;
  },
  reorder: function () {
    var q = new THREE.Quaternion();
    return function (newOrder) {
      q.setFromEuler(this);
      this.setFromQuaternion(q, newOrder);
    };
  }(),
  fromArray: function (array) {
    this._x = array[0];
    this._y = array[1];
    this._z = array[2];
    if (array[3] !== undefined)
      this._order = array[3];
    this._updateQuaternion();
    return this;
  },
  toArray: function () {
    return [
      this._x,
      this._y,
      this._z,
      this._order
    ];
  },
  equals: function (euler) {
    return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
  },
  clone: function () {
    return new THREE.Euler(this._x, this._y, this._z, this._order);
  }
};
THREE.Line3 = function (start, end) {
  this.start = start !== undefined ? start : new THREE.Vector3();
  this.end = end !== undefined ? end : new THREE.Vector3();
};
THREE.Line3.prototype = {
  constructor: THREE.Line3,
  set: function (start, end) {
    this.start.copy(start);
    this.end.copy(end);
    return this;
  },
  copy: function (line) {
    this.start.copy(line.start);
    this.end.copy(line.end);
    return this;
  },
  center: function (optionalTarget) {
    var result = optionalTarget || new THREE.Vector3();
    return result.addVectors(this.start, this.end).multiplyScalar(0.5);
  },
  delta: function (optionalTarget) {
    var result = optionalTarget || new THREE.Vector3();
    return result.subVectors(this.end, this.start);
  },
  distanceSq: function () {
    return this.start.distanceToSquared(this.end);
  },
  distance: function () {
    return this.start.distanceTo(this.end);
  },
  at: function (t, optionalTarget) {
    var result = optionalTarget || new THREE.Vector3();
    return this.delta(result).multiplyScalar(t).add(this.start);
  },
  closestPointToPointParameter: function () {
    var startP = new THREE.Vector3();
    var startEnd = new THREE.Vector3();
    return function (point, clampToLine) {
      startP.subVectors(point, this.start);
      startEnd.subVectors(this.end, this.start);
      var startEnd2 = startEnd.dot(startEnd);
      var startEnd_startP = startEnd.dot(startP);
      var t = startEnd_startP / startEnd2;
      if (clampToLine) {
        t = THREE.Math.clamp(t, 0, 1);
      }
      return t;
    };
  }(),
  closestPointToPoint: function (point, clampToLine, optionalTarget) {
    var t = this.closestPointToPointParameter(point, clampToLine);
    var result = optionalTarget || new THREE.Vector3();
    return this.delta(result).multiplyScalar(t).add(this.start);
  },
  applyMatrix4: function (matrix) {
    this.start.applyMatrix4(matrix);
    this.end.applyMatrix4(matrix);
    return this;
  },
  equals: function (line) {
    return line.start.equals(this.start) && line.end.equals(this.end);
  },
  clone: function () {
    return new THREE.Line3().copy(this);
  }
};
THREE.Box2 = function (min, max) {
  this.min = min !== undefined ? min : new THREE.Vector2(Infinity, Infinity);
  this.max = max !== undefined ? max : new THREE.Vector2(-Infinity, -Infinity);
};
THREE.Box2.prototype = {
  constructor: THREE.Box2,
  set: function (min, max) {
    this.min.copy(min);
    this.max.copy(max);
    return this;
  },
  setFromPoints: function (points) {
    if (points.length > 0) {
      var point = points[0];
      this.min.copy(point);
      this.max.copy(point);
      for (var i = 1, il = points.length; i < il; i++) {
        point = points[i];
        if (point.x < this.min.x) {
          this.min.x = point.x;
        } else if (point.x > this.max.x) {
          this.max.x = point.x;
        }
        if (point.y < this.min.y) {
          this.min.y = point.y;
        } else if (point.y > this.max.y) {
          this.max.y = point.y;
        }
      }
    } else {
      this.makeEmpty();
    }
    return this;
  },
  setFromCenterAndSize: function () {
    var v1 = new THREE.Vector2();
    return function (center, size) {
      var halfSize = v1.copy(size).multiplyScalar(0.5);
      this.min.copy(center).sub(halfSize);
      this.max.copy(center).add(halfSize);
      return this;
    };
  }(),
  copy: function (box) {
    this.min.copy(box.min);
    this.max.copy(box.max);
    return this;
  },
  makeEmpty: function () {
    this.min.x = this.min.y = Infinity;
    this.max.x = this.max.y = -Infinity;
    return this;
  },
  empty: function () {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  },
  center: function (optionalTarget) {
    var result = optionalTarget || new THREE.Vector2();
    return result.addVectors(this.min, this.max).multiplyScalar(0.5);
  },
  size: function (optionalTarget) {
    var result = optionalTarget || new THREE.Vector2();
    return result.subVectors(this.max, this.min);
  },
  expandByPoint: function (point) {
    this.min.min(point);
    this.max.max(point);
    return this;
  },
  expandByVector: function (vector) {
    this.min.sub(vector);
    this.max.add(vector);
    return this;
  },
  expandByScalar: function (scalar) {
    this.min.addScalar(-scalar);
    this.max.addScalar(scalar);
    return this;
  },
  containsPoint: function (point) {
    if (point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y) {
      return false;
    }
    return true;
  },
  containsBox: function (box) {
    if (this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y) {
      return true;
    }
    return false;
  },
  getParameter: function (point) {
    return new THREE.Vector2((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));
  },
  isIntersectionBox: function (box) {
    if (box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y) {
      return false;
    }
    return true;
  },
  clampPoint: function (point, optionalTarget) {
    var result = optionalTarget || new THREE.Vector2();
    return result.copy(point).clamp(this.min, this.max);
  },
  distanceToPoint: function () {
    var v1 = new THREE.Vector2();
    return function (point) {
      var clampedPoint = v1.copy(point).clamp(this.min, this.max);
      return clampedPoint.sub(point).length();
    };
  }(),
  intersect: function (box) {
    this.min.max(box.min);
    this.max.min(box.max);
    return this;
  },
  union: function (box) {
    this.min.min(box.min);
    this.max.max(box.max);
    return this;
  },
  translate: function (offset) {
    this.min.add(offset);
    this.max.add(offset);
    return this;
  },
  equals: function (box) {
    return box.min.equals(this.min) && box.max.equals(this.max);
  },
  clone: function () {
    return new THREE.Box2().copy(this);
  }
};
THREE.Box3 = function (min, max) {
  this.min = min !== undefined ? min : new THREE.Vector3(Infinity, Infinity, Infinity);
  this.max = max !== undefined ? max : new THREE.Vector3(-Infinity, -Infinity, -Infinity);
};
THREE.Box3.prototype = {
  constructor: THREE.Box3,
  set: function (min, max) {
    this.min.copy(min);
    this.max.copy(max);
    return this;
  },
  addPoint: function (point) {
    if (point.x < this.min.x) {
      this.min.x = point.x;
    } else if (point.x > this.max.x) {
      this.max.x = point.x;
    }
    if (point.y < this.min.y) {
      this.min.y = point.y;
    } else if (point.y > this.max.y) {
      this.max.y = point.y;
    }
    if (point.z < this.min.z) {
      this.min.z = point.z;
    } else if (point.z > this.max.z) {
      this.max.z = point.z;
    }
  },
  setFromPoints: function (points) {
    if (points.length > 0) {
      var point = points[0];
      this.min.copy(point);
      this.max.copy(point);
      for (var i = 1, il = points.length; i < il; i++) {
        this.addPoint(points[i]);
      }
    } else {
      this.makeEmpty();
    }
    return this;
  },
  setFromCenterAndSize: function () {
    var v1 = new THREE.Vector3();
    return function (center, size) {
      var halfSize = v1.copy(size).multiplyScalar(0.5);
      this.min.copy(center).sub(halfSize);
      this.max.copy(center).add(halfSize);
      return this;
    };
  }(),
  setFromObject: function () {
    var v1 = new THREE.Vector3();
    return function (object) {
      var scope = this;
      object.updateMatrixWorld(true);
      this.makeEmpty();
      object.traverse(function (node) {
        if (node.geometry !== undefined && node.geometry.vertices !== undefined) {
          var vertices = node.geometry.vertices;
          for (var i = 0, il = vertices.length; i < il; i++) {
            v1.copy(vertices[i]);
            v1.applyMatrix4(node.matrixWorld);
            scope.expandByPoint(v1);
          }
        }
      });
      return this;
    };
  }(),
  copy: function (box) {
    this.min.copy(box.min);
    this.max.copy(box.max);
    return this;
  },
  makeEmpty: function () {
    this.min.x = this.min.y = this.min.z = Infinity;
    this.max.x = this.max.y = this.max.z = -Infinity;
    return this;
  },
  empty: function () {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  },
  center: function (optionalTarget) {
    var result = optionalTarget || new THREE.Vector3();
    return result.addVectors(this.min, this.max).multiplyScalar(0.5);
  },
  size: function (optionalTarget) {
    var result = optionalTarget || new THREE.Vector3();
    return result.subVectors(this.max, this.min);
  },
  expandByPoint: function (point) {
    this.min.min(point);
    this.max.max(point);
    return this;
  },
  expandByVector: function (vector) {
    this.min.sub(vector);
    this.max.add(vector);
    return this;
  },
  expandByScalar: function (scalar) {
    this.min.addScalar(-scalar);
    this.max.addScalar(scalar);
    return this;
  },
  containsPoint: function (point) {
    if (point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z) {
      return false;
    }
    return true;
  },
  containsBox: function (box) {
    if (this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z) {
      return true;
    }
    return false;
  },
  getParameter: function (point) {
    return new THREE.Vector3((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
  },
  isIntersectionBox: function (box) {
    if (box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z) {
      return false;
    }
    return true;
  },
  clampPoint: function (point, optionalTarget) {
    var result = optionalTarget || new THREE.Vector3();
    return result.copy(point).clamp(this.min, this.max);
  },
  distanceToPoint: function () {
    var v1 = new THREE.Vector3();
    return function (point) {
      var clampedPoint = v1.copy(point).clamp(this.min, this.max);
      return clampedPoint.sub(point).length();
    };
  }(),
  getBoundingSphere: function () {
    var v1 = new THREE.Vector3();
    return function (optionalTarget) {
      var result = optionalTarget || new THREE.Sphere();
      result.center = this.center();
      result.radius = this.size(v1).length() * 0.5;
      return result;
    };
  }(),
  intersect: function (box) {
    this.min.max(box.min);
    this.max.min(box.max);
    return this;
  },
  union: function (box) {
    this.min.min(box.min);
    this.max.max(box.max);
    return this;
  },
  applyMatrix4: function () {
    var points = [
        new THREE.Vector3(),
        new THREE.Vector3(),
        new THREE.Vector3(),
        new THREE.Vector3(),
        new THREE.Vector3(),
        new THREE.Vector3(),
        new THREE.Vector3(),
        new THREE.Vector3()
      ];
    return function (matrix) {
      points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);
      points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);
      points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);
      points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);
      points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);
      points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);
      points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);
      points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);
      this.makeEmpty();
      this.setFromPoints(points);
      return this;
    };
  }(),
  translate: function (offset) {
    this.min.add(offset);
    this.max.add(offset);
    return this;
  },
  equals: function (box) {
    return box.min.equals(this.min) && box.max.equals(this.max);
  },
  clone: function () {
    return new THREE.Box3().copy(this);
  }
};
THREE.Matrix3 = function (n11, n12, n13, n21, n22, n23, n31, n32, n33) {
  this.elements = new Float32Array(9);
  this.set(n11 !== undefined ? n11 : 1, n12 || 0, n13 || 0, n21 || 0, n22 !== undefined ? n22 : 1, n23 || 0, n31 || 0, n32 || 0, n33 !== undefined ? n33 : 1);
};
THREE.Matrix3.prototype = {
  constructor: THREE.Matrix3,
  set: function (n11, n12, n13, n21, n22, n23, n31, n32, n33) {
    var te = this.elements;
    te[0] = n11;
    te[3] = n12;
    te[6] = n13;
    te[1] = n21;
    te[4] = n22;
    te[7] = n23;
    te[2] = n31;
    te[5] = n32;
    te[8] = n33;
    return this;
  },
  identity: function () {
    this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
    return this;
  },
  copy: function (m) {
    var me = m.elements;
    this.set(me[0], me[3], me[6], me[1], me[4], me[7], me[2], me[5], me[8]);
    return this;
  },
  multiplyVector3: function (vector) {
    console.warn('DEPRECATED: Matrix3\'s .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.');
    return vector.applyMatrix3(this);
  },
  multiplyVector3Array: function () {
    var v1 = new THREE.Vector3();
    return function (a) {
      for (var i = 0, il = a.length; i < il; i += 3) {
        v1.x = a[i];
        v1.y = a[i + 1];
        v1.z = a[i + 2];
        v1.applyMatrix3(this);
        a[i] = v1.x;
        a[i + 1] = v1.y;
        a[i + 2] = v1.z;
      }
      return a;
    };
  }(),
  multiplyScalar: function (s) {
    var te = this.elements;
    te[0] *= s;
    te[3] *= s;
    te[6] *= s;
    te[1] *= s;
    te[4] *= s;
    te[7] *= s;
    te[2] *= s;
    te[5] *= s;
    te[8] *= s;
    return this;
  },
  determinant: function () {
    var te = this.elements;
    var a = te[0], b = te[1], c = te[2], d = te[3], e = te[4], f = te[5], g = te[6], h = te[7], i = te[8];
    return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
  },
  getInverse: function (matrix, throwOnInvertible) {
    var me = matrix.elements;
    var te = this.elements;
    te[0] = me[10] * me[5] - me[6] * me[9];
    te[1] = -me[10] * me[1] + me[2] * me[9];
    te[2] = me[6] * me[1] - me[2] * me[5];
    te[3] = -me[10] * me[4] + me[6] * me[8];
    te[4] = me[10] * me[0] - me[2] * me[8];
    te[5] = -me[6] * me[0] + me[2] * me[4];
    te[6] = me[9] * me[4] - me[5] * me[8];
    te[7] = -me[9] * me[0] + me[1] * me[8];
    te[8] = me[5] * me[0] - me[1] * me[4];
    var det = me[0] * te[0] + me[1] * te[3] + me[2] * te[6];
    if (det === 0) {
      var msg = 'Matrix3.getInverse(): can\'t invert matrix, determinant is 0';
      if (throwOnInvertible || false) {
        throw new Error(msg);
      } else {
        console.warn(msg);
      }
      this.identity();
      return this;
    }
    this.multiplyScalar(1 / det);
    return this;
  },
  transpose: function () {
    var tmp, m = this.elements;
    tmp = m[1];
    m[1] = m[3];
    m[3] = tmp;
    tmp = m[2];
    m[2] = m[6];
    m[6] = tmp;
    tmp = m[5];
    m[5] = m[7];
    m[7] = tmp;
    return this;
  },
  getNormalMatrix: function (m) {
    this.getInverse(m).transpose();
    return this;
  },
  transposeIntoArray: function (r) {
    var m = this.elements;
    r[0] = m[0];
    r[1] = m[3];
    r[2] = m[6];
    r[3] = m[1];
    r[4] = m[4];
    r[5] = m[7];
    r[6] = m[2];
    r[7] = m[5];
    r[8] = m[8];
    return this;
  },
  clone: function () {
    var te = this.elements;
    return new THREE.Matrix3(te[0], te[3], te[6], te[1], te[4], te[7], te[2], te[5], te[8]);
  }
};
THREE.Matrix4 = function (n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
  this.elements = new Float32Array(16);
  var te = this.elements;
  te[0] = n11 !== undefined ? n11 : 1;
  te[4] = n12 || 0;
  te[8] = n13 || 0;
  te[12] = n14 || 0;
  te[1] = n21 || 0;
  te[5] = n22 !== undefined ? n22 : 1;
  te[9] = n23 || 0;
  te[13] = n24 || 0;
  te[2] = n31 || 0;
  te[6] = n32 || 0;
  te[10] = n33 !== undefined ? n33 : 1;
  te[14] = n34 || 0;
  te[3] = n41 || 0;
  te[7] = n42 || 0;
  te[11] = n43 || 0;
  te[15] = n44 !== undefined ? n44 : 1;
};
THREE.Matrix4.prototype = {
  constructor: THREE.Matrix4,
  set: function (n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
    var te = this.elements;
    te[0] = n11;
    te[4] = n12;
    te[8] = n13;
    te[12] = n14;
    te[1] = n21;
    te[5] = n22;
    te[9] = n23;
    te[13] = n24;
    te[2] = n31;
    te[6] = n32;
    te[10] = n33;
    te[14] = n34;
    te[3] = n41;
    te[7] = n42;
    te[11] = n43;
    te[15] = n44;
    return this;
  },
  identity: function () {
    this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    return this;
  },
  copy: function (m) {
    this.elements.set(m.elements);
    return this;
  },
  extractPosition: function (m) {
    console.warn('DEPRECATED: Matrix4\'s .extractPosition() has been renamed to .copyPosition().');
    return this.copyPosition(m);
  },
  copyPosition: function (m) {
    var te = this.elements;
    var me = m.elements;
    te[12] = me[12];
    te[13] = me[13];
    te[14] = me[14];
    return this;
  },
  extractRotation: function () {
    var v1 = new THREE.Vector3();
    return function (m) {
      var te = this.elements;
      var me = m.elements;
      var scaleX = 1 / v1.set(me[0], me[1], me[2]).length();
      var scaleY = 1 / v1.set(me[4], me[5], me[6]).length();
      var scaleZ = 1 / v1.set(me[8], me[9], me[10]).length();
      te[0] = me[0] * scaleX;
      te[1] = me[1] * scaleX;
      te[2] = me[2] * scaleX;
      te[4] = me[4] * scaleY;
      te[5] = me[5] * scaleY;
      te[6] = me[6] * scaleY;
      te[8] = me[8] * scaleZ;
      te[9] = me[9] * scaleZ;
      te[10] = me[10] * scaleZ;
      return this;
    };
  }(),
  makeRotationFromEuler: function (euler) {
    if (euler instanceof THREE.Euler === false) {
      console.error('ERROR: Matrix\'s .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.  Please update your code.');
    }
    var te = this.elements;
    var x = euler.x, y = euler.y, z = euler.z;
    var a = Math.cos(x), b = Math.sin(x);
    var c = Math.cos(y), d = Math.sin(y);
    var e = Math.cos(z), f = Math.sin(z);
    if (euler.order === 'XYZ') {
      var ae = a * e, af = a * f, be = b * e, bf = b * f;
      te[0] = c * e;
      te[4] = -c * f;
      te[8] = d;
      te[1] = af + be * d;
      te[5] = ae - bf * d;
      te[9] = -b * c;
      te[2] = bf - ae * d;
      te[6] = be + af * d;
      te[10] = a * c;
    } else if (euler.order === 'YXZ') {
      var ce = c * e, cf = c * f, de = d * e, df = d * f;
      te[0] = ce + df * b;
      te[4] = de * b - cf;
      te[8] = a * d;
      te[1] = a * f;
      te[5] = a * e;
      te[9] = -b;
      te[2] = cf * b - de;
      te[6] = df + ce * b;
      te[10] = a * c;
    } else if (euler.order === 'ZXY') {
      var ce = c * e, cf = c * f, de = d * e, df = d * f;
      te[0] = ce - df * b;
      te[4] = -a * f;
      te[8] = de + cf * b;
      te[1] = cf + de * b;
      te[5] = a * e;
      te[9] = df - ce * b;
      te[2] = -a * d;
      te[6] = b;
      te[10] = a * c;
    } else if (euler.order === 'ZYX') {
      var ae = a * e, af = a * f, be = b * e, bf = b * f;
      te[0] = c * e;
      te[4] = be * d - af;
      te[8] = ae * d + bf;
      te[1] = c * f;
      te[5] = bf * d + ae;
      te[9] = af * d - be;
      te[2] = -d;
      te[6] = b * c;
      te[10] = a * c;
    } else if (euler.order === 'YZX') {
      var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
      te[0] = c * e;
      te[4] = bd - ac * f;
      te[8] = bc * f + ad;
      te[1] = f;
      te[5] = a * e;
      te[9] = -b * e;
      te[2] = -d * e;
      te[6] = ad * f + bc;
      te[10] = ac - bd * f;
    } else if (euler.order === 'XZY') {
      var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
      te[0] = c * e;
      te[4] = -f;
      te[8] = d * e;
      te[1] = ac * f + bd;
      te[5] = a * e;
      te[9] = ad * f - bc;
      te[2] = bc * f - ad;
      te[6] = b * e;
      te[10] = bd * f + ac;
    }
    te[3] = 0;
    te[7] = 0;
    te[11] = 0;
    te[12] = 0;
    te[13] = 0;
    te[14] = 0;
    te[15] = 1;
    return this;
  },
  setRotationFromQuaternion: function (q) {
    console.warn('DEPRECATED: Matrix4\'s .setRotationFromQuaternion() has been deprecated in favor of makeRotationFromQuaternion.  Please update your code.');
    return this.makeRotationFromQuaternion(q);
  },
  makeRotationFromQuaternion: function (q) {
    var te = this.elements;
    var x = q.x, y = q.y, z = q.z, w = q.w;
    var x2 = x + x, y2 = y + y, z2 = z + z;
    var xx = x * x2, xy = x * y2, xz = x * z2;
    var yy = y * y2, yz = y * z2, zz = z * z2;
    var wx = w * x2, wy = w * y2, wz = w * z2;
    te[0] = 1 - (yy + zz);
    te[4] = xy - wz;
    te[8] = xz + wy;
    te[1] = xy + wz;
    te[5] = 1 - (xx + zz);
    te[9] = yz - wx;
    te[2] = xz - wy;
    te[6] = yz + wx;
    te[10] = 1 - (xx + yy);
    te[3] = 0;
    te[7] = 0;
    te[11] = 0;
    te[12] = 0;
    te[13] = 0;
    te[14] = 0;
    te[15] = 1;
    return this;
  },
  lookAt: function () {
    var x = new THREE.Vector3();
    var y = new THREE.Vector3();
    var z = new THREE.Vector3();
    return function (eye, target, up) {
      var te = this.elements;
      z.subVectors(eye, target).normalize();
      if (z.length() === 0) {
        z.z = 1;
      }
      x.crossVectors(up, z).normalize();
      if (x.length() === 0) {
        z.x += 0.0001;
        x.crossVectors(up, z).normalize();
      }
      y.crossVectors(z, x);
      te[0] = x.x;
      te[4] = y.x;
      te[8] = z.x;
      te[1] = x.y;
      te[5] = y.y;
      te[9] = z.y;
      te[2] = x.z;
      te[6] = y.z;
      te[10] = z.z;
      return this;
    };
  }(),
  multiply: function (m, n) {
    if (n !== undefined) {
      console.warn('DEPRECATED: Matrix4\'s .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.');
      return this.multiplyMatrices(m, n);
    }
    return this.multiplyMatrices(this, m);
  },
  multiplyMatrices: function (a, b) {
    var ae = a.elements;
    var be = b.elements;
    var te = this.elements;
    var a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
    var a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
    var a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
    var a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];
    var b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
    var b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
    var b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
    var b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
    te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
    te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
    te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
    te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
    te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
    te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
    te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
    te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
    te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
    te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
    te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
    te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
    te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
    te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
    te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
    te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
    return this;
  },
  multiplyToArray: function (a, b, r) {
    var te = this.elements;
    this.multiplyMatrices(a, b);
    r[0] = te[0];
    r[1] = te[1];
    r[2] = te[2];
    r[3] = te[3];
    r[4] = te[4];
    r[5] = te[5];
    r[6] = te[6];
    r[7] = te[7];
    r[8] = te[8];
    r[9] = te[9];
    r[10] = te[10];
    r[11] = te[11];
    r[12] = te[12];
    r[13] = te[13];
    r[14] = te[14];
    r[15] = te[15];
    return this;
  },
  multiplyScalar: function (s) {
    var te = this.elements;
    te[0] *= s;
    te[4] *= s;
    te[8] *= s;
    te[12] *= s;
    te[1] *= s;
    te[5] *= s;
    te[9] *= s;
    te[13] *= s;
    te[2] *= s;
    te[6] *= s;
    te[10] *= s;
    te[14] *= s;
    te[3] *= s;
    te[7] *= s;
    te[11] *= s;
    te[15] *= s;
    return this;
  },
  multiplyVector3: function (vector) {
    console.warn('DEPRECATED: Matrix4\'s .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.');
    return vector.applyProjection(this);
  },
  multiplyVector4: function (vector) {
    console.warn('DEPRECATED: Matrix4\'s .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.');
    return vector.applyMatrix4(this);
  },
  multiplyVector3Array: function () {
    var v1 = new THREE.Vector3();
    return function (a) {
      for (var i = 0, il = a.length; i < il; i += 3) {
        v1.x = a[i];
        v1.y = a[i + 1];
        v1.z = a[i + 2];
        v1.applyProjection(this);
        a[i] = v1.x;
        a[i + 1] = v1.y;
        a[i + 2] = v1.z;
      }
      return a;
    };
  }(),
  rotateAxis: function (v) {
    console.warn('DEPRECATED: Matrix4\'s .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.');
    v.transformDirection(this);
  },
  crossVector: function (vector) {
    console.warn('DEPRECATED: Matrix4\'s .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.');
    return vector.applyMatrix4(this);
  },
  determinant: function () {
    var te = this.elements;
    var n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
    var n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
    var n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
    var n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];
    return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
  },
  transpose: function () {
    var te = this.elements;
    var tmp;
    tmp = te[1];
    te[1] = te[4];
    te[4] = tmp;
    tmp = te[2];
    te[2] = te[8];
    te[8] = tmp;
    tmp = te[6];
    te[6] = te[9];
    te[9] = tmp;
    tmp = te[3];
    te[3] = te[12];
    te[12] = tmp;
    tmp = te[7];
    te[7] = te[13];
    te[13] = tmp;
    tmp = te[11];
    te[11] = te[14];
    te[14] = tmp;
    return this;
  },
  flattenToArray: function (flat) {
    var te = this.elements;
    flat[0] = te[0];
    flat[1] = te[1];
    flat[2] = te[2];
    flat[3] = te[3];
    flat[4] = te[4];
    flat[5] = te[5];
    flat[6] = te[6];
    flat[7] = te[7];
    flat[8] = te[8];
    flat[9] = te[9];
    flat[10] = te[10];
    flat[11] = te[11];
    flat[12] = te[12];
    flat[13] = te[13];
    flat[14] = te[14];
    flat[15] = te[15];
    return flat;
  },
  flattenToArrayOffset: function (flat, offset) {
    var te = this.elements;
    flat[offset] = te[0];
    flat[offset + 1] = te[1];
    flat[offset + 2] = te[2];
    flat[offset + 3] = te[3];
    flat[offset + 4] = te[4];
    flat[offset + 5] = te[5];
    flat[offset + 6] = te[6];
    flat[offset + 7] = te[7];
    flat[offset + 8] = te[8];
    flat[offset + 9] = te[9];
    flat[offset + 10] = te[10];
    flat[offset + 11] = te[11];
    flat[offset + 12] = te[12];
    flat[offset + 13] = te[13];
    flat[offset + 14] = te[14];
    flat[offset + 15] = te[15];
    return flat;
  },
  getPosition: function () {
    var v1 = new THREE.Vector3();
    return function () {
      console.warn('DEPRECATED: Matrix4\'s .getPosition() has been removed. Use Vector3.getPositionFromMatrix( matrix ) instead.');
      var te = this.elements;
      return v1.set(te[12], te[13], te[14]);
    };
  }(),
  setPosition: function (v) {
    var te = this.elements;
    te[12] = v.x;
    te[13] = v.y;
    te[14] = v.z;
    return this;
  },
  getInverse: function (m, throwOnInvertible) {
    var te = this.elements;
    var me = m.elements;
    var n11 = me[0], n12 = me[4], n13 = me[8], n14 = me[12];
    var n21 = me[1], n22 = me[5], n23 = me[9], n24 = me[13];
    var n31 = me[2], n32 = me[6], n33 = me[10], n34 = me[14];
    var n41 = me[3], n42 = me[7], n43 = me[11], n44 = me[15];
    te[0] = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44;
    te[4] = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44;
    te[8] = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44;
    te[12] = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
    te[1] = n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44;
    te[5] = n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44;
    te[9] = n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44;
    te[13] = n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34;
    te[2] = n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44;
    te[6] = n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44;
    te[10] = n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44;
    te[14] = n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34;
    te[3] = n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43;
    te[7] = n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43;
    te[11] = n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43;
    te[15] = n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33;
    var det = n11 * te[0] + n21 * te[4] + n31 * te[8] + n41 * te[12];
    if (det == 0) {
      var msg = 'Matrix4.getInverse(): can\'t invert matrix, determinant is 0';
      if (throwOnInvertible || false) {
        throw new Error(msg);
      } else {
        console.warn(msg);
      }
      this.identity();
      return this;
    }
    this.multiplyScalar(1 / det);
    return this;
  },
  translate: function (v) {
    console.warn('DEPRECATED: Matrix4\'s .translate() has been removed.');
  },
  rotateX: function (angle) {
    console.warn('DEPRECATED: Matrix4\'s .rotateX() has been removed.');
  },
  rotateY: function (angle) {
    console.warn('DEPRECATED: Matrix4\'s .rotateY() has been removed.');
  },
  rotateZ: function (angle) {
    console.warn('DEPRECATED: Matrix4\'s .rotateZ() has been removed.');
  },
  rotateByAxis: function (axis, angle) {
    console.warn('DEPRECATED: Matrix4\'s .rotateByAxis() has been removed.');
  },
  scale: function (v) {
    var te = this.elements;
    var x = v.x, y = v.y, z = v.z;
    te[0] *= x;
    te[4] *= y;
    te[8] *= z;
    te[1] *= x;
    te[5] *= y;
    te[9] *= z;
    te[2] *= x;
    te[6] *= y;
    te[10] *= z;
    te[3] *= x;
    te[7] *= y;
    te[11] *= z;
    return this;
  },
  getMaxScaleOnAxis: function () {
    var te = this.elements;
    var scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
    var scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
    var scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
    return Math.sqrt(Math.max(scaleXSq, Math.max(scaleYSq, scaleZSq)));
  },
  makeTranslation: function (x, y, z) {
    this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
    return this;
  },
  makeRotationX: function (theta) {
    var c = Math.cos(theta), s = Math.sin(theta);
    this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
    return this;
  },
  makeRotationY: function (theta) {
    var c = Math.cos(theta), s = Math.sin(theta);
    this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
    return this;
  },
  makeRotationZ: function (theta) {
    var c = Math.cos(theta), s = Math.sin(theta);
    this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    return this;
  },
  makeRotationAxis: function (axis, angle) {
    var c = Math.cos(angle);
    var s = Math.sin(angle);
    var t = 1 - c;
    var x = axis.x, y = axis.y, z = axis.z;
    var tx = t * x, ty = t * y;
    this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);
    return this;
  },
  makeScale: function (x, y, z) {
    this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
    return this;
  },
  compose: function (position, quaternion, scale) {
    this.makeRotationFromQuaternion(quaternion);
    this.scale(scale);
    this.setPosition(position);
    return this;
  },
  decompose: function () {
    var vector = new THREE.Vector3();
    var matrix = new THREE.Matrix4();
    return function (position, quaternion, scale) {
      var te = this.elements;
      var sx = vector.set(te[0], te[1], te[2]).length();
      var sy = vector.set(te[4], te[5], te[6]).length();
      var sz = vector.set(te[8], te[9], te[10]).length();
      position.x = te[12];
      position.y = te[13];
      position.z = te[14];
      matrix.elements.set(this.elements);
      var invSX = 1 / sx;
      var invSY = 1 / sy;
      var invSZ = 1 / sz;
      matrix.elements[0] *= invSX;
      matrix.elements[1] *= invSX;
      matrix.elements[2] *= invSX;
      matrix.elements[4] *= invSY;
      matrix.elements[5] *= invSY;
      matrix.elements[6] *= invSY;
      matrix.elements[8] *= invSZ;
      matrix.elements[9] *= invSZ;
      matrix.elements[10] *= invSZ;
      quaternion.setFromRotationMatrix(matrix);
      scale.x = sx;
      scale.y = sy;
      scale.z = sz;
      return this;
    };
  }(),
  makeFrustum: function (left, right, bottom, top, near, far) {
    var te = this.elements;
    var x = 2 * near / (right - left);
    var y = 2 * near / (top - bottom);
    var a = (right + left) / (right - left);
    var b = (top + bottom) / (top - bottom);
    var c = -(far + near) / (far - near);
    var d = -2 * far * near / (far - near);
    te[0] = x;
    te[4] = 0;
    te[8] = a;
    te[12] = 0;
    te[1] = 0;
    te[5] = y;
    te[9] = b;
    te[13] = 0;
    te[2] = 0;
    te[6] = 0;
    te[10] = c;
    te[14] = d;
    te[3] = 0;
    te[7] = 0;
    te[11] = -1;
    te[15] = 0;
    return this;
  },
  makePerspective: function (fov, aspect, near, far) {
    var ymax = near * Math.tan(THREE.Math.degToRad(fov * 0.5));
    var ymin = -ymax;
    var xmin = ymin * aspect;
    var xmax = ymax * aspect;
    return this.makeFrustum(xmin, xmax, ymin, ymax, near, far);
  },
  makeOrthographic: function (left, right, top, bottom, near, far) {
    var te = this.elements;
    var w = right - left;
    var h = top - bottom;
    var p = far - near;
    var x = (right + left) / w;
    var y = (top + bottom) / h;
    var z = (far + near) / p;
    te[0] = 2 / w;
    te[4] = 0;
    te[8] = 0;
    te[12] = -x;
    te[1] = 0;
    te[5] = 2 / h;
    te[9] = 0;
    te[13] = -y;
    te[2] = 0;
    te[6] = 0;
    te[10] = -2 / p;
    te[14] = -z;
    te[3] = 0;
    te[7] = 0;
    te[11] = 0;
    te[15] = 1;
    return this;
  },
  fromArray: function (array) {
    this.elements.set(array);
    return this;
  },
  toArray: function () {
    var te = this.elements;
    return [
      te[0],
      te[1],
      te[2],
      te[3],
      te[4],
      te[5],
      te[6],
      te[7],
      te[8],
      te[9],
      te[10],
      te[11],
      te[12],
      te[13],
      te[14],
      te[15]
    ];
  },
  clone: function () {
    var te = this.elements;
    return new THREE.Matrix4(te[0], te[4], te[8], te[12], te[1], te[5], te[9], te[13], te[2], te[6], te[10], te[14], te[3], te[7], te[11], te[15]);
  }
};
THREE.Ray = function (origin, direction) {
  this.origin = origin !== undefined ? origin : new THREE.Vector3();
  this.direction = direction !== undefined ? direction : new THREE.Vector3();
};
THREE.Ray.prototype = {
  constructor: THREE.Ray,
  set: function (origin, direction) {
    this.origin.copy(origin);
    this.direction.copy(direction);
    return this;
  },
  copy: function (ray) {
    this.origin.copy(ray.origin);
    this.direction.copy(ray.direction);
    return this;
  },
  at: function (t, optionalTarget) {
    var result = optionalTarget || new THREE.Vector3();
    return result.copy(this.direction).multiplyScalar(t).add(this.origin);
  },
  recast: function () {
    var v1 = new THREE.Vector3();
    return function (t) {
      this.origin.copy(this.at(t, v1));
      return this;
    };
  }(),
  closestPointToPoint: function (point, optionalTarget) {
    var result = optionalTarget || new THREE.Vector3();
    result.subVectors(point, this.origin);
    var directionDistance = result.dot(this.direction);
    if (directionDistance < 0) {
      return result.copy(this.origin);
    }
    return result.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
  },
  distanceToPoint: function () {
    var v1 = new THREE.Vector3();
    return function (point) {
      var directionDistance = v1.subVectors(point, this.origin).dot(this.direction);
      if (directionDistance < 0) {
        return this.origin.distanceTo(point);
      }
      v1.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
      return v1.distanceTo(point);
    };
  }(),
  distanceSqToSegment: function (v0, v1, optionalPointOnRay, optionalPointOnSegment) {
    var segCenter = v0.clone().add(v1).multiplyScalar(0.5);
    var segDir = v1.clone().sub(v0).normalize();
    var segExtent = v0.distanceTo(v1) * 0.5;
    var diff = this.origin.clone().sub(segCenter);
    var a01 = -this.direction.dot(segDir);
    var b0 = diff.dot(this.direction);
    var b1 = -diff.dot(segDir);
    var c = diff.lengthSq();
    var det = Math.abs(1 - a01 * a01);
    var s0, s1, sqrDist, extDet;
    if (det >= 0) {
      s0 = a01 * b1 - b0;
      s1 = a01 * b0 - b1;
      extDet = segExtent * det;
      if (s0 >= 0) {
        if (s1 >= -extDet) {
          if (s1 <= extDet) {
            var invDet = 1 / det;
            s0 *= invDet;
            s1 *= invDet;
            sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
          } else {
            s1 = segExtent;
            s0 = Math.max(0, -(a01 * s1 + b0));
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
          }
        } else {
          s1 = -segExtent;
          s0 = Math.max(0, -(a01 * s1 + b0));
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
        }
      } else {
        if (s1 <= -extDet) {
          s0 = Math.max(0, -(-a01 * segExtent + b0));
          s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
        } else if (s1 <= extDet) {
          s0 = 0;
          s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = s1 * (s1 + 2 * b1) + c;
        } else {
          s0 = Math.max(0, -(a01 * segExtent + b0));
          s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
        }
      }
    } else {
      s1 = a01 > 0 ? -segExtent : segExtent;
      s0 = Math.max(0, -(a01 * s1 + b0));
      sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
    }
    if (optionalPointOnRay) {
      optionalPointOnRay.copy(this.direction.clone().multiplyScalar(s0).add(this.origin));
    }
    if (optionalPointOnSegment) {
      optionalPointOnSegment.copy(segDir.clone().multiplyScalar(s1).add(segCenter));
    }
    return sqrDist;
  },
  isIntersectionSphere: function (sphere) {
    return this.distanceToPoint(sphere.center) <= sphere.radius;
  },
  isIntersectionPlane: function (plane) {
    var distToPoint = plane.distanceToPoint(this.origin);
    if (distToPoint === 0) {
      return true;
    }
    var denominator = plane.normal.dot(this.direction);
    if (denominator * distToPoint < 0) {
      return true;
    }
    return false;
  },
  distanceToPlane: function (plane) {
    var denominator = plane.normal.dot(this.direction);
    if (denominator == 0) {
      if (plane.distanceToPoint(this.origin) == 0) {
        return 0;
      }
      return null;
    }
    var t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
    return t >= 0 ? t : null;
  },
  intersectPlane: function (plane, optionalTarget) {
    var t = this.distanceToPlane(plane);
    if (t === null) {
      return null;
    }
    return this.at(t, optionalTarget);
  },
  isIntersectionBox: function () {
    var v = new THREE.Vector3();
    return function (box) {
      return this.intersectBox(box, v) !== null;
    };
  }(),
  intersectBox: function (box, optionalTarget) {
    var tmin, tmax, tymin, tymax, tzmin, tzmax;
    var invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;
    var origin = this.origin;
    if (invdirx >= 0) {
      tmin = (box.min.x - origin.x) * invdirx;
      tmax = (box.max.x - origin.x) * invdirx;
    } else {
      tmin = (box.max.x - origin.x) * invdirx;
      tmax = (box.min.x - origin.x) * invdirx;
    }
    if (invdiry >= 0) {
      tymin = (box.min.y - origin.y) * invdiry;
      tymax = (box.max.y - origin.y) * invdiry;
    } else {
      tymin = (box.max.y - origin.y) * invdiry;
      tymax = (box.min.y - origin.y) * invdiry;
    }
    if (tmin > tymax || tymin > tmax)
      return null;
    if (tymin > tmin || tmin !== tmin)
      tmin = tymin;
    if (tymax < tmax || tmax !== tmax)
      tmax = tymax;
    if (invdirz >= 0) {
      tzmin = (box.min.z - origin.z) * invdirz;
      tzmax = (box.max.z - origin.z) * invdirz;
    } else {
      tzmin = (box.max.z - origin.z) * invdirz;
      tzmax = (box.min.z - origin.z) * invdirz;
    }
    if (tmin > tzmax || tzmin > tmax)
      return null;
    if (tzmin > tmin || tmin !== tmin)
      tmin = tzmin;
    if (tzmax < tmax || tmax !== tmax)
      tmax = tzmax;
    if (tmax < 0)
      return null;
    return this.at(tmin >= 0 ? tmin : tmax, optionalTarget);
  },
  intersectTriangle: function () {
    var diff = new THREE.Vector3();
    var edge1 = new THREE.Vector3();
    var edge2 = new THREE.Vector3();
    var normal = new THREE.Vector3();
    return function (a, b, c, backfaceCulling, optionalTarget) {
      edge1.subVectors(b, a);
      edge2.subVectors(c, a);
      normal.crossVectors(edge1, edge2);
      var DdN = this.direction.dot(normal);
      var sign;
      if (DdN > 0) {
        if (backfaceCulling)
          return null;
        sign = 1;
      } else if (DdN < 0) {
        sign = -1;
        DdN = -DdN;
      } else {
        return null;
      }
      diff.subVectors(this.origin, a);
      var DdQxE2 = sign * this.direction.dot(edge2.crossVectors(diff, edge2));
      if (DdQxE2 < 0) {
        return null;
      }
      var DdE1xQ = sign * this.direction.dot(edge1.cross(diff));
      if (DdE1xQ < 0) {
        return null;
      }
      if (DdQxE2 + DdE1xQ > DdN) {
        return null;
      }
      var QdN = -sign * diff.dot(normal);
      if (QdN < 0) {
        return null;
      }
      return this.at(QdN / DdN, optionalTarget);
    };
  }(),
  applyMatrix4: function (matrix4) {
    this.direction.add(this.origin).applyMatrix4(matrix4);
    this.origin.applyMatrix4(matrix4);
    this.direction.sub(this.origin);
    this.direction.normalize();
    return this;
  },
  equals: function (ray) {
    return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
  },
  clone: function () {
    return new THREE.Ray().copy(this);
  }
};
THREE.Sphere = function (center, radius) {
  this.center = center !== undefined ? center : new THREE.Vector3();
  this.radius = radius !== undefined ? radius : 0;
};
THREE.Sphere.prototype = {
  constructor: THREE.Sphere,
  set: function (center, radius) {
    this.center.copy(center);
    this.radius = radius;
    return this;
  },
  setFromPoints: function () {
    var box = new THREE.Box3();
    return function (points, optionalCenter) {
      var center = this.center;
      if (optionalCenter !== undefined) {
        center.copy(optionalCenter);
      } else {
        box.setFromPoints(points).center(center);
      }
      var maxRadiusSq = 0;
      for (var i = 0, il = points.length; i < il; i++) {
        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
      }
      this.radius = Math.sqrt(maxRadiusSq);
      return this;
    };
  }(),
  copy: function (sphere) {
    this.center.copy(sphere.center);
    this.radius = sphere.radius;
    return this;
  },
  empty: function () {
    return this.radius <= 0;
  },
  containsPoint: function (point) {
    return point.distanceToSquared(this.center) <= this.radius * this.radius;
  },
  distanceToPoint: function (point) {
    return point.distanceTo(this.center) - this.radius;
  },
  intersectsSphere: function (sphere) {
    var radiusSum = this.radius + sphere.radius;
    return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
  },
  clampPoint: function (point, optionalTarget) {
    var deltaLengthSq = this.center.distanceToSquared(point);
    var result = optionalTarget || new THREE.Vector3();
    result.copy(point);
    if (deltaLengthSq > this.radius * this.radius) {
      result.sub(this.center).normalize();
      result.multiplyScalar(this.radius).add(this.center);
    }
    return result;
  },
  getBoundingBox: function (optionalTarget) {
    var box = optionalTarget || new THREE.Box3();
    box.set(this.center, this.center);
    box.expandByScalar(this.radius);
    return box;
  },
  applyMatrix4: function (matrix) {
    this.center.applyMatrix4(matrix);
    this.radius = this.radius * matrix.getMaxScaleOnAxis();
    return this;
  },
  translate: function (offset) {
    this.center.add(offset);
    return this;
  },
  equals: function (sphere) {
    return sphere.center.equals(this.center) && sphere.radius === this.radius;
  },
  clone: function () {
    return new THREE.Sphere().copy(this);
  }
};
THREE.Frustum = function (p0, p1, p2, p3, p4, p5) {
  this.planes = [
    p0 !== undefined ? p0 : new THREE.Plane(),
    p1 !== undefined ? p1 : new THREE.Plane(),
    p2 !== undefined ? p2 : new THREE.Plane(),
    p3 !== undefined ? p3 : new THREE.Plane(),
    p4 !== undefined ? p4 : new THREE.Plane(),
    p5 !== undefined ? p5 : new THREE.Plane()
  ];
};
THREE.Frustum.prototype = {
  constructor: THREE.Frustum,
  set: function (p0, p1, p2, p3, p4, p5) {
    var planes = this.planes;
    planes[0].copy(p0);
    planes[1].copy(p1);
    planes[2].copy(p2);
    planes[3].copy(p3);
    planes[4].copy(p4);
    planes[5].copy(p5);
    return this;
  },
  copy: function (frustum) {
    var planes = this.planes;
    for (var i = 0; i < 6; i++) {
      planes[i].copy(frustum.planes[i]);
    }
    return this;
  },
  setFromMatrix: function (m) {
    var planes = this.planes;
    var me = m.elements;
    var me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];
    var me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];
    var me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];
    var me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];
    planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
    planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
    planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
    planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
    planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
    planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
    return this;
  },
  intersectsObject: function () {
    var sphere = new THREE.Sphere();
    return function (object) {
      var geometry = object.geometry;
      if (geometry.boundingSphere === null)
        geometry.computeBoundingSphere();
      sphere.copy(geometry.boundingSphere);
      sphere.applyMatrix4(object.matrixWorld);
      return this.intersectsSphere(sphere);
    };
  }(),
  intersectsSphere: function (sphere) {
    var planes = this.planes;
    var center = sphere.center;
    var negRadius = -sphere.radius;
    for (var i = 0; i < 6; i++) {
      var distance = planes[i].distanceToPoint(center);
      if (distance < negRadius) {
        return false;
      }
    }
    return true;
  },
  intersectsBox: function () {
    var p1 = new THREE.Vector3(), p2 = new THREE.Vector3();
    return function (box) {
      var planes = this.planes;
      for (var i = 0; i < 6; i++) {
        var plane = planes[i];
        p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
        p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
        p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
        p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
        p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
        p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;
        var d1 = plane.distanceToPoint(p1);
        var d2 = plane.distanceToPoint(p2);
        if (d1 < 0 && d2 < 0) {
          return false;
        }
      }
      return true;
    };
  }(),
  containsPoint: function (point) {
    var planes = this.planes;
    for (var i = 0; i < 6; i++) {
      if (planes[i].distanceToPoint(point) < 0) {
        return false;
      }
    }
    return true;
  },
  clone: function () {
    return new THREE.Frustum().copy(this);
  }
};
THREE.Plane = function (normal, constant) {
  this.normal = normal !== undefined ? normal : new THREE.Vector3(1, 0, 0);
  this.constant = constant !== undefined ? constant : 0;
};
THREE.Plane.prototype = {
  constructor: THREE.Plane,
  set: function (normal, constant) {
    this.normal.copy(normal);
    this.constant = constant;
    return this;
  },
  setComponents: function (x, y, z, w) {
    this.normal.set(x, y, z);
    this.constant = w;
    return this;
  },
  setFromNormalAndCoplanarPoint: function (normal, point) {
    this.normal.copy(normal);
    this.constant = -point.dot(this.normal);
    return this;
  },
  setFromCoplanarPoints: function () {
    var v1 = new THREE.Vector3();
    var v2 = new THREE.Vector3();
    return function (a, b, c) {
      var normal = v1.subVectors(c, b).cross(v2.subVectors(a, b)).normalize();
      this.setFromNormalAndCoplanarPoint(normal, a);
      return this;
    };
  }(),
  copy: function (plane) {
    this.normal.copy(plane.normal);
    this.constant = plane.constant;
    return this;
  },
  normalize: function () {
    var inverseNormalLength = 1 / this.normal.length();
    this.normal.multiplyScalar(inverseNormalLength);
    this.constant *= inverseNormalLength;
    return this;
  },
  negate: function () {
    this.constant *= -1;
    this.normal.negate();
    return this;
  },
  distanceToPoint: function (point) {
    return this.normal.dot(point) + this.constant;
  },
  distanceToSphere: function (sphere) {
    return this.distanceToPoint(sphere.center) - sphere.radius;
  },
  projectPoint: function (point, optionalTarget) {
    return this.orthoPoint(point, optionalTarget).sub(point).negate();
  },
  orthoPoint: function (point, optionalTarget) {
    var perpendicularMagnitude = this.distanceToPoint(point);
    var result = optionalTarget || new THREE.Vector3();
    return result.copy(this.normal).multiplyScalar(perpendicularMagnitude);
  },
  isIntersectionLine: function (line) {
    var startSign = this.distanceToPoint(line.start);
    var endSign = this.distanceToPoint(line.end);
    return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
  },
  intersectLine: function () {
    var v1 = new THREE.Vector3();
    return function (line, optionalTarget) {
      var result = optionalTarget || new THREE.Vector3();
      var direction = line.delta(v1);
      var denominator = this.normal.dot(direction);
      if (denominator == 0) {
        if (this.distanceToPoint(line.start) == 0) {
          return result.copy(line.start);
        }
        return undefined;
      }
      var t = -(line.start.dot(this.normal) + this.constant) / denominator;
      if (t < 0 || t > 1) {
        return undefined;
      }
      return result.copy(direction).multiplyScalar(t).add(line.start);
    };
  }(),
  coplanarPoint: function (optionalTarget) {
    var result = optionalTarget || new THREE.Vector3();
    return result.copy(this.normal).multiplyScalar(-this.constant);
  },
  applyMatrix4: function () {
    var v1 = new THREE.Vector3();
    var v2 = new THREE.Vector3();
    return function (matrix, optionalNormalMatrix) {
      optionalNormalMatrix = optionalNormalMatrix || new THREE.Matrix3().getNormalMatrix(matrix);
      var newNormal = v1.copy(this.normal).applyMatrix3(optionalNormalMatrix);
      var newCoplanarPoint = this.coplanarPoint(v2);
      newCoplanarPoint.applyMatrix4(matrix);
      this.setFromNormalAndCoplanarPoint(newNormal, newCoplanarPoint);
      return this;
    };
  }(),
  translate: function (offset) {
    this.constant = this.constant - offset.dot(this.normal);
    return this;
  },
  equals: function (plane) {
    return plane.normal.equals(this.normal) && plane.constant == this.constant;
  },
  clone: function () {
    return new THREE.Plane().copy(this);
  }
};
THREE.Math = {
  PI2: Math.PI * 2,
  generateUUID: function () {
    var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');
    var uuid = new Array(36);
    var rnd = 0, r;
    return function () {
      for (var i = 0; i < 36; i++) {
        if (i == 8 || i == 13 || i == 18 || i == 23) {
          uuid[i] = '-';
        } else if (i == 14) {
          uuid[i] = '4';
        } else {
          if (rnd <= 2)
            rnd = 33554432 + Math.random() * 16777216 | 0;
          r = rnd & 15;
          rnd = rnd >> 4;
          uuid[i] = chars[i == 19 ? r & 3 | 8 : r];
        }
      }
      return uuid.join('');
    };
  }(),
  clamp: function (x, a, b) {
    return x < a ? a : x > b ? b : x;
  },
  clampBottom: function (x, a) {
    return x < a ? a : x;
  },
  mapLinear: function (x, a1, a2, b1, b2) {
    return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
  },
  smoothstep: function (x, min, max) {
    if (x <= min)
      return 0;
    if (x >= max)
      return 1;
    x = (x - min) / (max - min);
    return x * x * (3 - 2 * x);
  },
  smootherstep: function (x, min, max) {
    if (x <= min)
      return 0;
    if (x >= max)
      return 1;
    x = (x - min) / (max - min);
    return x * x * x * (x * (x * 6 - 15) + 10);
  },
  random16: function () {
    return (65280 * Math.random() + 255 * Math.random()) / 65535;
  },
  randInt: function (low, high) {
    return low + Math.floor(Math.random() * (high - low + 1));
  },
  randFloat: function (low, high) {
    return low + Math.random() * (high - low);
  },
  randFloatSpread: function (range) {
    return range * (0.5 - Math.random());
  },
  sign: function (x) {
    return x < 0 ? -1 : x > 0 ? 1 : 0;
  },
  degToRad: function () {
    var degreeToRadiansFactor = Math.PI / 180;
    return function (degrees) {
      return degrees * degreeToRadiansFactor;
    };
  }(),
  radToDeg: function () {
    var radianToDegreesFactor = 180 / Math.PI;
    return function (radians) {
      return radians * radianToDegreesFactor;
    };
  }()
};
THREE.Spline = function (points) {
  this.points = points;
  var c = [], v3 = {
      x: 0,
      y: 0,
      z: 0
    }, point, intPoint, weight, w2, w3, pa, pb, pc, pd;
  this.initFromArray = function (a) {
    this.points = [];
    for (var i = 0; i < a.length; i++) {
      this.points[i] = {
        x: a[i][0],
        y: a[i][1],
        z: a[i][2]
      };
    }
  };
  this.getPoint = function (k) {
    point = (this.points.length - 1) * k;
    intPoint = Math.floor(point);
    weight = point - intPoint;
    c[0] = intPoint === 0 ? intPoint : intPoint - 1;
    c[1] = intPoint;
    c[2] = intPoint > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;
    c[3] = intPoint > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;
    pa = this.points[c[0]];
    pb = this.points[c[1]];
    pc = this.points[c[2]];
    pd = this.points[c[3]];
    w2 = weight * weight;
    w3 = weight * w2;
    v3.x = interpolate(pa.x, pb.x, pc.x, pd.x, weight, w2, w3);
    v3.y = interpolate(pa.y, pb.y, pc.y, pd.y, weight, w2, w3);
    v3.z = interpolate(pa.z, pb.z, pc.z, pd.z, weight, w2, w3);
    return v3;
  };
  this.getControlPointsArray = function () {
    var i, p, l = this.points.length, coords = [];
    for (i = 0; i < l; i++) {
      p = this.points[i];
      coords[i] = [
        p.x,
        p.y,
        p.z
      ];
    }
    return coords;
  };
  this.getLength = function (nSubDivisions) {
    var i, index, nSamples, position, point = 0, intPoint = 0, oldIntPoint = 0, oldPosition = new THREE.Vector3(), tmpVec = new THREE.Vector3(), chunkLengths = [], totalLength = 0;
    chunkLengths[0] = 0;
    if (!nSubDivisions)
      nSubDivisions = 100;
    nSamples = this.points.length * nSubDivisions;
    oldPosition.copy(this.points[0]);
    for (i = 1; i < nSamples; i++) {
      index = i / nSamples;
      position = this.getPoint(index);
      tmpVec.copy(position);
      totalLength += tmpVec.distanceTo(oldPosition);
      oldPosition.copy(position);
      point = (this.points.length - 1) * index;
      intPoint = Math.floor(point);
      if (intPoint != oldIntPoint) {
        chunkLengths[intPoint] = totalLength;
        oldIntPoint = intPoint;
      }
    }
    chunkLengths[chunkLengths.length] = totalLength;
    return {
      chunks: chunkLengths,
      total: totalLength
    };
  };
  this.reparametrizeByArcLength = function (samplingCoef) {
    var i, j, index, indexCurrent, indexNext, linearDistance, realDistance, sampling, position, newpoints = [], tmpVec = new THREE.Vector3(), sl = this.getLength();
    newpoints.push(tmpVec.copy(this.points[0]).clone());
    for (i = 1; i < this.points.length; i++) {
      realDistance = sl.chunks[i] - sl.chunks[i - 1];
      sampling = Math.ceil(samplingCoef * realDistance / sl.total);
      indexCurrent = (i - 1) / (this.points.length - 1);
      indexNext = i / (this.points.length - 1);
      for (j = 1; j < sampling - 1; j++) {
        index = indexCurrent + j * (1 / sampling) * (indexNext - indexCurrent);
        position = this.getPoint(index);
        newpoints.push(tmpVec.copy(position).clone());
      }
      newpoints.push(tmpVec.copy(this.points[i]).clone());
    }
    this.points = newpoints;
  };
  function interpolate(p0, p1, p2, p3, t, t2, t3) {
    var v0 = (p2 - p0) * 0.5, v1 = (p3 - p1) * 0.5;
    return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;
  }
  ;
};
THREE.Triangle = function (a, b, c) {
  this.a = a !== undefined ? a : new THREE.Vector3();
  this.b = b !== undefined ? b : new THREE.Vector3();
  this.c = c !== undefined ? c : new THREE.Vector3();
};
THREE.Triangle.normal = function () {
  var v0 = new THREE.Vector3();
  return function (a, b, c, optionalTarget) {
    var result = optionalTarget || new THREE.Vector3();
    result.subVectors(c, b);
    v0.subVectors(a, b);
    result.cross(v0);
    var resultLengthSq = result.lengthSq();
    if (resultLengthSq > 0) {
      return result.multiplyScalar(1 / Math.sqrt(resultLengthSq));
    }
    return result.set(0, 0, 0);
  };
}();
THREE.Triangle.barycoordFromPoint = function () {
  var v0 = new THREE.Vector3();
  var v1 = new THREE.Vector3();
  var v2 = new THREE.Vector3();
  return function (point, a, b, c, optionalTarget) {
    v0.subVectors(c, a);
    v1.subVectors(b, a);
    v2.subVectors(point, a);
    var dot00 = v0.dot(v0);
    var dot01 = v0.dot(v1);
    var dot02 = v0.dot(v2);
    var dot11 = v1.dot(v1);
    var dot12 = v1.dot(v2);
    var denom = dot00 * dot11 - dot01 * dot01;
    var result = optionalTarget || new THREE.Vector3();
    if (denom == 0) {
      return result.set(-2, -1, -1);
    }
    var invDenom = 1 / denom;
    var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
    var v = (dot00 * dot12 - dot01 * dot02) * invDenom;
    return result.set(1 - u - v, v, u);
  };
}();
THREE.Triangle.containsPoint = function () {
  var v1 = new THREE.Vector3();
  return function (point, a, b, c) {
    var result = THREE.Triangle.barycoordFromPoint(point, a, b, c, v1);
    return result.x >= 0 && result.y >= 0 && result.x + result.y <= 1;
  };
}();
THREE.Triangle.prototype = {
  constructor: THREE.Triangle,
  set: function (a, b, c) {
    this.a.copy(a);
    this.b.copy(b);
    this.c.copy(c);
    return this;
  },
  setFromPointsAndIndices: function (points, i0, i1, i2) {
    this.a.copy(points[i0]);
    this.b.copy(points[i1]);
    this.c.copy(points[i2]);
    return this;
  },
  copy: function (triangle) {
    this.a.copy(triangle.a);
    this.b.copy(triangle.b);
    this.c.copy(triangle.c);
    return this;
  },
  area: function () {
    var v0 = new THREE.Vector3();
    var v1 = new THREE.Vector3();
    return function () {
      v0.subVectors(this.c, this.b);
      v1.subVectors(this.a, this.b);
      return v0.cross(v1).length() * 0.5;
    };
  }(),
  midpoint: function (optionalTarget) {
    var result = optionalTarget || new THREE.Vector3();
    return result.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  },
  normal: function (optionalTarget) {
    return THREE.Triangle.normal(this.a, this.b, this.c, optionalTarget);
  },
  plane: function (optionalTarget) {
    var result = optionalTarget || new THREE.Plane();
    return result.setFromCoplanarPoints(this.a, this.b, this.c);
  },
  barycoordFromPoint: function (point, optionalTarget) {
    return THREE.Triangle.barycoordFromPoint(point, this.a, this.b, this.c, optionalTarget);
  },
  containsPoint: function (point) {
    return THREE.Triangle.containsPoint(point, this.a, this.b, this.c);
  },
  equals: function (triangle) {
    return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
  },
  clone: function () {
    return new THREE.Triangle().copy(this);
  }
};
THREE.Vertex = function (v) {
  console.warn('THREE.Vertex has been DEPRECATED. Use THREE.Vector3 instead.');
  return v;
};
THREE.UV = function (u, v) {
  console.warn('THREE.UV has been DEPRECATED. Use THREE.Vector2 instead.');
  return new THREE.Vector2(u, v);
};
THREE.Clock = function (autoStart) {
  this.autoStart = autoStart !== undefined ? autoStart : true;
  this.startTime = 0;
  this.oldTime = 0;
  this.elapsedTime = 0;
  this.running = false;
};
THREE.Clock.prototype = {
  constructor: THREE.Clock,
  start: function () {
    this.startTime = self.performance !== undefined && self.performance.now !== undefined ? self.performance.now() : Date.now();
    this.oldTime = this.startTime;
    this.running = true;
  },
  stop: function () {
    this.getElapsedTime();
    this.running = false;
  },
  getElapsedTime: function () {
    this.getDelta();
    return this.elapsedTime;
  },
  getDelta: function () {
    var diff = 0;
    if (this.autoStart && !this.running) {
      this.start();
    }
    if (this.running) {
      var newTime = self.performance !== undefined && self.performance.now !== undefined ? self.performance.now() : Date.now();
      diff = 0.001 * (newTime - this.oldTime);
      this.oldTime = newTime;
      this.elapsedTime += diff;
    }
    return diff;
  }
};
THREE.EventDispatcher = function () {
};
THREE.EventDispatcher.prototype = {
  constructor: THREE.EventDispatcher,
  apply: function (object) {
    object.addEventListener = THREE.EventDispatcher.prototype.addEventListener;
    object.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener;
    object.removeEventListener = THREE.EventDispatcher.prototype.removeEventListener;
    object.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent;
  },
  addEventListener: function (type, listener) {
    if (this._listeners === undefined)
      this._listeners = {};
    var listeners = this._listeners;
    if (listeners[type] === undefined) {
      listeners[type] = [];
    }
    if (listeners[type].indexOf(listener) === -1) {
      listeners[type].push(listener);
    }
  },
  hasEventListener: function (type, listener) {
    if (this._listeners === undefined)
      return false;
    var listeners = this._listeners;
    if (listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1) {
      return true;
    }
    return false;
  },
  removeEventListener: function (type, listener) {
    if (this._listeners === undefined)
      return;
    var listeners = this._listeners;
    var index = listeners[type].indexOf(listener);
    if (index !== -1) {
      listeners[type].splice(index, 1);
    }
  },
  dispatchEvent: function (event) {
    if (this._listeners === undefined)
      return;
    var listeners = this._listeners;
    var listenerArray = listeners[event.type];
    if (listenerArray !== undefined) {
      event.target = this;
      for (var i = 0, l = listenerArray.length; i < l; i++) {
        listenerArray[i].call(this, event);
      }
    }
  }
};
(function (THREE) {
  THREE.Raycaster = function (origin, direction, near, far) {
    this.ray = new THREE.Ray(origin, direction);
    this.near = near || 0;
    this.far = far || Infinity;
  };
  var sphere = new THREE.Sphere();
  var localRay = new THREE.Ray();
  var facePlane = new THREE.Plane();
  var intersectPoint = new THREE.Vector3();
  var matrixPosition = new THREE.Vector3();
  var inverseMatrix = new THREE.Matrix4();
  var descSort = function (a, b) {
    return a.distance - b.distance;
  };
  var vA = new THREE.Vector3();
  var vB = new THREE.Vector3();
  var vC = new THREE.Vector3();
  var intersectObject = function (object, raycaster, intersects) {
    if (object instanceof THREE.Particle) {
      matrixPosition.getPositionFromMatrix(object.matrixWorld);
      var distance = raycaster.ray.distanceToPoint(matrixPosition);
      if (distance > object.scale.x) {
        return intersects;
      }
      intersects.push({
        distance: distance,
        point: object.position,
        face: null,
        object: object
      });
    } else if (object instanceof THREE.LOD) {
      matrixPosition.getPositionFromMatrix(object.matrixWorld);
      var distance = raycaster.ray.origin.distanceTo(matrixPosition);
      intersectObject(object.getObjectForDistance(distance), raycaster, intersects);
    } else if (object instanceof THREE.Mesh) {
      var geometry = object.geometry;
      if (geometry.boundingSphere === null)
        geometry.computeBoundingSphere();
      sphere.copy(geometry.boundingSphere);
      sphere.applyMatrix4(object.matrixWorld);
      if (raycaster.ray.isIntersectionSphere(sphere) === false) {
        return intersects;
      }
      inverseMatrix.getInverse(object.matrixWorld);
      localRay.copy(raycaster.ray).applyMatrix4(inverseMatrix);
      if (geometry.boundingBox !== null) {
        if (localRay.isIntersectionBox(geometry.boundingBox) === false) {
          return intersects;
        }
      }
      var vertices = geometry.vertices;
      if (geometry instanceof THREE.BufferGeometry) {
        var material = object.material;
        if (material === undefined)
          return intersects;
        if (geometry.dynamic === false)
          return intersects;
        var a, b, c;
        var precision = raycaster.precision;
        if (geometry.attributes.index !== undefined) {
          var offsets = geometry.offsets;
          var indices = geometry.attributes.index.array;
          var positions = geometry.attributes.position.array;
          var offLength = geometry.offsets.length;
          var fl = geometry.attributes.index.array.length / 3;
          for (var oi = 0; oi < offLength; ++oi) {
            var start = offsets[oi].start;
            var count = offsets[oi].count;
            var index = offsets[oi].index;
            for (var i = start, il = start + count; i < il; i += 3) {
              a = index + indices[i];
              b = index + indices[i + 1];
              c = index + indices[i + 2];
              vA.set(positions[a * 3], positions[a * 3 + 1], positions[a * 3 + 2]);
              vB.set(positions[b * 3], positions[b * 3 + 1], positions[b * 3 + 2]);
              vC.set(positions[c * 3], positions[c * 3 + 1], positions[c * 3 + 2]);
              var intersectionPoint = localRay.intersectTriangle(vA, vB, vC, material.side !== THREE.DoubleSide);
              if (intersectionPoint === null)
                continue;
              intersectionPoint.applyMatrix4(object.matrixWorld);
              var distance = raycaster.ray.origin.distanceTo(intersectionPoint);
              if (distance < precision || distance < raycaster.near || distance > raycaster.far)
                continue;
              intersects.push({
                distance: distance,
                point: intersectionPoint,
                face: null,
                faceIndex: null,
                object: object
              });
            }
          }
        } else {
          var offsets = geometry.offsets;
          var positions = geometry.attributes.position.array;
          var offLength = geometry.offsets.length;
          var fl = geometry.attributes.position.array.length;
          for (var i = 0; i < fl; i += 3) {
            a = i;
            b = i + 1;
            c = i + 2;
            vA.set(positions[a * 3], positions[a * 3 + 1], positions[a * 3 + 2]);
            vB.set(positions[b * 3], positions[b * 3 + 1], positions[b * 3 + 2]);
            vC.set(positions[c * 3], positions[c * 3 + 1], positions[c * 3 + 2]);
            var intersectionPoint = localRay.intersectTriangle(vA, vB, vC, material.side !== THREE.DoubleSide);
            if (intersectionPoint === null)
              continue;
            intersectionPoint.applyMatrix4(object.matrixWorld);
            var distance = raycaster.ray.origin.distanceTo(intersectionPoint);
            if (distance < precision || distance < raycaster.near || distance > raycaster.far)
              continue;
            intersects.push({
              distance: distance,
              point: intersectionPoint,
              face: null,
              faceIndex: null,
              object: object
            });
          }
        }
      } else if (geometry instanceof THREE.Geometry) {
        var isFaceMaterial = object.material instanceof THREE.MeshFaceMaterial;
        var objectMaterials = isFaceMaterial === true ? object.material.materials : null;
        var a, b, c, d;
        var precision = raycaster.precision;
        for (var f = 0, fl = geometry.faces.length; f < fl; f++) {
          var face = geometry.faces[f];
          var material = isFaceMaterial === true ? objectMaterials[face.materialIndex] : object.material;
          if (material === undefined)
            continue;
          a = vertices[face.a];
          b = vertices[face.b];
          c = vertices[face.c];
          var intersectionPoint = localRay.intersectTriangle(a, b, c, material.side !== THREE.DoubleSide);
          if (intersectionPoint === null)
            continue;
          intersectionPoint.applyMatrix4(object.matrixWorld);
          var distance = raycaster.ray.origin.distanceTo(intersectionPoint);
          if (distance < precision || distance < raycaster.near || distance > raycaster.far)
            continue;
          intersects.push({
            distance: distance,
            point: intersectionPoint,
            face: face,
            faceIndex: f,
            object: object
          });
        }
      }
    } else if (object instanceof THREE.Line) {
      var precision = raycaster.linePrecision;
      var precisionSq = precision * precision;
      var geometry = object.geometry;
      if (geometry.boundingSphere === null)
        geometry.computeBoundingSphere();
      sphere.copy(geometry.boundingSphere);
      sphere.applyMatrix4(object.matrixWorld);
      if (raycaster.ray.isIntersectionSphere(sphere) === false) {
        return intersects;
      }
      inverseMatrix.getInverse(object.matrixWorld);
      localRay.copy(raycaster.ray).applyMatrix4(inverseMatrix);
      var vertices = geometry.vertices;
      var nbVertices = vertices.length;
      var interSegment = new THREE.Vector3();
      var interRay = new THREE.Vector3();
      var step = object.type === THREE.LineStrip ? 1 : 2;
      for (var i = 0; i < nbVertices - 1; i = i + step) {
        var distSq = localRay.distanceSqToSegment(vertices[i], vertices[i + 1], interRay, interSegment);
        if (distSq > precisionSq)
          continue;
        var distance = localRay.origin.distanceTo(interRay);
        if (distance < raycaster.near || distance > raycaster.far)
          continue;
        intersects.push({
          distance: distance,
          point: interSegment.clone().applyMatrix4(object.matrixWorld),
          face: null,
          faceIndex: null,
          object: object
        });
      }
    }
  };
  var intersectDescendants = function (object, raycaster, intersects) {
    var descendants = object.getDescendants();
    for (var i = 0, l = descendants.length; i < l; i++) {
      intersectObject(descendants[i], raycaster, intersects);
    }
  };
  THREE.Raycaster.prototype.precision = 0.0001;
  THREE.Raycaster.prototype.linePrecision = 1;
  THREE.Raycaster.prototype.set = function (origin, direction) {
    this.ray.set(origin, direction);
  };
  THREE.Raycaster.prototype.intersectObject = function (object, recursive) {
    var intersects = [];
    if (recursive === true) {
      intersectDescendants(object, this, intersects);
    }
    intersectObject(object, this, intersects);
    intersects.sort(descSort);
    return intersects;
  };
  THREE.Raycaster.prototype.intersectObjects = function (objects, recursive) {
    var intersects = [];
    for (var i = 0, l = objects.length; i < l; i++) {
      intersectObject(objects[i], this, intersects);
      if (recursive === true) {
        intersectDescendants(objects[i], this, intersects);
      }
    }
    intersects.sort(descSort);
    return intersects;
  };
}(THREE));
THREE.Object3D = function () {
  this.id = THREE.Object3DIdCount++;
  this.uuid = THREE.Math.generateUUID();
  this.name = '';
  this.parent = undefined;
  this.children = [];
  this.up = new THREE.Vector3(0, 1, 0);
  this.position = new THREE.Vector3();
  this.rotation = new THREE.Euler();
  this.quaternion = new THREE.Quaternion();
  this.scale = new THREE.Vector3(1, 1, 1);
  this.rotation._quaternion = this.quaternion;
  this.quaternion._euler = this.rotation;
  this.renderDepth = null;
  this.rotationAutoUpdate = true;
  this.matrix = new THREE.Matrix4();
  this.matrixWorld = new THREE.Matrix4();
  this.matrixAutoUpdate = true;
  this.matrixWorldNeedsUpdate = true;
  this.visible = true;
  this.castShadow = false;
  this.receiveShadow = false;
  this.frustumCulled = true;
  this.userData = {};
};
THREE.Object3D.prototype = {
  constructor: THREE.Object3D,
  get eulerOrder() {
    console.warn('DEPRECATED: Object3D\'s .eulerOrder has been moved to Object3D\'s .rotation.order.');
    return this.rotation.order;
  },
  set eulerOrder(value) {
    console.warn('DEPRECATED: Object3D\'s .eulerOrder has been moved to Object3D\'s .rotation.order.');
    this.rotation.order = value;
  },
  get useQuaternion() {
    console.warn('DEPRECATED: Object3D\'s .useQuaternion has been removed. The library now uses quaternions by default.');
  },
  set useQuaternion(value) {
    console.warn('DEPRECATED: Object3D\'s .useQuaternion has been removed. The library now uses quaternions by default.');
  },
  applyMatrix: function () {
    var m1 = new THREE.Matrix4();
    return function (matrix) {
      this.matrix.multiplyMatrices(matrix, this.matrix);
      this.position.getPositionFromMatrix(this.matrix);
      this.scale.getScaleFromMatrix(this.matrix);
      m1.extractRotation(this.matrix);
      this.quaternion.setFromRotationMatrix(m1);
    };
  }(),
  setRotationFromAxisAngle: function (axis, angle) {
    this.quaternion.setFromAxisAngle(axis, angle);
  },
  setRotationFromEuler: function (euler) {
    this.quaternion.setFromEuler(euler, true);
  },
  setRotationFromMatrix: function (m) {
    this.quaternion.setFromRotationMatrix(m);
  },
  setRotationFromQuaternion: function (q) {
    this.quaternion.copy(q);
  },
  rotateOnAxis: function () {
    var q1 = new THREE.Quaternion();
    return function (axis, angle) {
      q1.setFromAxisAngle(axis, angle);
      this.quaternion.multiply(q1);
      return this;
    };
  }(),
  rotateX: function () {
    var v1 = new THREE.Vector3(1, 0, 0);
    return function (angle) {
      return this.rotateOnAxis(v1, angle);
    };
  }(),
  rotateY: function () {
    var v1 = new THREE.Vector3(0, 1, 0);
    return function (angle) {
      return this.rotateOnAxis(v1, angle);
    };
  }(),
  rotateZ: function () {
    var v1 = new THREE.Vector3(0, 0, 1);
    return function (angle) {
      return this.rotateOnAxis(v1, angle);
    };
  }(),
  translateOnAxis: function () {
    var v1 = new THREE.Vector3();
    return function (axis, distance) {
      v1.copy(axis);
      v1.applyQuaternion(this.quaternion);
      this.position.add(v1.multiplyScalar(distance));
      return this;
    };
  }(),
  translate: function (distance, axis) {
    console.warn('DEPRECATED: Object3D\'s .translate() has been removed. Use .translateOnAxis( axis, distance ) instead. Note args have been changed.');
    return this.translateOnAxis(axis, distance);
  },
  translateX: function () {
    var v1 = new THREE.Vector3(1, 0, 0);
    return function (distance) {
      return this.translateOnAxis(v1, distance);
    };
  }(),
  translateY: function () {
    var v1 = new THREE.Vector3(0, 1, 0);
    return function (distance) {
      return this.translateOnAxis(v1, distance);
    };
  }(),
  translateZ: function () {
    var v1 = new THREE.Vector3(0, 0, 1);
    return function (distance) {
      return this.translateOnAxis(v1, distance);
    };
  }(),
  localToWorld: function (vector) {
    return vector.applyMatrix4(this.matrixWorld);
  },
  worldToLocal: function () {
    var m1 = new THREE.Matrix4();
    return function (vector) {
      return vector.applyMatrix4(m1.getInverse(this.matrixWorld));
    };
  }(),
  lookAt: function () {
    var m1 = new THREE.Matrix4();
    return function (vector) {
      m1.lookAt(vector, this.position, this.up);
      this.quaternion.setFromRotationMatrix(m1);
    };
  }(),
  add: function (object) {
    if (object === this) {
      console.warn('THREE.Object3D.add: An object can\'t be added as a child of itself.');
      return;
    }
    if (object instanceof THREE.Object3D) {
      if (object.parent !== undefined) {
        object.parent.remove(object);
      }
      object.parent = this;
      object.dispatchEvent({ type: 'added' });
      this.children.push(object);
      var scene = this;
      while (scene.parent !== undefined) {
        scene = scene.parent;
      }
      if (scene !== undefined && scene instanceof THREE.Scene) {
        scene.__addObject(object);
      }
    }
  },
  remove: function (object) {
    var index = this.children.indexOf(object);
    if (index !== -1) {
      object.parent = undefined;
      object.dispatchEvent({ type: 'removed' });
      this.children.splice(index, 1);
      var scene = this;
      while (scene.parent !== undefined) {
        scene = scene.parent;
      }
      if (scene !== undefined && scene instanceof THREE.Scene) {
        scene.__removeObject(object);
      }
    }
  },
  traverse: function (callback) {
    callback(this);
    for (var i = 0, l = this.children.length; i < l; i++) {
      this.children[i].traverse(callback);
    }
  },
  getObjectById: function (id, recursive) {
    for (var i = 0, l = this.children.length; i < l; i++) {
      var child = this.children[i];
      if (child.id === id) {
        return child;
      }
      if (recursive === true) {
        child = child.getObjectById(id, recursive);
        if (child !== undefined) {
          return child;
        }
      }
    }
    return undefined;
  },
  getObjectByName: function (name, recursive) {
    for (var i = 0, l = this.children.length; i < l; i++) {
      var child = this.children[i];
      if (child.name === name) {
        return child;
      }
      if (recursive === true) {
        child = child.getObjectByName(name, recursive);
        if (child !== undefined) {
          return child;
        }
      }
    }
    return undefined;
  },
  getChildByName: function (name, recursive) {
    console.warn('DEPRECATED: Object3D\'s .getChildByName() has been renamed to .getObjectByName().');
    return this.getObjectByName(name, recursive);
  },
  getDescendants: function (array) {
    if (array === undefined)
      array = [];
    Array.prototype.push.apply(array, this.children);
    for (var i = 0, l = this.children.length; i < l; i++) {
      this.children[i].getDescendants(array);
    }
    return array;
  },
  updateMatrix: function () {
    this.matrix.compose(this.position, this.quaternion, this.scale);
    this.matrixWorldNeedsUpdate = true;
  },
  updateMatrixWorld: function (force) {
    if (this.matrixAutoUpdate === true)
      this.updateMatrix();
    if (this.matrixWorldNeedsUpdate === true || force === true) {
      if (this.parent === undefined) {
        this.matrixWorld.copy(this.matrix);
      } else {
        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
      }
      this.matrixWorldNeedsUpdate = false;
      force = true;
    }
    for (var i = 0, l = this.children.length; i < l; i++) {
      this.children[i].updateMatrixWorld(force);
    }
  },
  clone: function (object, recursive) {
    if (object === undefined)
      object = new THREE.Object3D();
    if (recursive === undefined)
      recursive = true;
    object.name = this.name;
    object.up.copy(this.up);
    object.position.copy(this.position);
    object.quaternion.copy(this.quaternion);
    object.scale.copy(this.scale);
    object.renderDepth = this.renderDepth;
    object.rotationAutoUpdate = this.rotationAutoUpdate;
    object.matrix.copy(this.matrix);
    object.matrixWorld.copy(this.matrixWorld);
    object.matrixAutoUpdate = this.matrixAutoUpdate;
    object.matrixWorldNeedsUpdate = this.matrixWorldNeedsUpdate;
    object.visible = this.visible;
    object.castShadow = this.castShadow;
    object.receiveShadow = this.receiveShadow;
    object.frustumCulled = this.frustumCulled;
    object.userData = JSON.parse(JSON.stringify(this.userData));
    if (recursive === true) {
      for (var i = 0; i < this.children.length; i++) {
        var child = this.children[i];
        object.add(child.clone());
      }
    }
    return object;
  }
};
THREE.EventDispatcher.prototype.apply(THREE.Object3D.prototype);
THREE.Object3DIdCount = 0;
THREE.Projector = function () {
  var _object, _objectCount, _objectPool = [], _objectPoolLength = 0, _vertex, _vertexCount, _vertexPool = [], _vertexPoolLength = 0, _face, _face3Count, _face3Pool = [], _face3PoolLength = 0, _line, _lineCount, _linePool = [], _linePoolLength = 0, _particle, _particleCount, _particlePool = [], _particlePoolLength = 0, _renderData = {
      objects: [],
      sprites: [],
      lights: [],
      elements: []
    }, _vector3 = new THREE.Vector3(), _vector4 = new THREE.Vector4(), _clipBox = new THREE.Box3(new THREE.Vector3(-1, -1, -1), new THREE.Vector3(1, 1, 1)), _boundingBox = new THREE.Box3(), _points3 = new Array(3), _points4 = new Array(4), _viewMatrix = new THREE.Matrix4(), _viewProjectionMatrix = new THREE.Matrix4(), _modelMatrix, _modelViewProjectionMatrix = new THREE.Matrix4(), _normalMatrix = new THREE.Matrix3(), _normalViewMatrix = new THREE.Matrix3(), _centroid = new THREE.Vector3(), _frustum = new THREE.Frustum(), _clippedVertex1PositionScreen = new THREE.Vector4(), _clippedVertex2PositionScreen = new THREE.Vector4();
  this.projectVector = function (vector, camera) {
    camera.matrixWorldInverse.getInverse(camera.matrixWorld);
    _viewProjectionMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
    return vector.applyProjection(_viewProjectionMatrix);
  };
  this.unprojectVector = function (vector, camera) {
    camera.projectionMatrixInverse.getInverse(camera.projectionMatrix);
    _viewProjectionMatrix.multiplyMatrices(camera.matrixWorld, camera.projectionMatrixInverse);
    return vector.applyProjection(_viewProjectionMatrix);
  };
  this.pickingRay = function (vector, camera) {
    vector.z = -1;
    var end = new THREE.Vector3(vector.x, vector.y, 1);
    this.unprojectVector(vector, camera);
    this.unprojectVector(end, camera);
    end.sub(vector).normalize();
    return new THREE.Raycaster(vector, end);
  };
  var getObject = function (object) {
    _object = getNextObjectInPool();
    _object.id = object.id;
    _object.object = object;
    if (object.renderDepth !== null) {
      _object.z = object.renderDepth;
    } else {
      _vector3.getPositionFromMatrix(object.matrixWorld);
      _vector3.applyProjection(_viewProjectionMatrix);
      _object.z = _vector3.z;
    }
    return _object;
  };
  var projectObject = function (object) {
    if (object.visible === false)
      return;
    if (object instanceof THREE.Light) {
      _renderData.lights.push(object);
    } else if (object instanceof THREE.Mesh || object instanceof THREE.Line) {
      if (object.frustumCulled === false || _frustum.intersectsObject(object) === true) {
        _renderData.objects.push(getObject(object));
      }
    } else if (object instanceof THREE.Sprite || object instanceof THREE.Particle) {
      _renderData.sprites.push(getObject(object));
    }
    for (var i = 0, l = object.children.length; i < l; i++) {
      projectObject(object.children[i]);
    }
  };
  var projectGraph = function (root, sortObjects) {
    _objectCount = 0;
    _renderData.objects.length = 0;
    _renderData.sprites.length = 0;
    _renderData.lights.length = 0;
    projectObject(root);
    if (sortObjects === true) {
      _renderData.objects.sort(painterSort);
    }
  };
  this.projectScene = function (scene, camera, sortObjects, sortElements) {
    var visible = false, o, ol, v, vl, f, fl, n, nl, c, cl, u, ul, object, geometry, vertices, faces, face, faceVertexNormals, faceVertexUvs, uvs, v1, v2, v3, v4, isFaceMaterial, objectMaterials;
    _face3Count = 0;
    _lineCount = 0;
    _particleCount = 0;
    _renderData.elements.length = 0;
    if (scene.autoUpdate === true)
      scene.updateMatrixWorld();
    if (camera.parent === undefined)
      camera.updateMatrixWorld();
    _viewMatrix.copy(camera.matrixWorldInverse.getInverse(camera.matrixWorld));
    _viewProjectionMatrix.multiplyMatrices(camera.projectionMatrix, _viewMatrix);
    _normalViewMatrix.getNormalMatrix(_viewMatrix);
    _frustum.setFromMatrix(_viewProjectionMatrix);
    projectGraph(scene, sortObjects);
    for (o = 0, ol = _renderData.objects.length; o < ol; o++) {
      object = _renderData.objects[o].object;
      _modelMatrix = object.matrixWorld;
      _vertexCount = 0;
      if (object instanceof THREE.Mesh) {
        geometry = object.geometry;
        vertices = geometry.vertices;
        faces = geometry.faces;
        faceVertexUvs = geometry.faceVertexUvs;
        _normalMatrix.getNormalMatrix(_modelMatrix);
        isFaceMaterial = object.material instanceof THREE.MeshFaceMaterial;
        objectMaterials = isFaceMaterial === true ? object.material : null;
        for (v = 0, vl = vertices.length; v < vl; v++) {
          _vertex = getNextVertexInPool();
          _vertex.positionWorld.copy(vertices[v]).applyMatrix4(_modelMatrix);
          _vertex.positionScreen.copy(_vertex.positionWorld).applyMatrix4(_viewProjectionMatrix);
          var invW = 1 / _vertex.positionScreen.w;
          _vertex.positionScreen.x *= invW;
          _vertex.positionScreen.y *= invW;
          _vertex.positionScreen.z *= invW;
          _vertex.visible = !(_vertex.positionScreen.x < -1 || _vertex.positionScreen.x > 1 || _vertex.positionScreen.y < -1 || _vertex.positionScreen.y > 1 || _vertex.positionScreen.z < -1 || _vertex.positionScreen.z > 1);
        }
        for (f = 0, fl = faces.length; f < fl; f++) {
          face = faces[f];
          var material = isFaceMaterial === true ? objectMaterials.materials[face.materialIndex] : object.material;
          if (material === undefined)
            continue;
          var side = material.side;
          v1 = _vertexPool[face.a];
          v2 = _vertexPool[face.b];
          v3 = _vertexPool[face.c];
          _points3[0] = v1.positionScreen;
          _points3[1] = v2.positionScreen;
          _points3[2] = v3.positionScreen;
          if (v1.visible === true || v2.visible === true || v3.visible === true || _clipBox.isIntersectionBox(_boundingBox.setFromPoints(_points3))) {
            visible = (v3.positionScreen.x - v1.positionScreen.x) * (v2.positionScreen.y - v1.positionScreen.y) - (v3.positionScreen.y - v1.positionScreen.y) * (v2.positionScreen.x - v1.positionScreen.x) < 0;
            if (side === THREE.DoubleSide || visible === (side === THREE.FrontSide)) {
              _face = getNextFace3InPool();
              _face.id = object.id;
              _face.v1.copy(v1);
              _face.v2.copy(v2);
              _face.v3.copy(v3);
            } else {
              continue;
            }
          } else {
            continue;
          }
          _face.normalModel.copy(face.normal);
          if (visible === false && (side === THREE.BackSide || side === THREE.DoubleSide)) {
            _face.normalModel.negate();
          }
          _face.normalModel.applyMatrix3(_normalMatrix).normalize();
          _face.normalModelView.copy(_face.normalModel).applyMatrix3(_normalViewMatrix);
          _face.centroidModel.copy(face.centroid).applyMatrix4(_modelMatrix);
          faceVertexNormals = face.vertexNormals;
          for (n = 0, nl = Math.min(faceVertexNormals.length, 3); n < nl; n++) {
            var normalModel = _face.vertexNormalsModel[n];
            normalModel.copy(faceVertexNormals[n]);
            if (visible === false && (side === THREE.BackSide || side === THREE.DoubleSide)) {
              normalModel.negate();
            }
            normalModel.applyMatrix3(_normalMatrix).normalize();
            var normalModelView = _face.vertexNormalsModelView[n];
            normalModelView.copy(normalModel).applyMatrix3(_normalViewMatrix);
          }
          _face.vertexNormalsLength = faceVertexNormals.length;
          for (c = 0, cl = Math.min(faceVertexUvs.length, 3); c < cl; c++) {
            uvs = faceVertexUvs[c][f];
            if (uvs === undefined)
              continue;
            for (u = 0, ul = uvs.length; u < ul; u++) {
              _face.uvs[c][u] = uvs[u];
            }
          }
          _face.color = face.color;
          _face.material = material;
          _centroid.copy(_face.centroidModel).applyProjection(_viewProjectionMatrix);
          _face.z = _centroid.z;
          _renderData.elements.push(_face);
        }
      } else if (object instanceof THREE.Line) {
        _modelViewProjectionMatrix.multiplyMatrices(_viewProjectionMatrix, _modelMatrix);
        vertices = object.geometry.vertices;
        v1 = getNextVertexInPool();
        v1.positionScreen.copy(vertices[0]).applyMatrix4(_modelViewProjectionMatrix);
        var step = object.type === THREE.LinePieces ? 2 : 1;
        for (v = 1, vl = vertices.length; v < vl; v++) {
          v1 = getNextVertexInPool();
          v1.positionScreen.copy(vertices[v]).applyMatrix4(_modelViewProjectionMatrix);
          if ((v + 1) % step > 0)
            continue;
          v2 = _vertexPool[_vertexCount - 2];
          _clippedVertex1PositionScreen.copy(v1.positionScreen);
          _clippedVertex2PositionScreen.copy(v2.positionScreen);
          if (clipLine(_clippedVertex1PositionScreen, _clippedVertex2PositionScreen) === true) {
            _clippedVertex1PositionScreen.multiplyScalar(1 / _clippedVertex1PositionScreen.w);
            _clippedVertex2PositionScreen.multiplyScalar(1 / _clippedVertex2PositionScreen.w);
            _line = getNextLineInPool();
            _line.id = object.id;
            _line.v1.positionScreen.copy(_clippedVertex1PositionScreen);
            _line.v2.positionScreen.copy(_clippedVertex2PositionScreen);
            _line.z = Math.max(_clippedVertex1PositionScreen.z, _clippedVertex2PositionScreen.z);
            _line.material = object.material;
            if (object.material.vertexColors === THREE.VertexColors) {
              _line.vertexColors[0].copy(object.geometry.colors[v]);
              _line.vertexColors[1].copy(object.geometry.colors[v - 1]);
            }
            _renderData.elements.push(_line);
          }
        }
      }
    }
    for (o = 0, ol = _renderData.sprites.length; o < ol; o++) {
      object = _renderData.sprites[o].object;
      _modelMatrix = object.matrixWorld;
      if (object instanceof THREE.Particle) {
        _vector4.set(_modelMatrix.elements[12], _modelMatrix.elements[13], _modelMatrix.elements[14], 1);
        _vector4.applyMatrix4(_viewProjectionMatrix);
        var invW = 1 / _vector4.w;
        _vector4.z *= invW;
        if (_vector4.z > 0 && _vector4.z < 1) {
          _particle = getNextParticleInPool();
          _particle.id = object.id;
          _particle.x = _vector4.x * invW;
          _particle.y = _vector4.y * invW;
          _particle.z = _vector4.z;
          _particle.object = object;
          _particle.rotation = object.rotation.z;
          _particle.scale.x = object.scale.x * Math.abs(_particle.x - (_vector4.x + camera.projectionMatrix.elements[0]) / (_vector4.w + camera.projectionMatrix.elements[12]));
          _particle.scale.y = object.scale.y * Math.abs(_particle.y - (_vector4.y + camera.projectionMatrix.elements[5]) / (_vector4.w + camera.projectionMatrix.elements[13]));
          _particle.material = object.material;
          _renderData.elements.push(_particle);
        }
      }
    }
    if (sortElements === true)
      _renderData.elements.sort(painterSort);
    return _renderData;
  };
  function getNextObjectInPool() {
    if (_objectCount === _objectPoolLength) {
      var object = new THREE.RenderableObject();
      _objectPool.push(object);
      _objectPoolLength++;
      _objectCount++;
      return object;
    }
    return _objectPool[_objectCount++];
  }
  function getNextVertexInPool() {
    if (_vertexCount === _vertexPoolLength) {
      var vertex = new THREE.RenderableVertex();
      _vertexPool.push(vertex);
      _vertexPoolLength++;
      _vertexCount++;
      return vertex;
    }
    return _vertexPool[_vertexCount++];
  }
  function getNextFace3InPool() {
    if (_face3Count === _face3PoolLength) {
      var face = new THREE.RenderableFace3();
      _face3Pool.push(face);
      _face3PoolLength++;
      _face3Count++;
      return face;
    }
    return _face3Pool[_face3Count++];
  }
  function getNextLineInPool() {
    if (_lineCount === _linePoolLength) {
      var line = new THREE.RenderableLine();
      _linePool.push(line);
      _linePoolLength++;
      _lineCount++;
      return line;
    }
    return _linePool[_lineCount++];
  }
  function getNextParticleInPool() {
    if (_particleCount === _particlePoolLength) {
      var particle = new THREE.RenderableParticle();
      _particlePool.push(particle);
      _particlePoolLength++;
      _particleCount++;
      return particle;
    }
    return _particlePool[_particleCount++];
  }
  function painterSort(a, b) {
    if (a.z !== b.z) {
      return b.z - a.z;
    } else if (a.id !== b.id) {
      return a.id - b.id;
    } else {
      return 0;
    }
  }
  function clipLine(s1, s2) {
    var alpha1 = 0, alpha2 = 1, bc1near = s1.z + s1.w, bc2near = s2.z + s2.w, bc1far = -s1.z + s1.w, bc2far = -s2.z + s2.w;
    if (bc1near >= 0 && bc2near >= 0 && bc1far >= 0 && bc2far >= 0) {
      return true;
    } else if (bc1near < 0 && bc2near < 0 || bc1far < 0 && bc2far < 0) {
      return false;
    } else {
      if (bc1near < 0) {
        alpha1 = Math.max(alpha1, bc1near / (bc1near - bc2near));
      } else if (bc2near < 0) {
        alpha2 = Math.min(alpha2, bc1near / (bc1near - bc2near));
      }
      if (bc1far < 0) {
        alpha1 = Math.max(alpha1, bc1far / (bc1far - bc2far));
      } else if (bc2far < 0) {
        alpha2 = Math.min(alpha2, bc1far / (bc1far - bc2far));
      }
      if (alpha2 < alpha1) {
        return false;
      } else {
        s1.lerp(s2, alpha1);
        s2.lerp(s1, 1 - alpha2);
        return true;
      }
    }
  }
};
THREE.Face3 = function (a, b, c, normal, color, materialIndex) {
  this.a = a;
  this.b = b;
  this.c = c;
  this.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();
  this.vertexNormals = normal instanceof Array ? normal : [];
  this.color = color instanceof THREE.Color ? color : new THREE.Color();
  this.vertexColors = color instanceof Array ? color : [];
  this.vertexTangents = [];
  this.materialIndex = materialIndex !== undefined ? materialIndex : 0;
  this.centroid = new THREE.Vector3();
};
THREE.Face3.prototype = {
  constructor: THREE.Face3,
  clone: function () {
    var face = new THREE.Face3(this.a, this.b, this.c);
    face.normal.copy(this.normal);
    face.color.copy(this.color);
    face.centroid.copy(this.centroid);
    face.materialIndex = this.materialIndex;
    var i, il;
    for (i = 0, il = this.vertexNormals.length; i < il; i++)
      face.vertexNormals[i] = this.vertexNormals[i].clone();
    for (i = 0, il = this.vertexColors.length; i < il; i++)
      face.vertexColors[i] = this.vertexColors[i].clone();
    for (i = 0, il = this.vertexTangents.length; i < il; i++)
      face.vertexTangents[i] = this.vertexTangents[i].clone();
    return face;
  }
};
THREE.Face4 = function (a, b, c, d, normal, color, materialIndex) {
  return new THREE.Face3(a, b, c, normal, color, materialIndex);
};
THREE.Geometry = function () {
  this.id = THREE.GeometryIdCount++;
  this.uuid = THREE.Math.generateUUID();
  this.name = '';
  this.vertices = [];
  this.colors = [];
  this.normals = [];
  this.faces = [];
  this.faceVertexUvs = [[]];
  this.morphTargets = [];
  this.morphColors = [];
  this.morphNormals = [];
  this.skinWeights = [];
  this.skinIndices = [];
  this.lineDistances = [];
  this.boundingBox = null;
  this.boundingSphere = null;
  this.hasTangents = false;
  this.dynamic = true;
  this.verticesNeedUpdate = false;
  this.elementsNeedUpdate = false;
  this.uvsNeedUpdate = false;
  this.normalsNeedUpdate = false;
  this.tangentsNeedUpdate = false;
  this.colorsNeedUpdate = false;
  this.lineDistancesNeedUpdate = false;
  this.buffersNeedUpdate = false;
};
THREE.Geometry.prototype = {
  constructor: THREE.Geometry,
  applyMatrix: function (matrix) {
    var normalMatrix = new THREE.Matrix3().getNormalMatrix(matrix);
    for (var i = 0, il = this.vertices.length; i < il; i++) {
      var vertex = this.vertices[i];
      vertex.applyMatrix4(matrix);
    }
    for (var i = 0, il = this.faces.length; i < il; i++) {
      var face = this.faces[i];
      face.normal.applyMatrix3(normalMatrix).normalize();
      for (var j = 0, jl = face.vertexNormals.length; j < jl; j++) {
        face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();
      }
      face.centroid.applyMatrix4(matrix);
    }
    if (this.boundingBox instanceof THREE.Box3) {
      this.computeBoundingBox();
    }
    if (this.boundingSphere instanceof THREE.Sphere) {
      this.computeBoundingSphere();
    }
  },
  computeCentroids: function () {
    var f, fl, face;
    for (f = 0, fl = this.faces.length; f < fl; f++) {
      face = this.faces[f];
      face.centroid.set(0, 0, 0);
      face.centroid.add(this.vertices[face.a]);
      face.centroid.add(this.vertices[face.b]);
      face.centroid.add(this.vertices[face.c]);
      face.centroid.divideScalar(3);
    }
  },
  computeFaceNormals: function () {
    var cb = new THREE.Vector3(), ab = new THREE.Vector3();
    for (var f = 0, fl = this.faces.length; f < fl; f++) {
      var face = this.faces[f];
      var vA = this.vertices[face.a];
      var vB = this.vertices[face.b];
      var vC = this.vertices[face.c];
      cb.subVectors(vC, vB);
      ab.subVectors(vA, vB);
      cb.cross(ab);
      cb.normalize();
      face.normal.copy(cb);
    }
  },
  computeVertexNormals: function (areaWeighted) {
    var v, vl, f, fl, face, vertices;
    if (this.__tmpVertices === undefined) {
      this.__tmpVertices = new Array(this.vertices.length);
      vertices = this.__tmpVertices;
      for (v = 0, vl = this.vertices.length; v < vl; v++) {
        vertices[v] = new THREE.Vector3();
      }
      for (f = 0, fl = this.faces.length; f < fl; f++) {
        face = this.faces[f];
        face.vertexNormals = [
          new THREE.Vector3(),
          new THREE.Vector3(),
          new THREE.Vector3()
        ];
      }
    } else {
      vertices = this.__tmpVertices;
      for (v = 0, vl = this.vertices.length; v < vl; v++) {
        vertices[v].set(0, 0, 0);
      }
    }
    if (areaWeighted) {
      var vA, vB, vC, vD;
      var cb = new THREE.Vector3(), ab = new THREE.Vector3(), db = new THREE.Vector3(), dc = new THREE.Vector3(), bc = new THREE.Vector3();
      for (f = 0, fl = this.faces.length; f < fl; f++) {
        face = this.faces[f];
        vA = this.vertices[face.a];
        vB = this.vertices[face.b];
        vC = this.vertices[face.c];
        cb.subVectors(vC, vB);
        ab.subVectors(vA, vB);
        cb.cross(ab);
        vertices[face.a].add(cb);
        vertices[face.b].add(cb);
        vertices[face.c].add(cb);
      }
    } else {
      for (f = 0, fl = this.faces.length; f < fl; f++) {
        face = this.faces[f];
        vertices[face.a].add(face.normal);
        vertices[face.b].add(face.normal);
        vertices[face.c].add(face.normal);
      }
    }
    for (v = 0, vl = this.vertices.length; v < vl; v++) {
      vertices[v].normalize();
    }
    for (f = 0, fl = this.faces.length; f < fl; f++) {
      face = this.faces[f];
      face.vertexNormals[0].copy(vertices[face.a]);
      face.vertexNormals[1].copy(vertices[face.b]);
      face.vertexNormals[2].copy(vertices[face.c]);
    }
  },
  computeMorphNormals: function () {
    var i, il, f, fl, face;
    for (f = 0, fl = this.faces.length; f < fl; f++) {
      face = this.faces[f];
      if (!face.__originalFaceNormal) {
        face.__originalFaceNormal = face.normal.clone();
      } else {
        face.__originalFaceNormal.copy(face.normal);
      }
      if (!face.__originalVertexNormals)
        face.__originalVertexNormals = [];
      for (i = 0, il = face.vertexNormals.length; i < il; i++) {
        if (!face.__originalVertexNormals[i]) {
          face.__originalVertexNormals[i] = face.vertexNormals[i].clone();
        } else {
          face.__originalVertexNormals[i].copy(face.vertexNormals[i]);
        }
      }
    }
    var tmpGeo = new THREE.Geometry();
    tmpGeo.faces = this.faces;
    for (i = 0, il = this.morphTargets.length; i < il; i++) {
      if (!this.morphNormals[i]) {
        this.morphNormals[i] = {};
        this.morphNormals[i].faceNormals = [];
        this.morphNormals[i].vertexNormals = [];
        var dstNormalsFace = this.morphNormals[i].faceNormals;
        var dstNormalsVertex = this.morphNormals[i].vertexNormals;
        var faceNormal, vertexNormals;
        for (f = 0, fl = this.faces.length; f < fl; f++) {
          face = this.faces[f];
          faceNormal = new THREE.Vector3();
          vertexNormals = {
            a: new THREE.Vector3(),
            b: new THREE.Vector3(),
            c: new THREE.Vector3()
          };
          dstNormalsFace.push(faceNormal);
          dstNormalsVertex.push(vertexNormals);
        }
      }
      var morphNormals = this.morphNormals[i];
      tmpGeo.vertices = this.morphTargets[i].vertices;
      tmpGeo.computeFaceNormals();
      tmpGeo.computeVertexNormals();
      var faceNormal, vertexNormals;
      for (f = 0, fl = this.faces.length; f < fl; f++) {
        face = this.faces[f];
        faceNormal = morphNormals.faceNormals[f];
        vertexNormals = morphNormals.vertexNormals[f];
        faceNormal.copy(face.normal);
        vertexNormals.a.copy(face.vertexNormals[0]);
        vertexNormals.b.copy(face.vertexNormals[1]);
        vertexNormals.c.copy(face.vertexNormals[2]);
      }
    }
    for (f = 0, fl = this.faces.length; f < fl; f++) {
      face = this.faces[f];
      face.normal = face.__originalFaceNormal;
      face.vertexNormals = face.__originalVertexNormals;
    }
  },
  computeTangents: function () {
    var f, fl, v, vl, i, il, vertexIndex, face, uv, vA, vB, vC, uvA, uvB, uvC, x1, x2, y1, y2, z1, z2, s1, s2, t1, t2, r, t, test, tan1 = [], tan2 = [], sdir = new THREE.Vector3(), tdir = new THREE.Vector3(), tmp = new THREE.Vector3(), tmp2 = new THREE.Vector3(), n = new THREE.Vector3(), w;
    for (v = 0, vl = this.vertices.length; v < vl; v++) {
      tan1[v] = new THREE.Vector3();
      tan2[v] = new THREE.Vector3();
    }
    function handleTriangle(context, a, b, c, ua, ub, uc) {
      vA = context.vertices[a];
      vB = context.vertices[b];
      vC = context.vertices[c];
      uvA = uv[ua];
      uvB = uv[ub];
      uvC = uv[uc];
      x1 = vB.x - vA.x;
      x2 = vC.x - vA.x;
      y1 = vB.y - vA.y;
      y2 = vC.y - vA.y;
      z1 = vB.z - vA.z;
      z2 = vC.z - vA.z;
      s1 = uvB.x - uvA.x;
      s2 = uvC.x - uvA.x;
      t1 = uvB.y - uvA.y;
      t2 = uvC.y - uvA.y;
      r = 1 / (s1 * t2 - s2 * t1);
      sdir.set((t2 * x1 - t1 * x2) * r, (t2 * y1 - t1 * y2) * r, (t2 * z1 - t1 * z2) * r);
      tdir.set((s1 * x2 - s2 * x1) * r, (s1 * y2 - s2 * y1) * r, (s1 * z2 - s2 * z1) * r);
      tan1[a].add(sdir);
      tan1[b].add(sdir);
      tan1[c].add(sdir);
      tan2[a].add(tdir);
      tan2[b].add(tdir);
      tan2[c].add(tdir);
    }
    for (f = 0, fl = this.faces.length; f < fl; f++) {
      face = this.faces[f];
      uv = this.faceVertexUvs[0][f];
      handleTriangle(this, face.a, face.b, face.c, 0, 1, 2);
    }
    var faceIndex = [
        'a',
        'b',
        'c',
        'd'
      ];
    for (f = 0, fl = this.faces.length; f < fl; f++) {
      face = this.faces[f];
      for (i = 0; i < Math.min(face.vertexNormals.length, 3); i++) {
        n.copy(face.vertexNormals[i]);
        vertexIndex = face[faceIndex[i]];
        t = tan1[vertexIndex];
        tmp.copy(t);
        tmp.sub(n.multiplyScalar(n.dot(t))).normalize();
        tmp2.crossVectors(face.vertexNormals[i], t);
        test = tmp2.dot(tan2[vertexIndex]);
        w = test < 0 ? -1 : 1;
        face.vertexTangents[i] = new THREE.Vector4(tmp.x, tmp.y, tmp.z, w);
      }
    }
    this.hasTangents = true;
  },
  computeLineDistances: function () {
    var d = 0;
    var vertices = this.vertices;
    for (var i = 0, il = vertices.length; i < il; i++) {
      if (i > 0) {
        d += vertices[i].distanceTo(vertices[i - 1]);
      }
      this.lineDistances[i] = d;
    }
  },
  computeBoundingBox: function () {
    if (this.boundingBox === null) {
      this.boundingBox = new THREE.Box3();
    }
    this.boundingBox.setFromPoints(this.vertices);
  },
  computeBoundingSphere: function () {
    if (this.boundingSphere === null) {
      this.boundingSphere = new THREE.Sphere();
    }
    this.boundingSphere.setFromPoints(this.vertices);
  },
  mergeVertices: function () {
    var verticesMap = {};
    var unique = [], changes = [];
    var v, key;
    var precisionPoints = 4;
    var precision = Math.pow(10, precisionPoints);
    var i, il, face;
    var indices, k, j, jl, u;
    this.__tmpVertices = undefined;
    for (i = 0, il = this.vertices.length; i < il; i++) {
      v = this.vertices[i];
      key = Math.round(v.x * precision) + '_' + Math.round(v.y * precision) + '_' + Math.round(v.z * precision);
      if (verticesMap[key] === undefined) {
        verticesMap[key] = i;
        unique.push(this.vertices[i]);
        changes[i] = unique.length - 1;
      } else {
        changes[i] = changes[verticesMap[key]];
      }
    }
    ;
    var faceIndicesToRemove = [];
    for (i = 0, il = this.faces.length; i < il; i++) {
      face = this.faces[i];
      face.a = changes[face.a];
      face.b = changes[face.b];
      face.c = changes[face.c];
      indices = [
        face.a,
        face.b,
        face.c
      ];
      var dupIndex = -1;
      for (var n = 0; n < 3; n++) {
        if (indices[n] == indices[(n + 1) % 3]) {
          dupIndex = n;
          faceIndicesToRemove.push(i);
          break;
        }
      }
    }
    for (i = faceIndicesToRemove.length - 1; i >= 0; i--) {
      this.faces.splice(i, 1);
      for (j = 0, jl = this.faceVertexUvs.length; j < jl; j++) {
        this.faceVertexUvs[j].splice(i, 1);
      }
    }
    var diff = this.vertices.length - unique.length;
    this.vertices = unique;
    return diff;
  },
  clone: function () {
    var geometry = new THREE.Geometry();
    var vertices = this.vertices;
    for (var i = 0, il = vertices.length; i < il; i++) {
      geometry.vertices.push(vertices[i].clone());
    }
    var faces = this.faces;
    for (var i = 0, il = faces.length; i < il; i++) {
      geometry.faces.push(faces[i].clone());
    }
    var uvs = this.faceVertexUvs[0];
    for (var i = 0, il = uvs.length; i < il; i++) {
      var uv = uvs[i], uvCopy = [];
      for (var j = 0, jl = uv.length; j < jl; j++) {
        uvCopy.push(new THREE.Vector2(uv[j].x, uv[j].y));
      }
      geometry.faceVertexUvs[0].push(uvCopy);
    }
    return geometry;
  },
  dispose: function () {
    this.dispatchEvent({ type: 'dispose' });
  }
};
THREE.EventDispatcher.prototype.apply(THREE.Geometry.prototype);
THREE.GeometryIdCount = 0;
THREE.BufferGeometry = function () {
  this.id = THREE.GeometryIdCount++;
  this.uuid = THREE.Math.generateUUID();
  this.name = '';
  this.attributes = {};
  this.dynamic = true;
  this.offsets = [];
  this.boundingBox = null;
  this.boundingSphere = null;
  this.hasTangents = false;
  this.morphTargets = [];
};
THREE.BufferGeometry.prototype = {
  constructor: THREE.BufferGeometry,
  applyMatrix: function (matrix) {
    var positionArray;
    var normalArray;
    if (this.attributes['position'])
      positionArray = this.attributes['position'].array;
    if (this.attributes['normal'])
      normalArray = this.attributes['normal'].array;
    if (positionArray !== undefined) {
      matrix.multiplyVector3Array(positionArray);
      this.verticesNeedUpdate = true;
    }
    if (normalArray !== undefined) {
      var normalMatrix = new THREE.Matrix3().getNormalMatrix(matrix);
      normalMatrix.multiplyVector3Array(normalArray);
      this.normalizeNormals();
      this.normalsNeedUpdate = true;
    }
  },
  computeBoundingBox: function () {
    if (this.boundingBox === null) {
      this.boundingBox = new THREE.Box3();
    }
    var positions = this.attributes['position'].array;
    if (positions) {
      var bb = this.boundingBox;
      var x, y, z;
      if (positions.length >= 3) {
        bb.min.x = bb.max.x = positions[0];
        bb.min.y = bb.max.y = positions[1];
        bb.min.z = bb.max.z = positions[2];
      }
      for (var i = 3, il = positions.length; i < il; i += 3) {
        x = positions[i];
        y = positions[i + 1];
        z = positions[i + 2];
        if (x < bb.min.x) {
          bb.min.x = x;
        } else if (x > bb.max.x) {
          bb.max.x = x;
        }
        if (y < bb.min.y) {
          bb.min.y = y;
        } else if (y > bb.max.y) {
          bb.max.y = y;
        }
        if (z < bb.min.z) {
          bb.min.z = z;
        } else if (z > bb.max.z) {
          bb.max.z = z;
        }
      }
    }
    if (positions === undefined || positions.length === 0) {
      this.boundingBox.min.set(0, 0, 0);
      this.boundingBox.max.set(0, 0, 0);
    }
  },
  computeBoundingSphere: function () {
    var box = new THREE.Box3();
    var vector = new THREE.Vector3();
    return function () {
      if (this.boundingSphere === null) {
        this.boundingSphere = new THREE.Sphere();
      }
      var positions = this.attributes['position'].array;
      if (positions) {
        var center = this.boundingSphere.center;
        for (var i = 0, il = positions.length; i < il; i += 3) {
          vector.set(positions[i], positions[i + 1], positions[i + 2]);
          box.addPoint(vector);
        }
        box.center(center);
        var maxRadiusSq = 0;
        for (var i = 0, il = positions.length; i < il; i += 3) {
          vector.set(positions[i], positions[i + 1], positions[i + 2]);
          maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(vector));
        }
        this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
      }
    };
  }(),
  computeVertexNormals: function () {
    if (this.attributes['position']) {
      var i, il;
      var j, jl;
      var nVertexElements = this.attributes['position'].array.length;
      if (this.attributes['normal'] === undefined) {
        this.attributes['normal'] = {
          itemSize: 3,
          array: new Float32Array(nVertexElements)
        };
      } else {
        for (i = 0, il = this.attributes['normal'].array.length; i < il; i++) {
          this.attributes['normal'].array[i] = 0;
        }
      }
      var positions = this.attributes['position'].array;
      var normals = this.attributes['normal'].array;
      var vA, vB, vC, x, y, z, pA = new THREE.Vector3(), pB = new THREE.Vector3(), pC = new THREE.Vector3(), cb = new THREE.Vector3(), ab = new THREE.Vector3();
      if (this.attributes['index']) {
        var indices = this.attributes['index'].array;
        var offsets = this.offsets;
        for (j = 0, jl = offsets.length; j < jl; ++j) {
          var start = offsets[j].start;
          var count = offsets[j].count;
          var index = offsets[j].index;
          for (i = start, il = start + count; i < il; i += 3) {
            vA = index + indices[i];
            vB = index + indices[i + 1];
            vC = index + indices[i + 2];
            x = positions[vA * 3];
            y = positions[vA * 3 + 1];
            z = positions[vA * 3 + 2];
            pA.set(x, y, z);
            x = positions[vB * 3];
            y = positions[vB * 3 + 1];
            z = positions[vB * 3 + 2];
            pB.set(x, y, z);
            x = positions[vC * 3];
            y = positions[vC * 3 + 1];
            z = positions[vC * 3 + 2];
            pC.set(x, y, z);
            cb.subVectors(pC, pB);
            ab.subVectors(pA, pB);
            cb.cross(ab);
            normals[vA * 3] += cb.x;
            normals[vA * 3 + 1] += cb.y;
            normals[vA * 3 + 2] += cb.z;
            normals[vB * 3] += cb.x;
            normals[vB * 3 + 1] += cb.y;
            normals[vB * 3 + 2] += cb.z;
            normals[vC * 3] += cb.x;
            normals[vC * 3 + 1] += cb.y;
            normals[vC * 3 + 2] += cb.z;
          }
        }
      } else {
        for (i = 0, il = positions.length; i < il; i += 9) {
          x = positions[i];
          y = positions[i + 1];
          z = positions[i + 2];
          pA.set(x, y, z);
          x = positions[i + 3];
          y = positions[i + 4];
          z = positions[i + 5];
          pB.set(x, y, z);
          x = positions[i + 6];
          y = positions[i + 7];
          z = positions[i + 8];
          pC.set(x, y, z);
          cb.subVectors(pC, pB);
          ab.subVectors(pA, pB);
          cb.cross(ab);
          normals[i] = cb.x;
          normals[i + 1] = cb.y;
          normals[i + 2] = cb.z;
          normals[i + 3] = cb.x;
          normals[i + 4] = cb.y;
          normals[i + 5] = cb.z;
          normals[i + 6] = cb.x;
          normals[i + 7] = cb.y;
          normals[i + 8] = cb.z;
        }
      }
      this.normalizeNormals();
      this.normalsNeedUpdate = true;
    }
  },
  normalizeNormals: function () {
    var normals = this.attributes['normal'].array;
    var x, y, z, n;
    for (var i = 0, il = normals.length; i < il; i += 3) {
      x = normals[i];
      y = normals[i + 1];
      z = normals[i + 2];
      n = 1 / Math.sqrt(x * x + y * y + z * z);
      normals[i] *= n;
      normals[i + 1] *= n;
      normals[i + 2] *= n;
    }
  },
  computeTangents: function () {
    if (this.attributes['index'] === undefined || this.attributes['position'] === undefined || this.attributes['normal'] === undefined || this.attributes['uv'] === undefined) {
      console.warn('Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()');
      return;
    }
    var indices = this.attributes['index'].array;
    var positions = this.attributes['position'].array;
    var normals = this.attributes['normal'].array;
    var uvs = this.attributes['uv'].array;
    var nVertices = positions.length / 3;
    if (this.attributes['tangent'] === undefined) {
      var nTangentElements = 4 * nVertices;
      this.attributes['tangent'] = {
        itemSize: 4,
        array: new Float32Array(nTangentElements)
      };
    }
    var tangents = this.attributes['tangent'].array;
    var tan1 = [], tan2 = [];
    for (var k = 0; k < nVertices; k++) {
      tan1[k] = new THREE.Vector3();
      tan2[k] = new THREE.Vector3();
    }
    var xA, yA, zA, xB, yB, zB, xC, yC, zC, uA, vA, uB, vB, uC, vC, x1, x2, y1, y2, z1, z2, s1, s2, t1, t2, r;
    var sdir = new THREE.Vector3(), tdir = new THREE.Vector3();
    function handleTriangle(a, b, c) {
      xA = positions[a * 3];
      yA = positions[a * 3 + 1];
      zA = positions[a * 3 + 2];
      xB = positions[b * 3];
      yB = positions[b * 3 + 1];
      zB = positions[b * 3 + 2];
      xC = positions[c * 3];
      yC = positions[c * 3 + 1];
      zC = positions[c * 3 + 2];
      uA = uvs[a * 2];
      vA = uvs[a * 2 + 1];
      uB = uvs[b * 2];
      vB = uvs[b * 2 + 1];
      uC = uvs[c * 2];
      vC = uvs[c * 2 + 1];
      x1 = xB - xA;
      x2 = xC - xA;
      y1 = yB - yA;
      y2 = yC - yA;
      z1 = zB - zA;
      z2 = zC - zA;
      s1 = uB - uA;
      s2 = uC - uA;
      t1 = vB - vA;
      t2 = vC - vA;
      r = 1 / (s1 * t2 - s2 * t1);
      sdir.set((t2 * x1 - t1 * x2) * r, (t2 * y1 - t1 * y2) * r, (t2 * z1 - t1 * z2) * r);
      tdir.set((s1 * x2 - s2 * x1) * r, (s1 * y2 - s2 * y1) * r, (s1 * z2 - s2 * z1) * r);
      tan1[a].add(sdir);
      tan1[b].add(sdir);
      tan1[c].add(sdir);
      tan2[a].add(tdir);
      tan2[b].add(tdir);
      tan2[c].add(tdir);
    }
    var i, il;
    var j, jl;
    var iA, iB, iC;
    var offsets = this.offsets;
    for (j = 0, jl = offsets.length; j < jl; ++j) {
      var start = offsets[j].start;
      var count = offsets[j].count;
      var index = offsets[j].index;
      for (i = start, il = start + count; i < il; i += 3) {
        iA = index + indices[i];
        iB = index + indices[i + 1];
        iC = index + indices[i + 2];
        handleTriangle(iA, iB, iC);
      }
    }
    var tmp = new THREE.Vector3(), tmp2 = new THREE.Vector3();
    var n = new THREE.Vector3(), n2 = new THREE.Vector3();
    var w, t, test;
    function handleVertex(v) {
      n.x = normals[v * 3];
      n.y = normals[v * 3 + 1];
      n.z = normals[v * 3 + 2];
      n2.copy(n);
      t = tan1[v];
      tmp.copy(t);
      tmp.sub(n.multiplyScalar(n.dot(t))).normalize();
      tmp2.crossVectors(n2, t);
      test = tmp2.dot(tan2[v]);
      w = test < 0 ? -1 : 1;
      tangents[v * 4] = tmp.x;
      tangents[v * 4 + 1] = tmp.y;
      tangents[v * 4 + 2] = tmp.z;
      tangents[v * 4 + 3] = w;
    }
    for (j = 0, jl = offsets.length; j < jl; ++j) {
      var start = offsets[j].start;
      var count = offsets[j].count;
      var index = offsets[j].index;
      for (i = start, il = start + count; i < il; i += 3) {
        iA = index + indices[i];
        iB = index + indices[i + 1];
        iC = index + indices[i + 2];
        handleVertex(iA);
        handleVertex(iB);
        handleVertex(iC);
      }
    }
    this.hasTangents = true;
    this.tangentsNeedUpdate = true;
  },
  dispose: function () {
    this.dispatchEvent({ type: 'dispose' });
  }
};
THREE.EventDispatcher.prototype.apply(THREE.BufferGeometry.prototype);
THREE.Camera = function () {
  THREE.Object3D.call(this);
  this.matrixWorldInverse = new THREE.Matrix4();
  this.projectionMatrix = new THREE.Matrix4();
  this.projectionMatrixInverse = new THREE.Matrix4();
};
THREE.Camera.prototype = Object.create(THREE.Object3D.prototype);
THREE.Camera.prototype.lookAt = function () {
  var m1 = new THREE.Matrix4();
  return function (vector) {
    m1.lookAt(this.position, vector, this.up);
    this.quaternion.setFromRotationMatrix(m1);
  };
}();
THREE.Camera.prototype.clone = function (camera) {
  if (camera === undefined)
    camera = new THREE.Camera();
  THREE.Object3D.prototype.clone.call(this, camera);
  camera.matrixWorldInverse.copy(this.matrixWorldInverse);
  camera.projectionMatrix.copy(this.projectionMatrix);
  camera.projectionMatrixInverse.copy(this.projectionMatrixInverse);
  return camera;
};
THREE.OrthographicCamera = function (left, right, top, bottom, near, far) {
  THREE.Camera.call(this);
  this.left = left;
  this.right = right;
  this.top = top;
  this.bottom = bottom;
  this.near = near !== undefined ? near : 0.1;
  this.far = far !== undefined ? far : 2000;
  this.updateProjectionMatrix();
};
THREE.OrthographicCamera.prototype = Object.create(THREE.Camera.prototype);
THREE.OrthographicCamera.prototype.updateProjectionMatrix = function () {
  this.projectionMatrix.makeOrthographic(this.left, this.right, this.top, this.bottom, this.near, this.far);
};
THREE.OrthographicCamera.prototype.clone = function () {
  var camera = new THREE.OrthographicCamera();
  THREE.Camera.prototype.clone.call(this, camera);
  camera.left = this.left;
  camera.right = this.right;
  camera.top = this.top;
  camera.bottom = this.bottom;
  camera.near = this.near;
  camera.far = this.far;
  return camera;
};
THREE.PerspectiveCamera = function (fov, aspect, near, far) {
  THREE.Camera.call(this);
  this.fov = fov !== undefined ? fov : 50;
  this.aspect = aspect !== undefined ? aspect : 1;
  this.near = near !== undefined ? near : 0.1;
  this.far = far !== undefined ? far : 2000;
  this.updateProjectionMatrix();
};
THREE.PerspectiveCamera.prototype = Object.create(THREE.Camera.prototype);
THREE.PerspectiveCamera.prototype.setLens = function (focalLength, frameHeight) {
  if (frameHeight === undefined)
    frameHeight = 24;
  this.fov = 2 * THREE.Math.radToDeg(Math.atan(frameHeight / (focalLength * 2)));
  this.updateProjectionMatrix();
};
THREE.PerspectiveCamera.prototype.setViewOffset = function (fullWidth, fullHeight, x, y, width, height) {
  this.fullWidth = fullWidth;
  this.fullHeight = fullHeight;
  this.x = x;
  this.y = y;
  this.width = width;
  this.height = height;
  this.updateProjectionMatrix();
};
THREE.PerspectiveCamera.prototype.updateProjectionMatrix = function () {
  if (this.fullWidth) {
    var aspect = this.fullWidth / this.fullHeight;
    var top = Math.tan(THREE.Math.degToRad(this.fov * 0.5)) * this.near;
    var bottom = -top;
    var left = aspect * bottom;
    var right = aspect * top;
    var width = Math.abs(right - left);
    var height = Math.abs(top - bottom);
    this.projectionMatrix.makeFrustum(left + this.x * width / this.fullWidth, left + (this.x + this.width) * width / this.fullWidth, top - (this.y + this.height) * height / this.fullHeight, top - this.y * height / this.fullHeight, this.near, this.far);
  } else {
    this.projectionMatrix.makePerspective(this.fov, this.aspect, this.near, this.far);
  }
};
THREE.PerspectiveCamera.prototype.clone = function () {
  var camera = new THREE.PerspectiveCamera();
  THREE.Camera.prototype.clone.call(this, camera);
  camera.fov = this.fov;
  camera.aspect = this.aspect;
  camera.near = this.near;
  camera.far = this.far;
  return camera;
};
THREE.Light = function (hex) {
  THREE.Object3D.call(this);
  this.color = new THREE.Color(hex);
};
THREE.Light.prototype = Object.create(THREE.Object3D.prototype);
THREE.Light.prototype.clone = function (light) {
  if (light === undefined)
    light = new THREE.Light();
  THREE.Object3D.prototype.clone.call(this, light);
  light.color.copy(this.color);
  return light;
};
THREE.AmbientLight = function (hex) {
  THREE.Light.call(this, hex);
};
THREE.AmbientLight.prototype = Object.create(THREE.Light.prototype);
THREE.AmbientLight.prototype.clone = function () {
  var light = new THREE.AmbientLight();
  THREE.Light.prototype.clone.call(this, light);
  return light;
};
THREE.AreaLight = function (hex, intensity) {
  THREE.Light.call(this, hex);
  this.normal = new THREE.Vector3(0, -1, 0);
  this.right = new THREE.Vector3(1, 0, 0);
  this.intensity = intensity !== undefined ? intensity : 1;
  this.width = 1;
  this.height = 1;
  this.constantAttenuation = 1.5;
  this.linearAttenuation = 0.5;
  this.quadraticAttenuation = 0.1;
};
THREE.AreaLight.prototype = Object.create(THREE.Light.prototype);
THREE.DirectionalLight = function (hex, intensity) {
  THREE.Light.call(this, hex);
  this.position.set(0, 1, 0);
  this.target = new THREE.Object3D();
  this.intensity = intensity !== undefined ? intensity : 1;
  this.castShadow = false;
  this.onlyShadow = false;
  this.shadowCameraNear = 50;
  this.shadowCameraFar = 5000;
  this.shadowCameraLeft = -500;
  this.shadowCameraRight = 500;
  this.shadowCameraTop = 500;
  this.shadowCameraBottom = -500;
  this.shadowCameraVisible = false;
  this.shadowBias = 0;
  this.shadowDarkness = 0.5;
  this.shadowMapWidth = 512;
  this.shadowMapHeight = 512;
  this.shadowCascade = false;
  this.shadowCascadeOffset = new THREE.Vector3(0, 0, -1000);
  this.shadowCascadeCount = 2;
  this.shadowCascadeBias = [
    0,
    0,
    0
  ];
  this.shadowCascadeWidth = [
    512,
    512,
    512
  ];
  this.shadowCascadeHeight = [
    512,
    512,
    512
  ];
  this.shadowCascadeNearZ = [
    -1,
    0.99,
    0.998
  ];
  this.shadowCascadeFarZ = [
    0.99,
    0.998,
    1
  ];
  this.shadowCascadeArray = [];
  this.shadowMap = null;
  this.shadowMapSize = null;
  this.shadowCamera = null;
  this.shadowMatrix = null;
};
THREE.DirectionalLight.prototype = Object.create(THREE.Light.prototype);
THREE.DirectionalLight.prototype.clone = function () {
  var light = new THREE.DirectionalLight();
  THREE.Light.prototype.clone.call(this, light);
  light.target = this.target.clone();
  light.intensity = this.intensity;
  light.castShadow = this.castShadow;
  light.onlyShadow = this.onlyShadow;
  return light;
};
THREE.HemisphereLight = function (skyColorHex, groundColorHex, intensity) {
  THREE.Light.call(this, skyColorHex);
  this.position.set(0, 100, 0);
  this.groundColor = new THREE.Color(groundColorHex);
  this.intensity = intensity !== undefined ? intensity : 1;
};
THREE.HemisphereLight.prototype = Object.create(THREE.Light.prototype);
THREE.HemisphereLight.prototype.clone = function () {
  var light = new THREE.HemisphereLight();
  THREE.Light.prototype.clone.call(this, light);
  light.groundColor.copy(this.groundColor);
  light.intensity = this.intensity;
  return light;
};
THREE.PointLight = function (hex, intensity, distance) {
  THREE.Light.call(this, hex);
  this.intensity = intensity !== undefined ? intensity : 1;
  this.distance = distance !== undefined ? distance : 0;
};
THREE.PointLight.prototype = Object.create(THREE.Light.prototype);
THREE.PointLight.prototype.clone = function () {
  var light = new THREE.PointLight();
  THREE.Light.prototype.clone.call(this, light);
  light.intensity = this.intensity;
  light.distance = this.distance;
  return light;
};
THREE.SpotLight = function (hex, intensity, distance, angle, exponent) {
  THREE.Light.call(this, hex);
  this.position.set(0, 1, 0);
  this.target = new THREE.Object3D();
  this.intensity = intensity !== undefined ? intensity : 1;
  this.distance = distance !== undefined ? distance : 0;
  this.angle = angle !== undefined ? angle : Math.PI / 3;
  this.exponent = exponent !== undefined ? exponent : 10;
  this.castShadow = false;
  this.onlyShadow = false;
  this.shadowCameraNear = 50;
  this.shadowCameraFar = 5000;
  this.shadowCameraFov = 50;
  this.shadowCameraVisible = false;
  this.shadowBias = 0;
  this.shadowDarkness = 0.5;
  this.shadowMapWidth = 512;
  this.shadowMapHeight = 512;
  this.shadowMap = null;
  this.shadowMapSize = null;
  this.shadowCamera = null;
  this.shadowMatrix = null;
};
THREE.SpotLight.prototype = Object.create(THREE.Light.prototype);
THREE.SpotLight.prototype.clone = function () {
  var light = new THREE.SpotLight();
  THREE.Light.prototype.clone.call(this, light);
  light.target = this.target.clone();
  light.intensity = this.intensity;
  light.distance = this.distance;
  light.angle = this.angle;
  light.exponent = this.exponent;
  light.castShadow = this.castShadow;
  light.onlyShadow = this.onlyShadow;
  return light;
};
THREE.Loader = function (showStatus) {
  this.showStatus = showStatus;
  this.statusDomElement = showStatus ? THREE.Loader.prototype.addStatusElement() : null;
  this.onLoadStart = function () {
  };
  this.onLoadProgress = function () {
  };
  this.onLoadComplete = function () {
  };
};
THREE.Loader.prototype = {
  constructor: THREE.Loader,
  crossOrigin: 'anonymous',
  addStatusElement: function () {
    var e = document.createElement('div');
    e.style.position = 'absolute';
    e.style.right = '0px';
    e.style.top = '0px';
    e.style.fontSize = '0.8em';
    e.style.textAlign = 'left';
    e.style.background = 'rgba(0,0,0,0.25)';
    e.style.color = '#fff';
    e.style.width = '120px';
    e.style.padding = '0.5em 0.5em 0.5em 0.5em';
    e.style.zIndex = 1000;
    e.innerHTML = 'Loading ...';
    return e;
  },
  updateProgress: function (progress) {
    var message = 'Loaded ';
    if (progress.total) {
      message += (100 * progress.loaded / progress.total).toFixed(0) + '%';
    } else {
      message += (progress.loaded / 1000).toFixed(2) + ' KB';
    }
    this.statusDomElement.innerHTML = message;
  },
  extractUrlBase: function (url) {
    var parts = url.split('/');
    parts.pop();
    return (parts.length < 1 ? '.' : parts.join('/')) + '/';
  },
  initMaterials: function (materials, texturePath) {
    var array = [];
    for (var i = 0; i < materials.length; ++i) {
      array[i] = THREE.Loader.prototype.createMaterial(materials[i], texturePath);
    }
    return array;
  },
  needsTangents: function (materials) {
    for (var i = 0, il = materials.length; i < il; i++) {
      var m = materials[i];
      if (m instanceof THREE.ShaderMaterial)
        return true;
    }
    return false;
  },
  createMaterial: function (m, texturePath) {
    var _this = this;
    function is_pow2(n) {
      var l = Math.log(n) / Math.LN2;
      return Math.floor(l) == l;
    }
    function nearest_pow2(n) {
      var l = Math.log(n) / Math.LN2;
      return Math.pow(2, Math.round(l));
    }
    function load_image(where, url) {
      var image = new Image();
      image.onload = function () {
        if (!is_pow2(this.width) || !is_pow2(this.height)) {
          var width = nearest_pow2(this.width);
          var height = nearest_pow2(this.height);
          where.image.width = width;
          where.image.height = height;
          where.image.getContext('2d').drawImage(this, 0, 0, width, height);
        } else {
          where.image = this;
        }
        where.needsUpdate = true;
      };
      image.crossOrigin = _this.crossOrigin;
      image.src = url;
    }
    function create_texture(where, name, sourceFile, repeat, offset, wrap, anisotropy) {
      var isCompressed = /\.dds$/i.test(sourceFile);
      var fullPath = texturePath + '/' + sourceFile;
      if (isCompressed) {
        var texture = THREE.ImageUtils.loadCompressedTexture(fullPath);
        where[name] = texture;
      } else {
        var texture = document.createElement('canvas');
        where[name] = new THREE.Texture(texture);
      }
      where[name].sourceFile = sourceFile;
      if (repeat) {
        where[name].repeat.set(repeat[0], repeat[1]);
        if (repeat[0] !== 1)
          where[name].wrapS = THREE.RepeatWrapping;
        if (repeat[1] !== 1)
          where[name].wrapT = THREE.RepeatWrapping;
      }
      if (offset) {
        where[name].offset.set(offset[0], offset[1]);
      }
      if (wrap) {
        var wrapMap = {
            'repeat': THREE.RepeatWrapping,
            'mirror': THREE.MirroredRepeatWrapping
          };
        if (wrapMap[wrap[0]] !== undefined)
          where[name].wrapS = wrapMap[wrap[0]];
        if (wrapMap[wrap[1]] !== undefined)
          where[name].wrapT = wrapMap[wrap[1]];
      }
      if (anisotropy) {
        where[name].anisotropy = anisotropy;
      }
      if (!isCompressed) {
        load_image(where[name], fullPath);
      }
    }
    function rgb2hex(rgb) {
      return (rgb[0] * 255 << 16) + (rgb[1] * 255 << 8) + rgb[2] * 255;
    }
    var mtype = 'MeshLambertMaterial';
    var mpars = {
        color: 15658734,
        opacity: 1,
        map: null,
        lightMap: null,
        normalMap: null,
        bumpMap: null,
        wireframe: false
      };
    if (m.shading) {
      var shading = m.shading.toLowerCase();
      if (shading === 'phong')
        mtype = 'MeshPhongMaterial';
      else if (shading === 'basic')
        mtype = 'MeshBasicMaterial';
    }
    if (m.blending !== undefined && THREE[m.blending] !== undefined) {
      mpars.blending = THREE[m.blending];
    }
    if (m.transparent !== undefined || m.opacity < 1) {
      mpars.transparent = m.transparent;
    }
    if (m.depthTest !== undefined) {
      mpars.depthTest = m.depthTest;
    }
    if (m.depthWrite !== undefined) {
      mpars.depthWrite = m.depthWrite;
    }
    if (m.visible !== undefined) {
      mpars.visible = m.visible;
    }
    if (m.flipSided !== undefined) {
      mpars.side = THREE.BackSide;
    }
    if (m.doubleSided !== undefined) {
      mpars.side = THREE.DoubleSide;
    }
    if (m.wireframe !== undefined) {
      mpars.wireframe = m.wireframe;
    }
    if (m.vertexColors !== undefined) {
      if (m.vertexColors === 'face') {
        mpars.vertexColors = THREE.FaceColors;
      } else if (m.vertexColors) {
        mpars.vertexColors = THREE.VertexColors;
      }
    }
    if (m.colorDiffuse) {
      mpars.color = rgb2hex(m.colorDiffuse);
    } else if (m.DbgColor) {
      mpars.color = m.DbgColor;
    }
    if (m.colorSpecular) {
      mpars.specular = rgb2hex(m.colorSpecular);
    }
    if (m.colorAmbient) {
      mpars.ambient = rgb2hex(m.colorAmbient);
    }
    if (m.transparency) {
      mpars.opacity = m.transparency;
    }
    if (m.specularCoef) {
      mpars.shininess = m.specularCoef;
    }
    if (m.mapDiffuse && texturePath) {
      create_texture(mpars, 'map', m.mapDiffuse, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy);
    }
    if (m.mapLight && texturePath) {
      create_texture(mpars, 'lightMap', m.mapLight, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy);
    }
    if (m.mapBump && texturePath) {
      create_texture(mpars, 'bumpMap', m.mapBump, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy);
    }
    if (m.mapNormal && texturePath) {
      create_texture(mpars, 'normalMap', m.mapNormal, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy);
    }
    if (m.mapSpecular && texturePath) {
      create_texture(mpars, 'specularMap', m.mapSpecular, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy);
    }
    if (m.mapBumpScale) {
      mpars.bumpScale = m.mapBumpScale;
    }
    if (m.mapNormal) {
      var shader = THREE.ShaderLib['normalmap'];
      var uniforms = THREE.UniformsUtils.clone(shader.uniforms);
      uniforms['tNormal'].value = mpars.normalMap;
      if (m.mapNormalFactor) {
        uniforms['uNormalScale'].value.set(m.mapNormalFactor, m.mapNormalFactor);
      }
      if (mpars.map) {
        uniforms['tDiffuse'].value = mpars.map;
        uniforms['enableDiffuse'].value = true;
      }
      if (mpars.specularMap) {
        uniforms['tSpecular'].value = mpars.specularMap;
        uniforms['enableSpecular'].value = true;
      }
      if (mpars.lightMap) {
        uniforms['tAO'].value = mpars.lightMap;
        uniforms['enableAO'].value = true;
      }
      uniforms['uDiffuseColor'].value.setHex(mpars.color);
      uniforms['uSpecularColor'].value.setHex(mpars.specular);
      uniforms['uAmbientColor'].value.setHex(mpars.ambient);
      uniforms['uShininess'].value = mpars.shininess;
      if (mpars.opacity !== undefined) {
        uniforms['uOpacity'].value = mpars.opacity;
      }
      var parameters = {
          fragmentShader: shader.fragmentShader,
          vertexShader: shader.vertexShader,
          uniforms: uniforms,
          lights: true,
          fog: true
        };
      var material = new THREE.ShaderMaterial(parameters);
      if (mpars.transparent) {
        material.transparent = true;
      }
    } else {
      var material = new THREE[mtype](mpars);
    }
    if (m.DbgName !== undefined)
      material.name = m.DbgName;
    return material;
  }
};
THREE.XHRLoader = function (manager) {
  this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;
};
THREE.XHRLoader.prototype = {
  constructor: THREE.XHRLoader,
  load: function (url, onLoad, onProgress, onError) {
    var scope = this;
    var request = new XMLHttpRequest();
    if (onLoad !== undefined) {
      request.addEventListener('load', function (event) {
        onLoad(event.target.responseText);
        scope.manager.itemEnd(url);
      }, false);
    }
    if (onProgress !== undefined) {
      request.addEventListener('progress', function (event) {
        onProgress(event);
      }, false);
    }
    if (onError !== undefined) {
      request.addEventListener('error', function (event) {
        onError(event);
      }, false);
    }
    if (this.crossOrigin !== undefined)
      request.crossOrigin = this.crossOrigin;
    request.open('GET', url, true);
    request.send(null);
    scope.manager.itemStart(url);
  },
  setCrossOrigin: function (value) {
    this.crossOrigin = value;
  }
};
THREE.ImageLoader = function (manager) {
  this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;
};
THREE.ImageLoader.prototype = {
  constructor: THREE.ImageLoader,
  load: function (url, onLoad, onProgress, onError) {
    var scope = this;
    var image = document.createElement('img');
    if (onLoad !== undefined) {
      image.addEventListener('load', function (event) {
        scope.manager.itemEnd(url);
        onLoad(this);
      }, false);
    }
    if (onProgress !== undefined) {
      image.addEventListener('progress', function (event) {
        onProgress(event);
      }, false);
    }
    if (onError !== undefined) {
      image.addEventListener('error', function (event) {
        onError(event);
      }, false);
    }
    if (this.crossOrigin !== undefined)
      image.crossOrigin = this.crossOrigin;
    image.src = url;
    scope.manager.itemStart(url);
  },
  setCrossOrigin: function (value) {
    this.crossOrigin = value;
  }
};
THREE.JSONLoader = function (showStatus) {
  THREE.Loader.call(this, showStatus);
  this.withCredentials = false;
};
THREE.JSONLoader.prototype = Object.create(THREE.Loader.prototype);
THREE.JSONLoader.prototype.load = function (url, callback, texturePath) {
  var scope = this;
  texturePath = texturePath && typeof texturePath === 'string' ? texturePath : this.extractUrlBase(url);
  this.onLoadStart();
  this.loadAjaxJSON(this, url, callback, texturePath);
};
THREE.JSONLoader.prototype.loadAjaxJSON = function (context, url, callback, texturePath, callbackProgress) {
  var xhr = new XMLHttpRequest();
  var length = 0;
  xhr.onreadystatechange = function () {
    if (xhr.readyState === xhr.DONE) {
      if (xhr.status === 200 || xhr.status === 0) {
        if (xhr.responseText) {
          var json = JSON.parse(xhr.responseText);
          var result = context.parse(json, texturePath);
          callback(result.geometry, result.materials);
        } else {
          console.warn('THREE.JSONLoader: [' + url + '] seems to be unreachable or file there is empty');
        }
        context.onLoadComplete();
      } else {
        console.error('THREE.JSONLoader: Couldn\'t load [' + url + '] [' + xhr.status + ']');
      }
    } else if (xhr.readyState === xhr.LOADING) {
      if (callbackProgress) {
        if (length === 0) {
          length = xhr.getResponseHeader('Content-Length');
        }
        callbackProgress({
          total: length,
          loaded: xhr.responseText.length
        });
      }
    } else if (xhr.readyState === xhr.HEADERS_RECEIVED) {
      if (callbackProgress !== undefined) {
        length = xhr.getResponseHeader('Content-Length');
      }
    }
  };
  xhr.open('GET', url, true);
  xhr.withCredentials = this.withCredentials;
  xhr.send(null);
};
THREE.JSONLoader.prototype.parse = function (json, texturePath) {
  var scope = this, geometry = new THREE.Geometry(), scale = json.scale !== undefined ? 1 / json.scale : 1;
  parseModel(scale);
  parseSkin();
  parseMorphing(scale);
  geometry.computeCentroids();
  geometry.computeFaceNormals();
  geometry.computeBoundingSphere();
  function parseModel(scale) {
    function isBitSet(value, position) {
      return value & 1 << position;
    }
    var i, j, fi, offset, zLength, colorIndex, normalIndex, uvIndex, materialIndex, type, isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor, vertex, face, faceA, faceB, color, hex, normal, uvLayer, uv, u, v, faces = json.faces, vertices = json.vertices, normals = json.normals, colors = json.colors, nUvLayers = 0;
    if (json.uvs !== undefined) {
      for (i = 0; i < json.uvs.length; i++) {
        if (json.uvs[i].length)
          nUvLayers++;
      }
      for (i = 0; i < nUvLayers; i++) {
        geometry.faceVertexUvs[i] = [];
      }
    }
    offset = 0;
    zLength = vertices.length;
    while (offset < zLength) {
      vertex = new THREE.Vector3();
      vertex.x = vertices[offset++] * scale;
      vertex.y = vertices[offset++] * scale;
      vertex.z = vertices[offset++] * scale;
      geometry.vertices.push(vertex);
    }
    offset = 0;
    zLength = faces.length;
    while (offset < zLength) {
      type = faces[offset++];
      isQuad = isBitSet(type, 0);
      hasMaterial = isBitSet(type, 1);
      hasFaceVertexUv = isBitSet(type, 3);
      hasFaceNormal = isBitSet(type, 4);
      hasFaceVertexNormal = isBitSet(type, 5);
      hasFaceColor = isBitSet(type, 6);
      hasFaceVertexColor = isBitSet(type, 7);
      if (isQuad) {
        faceA = new THREE.Face3();
        faceA.a = faces[offset];
        faceA.b = faces[offset + 1];
        faceA.c = faces[offset + 3];
        faceB = new THREE.Face3();
        faceB.a = faces[offset + 1];
        faceB.b = faces[offset + 2];
        faceB.c = faces[offset + 3];
        offset += 4;
        if (hasMaterial) {
          materialIndex = faces[offset++];
          faceA.materialIndex = materialIndex;
          faceB.materialIndex = materialIndex;
        }
        fi = geometry.faces.length;
        if (hasFaceVertexUv) {
          for (i = 0; i < nUvLayers; i++) {
            uvLayer = json.uvs[i];
            geometry.faceVertexUvs[i][fi] = [];
            geometry.faceVertexUvs[i][fi + 1] = [];
            for (j = 0; j < 4; j++) {
              uvIndex = faces[offset++];
              u = uvLayer[uvIndex * 2];
              v = uvLayer[uvIndex * 2 + 1];
              uv = new THREE.Vector2(u, v);
              if (j !== 2)
                geometry.faceVertexUvs[i][fi].push(uv);
              if (j !== 0)
                geometry.faceVertexUvs[i][fi + 1].push(uv);
            }
          }
        }
        if (hasFaceNormal) {
          normalIndex = faces[offset++] * 3;
          faceA.normal.set(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);
          faceB.normal.copy(faceA.normal);
        }
        if (hasFaceVertexNormal) {
          for (i = 0; i < 4; i++) {
            normalIndex = faces[offset++] * 3;
            normal = new THREE.Vector3(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);
            if (i !== 2)
              faceA.vertexNormals.push(normal);
            if (i !== 0)
              faceB.vertexNormals.push(normal);
          }
        }
        if (hasFaceColor) {
          colorIndex = faces[offset++];
          hex = colors[colorIndex];
          faceA.color.setHex(hex);
          faceB.color.setHex(hex);
        }
        if (hasFaceVertexColor) {
          for (i = 0; i < 4; i++) {
            colorIndex = faces[offset++];
            hex = colors[colorIndex];
            if (i !== 2)
              faceA.vertexColors.push(new THREE.Color(hex));
            if (i !== 0)
              faceB.vertexColors.push(new THREE.Color(hex));
          }
        }
        geometry.faces.push(faceA);
        geometry.faces.push(faceB);
      } else {
        face = new THREE.Face3();
        face.a = faces[offset++];
        face.b = faces[offset++];
        face.c = faces[offset++];
        if (hasMaterial) {
          materialIndex = faces[offset++];
          face.materialIndex = materialIndex;
        }
        fi = geometry.faces.length;
        if (hasFaceVertexUv) {
          for (i = 0; i < nUvLayers; i++) {
            uvLayer = json.uvs[i];
            geometry.faceVertexUvs[i][fi] = [];
            for (j = 0; j < 3; j++) {
              uvIndex = faces[offset++];
              u = uvLayer[uvIndex * 2];
              v = uvLayer[uvIndex * 2 + 1];
              uv = new THREE.Vector2(u, v);
              geometry.faceVertexUvs[i][fi].push(uv);
            }
          }
        }
        if (hasFaceNormal) {
          normalIndex = faces[offset++] * 3;
          face.normal.set(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);
        }
        if (hasFaceVertexNormal) {
          for (i = 0; i < 3; i++) {
            normalIndex = faces[offset++] * 3;
            normal = new THREE.Vector3(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);
            face.vertexNormals.push(normal);
          }
        }
        if (hasFaceColor) {
          colorIndex = faces[offset++];
          face.color.setHex(colors[colorIndex]);
        }
        if (hasFaceVertexColor) {
          for (i = 0; i < 3; i++) {
            colorIndex = faces[offset++];
            face.vertexColors.push(new THREE.Color(colors[colorIndex]));
          }
        }
        geometry.faces.push(face);
      }
    }
  }
  ;
  function parseSkin() {
    var i, l, x, y, z, w, a, b, c, d;
    if (json.skinWeights) {
      for (i = 0, l = json.skinWeights.length; i < l; i += 2) {
        x = json.skinWeights[i];
        y = json.skinWeights[i + 1];
        z = 0;
        w = 0;
        geometry.skinWeights.push(new THREE.Vector4(x, y, z, w));
      }
    }
    if (json.skinIndices) {
      for (i = 0, l = json.skinIndices.length; i < l; i += 2) {
        a = json.skinIndices[i];
        b = json.skinIndices[i + 1];
        c = 0;
        d = 0;
        geometry.skinIndices.push(new THREE.Vector4(a, b, c, d));
      }
    }
    geometry.bones = json.bones;
    geometry.animation = json.animation;
  }
  ;
  function parseMorphing(scale) {
    if (json.morphTargets !== undefined) {
      var i, l, v, vl, dstVertices, srcVertices;
      for (i = 0, l = json.morphTargets.length; i < l; i++) {
        geometry.morphTargets[i] = {};
        geometry.morphTargets[i].name = json.morphTargets[i].name;
        geometry.morphTargets[i].vertices = [];
        dstVertices = geometry.morphTargets[i].vertices;
        srcVertices = json.morphTargets[i].vertices;
        for (v = 0, vl = srcVertices.length; v < vl; v += 3) {
          var vertex = new THREE.Vector3();
          vertex.x = srcVertices[v] * scale;
          vertex.y = srcVertices[v + 1] * scale;
          vertex.z = srcVertices[v + 2] * scale;
          dstVertices.push(vertex);
        }
      }
    }
    if (json.morphColors !== undefined) {
      var i, l, c, cl, dstColors, srcColors, color;
      for (i = 0, l = json.morphColors.length; i < l; i++) {
        geometry.morphColors[i] = {};
        geometry.morphColors[i].name = json.morphColors[i].name;
        geometry.morphColors[i].colors = [];
        dstColors = geometry.morphColors[i].colors;
        srcColors = json.morphColors[i].colors;
        for (c = 0, cl = srcColors.length; c < cl; c += 3) {
          color = new THREE.Color(16755200);
          color.setRGB(srcColors[c], srcColors[c + 1], srcColors[c + 2]);
          dstColors.push(color);
        }
      }
    }
  }
  ;
  if (json.materials === undefined) {
    return { geometry: geometry };
  } else {
    var materials = this.initMaterials(json.materials, texturePath);
    if (this.needsTangents(materials)) {
      geometry.computeTangents();
    }
    return {
      geometry: geometry,
      materials: materials
    };
  }
};
THREE.LoadingManager = function (onLoad, onProgress, onError) {
  var scope = this;
  var loaded = 0, total = 0;
  this.onLoad = onLoad;
  this.onProgress = onProgress;
  this.onError = onError;
  this.itemStart = function (url) {
    total++;
  };
  this.itemEnd = function (url) {
    loaded++;
    if (scope.onProgress !== undefined) {
      scope.onProgress(url, loaded, total);
    }
    if (loaded === total && scope.onLoad !== undefined) {
      scope.onLoad();
    }
  };
};
THREE.DefaultLoadingManager = new THREE.LoadingManager();
THREE.BufferGeometryLoader = function (manager) {
  this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;
};
THREE.BufferGeometryLoader.prototype = {
  constructor: THREE.BufferGeometryLoader,
  load: function (url, onLoad, onProgress, onError) {
    var scope = this;
    var loader = new THREE.XHRLoader();
    loader.setCrossOrigin(this.crossOrigin);
    loader.load(url, function (text) {
      onLoad(scope.parse(JSON.parse(text)));
    });
  },
  setCrossOrigin: function (value) {
    this.crossOrigin = value;
  },
  parse: function (json) {
    var geometry = new THREE.BufferGeometry();
    var attributes = json.attributes;
    var offsets = json.offsets;
    var boundingSphere = json.boundingSphere;
    for (var key in attributes) {
      var attribute = attributes[key];
      geometry.attributes[key] = {
        itemSize: attribute.itemSize,
        array: new self[attribute.type](attribute.array)
      };
    }
    if (offsets !== undefined) {
      geometry.offsets = JSON.parse(JSON.stringify(offsets));
    }
    if (boundingSphere !== undefined) {
      geometry.boundingSphere = new THREE.Sphere(new THREE.Vector3().fromArray(boundingSphere.center !== undefined ? boundingSphere.center : [
        0,
        0,
        0
      ]), boundingSphere.radius);
    }
    return geometry;
  }
};
THREE.GeometryLoader = function (manager) {
  this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;
};
THREE.GeometryLoader.prototype = {
  constructor: THREE.GeometryLoader,
  load: function (url, onLoad, onProgress, onError) {
    var scope = this;
    var loader = new THREE.XHRLoader();
    loader.setCrossOrigin(this.crossOrigin);
    loader.load(url, function (text) {
      onLoad(scope.parse(JSON.parse(text)));
    });
  },
  setCrossOrigin: function (value) {
    this.crossOrigin = value;
  },
  parse: function (json) {
  }
};
THREE.MaterialLoader = function (manager) {
  this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;
};
THREE.MaterialLoader.prototype = {
  constructor: THREE.MaterialLoader,
  load: function (url, onLoad, onProgress, onError) {
    var scope = this;
    var loader = new THREE.XHRLoader();
    loader.setCrossOrigin(this.crossOrigin);
    loader.load(url, function (text) {
      onLoad(scope.parse(JSON.parse(text)));
    });
  },
  setCrossOrigin: function (value) {
    this.crossOrigin = value;
  },
  parse: function (json) {
    var material = new THREE[json.type]();
    if (json.color !== undefined)
      material.color.setHex(json.color);
    if (json.ambient !== undefined)
      material.ambient.setHex(json.ambient);
    if (json.emissive !== undefined)
      material.emissive.setHex(json.emissive);
    if (json.specular !== undefined)
      material.specular.setHex(json.specular);
    if (json.shininess !== undefined)
      material.shininess = json.shininess;
    if (json.vertexColors !== undefined)
      material.vertexColors = json.vertexColors;
    if (json.blending !== undefined)
      material.blending = json.blending;
    if (json.opacity !== undefined)
      material.opacity = json.opacity;
    if (json.transparent !== undefined)
      material.transparent = json.transparent;
    if (json.wireframe !== undefined)
      material.wireframe = json.wireframe;
    if (json.materials !== undefined) {
      for (var i = 0, l = json.materials.length; i < l; i++) {
        material.materials.push(this.parse(json.materials[i]));
      }
    }
    return material;
  }
};
THREE.ObjectLoader = function (manager) {
  this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;
};
THREE.ObjectLoader.prototype = {
  constructor: THREE.ObjectLoader,
  load: function (url, onLoad, onProgress, onError) {
    var scope = this;
    var loader = new THREE.XHRLoader(scope.manager);
    loader.setCrossOrigin(this.crossOrigin);
    loader.load(url, function (text) {
      onLoad(scope.parse(JSON.parse(text)));
    });
  },
  setCrossOrigin: function (value) {
    this.crossOrigin = value;
  },
  parse: function (json) {
    var geometries = this.parseGeometries(json.geometries);
    var materials = this.parseMaterials(json.materials);
    var object = this.parseObject(json.object, geometries, materials);
    return object;
  },
  parseGeometries: function (json) {
    var geometries = {};
    if (json !== undefined) {
      var geometryLoader = new THREE.JSONLoader();
      var bufferGeometryLoader = new THREE.BufferGeometryLoader();
      for (var i = 0, l = json.length; i < l; i++) {
        var geometry;
        var data = json[i];
        switch (data.type) {
        case 'PlaneGeometry':
          geometry = new THREE.PlaneGeometry(data.width, data.height, data.widthSegments, data.heightSegments);
          break;
        case 'CubeGeometry':
          geometry = new THREE.CubeGeometry(data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
          break;
        case 'CylinderGeometry':
          geometry = new THREE.CylinderGeometry(data.radiusTop, data.radiusBottom, data.height, data.radiusSegments, data.heightSegments, data.openEnded);
          break;
        case 'SphereGeometry':
          geometry = new THREE.SphereGeometry(data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
          break;
        case 'IcosahedronGeometry':
          geometry = new THREE.IcosahedronGeometry(data.radius, data.detail);
          break;
        case 'TorusGeometry':
          geometry = new THREE.TorusGeometry(data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);
          break;
        case 'TorusKnotGeometry':
          geometry = new THREE.TorusKnotGeometry(data.radius, data.tube, data.radialSegments, data.tubularSegments, data.p, data.q, data.heightScale);
          break;
        case 'BufferGeometry':
          geometry = bufferGeometryLoader.parse(data.data);
          break;
        case 'Geometry':
          geometry = geometryLoader.parse(data.data).geometry;
          break;
        }
        geometry.uuid = data.uuid;
        if (data.name !== undefined)
          geometry.name = data.name;
        geometries[data.uuid] = geometry;
      }
    }
    return geometries;
  },
  parseMaterials: function (json) {
    var materials = {};
    if (json !== undefined) {
      var loader = new THREE.MaterialLoader();
      for (var i = 0, l = json.length; i < l; i++) {
        var data = json[i];
        var material = loader.parse(data);
        material.uuid = data.uuid;
        if (data.name !== undefined)
          material.name = data.name;
        materials[data.uuid] = material;
      }
    }
    return materials;
  },
  parseObject: function () {
    var matrix = new THREE.Matrix4();
    return function (data, geometries, materials) {
      var object;
      switch (data.type) {
      case 'Scene':
        object = new THREE.Scene();
        break;
      case 'PerspectiveCamera':
        object = new THREE.PerspectiveCamera(data.fov, data.aspect, data.near, data.far);
        break;
      case 'OrthographicCamera':
        object = new THREE.OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);
        break;
      case 'AmbientLight':
        object = new THREE.AmbientLight(data.color);
        break;
      case 'DirectionalLight':
        object = new THREE.DirectionalLight(data.color, data.intensity);
        break;
      case 'PointLight':
        object = new THREE.PointLight(data.color, data.intensity, data.distance);
        break;
      case 'SpotLight':
        object = new THREE.SpotLight(data.color, data.intensity, data.distance, data.angle, data.exponent);
        break;
      case 'HemisphereLight':
        object = new THREE.HemisphereLight(data.color, data.groundColor, data.intensity);
        break;
      case 'Mesh':
        var geometry = geometries[data.geometry];
        var material = materials[data.material];
        if (geometry === undefined) {
          console.error('THREE.ObjectLoader: Undefined geometry ' + data.geometry);
        }
        if (material === undefined) {
          console.error('THREE.ObjectLoader: Undefined material ' + data.material);
        }
        object = new THREE.Mesh(geometry, material);
        break;
      default:
        object = new THREE.Object3D();
      }
      object.uuid = data.uuid;
      if (data.name !== undefined)
        object.name = data.name;
      if (data.matrix !== undefined) {
        matrix.fromArray(data.matrix);
        matrix.decompose(object.position, object.quaternion, object.scale);
      } else {
        if (data.position !== undefined)
          object.position.fromArray(data.position);
        if (data.rotation !== undefined)
          object.rotation.fromArray(data.rotation);
        if (data.scale !== undefined)
          object.scale.fromArray(data.scale);
      }
      if (data.visible !== undefined)
        object.visible = data.visible;
      if (data.userData !== undefined)
        object.userData = data.userData;
      if (data.children !== undefined) {
        for (var child in data.children) {
          object.add(this.parseObject(data.children[child], geometries, materials));
        }
      }
      return object;
    };
  }()
};
THREE.SceneLoader = function () {
  this.onLoadStart = function () {
  };
  this.onLoadProgress = function () {
  };
  this.onLoadComplete = function () {
  };
  this.callbackSync = function () {
  };
  this.callbackProgress = function () {
  };
  this.geometryHandlers = {};
  this.hierarchyHandlers = {};
  this.addGeometryHandler('ascii', THREE.JSONLoader);
};
THREE.SceneLoader.prototype = {
  constructor: THREE.SceneLoader,
  load: function (url, onLoad, onProgress, onError) {
    var scope = this;
    var loader = new THREE.XHRLoader(scope.manager);
    loader.setCrossOrigin(this.crossOrigin);
    loader.load(url, function (text) {
      scope.parse(JSON.parse(text), onLoad, url);
    });
  },
  setCrossOrigin: function (value) {
    this.crossOrigin = value;
  },
  addGeometryHandler: function (typeID, loaderClass) {
    this.geometryHandlers[typeID] = { 'loaderClass': loaderClass };
  },
  addHierarchyHandler: function (typeID, loaderClass) {
    this.hierarchyHandlers[typeID] = { 'loaderClass': loaderClass };
  },
  parse: function (json, callbackFinished, url) {
    var scope = this;
    var urlBase = THREE.Loader.prototype.extractUrlBase(url);
    var geometry, material, camera, fog, texture, images, color, light, hex, intensity, counter_models, counter_textures, total_models, total_textures, result;
    var target_array = [];
    var data = json;
    for (var typeID in this.geometryHandlers) {
      var loaderClass = this.geometryHandlers[typeID]['loaderClass'];
      this.geometryHandlers[typeID]['loaderObject'] = new loaderClass();
    }
    for (var typeID in this.hierarchyHandlers) {
      var loaderClass = this.hierarchyHandlers[typeID]['loaderClass'];
      this.hierarchyHandlers[typeID]['loaderObject'] = new loaderClass();
    }
    counter_models = 0;
    counter_textures = 0;
    result = {
      scene: new THREE.Scene(),
      geometries: {},
      face_materials: {},
      materials: {},
      textures: {},
      objects: {},
      cameras: {},
      lights: {},
      fogs: {},
      empties: {},
      groups: {}
    };
    if (data.transform) {
      var position = data.transform.position, rotation = data.transform.rotation, scale = data.transform.scale;
      if (position) {
        result.scene.position.fromArray(position);
      }
      if (rotation) {
        result.scene.rotation.fromArray(rotation);
      }
      if (scale) {
        result.scene.scale.fromArray(scale);
      }
      if (position || rotation || scale) {
        result.scene.updateMatrix();
        result.scene.updateMatrixWorld();
      }
    }
    function get_url(source_url, url_type) {
      if (url_type == 'relativeToHTML') {
        return source_url;
      } else {
        return urlBase + '/' + source_url;
      }
    }
    ;
    function handle_objects() {
      handle_children(result.scene, data.objects);
    }
    function handle_children(parent, children) {
      var mat, dst, pos, rot, scl, quat;
      for (var objID in children) {
        var object = result.objects[objID];
        var objJSON = children[objID];
        if (object === undefined) {
          if (objJSON.type && objJSON.type in scope.hierarchyHandlers) {
            if (objJSON.loading === undefined) {
              var reservedTypes = {
                  'type': 1,
                  'url': 1,
                  'material': 1,
                  'position': 1,
                  'rotation': 1,
                  'scale': 1,
                  'visible': 1,
                  'children': 1,
                  'userData': 1,
                  'skin': 1,
                  'morph': 1,
                  'mirroredLoop': 1,
                  'duration': 1
                };
              var loaderParameters = {};
              for (var parType in objJSON) {
                if (!(parType in reservedTypes)) {
                  loaderParameters[parType] = objJSON[parType];
                }
              }
              material = result.materials[objJSON.material];
              objJSON.loading = true;
              var loader = scope.hierarchyHandlers[objJSON.type]['loaderObject'];
              if (loader.options) {
                loader.load(get_url(objJSON.url, data.urlBaseType), create_callback_hierachy(objID, parent, material, objJSON));
              } else {
                loader.load(get_url(objJSON.url, data.urlBaseType), create_callback_hierachy(objID, parent, material, objJSON), loaderParameters);
              }
            }
          } else if (objJSON.geometry !== undefined) {
            geometry = result.geometries[objJSON.geometry];
            if (geometry) {
              var needsTangents = false;
              material = result.materials[objJSON.material];
              needsTangents = material instanceof THREE.ShaderMaterial;
              pos = objJSON.position;
              rot = objJSON.rotation;
              scl = objJSON.scale;
              mat = objJSON.matrix;
              quat = objJSON.quaternion;
              if (!objJSON.material) {
                material = new THREE.MeshFaceMaterial(result.face_materials[objJSON.geometry]);
              }
              if (material instanceof THREE.MeshFaceMaterial && material.materials.length === 0) {
                material = new THREE.MeshFaceMaterial(result.face_materials[objJSON.geometry]);
              }
              if (material instanceof THREE.MeshFaceMaterial) {
                for (var i = 0; i < material.materials.length; i++) {
                  needsTangents = needsTangents || material.materials[i] instanceof THREE.ShaderMaterial;
                }
              }
              if (needsTangents) {
                geometry.computeTangents();
              }
              if (objJSON.skin) {
                object = new THREE.SkinnedMesh(geometry, material);
              } else if (objJSON.morph) {
                object = new THREE.MorphAnimMesh(geometry, material);
                if (objJSON.duration !== undefined) {
                  object.duration = objJSON.duration;
                }
                if (objJSON.time !== undefined) {
                  object.time = objJSON.time;
                }
                if (objJSON.mirroredLoop !== undefined) {
                  object.mirroredLoop = objJSON.mirroredLoop;
                }
                if (material.morphNormals) {
                  geometry.computeMorphNormals();
                }
              } else {
                object = new THREE.Mesh(geometry, material);
              }
              object.name = objID;
              if (mat) {
                object.matrixAutoUpdate = false;
                object.matrix.set(mat[0], mat[1], mat[2], mat[3], mat[4], mat[5], mat[6], mat[7], mat[8], mat[9], mat[10], mat[11], mat[12], mat[13], mat[14], mat[15]);
              } else {
                object.position.fromArray(pos);
                if (quat) {
                  object.quaternion.fromArray(quat);
                } else {
                  object.rotation.fromArray(rot);
                }
                object.scale.fromArray(scl);
              }
              object.visible = objJSON.visible;
              object.castShadow = objJSON.castShadow;
              object.receiveShadow = objJSON.receiveShadow;
              parent.add(object);
              result.objects[objID] = object;
            }
          } else if (objJSON.type === 'DirectionalLight' || objJSON.type === 'PointLight' || objJSON.type === 'AmbientLight') {
            hex = objJSON.color !== undefined ? objJSON.color : 16777215;
            intensity = objJSON.intensity !== undefined ? objJSON.intensity : 1;
            if (objJSON.type === 'DirectionalLight') {
              pos = objJSON.direction;
              light = new THREE.DirectionalLight(hex, intensity);
              light.position.fromArray(pos);
              if (objJSON.target) {
                target_array.push({
                  'object': light,
                  'targetName': objJSON.target
                });
                light.target = null;
              }
            } else if (objJSON.type === 'PointLight') {
              pos = objJSON.position;
              dst = objJSON.distance;
              light = new THREE.PointLight(hex, intensity, dst);
              light.position.fromArray(pos);
            } else if (objJSON.type === 'AmbientLight') {
              light = new THREE.AmbientLight(hex);
            }
            parent.add(light);
            light.name = objID;
            result.lights[objID] = light;
            result.objects[objID] = light;
          } else if (objJSON.type === 'PerspectiveCamera' || objJSON.type === 'OrthographicCamera') {
            pos = objJSON.position;
            rot = objJSON.rotation;
            quat = objJSON.quaternion;
            if (objJSON.type === 'PerspectiveCamera') {
              camera = new THREE.PerspectiveCamera(objJSON.fov, objJSON.aspect, objJSON.near, objJSON.far);
            } else if (objJSON.type === 'OrthographicCamera') {
              camera = new THREE.OrthographicCamera(objJSON.left, objJSON.right, objJSON.top, objJSON.bottom, objJSON.near, objJSON.far);
            }
            camera.name = objID;
            camera.position.fromArray(pos);
            if (quat !== undefined) {
              camera.quaternion.fromArray(quat);
            } else if (rot !== undefined) {
              camera.rotation.fromArray(rot);
            }
            parent.add(camera);
            result.cameras[objID] = camera;
            result.objects[objID] = camera;
          } else {
            pos = objJSON.position;
            rot = objJSON.rotation;
            scl = objJSON.scale;
            quat = objJSON.quaternion;
            object = new THREE.Object3D();
            object.name = objID;
            object.position.fromArray(pos);
            if (quat) {
              object.quaternion.fromArray(quat);
            } else {
              object.rotation.fromArray(rot);
            }
            object.scale.fromArray(scl);
            object.visible = objJSON.visible !== undefined ? objJSON.visible : false;
            parent.add(object);
            result.objects[objID] = object;
            result.empties[objID] = object;
          }
          if (object) {
            if (objJSON.userData !== undefined) {
              for (var key in objJSON.userData) {
                var value = objJSON.userData[key];
                object.userData[key] = value;
              }
            }
            if (objJSON.groups !== undefined) {
              for (var i = 0; i < objJSON.groups.length; i++) {
                var groupID = objJSON.groups[i];
                if (result.groups[groupID] === undefined) {
                  result.groups[groupID] = [];
                }
                result.groups[groupID].push(objID);
              }
            }
          }
        }
        if (object !== undefined && objJSON.children !== undefined) {
          handle_children(object, objJSON.children);
        }
      }
    }
    ;
    function handle_mesh(geo, mat, id) {
      result.geometries[id] = geo;
      result.face_materials[id] = mat;
      handle_objects();
    }
    ;
    function handle_hierarchy(node, id, parent, material, obj) {
      var p = obj.position;
      var r = obj.rotation;
      var q = obj.quaternion;
      var s = obj.scale;
      node.position.fromArray(p);
      if (q) {
        node.quaternion.fromArray(q);
      } else {
        node.rotation.fromArray(r);
      }
      node.scale.fromArray(s);
      if (material) {
        node.traverse(function (child) {
          child.material = material;
        });
      }
      var visible = obj.visible !== undefined ? obj.visible : true;
      node.traverse(function (child) {
        child.visible = visible;
      });
      parent.add(node);
      node.name = id;
      result.objects[id] = node;
      handle_objects();
    }
    ;
    function create_callback_geometry(id) {
      return function (geo, mat) {
        geo.name = id;
        handle_mesh(geo, mat, id);
        counter_models -= 1;
        scope.onLoadComplete();
        async_callback_gate();
      };
    }
    ;
    function create_callback_hierachy(id, parent, material, obj) {
      return function (event) {
        var result;
        if (event.content) {
          result = event.content;
        } else if (event.dae) {
          result = event.scene;
        } else {
          result = event;
        }
        handle_hierarchy(result, id, parent, material, obj);
        counter_models -= 1;
        scope.onLoadComplete();
        async_callback_gate();
      };
    }
    ;
    function create_callback_embed(id) {
      return function (geo, mat) {
        geo.name = id;
        result.geometries[id] = geo;
        result.face_materials[id] = mat;
      };
    }
    ;
    function async_callback_gate() {
      var progress = {
          totalModels: total_models,
          totalTextures: total_textures,
          loadedModels: total_models - counter_models,
          loadedTextures: total_textures - counter_textures
        };
      scope.callbackProgress(progress, result);
      scope.onLoadProgress();
      if (counter_models === 0 && counter_textures === 0) {
        finalize();
        callbackFinished(result);
      }
    }
    ;
    function finalize() {
      for (var i = 0; i < target_array.length; i++) {
        var ta = target_array[i];
        var target = result.objects[ta.targetName];
        if (target) {
          ta.object.target = target;
        } else {
          ta.object.target = new THREE.Object3D();
          result.scene.add(ta.object.target);
        }
        ta.object.target.userData.targetInverse = ta.object;
      }
    }
    ;
    var callbackTexture = function (count) {
      counter_textures -= count;
      async_callback_gate();
      scope.onLoadComplete();
    };
    var generateTextureCallback = function (count) {
      return function () {
        callbackTexture(count);
      };
    };
    function traverse_json_hierarchy(objJSON, callback) {
      callback(objJSON);
      if (objJSON.children !== undefined) {
        for (var objChildID in objJSON.children) {
          traverse_json_hierarchy(objJSON.children[objChildID], callback);
        }
      }
    }
    ;
    var fogID, fogJSON;
    for (fogID in data.fogs) {
      fogJSON = data.fogs[fogID];
      if (fogJSON.type === 'linear') {
        fog = new THREE.Fog(0, fogJSON.near, fogJSON.far);
      } else if (fogJSON.type === 'exp2') {
        fog = new THREE.FogExp2(0, fogJSON.density);
      }
      color = fogJSON.color;
      fog.color.setRGB(color[0], color[1], color[2]);
      result.fogs[fogID] = fog;
    }
    var geoID, geoJSON;
    for (geoID in data.geometries) {
      geoJSON = data.geometries[geoID];
      if (geoJSON.type in this.geometryHandlers) {
        counter_models += 1;
        scope.onLoadStart();
      }
    }
    for (var objID in data.objects) {
      traverse_json_hierarchy(data.objects[objID], function (objJSON) {
        if (objJSON.type && objJSON.type in scope.hierarchyHandlers) {
          counter_models += 1;
          scope.onLoadStart();
        }
      });
    }
    total_models = counter_models;
    for (geoID in data.geometries) {
      geoJSON = data.geometries[geoID];
      if (geoJSON.type === 'cube') {
        geometry = new THREE.CubeGeometry(geoJSON.width, geoJSON.height, geoJSON.depth, geoJSON.widthSegments, geoJSON.heightSegments, geoJSON.depthSegments);
        geometry.name = geoID;
        result.geometries[geoID] = geometry;
      } else if (geoJSON.type === 'plane') {
        geometry = new THREE.PlaneGeometry(geoJSON.width, geoJSON.height, geoJSON.widthSegments, geoJSON.heightSegments);
        geometry.name = geoID;
        result.geometries[geoID] = geometry;
      } else if (geoJSON.type === 'sphere') {
        geometry = new THREE.SphereGeometry(geoJSON.radius, geoJSON.widthSegments, geoJSON.heightSegments);
        geometry.name = geoID;
        result.geometries[geoID] = geometry;
      } else if (geoJSON.type === 'cylinder') {
        geometry = new THREE.CylinderGeometry(geoJSON.topRad, geoJSON.botRad, geoJSON.height, geoJSON.radSegs, geoJSON.heightSegs);
        geometry.name = geoID;
        result.geometries[geoID] = geometry;
      } else if (geoJSON.type === 'torus') {
        geometry = new THREE.TorusGeometry(geoJSON.radius, geoJSON.tube, geoJSON.segmentsR, geoJSON.segmentsT);
        geometry.name = geoID;
        result.geometries[geoID] = geometry;
      } else if (geoJSON.type === 'icosahedron') {
        geometry = new THREE.IcosahedronGeometry(geoJSON.radius, geoJSON.subdivisions);
        geometry.name = geoID;
        result.geometries[geoID] = geometry;
      } else if (geoJSON.type in this.geometryHandlers) {
        var loaderParameters = {};
        for (var parType in geoJSON) {
          if (parType !== 'type' && parType !== 'url') {
            loaderParameters[parType] = geoJSON[parType];
          }
        }
        var loader = this.geometryHandlers[geoJSON.type]['loaderObject'];
        loader.load(get_url(geoJSON.url, data.urlBaseType), create_callback_geometry(geoID), loaderParameters);
      } else if (geoJSON.type === 'embedded') {
        var modelJson = data.embeds[geoJSON.id], texture_path = '';
        modelJson.metadata = data.metadata;
        if (modelJson) {
          var jsonLoader = this.geometryHandlers['ascii']['loaderObject'];
          var model = jsonLoader.parse(modelJson, texture_path);
          create_callback_embed(geoID)(model.geometry, model.materials);
        }
      }
    }
    var textureID, textureJSON;
    for (textureID in data.textures) {
      textureJSON = data.textures[textureID];
      if (textureJSON.url instanceof Array) {
        counter_textures += textureJSON.url.length;
        for (var n = 0; n < textureJSON.url.length; n++) {
          scope.onLoadStart();
        }
      } else {
        counter_textures += 1;
        scope.onLoadStart();
      }
    }
    total_textures = counter_textures;
    for (textureID in data.textures) {
      textureJSON = data.textures[textureID];
      if (textureJSON.mapping !== undefined && THREE[textureJSON.mapping] !== undefined) {
        textureJSON.mapping = new THREE[textureJSON.mapping]();
      }
      if (textureJSON.url instanceof Array) {
        var count = textureJSON.url.length;
        var url_array = [];
        for (var i = 0; i < count; i++) {
          url_array[i] = get_url(textureJSON.url[i], data.urlBaseType);
        }
        var isCompressed = /\.dds$/i.test(url_array[0]);
        if (isCompressed) {
          texture = THREE.ImageUtils.loadCompressedTextureCube(url_array, textureJSON.mapping, generateTextureCallback(count));
        } else {
          texture = THREE.ImageUtils.loadTextureCube(url_array, textureJSON.mapping, generateTextureCallback(count));
        }
      } else {
        var isCompressed = /\.dds$/i.test(textureJSON.url);
        var fullUrl = get_url(textureJSON.url, data.urlBaseType);
        var textureCallback = generateTextureCallback(1);
        if (isCompressed) {
          texture = THREE.ImageUtils.loadCompressedTexture(fullUrl, textureJSON.mapping, textureCallback);
        } else {
          texture = THREE.ImageUtils.loadTexture(fullUrl, textureJSON.mapping, textureCallback);
        }
        if (THREE[textureJSON.minFilter] !== undefined)
          texture.minFilter = THREE[textureJSON.minFilter];
        if (THREE[textureJSON.magFilter] !== undefined)
          texture.magFilter = THREE[textureJSON.magFilter];
        if (textureJSON.anisotropy)
          texture.anisotropy = textureJSON.anisotropy;
        if (textureJSON.repeat) {
          texture.repeat.set(textureJSON.repeat[0], textureJSON.repeat[1]);
          if (textureJSON.repeat[0] !== 1)
            texture.wrapS = THREE.RepeatWrapping;
          if (textureJSON.repeat[1] !== 1)
            texture.wrapT = THREE.RepeatWrapping;
        }
        if (textureJSON.offset) {
          texture.offset.set(textureJSON.offset[0], textureJSON.offset[1]);
        }
        if (textureJSON.wrap) {
          var wrapMap = {
              'repeat': THREE.RepeatWrapping,
              'mirror': THREE.MirroredRepeatWrapping
            };
          if (wrapMap[textureJSON.wrap[0]] !== undefined)
            texture.wrapS = wrapMap[textureJSON.wrap[0]];
          if (wrapMap[textureJSON.wrap[1]] !== undefined)
            texture.wrapT = wrapMap[textureJSON.wrap[1]];
        }
      }
      result.textures[textureID] = texture;
    }
    var matID, matJSON;
    var parID;
    for (matID in data.materials) {
      matJSON = data.materials[matID];
      for (parID in matJSON.parameters) {
        if (parID === 'envMap' || parID === 'map' || parID === 'lightMap' || parID === 'bumpMap') {
          matJSON.parameters[parID] = result.textures[matJSON.parameters[parID]];
        } else if (parID === 'shading') {
          matJSON.parameters[parID] = matJSON.parameters[parID] === 'flat' ? THREE.FlatShading : THREE.SmoothShading;
        } else if (parID === 'side') {
          if (matJSON.parameters[parID] == 'double') {
            matJSON.parameters[parID] = THREE.DoubleSide;
          } else if (matJSON.parameters[parID] == 'back') {
            matJSON.parameters[parID] = THREE.BackSide;
          } else {
            matJSON.parameters[parID] = THREE.FrontSide;
          }
        } else if (parID === 'blending') {
          matJSON.parameters[parID] = matJSON.parameters[parID] in THREE ? THREE[matJSON.parameters[parID]] : THREE.NormalBlending;
        } else if (parID === 'combine') {
          matJSON.parameters[parID] = matJSON.parameters[parID] in THREE ? THREE[matJSON.parameters[parID]] : THREE.MultiplyOperation;
        } else if (parID === 'vertexColors') {
          if (matJSON.parameters[parID] == 'face') {
            matJSON.parameters[parID] = THREE.FaceColors;
          } else if (matJSON.parameters[parID]) {
            matJSON.parameters[parID] = THREE.VertexColors;
          }
        } else if (parID === 'wrapRGB') {
          var v3 = matJSON.parameters[parID];
          matJSON.parameters[parID] = new THREE.Vector3(v3[0], v3[1], v3[2]);
        }
      }
      if (matJSON.parameters.opacity !== undefined && matJSON.parameters.opacity < 1) {
        matJSON.parameters.transparent = true;
      }
      if (matJSON.parameters.normalMap) {
        var shader = THREE.ShaderLib['normalmap'];
        var uniforms = THREE.UniformsUtils.clone(shader.uniforms);
        var diffuse = matJSON.parameters.color;
        var specular = matJSON.parameters.specular;
        var ambient = matJSON.parameters.ambient;
        var shininess = matJSON.parameters.shininess;
        uniforms['tNormal'].value = result.textures[matJSON.parameters.normalMap];
        if (matJSON.parameters.normalScale) {
          uniforms['uNormalScale'].value.set(matJSON.parameters.normalScale[0], matJSON.parameters.normalScale[1]);
        }
        if (matJSON.parameters.map) {
          uniforms['tDiffuse'].value = matJSON.parameters.map;
          uniforms['enableDiffuse'].value = true;
        }
        if (matJSON.parameters.envMap) {
          uniforms['tCube'].value = matJSON.parameters.envMap;
          uniforms['enableReflection'].value = true;
          uniforms['uReflectivity'].value = matJSON.parameters.reflectivity;
        }
        if (matJSON.parameters.lightMap) {
          uniforms['tAO'].value = matJSON.parameters.lightMap;
          uniforms['enableAO'].value = true;
        }
        if (matJSON.parameters.specularMap) {
          uniforms['tSpecular'].value = result.textures[matJSON.parameters.specularMap];
          uniforms['enableSpecular'].value = true;
        }
        if (matJSON.parameters.displacementMap) {
          uniforms['tDisplacement'].value = result.textures[matJSON.parameters.displacementMap];
          uniforms['enableDisplacement'].value = true;
          uniforms['uDisplacementBias'].value = matJSON.parameters.displacementBias;
          uniforms['uDisplacementScale'].value = matJSON.parameters.displacementScale;
        }
        uniforms['uDiffuseColor'].value.setHex(diffuse);
        uniforms['uSpecularColor'].value.setHex(specular);
        uniforms['uAmbientColor'].value.setHex(ambient);
        uniforms['uShininess'].value = shininess;
        if (matJSON.parameters.opacity) {
          uniforms['uOpacity'].value = matJSON.parameters.opacity;
        }
        var parameters = {
            fragmentShader: shader.fragmentShader,
            vertexShader: shader.vertexShader,
            uniforms: uniforms,
            lights: true,
            fog: true
          };
        material = new THREE.ShaderMaterial(parameters);
      } else {
        material = new THREE[matJSON.type](matJSON.parameters);
      }
      material.name = matID;
      result.materials[matID] = material;
    }
    for (matID in data.materials) {
      matJSON = data.materials[matID];
      if (matJSON.parameters.materials) {
        var materialArray = [];
        for (var i = 0; i < matJSON.parameters.materials.length; i++) {
          var label = matJSON.parameters.materials[i];
          materialArray.push(result.materials[label]);
        }
        result.materials[matID].materials = materialArray;
      }
    }
    handle_objects();
    if (result.cameras && data.defaults.camera) {
      result.currentCamera = result.cameras[data.defaults.camera];
    }
    if (result.fogs && data.defaults.fog) {
      result.scene.fog = result.fogs[data.defaults.fog];
    }
    scope.callbackSync(result);
    async_callback_gate();
  }
};
THREE.TextureLoader = function (manager) {
  this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;
};
THREE.TextureLoader.prototype = {
  constructor: THREE.TextureLoader,
  load: function (url, onLoad, onProgress, onError) {
    var scope = this;
    var loader = new THREE.ImageLoader(scope.manager);
    loader.setCrossOrigin(this.crossOrigin);
    loader.load(url, function (image) {
      var texture = new THREE.Texture(image);
      texture.needsUpdate = true;
      if (onLoad !== undefined) {
        onLoad(texture);
      }
    });
  },
  setCrossOrigin: function (value) {
    this.crossOrigin = value;
  }
};
THREE.Material = function () {
  this.id = THREE.MaterialIdCount++;
  this.uuid = THREE.Math.generateUUID();
  this.name = '';
  this.side = THREE.FrontSide;
  this.opacity = 1;
  this.transparent = false;
  this.blending = THREE.NormalBlending;
  this.blendSrc = THREE.SrcAlphaFactor;
  this.blendDst = THREE.OneMinusSrcAlphaFactor;
  this.blendEquation = THREE.AddEquation;
  this.depthTest = true;
  this.depthWrite = true;
  this.polygonOffset = false;
  this.polygonOffsetFactor = 0;
  this.polygonOffsetUnits = 0;
  this.alphaTest = 0;
  this.overdraw = 0;
  this.visible = true;
  this.needsUpdate = true;
};
THREE.Material.prototype = {
  constructor: THREE.Material,
  setValues: function (values) {
    if (values === undefined)
      return;
    for (var key in values) {
      var newValue = values[key];
      if (newValue === undefined) {
        console.warn('THREE.Material: \'' + key + '\' parameter is undefined.');
        continue;
      }
      if (key in this) {
        var currentValue = this[key];
        if (currentValue instanceof THREE.Color) {
          currentValue.set(newValue);
        } else if (currentValue instanceof THREE.Vector3 && newValue instanceof THREE.Vector3) {
          currentValue.copy(newValue);
        } else if (key == 'overdraw') {
          this[key] = Number(newValue);
        } else {
          this[key] = newValue;
        }
      }
    }
  },
  clone: function (material) {
    if (material === undefined)
      material = new THREE.Material();
    material.name = this.name;
    material.side = this.side;
    material.opacity = this.opacity;
    material.transparent = this.transparent;
    material.blending = this.blending;
    material.blendSrc = this.blendSrc;
    material.blendDst = this.blendDst;
    material.blendEquation = this.blendEquation;
    material.depthTest = this.depthTest;
    material.depthWrite = this.depthWrite;
    material.polygonOffset = this.polygonOffset;
    material.polygonOffsetFactor = this.polygonOffsetFactor;
    material.polygonOffsetUnits = this.polygonOffsetUnits;
    material.alphaTest = this.alphaTest;
    material.overdraw = this.overdraw;
    material.visible = this.visible;
    return material;
  },
  dispose: function () {
    this.dispatchEvent({ type: 'dispose' });
  }
};
THREE.EventDispatcher.prototype.apply(THREE.Material.prototype);
THREE.MaterialIdCount = 0;
THREE.LineBasicMaterial = function (parameters) {
  THREE.Material.call(this);
  this.color = new THREE.Color(16777215);
  this.linewidth = 1;
  this.linecap = 'round';
  this.linejoin = 'round';
  this.vertexColors = false;
  this.fog = true;
  this.setValues(parameters);
};
THREE.LineBasicMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.LineBasicMaterial.prototype.clone = function () {
  var material = new THREE.LineBasicMaterial();
  THREE.Material.prototype.clone.call(this, material);
  material.color.copy(this.color);
  material.linewidth = this.linewidth;
  material.linecap = this.linecap;
  material.linejoin = this.linejoin;
  material.vertexColors = this.vertexColors;
  material.fog = this.fog;
  return material;
};
THREE.LineDashedMaterial = function (parameters) {
  THREE.Material.call(this);
  this.color = new THREE.Color(16777215);
  this.linewidth = 1;
  this.scale = 1;
  this.dashSize = 3;
  this.gapSize = 1;
  this.vertexColors = false;
  this.fog = true;
  this.setValues(parameters);
};
THREE.LineDashedMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.LineDashedMaterial.prototype.clone = function () {
  var material = new THREE.LineDashedMaterial();
  THREE.Material.prototype.clone.call(this, material);
  material.color.copy(this.color);
  material.linewidth = this.linewidth;
  material.scale = this.scale;
  material.dashSize = this.dashSize;
  material.gapSize = this.gapSize;
  material.vertexColors = this.vertexColors;
  material.fog = this.fog;
  return material;
};
THREE.MeshBasicMaterial = function (parameters) {
  THREE.Material.call(this);
  this.color = new THREE.Color(16777215);
  this.map = null;
  this.lightMap = null;
  this.specularMap = null;
  this.envMap = null;
  this.combine = THREE.MultiplyOperation;
  this.reflectivity = 1;
  this.refractionRatio = 0.98;
  this.fog = true;
  this.shading = THREE.SmoothShading;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.wireframeLinecap = 'round';
  this.wireframeLinejoin = 'round';
  this.vertexColors = THREE.NoColors;
  this.skinning = false;
  this.morphTargets = false;
  this.setValues(parameters);
};
THREE.MeshBasicMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.MeshBasicMaterial.prototype.clone = function () {
  var material = new THREE.MeshBasicMaterial();
  THREE.Material.prototype.clone.call(this, material);
  material.color.copy(this.color);
  material.map = this.map;
  material.lightMap = this.lightMap;
  material.specularMap = this.specularMap;
  material.envMap = this.envMap;
  material.combine = this.combine;
  material.reflectivity = this.reflectivity;
  material.refractionRatio = this.refractionRatio;
  material.fog = this.fog;
  material.shading = this.shading;
  material.wireframe = this.wireframe;
  material.wireframeLinewidth = this.wireframeLinewidth;
  material.wireframeLinecap = this.wireframeLinecap;
  material.wireframeLinejoin = this.wireframeLinejoin;
  material.vertexColors = this.vertexColors;
  material.skinning = this.skinning;
  material.morphTargets = this.morphTargets;
  return material;
};
THREE.MeshLambertMaterial = function (parameters) {
  THREE.Material.call(this);
  this.color = new THREE.Color(16777215);
  this.ambient = new THREE.Color(16777215);
  this.emissive = new THREE.Color(0);
  this.wrapAround = false;
  this.wrapRGB = new THREE.Vector3(1, 1, 1);
  this.map = null;
  this.lightMap = null;
  this.specularMap = null;
  this.envMap = null;
  this.combine = THREE.MultiplyOperation;
  this.reflectivity = 1;
  this.refractionRatio = 0.98;
  this.fog = true;
  this.shading = THREE.SmoothShading;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.wireframeLinecap = 'round';
  this.wireframeLinejoin = 'round';
  this.vertexColors = THREE.NoColors;
  this.skinning = false;
  this.morphTargets = false;
  this.morphNormals = false;
  this.setValues(parameters);
};
THREE.MeshLambertMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.MeshLambertMaterial.prototype.clone = function () {
  var material = new THREE.MeshLambertMaterial();
  THREE.Material.prototype.clone.call(this, material);
  material.color.copy(this.color);
  material.ambient.copy(this.ambient);
  material.emissive.copy(this.emissive);
  material.wrapAround = this.wrapAround;
  material.wrapRGB.copy(this.wrapRGB);
  material.map = this.map;
  material.lightMap = this.lightMap;
  material.specularMap = this.specularMap;
  material.envMap = this.envMap;
  material.combine = this.combine;
  material.reflectivity = this.reflectivity;
  material.refractionRatio = this.refractionRatio;
  material.fog = this.fog;
  material.shading = this.shading;
  material.wireframe = this.wireframe;
  material.wireframeLinewidth = this.wireframeLinewidth;
  material.wireframeLinecap = this.wireframeLinecap;
  material.wireframeLinejoin = this.wireframeLinejoin;
  material.vertexColors = this.vertexColors;
  material.skinning = this.skinning;
  material.morphTargets = this.morphTargets;
  material.morphNormals = this.morphNormals;
  return material;
};
THREE.MeshPhongMaterial = function (parameters) {
  THREE.Material.call(this);
  this.color = new THREE.Color(16777215);
  this.ambient = new THREE.Color(16777215);
  this.emissive = new THREE.Color(0);
  this.specular = new THREE.Color(1118481);
  this.shininess = 30;
  this.metal = false;
  this.perPixel = true;
  this.wrapAround = false;
  this.wrapRGB = new THREE.Vector3(1, 1, 1);
  this.map = null;
  this.lightMap = null;
  this.bumpMap = null;
  this.bumpScale = 1;
  this.normalMap = null;
  this.normalScale = new THREE.Vector2(1, 1);
  this.specularMap = null;
  this.envMap = null;
  this.combine = THREE.MultiplyOperation;
  this.reflectivity = 1;
  this.refractionRatio = 0.98;
  this.fog = true;
  this.shading = THREE.SmoothShading;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.wireframeLinecap = 'round';
  this.wireframeLinejoin = 'round';
  this.vertexColors = THREE.NoColors;
  this.skinning = false;
  this.morphTargets = false;
  this.morphNormals = false;
  this.setValues(parameters);
};
THREE.MeshPhongMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.MeshPhongMaterial.prototype.clone = function () {
  var material = new THREE.MeshPhongMaterial();
  THREE.Material.prototype.clone.call(this, material);
  material.color.copy(this.color);
  material.ambient.copy(this.ambient);
  material.emissive.copy(this.emissive);
  material.specular.copy(this.specular);
  material.shininess = this.shininess;
  material.metal = this.metal;
  material.perPixel = this.perPixel;
  material.wrapAround = this.wrapAround;
  material.wrapRGB.copy(this.wrapRGB);
  material.map = this.map;
  material.lightMap = this.lightMap;
  material.bumpMap = this.bumpMap;
  material.bumpScale = this.bumpScale;
  material.normalMap = this.normalMap;
  material.normalScale.copy(this.normalScale);
  material.specularMap = this.specularMap;
  material.envMap = this.envMap;
  material.combine = this.combine;
  material.reflectivity = this.reflectivity;
  material.refractionRatio = this.refractionRatio;
  material.fog = this.fog;
  material.shading = this.shading;
  material.wireframe = this.wireframe;
  material.wireframeLinewidth = this.wireframeLinewidth;
  material.wireframeLinecap = this.wireframeLinecap;
  material.wireframeLinejoin = this.wireframeLinejoin;
  material.vertexColors = this.vertexColors;
  material.skinning = this.skinning;
  material.morphTargets = this.morphTargets;
  material.morphNormals = this.morphNormals;
  return material;
};
THREE.MeshDepthMaterial = function (parameters) {
  THREE.Material.call(this);
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.setValues(parameters);
};
THREE.MeshDepthMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.MeshDepthMaterial.prototype.clone = function () {
  var material = new THREE.MeshDepthMaterial();
  THREE.Material.prototype.clone.call(this, material);
  material.wireframe = this.wireframe;
  material.wireframeLinewidth = this.wireframeLinewidth;
  return material;
};
THREE.MeshNormalMaterial = function (parameters) {
  THREE.Material.call(this, parameters);
  this.shading = THREE.FlatShading;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.morphTargets = false;
  this.setValues(parameters);
};
THREE.MeshNormalMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.MeshNormalMaterial.prototype.clone = function () {
  var material = new THREE.MeshNormalMaterial();
  THREE.Material.prototype.clone.call(this, material);
  material.shading = this.shading;
  material.wireframe = this.wireframe;
  material.wireframeLinewidth = this.wireframeLinewidth;
  return material;
};
THREE.MeshFaceMaterial = function (materials) {
  this.materials = materials instanceof Array ? materials : [];
};
THREE.MeshFaceMaterial.prototype.clone = function () {
  return new THREE.MeshFaceMaterial(this.materials.slice(0));
};
THREE.ParticleBasicMaterial = function (parameters) {
  THREE.Material.call(this);
  this.color = new THREE.Color(16777215);
  this.map = null;
  this.size = 1;
  this.sizeAttenuation = true;
  this.vertexColors = false;
  this.fog = true;
  this.setValues(parameters);
};
THREE.ParticleBasicMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.ParticleBasicMaterial.prototype.clone = function () {
  var material = new THREE.ParticleBasicMaterial();
  THREE.Material.prototype.clone.call(this, material);
  material.color.copy(this.color);
  material.map = this.map;
  material.size = this.size;
  material.sizeAttenuation = this.sizeAttenuation;
  material.vertexColors = this.vertexColors;
  material.fog = this.fog;
  return material;
};
THREE.ParticleCanvasMaterial = function (parameters) {
  THREE.Material.call(this);
  this.color = new THREE.Color(16777215);
  this.program = function (context, color) {
  };
  this.setValues(parameters);
};
THREE.ParticleCanvasMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.ParticleCanvasMaterial.prototype.clone = function () {
  var material = new THREE.ParticleCanvasMaterial();
  THREE.Material.prototype.clone.call(this, material);
  material.color.copy(this.color);
  material.program = this.program;
  return material;
};
THREE.ShaderMaterial = function (parameters) {
  THREE.Material.call(this);
  this.fragmentShader = 'void main() {}';
  this.vertexShader = 'void main() {}';
  this.uniforms = {};
  this.defines = {};
  this.attributes = null;
  this.shading = THREE.SmoothShading;
  this.linewidth = 1;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.fog = false;
  this.lights = false;
  this.vertexColors = THREE.NoColors;
  this.skinning = false;
  this.morphTargets = false;
  this.morphNormals = false;
  this.defaultAttributeValues = {
    'color': [
      1,
      1,
      1
    ],
    'uv': [
      0,
      0
    ],
    'uv2': [
      0,
      0
    ]
  };
  this.index0AttributeName = 'position';
  this.setValues(parameters);
};
THREE.ShaderMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.ShaderMaterial.prototype.clone = function () {
  var material = new THREE.ShaderMaterial();
  THREE.Material.prototype.clone.call(this, material);
  material.fragmentShader = this.fragmentShader;
  material.vertexShader = this.vertexShader;
  material.uniforms = THREE.UniformsUtils.clone(this.uniforms);
  material.attributes = this.attributes;
  material.defines = this.defines;
  material.shading = this.shading;
  material.wireframe = this.wireframe;
  material.wireframeLinewidth = this.wireframeLinewidth;
  material.fog = this.fog;
  material.lights = this.lights;
  material.vertexColors = this.vertexColors;
  material.skinning = this.skinning;
  material.morphTargets = this.morphTargets;
  material.morphNormals = this.morphNormals;
  return material;
};
THREE.SpriteMaterial = function (parameters) {
  THREE.Material.call(this);
  this.color = new THREE.Color(16777215);
  this.map = new THREE.Texture();
  this.useScreenCoordinates = true;
  this.depthTest = !this.useScreenCoordinates;
  this.sizeAttenuation = !this.useScreenCoordinates;
  this.scaleByViewport = !this.sizeAttenuation;
  this.alignment = THREE.SpriteAlignment.center.clone();
  this.fog = false;
  this.uvOffset = new THREE.Vector2(0, 0);
  this.uvScale = new THREE.Vector2(1, 1);
  this.setValues(parameters);
  parameters = parameters || {};
  if (parameters.depthTest === undefined)
    this.depthTest = !this.useScreenCoordinates;
  if (parameters.sizeAttenuation === undefined)
    this.sizeAttenuation = !this.useScreenCoordinates;
  if (parameters.scaleByViewport === undefined)
    this.scaleByViewport = !this.sizeAttenuation;
};
THREE.SpriteMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.SpriteMaterial.prototype.clone = function () {
  var material = new THREE.SpriteMaterial();
  THREE.Material.prototype.clone.call(this, material);
  material.color.copy(this.color);
  material.map = this.map;
  material.useScreenCoordinates = this.useScreenCoordinates;
  material.sizeAttenuation = this.sizeAttenuation;
  material.scaleByViewport = this.scaleByViewport;
  material.alignment.copy(this.alignment);
  material.uvOffset.copy(this.uvOffset);
  material.uvScale.copy(this.uvScale);
  material.fog = this.fog;
  return material;
};
THREE.SpriteAlignment = {};
THREE.SpriteAlignment.topLeft = new THREE.Vector2(1, -1);
THREE.SpriteAlignment.topCenter = new THREE.Vector2(0, -1);
THREE.SpriteAlignment.topRight = new THREE.Vector2(-1, -1);
THREE.SpriteAlignment.centerLeft = new THREE.Vector2(1, 0);
THREE.SpriteAlignment.center = new THREE.Vector2(0, 0);
THREE.SpriteAlignment.centerRight = new THREE.Vector2(-1, 0);
THREE.SpriteAlignment.bottomLeft = new THREE.Vector2(1, 1);
THREE.SpriteAlignment.bottomCenter = new THREE.Vector2(0, 1);
THREE.SpriteAlignment.bottomRight = new THREE.Vector2(-1, 1);
THREE.Texture = function (image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
  this.id = THREE.TextureIdCount++;
  this.uuid = THREE.Math.generateUUID();
  this.name = '';
  this.image = image;
  this.mipmaps = [];
  this.mapping = mapping !== undefined ? mapping : new THREE.UVMapping();
  this.wrapS = wrapS !== undefined ? wrapS : THREE.ClampToEdgeWrapping;
  this.wrapT = wrapT !== undefined ? wrapT : THREE.ClampToEdgeWrapping;
  this.magFilter = magFilter !== undefined ? magFilter : THREE.LinearFilter;
  this.minFilter = minFilter !== undefined ? minFilter : THREE.LinearMipMapLinearFilter;
  this.anisotropy = anisotropy !== undefined ? anisotropy : 1;
  this.format = format !== undefined ? format : THREE.RGBAFormat;
  this.type = type !== undefined ? type : THREE.UnsignedByteType;
  this.offset = new THREE.Vector2(0, 0);
  this.repeat = new THREE.Vector2(1, 1);
  this.generateMipmaps = true;
  this.premultiplyAlpha = false;
  this.flipY = true;
  this.unpackAlignment = 4;
  this.needsUpdate = false;
  this.onUpdate = null;
};
THREE.Texture.prototype = {
  constructor: THREE.Texture,
  clone: function (texture) {
    if (texture === undefined)
      texture = new THREE.Texture();
    texture.image = this.image;
    texture.mipmaps = this.mipmaps.slice(0);
    texture.mapping = this.mapping;
    texture.wrapS = this.wrapS;
    texture.wrapT = this.wrapT;
    texture.magFilter = this.magFilter;
    texture.minFilter = this.minFilter;
    texture.anisotropy = this.anisotropy;
    texture.format = this.format;
    texture.type = this.type;
    texture.offset.copy(this.offset);
    texture.repeat.copy(this.repeat);
    texture.generateMipmaps = this.generateMipmaps;
    texture.premultiplyAlpha = this.premultiplyAlpha;
    texture.flipY = this.flipY;
    texture.unpackAlignment = this.unpackAlignment;
    return texture;
  },
  dispose: function () {
    this.dispatchEvent({ type: 'dispose' });
  }
};
THREE.EventDispatcher.prototype.apply(THREE.Texture.prototype);
THREE.TextureIdCount = 0;
THREE.CompressedTexture = function (mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy) {
  THREE.Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
  this.image = {
    width: width,
    height: height
  };
  this.mipmaps = mipmaps;
  this.generateMipmaps = false;
};
THREE.CompressedTexture.prototype = Object.create(THREE.Texture.prototype);
THREE.CompressedTexture.prototype.clone = function () {
  var texture = new THREE.CompressedTexture();
  THREE.Texture.prototype.clone.call(this, texture);
  return texture;
};
THREE.DataTexture = function (data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy) {
  THREE.Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
  this.image = {
    data: data,
    width: width,
    height: height
  };
};
THREE.DataTexture.prototype = Object.create(THREE.Texture.prototype);
THREE.DataTexture.prototype.clone = function () {
  var texture = new THREE.DataTexture();
  THREE.Texture.prototype.clone.call(this, texture);
  return texture;
};
THREE.Particle = function (material) {
  THREE.Object3D.call(this);
  this.material = material;
};
THREE.Particle.prototype = Object.create(THREE.Object3D.prototype);
THREE.Particle.prototype.clone = function (object) {
  if (object === undefined)
    object = new THREE.Particle(this.material);
  THREE.Object3D.prototype.clone.call(this, object);
  return object;
};
THREE.ParticleSystem = function (geometry, material) {
  THREE.Object3D.call(this);
  this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
  this.material = material !== undefined ? material : new THREE.ParticleBasicMaterial({ color: Math.random() * 16777215 });
  this.sortParticles = false;
  this.frustumCulled = false;
};
THREE.ParticleSystem.prototype = Object.create(THREE.Object3D.prototype);
THREE.ParticleSystem.prototype.clone = function (object) {
  if (object === undefined)
    object = new THREE.ParticleSystem(this.geometry, this.material);
  object.sortParticles = this.sortParticles;
  THREE.Object3D.prototype.clone.call(this, object);
  return object;
};
THREE.Line = function (geometry, material, type) {
  THREE.Object3D.call(this);
  this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
  this.material = material !== undefined ? material : new THREE.LineBasicMaterial({ color: Math.random() * 16777215 });
  this.type = type !== undefined ? type : THREE.LineStrip;
};
THREE.LineStrip = 0;
THREE.LinePieces = 1;
THREE.Line.prototype = Object.create(THREE.Object3D.prototype);
THREE.Line.prototype.clone = function (object) {
  if (object === undefined)
    object = new THREE.Line(this.geometry, this.material, this.type);
  THREE.Object3D.prototype.clone.call(this, object);
  return object;
};
THREE.Mesh = function (geometry, material) {
  THREE.Object3D.call(this);
  this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
  this.material = material !== undefined ? material : new THREE.MeshBasicMaterial({ color: Math.random() * 16777215 });
  this.updateMorphTargets();
};
THREE.Mesh.prototype = Object.create(THREE.Object3D.prototype);
THREE.Mesh.prototype.updateMorphTargets = function () {
  if (this.geometry.morphTargets.length > 0) {
    this.morphTargetBase = -1;
    this.morphTargetForcedOrder = [];
    this.morphTargetInfluences = [];
    this.morphTargetDictionary = {};
    for (var m = 0, ml = this.geometry.morphTargets.length; m < ml; m++) {
      this.morphTargetInfluences.push(0);
      this.morphTargetDictionary[this.geometry.morphTargets[m].name] = m;
    }
  }
};
THREE.Mesh.prototype.getMorphTargetIndexByName = function (name) {
  if (this.morphTargetDictionary[name] !== undefined) {
    return this.morphTargetDictionary[name];
  }
  console.log('THREE.Mesh.getMorphTargetIndexByName: morph target ' + name + ' does not exist. Returning 0.');
  return 0;
};
THREE.Mesh.prototype.clone = function (object) {
  if (object === undefined)
    object = new THREE.Mesh(this.geometry, this.material);
  THREE.Object3D.prototype.clone.call(this, object);
  return object;
};
THREE.Bone = function (belongsToSkin) {
  THREE.Object3D.call(this);
  this.skin = belongsToSkin;
  this.skinMatrix = new THREE.Matrix4();
};
THREE.Bone.prototype = Object.create(THREE.Object3D.prototype);
THREE.Bone.prototype.update = function (parentSkinMatrix, forceUpdate) {
  if (this.matrixAutoUpdate) {
    forceUpdate |= this.updateMatrix();
  }
  if (forceUpdate || this.matrixWorldNeedsUpdate) {
    if (parentSkinMatrix) {
      this.skinMatrix.multiplyMatrices(parentSkinMatrix, this.matrix);
    } else {
      this.skinMatrix.copy(this.matrix);
    }
    this.matrixWorldNeedsUpdate = false;
    forceUpdate = true;
  }
  var child, i, l = this.children.length;
  for (i = 0; i < l; i++) {
    this.children[i].update(this.skinMatrix, forceUpdate);
  }
};
THREE.SkinnedMesh = function (geometry, material, useVertexTexture) {
  THREE.Mesh.call(this, geometry, material);
  this.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;
  this.identityMatrix = new THREE.Matrix4();
  this.bones = [];
  this.boneMatrices = [];
  var b, bone, gbone, p, q, s;
  if (this.geometry && this.geometry.bones !== undefined) {
    for (b = 0; b < this.geometry.bones.length; b++) {
      gbone = this.geometry.bones[b];
      p = gbone.pos;
      q = gbone.rotq;
      s = gbone.scl;
      bone = this.addBone();
      bone.name = gbone.name;
      bone.position.set(p[0], p[1], p[2]);
      bone.quaternion.set(q[0], q[1], q[2], q[3]);
      if (s !== undefined) {
        bone.scale.set(s[0], s[1], s[2]);
      } else {
        bone.scale.set(1, 1, 1);
      }
    }
    for (b = 0; b < this.bones.length; b++) {
      gbone = this.geometry.bones[b];
      bone = this.bones[b];
      if (gbone.parent === -1) {
        this.add(bone);
      } else {
        this.bones[gbone.parent].add(bone);
      }
    }
    var nBones = this.bones.length;
    if (this.useVertexTexture) {
      var size;
      if (nBones > 256)
        size = 64;
      else if (nBones > 64)
        size = 32;
      else if (nBones > 16)
        size = 16;
      else
        size = 8;
      this.boneTextureWidth = size;
      this.boneTextureHeight = size;
      this.boneMatrices = new Float32Array(this.boneTextureWidth * this.boneTextureHeight * 4);
      this.boneTexture = new THREE.DataTexture(this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType);
      this.boneTexture.minFilter = THREE.NearestFilter;
      this.boneTexture.magFilter = THREE.NearestFilter;
      this.boneTexture.generateMipmaps = false;
      this.boneTexture.flipY = false;
    } else {
      this.boneMatrices = new Float32Array(16 * nBones);
    }
    this.pose();
  }
};
THREE.SkinnedMesh.prototype = Object.create(THREE.Mesh.prototype);
THREE.SkinnedMesh.prototype.addBone = function (bone) {
  if (bone === undefined) {
    bone = new THREE.Bone(this);
  }
  this.bones.push(bone);
  return bone;
};
THREE.SkinnedMesh.prototype.updateMatrixWorld = function () {
  var offsetMatrix = new THREE.Matrix4();
  return function (force) {
    this.matrixAutoUpdate && this.updateMatrix();
    if (this.matrixWorldNeedsUpdate || force) {
      if (this.parent) {
        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
      } else {
        this.matrixWorld.copy(this.matrix);
      }
      this.matrixWorldNeedsUpdate = false;
      force = true;
    }
    for (var i = 0, l = this.children.length; i < l; i++) {
      var child = this.children[i];
      if (child instanceof THREE.Bone) {
        child.update(this.identityMatrix, false);
      } else {
        child.updateMatrixWorld(true);
      }
    }
    if (this.boneInverses == undefined) {
      this.boneInverses = [];
      for (var b = 0, bl = this.bones.length; b < bl; b++) {
        var inverse = new THREE.Matrix4();
        inverse.getInverse(this.bones[b].skinMatrix);
        this.boneInverses.push(inverse);
      }
    }
    for (var b = 0, bl = this.bones.length; b < bl; b++) {
      offsetMatrix.multiplyMatrices(this.bones[b].skinMatrix, this.boneInverses[b]);
      offsetMatrix.flattenToArrayOffset(this.boneMatrices, b * 16);
    }
    if (this.useVertexTexture) {
      this.boneTexture.needsUpdate = true;
    }
  };
}();
THREE.SkinnedMesh.prototype.pose = function () {
  this.updateMatrixWorld(true);
  this.normalizeSkinWeights();
};
THREE.SkinnedMesh.prototype.normalizeSkinWeights = function () {
  if (this.geometry instanceof THREE.Geometry) {
    for (var i = 0; i < this.geometry.skinIndices.length; i++) {
      var sw = this.geometry.skinWeights[i];
      var scale = 1 / sw.lengthManhattan();
      if (scale !== Infinity) {
        sw.multiplyScalar(scale);
      } else {
        sw.set(1);
      }
    }
  } else {
  }
};
THREE.SkinnedMesh.prototype.clone = function (object) {
  if (object === undefined) {
    object = new THREE.SkinnedMesh(this.geometry, this.material, this.useVertexTexture);
  }
  THREE.Mesh.prototype.clone.call(this, object);
  return object;
};
THREE.MorphAnimMesh = function (geometry, material) {
  THREE.Mesh.call(this, geometry, material);
  this.duration = 1000;
  this.mirroredLoop = false;
  this.time = 0;
  this.lastKeyframe = 0;
  this.currentKeyframe = 0;
  this.direction = 1;
  this.directionBackwards = false;
  this.setFrameRange(0, this.geometry.morphTargets.length - 1);
};
THREE.MorphAnimMesh.prototype = Object.create(THREE.Mesh.prototype);
THREE.MorphAnimMesh.prototype.setFrameRange = function (start, end) {
  this.startKeyframe = start;
  this.endKeyframe = end;
  this.length = this.endKeyframe - this.startKeyframe + 1;
};
THREE.MorphAnimMesh.prototype.setDirectionForward = function () {
  this.direction = 1;
  this.directionBackwards = false;
};
THREE.MorphAnimMesh.prototype.setDirectionBackward = function () {
  this.direction = -1;
  this.directionBackwards = true;
};
THREE.MorphAnimMesh.prototype.parseAnimations = function () {
  var geometry = this.geometry;
  if (!geometry.animations)
    geometry.animations = {};
  var firstAnimation, animations = geometry.animations;
  var pattern = /([a-z]+)(\d+)/;
  for (var i = 0, il = geometry.morphTargets.length; i < il; i++) {
    var morph = geometry.morphTargets[i];
    var parts = morph.name.match(pattern);
    if (parts && parts.length > 1) {
      var label = parts[1];
      var num = parts[2];
      if (!animations[label])
        animations[label] = {
          start: Infinity,
          end: -Infinity
        };
      var animation = animations[label];
      if (i < animation.start)
        animation.start = i;
      if (i > animation.end)
        animation.end = i;
      if (!firstAnimation)
        firstAnimation = label;
    }
  }
  geometry.firstAnimation = firstAnimation;
};
THREE.MorphAnimMesh.prototype.setAnimationLabel = function (label, start, end) {
  if (!this.geometry.animations)
    this.geometry.animations = {};
  this.geometry.animations[label] = {
    start: start,
    end: end
  };
};
THREE.MorphAnimMesh.prototype.playAnimation = function (label, fps) {
  var animation = this.geometry.animations[label];
  if (animation) {
    this.setFrameRange(animation.start, animation.end);
    this.duration = 1000 * ((animation.end - animation.start) / fps);
    this.time = 0;
  } else {
    console.warn('animation[' + label + '] undefined');
  }
};
THREE.MorphAnimMesh.prototype.updateAnimation = function (delta) {
  var frameTime = this.duration / this.length;
  this.time += this.direction * delta;
  if (this.mirroredLoop) {
    if (this.time > this.duration || this.time < 0) {
      this.direction *= -1;
      if (this.time > this.duration) {
        this.time = this.duration;
        this.directionBackwards = true;
      }
      if (this.time < 0) {
        this.time = 0;
        this.directionBackwards = false;
      }
    }
  } else {
    this.time = this.time % this.duration;
    if (this.time < 0)
      this.time += this.duration;
  }
  var keyframe = this.startKeyframe + THREE.Math.clamp(Math.floor(this.time / frameTime), 0, this.length - 1);
  if (keyframe !== this.currentKeyframe) {
    this.morphTargetInfluences[this.lastKeyframe] = 0;
    this.morphTargetInfluences[this.currentKeyframe] = 1;
    this.morphTargetInfluences[keyframe] = 0;
    this.lastKeyframe = this.currentKeyframe;
    this.currentKeyframe = keyframe;
  }
  var mix = this.time % frameTime / frameTime;
  if (this.directionBackwards) {
    mix = 1 - mix;
  }
  this.morphTargetInfluences[this.currentKeyframe] = mix;
  this.morphTargetInfluences[this.lastKeyframe] = 1 - mix;
};
THREE.MorphAnimMesh.prototype.clone = function (object) {
  if (object === undefined)
    object = new THREE.MorphAnimMesh(this.geometry, this.material);
  object.duration = this.duration;
  object.mirroredLoop = this.mirroredLoop;
  object.time = this.time;
  object.lastKeyframe = this.lastKeyframe;
  object.currentKeyframe = this.currentKeyframe;
  object.direction = this.direction;
  object.directionBackwards = this.directionBackwards;
  THREE.Mesh.prototype.clone.call(this, object);
  return object;
};
THREE.Ribbon = function (geometry, material) {
  THREE.Object3D.call(this);
  this.geometry = geometry;
  this.material = material;
};
THREE.Ribbon.prototype = Object.create(THREE.Object3D.prototype);
THREE.Ribbon.prototype.clone = function (object) {
  if (object === undefined)
    object = new THREE.Ribbon(this.geometry, this.material);
  THREE.Object3D.prototype.clone.call(this, object);
  return object;
};
THREE.LOD = function () {
  THREE.Object3D.call(this);
  this.objects = [];
};
THREE.LOD.prototype = Object.create(THREE.Object3D.prototype);
THREE.LOD.prototype.addLevel = function (object, distance) {
  if (distance === undefined)
    distance = 0;
  distance = Math.abs(distance);
  for (var l = 0; l < this.objects.length; l++) {
    if (distance < this.objects[l].distance) {
      break;
    }
  }
  this.objects.splice(l, 0, {
    distance: distance,
    object: object
  });
  this.add(object);
};
THREE.LOD.prototype.getObjectForDistance = function (distance) {
  for (var i = 1, l = this.objects.length; i < l; i++) {
    if (distance < this.objects[i].distance) {
      break;
    }
  }
  return this.objects[i - 1].object;
};
THREE.LOD.prototype.update = function () {
  var v1 = new THREE.Vector3();
  var v2 = new THREE.Vector3();
  return function (camera) {
    if (this.objects.length > 1) {
      v1.getPositionFromMatrix(camera.matrixWorld);
      v2.getPositionFromMatrix(this.matrixWorld);
      var distance = v1.distanceTo(v2);
      this.objects[0].object.visible = true;
      for (var i = 1, l = this.objects.length; i < l; i++) {
        if (distance >= this.objects[i].distance) {
          this.objects[i - 1].object.visible = false;
          this.objects[i].object.visible = true;
        } else {
          break;
        }
      }
      for (; i < l; i++) {
        this.objects[i].object.visible = false;
      }
    }
  };
}();
THREE.LOD.prototype.clone = function () {
};
THREE.Sprite = function (material) {
  THREE.Object3D.call(this);
  this.material = material !== undefined ? material : new THREE.SpriteMaterial();
  this.rotation3d = this.rotation;
  this.rotation = 0;
};
THREE.Sprite.prototype = Object.create(THREE.Object3D.prototype);
THREE.Sprite.prototype.updateMatrix = function () {
  this.rotation3d.set(0, 0, this.rotation, this.rotation3d.order);
  this.quaternion.setFromEuler(this.rotation3d);
  this.matrix.compose(this.position, this.quaternion, this.scale);
  this.matrixWorldNeedsUpdate = true;
};
THREE.Sprite.prototype.clone = function (object) {
  if (object === undefined)
    object = new THREE.Sprite(this.material);
  THREE.Object3D.prototype.clone.call(this, object);
  return object;
};
THREE.Scene = function () {
  THREE.Object3D.call(this);
  this.fog = null;
  this.overrideMaterial = null;
  this.autoUpdate = true;
  this.matrixAutoUpdate = false;
  this.__objects = [];
  this.__lights = [];
  this.__objectsAdded = [];
  this.__objectsRemoved = [];
};
THREE.Scene.prototype = Object.create(THREE.Object3D.prototype);
THREE.Scene.prototype.__addObject = function (object) {
  if (object instanceof THREE.Light) {
    if (this.__lights.indexOf(object) === -1) {
      this.__lights.push(object);
    }
    if (object.target && object.target.parent === undefined) {
      this.add(object.target);
    }
  } else if (!(object instanceof THREE.Camera || object instanceof THREE.Bone)) {
    if (this.__objects.indexOf(object) === -1) {
      this.__objects.push(object);
      this.__objectsAdded.push(object);
      var i = this.__objectsRemoved.indexOf(object);
      if (i !== -1) {
        this.__objectsRemoved.splice(i, 1);
      }
    }
  }
  for (var c = 0; c < object.children.length; c++) {
    this.__addObject(object.children[c]);
  }
};
THREE.Scene.prototype.__removeObject = function (object) {
  if (object instanceof THREE.Light) {
    var i = this.__lights.indexOf(object);
    if (i !== -1) {
      this.__lights.splice(i, 1);
    }
  } else if (!(object instanceof THREE.Camera)) {
    var i = this.__objects.indexOf(object);
    if (i !== -1) {
      this.__objects.splice(i, 1);
      this.__objectsRemoved.push(object);
      var ai = this.__objectsAdded.indexOf(object);
      if (ai !== -1) {
        this.__objectsAdded.splice(ai, 1);
      }
    }
  }
  for (var c = 0; c < object.children.length; c++) {
    this.__removeObject(object.children[c]);
  }
};
THREE.Scene.prototype.clone = function (object) {
  if (object === undefined)
    object = new THREE.Scene();
  THREE.Object3D.prototype.clone.call(this, object);
  if (this.fog !== null)
    object.fog = this.fog.clone();
  if (this.overrideMaterial !== null)
    object.overrideMaterial = this.overrideMaterial.clone();
  object.autoUpdate = this.autoUpdate;
  object.matrixAutoUpdate = this.matrixAutoUpdate;
  return object;
};
THREE.Fog = function (hex, near, far) {
  this.name = '';
  this.color = new THREE.Color(hex);
  this.near = near !== undefined ? near : 1;
  this.far = far !== undefined ? far : 1000;
};
THREE.Fog.prototype.clone = function () {
  return new THREE.Fog(this.color.getHex(), this.near, this.far);
};
THREE.FogExp2 = function (hex, density) {
  this.name = '';
  this.color = new THREE.Color(hex);
  this.density = density !== undefined ? density : 0.00025;
};
THREE.FogExp2.prototype.clone = function () {
  return new THREE.FogExp2(this.color.getHex(), this.density);
};
THREE.CanvasRenderer = function (parameters) {
  console.log('THREE.CanvasRenderer', THREE.REVISION);
  var smoothstep = THREE.Math.smoothstep;
  parameters = parameters || {};
  var _this = this, _renderData, _elements, _lights, _projector = new THREE.Projector(), _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElement('canvas'), _canvasWidth, _canvasHeight, _canvasWidthHalf, _canvasHeightHalf, _context = _canvas.getContext('2d'), _clearColor = new THREE.Color(0), _clearAlpha = 0, _contextGlobalAlpha = 1, _contextGlobalCompositeOperation = 0, _contextStrokeStyle = null, _contextFillStyle = null, _contextLineWidth = null, _contextLineCap = null, _contextLineJoin = null, _contextDashSize = null, _contextGapSize = 0, _camera, _v1, _v2, _v3, _v4, _v5 = new THREE.RenderableVertex(), _v6 = new THREE.RenderableVertex(), _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _v4x, _v4y, _v5x, _v5y, _v6x, _v6y, _color = new THREE.Color(), _color1 = new THREE.Color(), _color2 = new THREE.Color(), _color3 = new THREE.Color(), _color4 = new THREE.Color(), _diffuseColor = new THREE.Color(), _emissiveColor = new THREE.Color(), _lightColor = new THREE.Color(), _patterns = {}, _imagedatas = {}, _near, _far, _image, _uvs, _uv1x, _uv1y, _uv2x, _uv2y, _uv3x, _uv3y, _clipBox = new THREE.Box2(), _clearBox = new THREE.Box2(), _elemBox = new THREE.Box2(), _ambientLight = new THREE.Color(), _directionalLights = new THREE.Color(), _pointLights = new THREE.Color(), _vector3 = new THREE.Vector3(), _pixelMap, _pixelMapContext, _pixelMapImage, _pixelMapData, _gradientMap, _gradientMapContext, _gradientMapQuality = 16;
  _pixelMap = document.createElement('canvas');
  _pixelMap.width = _pixelMap.height = 2;
  _pixelMapContext = _pixelMap.getContext('2d');
  _pixelMapContext.fillStyle = 'rgba(0,0,0,1)';
  _pixelMapContext.fillRect(0, 0, 2, 2);
  _pixelMapImage = _pixelMapContext.getImageData(0, 0, 2, 2);
  _pixelMapData = _pixelMapImage.data;
  _gradientMap = document.createElement('canvas');
  _gradientMap.width = _gradientMap.height = _gradientMapQuality;
  _gradientMapContext = _gradientMap.getContext('2d');
  _gradientMapContext.translate(-_gradientMapQuality / 2, -_gradientMapQuality / 2);
  _gradientMapContext.scale(_gradientMapQuality, _gradientMapQuality);
  _gradientMapQuality--;
  if (_context.setLineDash === undefined) {
    if (_context.mozDash !== undefined) {
      _context.setLineDash = function (values) {
        _context.mozDash = values[0] !== null ? values : null;
      };
    } else {
      _context.setLineDash = function () {
      };
    }
  }
  this.domElement = _canvas;
  this.devicePixelRatio = parameters.devicePixelRatio !== undefined ? parameters.devicePixelRatio : window.devicePixelRatio !== undefined ? window.devicePixelRatio : 1;
  this.autoClear = true;
  this.sortObjects = true;
  this.sortElements = true;
  this.info = {
    render: {
      vertices: 0,
      faces: 0
    }
  };
  this.supportsVertexTextures = function () {
  };
  this.setFaceCulling = function () {
  };
  this.setSize = function (width, height, updateStyle) {
    _canvasWidth = width * this.devicePixelRatio;
    _canvasHeight = height * this.devicePixelRatio;
    _canvasWidthHalf = Math.floor(_canvasWidth / 2);
    _canvasHeightHalf = Math.floor(_canvasHeight / 2);
    _canvas.width = _canvasWidth;
    _canvas.height = _canvasHeight;
    if (this.devicePixelRatio !== 1 && updateStyle !== false) {
      _canvas.style.width = width + 'px';
      _canvas.style.height = height + 'px';
    }
    _clipBox.set(new THREE.Vector2(-_canvasWidthHalf, -_canvasHeightHalf), new THREE.Vector2(_canvasWidthHalf, _canvasHeightHalf));
    _clearBox.set(new THREE.Vector2(-_canvasWidthHalf, -_canvasHeightHalf), new THREE.Vector2(_canvasWidthHalf, _canvasHeightHalf));
    _contextGlobalAlpha = 1;
    _contextGlobalCompositeOperation = 0;
    _contextStrokeStyle = null;
    _contextFillStyle = null;
    _contextLineWidth = null;
    _contextLineCap = null;
    _contextLineJoin = null;
  };
  this.setClearColor = function (color, alpha) {
    _clearColor.set(color);
    _clearAlpha = alpha !== undefined ? alpha : 1;
    _clearBox.set(new THREE.Vector2(-_canvasWidthHalf, -_canvasHeightHalf), new THREE.Vector2(_canvasWidthHalf, _canvasHeightHalf));
  };
  this.setClearColorHex = function (hex, alpha) {
    console.warn('DEPRECATED: .setClearColorHex() is being removed. Use .setClearColor() instead.');
    this.setClearColor(hex, alpha);
  };
  this.getMaxAnisotropy = function () {
    return 0;
  };
  this.clear = function () {
    _context.setTransform(1, 0, 0, -1, _canvasWidthHalf, _canvasHeightHalf);
    if (_clearBox.empty() === false) {
      _clearBox.intersect(_clipBox);
      _clearBox.expandByScalar(2);
      if (_clearAlpha < 1) {
        _context.clearRect(_clearBox.min.x | 0, _clearBox.min.y | 0, _clearBox.max.x - _clearBox.min.x | 0, _clearBox.max.y - _clearBox.min.y | 0);
      }
      if (_clearAlpha > 0) {
        setBlending(THREE.NormalBlending);
        setOpacity(1);
        setFillStyle('rgba(' + Math.floor(_clearColor.r * 255) + ',' + Math.floor(_clearColor.g * 255) + ',' + Math.floor(_clearColor.b * 255) + ',' + _clearAlpha + ')');
        _context.fillRect(_clearBox.min.x | 0, _clearBox.min.y | 0, _clearBox.max.x - _clearBox.min.x | 0, _clearBox.max.y - _clearBox.min.y | 0);
      }
      _clearBox.makeEmpty();
    }
  };
  this.render = function (scene, camera) {
    if (camera instanceof THREE.Camera === false) {
      console.error('THREE.CanvasRenderer.render: camera is not an instance of THREE.Camera.');
      return;
    }
    if (this.autoClear === true)
      this.clear();
    _context.setTransform(1, 0, 0, -1, _canvasWidthHalf, _canvasHeightHalf);
    _this.info.render.vertices = 0;
    _this.info.render.faces = 0;
    _renderData = _projector.projectScene(scene, camera, this.sortObjects, this.sortElements);
    _elements = _renderData.elements;
    _lights = _renderData.lights;
    _camera = camera;
    calculateLights();
    for (var e = 0, el = _elements.length; e < el; e++) {
      var element = _elements[e];
      var material = element.material;
      if (material === undefined || material.visible === false)
        continue;
      _elemBox.makeEmpty();
      if (element instanceof THREE.RenderableParticle) {
        _v1 = element;
        _v1.x *= _canvasWidthHalf;
        _v1.y *= _canvasHeightHalf;
        renderParticle(_v1, element, material);
      } else if (element instanceof THREE.RenderableLine) {
        _v1 = element.v1;
        _v2 = element.v2;
        _v1.positionScreen.x *= _canvasWidthHalf;
        _v1.positionScreen.y *= _canvasHeightHalf;
        _v2.positionScreen.x *= _canvasWidthHalf;
        _v2.positionScreen.y *= _canvasHeightHalf;
        _elemBox.setFromPoints([
          _v1.positionScreen,
          _v2.positionScreen
        ]);
        if (_clipBox.isIntersectionBox(_elemBox) === true) {
          renderLine(_v1, _v2, element, material);
        }
      } else if (element instanceof THREE.RenderableFace3) {
        _v1 = element.v1;
        _v2 = element.v2;
        _v3 = element.v3;
        if (_v1.positionScreen.z < -1 || _v1.positionScreen.z > 1)
          continue;
        if (_v2.positionScreen.z < -1 || _v2.positionScreen.z > 1)
          continue;
        if (_v3.positionScreen.z < -1 || _v3.positionScreen.z > 1)
          continue;
        _v1.positionScreen.x *= _canvasWidthHalf;
        _v1.positionScreen.y *= _canvasHeightHalf;
        _v2.positionScreen.x *= _canvasWidthHalf;
        _v2.positionScreen.y *= _canvasHeightHalf;
        _v3.positionScreen.x *= _canvasWidthHalf;
        _v3.positionScreen.y *= _canvasHeightHalf;
        if (material.overdraw > 0) {
          expand(_v1.positionScreen, _v2.positionScreen, material.overdraw);
          expand(_v2.positionScreen, _v3.positionScreen, material.overdraw);
          expand(_v3.positionScreen, _v1.positionScreen, material.overdraw);
        }
        _elemBox.setFromPoints([
          _v1.positionScreen,
          _v2.positionScreen,
          _v3.positionScreen
        ]);
        if (_clipBox.isIntersectionBox(_elemBox) === true) {
          renderFace3(_v1, _v2, _v3, 0, 1, 2, element, material);
        }
      }
      _clearBox.union(_elemBox);
    }
    _context.setTransform(1, 0, 0, 1, 0, 0);
  };
  function calculateLights() {
    _ambientLight.setRGB(0, 0, 0);
    _directionalLights.setRGB(0, 0, 0);
    _pointLights.setRGB(0, 0, 0);
    for (var l = 0, ll = _lights.length; l < ll; l++) {
      var light = _lights[l];
      var lightColor = light.color;
      if (light instanceof THREE.AmbientLight) {
        _ambientLight.add(lightColor);
      } else if (light instanceof THREE.DirectionalLight) {
        _directionalLights.add(lightColor);
      } else if (light instanceof THREE.PointLight) {
        _pointLights.add(lightColor);
      }
    }
  }
  function calculateLight(position, normal, color) {
    for (var l = 0, ll = _lights.length; l < ll; l++) {
      var light = _lights[l];
      _lightColor.copy(light.color);
      if (light instanceof THREE.DirectionalLight) {
        var lightPosition = _vector3.getPositionFromMatrix(light.matrixWorld).normalize();
        var amount = normal.dot(lightPosition);
        if (amount <= 0)
          continue;
        amount *= light.intensity;
        color.add(_lightColor.multiplyScalar(amount));
      } else if (light instanceof THREE.PointLight) {
        var lightPosition = _vector3.getPositionFromMatrix(light.matrixWorld);
        var amount = normal.dot(_vector3.subVectors(lightPosition, position).normalize());
        if (amount <= 0)
          continue;
        amount *= light.distance == 0 ? 1 : 1 - Math.min(position.distanceTo(lightPosition) / light.distance, 1);
        if (amount == 0)
          continue;
        amount *= light.intensity;
        color.add(_lightColor.multiplyScalar(amount));
      }
    }
  }
  function renderParticle(v1, element, material) {
    setOpacity(material.opacity);
    setBlending(material.blending);
    var width, height, scaleX, scaleY, bitmap, bitmapWidth, bitmapHeight;
    if (material instanceof THREE.ParticleBasicMaterial) {
      if (material.map === null) {
        scaleX = element.object.scale.x;
        scaleY = element.object.scale.y;
        scaleX *= element.scale.x * _canvasWidthHalf;
        scaleY *= element.scale.y * _canvasHeightHalf;
        _elemBox.min.set(v1.x - scaleX, v1.y - scaleY);
        _elemBox.max.set(v1.x + scaleX, v1.y + scaleY);
        if (_clipBox.isIntersectionBox(_elemBox) === false) {
          _elemBox.makeEmpty();
          return;
        }
        setFillStyle(material.color.getStyle());
        _context.save();
        _context.translate(v1.x, v1.y);
        _context.rotate(-element.rotation);
        _context.scale(scaleX, scaleY);
        _context.fillRect(-1, -1, 2, 2);
        _context.restore();
      } else {
        bitmap = material.map.image;
        bitmapWidth = bitmap.width >> 1;
        bitmapHeight = bitmap.height >> 1;
        scaleX = element.scale.x * _canvasWidthHalf;
        scaleY = element.scale.y * _canvasHeightHalf;
        width = scaleX * bitmapWidth;
        height = scaleY * bitmapHeight;
        _elemBox.min.set(v1.x - width, v1.y - height);
        _elemBox.max.set(v1.x + width, v1.y + height);
        if (_clipBox.isIntersectionBox(_elemBox) === false) {
          _elemBox.makeEmpty();
          return;
        }
        _context.save();
        _context.translate(v1.x, v1.y);
        _context.rotate(-element.rotation);
        _context.scale(scaleX, -scaleY);
        _context.translate(-bitmapWidth, -bitmapHeight);
        _context.drawImage(bitmap, 0, 0);
        _context.restore();
      }
    } else if (material instanceof THREE.ParticleCanvasMaterial) {
      width = element.scale.x * _canvasWidthHalf;
      height = element.scale.y * _canvasHeightHalf;
      _elemBox.min.set(v1.x - width, v1.y - height);
      _elemBox.max.set(v1.x + width, v1.y + height);
      if (_clipBox.isIntersectionBox(_elemBox) === false) {
        _elemBox.makeEmpty();
        return;
      }
      setStrokeStyle(material.color.getStyle());
      setFillStyle(material.color.getStyle());
      _context.save();
      _context.translate(v1.x, v1.y);
      _context.rotate(-element.rotation);
      _context.scale(width, height);
      material.program(_context);
      _context.restore();
    }
  }
  function renderLine(v1, v2, element, material) {
    setOpacity(material.opacity);
    setBlending(material.blending);
    _context.beginPath();
    _context.moveTo(v1.positionScreen.x, v1.positionScreen.y);
    _context.lineTo(v2.positionScreen.x, v2.positionScreen.y);
    if (material instanceof THREE.LineBasicMaterial) {
      setLineWidth(material.linewidth);
      setLineCap(material.linecap);
      setLineJoin(material.linejoin);
      if (material.vertexColors !== THREE.VertexColors) {
        setStrokeStyle(material.color.getStyle());
      } else {
        var colorStyle1 = element.vertexColors[0].getStyle();
        var colorStyle2 = element.vertexColors[1].getStyle();
        if (colorStyle1 === colorStyle2) {
          setStrokeStyle(colorStyle1);
        } else {
          try {
            var grad = _context.createLinearGradient(v1.positionScreen.x, v1.positionScreen.y, v2.positionScreen.x, v2.positionScreen.y);
            grad.addColorStop(0, colorStyle1);
            grad.addColorStop(1, colorStyle2);
          } catch (exception) {
            grad = colorStyle1;
          }
          setStrokeStyle(grad);
        }
      }
      _context.stroke();
      _elemBox.expandByScalar(material.linewidth * 2);
    } else if (material instanceof THREE.LineDashedMaterial) {
      setLineWidth(material.linewidth);
      setLineCap(material.linecap);
      setLineJoin(material.linejoin);
      setStrokeStyle(material.color.getStyle());
      setDashAndGap(material.dashSize, material.gapSize);
      _context.stroke();
      _elemBox.expandByScalar(material.linewidth * 2);
      setDashAndGap(null, null);
    }
  }
  function renderFace3(v1, v2, v3, uv1, uv2, uv3, element, material) {
    _this.info.render.vertices += 3;
    _this.info.render.faces++;
    setOpacity(material.opacity);
    setBlending(material.blending);
    _v1x = v1.positionScreen.x;
    _v1y = v1.positionScreen.y;
    _v2x = v2.positionScreen.x;
    _v2y = v2.positionScreen.y;
    _v3x = v3.positionScreen.x;
    _v3y = v3.positionScreen.y;
    drawTriangle(_v1x, _v1y, _v2x, _v2y, _v3x, _v3y);
    if ((material instanceof THREE.MeshLambertMaterial || material instanceof THREE.MeshPhongMaterial) && material.map === null) {
      _diffuseColor.copy(material.color);
      _emissiveColor.copy(material.emissive);
      if (material.vertexColors === THREE.FaceColors) {
        _diffuseColor.multiply(element.color);
      }
      if (material.wireframe === false && material.shading == THREE.SmoothShading && element.vertexNormalsLength == 3) {
        _color1.copy(_ambientLight);
        _color2.copy(_ambientLight);
        _color3.copy(_ambientLight);
        calculateLight(element.v1.positionWorld, element.vertexNormalsModel[0], _color1);
        calculateLight(element.v2.positionWorld, element.vertexNormalsModel[1], _color2);
        calculateLight(element.v3.positionWorld, element.vertexNormalsModel[2], _color3);
        _color1.multiply(_diffuseColor).add(_emissiveColor);
        _color2.multiply(_diffuseColor).add(_emissiveColor);
        _color3.multiply(_diffuseColor).add(_emissiveColor);
        _color4.addColors(_color2, _color3).multiplyScalar(0.5);
        _image = getGradientTexture(_color1, _color2, _color3, _color4);
        clipImage(_v1x, _v1y, _v2x, _v2y, _v3x, _v3y, 0, 0, 1, 0, 0, 1, _image);
      } else {
        _color.copy(_ambientLight);
        calculateLight(element.centroidModel, element.normalModel, _color);
        _color.multiply(_diffuseColor).add(_emissiveColor);
        material.wireframe === true ? strokePath(_color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin) : fillPath(_color);
      }
    } else if (material instanceof THREE.MeshBasicMaterial || material instanceof THREE.MeshLambertMaterial || material instanceof THREE.MeshPhongMaterial) {
      if (material.map !== null) {
        if (material.map.mapping instanceof THREE.UVMapping) {
          _uvs = element.uvs[0];
          patternPath(_v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _uvs[uv1].x, _uvs[uv1].y, _uvs[uv2].x, _uvs[uv2].y, _uvs[uv3].x, _uvs[uv3].y, material.map);
        }
      } else if (material.envMap !== null) {
        if (material.envMap.mapping instanceof THREE.SphericalReflectionMapping) {
          _vector3.copy(element.vertexNormalsModelView[uv1]);
          _uv1x = 0.5 * _vector3.x + 0.5;
          _uv1y = 0.5 * _vector3.y + 0.5;
          _vector3.copy(element.vertexNormalsModelView[uv2]);
          _uv2x = 0.5 * _vector3.x + 0.5;
          _uv2y = 0.5 * _vector3.y + 0.5;
          _vector3.copy(element.vertexNormalsModelView[uv3]);
          _uv3x = 0.5 * _vector3.x + 0.5;
          _uv3y = 0.5 * _vector3.y + 0.5;
          patternPath(_v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _uv1x, _uv1y, _uv2x, _uv2y, _uv3x, _uv3y, material.envMap);
        }
      } else {
        _color.copy(material.color);
        if (material.vertexColors === THREE.FaceColors) {
          _color.multiply(element.color);
        }
        material.wireframe === true ? strokePath(_color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin) : fillPath(_color);
      }
    } else if (material instanceof THREE.MeshDepthMaterial) {
      _near = _camera.near;
      _far = _camera.far;
      _color1.r = _color1.g = _color1.b = 1 - smoothstep(v1.positionScreen.z * v1.positionScreen.w, _near, _far);
      _color2.r = _color2.g = _color2.b = 1 - smoothstep(v2.positionScreen.z * v2.positionScreen.w, _near, _far);
      _color3.r = _color3.g = _color3.b = 1 - smoothstep(v3.positionScreen.z * v3.positionScreen.w, _near, _far);
      _color4.addColors(_color2, _color3).multiplyScalar(0.5);
      _image = getGradientTexture(_color1, _color2, _color3, _color4);
      clipImage(_v1x, _v1y, _v2x, _v2y, _v3x, _v3y, 0, 0, 1, 0, 0, 1, _image);
    } else if (material instanceof THREE.MeshNormalMaterial) {
      var normal;
      if (material.shading == THREE.FlatShading) {
        normal = element.normalModelView;
        _color.setRGB(normal.x, normal.y, normal.z).multiplyScalar(0.5).addScalar(0.5);
        material.wireframe === true ? strokePath(_color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin) : fillPath(_color);
      } else if (material.shading == THREE.SmoothShading) {
        normal = element.vertexNormalsModelView[uv1];
        _color1.setRGB(normal.x, normal.y, normal.z).multiplyScalar(0.5).addScalar(0.5);
        normal = element.vertexNormalsModelView[uv2];
        _color2.setRGB(normal.x, normal.y, normal.z).multiplyScalar(0.5).addScalar(0.5);
        normal = element.vertexNormalsModelView[uv3];
        _color3.setRGB(normal.x, normal.y, normal.z).multiplyScalar(0.5).addScalar(0.5);
        _color4.addColors(_color2, _color3).multiplyScalar(0.5);
        _image = getGradientTexture(_color1, _color2, _color3, _color4);
        clipImage(_v1x, _v1y, _v2x, _v2y, _v3x, _v3y, 0, 0, 1, 0, 0, 1, _image);
      }
    }
  }
  function drawTriangle(x0, y0, x1, y1, x2, y2) {
    _context.beginPath();
    _context.moveTo(x0, y0);
    _context.lineTo(x1, y1);
    _context.lineTo(x2, y2);
    _context.closePath();
  }
  function strokePath(color, linewidth, linecap, linejoin) {
    setLineWidth(linewidth);
    setLineCap(linecap);
    setLineJoin(linejoin);
    setStrokeStyle(color.getStyle());
    _context.stroke();
    _elemBox.expandByScalar(linewidth * 2);
  }
  function fillPath(color) {
    setFillStyle(color.getStyle());
    _context.fill();
  }
  function patternPath(x0, y0, x1, y1, x2, y2, u0, v0, u1, v1, u2, v2, texture) {
    if (texture instanceof THREE.DataTexture || texture.image === undefined || texture.image.width == 0)
      return;
    if (texture.needsUpdate === true) {
      var repeatX = texture.wrapS == THREE.RepeatWrapping;
      var repeatY = texture.wrapT == THREE.RepeatWrapping;
      _patterns[texture.id] = _context.createPattern(texture.image, repeatX === true && repeatY === true ? 'repeat' : repeatX === true && repeatY === false ? 'repeat-x' : repeatX === false && repeatY === true ? 'repeat-y' : 'no-repeat');
      texture.needsUpdate = false;
    }
    _patterns[texture.id] === undefined ? setFillStyle('rgba(0,0,0,1)') : setFillStyle(_patterns[texture.id]);
    var a, b, c, d, e, f, det, idet, offsetX = texture.offset.x / texture.repeat.x, offsetY = texture.offset.y / texture.repeat.y, width = texture.image.width * texture.repeat.x, height = texture.image.height * texture.repeat.y;
    u0 = (u0 + offsetX) * width;
    v0 = (1 - v0 + offsetY) * height;
    u1 = (u1 + offsetX) * width;
    v1 = (1 - v1 + offsetY) * height;
    u2 = (u2 + offsetX) * width;
    v2 = (1 - v2 + offsetY) * height;
    x1 -= x0;
    y1 -= y0;
    x2 -= x0;
    y2 -= y0;
    u1 -= u0;
    v1 -= v0;
    u2 -= u0;
    v2 -= v0;
    det = u1 * v2 - u2 * v1;
    if (det === 0) {
      if (_imagedatas[texture.id] === undefined) {
        var canvas = document.createElement('canvas');
        canvas.width = texture.image.width;
        canvas.height = texture.image.height;
        var context = canvas.getContext('2d');
        context.drawImage(texture.image, 0, 0);
        _imagedatas[texture.id] = context.getImageData(0, 0, texture.image.width, texture.image.height).data;
      }
      var data = _imagedatas[texture.id];
      var index = (Math.floor(u0) + Math.floor(v0) * texture.image.width) * 4;
      _color.setRGB(data[index] / 255, data[index + 1] / 255, data[index + 2] / 255);
      fillPath(_color);
      return;
    }
    idet = 1 / det;
    a = (v2 * x1 - v1 * x2) * idet;
    b = (v2 * y1 - v1 * y2) * idet;
    c = (u1 * x2 - u2 * x1) * idet;
    d = (u1 * y2 - u2 * y1) * idet;
    e = x0 - a * u0 - c * v0;
    f = y0 - b * u0 - d * v0;
    _context.save();
    _context.transform(a, b, c, d, e, f);
    _context.fill();
    _context.restore();
  }
  function clipImage(x0, y0, x1, y1, x2, y2, u0, v0, u1, v1, u2, v2, image) {
    var a, b, c, d, e, f, det, idet, width = image.width - 1, height = image.height - 1;
    u0 *= width;
    v0 *= height;
    u1 *= width;
    v1 *= height;
    u2 *= width;
    v2 *= height;
    x1 -= x0;
    y1 -= y0;
    x2 -= x0;
    y2 -= y0;
    u1 -= u0;
    v1 -= v0;
    u2 -= u0;
    v2 -= v0;
    det = u1 * v2 - u2 * v1;
    idet = 1 / det;
    a = (v2 * x1 - v1 * x2) * idet;
    b = (v2 * y1 - v1 * y2) * idet;
    c = (u1 * x2 - u2 * x1) * idet;
    d = (u1 * y2 - u2 * y1) * idet;
    e = x0 - a * u0 - c * v0;
    f = y0 - b * u0 - d * v0;
    _context.save();
    _context.transform(a, b, c, d, e, f);
    _context.clip();
    _context.drawImage(image, 0, 0);
    _context.restore();
  }
  function getGradientTexture(color1, color2, color3, color4) {
    _pixelMapData[0] = color1.r * 255 | 0;
    _pixelMapData[1] = color1.g * 255 | 0;
    _pixelMapData[2] = color1.b * 255 | 0;
    _pixelMapData[4] = color2.r * 255 | 0;
    _pixelMapData[5] = color2.g * 255 | 0;
    _pixelMapData[6] = color2.b * 255 | 0;
    _pixelMapData[8] = color3.r * 255 | 0;
    _pixelMapData[9] = color3.g * 255 | 0;
    _pixelMapData[10] = color3.b * 255 | 0;
    _pixelMapData[12] = color4.r * 255 | 0;
    _pixelMapData[13] = color4.g * 255 | 0;
    _pixelMapData[14] = color4.b * 255 | 0;
    _pixelMapContext.putImageData(_pixelMapImage, 0, 0);
    _gradientMapContext.drawImage(_pixelMap, 0, 0);
    return _gradientMap;
  }
  function expand(v1, v2, pixels) {
    var x = v2.x - v1.x, y = v2.y - v1.y, det = x * x + y * y, idet;
    if (det === 0)
      return;
    idet = pixels / Math.sqrt(det);
    x *= idet;
    y *= idet;
    v2.x += x;
    v2.y += y;
    v1.x -= x;
    v1.y -= y;
  }
  function setOpacity(value) {
    if (_contextGlobalAlpha !== value) {
      _context.globalAlpha = value;
      _contextGlobalAlpha = value;
    }
  }
  function setBlending(value) {
    if (_contextGlobalCompositeOperation !== value) {
      if (value === THREE.NormalBlending) {
        _context.globalCompositeOperation = 'source-over';
      } else if (value === THREE.AdditiveBlending) {
        _context.globalCompositeOperation = 'lighter';
      } else if (value === THREE.SubtractiveBlending) {
        _context.globalCompositeOperation = 'darker';
      }
      _contextGlobalCompositeOperation = value;
    }
  }
  function setLineWidth(value) {
    if (_contextLineWidth !== value) {
      _context.lineWidth = value;
      _contextLineWidth = value;
    }
  }
  function setLineCap(value) {
    if (_contextLineCap !== value) {
      _context.lineCap = value;
      _contextLineCap = value;
    }
  }
  function setLineJoin(value) {
    if (_contextLineJoin !== value) {
      _context.lineJoin = value;
      _contextLineJoin = value;
    }
  }
  function setStrokeStyle(value) {
    if (_contextStrokeStyle !== value) {
      _context.strokeStyle = value;
      _contextStrokeStyle = value;
    }
  }
  function setFillStyle(value) {
    if (_contextFillStyle !== value) {
      _context.fillStyle = value;
      _contextFillStyle = value;
    }
  }
  function setDashAndGap(dashSizeValue, gapSizeValue) {
    if (_contextDashSize !== dashSizeValue || _contextGapSize !== gapSizeValue) {
      _context.setLineDash([
        dashSizeValue,
        gapSizeValue
      ]);
      _contextDashSize = dashSizeValue;
      _contextGapSize = gapSizeValue;
    }
  }
};
THREE.ShaderChunk = {
  fog_pars_fragment: [
    '#ifdef USE_FOG',
    'uniform vec3 fogColor;',
    '#ifdef FOG_EXP2',
    'uniform float fogDensity;',
    '#else',
    'uniform float fogNear;',
    'uniform float fogFar;',
    '#endif',
    '#endif'
  ].join('\n'),
  fog_fragment: [
    '#ifdef USE_FOG',
    'float depth = gl_FragCoord.z / gl_FragCoord.w;',
    '#ifdef FOG_EXP2',
    'const float LOG2 = 1.442695;',
    'float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',
    'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',
    '#else',
    'float fogFactor = smoothstep( fogNear, fogFar, depth );',
    '#endif',
    'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',
    '#endif'
  ].join('\n'),
  envmap_pars_fragment: [
    '#ifdef USE_ENVMAP',
    'uniform float reflectivity;',
    'uniform samplerCube envMap;',
    'uniform float flipEnvMap;',
    'uniform int combine;',
    '#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )',
    'uniform bool useRefract;',
    'uniform float refractionRatio;',
    '#else',
    'varying vec3 vReflect;',
    '#endif',
    '#endif'
  ].join('\n'),
  envmap_fragment: [
    '#ifdef USE_ENVMAP',
    'vec3 reflectVec;',
    '#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )',
    'vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );',
    'if ( useRefract ) {',
    'reflectVec = refract( cameraToVertex, normal, refractionRatio );',
    '} else { ',
    'reflectVec = reflect( cameraToVertex, normal );',
    '}',
    '#else',
    'reflectVec = vReflect;',
    '#endif',
    '#ifdef DOUBLE_SIDED',
    'float flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );',
    'vec4 cubeColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );',
    '#else',
    'vec4 cubeColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );',
    '#endif',
    '#ifdef GAMMA_INPUT',
    'cubeColor.xyz *= cubeColor.xyz;',
    '#endif',
    'if ( combine == 1 ) {',
    'gl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularStrength * reflectivity );',
    '} else if ( combine == 2 ) {',
    'gl_FragColor.xyz += cubeColor.xyz * specularStrength * reflectivity;',
    '} else {',
    'gl_FragColor.xyz = mix( gl_FragColor.xyz, gl_FragColor.xyz * cubeColor.xyz, specularStrength * reflectivity );',
    '}',
    '#endif'
  ].join('\n'),
  envmap_pars_vertex: [
    '#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )',
    'varying vec3 vReflect;',
    'uniform float refractionRatio;',
    'uniform bool useRefract;',
    '#endif'
  ].join('\n'),
  worldpos_vertex: [
    '#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )',
    '#ifdef USE_SKINNING',
    'vec4 worldPosition = modelMatrix * skinned;',
    '#endif',
    '#if defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )',
    'vec4 worldPosition = modelMatrix * vec4( morphed, 1.0 );',
    '#endif',
    '#if ! defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )',
    'vec4 worldPosition = modelMatrix * vec4( position, 1.0 );',
    '#endif',
    '#endif'
  ].join('\n'),
  envmap_vertex: [
    '#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )',
    'vec3 worldNormal = mat3( modelMatrix[ 0 ].xyz, modelMatrix[ 1 ].xyz, modelMatrix[ 2 ].xyz ) * objectNormal;',
    'worldNormal = normalize( worldNormal );',
    'vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );',
    'if ( useRefract ) {',
    'vReflect = refract( cameraToVertex, worldNormal, refractionRatio );',
    '} else {',
    'vReflect = reflect( cameraToVertex, worldNormal );',
    '}',
    '#endif'
  ].join('\n'),
  map_particle_pars_fragment: [
    '#ifdef USE_MAP',
    'uniform sampler2D map;',
    '#endif'
  ].join('\n'),
  map_particle_fragment: [
    '#ifdef USE_MAP',
    'gl_FragColor = gl_FragColor * texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) );',
    '#endif'
  ].join('\n'),
  map_pars_vertex: [
    '#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )',
    'varying vec2 vUv;',
    'uniform vec4 offsetRepeat;',
    '#endif'
  ].join('\n'),
  map_pars_fragment: [
    '#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )',
    'varying vec2 vUv;',
    '#endif',
    '#ifdef USE_MAP',
    'uniform sampler2D map;',
    '#endif'
  ].join('\n'),
  map_vertex: [
    '#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )',
    'vUv = uv * offsetRepeat.zw + offsetRepeat.xy;',
    '#endif'
  ].join('\n'),
  map_fragment: [
    '#ifdef USE_MAP',
    'vec4 texelColor = texture2D( map, vUv );',
    '#ifdef GAMMA_INPUT',
    'texelColor.xyz *= texelColor.xyz;',
    '#endif',
    'gl_FragColor = gl_FragColor * texelColor;',
    '#endif'
  ].join('\n'),
  lightmap_pars_fragment: [
    '#ifdef USE_LIGHTMAP',
    'varying vec2 vUv2;',
    'uniform sampler2D lightMap;',
    '#endif'
  ].join('\n'),
  lightmap_pars_vertex: [
    '#ifdef USE_LIGHTMAP',
    'varying vec2 vUv2;',
    '#endif'
  ].join('\n'),
  lightmap_fragment: [
    '#ifdef USE_LIGHTMAP',
    'gl_FragColor = gl_FragColor * texture2D( lightMap, vUv2 );',
    '#endif'
  ].join('\n'),
  lightmap_vertex: [
    '#ifdef USE_LIGHTMAP',
    'vUv2 = uv2;',
    '#endif'
  ].join('\n'),
  bumpmap_pars_fragment: [
    '#ifdef USE_BUMPMAP',
    'uniform sampler2D bumpMap;',
    'uniform float bumpScale;',
    'vec2 dHdxy_fwd() {',
    'vec2 dSTdx = dFdx( vUv );',
    'vec2 dSTdy = dFdy( vUv );',
    'float Hll = bumpScale * texture2D( bumpMap, vUv ).x;',
    'float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;',
    'float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;',
    'return vec2( dBx, dBy );',
    '}',
    'vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {',
    'vec3 vSigmaX = dFdx( surf_pos );',
    'vec3 vSigmaY = dFdy( surf_pos );',
    'vec3 vN = surf_norm;',
    'vec3 R1 = cross( vSigmaY, vN );',
    'vec3 R2 = cross( vN, vSigmaX );',
    'float fDet = dot( vSigmaX, R1 );',
    'vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );',
    'return normalize( abs( fDet ) * surf_norm - vGrad );',
    '}',
    '#endif'
  ].join('\n'),
  normalmap_pars_fragment: [
    '#ifdef USE_NORMALMAP',
    'uniform sampler2D normalMap;',
    'uniform vec2 normalScale;',
    'vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {',
    'vec3 q0 = dFdx( eye_pos.xyz );',
    'vec3 q1 = dFdy( eye_pos.xyz );',
    'vec2 st0 = dFdx( vUv.st );',
    'vec2 st1 = dFdy( vUv.st );',
    'vec3 S = normalize(  q0 * st1.t - q1 * st0.t );',
    'vec3 T = normalize( -q0 * st1.s + q1 * st0.s );',
    'vec3 N = normalize( surf_norm );',
    'vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;',
    'mapN.xy = normalScale * mapN.xy;',
    'mat3 tsn = mat3( S, T, N );',
    'return normalize( tsn * mapN );',
    '}',
    '#endif'
  ].join('\n'),
  specularmap_pars_fragment: [
    '#ifdef USE_SPECULARMAP',
    'uniform sampler2D specularMap;',
    '#endif'
  ].join('\n'),
  specularmap_fragment: [
    'float specularStrength;',
    '#ifdef USE_SPECULARMAP',
    'vec4 texelSpecular = texture2D( specularMap, vUv );',
    'specularStrength = texelSpecular.r;',
    '#else',
    'specularStrength = 1.0;',
    '#endif'
  ].join('\n'),
  lights_lambert_pars_vertex: [
    'uniform vec3 ambient;',
    'uniform vec3 diffuse;',
    'uniform vec3 emissive;',
    'uniform vec3 ambientLightColor;',
    '#if MAX_DIR_LIGHTS > 0',
    'uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];',
    'uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];',
    '#endif',
    '#if MAX_HEMI_LIGHTS > 0',
    'uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];',
    'uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];',
    'uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];',
    '#endif',
    '#if MAX_POINT_LIGHTS > 0',
    'uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];',
    'uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];',
    'uniform float pointLightDistance[ MAX_POINT_LIGHTS ];',
    '#endif',
    '#if MAX_SPOT_LIGHTS > 0',
    'uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];',
    'uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];',
    'uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];',
    'uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];',
    'uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];',
    'uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];',
    '#endif',
    '#ifdef WRAP_AROUND',
    'uniform vec3 wrapRGB;',
    '#endif'
  ].join('\n'),
  lights_lambert_vertex: [
    'vLightFront = vec3( 0.0 );',
    '#ifdef DOUBLE_SIDED',
    'vLightBack = vec3( 0.0 );',
    '#endif',
    'transformedNormal = normalize( transformedNormal );',
    '#if MAX_DIR_LIGHTS > 0',
    'for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {',
    'vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );',
    'vec3 dirVector = normalize( lDirection.xyz );',
    'float dotProduct = dot( transformedNormal, dirVector );',
    'vec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );',
    '#ifdef DOUBLE_SIDED',
    'vec3 directionalLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );',
    '#ifdef WRAP_AROUND',
    'vec3 directionalLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );',
    '#endif',
    '#endif',
    '#ifdef WRAP_AROUND',
    'vec3 directionalLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );',
    'directionalLightWeighting = mix( directionalLightWeighting, directionalLightWeightingHalf, wrapRGB );',
    '#ifdef DOUBLE_SIDED',
    'directionalLightWeightingBack = mix( directionalLightWeightingBack, directionalLightWeightingHalfBack, wrapRGB );',
    '#endif',
    '#endif',
    'vLightFront += directionalLightColor[ i ] * directionalLightWeighting;',
    '#ifdef DOUBLE_SIDED',
    'vLightBack += directionalLightColor[ i ] * directionalLightWeightingBack;',
    '#endif',
    '}',
    '#endif',
    '#if MAX_POINT_LIGHTS > 0',
    'for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {',
    'vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );',
    'vec3 lVector = lPosition.xyz - mvPosition.xyz;',
    'float lDistance = 1.0;',
    'if ( pointLightDistance[ i ] > 0.0 )',
    'lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );',
    'lVector = normalize( lVector );',
    'float dotProduct = dot( transformedNormal, lVector );',
    'vec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );',
    '#ifdef DOUBLE_SIDED',
    'vec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );',
    '#ifdef WRAP_AROUND',
    'vec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );',
    '#endif',
    '#endif',
    '#ifdef WRAP_AROUND',
    'vec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );',
    'pointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );',
    '#ifdef DOUBLE_SIDED',
    'pointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );',
    '#endif',
    '#endif',
    'vLightFront += pointLightColor[ i ] * pointLightWeighting * lDistance;',
    '#ifdef DOUBLE_SIDED',
    'vLightBack += pointLightColor[ i ] * pointLightWeightingBack * lDistance;',
    '#endif',
    '}',
    '#endif',
    '#if MAX_SPOT_LIGHTS > 0',
    'for( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {',
    'vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );',
    'vec3 lVector = lPosition.xyz - mvPosition.xyz;',
    'float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - worldPosition.xyz ) );',
    'if ( spotEffect > spotLightAngleCos[ i ] ) {',
    'spotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );',
    'float lDistance = 1.0;',
    'if ( spotLightDistance[ i ] > 0.0 )',
    'lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );',
    'lVector = normalize( lVector );',
    'float dotProduct = dot( transformedNormal, lVector );',
    'vec3 spotLightWeighting = vec3( max( dotProduct, 0.0 ) );',
    '#ifdef DOUBLE_SIDED',
    'vec3 spotLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );',
    '#ifdef WRAP_AROUND',
    'vec3 spotLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );',
    '#endif',
    '#endif',
    '#ifdef WRAP_AROUND',
    'vec3 spotLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );',
    'spotLightWeighting = mix( spotLightWeighting, spotLightWeightingHalf, wrapRGB );',
    '#ifdef DOUBLE_SIDED',
    'spotLightWeightingBack = mix( spotLightWeightingBack, spotLightWeightingHalfBack, wrapRGB );',
    '#endif',
    '#endif',
    'vLightFront += spotLightColor[ i ] * spotLightWeighting * lDistance * spotEffect;',
    '#ifdef DOUBLE_SIDED',
    'vLightBack += spotLightColor[ i ] * spotLightWeightingBack * lDistance * spotEffect;',
    '#endif',
    '}',
    '}',
    '#endif',
    '#if MAX_HEMI_LIGHTS > 0',
    'for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {',
    'vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );',
    'vec3 lVector = normalize( lDirection.xyz );',
    'float dotProduct = dot( transformedNormal, lVector );',
    'float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;',
    'float hemiDiffuseWeightBack = -0.5 * dotProduct + 0.5;',
    'vLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );',
    '#ifdef DOUBLE_SIDED',
    'vLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );',
    '#endif',
    '}',
    '#endif',
    'vLightFront = vLightFront * diffuse + ambient * ambientLightColor + emissive;',
    '#ifdef DOUBLE_SIDED',
    'vLightBack = vLightBack * diffuse + ambient * ambientLightColor + emissive;',
    '#endif'
  ].join('\n'),
  lights_phong_pars_vertex: [
    '#ifndef PHONG_PER_PIXEL',
    '#if MAX_POINT_LIGHTS > 0',
    'uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];',
    'uniform float pointLightDistance[ MAX_POINT_LIGHTS ];',
    'varying vec4 vPointLight[ MAX_POINT_LIGHTS ];',
    '#endif',
    '#if MAX_SPOT_LIGHTS > 0',
    'uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];',
    'uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];',
    'varying vec4 vSpotLight[ MAX_SPOT_LIGHTS ];',
    '#endif',
    '#endif',
    '#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )',
    'varying vec3 vWorldPosition;',
    '#endif'
  ].join('\n'),
  lights_phong_vertex: [
    '#ifndef PHONG_PER_PIXEL',
    '#if MAX_POINT_LIGHTS > 0',
    'for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {',
    'vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );',
    'vec3 lVector = lPosition.xyz - mvPosition.xyz;',
    'float lDistance = 1.0;',
    'if ( pointLightDistance[ i ] > 0.0 )',
    'lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );',
    'vPointLight[ i ] = vec4( lVector, lDistance );',
    '}',
    '#endif',
    '#if MAX_SPOT_LIGHTS > 0',
    'for( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {',
    'vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );',
    'vec3 lVector = lPosition.xyz - mvPosition.xyz;',
    'float lDistance = 1.0;',
    'if ( spotLightDistance[ i ] > 0.0 )',
    'lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );',
    'vSpotLight[ i ] = vec4( lVector, lDistance );',
    '}',
    '#endif',
    '#endif',
    '#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )',
    'vWorldPosition = worldPosition.xyz;',
    '#endif'
  ].join('\n'),
  lights_phong_pars_fragment: [
    'uniform vec3 ambientLightColor;',
    '#if MAX_DIR_LIGHTS > 0',
    'uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];',
    'uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];',
    '#endif',
    '#if MAX_HEMI_LIGHTS > 0',
    'uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];',
    'uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];',
    'uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];',
    '#endif',
    '#if MAX_POINT_LIGHTS > 0',
    'uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];',
    '#ifdef PHONG_PER_PIXEL',
    'uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];',
    'uniform float pointLightDistance[ MAX_POINT_LIGHTS ];',
    '#else',
    'varying vec4 vPointLight[ MAX_POINT_LIGHTS ];',
    '#endif',
    '#endif',
    '#if MAX_SPOT_LIGHTS > 0',
    'uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];',
    'uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];',
    'uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];',
    'uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];',
    'uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];',
    '#ifdef PHONG_PER_PIXEL',
    'uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];',
    '#else',
    'varying vec4 vSpotLight[ MAX_SPOT_LIGHTS ];',
    '#endif',
    '#endif',
    '#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )',
    'varying vec3 vWorldPosition;',
    '#endif',
    '#ifdef WRAP_AROUND',
    'uniform vec3 wrapRGB;',
    '#endif',
    'varying vec3 vViewPosition;',
    'varying vec3 vNormal;'
  ].join('\n'),
  lights_phong_fragment: [
    'vec3 normal = normalize( vNormal );',
    'vec3 viewPosition = normalize( vViewPosition );',
    '#ifdef DOUBLE_SIDED',
    'normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );',
    '#endif',
    '#ifdef USE_NORMALMAP',
    'normal = perturbNormal2Arb( -vViewPosition, normal );',
    '#elif defined( USE_BUMPMAP )',
    'normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );',
    '#endif',
    '#if MAX_POINT_LIGHTS > 0',
    'vec3 pointDiffuse  = vec3( 0.0 );',
    'vec3 pointSpecular = vec3( 0.0 );',
    'for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {',
    '#ifdef PHONG_PER_PIXEL',
    'vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );',
    'vec3 lVector = lPosition.xyz + vViewPosition.xyz;',
    'float lDistance = 1.0;',
    'if ( pointLightDistance[ i ] > 0.0 )',
    'lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );',
    'lVector = normalize( lVector );',
    '#else',
    'vec3 lVector = normalize( vPointLight[ i ].xyz );',
    'float lDistance = vPointLight[ i ].w;',
    '#endif',
    'float dotProduct = dot( normal, lVector );',
    '#ifdef WRAP_AROUND',
    'float pointDiffuseWeightFull = max( dotProduct, 0.0 );',
    'float pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );',
    'vec3 pointDiffuseWeight = mix( vec3 ( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );',
    '#else',
    'float pointDiffuseWeight = max( dotProduct, 0.0 );',
    '#endif',
    'pointDiffuse  += diffuse * pointLightColor[ i ] * pointDiffuseWeight * lDistance;',
    'vec3 pointHalfVector = normalize( lVector + viewPosition );',
    'float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );',
    'float pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininess ), 0.0 );',
    '#ifdef PHYSICALLY_BASED_SHADING',
    'float specularNormalization = ( shininess + 2.0001 ) / 8.0;',
    'vec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, pointHalfVector ), 5.0 );',
    'pointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance * specularNormalization;',
    '#else',
    'pointSpecular += specular * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance;',
    '#endif',
    '}',
    '#endif',
    '#if MAX_SPOT_LIGHTS > 0',
    'vec3 spotDiffuse  = vec3( 0.0 );',
    'vec3 spotSpecular = vec3( 0.0 );',
    'for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {',
    '#ifdef PHONG_PER_PIXEL',
    'vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );',
    'vec3 lVector = lPosition.xyz + vViewPosition.xyz;',
    'float lDistance = 1.0;',
    'if ( spotLightDistance[ i ] > 0.0 )',
    'lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );',
    'lVector = normalize( lVector );',
    '#else',
    'vec3 lVector = normalize( vSpotLight[ i ].xyz );',
    'float lDistance = vSpotLight[ i ].w;',
    '#endif',
    'float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );',
    'if ( spotEffect > spotLightAngleCos[ i ] ) {',
    'spotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );',
    'float dotProduct = dot( normal, lVector );',
    '#ifdef WRAP_AROUND',
    'float spotDiffuseWeightFull = max( dotProduct, 0.0 );',
    'float spotDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );',
    'vec3 spotDiffuseWeight = mix( vec3 ( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );',
    '#else',
    'float spotDiffuseWeight = max( dotProduct, 0.0 );',
    '#endif',
    'spotDiffuse += diffuse * spotLightColor[ i ] * spotDiffuseWeight * lDistance * spotEffect;',
    'vec3 spotHalfVector = normalize( lVector + viewPosition );',
    'float spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );',
    'float spotSpecularWeight = specularStrength * max( pow( spotDotNormalHalf, shininess ), 0.0 );',
    '#ifdef PHYSICALLY_BASED_SHADING',
    'float specularNormalization = ( shininess + 2.0001 ) / 8.0;',
    'vec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, spotHalfVector ), 5.0 );',
    'spotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * lDistance * specularNormalization * spotEffect;',
    '#else',
    'spotSpecular += specular * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * lDistance * spotEffect;',
    '#endif',
    '}',
    '}',
    '#endif',
    '#if MAX_DIR_LIGHTS > 0',
    'vec3 dirDiffuse  = vec3( 0.0 );',
    'vec3 dirSpecular = vec3( 0.0 );',
    'for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {',
    'vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );',
    'vec3 dirVector = normalize( lDirection.xyz );',
    'float dotProduct = dot( normal, dirVector );',
    '#ifdef WRAP_AROUND',
    'float dirDiffuseWeightFull = max( dotProduct, 0.0 );',
    'float dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );',
    'vec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );',
    '#else',
    'float dirDiffuseWeight = max( dotProduct, 0.0 );',
    '#endif',
    'dirDiffuse  += diffuse * directionalLightColor[ i ] * dirDiffuseWeight;',
    'vec3 dirHalfVector = normalize( dirVector + viewPosition );',
    'float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );',
    'float dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininess ), 0.0 );',
    '#ifdef PHYSICALLY_BASED_SHADING',
    'float specularNormalization = ( shininess + 2.0001 ) / 8.0;',
    'vec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( dirVector, dirHalfVector ), 5.0 );',
    'dirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;',
    '#else',
    'dirSpecular += specular * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight;',
    '#endif',
    '}',
    '#endif',
    '#if MAX_HEMI_LIGHTS > 0',
    'vec3 hemiDiffuse  = vec3( 0.0 );',
    'vec3 hemiSpecular = vec3( 0.0 );',
    'for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {',
    'vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );',
    'vec3 lVector = normalize( lDirection.xyz );',
    'float dotProduct = dot( normal, lVector );',
    'float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;',
    'vec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );',
    'hemiDiffuse += diffuse * hemiColor;',
    'vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );',
    'float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;',
    'float hemiSpecularWeightSky = specularStrength * max( pow( hemiDotNormalHalfSky, shininess ), 0.0 );',
    'vec3 lVectorGround = -lVector;',
    'vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );',
    'float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;',
    'float hemiSpecularWeightGround = specularStrength * max( pow( hemiDotNormalHalfGround, shininess ), 0.0 );',
    '#ifdef PHYSICALLY_BASED_SHADING',
    'float dotProductGround = dot( normal, lVectorGround );',
    'float specularNormalization = ( shininess + 2.0001 ) / 8.0;',
    'vec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, hemiHalfVectorSky ), 5.0 );',
    'vec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 5.0 );',
    'hemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );',
    '#else',
    'hemiSpecular += specular * hemiColor * ( hemiSpecularWeightSky + hemiSpecularWeightGround ) * hemiDiffuseWeight;',
    '#endif',
    '}',
    '#endif',
    'vec3 totalDiffuse = vec3( 0.0 );',
    'vec3 totalSpecular = vec3( 0.0 );',
    '#if MAX_DIR_LIGHTS > 0',
    'totalDiffuse += dirDiffuse;',
    'totalSpecular += dirSpecular;',
    '#endif',
    '#if MAX_HEMI_LIGHTS > 0',
    'totalDiffuse += hemiDiffuse;',
    'totalSpecular += hemiSpecular;',
    '#endif',
    '#if MAX_POINT_LIGHTS > 0',
    'totalDiffuse += pointDiffuse;',
    'totalSpecular += pointSpecular;',
    '#endif',
    '#if MAX_SPOT_LIGHTS > 0',
    'totalDiffuse += spotDiffuse;',
    'totalSpecular += spotSpecular;',
    '#endif',
    '#ifdef METAL',
    'gl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient + totalSpecular );',
    '#else',
    'gl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient ) + totalSpecular;',
    '#endif'
  ].join('\n'),
  color_pars_fragment: [
    '#ifdef USE_COLOR',
    'varying vec3 vColor;',
    '#endif'
  ].join('\n'),
  color_fragment: [
    '#ifdef USE_COLOR',
    'gl_FragColor = gl_FragColor * vec4( vColor, opacity );',
    '#endif'
  ].join('\n'),
  color_pars_vertex: [
    '#ifdef USE_COLOR',
    'varying vec3 vColor;',
    '#endif'
  ].join('\n'),
  color_vertex: [
    '#ifdef USE_COLOR',
    '#ifdef GAMMA_INPUT',
    'vColor = color * color;',
    '#else',
    'vColor = color;',
    '#endif',
    '#endif'
  ].join('\n'),
  skinning_pars_vertex: [
    '#ifdef USE_SKINNING',
    '#ifdef BONE_TEXTURE',
    'uniform sampler2D boneTexture;',
    'mat4 getBoneMatrix( const in float i ) {',
    'float j = i * 4.0;',
    'float x = mod( j, N_BONE_PIXEL_X );',
    'float y = floor( j / N_BONE_PIXEL_X );',
    'const float dx = 1.0 / N_BONE_PIXEL_X;',
    'const float dy = 1.0 / N_BONE_PIXEL_Y;',
    'y = dy * ( y + 0.5 );',
    'vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );',
    'vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );',
    'vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );',
    'vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );',
    'mat4 bone = mat4( v1, v2, v3, v4 );',
    'return bone;',
    '}',
    '#else',
    'uniform mat4 boneGlobalMatrices[ MAX_BONES ];',
    'mat4 getBoneMatrix( const in float i ) {',
    'mat4 bone = boneGlobalMatrices[ int(i) ];',
    'return bone;',
    '}',
    '#endif',
    '#endif'
  ].join('\n'),
  skinbase_vertex: [
    '#ifdef USE_SKINNING',
    'mat4 boneMatX = getBoneMatrix( skinIndex.x );',
    'mat4 boneMatY = getBoneMatrix( skinIndex.y );',
    '#endif'
  ].join('\n'),
  skinning_vertex: [
    '#ifdef USE_SKINNING',
    '#ifdef USE_MORPHTARGETS',
    'vec4 skinVertex = vec4( morphed, 1.0 );',
    '#else',
    'vec4 skinVertex = vec4( position, 1.0 );',
    '#endif',
    'vec4 skinned  = boneMatX * skinVertex * skinWeight.x;',
    'skinned \t  += boneMatY * skinVertex * skinWeight.y;',
    '#endif'
  ].join('\n'),
  morphtarget_pars_vertex: [
    '#ifdef USE_MORPHTARGETS',
    '#ifndef USE_MORPHNORMALS',
    'uniform float morphTargetInfluences[ 8 ];',
    '#else',
    'uniform float morphTargetInfluences[ 4 ];',
    '#endif',
    '#endif'
  ].join('\n'),
  morphtarget_vertex: [
    '#ifdef USE_MORPHTARGETS',
    'vec3 morphed = vec3( 0.0 );',
    'morphed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];',
    'morphed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];',
    'morphed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];',
    'morphed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];',
    '#ifndef USE_MORPHNORMALS',
    'morphed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];',
    'morphed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];',
    'morphed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];',
    'morphed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];',
    '#endif',
    'morphed += position;',
    '#endif'
  ].join('\n'),
  default_vertex: [
    'vec4 mvPosition;',
    '#ifdef USE_SKINNING',
    'mvPosition = modelViewMatrix * skinned;',
    '#endif',
    '#if !defined( USE_SKINNING ) && defined( USE_MORPHTARGETS )',
    'mvPosition = modelViewMatrix * vec4( morphed, 1.0 );',
    '#endif',
    '#if !defined( USE_SKINNING ) && ! defined( USE_MORPHTARGETS )',
    'mvPosition = modelViewMatrix * vec4( position, 1.0 );',
    '#endif',
    'gl_Position = projectionMatrix * mvPosition;'
  ].join('\n'),
  morphnormal_vertex: [
    '#ifdef USE_MORPHNORMALS',
    'vec3 morphedNormal = vec3( 0.0 );',
    'morphedNormal +=  ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];',
    'morphedNormal +=  ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];',
    'morphedNormal +=  ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];',
    'morphedNormal +=  ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];',
    'morphedNormal += normal;',
    '#endif'
  ].join('\n'),
  skinnormal_vertex: [
    '#ifdef USE_SKINNING',
    'mat4 skinMatrix = skinWeight.x * boneMatX;',
    'skinMatrix \t+= skinWeight.y * boneMatY;',
    '#ifdef USE_MORPHNORMALS',
    'vec4 skinnedNormal = skinMatrix * vec4( morphedNormal, 0.0 );',
    '#else',
    'vec4 skinnedNormal = skinMatrix * vec4( normal, 0.0 );',
    '#endif',
    '#endif'
  ].join('\n'),
  defaultnormal_vertex: [
    'vec3 objectNormal;',
    '#ifdef USE_SKINNING',
    'objectNormal = skinnedNormal.xyz;',
    '#endif',
    '#if !defined( USE_SKINNING ) && defined( USE_MORPHNORMALS )',
    'objectNormal = morphedNormal;',
    '#endif',
    '#if !defined( USE_SKINNING ) && ! defined( USE_MORPHNORMALS )',
    'objectNormal = normal;',
    '#endif',
    '#ifdef FLIP_SIDED',
    'objectNormal = -objectNormal;',
    '#endif',
    'vec3 transformedNormal = normalMatrix * objectNormal;'
  ].join('\n'),
  shadowmap_pars_fragment: [
    '#ifdef USE_SHADOWMAP',
    'uniform sampler2D shadowMap[ MAX_SHADOWS ];',
    'uniform vec2 shadowMapSize[ MAX_SHADOWS ];',
    'uniform float shadowDarkness[ MAX_SHADOWS ];',
    'uniform float shadowBias[ MAX_SHADOWS ];',
    'varying vec4 vShadowCoord[ MAX_SHADOWS ];',
    'float unpackDepth( const in vec4 rgba_depth ) {',
    'const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );',
    'float depth = dot( rgba_depth, bit_shift );',
    'return depth;',
    '}',
    '#endif'
  ].join('\n'),
  shadowmap_fragment: [
    '#ifdef USE_SHADOWMAP',
    '#ifdef SHADOWMAP_DEBUG',
    'vec3 frustumColors[3];',
    'frustumColors[0] = vec3( 1.0, 0.5, 0.0 );',
    'frustumColors[1] = vec3( 0.0, 1.0, 0.8 );',
    'frustumColors[2] = vec3( 0.0, 0.5, 1.0 );',
    '#endif',
    '#ifdef SHADOWMAP_CASCADE',
    'int inFrustumCount = 0;',
    '#endif',
    'float fDepth;',
    'vec3 shadowColor = vec3( 1.0 );',
    'for( int i = 0; i < MAX_SHADOWS; i ++ ) {',
    'vec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;',
    'bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );',
    'bool inFrustum = all( inFrustumVec );',
    '#ifdef SHADOWMAP_CASCADE',
    'inFrustumCount += int( inFrustum );',
    'bvec3 frustumTestVec = bvec3( inFrustum, inFrustumCount == 1, shadowCoord.z <= 1.0 );',
    '#else',
    'bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );',
    '#endif',
    'bool frustumTest = all( frustumTestVec );',
    'if ( frustumTest ) {',
    'shadowCoord.z += shadowBias[ i ];',
    '#if defined( SHADOWMAP_TYPE_PCF )',
    'float shadow = 0.0;',
    'const float shadowDelta = 1.0 / 9.0;',
    'float xPixelOffset = 1.0 / shadowMapSize[ i ].x;',
    'float yPixelOffset = 1.0 / shadowMapSize[ i ].y;',
    'float dx0 = -1.25 * xPixelOffset;',
    'float dy0 = -1.25 * yPixelOffset;',
    'float dx1 = 1.25 * xPixelOffset;',
    'float dy1 = 1.25 * yPixelOffset;',
    'fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );',
    'if ( fDepth < shadowCoord.z ) shadow += shadowDelta;',
    'fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );',
    'if ( fDepth < shadowCoord.z ) shadow += shadowDelta;',
    'fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );',
    'if ( fDepth < shadowCoord.z ) shadow += shadowDelta;',
    'fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );',
    'if ( fDepth < shadowCoord.z ) shadow += shadowDelta;',
    'fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );',
    'if ( fDepth < shadowCoord.z ) shadow += shadowDelta;',
    'fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );',
    'if ( fDepth < shadowCoord.z ) shadow += shadowDelta;',
    'fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );',
    'if ( fDepth < shadowCoord.z ) shadow += shadowDelta;',
    'fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );',
    'if ( fDepth < shadowCoord.z ) shadow += shadowDelta;',
    'fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );',
    'if ( fDepth < shadowCoord.z ) shadow += shadowDelta;',
    'shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );',
    '#elif defined( SHADOWMAP_TYPE_PCF_SOFT )',
    'float shadow = 0.0;',
    'float xPixelOffset = 1.0 / shadowMapSize[ i ].x;',
    'float yPixelOffset = 1.0 / shadowMapSize[ i ].y;',
    'float dx0 = -1.0 * xPixelOffset;',
    'float dy0 = -1.0 * yPixelOffset;',
    'float dx1 = 1.0 * xPixelOffset;',
    'float dy1 = 1.0 * yPixelOffset;',
    'mat3 shadowKernel;',
    'mat3 depthKernel;',
    'depthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );',
    'depthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );',
    'depthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );',
    'depthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );',
    'depthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );',
    'depthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );',
    'depthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );',
    'depthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );',
    'depthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );',
    'vec3 shadowZ = vec3( shadowCoord.z );',
    'shadowKernel[0] = vec3(lessThan(depthKernel[0], shadowZ ));',
    'shadowKernel[0] *= vec3(0.25);',
    'shadowKernel[1] = vec3(lessThan(depthKernel[1], shadowZ ));',
    'shadowKernel[1] *= vec3(0.25);',
    'shadowKernel[2] = vec3(lessThan(depthKernel[2], shadowZ ));',
    'shadowKernel[2] *= vec3(0.25);',
    'vec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );',
    'shadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );',
    'shadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );',
    'vec4 shadowValues;',
    'shadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );',
    'shadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );',
    'shadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );',
    'shadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );',
    'shadow = dot( shadowValues, vec4( 1.0 ) );',
    'shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );',
    '#else',
    'vec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );',
    'float fDepth = unpackDepth( rgbaDepth );',
    'if ( fDepth < shadowCoord.z )',
    'shadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );',
    '#endif',
    '}',
    '#ifdef SHADOWMAP_DEBUG',
    '#ifdef SHADOWMAP_CASCADE',
    'if ( inFrustum && inFrustumCount == 1 ) gl_FragColor.xyz *= frustumColors[ i ];',
    '#else',
    'if ( inFrustum ) gl_FragColor.xyz *= frustumColors[ i ];',
    '#endif',
    '#endif',
    '}',
    '#ifdef GAMMA_OUTPUT',
    'shadowColor *= shadowColor;',
    '#endif',
    'gl_FragColor.xyz = gl_FragColor.xyz * shadowColor;',
    '#endif'
  ].join('\n'),
  shadowmap_pars_vertex: [
    '#ifdef USE_SHADOWMAP',
    'varying vec4 vShadowCoord[ MAX_SHADOWS ];',
    'uniform mat4 shadowMatrix[ MAX_SHADOWS ];',
    '#endif'
  ].join('\n'),
  shadowmap_vertex: [
    '#ifdef USE_SHADOWMAP',
    'for( int i = 0; i < MAX_SHADOWS; i ++ ) {',
    'vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;',
    '}',
    '#endif'
  ].join('\n'),
  alphatest_fragment: [
    '#ifdef ALPHATEST',
    'if ( gl_FragColor.a < ALPHATEST ) discard;',
    '#endif'
  ].join('\n'),
  linear_to_gamma_fragment: [
    '#ifdef GAMMA_OUTPUT',
    'gl_FragColor.xyz = sqrt( gl_FragColor.xyz );',
    '#endif'
  ].join('\n')
};
THREE.UniformsUtils = {
  merge: function (uniforms) {
    var u, p, tmp, merged = {};
    for (u = 0; u < uniforms.length; u++) {
      tmp = this.clone(uniforms[u]);
      for (p in tmp) {
        merged[p] = tmp[p];
      }
    }
    return merged;
  },
  clone: function (uniforms_src) {
    var u, p, parameter, parameter_src, uniforms_dst = {};
    for (u in uniforms_src) {
      uniforms_dst[u] = {};
      for (p in uniforms_src[u]) {
        parameter_src = uniforms_src[u][p];
        if (parameter_src instanceof THREE.Color || parameter_src instanceof THREE.Vector2 || parameter_src instanceof THREE.Vector3 || parameter_src instanceof THREE.Vector4 || parameter_src instanceof THREE.Matrix4 || parameter_src instanceof THREE.Texture) {
          uniforms_dst[u][p] = parameter_src.clone();
        } else if (parameter_src instanceof Array) {
          uniforms_dst[u][p] = parameter_src.slice();
        } else {
          uniforms_dst[u][p] = parameter_src;
        }
      }
    }
    return uniforms_dst;
  }
};
THREE.UniformsLib = {
  common: {
    'diffuse': {
      type: 'c',
      value: new THREE.Color(15658734)
    },
    'opacity': {
      type: 'f',
      value: 1
    },
    'map': {
      type: 't',
      value: null
    },
    'offsetRepeat': {
      type: 'v4',
      value: new THREE.Vector4(0, 0, 1, 1)
    },
    'lightMap': {
      type: 't',
      value: null
    },
    'specularMap': {
      type: 't',
      value: null
    },
    'envMap': {
      type: 't',
      value: null
    },
    'flipEnvMap': {
      type: 'f',
      value: -1
    },
    'useRefract': {
      type: 'i',
      value: 0
    },
    'reflectivity': {
      type: 'f',
      value: 1
    },
    'refractionRatio': {
      type: 'f',
      value: 0.98
    },
    'combine': {
      type: 'i',
      value: 0
    },
    'morphTargetInfluences': {
      type: 'f',
      value: 0
    }
  },
  bump: {
    'bumpMap': {
      type: 't',
      value: null
    },
    'bumpScale': {
      type: 'f',
      value: 1
    }
  },
  normalmap: {
    'normalMap': {
      type: 't',
      value: null
    },
    'normalScale': {
      type: 'v2',
      value: new THREE.Vector2(1, 1)
    }
  },
  fog: {
    'fogDensity': {
      type: 'f',
      value: 0.00025
    },
    'fogNear': {
      type: 'f',
      value: 1
    },
    'fogFar': {
      type: 'f',
      value: 2000
    },
    'fogColor': {
      type: 'c',
      value: new THREE.Color(16777215)
    }
  },
  lights: {
    'ambientLightColor': {
      type: 'fv',
      value: []
    },
    'directionalLightDirection': {
      type: 'fv',
      value: []
    },
    'directionalLightColor': {
      type: 'fv',
      value: []
    },
    'hemisphereLightDirection': {
      type: 'fv',
      value: []
    },
    'hemisphereLightSkyColor': {
      type: 'fv',
      value: []
    },
    'hemisphereLightGroundColor': {
      type: 'fv',
      value: []
    },
    'pointLightColor': {
      type: 'fv',
      value: []
    },
    'pointLightPosition': {
      type: 'fv',
      value: []
    },
    'pointLightDistance': {
      type: 'fv1',
      value: []
    },
    'spotLightColor': {
      type: 'fv',
      value: []
    },
    'spotLightPosition': {
      type: 'fv',
      value: []
    },
    'spotLightDirection': {
      type: 'fv',
      value: []
    },
    'spotLightDistance': {
      type: 'fv1',
      value: []
    },
    'spotLightAngleCos': {
      type: 'fv1',
      value: []
    },
    'spotLightExponent': {
      type: 'fv1',
      value: []
    }
  },
  particle: {
    'psColor': {
      type: 'c',
      value: new THREE.Color(15658734)
    },
    'opacity': {
      type: 'f',
      value: 1
    },
    'size': {
      type: 'f',
      value: 1
    },
    'scale': {
      type: 'f',
      value: 1
    },
    'map': {
      type: 't',
      value: null
    },
    'fogDensity': {
      type: 'f',
      value: 0.00025
    },
    'fogNear': {
      type: 'f',
      value: 1
    },
    'fogFar': {
      type: 'f',
      value: 2000
    },
    'fogColor': {
      type: 'c',
      value: new THREE.Color(16777215)
    }
  },
  shadowmap: {
    'shadowMap': {
      type: 'tv',
      value: []
    },
    'shadowMapSize': {
      type: 'v2v',
      value: []
    },
    'shadowBias': {
      type: 'fv1',
      value: []
    },
    'shadowDarkness': {
      type: 'fv1',
      value: []
    },
    'shadowMatrix': {
      type: 'm4v',
      value: []
    }
  }
};
THREE.ShaderLib = {
  'basic': {
    uniforms: THREE.UniformsUtils.merge([
      THREE.UniformsLib['common'],
      THREE.UniformsLib['fog'],
      THREE.UniformsLib['shadowmap']
    ]),
    vertexShader: [
      THREE.ShaderChunk['map_pars_vertex'],
      THREE.ShaderChunk['lightmap_pars_vertex'],
      THREE.ShaderChunk['envmap_pars_vertex'],
      THREE.ShaderChunk['color_pars_vertex'],
      THREE.ShaderChunk['morphtarget_pars_vertex'],
      THREE.ShaderChunk['skinning_pars_vertex'],
      THREE.ShaderChunk['shadowmap_pars_vertex'],
      'void main() {',
      THREE.ShaderChunk['map_vertex'],
      THREE.ShaderChunk['lightmap_vertex'],
      THREE.ShaderChunk['color_vertex'],
      THREE.ShaderChunk['skinbase_vertex'],
      '#ifdef USE_ENVMAP',
      THREE.ShaderChunk['morphnormal_vertex'],
      THREE.ShaderChunk['skinnormal_vertex'],
      THREE.ShaderChunk['defaultnormal_vertex'],
      '#endif',
      THREE.ShaderChunk['morphtarget_vertex'],
      THREE.ShaderChunk['skinning_vertex'],
      THREE.ShaderChunk['default_vertex'],
      THREE.ShaderChunk['worldpos_vertex'],
      THREE.ShaderChunk['envmap_vertex'],
      THREE.ShaderChunk['shadowmap_vertex'],
      '}'
    ].join('\n'),
    fragmentShader: [
      'uniform vec3 diffuse;',
      'uniform float opacity;',
      THREE.ShaderChunk['color_pars_fragment'],
      THREE.ShaderChunk['map_pars_fragment'],
      THREE.ShaderChunk['lightmap_pars_fragment'],
      THREE.ShaderChunk['envmap_pars_fragment'],
      THREE.ShaderChunk['fog_pars_fragment'],
      THREE.ShaderChunk['shadowmap_pars_fragment'],
      THREE.ShaderChunk['specularmap_pars_fragment'],
      'void main() {',
      'gl_FragColor = vec4( diffuse, opacity );',
      THREE.ShaderChunk['map_fragment'],
      THREE.ShaderChunk['alphatest_fragment'],
      THREE.ShaderChunk['specularmap_fragment'],
      THREE.ShaderChunk['lightmap_fragment'],
      THREE.ShaderChunk['color_fragment'],
      THREE.ShaderChunk['envmap_fragment'],
      THREE.ShaderChunk['shadowmap_fragment'],
      THREE.ShaderChunk['linear_to_gamma_fragment'],
      THREE.ShaderChunk['fog_fragment'],
      '}'
    ].join('\n')
  },
  'lambert': {
    uniforms: THREE.UniformsUtils.merge([
      THREE.UniformsLib['common'],
      THREE.UniformsLib['fog'],
      THREE.UniformsLib['lights'],
      THREE.UniformsLib['shadowmap'],
      {
        'ambient': {
          type: 'c',
          value: new THREE.Color(16777215)
        },
        'emissive': {
          type: 'c',
          value: new THREE.Color(0)
        },
        'wrapRGB': {
          type: 'v3',
          value: new THREE.Vector3(1, 1, 1)
        }
      }
    ]),
    vertexShader: [
      '#define LAMBERT',
      'varying vec3 vLightFront;',
      '#ifdef DOUBLE_SIDED',
      'varying vec3 vLightBack;',
      '#endif',
      THREE.ShaderChunk['map_pars_vertex'],
      THREE.ShaderChunk['lightmap_pars_vertex'],
      THREE.ShaderChunk['envmap_pars_vertex'],
      THREE.ShaderChunk['lights_lambert_pars_vertex'],
      THREE.ShaderChunk['color_pars_vertex'],
      THREE.ShaderChunk['morphtarget_pars_vertex'],
      THREE.ShaderChunk['skinning_pars_vertex'],
      THREE.ShaderChunk['shadowmap_pars_vertex'],
      'void main() {',
      THREE.ShaderChunk['map_vertex'],
      THREE.ShaderChunk['lightmap_vertex'],
      THREE.ShaderChunk['color_vertex'],
      THREE.ShaderChunk['morphnormal_vertex'],
      THREE.ShaderChunk['skinbase_vertex'],
      THREE.ShaderChunk['skinnormal_vertex'],
      THREE.ShaderChunk['defaultnormal_vertex'],
      THREE.ShaderChunk['morphtarget_vertex'],
      THREE.ShaderChunk['skinning_vertex'],
      THREE.ShaderChunk['default_vertex'],
      THREE.ShaderChunk['worldpos_vertex'],
      THREE.ShaderChunk['envmap_vertex'],
      THREE.ShaderChunk['lights_lambert_vertex'],
      THREE.ShaderChunk['shadowmap_vertex'],
      '}'
    ].join('\n'),
    fragmentShader: [
      'uniform float opacity;',
      'varying vec3 vLightFront;',
      '#ifdef DOUBLE_SIDED',
      'varying vec3 vLightBack;',
      '#endif',
      THREE.ShaderChunk['color_pars_fragment'],
      THREE.ShaderChunk['map_pars_fragment'],
      THREE.ShaderChunk['lightmap_pars_fragment'],
      THREE.ShaderChunk['envmap_pars_fragment'],
      THREE.ShaderChunk['fog_pars_fragment'],
      THREE.ShaderChunk['shadowmap_pars_fragment'],
      THREE.ShaderChunk['specularmap_pars_fragment'],
      'void main() {',
      'gl_FragColor = vec4( vec3 ( 1.0 ), opacity );',
      THREE.ShaderChunk['map_fragment'],
      THREE.ShaderChunk['alphatest_fragment'],
      THREE.ShaderChunk['specularmap_fragment'],
      '#ifdef DOUBLE_SIDED',
      'if ( gl_FrontFacing )',
      'gl_FragColor.xyz *= vLightFront;',
      'else',
      'gl_FragColor.xyz *= vLightBack;',
      '#else',
      'gl_FragColor.xyz *= vLightFront;',
      '#endif',
      THREE.ShaderChunk['lightmap_fragment'],
      THREE.ShaderChunk['color_fragment'],
      THREE.ShaderChunk['envmap_fragment'],
      THREE.ShaderChunk['shadowmap_fragment'],
      THREE.ShaderChunk['linear_to_gamma_fragment'],
      THREE.ShaderChunk['fog_fragment'],
      '}'
    ].join('\n')
  },
  'phong': {
    uniforms: THREE.UniformsUtils.merge([
      THREE.UniformsLib['common'],
      THREE.UniformsLib['bump'],
      THREE.UniformsLib['normalmap'],
      THREE.UniformsLib['fog'],
      THREE.UniformsLib['lights'],
      THREE.UniformsLib['shadowmap'],
      {
        'ambient': {
          type: 'c',
          value: new THREE.Color(16777215)
        },
        'emissive': {
          type: 'c',
          value: new THREE.Color(0)
        },
        'specular': {
          type: 'c',
          value: new THREE.Color(1118481)
        },
        'shininess': {
          type: 'f',
          value: 30
        },
        'wrapRGB': {
          type: 'v3',
          value: new THREE.Vector3(1, 1, 1)
        }
      }
    ]),
    vertexShader: [
      '#define PHONG',
      'varying vec3 vViewPosition;',
      'varying vec3 vNormal;',
      THREE.ShaderChunk['map_pars_vertex'],
      THREE.ShaderChunk['lightmap_pars_vertex'],
      THREE.ShaderChunk['envmap_pars_vertex'],
      THREE.ShaderChunk['lights_phong_pars_vertex'],
      THREE.ShaderChunk['color_pars_vertex'],
      THREE.ShaderChunk['morphtarget_pars_vertex'],
      THREE.ShaderChunk['skinning_pars_vertex'],
      THREE.ShaderChunk['shadowmap_pars_vertex'],
      'void main() {',
      THREE.ShaderChunk['map_vertex'],
      THREE.ShaderChunk['lightmap_vertex'],
      THREE.ShaderChunk['color_vertex'],
      THREE.ShaderChunk['morphnormal_vertex'],
      THREE.ShaderChunk['skinbase_vertex'],
      THREE.ShaderChunk['skinnormal_vertex'],
      THREE.ShaderChunk['defaultnormal_vertex'],
      'vNormal = normalize( transformedNormal );',
      THREE.ShaderChunk['morphtarget_vertex'],
      THREE.ShaderChunk['skinning_vertex'],
      THREE.ShaderChunk['default_vertex'],
      'vViewPosition = -mvPosition.xyz;',
      THREE.ShaderChunk['worldpos_vertex'],
      THREE.ShaderChunk['envmap_vertex'],
      THREE.ShaderChunk['lights_phong_vertex'],
      THREE.ShaderChunk['shadowmap_vertex'],
      '}'
    ].join('\n'),
    fragmentShader: [
      'uniform vec3 diffuse;',
      'uniform float opacity;',
      'uniform vec3 ambient;',
      'uniform vec3 emissive;',
      'uniform vec3 specular;',
      'uniform float shininess;',
      THREE.ShaderChunk['color_pars_fragment'],
      THREE.ShaderChunk['map_pars_fragment'],
      THREE.ShaderChunk['lightmap_pars_fragment'],
      THREE.ShaderChunk['envmap_pars_fragment'],
      THREE.ShaderChunk['fog_pars_fragment'],
      THREE.ShaderChunk['lights_phong_pars_fragment'],
      THREE.ShaderChunk['shadowmap_pars_fragment'],
      THREE.ShaderChunk['bumpmap_pars_fragment'],
      THREE.ShaderChunk['normalmap_pars_fragment'],
      THREE.ShaderChunk['specularmap_pars_fragment'],
      'void main() {',
      'gl_FragColor = vec4( vec3 ( 1.0 ), opacity );',
      THREE.ShaderChunk['map_fragment'],
      THREE.ShaderChunk['alphatest_fragment'],
      THREE.ShaderChunk['specularmap_fragment'],
      THREE.ShaderChunk['lights_phong_fragment'],
      THREE.ShaderChunk['lightmap_fragment'],
      THREE.ShaderChunk['color_fragment'],
      THREE.ShaderChunk['envmap_fragment'],
      THREE.ShaderChunk['shadowmap_fragment'],
      THREE.ShaderChunk['linear_to_gamma_fragment'],
      THREE.ShaderChunk['fog_fragment'],
      '}'
    ].join('\n')
  },
  'particle_basic': {
    uniforms: THREE.UniformsUtils.merge([
      THREE.UniformsLib['particle'],
      THREE.UniformsLib['shadowmap']
    ]),
    vertexShader: [
      'uniform float size;',
      'uniform float scale;',
      THREE.ShaderChunk['color_pars_vertex'],
      THREE.ShaderChunk['shadowmap_pars_vertex'],
      'void main() {',
      THREE.ShaderChunk['color_vertex'],
      'vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );',
      '#ifdef USE_SIZEATTENUATION',
      'gl_PointSize = size * ( scale / length( mvPosition.xyz ) );',
      '#else',
      'gl_PointSize = size;',
      '#endif',
      'gl_Position = projectionMatrix * mvPosition;',
      THREE.ShaderChunk['worldpos_vertex'],
      THREE.ShaderChunk['shadowmap_vertex'],
      '}'
    ].join('\n'),
    fragmentShader: [
      'uniform vec3 psColor;',
      'uniform float opacity;',
      THREE.ShaderChunk['color_pars_fragment'],
      THREE.ShaderChunk['map_particle_pars_fragment'],
      THREE.ShaderChunk['fog_pars_fragment'],
      THREE.ShaderChunk['shadowmap_pars_fragment'],
      'void main() {',
      'gl_FragColor = vec4( psColor, opacity );',
      THREE.ShaderChunk['map_particle_fragment'],
      THREE.ShaderChunk['alphatest_fragment'],
      THREE.ShaderChunk['color_fragment'],
      THREE.ShaderChunk['shadowmap_fragment'],
      THREE.ShaderChunk['fog_fragment'],
      '}'
    ].join('\n')
  },
  'dashed': {
    uniforms: THREE.UniformsUtils.merge([
      THREE.UniformsLib['common'],
      THREE.UniformsLib['fog'],
      {
        'scale': {
          type: 'f',
          value: 1
        },
        'dashSize': {
          type: 'f',
          value: 1
        },
        'totalSize': {
          type: 'f',
          value: 2
        }
      }
    ]),
    vertexShader: [
      'uniform float scale;',
      'attribute float lineDistance;',
      'varying float vLineDistance;',
      THREE.ShaderChunk['color_pars_vertex'],
      'void main() {',
      THREE.ShaderChunk['color_vertex'],
      'vLineDistance = scale * lineDistance;',
      'vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );',
      'gl_Position = projectionMatrix * mvPosition;',
      '}'
    ].join('\n'),
    fragmentShader: [
      'uniform vec3 diffuse;',
      'uniform float opacity;',
      'uniform float dashSize;',
      'uniform float totalSize;',
      'varying float vLineDistance;',
      THREE.ShaderChunk['color_pars_fragment'],
      THREE.ShaderChunk['fog_pars_fragment'],
      'void main() {',
      'if ( mod( vLineDistance, totalSize ) > dashSize ) {',
      'discard;',
      '}',
      'gl_FragColor = vec4( diffuse, opacity );',
      THREE.ShaderChunk['color_fragment'],
      THREE.ShaderChunk['fog_fragment'],
      '}'
    ].join('\n')
  },
  'depth': {
    uniforms: {
      'mNear': {
        type: 'f',
        value: 1
      },
      'mFar': {
        type: 'f',
        value: 2000
      },
      'opacity': {
        type: 'f',
        value: 1
      }
    },
    vertexShader: [
      'void main() {',
      'gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',
      '}'
    ].join('\n'),
    fragmentShader: [
      'uniform float mNear;',
      'uniform float mFar;',
      'uniform float opacity;',
      'void main() {',
      'float depth = gl_FragCoord.z / gl_FragCoord.w;',
      'float color = 1.0 - smoothstep( mNear, mFar, depth );',
      'gl_FragColor = vec4( vec3( color ), opacity );',
      '}'
    ].join('\n')
  },
  'normal': {
    uniforms: {
      'opacity': {
        type: 'f',
        value: 1
      }
    },
    vertexShader: [
      'varying vec3 vNormal;',
      THREE.ShaderChunk['morphtarget_pars_vertex'],
      'void main() {',
      'vNormal = normalize( normalMatrix * normal );',
      THREE.ShaderChunk['morphtarget_vertex'],
      THREE.ShaderChunk['default_vertex'],
      '}'
    ].join('\n'),
    fragmentShader: [
      'uniform float opacity;',
      'varying vec3 vNormal;',
      'void main() {',
      'gl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );',
      '}'
    ].join('\n')
  },
  'normalmap': {
    uniforms: THREE.UniformsUtils.merge([
      THREE.UniformsLib['fog'],
      THREE.UniformsLib['lights'],
      THREE.UniformsLib['shadowmap'],
      {
        'enableAO': {
          type: 'i',
          value: 0
        },
        'enableDiffuse': {
          type: 'i',
          value: 0
        },
        'enableSpecular': {
          type: 'i',
          value: 0
        },
        'enableReflection': {
          type: 'i',
          value: 0
        },
        'enableDisplacement': {
          type: 'i',
          value: 0
        },
        'tDisplacement': {
          type: 't',
          value: null
        },
        'tDiffuse': {
          type: 't',
          value: null
        },
        'tCube': {
          type: 't',
          value: null
        },
        'tNormal': {
          type: 't',
          value: null
        },
        'tSpecular': {
          type: 't',
          value: null
        },
        'tAO': {
          type: 't',
          value: null
        },
        'uNormalScale': {
          type: 'v2',
          value: new THREE.Vector2(1, 1)
        },
        'uDisplacementBias': {
          type: 'f',
          value: 0
        },
        'uDisplacementScale': {
          type: 'f',
          value: 1
        },
        'uDiffuseColor': {
          type: 'c',
          value: new THREE.Color(16777215)
        },
        'uSpecularColor': {
          type: 'c',
          value: new THREE.Color(1118481)
        },
        'uAmbientColor': {
          type: 'c',
          value: new THREE.Color(16777215)
        },
        'uShininess': {
          type: 'f',
          value: 30
        },
        'uOpacity': {
          type: 'f',
          value: 1
        },
        'useRefract': {
          type: 'i',
          value: 0
        },
        'uRefractionRatio': {
          type: 'f',
          value: 0.98
        },
        'uReflectivity': {
          type: 'f',
          value: 0.5
        },
        'uOffset': {
          type: 'v2',
          value: new THREE.Vector2(0, 0)
        },
        'uRepeat': {
          type: 'v2',
          value: new THREE.Vector2(1, 1)
        },
        'wrapRGB': {
          type: 'v3',
          value: new THREE.Vector3(1, 1, 1)
        }
      }
    ]),
    fragmentShader: [
      'uniform vec3 uAmbientColor;',
      'uniform vec3 uDiffuseColor;',
      'uniform vec3 uSpecularColor;',
      'uniform float uShininess;',
      'uniform float uOpacity;',
      'uniform bool enableDiffuse;',
      'uniform bool enableSpecular;',
      'uniform bool enableAO;',
      'uniform bool enableReflection;',
      'uniform sampler2D tDiffuse;',
      'uniform sampler2D tNormal;',
      'uniform sampler2D tSpecular;',
      'uniform sampler2D tAO;',
      'uniform samplerCube tCube;',
      'uniform vec2 uNormalScale;',
      'uniform bool useRefract;',
      'uniform float uRefractionRatio;',
      'uniform float uReflectivity;',
      'varying vec3 vTangent;',
      'varying vec3 vBinormal;',
      'varying vec3 vNormal;',
      'varying vec2 vUv;',
      'uniform vec3 ambientLightColor;',
      '#if MAX_DIR_LIGHTS > 0',
      'uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];',
      'uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];',
      '#endif',
      '#if MAX_HEMI_LIGHTS > 0',
      'uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];',
      'uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];',
      'uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];',
      '#endif',
      '#if MAX_POINT_LIGHTS > 0',
      'uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];',
      'uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];',
      'uniform float pointLightDistance[ MAX_POINT_LIGHTS ];',
      '#endif',
      '#if MAX_SPOT_LIGHTS > 0',
      'uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];',
      'uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];',
      'uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];',
      'uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];',
      'uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];',
      'uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];',
      '#endif',
      '#ifdef WRAP_AROUND',
      'uniform vec3 wrapRGB;',
      '#endif',
      'varying vec3 vWorldPosition;',
      'varying vec3 vViewPosition;',
      THREE.ShaderChunk['shadowmap_pars_fragment'],
      THREE.ShaderChunk['fog_pars_fragment'],
      'void main() {',
      'gl_FragColor = vec4( vec3( 1.0 ), uOpacity );',
      'vec3 specularTex = vec3( 1.0 );',
      'vec3 normalTex = texture2D( tNormal, vUv ).xyz * 2.0 - 1.0;',
      'normalTex.xy *= uNormalScale;',
      'normalTex = normalize( normalTex );',
      'if( enableDiffuse ) {',
      '#ifdef GAMMA_INPUT',
      'vec4 texelColor = texture2D( tDiffuse, vUv );',
      'texelColor.xyz *= texelColor.xyz;',
      'gl_FragColor = gl_FragColor * texelColor;',
      '#else',
      'gl_FragColor = gl_FragColor * texture2D( tDiffuse, vUv );',
      '#endif',
      '}',
      'if( enableAO ) {',
      '#ifdef GAMMA_INPUT',
      'vec4 aoColor = texture2D( tAO, vUv );',
      'aoColor.xyz *= aoColor.xyz;',
      'gl_FragColor.xyz = gl_FragColor.xyz * aoColor.xyz;',
      '#else',
      'gl_FragColor.xyz = gl_FragColor.xyz * texture2D( tAO, vUv ).xyz;',
      '#endif',
      '}',
      'if( enableSpecular )',
      'specularTex = texture2D( tSpecular, vUv ).xyz;',
      'mat3 tsb = mat3( normalize( vTangent ), normalize( vBinormal ), normalize( vNormal ) );',
      'vec3 finalNormal = tsb * normalTex;',
      '#ifdef FLIP_SIDED',
      'finalNormal = -finalNormal;',
      '#endif',
      'vec3 normal = normalize( finalNormal );',
      'vec3 viewPosition = normalize( vViewPosition );',
      '#if MAX_POINT_LIGHTS > 0',
      'vec3 pointDiffuse = vec3( 0.0 );',
      'vec3 pointSpecular = vec3( 0.0 );',
      'for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {',
      'vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );',
      'vec3 pointVector = lPosition.xyz + vViewPosition.xyz;',
      'float pointDistance = 1.0;',
      'if ( pointLightDistance[ i ] > 0.0 )',
      'pointDistance = 1.0 - min( ( length( pointVector ) / pointLightDistance[ i ] ), 1.0 );',
      'pointVector = normalize( pointVector );',
      '#ifdef WRAP_AROUND',
      'float pointDiffuseWeightFull = max( dot( normal, pointVector ), 0.0 );',
      'float pointDiffuseWeightHalf = max( 0.5 * dot( normal, pointVector ) + 0.5, 0.0 );',
      'vec3 pointDiffuseWeight = mix( vec3 ( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );',
      '#else',
      'float pointDiffuseWeight = max( dot( normal, pointVector ), 0.0 );',
      '#endif',
      'pointDiffuse += pointDistance * pointLightColor[ i ] * uDiffuseColor * pointDiffuseWeight;',
      'vec3 pointHalfVector = normalize( pointVector + viewPosition );',
      'float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );',
      'float pointSpecularWeight = specularTex.r * max( pow( pointDotNormalHalf, uShininess ), 0.0 );',
      '#ifdef PHYSICALLY_BASED_SHADING',
      'float specularNormalization = ( uShininess + 2.0001 ) / 8.0;',
      'vec3 schlick = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( pointVector, pointHalfVector ), 5.0 );',
      'pointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * pointDistance * specularNormalization;',
      '#else',
      'pointSpecular += pointDistance * pointLightColor[ i ] * uSpecularColor * pointSpecularWeight * pointDiffuseWeight;',
      '#endif',
      '}',
      '#endif',
      '#if MAX_SPOT_LIGHTS > 0',
      'vec3 spotDiffuse = vec3( 0.0 );',
      'vec3 spotSpecular = vec3( 0.0 );',
      'for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {',
      'vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );',
      'vec3 spotVector = lPosition.xyz + vViewPosition.xyz;',
      'float spotDistance = 1.0;',
      'if ( spotLightDistance[ i ] > 0.0 )',
      'spotDistance = 1.0 - min( ( length( spotVector ) / spotLightDistance[ i ] ), 1.0 );',
      'spotVector = normalize( spotVector );',
      'float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );',
      'if ( spotEffect > spotLightAngleCos[ i ] ) {',
      'spotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );',
      '#ifdef WRAP_AROUND',
      'float spotDiffuseWeightFull = max( dot( normal, spotVector ), 0.0 );',
      'float spotDiffuseWeightHalf = max( 0.5 * dot( normal, spotVector ) + 0.5, 0.0 );',
      'vec3 spotDiffuseWeight = mix( vec3 ( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );',
      '#else',
      'float spotDiffuseWeight = max( dot( normal, spotVector ), 0.0 );',
      '#endif',
      'spotDiffuse += spotDistance * spotLightColor[ i ] * uDiffuseColor * spotDiffuseWeight * spotEffect;',
      'vec3 spotHalfVector = normalize( spotVector + viewPosition );',
      'float spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );',
      'float spotSpecularWeight = specularTex.r * max( pow( spotDotNormalHalf, uShininess ), 0.0 );',
      '#ifdef PHYSICALLY_BASED_SHADING',
      'float specularNormalization = ( uShininess + 2.0001 ) / 8.0;',
      'vec3 schlick = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( spotVector, spotHalfVector ), 5.0 );',
      'spotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * spotDistance * specularNormalization * spotEffect;',
      '#else',
      'spotSpecular += spotDistance * spotLightColor[ i ] * uSpecularColor * spotSpecularWeight * spotDiffuseWeight * spotEffect;',
      '#endif',
      '}',
      '}',
      '#endif',
      '#if MAX_DIR_LIGHTS > 0',
      'vec3 dirDiffuse = vec3( 0.0 );',
      'vec3 dirSpecular = vec3( 0.0 );',
      'for( int i = 0; i < MAX_DIR_LIGHTS; i++ ) {',
      'vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );',
      'vec3 dirVector = normalize( lDirection.xyz );',
      '#ifdef WRAP_AROUND',
      'float directionalLightWeightingFull = max( dot( normal, dirVector ), 0.0 );',
      'float directionalLightWeightingHalf = max( 0.5 * dot( normal, dirVector ) + 0.5, 0.0 );',
      'vec3 dirDiffuseWeight = mix( vec3( directionalLightWeightingFull ), vec3( directionalLightWeightingHalf ), wrapRGB );',
      '#else',
      'float dirDiffuseWeight = max( dot( normal, dirVector ), 0.0 );',
      '#endif',
      'dirDiffuse += directionalLightColor[ i ] * uDiffuseColor * dirDiffuseWeight;',
      'vec3 dirHalfVector = normalize( dirVector + viewPosition );',
      'float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );',
      'float dirSpecularWeight = specularTex.r * max( pow( dirDotNormalHalf, uShininess ), 0.0 );',
      '#ifdef PHYSICALLY_BASED_SHADING',
      'float specularNormalization = ( uShininess + 2.0001 ) / 8.0;',
      'vec3 schlick = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( dirVector, dirHalfVector ), 5.0 );',
      'dirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;',
      '#else',
      'dirSpecular += directionalLightColor[ i ] * uSpecularColor * dirSpecularWeight * dirDiffuseWeight;',
      '#endif',
      '}',
      '#endif',
      '#if MAX_HEMI_LIGHTS > 0',
      'vec3 hemiDiffuse  = vec3( 0.0 );',
      'vec3 hemiSpecular = vec3( 0.0 );',
      'for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {',
      'vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );',
      'vec3 lVector = normalize( lDirection.xyz );',
      'float dotProduct = dot( normal, lVector );',
      'float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;',
      'vec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );',
      'hemiDiffuse += uDiffuseColor * hemiColor;',
      'vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );',
      'float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;',
      'float hemiSpecularWeightSky = specularTex.r * max( pow( hemiDotNormalHalfSky, uShininess ), 0.0 );',
      'vec3 lVectorGround = -lVector;',
      'vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );',
      'float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;',
      'float hemiSpecularWeightGround = specularTex.r * max( pow( hemiDotNormalHalfGround, uShininess ), 0.0 );',
      '#ifdef PHYSICALLY_BASED_SHADING',
      'float dotProductGround = dot( normal, lVectorGround );',
      'float specularNormalization = ( uShininess + 2.0001 ) / 8.0;',
      'vec3 schlickSky = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( lVector, hemiHalfVectorSky ), 5.0 );',
      'vec3 schlickGround = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 5.0 );',
      'hemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );',
      '#else',
      'hemiSpecular += uSpecularColor * hemiColor * ( hemiSpecularWeightSky + hemiSpecularWeightGround ) * hemiDiffuseWeight;',
      '#endif',
      '}',
      '#endif',
      'vec3 totalDiffuse = vec3( 0.0 );',
      'vec3 totalSpecular = vec3( 0.0 );',
      '#if MAX_DIR_LIGHTS > 0',
      'totalDiffuse += dirDiffuse;',
      'totalSpecular += dirSpecular;',
      '#endif',
      '#if MAX_HEMI_LIGHTS > 0',
      'totalDiffuse += hemiDiffuse;',
      'totalSpecular += hemiSpecular;',
      '#endif',
      '#if MAX_POINT_LIGHTS > 0',
      'totalDiffuse += pointDiffuse;',
      'totalSpecular += pointSpecular;',
      '#endif',
      '#if MAX_SPOT_LIGHTS > 0',
      'totalDiffuse += spotDiffuse;',
      'totalSpecular += spotSpecular;',
      '#endif',
      '#ifdef METAL',
      'gl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * uAmbientColor + totalSpecular );',
      '#else',
      'gl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * uAmbientColor ) + totalSpecular;',
      '#endif',
      'if ( enableReflection ) {',
      'vec3 vReflect;',
      'vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );',
      'if ( useRefract ) {',
      'vReflect = refract( cameraToVertex, normal, uRefractionRatio );',
      '} else {',
      'vReflect = reflect( cameraToVertex, normal );',
      '}',
      'vec4 cubeColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );',
      '#ifdef GAMMA_INPUT',
      'cubeColor.xyz *= cubeColor.xyz;',
      '#endif',
      'gl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularTex.r * uReflectivity );',
      '}',
      THREE.ShaderChunk['shadowmap_fragment'],
      THREE.ShaderChunk['linear_to_gamma_fragment'],
      THREE.ShaderChunk['fog_fragment'],
      '}'
    ].join('\n'),
    vertexShader: [
      'attribute vec4 tangent;',
      'uniform vec2 uOffset;',
      'uniform vec2 uRepeat;',
      'uniform bool enableDisplacement;',
      '#ifdef VERTEX_TEXTURES',
      'uniform sampler2D tDisplacement;',
      'uniform float uDisplacementScale;',
      'uniform float uDisplacementBias;',
      '#endif',
      'varying vec3 vTangent;',
      'varying vec3 vBinormal;',
      'varying vec3 vNormal;',
      'varying vec2 vUv;',
      'varying vec3 vWorldPosition;',
      'varying vec3 vViewPosition;',
      THREE.ShaderChunk['skinning_pars_vertex'],
      THREE.ShaderChunk['shadowmap_pars_vertex'],
      'void main() {',
      THREE.ShaderChunk['skinbase_vertex'],
      THREE.ShaderChunk['skinnormal_vertex'],
      '#ifdef USE_SKINNING',
      'vNormal = normalize( normalMatrix * skinnedNormal.xyz );',
      'vec4 skinnedTangent = skinMatrix * vec4( tangent.xyz, 0.0 );',
      'vTangent = normalize( normalMatrix * skinnedTangent.xyz );',
      '#else',
      'vNormal = normalize( normalMatrix * normal );',
      'vTangent = normalize( normalMatrix * tangent.xyz );',
      '#endif',
      'vBinormal = normalize( cross( vNormal, vTangent ) * tangent.w );',
      'vUv = uv * uRepeat + uOffset;',
      'vec3 displacedPosition;',
      '#ifdef VERTEX_TEXTURES',
      'if ( enableDisplacement ) {',
      'vec3 dv = texture2D( tDisplacement, uv ).xyz;',
      'float df = uDisplacementScale * dv.x + uDisplacementBias;',
      'displacedPosition = position + normalize( normal ) * df;',
      '} else {',
      '#ifdef USE_SKINNING',
      'vec4 skinVertex = vec4( position, 1.0 );',
      'vec4 skinned  = boneMatX * skinVertex * skinWeight.x;',
      'skinned \t  += boneMatY * skinVertex * skinWeight.y;',
      'displacedPosition  = skinned.xyz;',
      '#else',
      'displacedPosition = position;',
      '#endif',
      '}',
      '#else',
      '#ifdef USE_SKINNING',
      'vec4 skinVertex = vec4( position, 1.0 );',
      'vec4 skinned  = boneMatX * skinVertex * skinWeight.x;',
      'skinned \t  += boneMatY * skinVertex * skinWeight.y;',
      'displacedPosition  = skinned.xyz;',
      '#else',
      'displacedPosition = position;',
      '#endif',
      '#endif',
      'vec4 mvPosition = modelViewMatrix * vec4( displacedPosition, 1.0 );',
      'vec4 worldPosition = modelMatrix * vec4( displacedPosition, 1.0 );',
      'gl_Position = projectionMatrix * mvPosition;',
      'vWorldPosition = worldPosition.xyz;',
      'vViewPosition = -mvPosition.xyz;',
      '#ifdef USE_SHADOWMAP',
      'for( int i = 0; i < MAX_SHADOWS; i ++ ) {',
      'vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;',
      '}',
      '#endif',
      '}'
    ].join('\n')
  },
  'cube': {
    uniforms: {
      'tCube': {
        type: 't',
        value: null
      },
      'tFlip': {
        type: 'f',
        value: -1
      }
    },
    vertexShader: [
      'varying vec3 vWorldPosition;',
      'void main() {',
      'vec4 worldPosition = modelMatrix * vec4( position, 1.0 );',
      'vWorldPosition = worldPosition.xyz;',
      'gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',
      '}'
    ].join('\n'),
    fragmentShader: [
      'uniform samplerCube tCube;',
      'uniform float tFlip;',
      'varying vec3 vWorldPosition;',
      'void main() {',
      'gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );',
      '}'
    ].join('\n')
  },
  'depthRGBA': {
    uniforms: {},
    vertexShader: [
      THREE.ShaderChunk['morphtarget_pars_vertex'],
      THREE.ShaderChunk['skinning_pars_vertex'],
      'void main() {',
      THREE.ShaderChunk['skinbase_vertex'],
      THREE.ShaderChunk['morphtarget_vertex'],
      THREE.ShaderChunk['skinning_vertex'],
      THREE.ShaderChunk['default_vertex'],
      '}'
    ].join('\n'),
    fragmentShader: [
      'vec4 pack_depth( const in float depth ) {',
      'const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );',
      'const vec4 bit_mask  = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );',
      'vec4 res = fract( depth * bit_shift );',
      'res -= res.xxyz * bit_mask;',
      'return res;',
      '}',
      'void main() {',
      'gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );',
      '}'
    ].join('\n')
  }
};
THREE.WebGLRenderer = function (parameters) {
  console.log('THREE.WebGLRenderer', THREE.REVISION);
  parameters = parameters || {};
  var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElement('canvas'), _precision = parameters.precision !== undefined ? parameters.precision : 'highp', _alpha = parameters.alpha !== undefined ? parameters.alpha : true, _premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true, _antialias = parameters.antialias !== undefined ? parameters.antialias : false, _stencil = parameters.stencil !== undefined ? parameters.stencil : true, _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false, _clearColor = new THREE.Color(0), _clearAlpha = 0;
  if (parameters.clearColor !== undefined) {
    console.warn('DEPRECATED: clearColor in WebGLRenderer constructor parameters is being removed. Use .setClearColor() instead.');
    _clearColor.setHex(parameters.clearColor);
  }
  if (parameters.clearAlpha !== undefined) {
    console.warn('DEPRECATED: clearAlpha in WebGLRenderer constructor parameters is being removed. Use .setClearColor() instead.');
    _clearAlpha = parameters.clearAlpha;
  }
  this.domElement = _canvas;
  this.context = null;
  this.devicePixelRatio = parameters.devicePixelRatio !== undefined ? parameters.devicePixelRatio : window.devicePixelRatio !== undefined ? window.devicePixelRatio : 1;
  this.autoClear = true;
  this.autoClearColor = true;
  this.autoClearDepth = true;
  this.autoClearStencil = true;
  this.sortObjects = true;
  this.autoUpdateObjects = true;
  this.gammaInput = false;
  this.gammaOutput = false;
  this.physicallyBasedShading = false;
  this.shadowMapEnabled = false;
  this.shadowMapAutoUpdate = true;
  this.shadowMapType = THREE.PCFShadowMap;
  this.shadowMapCullFace = THREE.CullFaceFront;
  this.shadowMapDebug = false;
  this.shadowMapCascade = false;
  this.maxMorphTargets = 8;
  this.maxMorphNormals = 4;
  this.autoScaleCubemaps = true;
  this.renderPluginsPre = [];
  this.renderPluginsPost = [];
  this.info = {
    memory: {
      programs: 0,
      geometries: 0,
      textures: 0
    },
    render: {
      calls: 0,
      vertices: 0,
      faces: 0,
      points: 0
    }
  };
  var _this = this, _programs = [], _programs_counter = 0, _currentProgram = null, _currentFramebuffer = null, _currentMaterialId = -1, _currentGeometryGroupHash = null, _currentCamera = null, _geometryGroupCounter = 0, _usedTextureUnits = 0, _oldDoubleSided = -1, _oldFlipSided = -1, _oldBlending = -1, _oldBlendEquation = -1, _oldBlendSrc = -1, _oldBlendDst = -1, _oldDepthTest = -1, _oldDepthWrite = -1, _oldPolygonOffset = null, _oldPolygonOffsetFactor = null, _oldPolygonOffsetUnits = null, _oldLineWidth = null, _viewportX = 0, _viewportY = 0, _viewportWidth = 0, _viewportHeight = 0, _currentWidth = 0, _currentHeight = 0, _enabledAttributes = {}, _frustum = new THREE.Frustum(), _projScreenMatrix = new THREE.Matrix4(), _projScreenMatrixPS = new THREE.Matrix4(), _vector3 = new THREE.Vector3(), _direction = new THREE.Vector3(), _lightsNeedUpdate = true, _lights = {
      ambient: [
        0,
        0,
        0
      ],
      directional: {
        length: 0,
        colors: new Array(),
        positions: new Array()
      },
      point: {
        length: 0,
        colors: new Array(),
        positions: new Array(),
        distances: new Array()
      },
      spot: {
        length: 0,
        colors: new Array(),
        positions: new Array(),
        distances: new Array(),
        directions: new Array(),
        anglesCos: new Array(),
        exponents: new Array()
      },
      hemi: {
        length: 0,
        skyColors: new Array(),
        groundColors: new Array(),
        positions: new Array()
      }
    };
  var _gl;
  var _glExtensionTextureFloat;
  var _glExtensionTextureFloatLinear;
  var _glExtensionStandardDerivatives;
  var _glExtensionTextureFilterAnisotropic;
  var _glExtensionCompressedTextureS3TC;
  initGL();
  setDefaultGLState();
  this.context = _gl;
  var _maxTextures = _gl.getParameter(_gl.MAX_TEXTURE_IMAGE_UNITS);
  var _maxVertexTextures = _gl.getParameter(_gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
  var _maxTextureSize = _gl.getParameter(_gl.MAX_TEXTURE_SIZE);
  var _maxCubemapSize = _gl.getParameter(_gl.MAX_CUBE_MAP_TEXTURE_SIZE);
  var _maxAnisotropy = _glExtensionTextureFilterAnisotropic ? _gl.getParameter(_glExtensionTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0;
  var _supportsVertexTextures = _maxVertexTextures > 0;
  var _supportsBoneTextures = _supportsVertexTextures && _glExtensionTextureFloat;
  var _compressedTextureFormats = _glExtensionCompressedTextureS3TC ? _gl.getParameter(_gl.COMPRESSED_TEXTURE_FORMATS) : [];
  var _vertexShaderPrecisionHighpFloat = _gl.getShaderPrecisionFormat(_gl.VERTEX_SHADER, _gl.HIGH_FLOAT);
  var _vertexShaderPrecisionMediumpFloat = _gl.getShaderPrecisionFormat(_gl.VERTEX_SHADER, _gl.MEDIUM_FLOAT);
  var _vertexShaderPrecisionLowpFloat = _gl.getShaderPrecisionFormat(_gl.VERTEX_SHADER, _gl.LOW_FLOAT);
  var _fragmentShaderPrecisionHighpFloat = _gl.getShaderPrecisionFormat(_gl.FRAGMENT_SHADER, _gl.HIGH_FLOAT);
  var _fragmentShaderPrecisionMediumpFloat = _gl.getShaderPrecisionFormat(_gl.FRAGMENT_SHADER, _gl.MEDIUM_FLOAT);
  var _fragmentShaderPrecisionLowpFloat = _gl.getShaderPrecisionFormat(_gl.FRAGMENT_SHADER, _gl.LOW_FLOAT);
  var _vertexShaderPrecisionHighpInt = _gl.getShaderPrecisionFormat(_gl.VERTEX_SHADER, _gl.HIGH_INT);
  var _vertexShaderPrecisionMediumpInt = _gl.getShaderPrecisionFormat(_gl.VERTEX_SHADER, _gl.MEDIUM_INT);
  var _vertexShaderPrecisionLowpInt = _gl.getShaderPrecisionFormat(_gl.VERTEX_SHADER, _gl.LOW_INT);
  var _fragmentShaderPrecisionHighpInt = _gl.getShaderPrecisionFormat(_gl.FRAGMENT_SHADER, _gl.HIGH_INT);
  var _fragmentShaderPrecisionMediumpInt = _gl.getShaderPrecisionFormat(_gl.FRAGMENT_SHADER, _gl.MEDIUM_INT);
  var _fragmentShaderPrecisionLowpInt = _gl.getShaderPrecisionFormat(_gl.FRAGMENT_SHADER, _gl.LOW_INT);
  var highpAvailable = _vertexShaderPrecisionHighpFloat.precision > 0 && _fragmentShaderPrecisionHighpFloat.precision > 0;
  var mediumpAvailable = _vertexShaderPrecisionMediumpFloat.precision > 0 && _fragmentShaderPrecisionMediumpFloat.precision > 0;
  if (_precision === 'highp' && !highpAvailable) {
    if (mediumpAvailable) {
      _precision = 'mediump';
      console.warn('WebGLRenderer: highp not supported, using mediump');
    } else {
      _precision = 'lowp';
      console.warn('WebGLRenderer: highp and mediump not supported, using lowp');
    }
  }
  if (_precision === 'mediump' && !mediumpAvailable) {
    _precision = 'lowp';
    console.warn('WebGLRenderer: mediump not supported, using lowp');
  }
  this.getContext = function () {
    return _gl;
  };
  this.supportsVertexTextures = function () {
    return _supportsVertexTextures;
  };
  this.supportsFloatTextures = function () {
    return _glExtensionTextureFloat;
  };
  this.supportsStandardDerivatives = function () {
    return _glExtensionStandardDerivatives;
  };
  this.supportsCompressedTextureS3TC = function () {
    return _glExtensionCompressedTextureS3TC;
  };
  this.getMaxAnisotropy = function () {
    return _maxAnisotropy;
  };
  this.getPrecision = function () {
    return _precision;
  };
  this.setSize = function (width, height, updateStyle) {
    _canvas.width = width * this.devicePixelRatio;
    _canvas.height = height * this.devicePixelRatio;
    if (this.devicePixelRatio !== 1 && updateStyle !== false) {
      _canvas.style.width = width + 'px';
      _canvas.style.height = height + 'px';
    }
    this.setViewport(0, 0, _canvas.width, _canvas.height);
  };
  this.setViewport = function (x, y, width, height) {
    _viewportX = x !== undefined ? x : 0;
    _viewportY = y !== undefined ? y : 0;
    _viewportWidth = width !== undefined ? width : _canvas.width;
    _viewportHeight = height !== undefined ? height : _canvas.height;
    _gl.viewport(_viewportX, _viewportY, _viewportWidth, _viewportHeight);
  };
  this.setScissor = function (x, y, width, height) {
    _gl.scissor(x, y, width, height);
  };
  this.enableScissorTest = function (enable) {
    enable ? _gl.enable(_gl.SCISSOR_TEST) : _gl.disable(_gl.SCISSOR_TEST);
  };
  this.setClearColor = function (color, alpha) {
    _clearColor.set(color);
    _clearAlpha = alpha !== undefined ? alpha : 1;
    _gl.clearColor(_clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha);
  };
  this.setClearColorHex = function (hex, alpha) {
    console.warn('DEPRECATED: .setClearColorHex() is being removed. Use .setClearColor() instead.');
    this.setClearColor(hex, alpha);
  };
  this.getClearColor = function () {
    return _clearColor;
  };
  this.getClearAlpha = function () {
    return _clearAlpha;
  };
  this.clear = function (color, depth, stencil) {
    var bits = 0;
    if (color === undefined || color)
      bits |= _gl.COLOR_BUFFER_BIT;
    if (depth === undefined || depth)
      bits |= _gl.DEPTH_BUFFER_BIT;
    if (stencil === undefined || stencil)
      bits |= _gl.STENCIL_BUFFER_BIT;
    _gl.clear(bits);
  };
  this.clearTarget = function (renderTarget, color, depth, stencil) {
    this.setRenderTarget(renderTarget);
    this.clear(color, depth, stencil);
  };
  this.addPostPlugin = function (plugin) {
    plugin.init(this);
    this.renderPluginsPost.push(plugin);
  };
  this.addPrePlugin = function (plugin) {
    plugin.init(this);
    this.renderPluginsPre.push(plugin);
  };
  this.updateShadowMap = function (scene, camera) {
    _currentProgram = null;
    _oldBlending = -1;
    _oldDepthTest = -1;
    _oldDepthWrite = -1;
    _currentGeometryGroupHash = -1;
    _currentMaterialId = -1;
    _lightsNeedUpdate = true;
    _oldDoubleSided = -1;
    _oldFlipSided = -1;
    this.shadowMapPlugin.update(scene, camera);
  };
  function createParticleBuffers(geometry) {
    geometry.__webglVertexBuffer = _gl.createBuffer();
    geometry.__webglColorBuffer = _gl.createBuffer();
    _this.info.memory.geometries++;
  }
  ;
  function createLineBuffers(geometry) {
    geometry.__webglVertexBuffer = _gl.createBuffer();
    geometry.__webglColorBuffer = _gl.createBuffer();
    geometry.__webglLineDistanceBuffer = _gl.createBuffer();
    _this.info.memory.geometries++;
  }
  ;
  function createRibbonBuffers(geometry) {
    geometry.__webglVertexBuffer = _gl.createBuffer();
    geometry.__webglColorBuffer = _gl.createBuffer();
    geometry.__webglNormalBuffer = _gl.createBuffer();
    _this.info.memory.geometries++;
  }
  ;
  function createMeshBuffers(geometryGroup) {
    geometryGroup.__webglVertexBuffer = _gl.createBuffer();
    geometryGroup.__webglNormalBuffer = _gl.createBuffer();
    geometryGroup.__webglTangentBuffer = _gl.createBuffer();
    geometryGroup.__webglColorBuffer = _gl.createBuffer();
    geometryGroup.__webglUVBuffer = _gl.createBuffer();
    geometryGroup.__webglUV2Buffer = _gl.createBuffer();
    geometryGroup.__webglSkinIndicesBuffer = _gl.createBuffer();
    geometryGroup.__webglSkinWeightsBuffer = _gl.createBuffer();
    geometryGroup.__webglFaceBuffer = _gl.createBuffer();
    geometryGroup.__webglLineBuffer = _gl.createBuffer();
    var m, ml;
    if (geometryGroup.numMorphTargets) {
      geometryGroup.__webglMorphTargetsBuffers = [];
      for (m = 0, ml = geometryGroup.numMorphTargets; m < ml; m++) {
        geometryGroup.__webglMorphTargetsBuffers.push(_gl.createBuffer());
      }
    }
    if (geometryGroup.numMorphNormals) {
      geometryGroup.__webglMorphNormalsBuffers = [];
      for (m = 0, ml = geometryGroup.numMorphNormals; m < ml; m++) {
        geometryGroup.__webglMorphNormalsBuffers.push(_gl.createBuffer());
      }
    }
    _this.info.memory.geometries++;
  }
  ;
  var onGeometryDispose = function (event) {
    var geometry = event.target;
    geometry.removeEventListener('dispose', onGeometryDispose);
    deallocateGeometry(geometry);
  };
  var onTextureDispose = function (event) {
    var texture = event.target;
    texture.removeEventListener('dispose', onTextureDispose);
    deallocateTexture(texture);
    _this.info.memory.textures--;
  };
  var onRenderTargetDispose = function (event) {
    var renderTarget = event.target;
    renderTarget.removeEventListener('dispose', onRenderTargetDispose);
    deallocateRenderTarget(renderTarget);
    _this.info.memory.textures--;
  };
  var onMaterialDispose = function (event) {
    var material = event.target;
    material.removeEventListener('dispose', onMaterialDispose);
    deallocateMaterial(material);
  };
  var deleteBuffers = function (geometry) {
    if (geometry.__webglVertexBuffer !== undefined)
      _gl.deleteBuffer(geometry.__webglVertexBuffer);
    if (geometry.__webglNormalBuffer !== undefined)
      _gl.deleteBuffer(geometry.__webglNormalBuffer);
    if (geometry.__webglTangentBuffer !== undefined)
      _gl.deleteBuffer(geometry.__webglTangentBuffer);
    if (geometry.__webglColorBuffer !== undefined)
      _gl.deleteBuffer(geometry.__webglColorBuffer);
    if (geometry.__webglUVBuffer !== undefined)
      _gl.deleteBuffer(geometry.__webglUVBuffer);
    if (geometry.__webglUV2Buffer !== undefined)
      _gl.deleteBuffer(geometry.__webglUV2Buffer);
    if (geometry.__webglSkinIndicesBuffer !== undefined)
      _gl.deleteBuffer(geometry.__webglSkinIndicesBuffer);
    if (geometry.__webglSkinWeightsBuffer !== undefined)
      _gl.deleteBuffer(geometry.__webglSkinWeightsBuffer);
    if (geometry.__webglFaceBuffer !== undefined)
      _gl.deleteBuffer(geometry.__webglFaceBuffer);
    if (geometry.__webglLineBuffer !== undefined)
      _gl.deleteBuffer(geometry.__webglLineBuffer);
    if (geometry.__webglLineDistanceBuffer !== undefined)
      _gl.deleteBuffer(geometry.__webglLineDistanceBuffer);
    if (geometry.__webglCustomAttributesList !== undefined) {
      for (var id in geometry.__webglCustomAttributesList) {
        _gl.deleteBuffer(geometry.__webglCustomAttributesList[id].buffer);
      }
    }
    _this.info.memory.geometries--;
  };
  var deallocateGeometry = function (geometry) {
    geometry.__webglInit = undefined;
    if (geometry instanceof THREE.BufferGeometry) {
      var attributes = geometry.attributes;
      for (var key in attributes) {
        if (attributes[key].buffer !== undefined) {
          _gl.deleteBuffer(attributes[key].buffer);
        }
      }
      _this.info.memory.geometries--;
    } else {
      if (geometry.geometryGroups !== undefined) {
        for (var g in geometry.geometryGroups) {
          var geometryGroup = geometry.geometryGroups[g];
          if (geometryGroup.numMorphTargets !== undefined) {
            for (var m = 0, ml = geometryGroup.numMorphTargets; m < ml; m++) {
              _gl.deleteBuffer(geometryGroup.__webglMorphTargetsBuffers[m]);
            }
          }
          if (geometryGroup.numMorphNormals !== undefined) {
            for (var m = 0, ml = geometryGroup.numMorphNormals; m < ml; m++) {
              _gl.deleteBuffer(geometryGroup.__webglMorphNormalsBuffers[m]);
            }
          }
          deleteBuffers(geometryGroup);
        }
      } else {
        deleteBuffers(geometry);
      }
    }
  };
  var deallocateTexture = function (texture) {
    if (texture.image && texture.image.__webglTextureCube) {
      _gl.deleteTexture(texture.image.__webglTextureCube);
    } else {
      if (!texture.__webglInit)
        return;
      texture.__webglInit = false;
      _gl.deleteTexture(texture.__webglTexture);
    }
  };
  var deallocateRenderTarget = function (renderTarget) {
    if (!renderTarget || !renderTarget.__webglTexture)
      return;
    _gl.deleteTexture(renderTarget.__webglTexture);
    if (renderTarget instanceof THREE.WebGLRenderTargetCube) {
      for (var i = 0; i < 6; i++) {
        _gl.deleteFramebuffer(renderTarget.__webglFramebuffer[i]);
        _gl.deleteRenderbuffer(renderTarget.__webglRenderbuffer[i]);
      }
    } else {
      _gl.deleteFramebuffer(renderTarget.__webglFramebuffer);
      _gl.deleteRenderbuffer(renderTarget.__webglRenderbuffer);
    }
  };
  var deallocateMaterial = function (material) {
    var program = material.program;
    if (program === undefined)
      return;
    material.program = undefined;
    var i, il, programInfo;
    var deleteProgram = false;
    for (i = 0, il = _programs.length; i < il; i++) {
      programInfo = _programs[i];
      if (programInfo.program === program) {
        programInfo.usedTimes--;
        if (programInfo.usedTimes === 0) {
          deleteProgram = true;
        }
        break;
      }
    }
    if (deleteProgram === true) {
      var newPrograms = [];
      for (i = 0, il = _programs.length; i < il; i++) {
        programInfo = _programs[i];
        if (programInfo.program !== program) {
          newPrograms.push(programInfo);
        }
      }
      _programs = newPrograms;
      _gl.deleteProgram(program);
      _this.info.memory.programs--;
    }
  };
  function initCustomAttributes(geometry, object) {
    var nvertices = geometry.vertices.length;
    var material = object.material;
    if (material.attributes) {
      if (geometry.__webglCustomAttributesList === undefined) {
        geometry.__webglCustomAttributesList = [];
      }
      for (var a in material.attributes) {
        var attribute = material.attributes[a];
        if (!attribute.__webglInitialized || attribute.createUniqueBuffers) {
          attribute.__webglInitialized = true;
          var size = 1;
          if (attribute.type === 'v2')
            size = 2;
          else if (attribute.type === 'v3')
            size = 3;
          else if (attribute.type === 'v4')
            size = 4;
          else if (attribute.type === 'c')
            size = 3;
          attribute.size = size;
          attribute.array = new Float32Array(nvertices * size);
          attribute.buffer = _gl.createBuffer();
          attribute.buffer.belongsToAttribute = a;
          attribute.needsUpdate = true;
        }
        geometry.__webglCustomAttributesList.push(attribute);
      }
    }
  }
  ;
  function initParticleBuffers(geometry, object) {
    var nvertices = geometry.vertices.length;
    geometry.__vertexArray = new Float32Array(nvertices * 3);
    geometry.__colorArray = new Float32Array(nvertices * 3);
    geometry.__sortArray = [];
    geometry.__webglParticleCount = nvertices;
    initCustomAttributes(geometry, object);
  }
  ;
  function initLineBuffers(geometry, object) {
    var nvertices = geometry.vertices.length;
    geometry.__vertexArray = new Float32Array(nvertices * 3);
    geometry.__colorArray = new Float32Array(nvertices * 3);
    geometry.__lineDistanceArray = new Float32Array(nvertices * 1);
    geometry.__webglLineCount = nvertices;
    initCustomAttributes(geometry, object);
  }
  ;
  function initRibbonBuffers(geometry, object) {
    var nvertices = geometry.vertices.length;
    geometry.__vertexArray = new Float32Array(nvertices * 3);
    geometry.__colorArray = new Float32Array(nvertices * 3);
    geometry.__normalArray = new Float32Array(nvertices * 3);
    geometry.__webglVertexCount = nvertices;
    initCustomAttributes(geometry, object);
  }
  ;
  function initMeshBuffers(geometryGroup, object) {
    var geometry = object.geometry, faces3 = geometryGroup.faces3, nvertices = faces3.length * 3, ntris = faces3.length * 1, nlines = faces3.length * 3, material = getBufferMaterial(object, geometryGroup), uvType = bufferGuessUVType(material), normalType = bufferGuessNormalType(material), vertexColorType = bufferGuessVertexColorType(material);
    geometryGroup.__vertexArray = new Float32Array(nvertices * 3);
    if (normalType) {
      geometryGroup.__normalArray = new Float32Array(nvertices * 3);
    }
    if (geometry.hasTangents) {
      geometryGroup.__tangentArray = new Float32Array(nvertices * 4);
    }
    if (vertexColorType) {
      geometryGroup.__colorArray = new Float32Array(nvertices * 3);
    }
    if (uvType) {
      if (geometry.faceVertexUvs.length > 0) {
        geometryGroup.__uvArray = new Float32Array(nvertices * 2);
      }
      if (geometry.faceVertexUvs.length > 1) {
        geometryGroup.__uv2Array = new Float32Array(nvertices * 2);
      }
    }
    if (object.geometry.skinWeights.length && object.geometry.skinIndices.length) {
      geometryGroup.__skinIndexArray = new Float32Array(nvertices * 4);
      geometryGroup.__skinWeightArray = new Float32Array(nvertices * 4);
    }
    geometryGroup.__faceArray = new Uint16Array(ntris * 3);
    geometryGroup.__lineArray = new Uint16Array(nlines * 2);
    var m, ml;
    if (geometryGroup.numMorphTargets) {
      geometryGroup.__morphTargetsArrays = [];
      for (m = 0, ml = geometryGroup.numMorphTargets; m < ml; m++) {
        geometryGroup.__morphTargetsArrays.push(new Float32Array(nvertices * 3));
      }
    }
    if (geometryGroup.numMorphNormals) {
      geometryGroup.__morphNormalsArrays = [];
      for (m = 0, ml = geometryGroup.numMorphNormals; m < ml; m++) {
        geometryGroup.__morphNormalsArrays.push(new Float32Array(nvertices * 3));
      }
    }
    geometryGroup.__webglFaceCount = ntris * 3;
    geometryGroup.__webglLineCount = nlines * 2;
    if (material.attributes) {
      if (geometryGroup.__webglCustomAttributesList === undefined) {
        geometryGroup.__webglCustomAttributesList = [];
      }
      for (var a in material.attributes) {
        var originalAttribute = material.attributes[a];
        var attribute = {};
        for (var property in originalAttribute) {
          attribute[property] = originalAttribute[property];
        }
        if (!attribute.__webglInitialized || attribute.createUniqueBuffers) {
          attribute.__webglInitialized = true;
          var size = 1;
          if (attribute.type === 'v2')
            size = 2;
          else if (attribute.type === 'v3')
            size = 3;
          else if (attribute.type === 'v4')
            size = 4;
          else if (attribute.type === 'c')
            size = 3;
          attribute.size = size;
          attribute.array = new Float32Array(nvertices * size);
          attribute.buffer = _gl.createBuffer();
          attribute.buffer.belongsToAttribute = a;
          originalAttribute.needsUpdate = true;
          attribute.__original = originalAttribute;
        }
        geometryGroup.__webglCustomAttributesList.push(attribute);
      }
    }
    geometryGroup.__inittedArrays = true;
  }
  ;
  function getBufferMaterial(object, geometryGroup) {
    return object.material instanceof THREE.MeshFaceMaterial ? object.material.materials[geometryGroup.materialIndex] : object.material;
  }
  ;
  function materialNeedsSmoothNormals(material) {
    return material && material.shading !== undefined && material.shading === THREE.SmoothShading;
  }
  ;
  function bufferGuessNormalType(material) {
    if (material instanceof THREE.MeshBasicMaterial && !material.envMap || material instanceof THREE.MeshDepthMaterial) {
      return false;
    }
    if (materialNeedsSmoothNormals(material)) {
      return THREE.SmoothShading;
    } else {
      return THREE.FlatShading;
    }
  }
  ;
  function bufferGuessVertexColorType(material) {
    if (material.vertexColors) {
      return material.vertexColors;
    }
    return false;
  }
  ;
  function bufferGuessUVType(material) {
    if (material.map || material.lightMap || material.bumpMap || material.normalMap || material.specularMap || material instanceof THREE.ShaderMaterial) {
      return true;
    }
    return false;
  }
  ;
  function initDirectBuffers(geometry) {
    var a, attribute, type;
    for (a in geometry.attributes) {
      if (a === 'index') {
        type = _gl.ELEMENT_ARRAY_BUFFER;
      } else {
        type = _gl.ARRAY_BUFFER;
      }
      attribute = geometry.attributes[a];
      if (attribute.numItems === undefined) {
        attribute.numItems = attribute.array.length;
      }
      attribute.buffer = _gl.createBuffer();
      _gl.bindBuffer(type, attribute.buffer);
      _gl.bufferData(type, attribute.array, _gl.STATIC_DRAW);
    }
  }
  ;
  function setParticleBuffers(geometry, hint, object) {
    var v, c, vertex, offset, index, color, vertices = geometry.vertices, vl = vertices.length, colors = geometry.colors, cl = colors.length, vertexArray = geometry.__vertexArray, colorArray = geometry.__colorArray, sortArray = geometry.__sortArray, dirtyVertices = geometry.verticesNeedUpdate, dirtyElements = geometry.elementsNeedUpdate, dirtyColors = geometry.colorsNeedUpdate, customAttributes = geometry.__webglCustomAttributesList, i, il, a, ca, cal, value, customAttribute;
    if (object.sortParticles) {
      _projScreenMatrixPS.copy(_projScreenMatrix);
      _projScreenMatrixPS.multiply(object.matrixWorld);
      for (v = 0; v < vl; v++) {
        vertex = vertices[v];
        _vector3.copy(vertex);
        _vector3.applyProjection(_projScreenMatrixPS);
        sortArray[v] = [
          _vector3.z,
          v
        ];
      }
      sortArray.sort(numericalSort);
      for (v = 0; v < vl; v++) {
        vertex = vertices[sortArray[v][1]];
        offset = v * 3;
        vertexArray[offset] = vertex.x;
        vertexArray[offset + 1] = vertex.y;
        vertexArray[offset + 2] = vertex.z;
      }
      for (c = 0; c < cl; c++) {
        offset = c * 3;
        color = colors[sortArray[c][1]];
        colorArray[offset] = color.r;
        colorArray[offset + 1] = color.g;
        colorArray[offset + 2] = color.b;
      }
      if (customAttributes) {
        for (i = 0, il = customAttributes.length; i < il; i++) {
          customAttribute = customAttributes[i];
          if (!(customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices'))
            continue;
          offset = 0;
          cal = customAttribute.value.length;
          if (customAttribute.size === 1) {
            for (ca = 0; ca < cal; ca++) {
              index = sortArray[ca][1];
              customAttribute.array[ca] = customAttribute.value[index];
            }
          } else if (customAttribute.size === 2) {
            for (ca = 0; ca < cal; ca++) {
              index = sortArray[ca][1];
              value = customAttribute.value[index];
              customAttribute.array[offset] = value.x;
              customAttribute.array[offset + 1] = value.y;
              offset += 2;
            }
          } else if (customAttribute.size === 3) {
            if (customAttribute.type === 'c') {
              for (ca = 0; ca < cal; ca++) {
                index = sortArray[ca][1];
                value = customAttribute.value[index];
                customAttribute.array[offset] = value.r;
                customAttribute.array[offset + 1] = value.g;
                customAttribute.array[offset + 2] = value.b;
                offset += 3;
              }
            } else {
              for (ca = 0; ca < cal; ca++) {
                index = sortArray[ca][1];
                value = customAttribute.value[index];
                customAttribute.array[offset] = value.x;
                customAttribute.array[offset + 1] = value.y;
                customAttribute.array[offset + 2] = value.z;
                offset += 3;
              }
            }
          } else if (customAttribute.size === 4) {
            for (ca = 0; ca < cal; ca++) {
              index = sortArray[ca][1];
              value = customAttribute.value[index];
              customAttribute.array[offset] = value.x;
              customAttribute.array[offset + 1] = value.y;
              customAttribute.array[offset + 2] = value.z;
              customAttribute.array[offset + 3] = value.w;
              offset += 4;
            }
          }
        }
      }
    } else {
      if (dirtyVertices) {
        for (v = 0; v < vl; v++) {
          vertex = vertices[v];
          offset = v * 3;
          vertexArray[offset] = vertex.x;
          vertexArray[offset + 1] = vertex.y;
          vertexArray[offset + 2] = vertex.z;
        }
      }
      if (dirtyColors) {
        for (c = 0; c < cl; c++) {
          color = colors[c];
          offset = c * 3;
          colorArray[offset] = color.r;
          colorArray[offset + 1] = color.g;
          colorArray[offset + 2] = color.b;
        }
      }
      if (customAttributes) {
        for (i = 0, il = customAttributes.length; i < il; i++) {
          customAttribute = customAttributes[i];
          if (customAttribute.needsUpdate && (customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices')) {
            cal = customAttribute.value.length;
            offset = 0;
            if (customAttribute.size === 1) {
              for (ca = 0; ca < cal; ca++) {
                customAttribute.array[ca] = customAttribute.value[ca];
              }
            } else if (customAttribute.size === 2) {
              for (ca = 0; ca < cal; ca++) {
                value = customAttribute.value[ca];
                customAttribute.array[offset] = value.x;
                customAttribute.array[offset + 1] = value.y;
                offset += 2;
              }
            } else if (customAttribute.size === 3) {
              if (customAttribute.type === 'c') {
                for (ca = 0; ca < cal; ca++) {
                  value = customAttribute.value[ca];
                  customAttribute.array[offset] = value.r;
                  customAttribute.array[offset + 1] = value.g;
                  customAttribute.array[offset + 2] = value.b;
                  offset += 3;
                }
              } else {
                for (ca = 0; ca < cal; ca++) {
                  value = customAttribute.value[ca];
                  customAttribute.array[offset] = value.x;
                  customAttribute.array[offset + 1] = value.y;
                  customAttribute.array[offset + 2] = value.z;
                  offset += 3;
                }
              }
            } else if (customAttribute.size === 4) {
              for (ca = 0; ca < cal; ca++) {
                value = customAttribute.value[ca];
                customAttribute.array[offset] = value.x;
                customAttribute.array[offset + 1] = value.y;
                customAttribute.array[offset + 2] = value.z;
                customAttribute.array[offset + 3] = value.w;
                offset += 4;
              }
            }
          }
        }
      }
    }
    if (dirtyVertices || object.sortParticles) {
      _gl.bindBuffer(_gl.ARRAY_BUFFER, geometry.__webglVertexBuffer);
      _gl.bufferData(_gl.ARRAY_BUFFER, vertexArray, hint);
    }
    if (dirtyColors || object.sortParticles) {
      _gl.bindBuffer(_gl.ARRAY_BUFFER, geometry.__webglColorBuffer);
      _gl.bufferData(_gl.ARRAY_BUFFER, colorArray, hint);
    }
    if (customAttributes) {
      for (i = 0, il = customAttributes.length; i < il; i++) {
        customAttribute = customAttributes[i];
        if (customAttribute.needsUpdate || object.sortParticles) {
          _gl.bindBuffer(_gl.ARRAY_BUFFER, customAttribute.buffer);
          _gl.bufferData(_gl.ARRAY_BUFFER, customAttribute.array, hint);
        }
      }
    }
  }
  ;
  function setLineBuffers(geometry, hint) {
    var v, c, d, vertex, offset, color, vertices = geometry.vertices, colors = geometry.colors, lineDistances = geometry.lineDistances, vl = vertices.length, cl = colors.length, dl = lineDistances.length, vertexArray = geometry.__vertexArray, colorArray = geometry.__colorArray, lineDistanceArray = geometry.__lineDistanceArray, dirtyVertices = geometry.verticesNeedUpdate, dirtyColors = geometry.colorsNeedUpdate, dirtyLineDistances = geometry.lineDistancesNeedUpdate, customAttributes = geometry.__webglCustomAttributesList, i, il, a, ca, cal, value, customAttribute;
    if (dirtyVertices) {
      for (v = 0; v < vl; v++) {
        vertex = vertices[v];
        offset = v * 3;
        vertexArray[offset] = vertex.x;
        vertexArray[offset + 1] = vertex.y;
        vertexArray[offset + 2] = vertex.z;
      }
      _gl.bindBuffer(_gl.ARRAY_BUFFER, geometry.__webglVertexBuffer);
      _gl.bufferData(_gl.ARRAY_BUFFER, vertexArray, hint);
    }
    if (dirtyColors) {
      for (c = 0; c < cl; c++) {
        color = colors[c];
        offset = c * 3;
        colorArray[offset] = color.r;
        colorArray[offset + 1] = color.g;
        colorArray[offset + 2] = color.b;
      }
      _gl.bindBuffer(_gl.ARRAY_BUFFER, geometry.__webglColorBuffer);
      _gl.bufferData(_gl.ARRAY_BUFFER, colorArray, hint);
    }
    if (dirtyLineDistances) {
      for (d = 0; d < dl; d++) {
        lineDistanceArray[d] = lineDistances[d];
      }
      _gl.bindBuffer(_gl.ARRAY_BUFFER, geometry.__webglLineDistanceBuffer);
      _gl.bufferData(_gl.ARRAY_BUFFER, lineDistanceArray, hint);
    }
    if (customAttributes) {
      for (i = 0, il = customAttributes.length; i < il; i++) {
        customAttribute = customAttributes[i];
        if (customAttribute.needsUpdate && (customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices')) {
          offset = 0;
          cal = customAttribute.value.length;
          if (customAttribute.size === 1) {
            for (ca = 0; ca < cal; ca++) {
              customAttribute.array[ca] = customAttribute.value[ca];
            }
          } else if (customAttribute.size === 2) {
            for (ca = 0; ca < cal; ca++) {
              value = customAttribute.value[ca];
              customAttribute.array[offset] = value.x;
              customAttribute.array[offset + 1] = value.y;
              offset += 2;
            }
          } else if (customAttribute.size === 3) {
            if (customAttribute.type === 'c') {
              for (ca = 0; ca < cal; ca++) {
                value = customAttribute.value[ca];
                customAttribute.array[offset] = value.r;
                customAttribute.array[offset + 1] = value.g;
                customAttribute.array[offset + 2] = value.b;
                offset += 3;
              }
            } else {
              for (ca = 0; ca < cal; ca++) {
                value = customAttribute.value[ca];
                customAttribute.array[offset] = value.x;
                customAttribute.array[offset + 1] = value.y;
                customAttribute.array[offset + 2] = value.z;
                offset += 3;
              }
            }
          } else if (customAttribute.size === 4) {
            for (ca = 0; ca < cal; ca++) {
              value = customAttribute.value[ca];
              customAttribute.array[offset] = value.x;
              customAttribute.array[offset + 1] = value.y;
              customAttribute.array[offset + 2] = value.z;
              customAttribute.array[offset + 3] = value.w;
              offset += 4;
            }
          }
          _gl.bindBuffer(_gl.ARRAY_BUFFER, customAttribute.buffer);
          _gl.bufferData(_gl.ARRAY_BUFFER, customAttribute.array, hint);
        }
      }
    }
  }
  ;
  function setRibbonBuffers(geometry, hint) {
    var v, c, n, vertex, offset, color, normal, i, il, ca, cal, customAttribute, value, vertices = geometry.vertices, colors = geometry.colors, normals = geometry.normals, vl = vertices.length, cl = colors.length, nl = normals.length, vertexArray = geometry.__vertexArray, colorArray = geometry.__colorArray, normalArray = geometry.__normalArray, dirtyVertices = geometry.verticesNeedUpdate, dirtyColors = geometry.colorsNeedUpdate, dirtyNormals = geometry.normalsNeedUpdate, customAttributes = geometry.__webglCustomAttributesList;
    if (dirtyVertices) {
      for (v = 0; v < vl; v++) {
        vertex = vertices[v];
        offset = v * 3;
        vertexArray[offset] = vertex.x;
        vertexArray[offset + 1] = vertex.y;
        vertexArray[offset + 2] = vertex.z;
      }
      _gl.bindBuffer(_gl.ARRAY_BUFFER, geometry.__webglVertexBuffer);
      _gl.bufferData(_gl.ARRAY_BUFFER, vertexArray, hint);
    }
    if (dirtyColors) {
      for (c = 0; c < cl; c++) {
        color = colors[c];
        offset = c * 3;
        colorArray[offset] = color.r;
        colorArray[offset + 1] = color.g;
        colorArray[offset + 2] = color.b;
      }
      _gl.bindBuffer(_gl.ARRAY_BUFFER, geometry.__webglColorBuffer);
      _gl.bufferData(_gl.ARRAY_BUFFER, colorArray, hint);
    }
    if (dirtyNormals) {
      for (n = 0; n < nl; n++) {
        normal = normals[n];
        offset = n * 3;
        normalArray[offset] = normal.x;
        normalArray[offset + 1] = normal.y;
        normalArray[offset + 2] = normal.z;
      }
      _gl.bindBuffer(_gl.ARRAY_BUFFER, geometry.__webglNormalBuffer);
      _gl.bufferData(_gl.ARRAY_BUFFER, normalArray, hint);
    }
    if (customAttributes) {
      for (i = 0, il = customAttributes.length; i < il; i++) {
        customAttribute = customAttributes[i];
        if (customAttribute.needsUpdate && (customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices')) {
          offset = 0;
          cal = customAttribute.value.length;
          if (customAttribute.size === 1) {
            for (ca = 0; ca < cal; ca++) {
              customAttribute.array[ca] = customAttribute.value[ca];
            }
          } else if (customAttribute.size === 2) {
            for (ca = 0; ca < cal; ca++) {
              value = customAttribute.value[ca];
              customAttribute.array[offset] = value.x;
              customAttribute.array[offset + 1] = value.y;
              offset += 2;
            }
          } else if (customAttribute.size === 3) {
            if (customAttribute.type === 'c') {
              for (ca = 0; ca < cal; ca++) {
                value = customAttribute.value[ca];
                customAttribute.array[offset] = value.r;
                customAttribute.array[offset + 1] = value.g;
                customAttribute.array[offset + 2] = value.b;
                offset += 3;
              }
            } else {
              for (ca = 0; ca < cal; ca++) {
                value = customAttribute.value[ca];
                customAttribute.array[offset] = value.x;
                customAttribute.array[offset + 1] = value.y;
                customAttribute.array[offset + 2] = value.z;
                offset += 3;
              }
            }
          } else if (customAttribute.size === 4) {
            for (ca = 0; ca < cal; ca++) {
              value = customAttribute.value[ca];
              customAttribute.array[offset] = value.x;
              customAttribute.array[offset + 1] = value.y;
              customAttribute.array[offset + 2] = value.z;
              customAttribute.array[offset + 3] = value.w;
              offset += 4;
            }
          }
          _gl.bindBuffer(_gl.ARRAY_BUFFER, customAttribute.buffer);
          _gl.bufferData(_gl.ARRAY_BUFFER, customAttribute.array, hint);
        }
      }
    }
  }
  ;
  function setMeshBuffers(geometryGroup, object, hint, dispose, material) {
    if (!geometryGroup.__inittedArrays) {
      return;
    }
    var normalType = bufferGuessNormalType(material), vertexColorType = bufferGuessVertexColorType(material), uvType = bufferGuessUVType(material), needsSmoothNormals = normalType === THREE.SmoothShading;
    var f, fl, fi, face, vertexNormals, faceNormal, normal, vertexColors, faceColor, vertexTangents, uv, uv2, v1, v2, v3, v4, t1, t2, t3, t4, n1, n2, n3, n4, c1, c2, c3, c4, sw1, sw2, sw3, sw4, si1, si2, si3, si4, sa1, sa2, sa3, sa4, sb1, sb2, sb3, sb4, m, ml, i, il, vn, uvi, uv2i, vk, vkl, vka, nka, chf, faceVertexNormals, a, vertexIndex = 0, offset = 0, offset_uv = 0, offset_uv2 = 0, offset_face = 0, offset_normal = 0, offset_tangent = 0, offset_line = 0, offset_color = 0, offset_skin = 0, offset_morphTarget = 0, offset_custom = 0, offset_customSrc = 0, value, vertexArray = geometryGroup.__vertexArray, uvArray = geometryGroup.__uvArray, uv2Array = geometryGroup.__uv2Array, normalArray = geometryGroup.__normalArray, tangentArray = geometryGroup.__tangentArray, colorArray = geometryGroup.__colorArray, skinIndexArray = geometryGroup.__skinIndexArray, skinWeightArray = geometryGroup.__skinWeightArray, morphTargetsArrays = geometryGroup.__morphTargetsArrays, morphNormalsArrays = geometryGroup.__morphNormalsArrays, customAttributes = geometryGroup.__webglCustomAttributesList, customAttribute, faceArray = geometryGroup.__faceArray, lineArray = geometryGroup.__lineArray, geometry = object.geometry, dirtyVertices = geometry.verticesNeedUpdate, dirtyElements = geometry.elementsNeedUpdate, dirtyUvs = geometry.uvsNeedUpdate, dirtyNormals = geometry.normalsNeedUpdate, dirtyTangents = geometry.tangentsNeedUpdate, dirtyColors = geometry.colorsNeedUpdate, dirtyMorphTargets = geometry.morphTargetsNeedUpdate, vertices = geometry.vertices, chunk_faces3 = geometryGroup.faces3, obj_faces = geometry.faces, obj_uvs = geometry.faceVertexUvs[0], obj_uvs2 = geometry.faceVertexUvs[1], obj_colors = geometry.colors, obj_skinIndices = geometry.skinIndices, obj_skinWeights = geometry.skinWeights, morphTargets = geometry.morphTargets, morphNormals = geometry.morphNormals;
    if (dirtyVertices) {
      for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
        face = obj_faces[chunk_faces3[f]];
        v1 = vertices[face.a];
        v2 = vertices[face.b];
        v3 = vertices[face.c];
        vertexArray[offset] = v1.x;
        vertexArray[offset + 1] = v1.y;
        vertexArray[offset + 2] = v1.z;
        vertexArray[offset + 3] = v2.x;
        vertexArray[offset + 4] = v2.y;
        vertexArray[offset + 5] = v2.z;
        vertexArray[offset + 6] = v3.x;
        vertexArray[offset + 7] = v3.y;
        vertexArray[offset + 8] = v3.z;
        offset += 9;
      }
      _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer);
      _gl.bufferData(_gl.ARRAY_BUFFER, vertexArray, hint);
    }
    if (dirtyMorphTargets) {
      for (vk = 0, vkl = morphTargets.length; vk < vkl; vk++) {
        offset_morphTarget = 0;
        for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
          chf = chunk_faces3[f];
          face = obj_faces[chf];
          v1 = morphTargets[vk].vertices[face.a];
          v2 = morphTargets[vk].vertices[face.b];
          v3 = morphTargets[vk].vertices[face.c];
          vka = morphTargetsArrays[vk];
          vka[offset_morphTarget] = v1.x;
          vka[offset_morphTarget + 1] = v1.y;
          vka[offset_morphTarget + 2] = v1.z;
          vka[offset_morphTarget + 3] = v2.x;
          vka[offset_morphTarget + 4] = v2.y;
          vka[offset_morphTarget + 5] = v2.z;
          vka[offset_morphTarget + 6] = v3.x;
          vka[offset_morphTarget + 7] = v3.y;
          vka[offset_morphTarget + 8] = v3.z;
          if (material.morphNormals) {
            if (needsSmoothNormals) {
              faceVertexNormals = morphNormals[vk].vertexNormals[chf];
              n1 = faceVertexNormals.a;
              n2 = faceVertexNormals.b;
              n3 = faceVertexNormals.c;
            } else {
              n1 = morphNormals[vk].faceNormals[chf];
              n2 = n1;
              n3 = n1;
            }
            nka = morphNormalsArrays[vk];
            nka[offset_morphTarget] = n1.x;
            nka[offset_morphTarget + 1] = n1.y;
            nka[offset_morphTarget + 2] = n1.z;
            nka[offset_morphTarget + 3] = n2.x;
            nka[offset_morphTarget + 4] = n2.y;
            nka[offset_morphTarget + 5] = n2.z;
            nka[offset_morphTarget + 6] = n3.x;
            nka[offset_morphTarget + 7] = n3.y;
            nka[offset_morphTarget + 8] = n3.z;
          }
          offset_morphTarget += 9;
        }
        _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[vk]);
        _gl.bufferData(_gl.ARRAY_BUFFER, morphTargetsArrays[vk], hint);
        if (material.morphNormals) {
          _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[vk]);
          _gl.bufferData(_gl.ARRAY_BUFFER, morphNormalsArrays[vk], hint);
        }
      }
    }
    if (obj_skinWeights.length) {
      for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
        face = obj_faces[chunk_faces3[f]];
        sw1 = obj_skinWeights[face.a];
        sw2 = obj_skinWeights[face.b];
        sw3 = obj_skinWeights[face.c];
        skinWeightArray[offset_skin] = sw1.x;
        skinWeightArray[offset_skin + 1] = sw1.y;
        skinWeightArray[offset_skin + 2] = sw1.z;
        skinWeightArray[offset_skin + 3] = sw1.w;
        skinWeightArray[offset_skin + 4] = sw2.x;
        skinWeightArray[offset_skin + 5] = sw2.y;
        skinWeightArray[offset_skin + 6] = sw2.z;
        skinWeightArray[offset_skin + 7] = sw2.w;
        skinWeightArray[offset_skin + 8] = sw3.x;
        skinWeightArray[offset_skin + 9] = sw3.y;
        skinWeightArray[offset_skin + 10] = sw3.z;
        skinWeightArray[offset_skin + 11] = sw3.w;
        si1 = obj_skinIndices[face.a];
        si2 = obj_skinIndices[face.b];
        si3 = obj_skinIndices[face.c];
        skinIndexArray[offset_skin] = si1.x;
        skinIndexArray[offset_skin + 1] = si1.y;
        skinIndexArray[offset_skin + 2] = si1.z;
        skinIndexArray[offset_skin + 3] = si1.w;
        skinIndexArray[offset_skin + 4] = si2.x;
        skinIndexArray[offset_skin + 5] = si2.y;
        skinIndexArray[offset_skin + 6] = si2.z;
        skinIndexArray[offset_skin + 7] = si2.w;
        skinIndexArray[offset_skin + 8] = si3.x;
        skinIndexArray[offset_skin + 9] = si3.y;
        skinIndexArray[offset_skin + 10] = si3.z;
        skinIndexArray[offset_skin + 11] = si3.w;
        offset_skin += 12;
      }
      if (offset_skin > 0) {
        _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglSkinIndicesBuffer);
        _gl.bufferData(_gl.ARRAY_BUFFER, skinIndexArray, hint);
        _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglSkinWeightsBuffer);
        _gl.bufferData(_gl.ARRAY_BUFFER, skinWeightArray, hint);
      }
    }
    if (dirtyColors && vertexColorType) {
      for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
        face = obj_faces[chunk_faces3[f]];
        vertexColors = face.vertexColors;
        faceColor = face.color;
        if (vertexColors.length === 3 && vertexColorType === THREE.VertexColors) {
          c1 = vertexColors[0];
          c2 = vertexColors[1];
          c3 = vertexColors[2];
        } else {
          c1 = faceColor;
          c2 = faceColor;
          c3 = faceColor;
        }
        colorArray[offset_color] = c1.r;
        colorArray[offset_color + 1] = c1.g;
        colorArray[offset_color + 2] = c1.b;
        colorArray[offset_color + 3] = c2.r;
        colorArray[offset_color + 4] = c2.g;
        colorArray[offset_color + 5] = c2.b;
        colorArray[offset_color + 6] = c3.r;
        colorArray[offset_color + 7] = c3.g;
        colorArray[offset_color + 8] = c3.b;
        offset_color += 9;
      }
      if (offset_color > 0) {
        _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer);
        _gl.bufferData(_gl.ARRAY_BUFFER, colorArray, hint);
      }
    }
    if (dirtyTangents && geometry.hasTangents) {
      for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
        face = obj_faces[chunk_faces3[f]];
        vertexTangents = face.vertexTangents;
        t1 = vertexTangents[0];
        t2 = vertexTangents[1];
        t3 = vertexTangents[2];
        tangentArray[offset_tangent] = t1.x;
        tangentArray[offset_tangent + 1] = t1.y;
        tangentArray[offset_tangent + 2] = t1.z;
        tangentArray[offset_tangent + 3] = t1.w;
        tangentArray[offset_tangent + 4] = t2.x;
        tangentArray[offset_tangent + 5] = t2.y;
        tangentArray[offset_tangent + 6] = t2.z;
        tangentArray[offset_tangent + 7] = t2.w;
        tangentArray[offset_tangent + 8] = t3.x;
        tangentArray[offset_tangent + 9] = t3.y;
        tangentArray[offset_tangent + 10] = t3.z;
        tangentArray[offset_tangent + 11] = t3.w;
        offset_tangent += 12;
      }
      _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglTangentBuffer);
      _gl.bufferData(_gl.ARRAY_BUFFER, tangentArray, hint);
    }
    if (dirtyNormals && normalType) {
      for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
        face = obj_faces[chunk_faces3[f]];
        vertexNormals = face.vertexNormals;
        faceNormal = face.normal;
        if (vertexNormals.length === 3 && needsSmoothNormals) {
          for (i = 0; i < 3; i++) {
            vn = vertexNormals[i];
            normalArray[offset_normal] = vn.x;
            normalArray[offset_normal + 1] = vn.y;
            normalArray[offset_normal + 2] = vn.z;
            offset_normal += 3;
          }
        } else {
          for (i = 0; i < 3; i++) {
            normalArray[offset_normal] = faceNormal.x;
            normalArray[offset_normal + 1] = faceNormal.y;
            normalArray[offset_normal + 2] = faceNormal.z;
            offset_normal += 3;
          }
        }
      }
      _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer);
      _gl.bufferData(_gl.ARRAY_BUFFER, normalArray, hint);
    }
    if (dirtyUvs && obj_uvs && uvType) {
      for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
        fi = chunk_faces3[f];
        uv = obj_uvs[fi];
        if (uv === undefined)
          continue;
        for (i = 0; i < 3; i++) {
          uvi = uv[i];
          uvArray[offset_uv] = uvi.x;
          uvArray[offset_uv + 1] = uvi.y;
          offset_uv += 2;
        }
      }
      if (offset_uv > 0) {
        _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglUVBuffer);
        _gl.bufferData(_gl.ARRAY_BUFFER, uvArray, hint);
      }
    }
    if (dirtyUvs && obj_uvs2 && uvType) {
      for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
        fi = chunk_faces3[f];
        uv2 = obj_uvs2[fi];
        if (uv2 === undefined)
          continue;
        for (i = 0; i < 3; i++) {
          uv2i = uv2[i];
          uv2Array[offset_uv2] = uv2i.x;
          uv2Array[offset_uv2 + 1] = uv2i.y;
          offset_uv2 += 2;
        }
      }
      if (offset_uv2 > 0) {
        _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglUV2Buffer);
        _gl.bufferData(_gl.ARRAY_BUFFER, uv2Array, hint);
      }
    }
    if (dirtyElements) {
      for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
        faceArray[offset_face] = vertexIndex;
        faceArray[offset_face + 1] = vertexIndex + 1;
        faceArray[offset_face + 2] = vertexIndex + 2;
        offset_face += 3;
        lineArray[offset_line] = vertexIndex;
        lineArray[offset_line + 1] = vertexIndex + 1;
        lineArray[offset_line + 2] = vertexIndex;
        lineArray[offset_line + 3] = vertexIndex + 2;
        lineArray[offset_line + 4] = vertexIndex + 1;
        lineArray[offset_line + 5] = vertexIndex + 2;
        offset_line += 6;
        vertexIndex += 3;
      }
      _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer);
      _gl.bufferData(_gl.ELEMENT_ARRAY_BUFFER, faceArray, hint);
      _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer);
      _gl.bufferData(_gl.ELEMENT_ARRAY_BUFFER, lineArray, hint);
    }
    if (customAttributes) {
      for (i = 0, il = customAttributes.length; i < il; i++) {
        customAttribute = customAttributes[i];
        if (!customAttribute.__original.needsUpdate)
          continue;
        offset_custom = 0;
        offset_customSrc = 0;
        if (customAttribute.size === 1) {
          if (customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices') {
            for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
              face = obj_faces[chunk_faces3[f]];
              customAttribute.array[offset_custom] = customAttribute.value[face.a];
              customAttribute.array[offset_custom + 1] = customAttribute.value[face.b];
              customAttribute.array[offset_custom + 2] = customAttribute.value[face.c];
              offset_custom += 3;
            }
          } else if (customAttribute.boundTo === 'faces') {
            for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
              value = customAttribute.value[chunk_faces3[f]];
              customAttribute.array[offset_custom] = value;
              customAttribute.array[offset_custom + 1] = value;
              customAttribute.array[offset_custom + 2] = value;
              offset_custom += 3;
            }
          }
        } else if (customAttribute.size === 2) {
          if (customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices') {
            for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
              face = obj_faces[chunk_faces3[f]];
              v1 = customAttribute.value[face.a];
              v2 = customAttribute.value[face.b];
              v3 = customAttribute.value[face.c];
              customAttribute.array[offset_custom] = v1.x;
              customAttribute.array[offset_custom + 1] = v1.y;
              customAttribute.array[offset_custom + 2] = v2.x;
              customAttribute.array[offset_custom + 3] = v2.y;
              customAttribute.array[offset_custom + 4] = v3.x;
              customAttribute.array[offset_custom + 5] = v3.y;
              offset_custom += 6;
            }
          } else if (customAttribute.boundTo === 'faces') {
            for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
              value = customAttribute.value[chunk_faces3[f]];
              v1 = value;
              v2 = value;
              v3 = value;
              customAttribute.array[offset_custom] = v1.x;
              customAttribute.array[offset_custom + 1] = v1.y;
              customAttribute.array[offset_custom + 2] = v2.x;
              customAttribute.array[offset_custom + 3] = v2.y;
              customAttribute.array[offset_custom + 4] = v3.x;
              customAttribute.array[offset_custom + 5] = v3.y;
              offset_custom += 6;
            }
          }
        } else if (customAttribute.size === 3) {
          var pp;
          if (customAttribute.type === 'c') {
            pp = [
              'r',
              'g',
              'b'
            ];
          } else {
            pp = [
              'x',
              'y',
              'z'
            ];
          }
          if (customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices') {
            for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
              face = obj_faces[chunk_faces3[f]];
              v1 = customAttribute.value[face.a];
              v2 = customAttribute.value[face.b];
              v3 = customAttribute.value[face.c];
              customAttribute.array[offset_custom] = v1[pp[0]];
              customAttribute.array[offset_custom + 1] = v1[pp[1]];
              customAttribute.array[offset_custom + 2] = v1[pp[2]];
              customAttribute.array[offset_custom + 3] = v2[pp[0]];
              customAttribute.array[offset_custom + 4] = v2[pp[1]];
              customAttribute.array[offset_custom + 5] = v2[pp[2]];
              customAttribute.array[offset_custom + 6] = v3[pp[0]];
              customAttribute.array[offset_custom + 7] = v3[pp[1]];
              customAttribute.array[offset_custom + 8] = v3[pp[2]];
              offset_custom += 9;
            }
          } else if (customAttribute.boundTo === 'faces') {
            for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
              value = customAttribute.value[chunk_faces3[f]];
              v1 = value;
              v2 = value;
              v3 = value;
              customAttribute.array[offset_custom] = v1[pp[0]];
              customAttribute.array[offset_custom + 1] = v1[pp[1]];
              customAttribute.array[offset_custom + 2] = v1[pp[2]];
              customAttribute.array[offset_custom + 3] = v2[pp[0]];
              customAttribute.array[offset_custom + 4] = v2[pp[1]];
              customAttribute.array[offset_custom + 5] = v2[pp[2]];
              customAttribute.array[offset_custom + 6] = v3[pp[0]];
              customAttribute.array[offset_custom + 7] = v3[pp[1]];
              customAttribute.array[offset_custom + 8] = v3[pp[2]];
              offset_custom += 9;
            }
          } else if (customAttribute.boundTo === 'faceVertices') {
            for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
              value = customAttribute.value[chunk_faces3[f]];
              v1 = value[0];
              v2 = value[1];
              v3 = value[2];
              customAttribute.array[offset_custom] = v1[pp[0]];
              customAttribute.array[offset_custom + 1] = v1[pp[1]];
              customAttribute.array[offset_custom + 2] = v1[pp[2]];
              customAttribute.array[offset_custom + 3] = v2[pp[0]];
              customAttribute.array[offset_custom + 4] = v2[pp[1]];
              customAttribute.array[offset_custom + 5] = v2[pp[2]];
              customAttribute.array[offset_custom + 6] = v3[pp[0]];
              customAttribute.array[offset_custom + 7] = v3[pp[1]];
              customAttribute.array[offset_custom + 8] = v3[pp[2]];
              offset_custom += 9;
            }
          }
        } else if (customAttribute.size === 4) {
          if (customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices') {
            for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
              face = obj_faces[chunk_faces3[f]];
              v1 = customAttribute.value[face.a];
              v2 = customAttribute.value[face.b];
              v3 = customAttribute.value[face.c];
              customAttribute.array[offset_custom] = v1.x;
              customAttribute.array[offset_custom + 1] = v1.y;
              customAttribute.array[offset_custom + 2] = v1.z;
              customAttribute.array[offset_custom + 3] = v1.w;
              customAttribute.array[offset_custom + 4] = v2.x;
              customAttribute.array[offset_custom + 5] = v2.y;
              customAttribute.array[offset_custom + 6] = v2.z;
              customAttribute.array[offset_custom + 7] = v2.w;
              customAttribute.array[offset_custom + 8] = v3.x;
              customAttribute.array[offset_custom + 9] = v3.y;
              customAttribute.array[offset_custom + 10] = v3.z;
              customAttribute.array[offset_custom + 11] = v3.w;
              offset_custom += 12;
            }
          } else if (customAttribute.boundTo === 'faces') {
            for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
              value = customAttribute.value[chunk_faces3[f]];
              v1 = value;
              v2 = value;
              v3 = value;
              customAttribute.array[offset_custom] = v1.x;
              customAttribute.array[offset_custom + 1] = v1.y;
              customAttribute.array[offset_custom + 2] = v1.z;
              customAttribute.array[offset_custom + 3] = v1.w;
              customAttribute.array[offset_custom + 4] = v2.x;
              customAttribute.array[offset_custom + 5] = v2.y;
              customAttribute.array[offset_custom + 6] = v2.z;
              customAttribute.array[offset_custom + 7] = v2.w;
              customAttribute.array[offset_custom + 8] = v3.x;
              customAttribute.array[offset_custom + 9] = v3.y;
              customAttribute.array[offset_custom + 10] = v3.z;
              customAttribute.array[offset_custom + 11] = v3.w;
              offset_custom += 12;
            }
          } else if (customAttribute.boundTo === 'faceVertices') {
            for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
              value = customAttribute.value[chunk_faces3[f]];
              v1 = value[0];
              v2 = value[1];
              v3 = value[2];
              customAttribute.array[offset_custom] = v1.x;
              customAttribute.array[offset_custom + 1] = v1.y;
              customAttribute.array[offset_custom + 2] = v1.z;
              customAttribute.array[offset_custom + 3] = v1.w;
              customAttribute.array[offset_custom + 4] = v2.x;
              customAttribute.array[offset_custom + 5] = v2.y;
              customAttribute.array[offset_custom + 6] = v2.z;
              customAttribute.array[offset_custom + 7] = v2.w;
              customAttribute.array[offset_custom + 8] = v3.x;
              customAttribute.array[offset_custom + 9] = v3.y;
              customAttribute.array[offset_custom + 10] = v3.z;
              customAttribute.array[offset_custom + 11] = v3.w;
              offset_custom += 12;
            }
          }
        }
        _gl.bindBuffer(_gl.ARRAY_BUFFER, customAttribute.buffer);
        _gl.bufferData(_gl.ARRAY_BUFFER, customAttribute.array, hint);
      }
    }
    if (dispose) {
      delete geometryGroup.__inittedArrays;
      delete geometryGroup.__colorArray;
      delete geometryGroup.__normalArray;
      delete geometryGroup.__tangentArray;
      delete geometryGroup.__uvArray;
      delete geometryGroup.__uv2Array;
      delete geometryGroup.__faceArray;
      delete geometryGroup.__vertexArray;
      delete geometryGroup.__lineArray;
      delete geometryGroup.__skinIndexArray;
      delete geometryGroup.__skinWeightArray;
    }
  }
  ;
  function setDirectBuffers(geometry, hint, dispose) {
    var attributes = geometry.attributes;
    var attributeName, attributeItem;
    for (attributeName in attributes) {
      attributeItem = attributes[attributeName];
      if (attributeItem.needsUpdate) {
        if (attributeName === 'index') {
          _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, attributeItem.buffer);
          _gl.bufferData(_gl.ELEMENT_ARRAY_BUFFER, attributeItem.array, hint);
        } else {
          _gl.bindBuffer(_gl.ARRAY_BUFFER, attributeItem.buffer);
          _gl.bufferData(_gl.ARRAY_BUFFER, attributeItem.array, hint);
        }
        attributeItem.needsUpdate = false;
      }
      if (dispose && !attributeItem.dynamic) {
        attributeItem.array = null;
      }
    }
  }
  ;
  this.renderBufferImmediate = function (object, program, material) {
    if (object.hasPositions && !object.__webglVertexBuffer)
      object.__webglVertexBuffer = _gl.createBuffer();
    if (object.hasNormals && !object.__webglNormalBuffer)
      object.__webglNormalBuffer = _gl.createBuffer();
    if (object.hasUvs && !object.__webglUvBuffer)
      object.__webglUvBuffer = _gl.createBuffer();
    if (object.hasColors && !object.__webglColorBuffer)
      object.__webglColorBuffer = _gl.createBuffer();
    if (object.hasPositions) {
      _gl.bindBuffer(_gl.ARRAY_BUFFER, object.__webglVertexBuffer);
      _gl.bufferData(_gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW);
      _gl.enableVertexAttribArray(program.attributes.position);
      _gl.vertexAttribPointer(program.attributes.position, 3, _gl.FLOAT, false, 0, 0);
    }
    if (object.hasNormals) {
      _gl.bindBuffer(_gl.ARRAY_BUFFER, object.__webglNormalBuffer);
      if (material.shading === THREE.FlatShading) {
        var nx, ny, nz, nax, nbx, ncx, nay, nby, ncy, naz, nbz, ncz, normalArray, i, il = object.count * 3;
        for (i = 0; i < il; i += 9) {
          normalArray = object.normalArray;
          nax = normalArray[i];
          nay = normalArray[i + 1];
          naz = normalArray[i + 2];
          nbx = normalArray[i + 3];
          nby = normalArray[i + 4];
          nbz = normalArray[i + 5];
          ncx = normalArray[i + 6];
          ncy = normalArray[i + 7];
          ncz = normalArray[i + 8];
          nx = (nax + nbx + ncx) / 3;
          ny = (nay + nby + ncy) / 3;
          nz = (naz + nbz + ncz) / 3;
          normalArray[i] = nx;
          normalArray[i + 1] = ny;
          normalArray[i + 2] = nz;
          normalArray[i + 3] = nx;
          normalArray[i + 4] = ny;
          normalArray[i + 5] = nz;
          normalArray[i + 6] = nx;
          normalArray[i + 7] = ny;
          normalArray[i + 8] = nz;
        }
      }
      _gl.bufferData(_gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW);
      _gl.enableVertexAttribArray(program.attributes.normal);
      _gl.vertexAttribPointer(program.attributes.normal, 3, _gl.FLOAT, false, 0, 0);
    }
    if (object.hasUvs && material.map) {
      _gl.bindBuffer(_gl.ARRAY_BUFFER, object.__webglUvBuffer);
      _gl.bufferData(_gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW);
      _gl.enableVertexAttribArray(program.attributes.uv);
      _gl.vertexAttribPointer(program.attributes.uv, 2, _gl.FLOAT, false, 0, 0);
    }
    if (object.hasColors && material.vertexColors !== THREE.NoColors) {
      _gl.bindBuffer(_gl.ARRAY_BUFFER, object.__webglColorBuffer);
      _gl.bufferData(_gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW);
      _gl.enableVertexAttribArray(program.attributes.color);
      _gl.vertexAttribPointer(program.attributes.color, 3, _gl.FLOAT, false, 0, 0);
    }
    _gl.drawArrays(_gl.TRIANGLES, 0, object.count);
    object.count = 0;
  };
  this.renderBufferDirect = function (camera, lights, fog, material, geometry, object) {
    if (material.visible === false)
      return;
    var linewidth, a, attribute;
    var attributeItem, attributeName, attributePointer, attributeSize;
    var program = setProgram(camera, lights, fog, material, object);
    var programAttributes = program.attributes;
    var geometryAttributes = geometry.attributes;
    var updateBuffers = false, wireframeBit = material.wireframe ? 1 : 0, geometryHash = geometry.id * 16777215 + program.id * 2 + wireframeBit;
    if (geometryHash !== _currentGeometryGroupHash) {
      _currentGeometryGroupHash = geometryHash;
      updateBuffers = true;
    }
    if (updateBuffers) {
      disableAttributes();
    }
    if (object instanceof THREE.Mesh) {
      var index = geometryAttributes['index'];
      if (index) {
        var offsets = geometry.offsets;
        if (offsets.length > 1)
          updateBuffers = true;
        for (var i = 0, il = offsets.length; i < il; i++) {
          var startIndex = offsets[i].index;
          if (updateBuffers) {
            for (attributeName in programAttributes) {
              attributePointer = programAttributes[attributeName];
              attributeItem = geometryAttributes[attributeName];
              if (attributePointer >= 0) {
                if (attributeItem) {
                  attributeSize = attributeItem.itemSize;
                  _gl.bindBuffer(_gl.ARRAY_BUFFER, attributeItem.buffer);
                  enableAttribute(attributePointer);
                  _gl.vertexAttribPointer(attributePointer, attributeSize, _gl.FLOAT, false, 0, startIndex * attributeSize * 4);
                } else if (material.defaultAttributeValues) {
                  if (material.defaultAttributeValues[attributeName].length === 2) {
                    _gl.vertexAttrib2fv(attributePointer, material.defaultAttributeValues[attributeName]);
                  } else if (material.defaultAttributeValues[attributeName].length === 3) {
                    _gl.vertexAttrib3fv(attributePointer, material.defaultAttributeValues[attributeName]);
                  }
                }
              }
            }
            _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, index.buffer);
          }
          _gl.drawElements(_gl.TRIANGLES, offsets[i].count, _gl.UNSIGNED_SHORT, offsets[i].start * 2);
          _this.info.render.calls++;
          _this.info.render.vertices += offsets[i].count;
          _this.info.render.faces += offsets[i].count / 3;
        }
      } else {
        if (updateBuffers) {
          for (attributeName in programAttributes) {
            if (attributeName === 'index')
              continue;
            attributePointer = programAttributes[attributeName];
            attributeItem = geometryAttributes[attributeName];
            if (attributePointer >= 0) {
              if (attributeItem) {
                attributeSize = attributeItem.itemSize;
                _gl.bindBuffer(_gl.ARRAY_BUFFER, attributeItem.buffer);
                enableAttribute(attributePointer);
                _gl.vertexAttribPointer(attributePointer, attributeSize, _gl.FLOAT, false, 0, 0);
              } else if (material.defaultAttributeValues && material.defaultAttributeValues[attributeName]) {
                if (material.defaultAttributeValues[attributeName].length === 2) {
                  _gl.vertexAttrib2fv(attributePointer, material.defaultAttributeValues[attributeName]);
                } else if (material.defaultAttributeValues[attributeName].length === 3) {
                  _gl.vertexAttrib3fv(attributePointer, material.defaultAttributeValues[attributeName]);
                }
              }
            }
          }
        }
        var position = geometry.attributes['position'];
        _gl.drawArrays(_gl.TRIANGLES, 0, position.numItems / 3);
        _this.info.render.calls++;
        _this.info.render.vertices += position.numItems / 3;
        _this.info.render.faces += position.numItems / 3 / 3;
      }
    } else if (object instanceof THREE.ParticleSystem) {
      if (updateBuffers) {
        for (attributeName in programAttributes) {
          attributePointer = programAttributes[attributeName];
          attributeItem = geometryAttributes[attributeName];
          if (attributePointer >= 0) {
            if (attributeItem) {
              attributeSize = attributeItem.itemSize;
              _gl.bindBuffer(_gl.ARRAY_BUFFER, attributeItem.buffer);
              enableAttribute(attributePointer);
              _gl.vertexAttribPointer(attributePointer, attributeSize, _gl.FLOAT, false, 0, 0);
            } else if (material.defaultAttributeValues && material.defaultAttributeValues[attributeName]) {
              if (material.defaultAttributeValues[attributeName].length === 2) {
                _gl.vertexAttrib2fv(attributePointer, material.defaultAttributeValues[attributeName]);
              } else if (material.defaultAttributeValues[attributeName].length === 3) {
                _gl.vertexAttrib3fv(attributePointer, material.defaultAttributeValues[attributeName]);
              }
            }
          }
        }
        var position = geometryAttributes['position'];
        _gl.drawArrays(_gl.POINTS, 0, position.numItems / 3);
        _this.info.render.calls++;
        _this.info.render.points += position.numItems / 3;
      }
    } else if (object instanceof THREE.Line) {
      if (updateBuffers) {
        for (attributeName in programAttributes) {
          attributePointer = programAttributes[attributeName];
          attributeItem = geometryAttributes[attributeName];
          if (attributePointer >= 0) {
            if (attributeItem) {
              attributeSize = attributeItem.itemSize;
              _gl.bindBuffer(_gl.ARRAY_BUFFER, attributeItem.buffer);
              enableAttribute(attributePointer);
              _gl.vertexAttribPointer(attributePointer, attributeSize, _gl.FLOAT, false, 0, 0);
            } else if (material.defaultAttributeValues && material.defaultAttributeValues[attributeName]) {
              if (material.defaultAttributeValues[attributeName].length === 2) {
                _gl.vertexAttrib2fv(attributePointer, material.defaultAttributeValues[attributeName]);
              } else if (material.defaultAttributeValues[attributeName].length === 3) {
                _gl.vertexAttrib3fv(attributePointer, material.defaultAttributeValues[attributeName]);
              }
            }
          }
        }
        var primitives = object.type === THREE.LineStrip ? _gl.LINE_STRIP : _gl.LINES;
        setLineWidth(material.linewidth);
        var position = geometryAttributes['position'];
        _gl.drawArrays(primitives, 0, position.numItems / 3);
        _this.info.render.calls++;
        _this.info.render.points += position.numItems;
      }
    }
  };
  this.renderBuffer = function (camera, lights, fog, material, geometryGroup, object) {
    if (material.visible === false)
      return;
    var linewidth, a, attribute, i, il;
    var program = setProgram(camera, lights, fog, material, object);
    var attributes = program.attributes;
    var updateBuffers = false, wireframeBit = material.wireframe ? 1 : 0, geometryGroupHash = geometryGroup.id * 16777215 + program.id * 2 + wireframeBit;
    if (geometryGroupHash !== _currentGeometryGroupHash) {
      _currentGeometryGroupHash = geometryGroupHash;
      updateBuffers = true;
    }
    if (updateBuffers) {
      disableAttributes();
    }
    if (!material.morphTargets && attributes.position >= 0) {
      if (updateBuffers) {
        _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer);
        enableAttribute(attributes.position);
        _gl.vertexAttribPointer(attributes.position, 3, _gl.FLOAT, false, 0, 0);
      }
    } else {
      if (object.morphTargetBase) {
        setupMorphTargets(material, geometryGroup, object);
      }
    }
    if (updateBuffers) {
      if (geometryGroup.__webglCustomAttributesList) {
        for (i = 0, il = geometryGroup.__webglCustomAttributesList.length; i < il; i++) {
          attribute = geometryGroup.__webglCustomAttributesList[i];
          if (attributes[attribute.buffer.belongsToAttribute] >= 0) {
            _gl.bindBuffer(_gl.ARRAY_BUFFER, attribute.buffer);
            enableAttribute(attributes[attribute.buffer.belongsToAttribute]);
            _gl.vertexAttribPointer(attributes[attribute.buffer.belongsToAttribute], attribute.size, _gl.FLOAT, false, 0, 0);
          }
        }
      }
      if (attributes.color >= 0) {
        if (object.geometry.colors.length > 0 || object.geometry.faces.length > 0) {
          _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer);
          enableAttribute(attributes.color);
          _gl.vertexAttribPointer(attributes.color, 3, _gl.FLOAT, false, 0, 0);
        } else if (material.defaultAttributeValues) {
          _gl.vertexAttrib3fv(attributes.color, material.defaultAttributeValues.color);
        }
      }
      if (attributes.normal >= 0) {
        _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer);
        enableAttribute(attributes.normal);
        _gl.vertexAttribPointer(attributes.normal, 3, _gl.FLOAT, false, 0, 0);
      }
      if (attributes.tangent >= 0) {
        _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglTangentBuffer);
        enableAttribute(attributes.tangent);
        _gl.vertexAttribPointer(attributes.tangent, 4, _gl.FLOAT, false, 0, 0);
      }
      if (attributes.uv >= 0) {
        if (object.geometry.faceVertexUvs[0]) {
          _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglUVBuffer);
          enableAttribute(attributes.uv);
          _gl.vertexAttribPointer(attributes.uv, 2, _gl.FLOAT, false, 0, 0);
        } else if (material.defaultAttributeValues) {
          _gl.vertexAttrib2fv(attributes.uv, material.defaultAttributeValues.uv);
        }
      }
      if (attributes.uv2 >= 0) {
        if (object.geometry.faceVertexUvs[1]) {
          _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglUV2Buffer);
          enableAttribute(attributes.uv2);
          _gl.vertexAttribPointer(attributes.uv2, 2, _gl.FLOAT, false, 0, 0);
        } else if (material.defaultAttributeValues) {
          _gl.vertexAttrib2fv(attributes.uv2, material.defaultAttributeValues.uv2);
        }
      }
      if (material.skinning && attributes.skinIndex >= 0 && attributes.skinWeight >= 0) {
        _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglSkinIndicesBuffer);
        enableAttribute(attributes.skinIndex);
        _gl.vertexAttribPointer(attributes.skinIndex, 4, _gl.FLOAT, false, 0, 0);
        _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglSkinWeightsBuffer);
        enableAttribute(attributes.skinWeight);
        _gl.vertexAttribPointer(attributes.skinWeight, 4, _gl.FLOAT, false, 0, 0);
      }
      if (attributes.lineDistance >= 0) {
        _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglLineDistanceBuffer);
        enableAttribute(attributes.lineDistance);
        _gl.vertexAttribPointer(attributes.lineDistance, 1, _gl.FLOAT, false, 0, 0);
      }
    }
    if (object instanceof THREE.Mesh) {
      if (material.wireframe) {
        setLineWidth(material.wireframeLinewidth);
        if (updateBuffers)
          _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer);
        _gl.drawElements(_gl.LINES, geometryGroup.__webglLineCount, _gl.UNSIGNED_SHORT, 0);
      } else {
        if (updateBuffers)
          _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer);
        _gl.drawElements(_gl.TRIANGLES, geometryGroup.__webglFaceCount, _gl.UNSIGNED_SHORT, 0);
      }
      _this.info.render.calls++;
      _this.info.render.vertices += geometryGroup.__webglFaceCount;
      _this.info.render.faces += geometryGroup.__webglFaceCount / 3;
    } else if (object instanceof THREE.Line) {
      var primitives = object.type === THREE.LineStrip ? _gl.LINE_STRIP : _gl.LINES;
      setLineWidth(material.linewidth);
      _gl.drawArrays(primitives, 0, geometryGroup.__webglLineCount);
      _this.info.render.calls++;
    } else if (object instanceof THREE.ParticleSystem) {
      _gl.drawArrays(_gl.POINTS, 0, geometryGroup.__webglParticleCount);
      _this.info.render.calls++;
      _this.info.render.points += geometryGroup.__webglParticleCount;
    } else if (object instanceof THREE.Ribbon) {
      _gl.drawArrays(_gl.TRIANGLE_STRIP, 0, geometryGroup.__webglVertexCount);
      _this.info.render.calls++;
    }
  };
  function enableAttribute(attribute) {
    if (!_enabledAttributes[attribute]) {
      _gl.enableVertexAttribArray(attribute);
      _enabledAttributes[attribute] = true;
    }
  }
  ;
  function disableAttributes() {
    for (var attribute in _enabledAttributes) {
      if (_enabledAttributes[attribute]) {
        _gl.disableVertexAttribArray(attribute);
        _enabledAttributes[attribute] = false;
      }
    }
  }
  ;
  function setupMorphTargets(material, geometryGroup, object) {
    var attributes = material.program.attributes;
    if (object.morphTargetBase !== -1 && attributes.position >= 0) {
      _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[object.morphTargetBase]);
      enableAttribute(attributes.position);
      _gl.vertexAttribPointer(attributes.position, 3, _gl.FLOAT, false, 0, 0);
    } else if (attributes.position >= 0) {
      _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer);
      enableAttribute(attributes.position);
      _gl.vertexAttribPointer(attributes.position, 3, _gl.FLOAT, false, 0, 0);
    }
    if (object.morphTargetForcedOrder.length) {
      var m = 0;
      var order = object.morphTargetForcedOrder;
      var influences = object.morphTargetInfluences;
      while (m < material.numSupportedMorphTargets && m < order.length) {
        if (attributes['morphTarget' + m] >= 0) {
          _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[order[m]]);
          enableAttribute(attributes['morphTarget' + m]);
          _gl.vertexAttribPointer(attributes['morphTarget' + m], 3, _gl.FLOAT, false, 0, 0);
        }
        if (attributes['morphNormal' + m] >= 0 && material.morphNormals) {
          _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[order[m]]);
          enableAttribute(attributes['morphNormal' + m]);
          _gl.vertexAttribPointer(attributes['morphNormal' + m], 3, _gl.FLOAT, false, 0, 0);
        }
        object.__webglMorphTargetInfluences[m] = influences[order[m]];
        m++;
      }
    } else {
      var influence, activeInfluenceIndices = [];
      var influences = object.morphTargetInfluences;
      var i, il = influences.length;
      for (i = 0; i < il; i++) {
        influence = influences[i];
        if (influence > 0) {
          activeInfluenceIndices.push([
            influence,
            i
          ]);
        }
      }
      if (activeInfluenceIndices.length > material.numSupportedMorphTargets) {
        activeInfluenceIndices.sort(numericalSort);
        activeInfluenceIndices.length = material.numSupportedMorphTargets;
      } else if (activeInfluenceIndices.length > material.numSupportedMorphNormals) {
        activeInfluenceIndices.sort(numericalSort);
      } else if (activeInfluenceIndices.length === 0) {
        activeInfluenceIndices.push([
          0,
          0
        ]);
      }
      ;
      var influenceIndex, m = 0;
      while (m < material.numSupportedMorphTargets) {
        if (activeInfluenceIndices[m]) {
          influenceIndex = activeInfluenceIndices[m][1];
          if (attributes['morphTarget' + m] >= 0) {
            _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[influenceIndex]);
            enableAttribute(attributes['morphTarget' + m]);
            _gl.vertexAttribPointer(attributes['morphTarget' + m], 3, _gl.FLOAT, false, 0, 0);
          }
          if (attributes['morphNormal' + m] >= 0 && material.morphNormals) {
            _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[influenceIndex]);
            enableAttribute(attributes['morphNormal' + m]);
            _gl.vertexAttribPointer(attributes['morphNormal' + m], 3, _gl.FLOAT, false, 0, 0);
          }
          object.__webglMorphTargetInfluences[m] = influences[influenceIndex];
        } else {
          object.__webglMorphTargetInfluences[m] = 0;
        }
        m++;
      }
    }
    if (material.program.uniforms.morphTargetInfluences !== null) {
      _gl.uniform1fv(material.program.uniforms.morphTargetInfluences, object.__webglMorphTargetInfluences);
    }
  }
  ;
  function painterSortStable(a, b) {
    if (a.z !== b.z) {
      return b.z - a.z;
    } else {
      return a.id - b.id;
    }
  }
  ;
  function numericalSort(a, b) {
    return b[0] - a[0];
  }
  ;
  this.render = function (scene, camera, renderTarget, forceClear) {
    if (camera instanceof THREE.Camera === false) {
      console.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.');
      return;
    }
    var i, il, webglObject, object, renderList, lights = scene.__lights, fog = scene.fog;
    _currentMaterialId = -1;
    _lightsNeedUpdate = true;
    if (scene.autoUpdate === true)
      scene.updateMatrixWorld();
    if (camera.parent === undefined)
      camera.updateMatrixWorld();
    camera.matrixWorldInverse.getInverse(camera.matrixWorld);
    _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
    _frustum.setFromMatrix(_projScreenMatrix);
    if (this.autoUpdateObjects)
      this.initWebGLObjects(scene);
    renderPlugins(this.renderPluginsPre, scene, camera);
    _this.info.render.calls = 0;
    _this.info.render.vertices = 0;
    _this.info.render.faces = 0;
    _this.info.render.points = 0;
    this.setRenderTarget(renderTarget);
    if (this.autoClear || forceClear) {
      this.clear(this.autoClearColor, this.autoClearDepth, this.autoClearStencil);
    }
    renderList = scene.__webglObjects;
    for (i = 0, il = renderList.length; i < il; i++) {
      webglObject = renderList[i];
      object = webglObject.object;
      webglObject.id = i;
      webglObject.render = false;
      if (object.visible) {
        if (!(object instanceof THREE.Mesh || object instanceof THREE.ParticleSystem) || !object.frustumCulled || _frustum.intersectsObject(object)) {
          setupMatrices(object, camera);
          unrollBufferMaterial(webglObject);
          webglObject.render = true;
          if (this.sortObjects === true) {
            if (object.renderDepth !== null) {
              webglObject.z = object.renderDepth;
            } else {
              _vector3.getPositionFromMatrix(object.matrixWorld);
              _vector3.applyProjection(_projScreenMatrix);
              webglObject.z = _vector3.z;
            }
          }
        }
      }
    }
    if (this.sortObjects) {
      renderList.sort(painterSortStable);
    }
    renderList = scene.__webglObjectsImmediate;
    for (i = 0, il = renderList.length; i < il; i++) {
      webglObject = renderList[i];
      object = webglObject.object;
      if (object.visible) {
        setupMatrices(object, camera);
        unrollImmediateBufferMaterial(webglObject);
      }
    }
    if (scene.overrideMaterial) {
      var material = scene.overrideMaterial;
      this.setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst);
      this.setDepthTest(material.depthTest);
      this.setDepthWrite(material.depthWrite);
      setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
      renderObjects(scene.__webglObjects, false, '', camera, lights, fog, true, material);
      renderObjectsImmediate(scene.__webglObjectsImmediate, '', camera, lights, fog, false, material);
    } else {
      var material = null;
      this.setBlending(THREE.NoBlending);
      renderObjects(scene.__webglObjects, true, 'opaque', camera, lights, fog, false, material);
      renderObjectsImmediate(scene.__webglObjectsImmediate, 'opaque', camera, lights, fog, false, material);
      renderObjects(scene.__webglObjects, false, 'transparent', camera, lights, fog, true, material);
      renderObjectsImmediate(scene.__webglObjectsImmediate, 'transparent', camera, lights, fog, true, material);
    }
    renderPlugins(this.renderPluginsPost, scene, camera);
    if (renderTarget && renderTarget.generateMipmaps && renderTarget.minFilter !== THREE.NearestFilter && renderTarget.minFilter !== THREE.LinearFilter) {
      updateRenderTargetMipmap(renderTarget);
    }
    this.setDepthTest(true);
    this.setDepthWrite(true);
  };
  function renderPlugins(plugins, scene, camera) {
    if (!plugins.length)
      return;
    for (var i = 0, il = plugins.length; i < il; i++) {
      _currentProgram = null;
      _currentCamera = null;
      _oldBlending = -1;
      _oldDepthTest = -1;
      _oldDepthWrite = -1;
      _oldDoubleSided = -1;
      _oldFlipSided = -1;
      _currentGeometryGroupHash = -1;
      _currentMaterialId = -1;
      _lightsNeedUpdate = true;
      plugins[i].render(scene, camera, _currentWidth, _currentHeight);
      _currentProgram = null;
      _currentCamera = null;
      _oldBlending = -1;
      _oldDepthTest = -1;
      _oldDepthWrite = -1;
      _oldDoubleSided = -1;
      _oldFlipSided = -1;
      _currentGeometryGroupHash = -1;
      _currentMaterialId = -1;
      _lightsNeedUpdate = true;
    }
  }
  ;
  function renderObjects(renderList, reverse, materialType, camera, lights, fog, useBlending, overrideMaterial) {
    var webglObject, object, buffer, material, start, end, delta;
    if (reverse) {
      start = renderList.length - 1;
      end = -1;
      delta = -1;
    } else {
      start = 0;
      end = renderList.length;
      delta = 1;
    }
    for (var i = start; i !== end; i += delta) {
      webglObject = renderList[i];
      if (webglObject.render) {
        object = webglObject.object;
        buffer = webglObject.buffer;
        if (overrideMaterial) {
          material = overrideMaterial;
        } else {
          material = webglObject[materialType];
          if (!material)
            continue;
          if (useBlending)
            _this.setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst);
          _this.setDepthTest(material.depthTest);
          _this.setDepthWrite(material.depthWrite);
          setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
        }
        _this.setMaterialFaces(material);
        if (buffer instanceof THREE.BufferGeometry) {
          _this.renderBufferDirect(camera, lights, fog, material, buffer, object);
        } else {
          _this.renderBuffer(camera, lights, fog, material, buffer, object);
        }
      }
    }
  }
  ;
  function renderObjectsImmediate(renderList, materialType, camera, lights, fog, useBlending, overrideMaterial) {
    var webglObject, object, material, program;
    for (var i = 0, il = renderList.length; i < il; i++) {
      webglObject = renderList[i];
      object = webglObject.object;
      if (object.visible) {
        if (overrideMaterial) {
          material = overrideMaterial;
        } else {
          material = webglObject[materialType];
          if (!material)
            continue;
          if (useBlending)
            _this.setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst);
          _this.setDepthTest(material.depthTest);
          _this.setDepthWrite(material.depthWrite);
          setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
        }
        _this.renderImmediateObject(camera, lights, fog, material, object);
      }
    }
  }
  ;
  this.renderImmediateObject = function (camera, lights, fog, material, object) {
    var program = setProgram(camera, lights, fog, material, object);
    _currentGeometryGroupHash = -1;
    _this.setMaterialFaces(material);
    if (object.immediateRenderCallback) {
      object.immediateRenderCallback(program, _gl, _frustum);
    } else {
      object.render(function (object) {
        _this.renderBufferImmediate(object, program, material);
      });
    }
  };
  function unrollImmediateBufferMaterial(globject) {
    var object = globject.object, material = object.material;
    if (material.transparent) {
      globject.transparent = material;
      globject.opaque = null;
    } else {
      globject.opaque = material;
      globject.transparent = null;
    }
  }
  ;
  function unrollBufferMaterial(globject) {
    var object = globject.object, buffer = globject.buffer, material, materialIndex, meshMaterial;
    meshMaterial = object.material;
    if (meshMaterial instanceof THREE.MeshFaceMaterial) {
      materialIndex = buffer.materialIndex;
      material = meshMaterial.materials[materialIndex];
      if (material.transparent) {
        globject.transparent = material;
        globject.opaque = null;
      } else {
        globject.opaque = material;
        globject.transparent = null;
      }
    } else {
      material = meshMaterial;
      if (material) {
        if (material.transparent) {
          globject.transparent = material;
          globject.opaque = null;
        } else {
          globject.opaque = material;
          globject.transparent = null;
        }
      }
    }
  }
  ;
  function sortFacesByMaterial(geometry, material) {
    var f, fl, face, materialIndex, vertices, groupHash, hash_map = {};
    var numMorphTargets = geometry.morphTargets.length;
    var numMorphNormals = geometry.morphNormals.length;
    var usesFaceMaterial = material instanceof THREE.MeshFaceMaterial;
    geometry.geometryGroups = {};
    for (f = 0, fl = geometry.faces.length; f < fl; f++) {
      face = geometry.faces[f];
      materialIndex = usesFaceMaterial ? face.materialIndex : 0;
      if (hash_map[materialIndex] === undefined) {
        hash_map[materialIndex] = {
          'hash': materialIndex,
          'counter': 0
        };
      }
      groupHash = hash_map[materialIndex].hash + '_' + hash_map[materialIndex].counter;
      if (geometry.geometryGroups[groupHash] === undefined) {
        geometry.geometryGroups[groupHash] = {
          'faces3': [],
          'materialIndex': materialIndex,
          'vertices': 0,
          'numMorphTargets': numMorphTargets,
          'numMorphNormals': numMorphNormals
        };
      }
      vertices = 3;
      if (geometry.geometryGroups[groupHash].vertices + vertices > 65535) {
        hash_map[materialIndex].counter += 1;
        groupHash = hash_map[materialIndex].hash + '_' + hash_map[materialIndex].counter;
        if (geometry.geometryGroups[groupHash] === undefined) {
          geometry.geometryGroups[groupHash] = {
            'faces3': [],
            'materialIndex': materialIndex,
            'vertices': 0,
            'numMorphTargets': numMorphTargets,
            'numMorphNormals': numMorphNormals
          };
        }
      }
      geometry.geometryGroups[groupHash].faces3.push(f);
      geometry.geometryGroups[groupHash].vertices += vertices;
    }
    geometry.geometryGroupsList = [];
    for (var g in geometry.geometryGroups) {
      geometry.geometryGroups[g].id = _geometryGroupCounter++;
      geometry.geometryGroupsList.push(geometry.geometryGroups[g]);
    }
  }
  ;
  this.initWebGLObjects = function (scene) {
    if (!scene.__webglObjects) {
      scene.__webglObjects = [];
      scene.__webglObjectsImmediate = [];
      scene.__webglSprites = [];
      scene.__webglFlares = [];
    }
    while (scene.__objectsAdded.length) {
      addObject(scene.__objectsAdded[0], scene);
      scene.__objectsAdded.splice(0, 1);
    }
    while (scene.__objectsRemoved.length) {
      removeObject(scene.__objectsRemoved[0], scene);
      scene.__objectsRemoved.splice(0, 1);
    }
    for (var o = 0, ol = scene.__webglObjects.length; o < ol; o++) {
      var object = scene.__webglObjects[o].object;
      if (object.__webglInit === undefined) {
        if (object.__webglActive !== undefined) {
          removeObject(object, scene);
        }
        addObject(object, scene);
      }
      updateObject(object);
    }
  };
  function addObject(object, scene) {
    var g, geometry, material, geometryGroup;
    if (object.__webglInit === undefined) {
      object.__webglInit = true;
      object._modelViewMatrix = new THREE.Matrix4();
      object._normalMatrix = new THREE.Matrix3();
      if (object.geometry !== undefined && object.geometry.__webglInit === undefined) {
        object.geometry.__webglInit = true;
        object.geometry.addEventListener('dispose', onGeometryDispose);
      }
      geometry = object.geometry;
      if (geometry === undefined) {
      } else if (geometry instanceof THREE.BufferGeometry) {
        initDirectBuffers(geometry);
      } else if (object instanceof THREE.Mesh) {
        material = object.material;
        if (geometry.geometryGroups === undefined) {
          sortFacesByMaterial(geometry, material);
        }
        for (g in geometry.geometryGroups) {
          geometryGroup = geometry.geometryGroups[g];
          if (!geometryGroup.__webglVertexBuffer) {
            createMeshBuffers(geometryGroup);
            initMeshBuffers(geometryGroup, object);
            geometry.verticesNeedUpdate = true;
            geometry.morphTargetsNeedUpdate = true;
            geometry.elementsNeedUpdate = true;
            geometry.uvsNeedUpdate = true;
            geometry.normalsNeedUpdate = true;
            geometry.tangentsNeedUpdate = true;
            geometry.colorsNeedUpdate = true;
          }
        }
      } else if (object instanceof THREE.Ribbon) {
        if (!geometry.__webglVertexBuffer) {
          createRibbonBuffers(geometry);
          initRibbonBuffers(geometry, object);
          geometry.verticesNeedUpdate = true;
          geometry.colorsNeedUpdate = true;
          geometry.normalsNeedUpdate = true;
        }
      } else if (object instanceof THREE.Line) {
        if (!geometry.__webglVertexBuffer) {
          createLineBuffers(geometry);
          initLineBuffers(geometry, object);
          geometry.verticesNeedUpdate = true;
          geometry.colorsNeedUpdate = true;
          geometry.lineDistancesNeedUpdate = true;
        }
      } else if (object instanceof THREE.ParticleSystem) {
        if (!geometry.__webglVertexBuffer) {
          createParticleBuffers(geometry);
          initParticleBuffers(geometry, object);
          geometry.verticesNeedUpdate = true;
          geometry.colorsNeedUpdate = true;
        }
      }
    }
    if (object.__webglActive === undefined) {
      if (object instanceof THREE.Mesh) {
        geometry = object.geometry;
        if (geometry instanceof THREE.BufferGeometry) {
          addBuffer(scene.__webglObjects, geometry, object);
        } else if (geometry instanceof THREE.Geometry) {
          for (g in geometry.geometryGroups) {
            geometryGroup = geometry.geometryGroups[g];
            addBuffer(scene.__webglObjects, geometryGroup, object);
          }
        }
      } else if (object instanceof THREE.Ribbon || object instanceof THREE.Line || object instanceof THREE.ParticleSystem) {
        geometry = object.geometry;
        addBuffer(scene.__webglObjects, geometry, object);
      } else if (object instanceof THREE.ImmediateRenderObject || object.immediateRenderCallback) {
        addBufferImmediate(scene.__webglObjectsImmediate, object);
      } else if (object instanceof THREE.Sprite) {
        scene.__webglSprites.push(object);
      } else if (object instanceof THREE.LensFlare) {
        scene.__webglFlares.push(object);
      }
      object.__webglActive = true;
    }
  }
  ;
  function addBuffer(objlist, buffer, object) {
    objlist.push({
      id: null,
      buffer: buffer,
      object: object,
      opaque: null,
      transparent: null,
      z: 0
    });
  }
  ;
  function addBufferImmediate(objlist, object) {
    objlist.push({
      id: null,
      object: object,
      opaque: null,
      transparent: null,
      z: 0
    });
  }
  ;
  function updateObject(object) {
    var geometry = object.geometry, geometryGroup, customAttributesDirty, material;
    if (geometry instanceof THREE.BufferGeometry) {
      setDirectBuffers(geometry, _gl.DYNAMIC_DRAW, !geometry.dynamic);
    } else if (object instanceof THREE.Mesh) {
      for (var i = 0, il = geometry.geometryGroupsList.length; i < il; i++) {
        geometryGroup = geometry.geometryGroupsList[i];
        material = getBufferMaterial(object, geometryGroup);
        if (geometry.buffersNeedUpdate) {
          initMeshBuffers(geometryGroup, object);
        }
        customAttributesDirty = material.attributes && areCustomAttributesDirty(material);
        if (geometry.verticesNeedUpdate || geometry.morphTargetsNeedUpdate || geometry.elementsNeedUpdate || geometry.uvsNeedUpdate || geometry.normalsNeedUpdate || geometry.colorsNeedUpdate || geometry.tangentsNeedUpdate || customAttributesDirty) {
          setMeshBuffers(geometryGroup, object, _gl.DYNAMIC_DRAW, !geometry.dynamic, material);
        }
      }
      geometry.verticesNeedUpdate = false;
      geometry.morphTargetsNeedUpdate = false;
      geometry.elementsNeedUpdate = false;
      geometry.uvsNeedUpdate = false;
      geometry.normalsNeedUpdate = false;
      geometry.colorsNeedUpdate = false;
      geometry.tangentsNeedUpdate = false;
      geometry.buffersNeedUpdate = false;
      material.attributes && clearCustomAttributes(material);
    } else if (object instanceof THREE.Ribbon) {
      material = getBufferMaterial(object, geometry);
      customAttributesDirty = material.attributes && areCustomAttributesDirty(material);
      if (geometry.verticesNeedUpdate || geometry.colorsNeedUpdate || geometry.normalsNeedUpdate || customAttributesDirty) {
        setRibbonBuffers(geometry, _gl.DYNAMIC_DRAW);
      }
      geometry.verticesNeedUpdate = false;
      geometry.colorsNeedUpdate = false;
      geometry.normalsNeedUpdate = false;
      material.attributes && clearCustomAttributes(material);
    } else if (object instanceof THREE.Line) {
      material = getBufferMaterial(object, geometry);
      customAttributesDirty = material.attributes && areCustomAttributesDirty(material);
      if (geometry.verticesNeedUpdate || geometry.colorsNeedUpdate || geometry.lineDistancesNeedUpdate || customAttributesDirty) {
        setLineBuffers(geometry, _gl.DYNAMIC_DRAW);
      }
      geometry.verticesNeedUpdate = false;
      geometry.colorsNeedUpdate = false;
      geometry.lineDistancesNeedUpdate = false;
      material.attributes && clearCustomAttributes(material);
    } else if (object instanceof THREE.ParticleSystem) {
      material = getBufferMaterial(object, geometry);
      customAttributesDirty = material.attributes && areCustomAttributesDirty(material);
      if (geometry.verticesNeedUpdate || geometry.colorsNeedUpdate || object.sortParticles || customAttributesDirty) {
        setParticleBuffers(geometry, _gl.DYNAMIC_DRAW, object);
      }
      geometry.verticesNeedUpdate = false;
      geometry.colorsNeedUpdate = false;
      material.attributes && clearCustomAttributes(material);
    }
  }
  ;
  function areCustomAttributesDirty(material) {
    for (var a in material.attributes) {
      if (material.attributes[a].needsUpdate)
        return true;
    }
    return false;
  }
  ;
  function clearCustomAttributes(material) {
    for (var a in material.attributes) {
      material.attributes[a].needsUpdate = false;
    }
  }
  ;
  function removeObject(object, scene) {
    if (object instanceof THREE.Mesh || object instanceof THREE.ParticleSystem || object instanceof THREE.Ribbon || object instanceof THREE.Line) {
      removeInstances(scene.__webglObjects, object);
    } else if (object instanceof THREE.Sprite) {
      removeInstancesDirect(scene.__webglSprites, object);
    } else if (object instanceof THREE.LensFlare) {
      removeInstancesDirect(scene.__webglFlares, object);
    } else if (object instanceof THREE.ImmediateRenderObject || object.immediateRenderCallback) {
      removeInstances(scene.__webglObjectsImmediate, object);
    }
    delete object.__webglActive;
  }
  ;
  function removeInstances(objlist, object) {
    for (var o = objlist.length - 1; o >= 0; o--) {
      if (objlist[o].object === object) {
        objlist.splice(o, 1);
      }
    }
  }
  ;
  function removeInstancesDirect(objlist, object) {
    for (var o = objlist.length - 1; o >= 0; o--) {
      if (objlist[o] === object) {
        objlist.splice(o, 1);
      }
    }
  }
  ;
  this.initMaterial = function (material, lights, fog, object) {
    material.addEventListener('dispose', onMaterialDispose);
    var u, a, identifiers, i, parameters, maxLightCount, maxBones, maxShadows, shaderID;
    if (material instanceof THREE.MeshDepthMaterial) {
      shaderID = 'depth';
    } else if (material instanceof THREE.MeshNormalMaterial) {
      shaderID = 'normal';
    } else if (material instanceof THREE.MeshBasicMaterial) {
      shaderID = 'basic';
    } else if (material instanceof THREE.MeshLambertMaterial) {
      shaderID = 'lambert';
    } else if (material instanceof THREE.MeshPhongMaterial) {
      shaderID = 'phong';
    } else if (material instanceof THREE.LineBasicMaterial) {
      shaderID = 'basic';
    } else if (material instanceof THREE.LineDashedMaterial) {
      shaderID = 'dashed';
    } else if (material instanceof THREE.ParticleBasicMaterial) {
      shaderID = 'particle_basic';
    }
    if (shaderID) {
      setMaterialShaders(material, THREE.ShaderLib[shaderID]);
    }
    maxLightCount = allocateLights(lights);
    maxShadows = allocateShadows(lights);
    maxBones = allocateBones(object);
    parameters = {
      map: !!material.map,
      envMap: !!material.envMap,
      lightMap: !!material.lightMap,
      bumpMap: !!material.bumpMap,
      normalMap: !!material.normalMap,
      specularMap: !!material.specularMap,
      vertexColors: material.vertexColors,
      fog: fog,
      useFog: material.fog,
      fogExp: fog instanceof THREE.FogExp2,
      sizeAttenuation: material.sizeAttenuation,
      skinning: material.skinning,
      maxBones: maxBones,
      useVertexTexture: _supportsBoneTextures && object && object.useVertexTexture,
      boneTextureWidth: object && object.boneTextureWidth,
      boneTextureHeight: object && object.boneTextureHeight,
      morphTargets: material.morphTargets,
      morphNormals: material.morphNormals,
      maxMorphTargets: this.maxMorphTargets,
      maxMorphNormals: this.maxMorphNormals,
      maxDirLights: maxLightCount.directional,
      maxPointLights: maxLightCount.point,
      maxSpotLights: maxLightCount.spot,
      maxHemiLights: maxLightCount.hemi,
      maxShadows: maxShadows,
      shadowMapEnabled: this.shadowMapEnabled && object.receiveShadow,
      shadowMapType: this.shadowMapType,
      shadowMapDebug: this.shadowMapDebug,
      shadowMapCascade: this.shadowMapCascade,
      alphaTest: material.alphaTest,
      metal: material.metal,
      perPixel: material.perPixel,
      wrapAround: material.wrapAround,
      doubleSided: material.side === THREE.DoubleSide,
      flipSided: material.side === THREE.BackSide
    };
    material.program = buildProgram(shaderID, material.fragmentShader, material.vertexShader, material.uniforms, material.attributes, material.defines, parameters, material.index0AttributeName);
    var attributes = material.program.attributes;
    if (material.morphTargets) {
      material.numSupportedMorphTargets = 0;
      var id, base = 'morphTarget';
      for (i = 0; i < this.maxMorphTargets; i++) {
        id = base + i;
        if (attributes[id] >= 0) {
          material.numSupportedMorphTargets++;
        }
      }
    }
    if (material.morphNormals) {
      material.numSupportedMorphNormals = 0;
      var id, base = 'morphNormal';
      for (i = 0; i < this.maxMorphNormals; i++) {
        id = base + i;
        if (attributes[id] >= 0) {
          material.numSupportedMorphNormals++;
        }
      }
    }
    material.uniformsList = [];
    for (u in material.uniforms) {
      material.uniformsList.push([
        material.uniforms[u],
        u
      ]);
    }
  };
  function setMaterialShaders(material, shaders) {
    material.uniforms = THREE.UniformsUtils.clone(shaders.uniforms);
    material.vertexShader = shaders.vertexShader;
    material.fragmentShader = shaders.fragmentShader;
  }
  ;
  function setProgram(camera, lights, fog, material, object) {
    _usedTextureUnits = 0;
    if (material.needsUpdate) {
      if (material.program)
        deallocateMaterial(material);
      _this.initMaterial(material, lights, fog, object);
      material.needsUpdate = false;
    }
    if (material.morphTargets) {
      if (!object.__webglMorphTargetInfluences) {
        object.__webglMorphTargetInfluences = new Float32Array(_this.maxMorphTargets);
      }
    }
    var refreshMaterial = false;
    var program = material.program, p_uniforms = program.uniforms, m_uniforms = material.uniforms;
    if (program !== _currentProgram) {
      _gl.useProgram(program);
      _currentProgram = program;
      refreshMaterial = true;
    }
    if (material.id !== _currentMaterialId) {
      _currentMaterialId = material.id;
      refreshMaterial = true;
    }
    if (refreshMaterial || camera !== _currentCamera) {
      _gl.uniformMatrix4fv(p_uniforms.projectionMatrix, false, camera.projectionMatrix.elements);
      if (camera !== _currentCamera)
        _currentCamera = camera;
    }
    if (material.skinning) {
      if (_supportsBoneTextures && object.useVertexTexture) {
        if (p_uniforms.boneTexture !== null) {
          var textureUnit = getTextureUnit();
          _gl.uniform1i(p_uniforms.boneTexture, textureUnit);
          _this.setTexture(object.boneTexture, textureUnit);
        }
      } else {
        if (p_uniforms.boneGlobalMatrices !== null) {
          _gl.uniformMatrix4fv(p_uniforms.boneGlobalMatrices, false, object.boneMatrices);
        }
      }
    }
    if (refreshMaterial) {
      if (fog && material.fog) {
        refreshUniformsFog(m_uniforms, fog);
      }
      if (material instanceof THREE.MeshPhongMaterial || material instanceof THREE.MeshLambertMaterial || material.lights) {
        if (_lightsNeedUpdate) {
          setupLights(program, lights);
          _lightsNeedUpdate = false;
        }
        refreshUniformsLights(m_uniforms, _lights);
      }
      if (material instanceof THREE.MeshBasicMaterial || material instanceof THREE.MeshLambertMaterial || material instanceof THREE.MeshPhongMaterial) {
        refreshUniformsCommon(m_uniforms, material);
      }
      if (material instanceof THREE.LineBasicMaterial) {
        refreshUniformsLine(m_uniforms, material);
      } else if (material instanceof THREE.LineDashedMaterial) {
        refreshUniformsLine(m_uniforms, material);
        refreshUniformsDash(m_uniforms, material);
      } else if (material instanceof THREE.ParticleBasicMaterial) {
        refreshUniformsParticle(m_uniforms, material);
      } else if (material instanceof THREE.MeshPhongMaterial) {
        refreshUniformsPhong(m_uniforms, material);
      } else if (material instanceof THREE.MeshLambertMaterial) {
        refreshUniformsLambert(m_uniforms, material);
      } else if (material instanceof THREE.MeshDepthMaterial) {
        m_uniforms.mNear.value = camera.near;
        m_uniforms.mFar.value = camera.far;
        m_uniforms.opacity.value = material.opacity;
      } else if (material instanceof THREE.MeshNormalMaterial) {
        m_uniforms.opacity.value = material.opacity;
      }
      if (object.receiveShadow && !material._shadowPass) {
        refreshUniformsShadow(m_uniforms, lights);
      }
      loadUniformsGeneric(program, material.uniformsList);
      if (material instanceof THREE.ShaderMaterial || material instanceof THREE.MeshPhongMaterial || material.envMap) {
        if (p_uniforms.cameraPosition !== null) {
          _vector3.getPositionFromMatrix(camera.matrixWorld);
          _gl.uniform3f(p_uniforms.cameraPosition, _vector3.x, _vector3.y, _vector3.z);
        }
      }
      if (material instanceof THREE.MeshPhongMaterial || material instanceof THREE.MeshLambertMaterial || material instanceof THREE.ShaderMaterial || material.skinning) {
        if (p_uniforms.viewMatrix !== null) {
          _gl.uniformMatrix4fv(p_uniforms.viewMatrix, false, camera.matrixWorldInverse.elements);
        }
      }
    }
    loadUniformsMatrices(p_uniforms, object);
    if (p_uniforms.modelMatrix !== null) {
      _gl.uniformMatrix4fv(p_uniforms.modelMatrix, false, object.matrixWorld.elements);
    }
    return program;
  }
  ;
  function refreshUniformsCommon(uniforms, material) {
    uniforms.opacity.value = material.opacity;
    if (_this.gammaInput) {
      uniforms.diffuse.value.copyGammaToLinear(material.color);
    } else {
      uniforms.diffuse.value = material.color;
    }
    uniforms.map.value = material.map;
    uniforms.lightMap.value = material.lightMap;
    uniforms.specularMap.value = material.specularMap;
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
    }
    var uvScaleMap;
    if (material.map) {
      uvScaleMap = material.map;
    } else if (material.specularMap) {
      uvScaleMap = material.specularMap;
    } else if (material.normalMap) {
      uvScaleMap = material.normalMap;
    } else if (material.bumpMap) {
      uvScaleMap = material.bumpMap;
    }
    if (uvScaleMap !== undefined) {
      var offset = uvScaleMap.offset;
      var repeat = uvScaleMap.repeat;
      uniforms.offsetRepeat.value.set(offset.x, offset.y, repeat.x, repeat.y);
    }
    uniforms.envMap.value = material.envMap;
    uniforms.flipEnvMap.value = material.envMap instanceof THREE.WebGLRenderTargetCube ? 1 : -1;
    if (_this.gammaInput) {
      uniforms.reflectivity.value = material.reflectivity;
    } else {
      uniforms.reflectivity.value = material.reflectivity;
    }
    uniforms.refractionRatio.value = material.refractionRatio;
    uniforms.combine.value = material.combine;
    uniforms.useRefract.value = material.envMap && material.envMap.mapping instanceof THREE.CubeRefractionMapping;
  }
  ;
  function refreshUniformsLine(uniforms, material) {
    uniforms.diffuse.value = material.color;
    uniforms.opacity.value = material.opacity;
  }
  ;
  function refreshUniformsDash(uniforms, material) {
    uniforms.dashSize.value = material.dashSize;
    uniforms.totalSize.value = material.dashSize + material.gapSize;
    uniforms.scale.value = material.scale;
  }
  ;
  function refreshUniformsParticle(uniforms, material) {
    uniforms.psColor.value = material.color;
    uniforms.opacity.value = material.opacity;
    uniforms.size.value = material.size;
    uniforms.scale.value = _canvas.height / 2;
    uniforms.map.value = material.map;
  }
  ;
  function refreshUniformsFog(uniforms, fog) {
    uniforms.fogColor.value = fog.color;
    if (fog instanceof THREE.Fog) {
      uniforms.fogNear.value = fog.near;
      uniforms.fogFar.value = fog.far;
    } else if (fog instanceof THREE.FogExp2) {
      uniforms.fogDensity.value = fog.density;
    }
  }
  ;
  function refreshUniformsPhong(uniforms, material) {
    uniforms.shininess.value = material.shininess;
    if (_this.gammaInput) {
      uniforms.ambient.value.copyGammaToLinear(material.ambient);
      uniforms.emissive.value.copyGammaToLinear(material.emissive);
      uniforms.specular.value.copyGammaToLinear(material.specular);
    } else {
      uniforms.ambient.value = material.ambient;
      uniforms.emissive.value = material.emissive;
      uniforms.specular.value = material.specular;
    }
    if (material.wrapAround) {
      uniforms.wrapRGB.value.copy(material.wrapRGB);
    }
  }
  ;
  function refreshUniformsLambert(uniforms, material) {
    if (_this.gammaInput) {
      uniforms.ambient.value.copyGammaToLinear(material.ambient);
      uniforms.emissive.value.copyGammaToLinear(material.emissive);
    } else {
      uniforms.ambient.value = material.ambient;
      uniforms.emissive.value = material.emissive;
    }
    if (material.wrapAround) {
      uniforms.wrapRGB.value.copy(material.wrapRGB);
    }
  }
  ;
  function refreshUniformsLights(uniforms, lights) {
    uniforms.ambientLightColor.value = lights.ambient;
    uniforms.directionalLightColor.value = lights.directional.colors;
    uniforms.directionalLightDirection.value = lights.directional.positions;
    uniforms.pointLightColor.value = lights.point.colors;
    uniforms.pointLightPosition.value = lights.point.positions;
    uniforms.pointLightDistance.value = lights.point.distances;
    uniforms.spotLightColor.value = lights.spot.colors;
    uniforms.spotLightPosition.value = lights.spot.positions;
    uniforms.spotLightDistance.value = lights.spot.distances;
    uniforms.spotLightDirection.value = lights.spot.directions;
    uniforms.spotLightAngleCos.value = lights.spot.anglesCos;
    uniforms.spotLightExponent.value = lights.spot.exponents;
    uniforms.hemisphereLightSkyColor.value = lights.hemi.skyColors;
    uniforms.hemisphereLightGroundColor.value = lights.hemi.groundColors;
    uniforms.hemisphereLightDirection.value = lights.hemi.positions;
  }
  ;
  function refreshUniformsShadow(uniforms, lights) {
    if (uniforms.shadowMatrix) {
      var j = 0;
      for (var i = 0, il = lights.length; i < il; i++) {
        var light = lights[i];
        if (!light.castShadow)
          continue;
        if (light instanceof THREE.SpotLight || light instanceof THREE.DirectionalLight && !light.shadowCascade) {
          uniforms.shadowMap.value[j] = light.shadowMap;
          uniforms.shadowMapSize.value[j] = light.shadowMapSize;
          uniforms.shadowMatrix.value[j] = light.shadowMatrix;
          uniforms.shadowDarkness.value[j] = light.shadowDarkness;
          uniforms.shadowBias.value[j] = light.shadowBias;
          j++;
        }
      }
    }
  }
  ;
  function loadUniformsMatrices(uniforms, object) {
    _gl.uniformMatrix4fv(uniforms.modelViewMatrix, false, object._modelViewMatrix.elements);
    if (uniforms.normalMatrix) {
      _gl.uniformMatrix3fv(uniforms.normalMatrix, false, object._normalMatrix.elements);
    }
  }
  ;
  function getTextureUnit() {
    var textureUnit = _usedTextureUnits;
    if (textureUnit >= _maxTextures) {
      console.warn('WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + _maxTextures);
    }
    _usedTextureUnits += 1;
    return textureUnit;
  }
  ;
  function loadUniformsGeneric(program, uniforms) {
    var uniform, value, type, location, texture, textureUnit, i, il, j, jl, offset;
    for (j = 0, jl = uniforms.length; j < jl; j++) {
      location = program.uniforms[uniforms[j][1]];
      if (!location)
        continue;
      uniform = uniforms[j][0];
      type = uniform.type;
      value = uniform.value;
      if (type === 'i') {
        _gl.uniform1i(location, value);
      } else if (type === 'f') {
        _gl.uniform1f(location, value);
      } else if (type === 'v2') {
        _gl.uniform2f(location, value.x, value.y);
      } else if (type === 'v3') {
        _gl.uniform3f(location, value.x, value.y, value.z);
      } else if (type === 'v4') {
        _gl.uniform4f(location, value.x, value.y, value.z, value.w);
      } else if (type === 'c') {
        _gl.uniform3f(location, value.r, value.g, value.b);
      } else if (type === 'iv1') {
        _gl.uniform1iv(location, value);
      } else if (type === 'iv') {
        _gl.uniform3iv(location, value);
      } else if (type === 'fv1') {
        _gl.uniform1fv(location, value);
      } else if (type === 'fv') {
        _gl.uniform3fv(location, value);
      } else if (type === 'v2v') {
        if (uniform._array === undefined) {
          uniform._array = new Float32Array(2 * value.length);
        }
        for (i = 0, il = value.length; i < il; i++) {
          offset = i * 2;
          uniform._array[offset] = value[i].x;
          uniform._array[offset + 1] = value[i].y;
        }
        _gl.uniform2fv(location, uniform._array);
      } else if (type === 'v3v') {
        if (uniform._array === undefined) {
          uniform._array = new Float32Array(3 * value.length);
        }
        for (i = 0, il = value.length; i < il; i++) {
          offset = i * 3;
          uniform._array[offset] = value[i].x;
          uniform._array[offset + 1] = value[i].y;
          uniform._array[offset + 2] = value[i].z;
        }
        _gl.uniform3fv(location, uniform._array);
      } else if (type === 'v4v') {
        if (uniform._array === undefined) {
          uniform._array = new Float32Array(4 * value.length);
        }
        for (i = 0, il = value.length; i < il; i++) {
          offset = i * 4;
          uniform._array[offset] = value[i].x;
          uniform._array[offset + 1] = value[i].y;
          uniform._array[offset + 2] = value[i].z;
          uniform._array[offset + 3] = value[i].w;
        }
        _gl.uniform4fv(location, uniform._array);
      } else if (type === 'm4') {
        if (uniform._array === undefined) {
          uniform._array = new Float32Array(16);
        }
        value.flattenToArray(uniform._array);
        _gl.uniformMatrix4fv(location, false, uniform._array);
      } else if (type === 'm4v') {
        if (uniform._array === undefined) {
          uniform._array = new Float32Array(16 * value.length);
        }
        for (i = 0, il = value.length; i < il; i++) {
          value[i].flattenToArrayOffset(uniform._array, i * 16);
        }
        _gl.uniformMatrix4fv(location, false, uniform._array);
      } else if (type === 't') {
        texture = value;
        textureUnit = getTextureUnit();
        _gl.uniform1i(location, textureUnit);
        if (!texture)
          continue;
        if (texture.image instanceof Array && texture.image.length === 6) {
          setCubeTexture(texture, textureUnit);
        } else if (texture instanceof THREE.WebGLRenderTargetCube) {
          setCubeTextureDynamic(texture, textureUnit);
        } else {
          _this.setTexture(texture, textureUnit);
        }
      } else if (type === 'tv') {
        if (uniform._array === undefined) {
          uniform._array = [];
        }
        for (i = 0, il = uniform.value.length; i < il; i++) {
          uniform._array[i] = getTextureUnit();
        }
        _gl.uniform1iv(location, uniform._array);
        for (i = 0, il = uniform.value.length; i < il; i++) {
          texture = uniform.value[i];
          textureUnit = uniform._array[i];
          if (!texture)
            continue;
          _this.setTexture(texture, textureUnit);
        }
      } else {
        console.warn('THREE.WebGLRenderer: Unknown uniform type: ' + type);
      }
    }
  }
  ;
  function setupMatrices(object, camera) {
    object._modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
    object._normalMatrix.getNormalMatrix(object._modelViewMatrix);
  }
  ;
  function setColorGamma(array, offset, color, intensitySq) {
    array[offset] = color.r * color.r * intensitySq;
    array[offset + 1] = color.g * color.g * intensitySq;
    array[offset + 2] = color.b * color.b * intensitySq;
  }
  ;
  function setColorLinear(array, offset, color, intensity) {
    array[offset] = color.r * intensity;
    array[offset + 1] = color.g * intensity;
    array[offset + 2] = color.b * intensity;
  }
  ;
  function setupLights(program, lights) {
    var l, ll, light, n, r = 0, g = 0, b = 0, color, skyColor, groundColor, intensity, intensitySq, position, distance, zlights = _lights, dirColors = zlights.directional.colors, dirPositions = zlights.directional.positions, pointColors = zlights.point.colors, pointPositions = zlights.point.positions, pointDistances = zlights.point.distances, spotColors = zlights.spot.colors, spotPositions = zlights.spot.positions, spotDistances = zlights.spot.distances, spotDirections = zlights.spot.directions, spotAnglesCos = zlights.spot.anglesCos, spotExponents = zlights.spot.exponents, hemiSkyColors = zlights.hemi.skyColors, hemiGroundColors = zlights.hemi.groundColors, hemiPositions = zlights.hemi.positions, dirLength = 0, pointLength = 0, spotLength = 0, hemiLength = 0, dirCount = 0, pointCount = 0, spotCount = 0, hemiCount = 0, dirOffset = 0, pointOffset = 0, spotOffset = 0, hemiOffset = 0;
    for (l = 0, ll = lights.length; l < ll; l++) {
      light = lights[l];
      if (light.onlyShadow)
        continue;
      color = light.color;
      intensity = light.intensity;
      distance = light.distance;
      if (light instanceof THREE.AmbientLight) {
        if (!light.visible)
          continue;
        if (_this.gammaInput) {
          r += color.r * color.r;
          g += color.g * color.g;
          b += color.b * color.b;
        } else {
          r += color.r;
          g += color.g;
          b += color.b;
        }
      } else if (light instanceof THREE.DirectionalLight) {
        dirCount += 1;
        if (!light.visible)
          continue;
        _direction.getPositionFromMatrix(light.matrixWorld);
        _vector3.getPositionFromMatrix(light.target.matrixWorld);
        _direction.sub(_vector3);
        _direction.normalize();
        if (_direction.x === 0 && _direction.y === 0 && _direction.z === 0)
          continue;
        dirOffset = dirLength * 3;
        dirPositions[dirOffset] = _direction.x;
        dirPositions[dirOffset + 1] = _direction.y;
        dirPositions[dirOffset + 2] = _direction.z;
        if (_this.gammaInput) {
          setColorGamma(dirColors, dirOffset, color, intensity * intensity);
        } else {
          setColorLinear(dirColors, dirOffset, color, intensity);
        }
        dirLength += 1;
      } else if (light instanceof THREE.PointLight) {
        pointCount += 1;
        if (!light.visible)
          continue;
        pointOffset = pointLength * 3;
        if (_this.gammaInput) {
          setColorGamma(pointColors, pointOffset, color, intensity * intensity);
        } else {
          setColorLinear(pointColors, pointOffset, color, intensity);
        }
        _vector3.getPositionFromMatrix(light.matrixWorld);
        pointPositions[pointOffset] = _vector3.x;
        pointPositions[pointOffset + 1] = _vector3.y;
        pointPositions[pointOffset + 2] = _vector3.z;
        pointDistances[pointLength] = distance;
        pointLength += 1;
      } else if (light instanceof THREE.SpotLight) {
        spotCount += 1;
        if (!light.visible)
          continue;
        spotOffset = spotLength * 3;
        if (_this.gammaInput) {
          setColorGamma(spotColors, spotOffset, color, intensity * intensity);
        } else {
          setColorLinear(spotColors, spotOffset, color, intensity);
        }
        _vector3.getPositionFromMatrix(light.matrixWorld);
        spotPositions[spotOffset] = _vector3.x;
        spotPositions[spotOffset + 1] = _vector3.y;
        spotPositions[spotOffset + 2] = _vector3.z;
        spotDistances[spotLength] = distance;
        _direction.copy(_vector3);
        _vector3.getPositionFromMatrix(light.target.matrixWorld);
        _direction.sub(_vector3);
        _direction.normalize();
        spotDirections[spotOffset] = _direction.x;
        spotDirections[spotOffset + 1] = _direction.y;
        spotDirections[spotOffset + 2] = _direction.z;
        spotAnglesCos[spotLength] = Math.cos(light.angle);
        spotExponents[spotLength] = light.exponent;
        spotLength += 1;
      } else if (light instanceof THREE.HemisphereLight) {
        hemiCount += 1;
        if (!light.visible)
          continue;
        _direction.getPositionFromMatrix(light.matrixWorld);
        _direction.normalize();
        if (_direction.x === 0 && _direction.y === 0 && _direction.z === 0)
          continue;
        hemiOffset = hemiLength * 3;
        hemiPositions[hemiOffset] = _direction.x;
        hemiPositions[hemiOffset + 1] = _direction.y;
        hemiPositions[hemiOffset + 2] = _direction.z;
        skyColor = light.color;
        groundColor = light.groundColor;
        if (_this.gammaInput) {
          intensitySq = intensity * intensity;
          setColorGamma(hemiSkyColors, hemiOffset, skyColor, intensitySq);
          setColorGamma(hemiGroundColors, hemiOffset, groundColor, intensitySq);
        } else {
          setColorLinear(hemiSkyColors, hemiOffset, skyColor, intensity);
          setColorLinear(hemiGroundColors, hemiOffset, groundColor, intensity);
        }
        hemiLength += 1;
      }
    }
    for (l = dirLength * 3, ll = Math.max(dirColors.length, dirCount * 3); l < ll; l++)
      dirColors[l] = 0;
    for (l = pointLength * 3, ll = Math.max(pointColors.length, pointCount * 3); l < ll; l++)
      pointColors[l] = 0;
    for (l = spotLength * 3, ll = Math.max(spotColors.length, spotCount * 3); l < ll; l++)
      spotColors[l] = 0;
    for (l = hemiLength * 3, ll = Math.max(hemiSkyColors.length, hemiCount * 3); l < ll; l++)
      hemiSkyColors[l] = 0;
    for (l = hemiLength * 3, ll = Math.max(hemiGroundColors.length, hemiCount * 3); l < ll; l++)
      hemiGroundColors[l] = 0;
    zlights.directional.length = dirLength;
    zlights.point.length = pointLength;
    zlights.spot.length = spotLength;
    zlights.hemi.length = hemiLength;
    zlights.ambient[0] = r;
    zlights.ambient[1] = g;
    zlights.ambient[2] = b;
  }
  ;
  this.setFaceCulling = function (cullFace, frontFaceDirection) {
    if (cullFace === THREE.CullFaceNone) {
      _gl.disable(_gl.CULL_FACE);
    } else {
      if (frontFaceDirection === THREE.FrontFaceDirectionCW) {
        _gl.frontFace(_gl.CW);
      } else {
        _gl.frontFace(_gl.CCW);
      }
      if (cullFace === THREE.CullFaceBack) {
        _gl.cullFace(_gl.BACK);
      } else if (cullFace === THREE.CullFaceFront) {
        _gl.cullFace(_gl.FRONT);
      } else {
        _gl.cullFace(_gl.FRONT_AND_BACK);
      }
      _gl.enable(_gl.CULL_FACE);
    }
  };
  this.setMaterialFaces = function (material) {
    var doubleSided = material.side === THREE.DoubleSide;
    var flipSided = material.side === THREE.BackSide;
    if (_oldDoubleSided !== doubleSided) {
      if (doubleSided) {
        _gl.disable(_gl.CULL_FACE);
      } else {
        _gl.enable(_gl.CULL_FACE);
      }
      _oldDoubleSided = doubleSided;
    }
    if (_oldFlipSided !== flipSided) {
      if (flipSided) {
        _gl.frontFace(_gl.CW);
      } else {
        _gl.frontFace(_gl.CCW);
      }
      _oldFlipSided = flipSided;
    }
  };
  this.setDepthTest = function (depthTest) {
    if (_oldDepthTest !== depthTest) {
      if (depthTest) {
        _gl.enable(_gl.DEPTH_TEST);
      } else {
        _gl.disable(_gl.DEPTH_TEST);
      }
      _oldDepthTest = depthTest;
    }
  };
  this.setDepthWrite = function (depthWrite) {
    if (_oldDepthWrite !== depthWrite) {
      _gl.depthMask(depthWrite);
      _oldDepthWrite = depthWrite;
    }
  };
  function setLineWidth(width) {
    if (width !== _oldLineWidth) {
      _gl.lineWidth(width);
      _oldLineWidth = width;
    }
  }
  ;
  function setPolygonOffset(polygonoffset, factor, units) {
    if (_oldPolygonOffset !== polygonoffset) {
      if (polygonoffset) {
        _gl.enable(_gl.POLYGON_OFFSET_FILL);
      } else {
        _gl.disable(_gl.POLYGON_OFFSET_FILL);
      }
      _oldPolygonOffset = polygonoffset;
    }
    if (polygonoffset && (_oldPolygonOffsetFactor !== factor || _oldPolygonOffsetUnits !== units)) {
      _gl.polygonOffset(factor, units);
      _oldPolygonOffsetFactor = factor;
      _oldPolygonOffsetUnits = units;
    }
  }
  ;
  this.setBlending = function (blending, blendEquation, blendSrc, blendDst) {
    if (blending !== _oldBlending) {
      if (blending === THREE.NoBlending) {
        _gl.disable(_gl.BLEND);
      } else if (blending === THREE.AdditiveBlending) {
        _gl.enable(_gl.BLEND);
        _gl.blendEquation(_gl.FUNC_ADD);
        _gl.blendFunc(_gl.SRC_ALPHA, _gl.ONE);
      } else if (blending === THREE.SubtractiveBlending) {
        _gl.enable(_gl.BLEND);
        _gl.blendEquation(_gl.FUNC_ADD);
        _gl.blendFunc(_gl.ZERO, _gl.ONE_MINUS_SRC_COLOR);
      } else if (blending === THREE.MultiplyBlending) {
        _gl.enable(_gl.BLEND);
        _gl.blendEquation(_gl.FUNC_ADD);
        _gl.blendFunc(_gl.ZERO, _gl.SRC_COLOR);
      } else if (blending === THREE.CustomBlending) {
        _gl.enable(_gl.BLEND);
      } else {
        _gl.enable(_gl.BLEND);
        _gl.blendEquationSeparate(_gl.FUNC_ADD, _gl.FUNC_ADD);
        _gl.blendFuncSeparate(_gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA, _gl.ONE, _gl.ONE_MINUS_SRC_ALPHA);
      }
      _oldBlending = blending;
    }
    if (blending === THREE.CustomBlending) {
      if (blendEquation !== _oldBlendEquation) {
        _gl.blendEquation(paramThreeToGL(blendEquation));
        _oldBlendEquation = blendEquation;
      }
      if (blendSrc !== _oldBlendSrc || blendDst !== _oldBlendDst) {
        _gl.blendFunc(paramThreeToGL(blendSrc), paramThreeToGL(blendDst));
        _oldBlendSrc = blendSrc;
        _oldBlendDst = blendDst;
      }
    } else {
      _oldBlendEquation = null;
      _oldBlendSrc = null;
      _oldBlendDst = null;
    }
  };
  function generateDefines(defines) {
    var value, chunk, chunks = [];
    for (var d in defines) {
      value = defines[d];
      if (value === false)
        continue;
      chunk = '#define ' + d + ' ' + value;
      chunks.push(chunk);
    }
    return chunks.join('\n');
  }
  ;
  function buildProgram(shaderID, fragmentShader, vertexShader, uniforms, attributes, defines, parameters, index0AttributeName) {
    var p, pl, d, program, code;
    var chunks = [];
    if (shaderID) {
      chunks.push(shaderID);
    } else {
      chunks.push(fragmentShader);
      chunks.push(vertexShader);
    }
    for (d in defines) {
      chunks.push(d);
      chunks.push(defines[d]);
    }
    for (p in parameters) {
      chunks.push(p);
      chunks.push(parameters[p]);
    }
    code = chunks.join();
    for (p = 0, pl = _programs.length; p < pl; p++) {
      var programInfo = _programs[p];
      if (programInfo.code === code) {
        programInfo.usedTimes++;
        return programInfo.program;
      }
    }
    var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';
    if (parameters.shadowMapType === THREE.PCFShadowMap) {
      shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';
    } else if (parameters.shadowMapType === THREE.PCFSoftShadowMap) {
      shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';
    }
    var customDefines = generateDefines(defines);
    program = _gl.createProgram();
    var prefix_vertex = [
        'precision ' + _precision + ' float;',
        'precision ' + _precision + ' int;',
        customDefines,
        _supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',
        _this.gammaInput ? '#define GAMMA_INPUT' : '',
        _this.gammaOutput ? '#define GAMMA_OUTPUT' : '',
        _this.physicallyBasedShading ? '#define PHYSICALLY_BASED_SHADING' : '',
        '#define MAX_DIR_LIGHTS ' + parameters.maxDirLights,
        '#define MAX_POINT_LIGHTS ' + parameters.maxPointLights,
        '#define MAX_SPOT_LIGHTS ' + parameters.maxSpotLights,
        '#define MAX_HEMI_LIGHTS ' + parameters.maxHemiLights,
        '#define MAX_SHADOWS ' + parameters.maxShadows,
        '#define MAX_BONES ' + parameters.maxBones,
        parameters.map ? '#define USE_MAP' : '',
        parameters.envMap ? '#define USE_ENVMAP' : '',
        parameters.lightMap ? '#define USE_LIGHTMAP' : '',
        parameters.bumpMap ? '#define USE_BUMPMAP' : '',
        parameters.normalMap ? '#define USE_NORMALMAP' : '',
        parameters.specularMap ? '#define USE_SPECULARMAP' : '',
        parameters.vertexColors ? '#define USE_COLOR' : '',
        parameters.skinning ? '#define USE_SKINNING' : '',
        parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',
        parameters.boneTextureWidth ? '#define N_BONE_PIXEL_X ' + parameters.boneTextureWidth.toFixed(1) : '',
        parameters.boneTextureHeight ? '#define N_BONE_PIXEL_Y ' + parameters.boneTextureHeight.toFixed(1) : '',
        parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
        parameters.morphNormals ? '#define USE_MORPHNORMALS' : '',
        parameters.perPixel ? '#define PHONG_PER_PIXEL' : '',
        parameters.wrapAround ? '#define WRAP_AROUND' : '',
        parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
        parameters.flipSided ? '#define FLIP_SIDED' : '',
        parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
        parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
        parameters.shadowMapDebug ? '#define SHADOWMAP_DEBUG' : '',
        parameters.shadowMapCascade ? '#define SHADOWMAP_CASCADE' : '',
        parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',
        'uniform mat4 modelMatrix;',
        'uniform mat4 modelViewMatrix;',
        'uniform mat4 projectionMatrix;',
        'uniform mat4 viewMatrix;',
        'uniform mat3 normalMatrix;',
        'uniform vec3 cameraPosition;',
        'attribute vec3 position;',
        'attribute vec3 normal;',
        'attribute vec2 uv;',
        'attribute vec2 uv2;',
        '#ifdef USE_COLOR',
        'attribute vec3 color;',
        '#endif',
        '#ifdef USE_MORPHTARGETS',
        'attribute vec3 morphTarget0;',
        'attribute vec3 morphTarget1;',
        'attribute vec3 morphTarget2;',
        'attribute vec3 morphTarget3;',
        '#ifdef USE_MORPHNORMALS',
        'attribute vec3 morphNormal0;',
        'attribute vec3 morphNormal1;',
        'attribute vec3 morphNormal2;',
        'attribute vec3 morphNormal3;',
        '#else',
        'attribute vec3 morphTarget4;',
        'attribute vec3 morphTarget5;',
        'attribute vec3 morphTarget6;',
        'attribute vec3 morphTarget7;',
        '#endif',
        '#endif',
        '#ifdef USE_SKINNING',
        'attribute vec4 skinIndex;',
        'attribute vec4 skinWeight;',
        '#endif',
        ''
      ].join('\n');
    var prefix_fragment = [
        'precision ' + _precision + ' float;',
        'precision ' + _precision + ' int;',
        parameters.bumpMap || parameters.normalMap ? '#extension GL_OES_standard_derivatives : enable' : '',
        customDefines,
        '#define MAX_DIR_LIGHTS ' + parameters.maxDirLights,
        '#define MAX_POINT_LIGHTS ' + parameters.maxPointLights,
        '#define MAX_SPOT_LIGHTS ' + parameters.maxSpotLights,
        '#define MAX_HEMI_LIGHTS ' + parameters.maxHemiLights,
        '#define MAX_SHADOWS ' + parameters.maxShadows,
        parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',
        _this.gammaInput ? '#define GAMMA_INPUT' : '',
        _this.gammaOutput ? '#define GAMMA_OUTPUT' : '',
        _this.physicallyBasedShading ? '#define PHYSICALLY_BASED_SHADING' : '',
        parameters.useFog && parameters.fog ? '#define USE_FOG' : '',
        parameters.useFog && parameters.fogExp ? '#define FOG_EXP2' : '',
        parameters.map ? '#define USE_MAP' : '',
        parameters.envMap ? '#define USE_ENVMAP' : '',
        parameters.lightMap ? '#define USE_LIGHTMAP' : '',
        parameters.bumpMap ? '#define USE_BUMPMAP' : '',
        parameters.normalMap ? '#define USE_NORMALMAP' : '',
        parameters.specularMap ? '#define USE_SPECULARMAP' : '',
        parameters.vertexColors ? '#define USE_COLOR' : '',
        parameters.metal ? '#define METAL' : '',
        parameters.perPixel ? '#define PHONG_PER_PIXEL' : '',
        parameters.wrapAround ? '#define WRAP_AROUND' : '',
        parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
        parameters.flipSided ? '#define FLIP_SIDED' : '',
        parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
        parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
        parameters.shadowMapDebug ? '#define SHADOWMAP_DEBUG' : '',
        parameters.shadowMapCascade ? '#define SHADOWMAP_CASCADE' : '',
        'uniform mat4 viewMatrix;',
        'uniform vec3 cameraPosition;',
        ''
      ].join('\n');
    var glVertexShader = getShader('vertex', prefix_vertex + vertexShader);
    var glFragmentShader = getShader('fragment', prefix_fragment + fragmentShader);
    _gl.attachShader(program, glVertexShader);
    _gl.attachShader(program, glFragmentShader);
    if (index0AttributeName) {
      _gl.bindAttribLocation(program, 0, index0AttributeName);
    }
    _gl.linkProgram(program);
    if (!_gl.getProgramParameter(program, _gl.LINK_STATUS)) {
      console.error('Could not initialise shader\n' + 'VALIDATE_STATUS: ' + _gl.getProgramParameter(program, _gl.VALIDATE_STATUS) + ', gl error [' + _gl.getError() + ']');
      console.error('Program Info Log: ' + _gl.getProgramInfoLog(program));
    }
    _gl.deleteShader(glFragmentShader);
    _gl.deleteShader(glVertexShader);
    program.uniforms = {};
    program.attributes = {};
    var identifiers, u, a, i;
    identifiers = [
      'viewMatrix',
      'modelViewMatrix',
      'projectionMatrix',
      'normalMatrix',
      'modelMatrix',
      'cameraPosition',
      'morphTargetInfluences'
    ];
    if (parameters.useVertexTexture) {
      identifiers.push('boneTexture');
    } else {
      identifiers.push('boneGlobalMatrices');
    }
    for (u in uniforms) {
      identifiers.push(u);
    }
    cacheUniformLocations(program, identifiers);
    identifiers = [
      'position',
      'normal',
      'uv',
      'uv2',
      'tangent',
      'color',
      'skinIndex',
      'skinWeight',
      'lineDistance'
    ];
    for (i = 0; i < parameters.maxMorphTargets; i++) {
      identifiers.push('morphTarget' + i);
    }
    for (i = 0; i < parameters.maxMorphNormals; i++) {
      identifiers.push('morphNormal' + i);
    }
    for (a in attributes) {
      identifiers.push(a);
    }
    cacheAttributeLocations(program, identifiers);
    program.id = _programs_counter++;
    _programs.push({
      program: program,
      code: code,
      usedTimes: 1
    });
    _this.info.memory.programs = _programs.length;
    return program;
  }
  ;
  function cacheUniformLocations(program, identifiers) {
    var i, l, id;
    for (i = 0, l = identifiers.length; i < l; i++) {
      id = identifiers[i];
      program.uniforms[id] = _gl.getUniformLocation(program, id);
    }
  }
  ;
  function cacheAttributeLocations(program, identifiers) {
    var i, l, id;
    for (i = 0, l = identifiers.length; i < l; i++) {
      id = identifiers[i];
      program.attributes[id] = _gl.getAttribLocation(program, id);
    }
  }
  ;
  function addLineNumbers(string) {
    var chunks = string.split('\n');
    for (var i = 0, il = chunks.length; i < il; i++) {
      chunks[i] = i + 1 + ': ' + chunks[i];
    }
    return chunks.join('\n');
  }
  ;
  function getShader(type, string) {
    var shader;
    if (type === 'fragment') {
      shader = _gl.createShader(_gl.FRAGMENT_SHADER);
    } else if (type === 'vertex') {
      shader = _gl.createShader(_gl.VERTEX_SHADER);
    }
    _gl.shaderSource(shader, string);
    _gl.compileShader(shader);
    if (!_gl.getShaderParameter(shader, _gl.COMPILE_STATUS)) {
      console.error(_gl.getShaderInfoLog(shader));
      console.error(addLineNumbers(string));
      return null;
    }
    return shader;
  }
  ;
  function isPowerOfTwo(value) {
    return (value & value - 1) === 0;
  }
  ;
  function setTextureParameters(textureType, texture, isImagePowerOfTwo) {
    if (isImagePowerOfTwo) {
      _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL(texture.wrapS));
      _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL(texture.wrapT));
      _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL(texture.magFilter));
      _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL(texture.minFilter));
    } else {
      _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE);
      _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE);
      _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterFallback(texture.magFilter));
      _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterFallback(texture.minFilter));
    }
    if (_glExtensionTextureFilterAnisotropic && texture.type !== THREE.FloatType) {
      if (texture.anisotropy > 1 || texture.__oldAnisotropy) {
        _gl.texParameterf(textureType, _glExtensionTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, _maxAnisotropy));
        texture.__oldAnisotropy = texture.anisotropy;
      }
    }
  }
  ;
  this.setTexture = function (texture, slot) {
    if (texture.needsUpdate) {
      if (!texture.__webglInit) {
        texture.__webglInit = true;
        texture.addEventListener('dispose', onTextureDispose);
        texture.__webglTexture = _gl.createTexture();
        _this.info.memory.textures++;
      }
      _gl.activeTexture(_gl.TEXTURE0 + slot);
      _gl.bindTexture(_gl.TEXTURE_2D, texture.__webglTexture);
      _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
      _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);
      _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);
      var image = texture.image, isImagePowerOfTwo = isPowerOfTwo(image.width) && isPowerOfTwo(image.height), glFormat = paramThreeToGL(texture.format), glType = paramThreeToGL(texture.type);
      setTextureParameters(_gl.TEXTURE_2D, texture, isImagePowerOfTwo);
      var mipmap, mipmaps = texture.mipmaps;
      if (texture instanceof THREE.DataTexture) {
        if (mipmaps.length > 0 && isImagePowerOfTwo) {
          for (var i = 0, il = mipmaps.length; i < il; i++) {
            mipmap = mipmaps[i];
            _gl.texImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
          }
          texture.generateMipmaps = false;
        } else {
          _gl.texImage2D(_gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data);
        }
      } else if (texture instanceof THREE.CompressedTexture) {
        for (var i = 0, il = mipmaps.length; i < il; i++) {
          mipmap = mipmaps[i];
          _gl.compressedTexImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data);
        }
      } else {
        if (mipmaps.length > 0 && isImagePowerOfTwo) {
          for (var i = 0, il = mipmaps.length; i < il; i++) {
            mipmap = mipmaps[i];
            _gl.texImage2D(_gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap);
          }
          texture.generateMipmaps = false;
        } else {
          _gl.texImage2D(_gl.TEXTURE_2D, 0, glFormat, glFormat, glType, texture.image);
        }
      }
      if (texture.generateMipmaps && isImagePowerOfTwo)
        _gl.generateMipmap(_gl.TEXTURE_2D);
      texture.needsUpdate = false;
      if (texture.onUpdate)
        texture.onUpdate();
    } else {
      _gl.activeTexture(_gl.TEXTURE0 + slot);
      _gl.bindTexture(_gl.TEXTURE_2D, texture.__webglTexture);
    }
  };
  function clampToMaxSize(image, maxSize) {
    if (image.width <= maxSize && image.height <= maxSize) {
      return image;
    }
    var maxDimension = Math.max(image.width, image.height);
    var newWidth = Math.floor(image.width * maxSize / maxDimension);
    var newHeight = Math.floor(image.height * maxSize / maxDimension);
    var canvas = document.createElement('canvas');
    canvas.width = newWidth;
    canvas.height = newHeight;
    var ctx = canvas.getContext('2d');
    ctx.drawImage(image, 0, 0, image.width, image.height, 0, 0, newWidth, newHeight);
    return canvas;
  }
  function setCubeTexture(texture, slot) {
    if (texture.image.length === 6) {
      if (texture.needsUpdate) {
        if (!texture.image.__webglTextureCube) {
          texture.addEventListener('dispose', onTextureDispose);
          texture.image.__webglTextureCube = _gl.createTexture();
          _this.info.memory.textures++;
        }
        _gl.activeTexture(_gl.TEXTURE0 + slot);
        _gl.bindTexture(_gl.TEXTURE_CUBE_MAP, texture.image.__webglTextureCube);
        _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
        var isCompressed = texture instanceof THREE.CompressedTexture;
        var cubeImage = [];
        for (var i = 0; i < 6; i++) {
          if (_this.autoScaleCubemaps && !isCompressed) {
            cubeImage[i] = clampToMaxSize(texture.image[i], _maxCubemapSize);
          } else {
            cubeImage[i] = texture.image[i];
          }
        }
        var image = cubeImage[0], isImagePowerOfTwo = isPowerOfTwo(image.width) && isPowerOfTwo(image.height), glFormat = paramThreeToGL(texture.format), glType = paramThreeToGL(texture.type);
        setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, isImagePowerOfTwo);
        for (var i = 0; i < 6; i++) {
          if (isCompressed) {
            var mipmap, mipmaps = cubeImage[i].mipmaps;
            for (var j = 0, jl = mipmaps.length; j < jl; j++) {
              mipmap = mipmaps[j];
              _gl.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data);
            }
          } else {
            _gl.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[i]);
          }
        }
        if (texture.generateMipmaps && isImagePowerOfTwo) {
          _gl.generateMipmap(_gl.TEXTURE_CUBE_MAP);
        }
        texture.needsUpdate = false;
        if (texture.onUpdate)
          texture.onUpdate();
      } else {
        _gl.activeTexture(_gl.TEXTURE0 + slot);
        _gl.bindTexture(_gl.TEXTURE_CUBE_MAP, texture.image.__webglTextureCube);
      }
    }
  }
  ;
  function setCubeTextureDynamic(texture, slot) {
    _gl.activeTexture(_gl.TEXTURE0 + slot);
    _gl.bindTexture(_gl.TEXTURE_CUBE_MAP, texture.__webglTexture);
  }
  ;
  function setupFrameBuffer(framebuffer, renderTarget, textureTarget) {
    _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
    _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureTarget, renderTarget.__webglTexture, 0);
  }
  ;
  function setupRenderBuffer(renderbuffer, renderTarget) {
    _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);
    if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
      _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height);
      _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
    } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
      _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height);
      _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
    } else {
      _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height);
    }
  }
  ;
  this.setRenderTarget = function (renderTarget) {
    var isCube = renderTarget instanceof THREE.WebGLRenderTargetCube;
    if (renderTarget && !renderTarget.__webglFramebuffer) {
      if (renderTarget.depthBuffer === undefined)
        renderTarget.depthBuffer = true;
      if (renderTarget.stencilBuffer === undefined)
        renderTarget.stencilBuffer = true;
      renderTarget.addEventListener('dispose', onRenderTargetDispose);
      renderTarget.__webglTexture = _gl.createTexture();
      _this.info.memory.textures++;
      var isTargetPowerOfTwo = isPowerOfTwo(renderTarget.width) && isPowerOfTwo(renderTarget.height), glFormat = paramThreeToGL(renderTarget.format), glType = paramThreeToGL(renderTarget.type);
      if (isCube) {
        renderTarget.__webglFramebuffer = [];
        renderTarget.__webglRenderbuffer = [];
        _gl.bindTexture(_gl.TEXTURE_CUBE_MAP, renderTarget.__webglTexture);
        setTextureParameters(_gl.TEXTURE_CUBE_MAP, renderTarget, isTargetPowerOfTwo);
        for (var i = 0; i < 6; i++) {
          renderTarget.__webglFramebuffer[i] = _gl.createFramebuffer();
          renderTarget.__webglRenderbuffer[i] = _gl.createRenderbuffer();
          _gl.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
          setupFrameBuffer(renderTarget.__webglFramebuffer[i], renderTarget, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i);
          setupRenderBuffer(renderTarget.__webglRenderbuffer[i], renderTarget);
        }
        if (isTargetPowerOfTwo)
          _gl.generateMipmap(_gl.TEXTURE_CUBE_MAP);
      } else {
        renderTarget.__webglFramebuffer = _gl.createFramebuffer();
        if (renderTarget.shareDepthFrom) {
          renderTarget.__webglRenderbuffer = renderTarget.shareDepthFrom.__webglRenderbuffer;
        } else {
          renderTarget.__webglRenderbuffer = _gl.createRenderbuffer();
        }
        _gl.bindTexture(_gl.TEXTURE_2D, renderTarget.__webglTexture);
        setTextureParameters(_gl.TEXTURE_2D, renderTarget, isTargetPowerOfTwo);
        _gl.texImage2D(_gl.TEXTURE_2D, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
        setupFrameBuffer(renderTarget.__webglFramebuffer, renderTarget, _gl.TEXTURE_2D);
        if (renderTarget.shareDepthFrom) {
          if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
            _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderTarget.__webglRenderbuffer);
          } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
            _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderTarget.__webglRenderbuffer);
          }
        } else {
          setupRenderBuffer(renderTarget.__webglRenderbuffer, renderTarget);
        }
        if (isTargetPowerOfTwo)
          _gl.generateMipmap(_gl.TEXTURE_2D);
      }
      if (isCube) {
        _gl.bindTexture(_gl.TEXTURE_CUBE_MAP, null);
      } else {
        _gl.bindTexture(_gl.TEXTURE_2D, null);
      }
      _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
      _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
    }
    var framebuffer, width, height, vx, vy;
    if (renderTarget) {
      if (isCube) {
        framebuffer = renderTarget.__webglFramebuffer[renderTarget.activeCubeFace];
      } else {
        framebuffer = renderTarget.__webglFramebuffer;
      }
      width = renderTarget.width;
      height = renderTarget.height;
      vx = 0;
      vy = 0;
    } else {
      framebuffer = null;
      width = _viewportWidth;
      height = _viewportHeight;
      vx = _viewportX;
      vy = _viewportY;
    }
    if (framebuffer !== _currentFramebuffer) {
      _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
      _gl.viewport(vx, vy, width, height);
      _currentFramebuffer = framebuffer;
    }
    _currentWidth = width;
    _currentHeight = height;
  };
  function updateRenderTargetMipmap(renderTarget) {
    if (renderTarget instanceof THREE.WebGLRenderTargetCube) {
      _gl.bindTexture(_gl.TEXTURE_CUBE_MAP, renderTarget.__webglTexture);
      _gl.generateMipmap(_gl.TEXTURE_CUBE_MAP);
      _gl.bindTexture(_gl.TEXTURE_CUBE_MAP, null);
    } else {
      _gl.bindTexture(_gl.TEXTURE_2D, renderTarget.__webglTexture);
      _gl.generateMipmap(_gl.TEXTURE_2D);
      _gl.bindTexture(_gl.TEXTURE_2D, null);
    }
  }
  ;
  function filterFallback(f) {
    if (f === THREE.NearestFilter || f === THREE.NearestMipMapNearestFilter || f === THREE.NearestMipMapLinearFilter) {
      return _gl.NEAREST;
    }
    return _gl.LINEAR;
  }
  ;
  function paramThreeToGL(p) {
    if (p === THREE.RepeatWrapping)
      return _gl.REPEAT;
    if (p === THREE.ClampToEdgeWrapping)
      return _gl.CLAMP_TO_EDGE;
    if (p === THREE.MirroredRepeatWrapping)
      return _gl.MIRRORED_REPEAT;
    if (p === THREE.NearestFilter)
      return _gl.NEAREST;
    if (p === THREE.NearestMipMapNearestFilter)
      return _gl.NEAREST_MIPMAP_NEAREST;
    if (p === THREE.NearestMipMapLinearFilter)
      return _gl.NEAREST_MIPMAP_LINEAR;
    if (p === THREE.LinearFilter)
      return _gl.LINEAR;
    if (p === THREE.LinearMipMapNearestFilter)
      return _gl.LINEAR_MIPMAP_NEAREST;
    if (p === THREE.LinearMipMapLinearFilter)
      return _gl.LINEAR_MIPMAP_LINEAR;
    if (p === THREE.UnsignedByteType)
      return _gl.UNSIGNED_BYTE;
    if (p === THREE.UnsignedShort4444Type)
      return _gl.UNSIGNED_SHORT_4_4_4_4;
    if (p === THREE.UnsignedShort5551Type)
      return _gl.UNSIGNED_SHORT_5_5_5_1;
    if (p === THREE.UnsignedShort565Type)
      return _gl.UNSIGNED_SHORT_5_6_5;
    if (p === THREE.ByteType)
      return _gl.BYTE;
    if (p === THREE.ShortType)
      return _gl.SHORT;
    if (p === THREE.UnsignedShortType)
      return _gl.UNSIGNED_SHORT;
    if (p === THREE.IntType)
      return _gl.INT;
    if (p === THREE.UnsignedIntType)
      return _gl.UNSIGNED_INT;
    if (p === THREE.FloatType)
      return _gl.FLOAT;
    if (p === THREE.AlphaFormat)
      return _gl.ALPHA;
    if (p === THREE.RGBFormat)
      return _gl.RGB;
    if (p === THREE.RGBAFormat)
      return _gl.RGBA;
    if (p === THREE.LuminanceFormat)
      return _gl.LUMINANCE;
    if (p === THREE.LuminanceAlphaFormat)
      return _gl.LUMINANCE_ALPHA;
    if (p === THREE.AddEquation)
      return _gl.FUNC_ADD;
    if (p === THREE.SubtractEquation)
      return _gl.FUNC_SUBTRACT;
    if (p === THREE.ReverseSubtractEquation)
      return _gl.FUNC_REVERSE_SUBTRACT;
    if (p === THREE.ZeroFactor)
      return _gl.ZERO;
    if (p === THREE.OneFactor)
      return _gl.ONE;
    if (p === THREE.SrcColorFactor)
      return _gl.SRC_COLOR;
    if (p === THREE.OneMinusSrcColorFactor)
      return _gl.ONE_MINUS_SRC_COLOR;
    if (p === THREE.SrcAlphaFactor)
      return _gl.SRC_ALPHA;
    if (p === THREE.OneMinusSrcAlphaFactor)
      return _gl.ONE_MINUS_SRC_ALPHA;
    if (p === THREE.DstAlphaFactor)
      return _gl.DST_ALPHA;
    if (p === THREE.OneMinusDstAlphaFactor)
      return _gl.ONE_MINUS_DST_ALPHA;
    if (p === THREE.DstColorFactor)
      return _gl.DST_COLOR;
    if (p === THREE.OneMinusDstColorFactor)
      return _gl.ONE_MINUS_DST_COLOR;
    if (p === THREE.SrcAlphaSaturateFactor)
      return _gl.SRC_ALPHA_SATURATE;
    if (_glExtensionCompressedTextureS3TC !== undefined) {
      if (p === THREE.RGB_S3TC_DXT1_Format)
        return _glExtensionCompressedTextureS3TC.COMPRESSED_RGB_S3TC_DXT1_EXT;
      if (p === THREE.RGBA_S3TC_DXT1_Format)
        return _glExtensionCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT1_EXT;
      if (p === THREE.RGBA_S3TC_DXT3_Format)
        return _glExtensionCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT3_EXT;
      if (p === THREE.RGBA_S3TC_DXT5_Format)
        return _glExtensionCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT5_EXT;
    }
    return 0;
  }
  ;
  function allocateBones(object) {
    if (_supportsBoneTextures && object && object.useVertexTexture) {
      return 1024;
    } else {
      var nVertexUniforms = _gl.getParameter(_gl.MAX_VERTEX_UNIFORM_VECTORS);
      var nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);
      var maxBones = nVertexMatrices;
      if (object !== undefined && object instanceof THREE.SkinnedMesh) {
        maxBones = Math.min(object.bones.length, maxBones);
        if (maxBones < object.bones.length) {
          console.warn('WebGLRenderer: too many bones - ' + object.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)');
        }
      }
      return maxBones;
    }
  }
  ;
  function allocateLights(lights) {
    var dirLights = 0;
    var pointLights = 0;
    var spotLights = 0;
    var hemiLights = 0;
    for (var l = 0, ll = lights.length; l < ll; l++) {
      var light = lights[l];
      if (light.onlyShadow)
        continue;
      if (light instanceof THREE.DirectionalLight)
        dirLights++;
      if (light instanceof THREE.PointLight)
        pointLights++;
      if (light instanceof THREE.SpotLight)
        spotLights++;
      if (light instanceof THREE.HemisphereLight)
        hemiLights++;
    }
    return {
      'directional': dirLights,
      'point': pointLights,
      'spot': spotLights,
      'hemi': hemiLights
    };
  }
  ;
  function allocateShadows(lights) {
    var maxShadows = 0;
    for (var l = 0, ll = lights.length; l < ll; l++) {
      var light = lights[l];
      if (!light.castShadow)
        continue;
      if (light instanceof THREE.SpotLight)
        maxShadows++;
      if (light instanceof THREE.DirectionalLight && !light.shadowCascade)
        maxShadows++;
    }
    return maxShadows;
  }
  ;
  function initGL() {
    try {
      var attributes = {
          alpha: _alpha,
          premultipliedAlpha: _premultipliedAlpha,
          antialias: _antialias,
          stencil: _stencil,
          preserveDrawingBuffer: _preserveDrawingBuffer
        };
      _gl = _canvas.getContext('webgl', attributes) || _canvas.getContext('experimental-webgl', attributes);
      if (_gl === null) {
        throw 'Error creating WebGL context.';
      }
    } catch (error) {
      console.error(error);
    }
    _glExtensionTextureFloat = _gl.getExtension('OES_texture_float');
    _glExtensionTextureFloatLinear = _gl.getExtension('OES_texture_float_linear');
    _glExtensionStandardDerivatives = _gl.getExtension('OES_standard_derivatives');
    _glExtensionTextureFilterAnisotropic = _gl.getExtension('EXT_texture_filter_anisotropic') || _gl.getExtension('MOZ_EXT_texture_filter_anisotropic') || _gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
    _glExtensionCompressedTextureS3TC = _gl.getExtension('WEBGL_compressed_texture_s3tc') || _gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc') || _gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
    if (!_glExtensionTextureFloat) {
      console.log('THREE.WebGLRenderer: Float textures not supported.');
    }
    if (!_glExtensionStandardDerivatives) {
      console.log('THREE.WebGLRenderer: Standard derivatives not supported.');
    }
    if (!_glExtensionTextureFilterAnisotropic) {
      console.log('THREE.WebGLRenderer: Anisotropic texture filtering not supported.');
    }
    if (!_glExtensionCompressedTextureS3TC) {
      console.log('THREE.WebGLRenderer: S3TC compressed textures not supported.');
    }
    if (_gl.getShaderPrecisionFormat === undefined) {
      _gl.getShaderPrecisionFormat = function () {
        return {
          'rangeMin': 1,
          'rangeMax': 1,
          'precision': 1
        };
      };
    }
  }
  ;
  function setDefaultGLState() {
    _gl.clearColor(0, 0, 0, 1);
    _gl.clearDepth(1);
    _gl.clearStencil(0);
    _gl.enable(_gl.DEPTH_TEST);
    _gl.depthFunc(_gl.LEQUAL);
    _gl.frontFace(_gl.CCW);
    _gl.cullFace(_gl.BACK);
    _gl.enable(_gl.CULL_FACE);
    _gl.enable(_gl.BLEND);
    _gl.blendEquation(_gl.FUNC_ADD);
    _gl.blendFunc(_gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA);
    _gl.clearColor(_clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha);
  }
  ;
  this.shadowMapPlugin = new THREE.ShadowMapPlugin();
  this.addPrePlugin(this.shadowMapPlugin);
  this.addPostPlugin(new THREE.SpritePlugin());
  this.addPostPlugin(new THREE.LensFlarePlugin());
};
THREE.WebGLRenderTarget = function (width, height, options) {
  this.width = width;
  this.height = height;
  options = options || {};
  this.wrapS = options.wrapS !== undefined ? options.wrapS : THREE.ClampToEdgeWrapping;
  this.wrapT = options.wrapT !== undefined ? options.wrapT : THREE.ClampToEdgeWrapping;
  this.magFilter = options.magFilter !== undefined ? options.magFilter : THREE.LinearFilter;
  this.minFilter = options.minFilter !== undefined ? options.minFilter : THREE.LinearMipMapLinearFilter;
  this.anisotropy = options.anisotropy !== undefined ? options.anisotropy : 1;
  this.offset = new THREE.Vector2(0, 0);
  this.repeat = new THREE.Vector2(1, 1);
  this.format = options.format !== undefined ? options.format : THREE.RGBAFormat;
  this.type = options.type !== undefined ? options.type : THREE.UnsignedByteType;
  this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
  this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;
  this.generateMipmaps = true;
  this.shareDepthFrom = null;
};
THREE.WebGLRenderTarget.prototype = {
  constructor: THREE.WebGLRenderTarget,
  clone: function () {
    var tmp = new THREE.WebGLRenderTarget(this.width, this.height);
    tmp.wrapS = this.wrapS;
    tmp.wrapT = this.wrapT;
    tmp.magFilter = this.magFilter;
    tmp.minFilter = this.minFilter;
    tmp.anisotropy = this.anisotropy;
    tmp.offset.copy(this.offset);
    tmp.repeat.copy(this.repeat);
    tmp.format = this.format;
    tmp.type = this.type;
    tmp.depthBuffer = this.depthBuffer;
    tmp.stencilBuffer = this.stencilBuffer;
    tmp.generateMipmaps = this.generateMipmaps;
    tmp.shareDepthFrom = this.shareDepthFrom;
    return tmp;
  },
  dispose: function () {
    this.dispatchEvent({ type: 'dispose' });
  }
};
THREE.EventDispatcher.prototype.apply(THREE.WebGLRenderTarget.prototype);
THREE.WebGLRenderTargetCube = function (width, height, options) {
  THREE.WebGLRenderTarget.call(this, width, height, options);
  this.activeCubeFace = 0;
};
THREE.WebGLRenderTargetCube.prototype = Object.create(THREE.WebGLRenderTarget.prototype);
THREE.RenderableVertex = function () {
  this.positionWorld = new THREE.Vector3();
  this.positionScreen = new THREE.Vector4();
  this.visible = true;
};
THREE.RenderableVertex.prototype.copy = function (vertex) {
  this.positionWorld.copy(vertex.positionWorld);
  this.positionScreen.copy(vertex.positionScreen);
};
THREE.RenderableFace3 = function () {
  this.id = 0;
  this.v1 = new THREE.RenderableVertex();
  this.v2 = new THREE.RenderableVertex();
  this.v3 = new THREE.RenderableVertex();
  this.centroidModel = new THREE.Vector3();
  this.normalModel = new THREE.Vector3();
  this.normalModelView = new THREE.Vector3();
  this.vertexNormalsLength = 0;
  this.vertexNormalsModel = [
    new THREE.Vector3(),
    new THREE.Vector3(),
    new THREE.Vector3()
  ];
  this.vertexNormalsModelView = [
    new THREE.Vector3(),
    new THREE.Vector3(),
    new THREE.Vector3()
  ];
  this.color = null;
  this.material = null;
  this.uvs = [[]];
  this.z = 0;
};
THREE.RenderableObject = function () {
  this.id = 0;
  this.object = null;
  this.z = 0;
};
THREE.RenderableParticle = function () {
  this.id = 0;
  this.object = null;
  this.x = 0;
  this.y = 0;
  this.z = 0;
  this.rotation = null;
  this.scale = new THREE.Vector2();
  this.material = null;
};
THREE.RenderableLine = function () {
  this.id = 0;
  this.v1 = new THREE.RenderableVertex();
  this.v2 = new THREE.RenderableVertex();
  this.vertexColors = [
    new THREE.Color(),
    new THREE.Color()
  ];
  this.material = null;
  this.z = 0;
};
THREE.GeometryUtils = {
  merge: function (geometry1, object2, materialIndexOffset) {
    var matrix, normalMatrix, vertexOffset = geometry1.vertices.length, uvPosition = geometry1.faceVertexUvs[0].length, geometry2 = object2 instanceof THREE.Mesh ? object2.geometry : object2, vertices1 = geometry1.vertices, vertices2 = geometry2.vertices, faces1 = geometry1.faces, faces2 = geometry2.faces, uvs1 = geometry1.faceVertexUvs[0], uvs2 = geometry2.faceVertexUvs[0];
    if (materialIndexOffset === undefined)
      materialIndexOffset = 0;
    if (object2 instanceof THREE.Mesh) {
      object2.matrixAutoUpdate && object2.updateMatrix();
      matrix = object2.matrix;
      normalMatrix = new THREE.Matrix3().getNormalMatrix(matrix);
    }
    for (var i = 0, il = vertices2.length; i < il; i++) {
      var vertex = vertices2[i];
      var vertexCopy = vertex.clone();
      if (matrix)
        vertexCopy.applyMatrix4(matrix);
      vertices1.push(vertexCopy);
    }
    for (i = 0, il = faces2.length; i < il; i++) {
      var face = faces2[i], faceCopy, normal, color, faceVertexNormals = face.vertexNormals, faceVertexColors = face.vertexColors;
      faceCopy = new THREE.Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);
      faceCopy.normal.copy(face.normal);
      if (normalMatrix) {
        faceCopy.normal.applyMatrix3(normalMatrix).normalize();
      }
      for (var j = 0, jl = faceVertexNormals.length; j < jl; j++) {
        normal = faceVertexNormals[j].clone();
        if (normalMatrix) {
          normal.applyMatrix3(normalMatrix).normalize();
        }
        faceCopy.vertexNormals.push(normal);
      }
      faceCopy.color.copy(face.color);
      for (var j = 0, jl = faceVertexColors.length; j < jl; j++) {
        color = faceVertexColors[j];
        faceCopy.vertexColors.push(color.clone());
      }
      faceCopy.materialIndex = face.materialIndex + materialIndexOffset;
      faceCopy.centroid.copy(face.centroid);
      if (matrix) {
        faceCopy.centroid.applyMatrix4(matrix);
      }
      faces1.push(faceCopy);
    }
    for (i = 0, il = uvs2.length; i < il; i++) {
      var uv = uvs2[i], uvCopy = [];
      for (var j = 0, jl = uv.length; j < jl; j++) {
        uvCopy.push(new THREE.Vector2(uv[j].x, uv[j].y));
      }
      uvs1.push(uvCopy);
    }
  },
  randomPointInTriangle: function () {
    var vector = new THREE.Vector3();
    return function (vectorA, vectorB, vectorC) {
      var point = new THREE.Vector3();
      var a = THREE.Math.random16();
      var b = THREE.Math.random16();
      if (a + b > 1) {
        a = 1 - a;
        b = 1 - b;
      }
      var c = 1 - a - b;
      point.copy(vectorA);
      point.multiplyScalar(a);
      vector.copy(vectorB);
      vector.multiplyScalar(b);
      point.add(vector);
      vector.copy(vectorC);
      vector.multiplyScalar(c);
      point.add(vector);
      return point;
    };
  }(),
  randomPointInFace: function (face, geometry, useCachedAreas) {
    var vA, vB, vC, vD;
    vA = geometry.vertices[face.a];
    vB = geometry.vertices[face.b];
    vC = geometry.vertices[face.c];
    return THREE.GeometryUtils.randomPointInTriangle(vA, vB, vC);
  },
  randomPointsInGeometry: function (geometry, n) {
    var face, i, faces = geometry.faces, vertices = geometry.vertices, il = faces.length, totalArea = 0, cumulativeAreas = [], vA, vB, vC, vD;
    for (i = 0; i < il; i++) {
      face = faces[i];
      vA = vertices[face.a];
      vB = vertices[face.b];
      vC = vertices[face.c];
      face._area = THREE.GeometryUtils.triangleArea(vA, vB, vC);
      totalArea += face._area;
      cumulativeAreas[i] = totalArea;
    }
    function binarySearchIndices(value) {
      function binarySearch(start, end) {
        if (end < start)
          return start;
        var mid = start + Math.floor((end - start) / 2);
        if (cumulativeAreas[mid] > value) {
          return binarySearch(start, mid - 1);
        } else if (cumulativeAreas[mid] < value) {
          return binarySearch(mid + 1, end);
        } else {
          return mid;
        }
      }
      var result = binarySearch(0, cumulativeAreas.length - 1);
      return result;
    }
    var r, index, result = [];
    var stats = {};
    for (i = 0; i < n; i++) {
      r = THREE.Math.random16() * totalArea;
      index = binarySearchIndices(r);
      result[i] = THREE.GeometryUtils.randomPointInFace(faces[index], geometry, true);
      if (!stats[index]) {
        stats[index] = 1;
      } else {
        stats[index] += 1;
      }
    }
    return result;
  },
  triangleArea: function () {
    var vector1 = new THREE.Vector3();
    var vector2 = new THREE.Vector3();
    return function (vectorA, vectorB, vectorC) {
      vector1.subVectors(vectorB, vectorA);
      vector2.subVectors(vectorC, vectorA);
      vector1.cross(vector2);
      return 0.5 * vector1.length();
    };
  }(),
  center: function (geometry) {
    geometry.computeBoundingBox();
    var bb = geometry.boundingBox;
    var offset = new THREE.Vector3();
    offset.addVectors(bb.min, bb.max);
    offset.multiplyScalar(-0.5);
    geometry.applyMatrix(new THREE.Matrix4().makeTranslation(offset.x, offset.y, offset.z));
    geometry.computeBoundingBox();
    return offset;
  },
  triangulateQuads: function (geometry) {
    var i, il, j, jl;
    var faces = [];
    var faceVertexUvs = [];
    for (i = 0, il = geometry.faceVertexUvs.length; i < il; i++) {
      faceVertexUvs[i] = [];
    }
    for (i = 0, il = geometry.faces.length; i < il; i++) {
      var face = geometry.faces[i];
      faces.push(face);
      for (j = 0, jl = geometry.faceVertexUvs.length; j < jl; j++) {
        faceVertexUvs[j].push(geometry.faceVertexUvs[j][i]);
      }
    }
    geometry.faces = faces;
    geometry.faceVertexUvs = faceVertexUvs;
    geometry.computeCentroids();
    geometry.computeFaceNormals();
    geometry.computeVertexNormals();
    if (geometry.hasTangents)
      geometry.computeTangents();
  }
};
THREE.ImageUtils = {
  crossOrigin: 'anonymous',
  loadTexture: function (url, mapping, onLoad, onError) {
    var image = new Image();
    var texture = new THREE.Texture(image, mapping);
    var loader = new THREE.ImageLoader();
    loader.crossOrigin = this.crossOrigin;
    loader.load(url, function (image) {
      texture.image = image;
      texture.needsUpdate = true;
      if (onLoad)
        onLoad(texture);
    });
    texture.sourceFile = url;
    return texture;
  },
  loadCompressedTexture: function (url, mapping, onLoad, onError) {
    var texture = new THREE.CompressedTexture();
    texture.mapping = mapping;
    var request = new XMLHttpRequest();
    request.onload = function () {
      var buffer = request.response;
      var dds = THREE.ImageUtils.parseDDS(buffer, true);
      texture.format = dds.format;
      texture.mipmaps = dds.mipmaps;
      texture.image.width = dds.width;
      texture.image.height = dds.height;
      texture.generateMipmaps = false;
      texture.needsUpdate = true;
      if (onLoad)
        onLoad(texture);
    };
    request.onerror = onError;
    request.open('GET', url, true);
    request.responseType = 'arraybuffer';
    request.send(null);
    return texture;
  },
  loadTextureCube: function (array, mapping, onLoad, onError) {
    var images = [];
    images.loadCount = 0;
    var texture = new THREE.Texture();
    texture.image = images;
    if (mapping !== undefined)
      texture.mapping = mapping;
    texture.flipY = false;
    for (var i = 0, il = array.length; i < il; ++i) {
      var cubeImage = new Image();
      images[i] = cubeImage;
      cubeImage.onload = function () {
        images.loadCount += 1;
        if (images.loadCount === 6) {
          texture.needsUpdate = true;
          if (onLoad)
            onLoad(texture);
        }
      };
      cubeImage.onerror = onError;
      cubeImage.crossOrigin = this.crossOrigin;
      cubeImage.src = array[i];
    }
    return texture;
  },
  loadCompressedTextureCube: function (array, mapping, onLoad, onError) {
    var images = [];
    images.loadCount = 0;
    var texture = new THREE.CompressedTexture();
    texture.image = images;
    if (mapping !== undefined)
      texture.mapping = mapping;
    texture.flipY = false;
    texture.generateMipmaps = false;
    var generateCubeFaceCallback = function (rq, img) {
      return function () {
        var buffer = rq.response;
        var dds = THREE.ImageUtils.parseDDS(buffer, true);
        img.format = dds.format;
        img.mipmaps = dds.mipmaps;
        img.width = dds.width;
        img.height = dds.height;
        images.loadCount += 1;
        if (images.loadCount === 6) {
          texture.format = dds.format;
          texture.needsUpdate = true;
          if (onLoad)
            onLoad(texture);
        }
      };
    };
    if (array instanceof Array) {
      for (var i = 0, il = array.length; i < il; ++i) {
        var cubeImage = {};
        images[i] = cubeImage;
        var request = new XMLHttpRequest();
        request.onload = generateCubeFaceCallback(request, cubeImage);
        request.onerror = onError;
        var url = array[i];
        request.open('GET', url, true);
        request.responseType = 'arraybuffer';
        request.send(null);
      }
    } else {
      var url = array;
      var request = new XMLHttpRequest();
      request.onload = function () {
        var buffer = request.response;
        var dds = THREE.ImageUtils.parseDDS(buffer, true);
        if (dds.isCubemap) {
          var faces = dds.mipmaps.length / dds.mipmapCount;
          for (var f = 0; f < faces; f++) {
            images[f] = { mipmaps: [] };
            for (var i = 0; i < dds.mipmapCount; i++) {
              images[f].mipmaps.push(dds.mipmaps[f * dds.mipmapCount + i]);
              images[f].format = dds.format;
              images[f].width = dds.width;
              images[f].height = dds.height;
            }
          }
          texture.format = dds.format;
          texture.needsUpdate = true;
          if (onLoad)
            onLoad(texture);
        }
      };
      request.onerror = onError;
      request.open('GET', url, true);
      request.responseType = 'arraybuffer';
      request.send(null);
    }
    return texture;
  },
  parseDDS: function (buffer, loadMipmaps) {
    var dds = {
        mipmaps: [],
        width: 0,
        height: 0,
        format: null,
        mipmapCount: 1
      };
    var DDS_MAGIC = 542327876;
    var DDSD_CAPS = 1, DDSD_HEIGHT = 2, DDSD_WIDTH = 4, DDSD_PITCH = 8, DDSD_PIXELFORMAT = 4096, DDSD_MIPMAPCOUNT = 131072, DDSD_LINEARSIZE = 524288, DDSD_DEPTH = 8388608;
    var DDSCAPS_COMPLEX = 8, DDSCAPS_MIPMAP = 4194304, DDSCAPS_TEXTURE = 4096;
    var DDSCAPS2_CUBEMAP = 512, DDSCAPS2_CUBEMAP_POSITIVEX = 1024, DDSCAPS2_CUBEMAP_NEGATIVEX = 2048, DDSCAPS2_CUBEMAP_POSITIVEY = 4096, DDSCAPS2_CUBEMAP_NEGATIVEY = 8192, DDSCAPS2_CUBEMAP_POSITIVEZ = 16384, DDSCAPS2_CUBEMAP_NEGATIVEZ = 32768, DDSCAPS2_VOLUME = 2097152;
    var DDPF_ALPHAPIXELS = 1, DDPF_ALPHA = 2, DDPF_FOURCC = 4, DDPF_RGB = 64, DDPF_YUV = 512, DDPF_LUMINANCE = 131072;
    function fourCCToInt32(value) {
      return value.charCodeAt(0) + (value.charCodeAt(1) << 8) + (value.charCodeAt(2) << 16) + (value.charCodeAt(3) << 24);
    }
    function int32ToFourCC(value) {
      return String.fromCharCode(value & 255, value >> 8 & 255, value >> 16 & 255, value >> 24 & 255);
    }
    var FOURCC_DXT1 = fourCCToInt32('DXT1');
    var FOURCC_DXT3 = fourCCToInt32('DXT3');
    var FOURCC_DXT5 = fourCCToInt32('DXT5');
    var headerLengthInt = 31;
    var off_magic = 0;
    var off_size = 1;
    var off_flags = 2;
    var off_height = 3;
    var off_width = 4;
    var off_mipmapCount = 7;
    var off_pfFlags = 20;
    var off_pfFourCC = 21;
    var off_caps = 27;
    var off_caps2 = 28;
    var off_caps3 = 29;
    var off_caps4 = 30;
    var header = new Int32Array(buffer, 0, headerLengthInt);
    if (header[off_magic] !== DDS_MAGIC) {
      console.error('ImageUtils.parseDDS(): Invalid magic number in DDS header');
      return dds;
    }
    if (!header[off_pfFlags] & DDPF_FOURCC) {
      console.error('ImageUtils.parseDDS(): Unsupported format, must contain a FourCC code');
      return dds;
    }
    var blockBytes;
    var fourCC = header[off_pfFourCC];
    switch (fourCC) {
    case FOURCC_DXT1:
      blockBytes = 8;
      dds.format = THREE.RGB_S3TC_DXT1_Format;
      break;
    case FOURCC_DXT3:
      blockBytes = 16;
      dds.format = THREE.RGBA_S3TC_DXT3_Format;
      break;
    case FOURCC_DXT5:
      blockBytes = 16;
      dds.format = THREE.RGBA_S3TC_DXT5_Format;
      break;
    default:
      console.error('ImageUtils.parseDDS(): Unsupported FourCC code: ', int32ToFourCC(fourCC));
      return dds;
    }
    dds.mipmapCount = 1;
    if (header[off_flags] & DDSD_MIPMAPCOUNT && loadMipmaps !== false) {
      dds.mipmapCount = Math.max(1, header[off_mipmapCount]);
    }
    dds.isCubemap = header[off_caps2] & DDSCAPS2_CUBEMAP ? true : false;
    dds.width = header[off_width];
    dds.height = header[off_height];
    var dataOffset = header[off_size] + 4;
    var width = dds.width;
    var height = dds.height;
    var faces = dds.isCubemap ? 6 : 1;
    for (var face = 0; face < faces; face++) {
      for (var i = 0; i < dds.mipmapCount; i++) {
        var dataLength = Math.max(4, width) / 4 * Math.max(4, height) / 4 * blockBytes;
        var byteArray = new Uint8Array(buffer, dataOffset, dataLength);
        var mipmap = {
            'data': byteArray,
            'width': width,
            'height': height
          };
        dds.mipmaps.push(mipmap);
        dataOffset += dataLength;
        width = Math.max(width * 0.5, 1);
        height = Math.max(height * 0.5, 1);
      }
      width = dds.width;
      height = dds.height;
    }
    return dds;
  },
  getNormalMap: function (image, depth) {
    var cross = function (a, b) {
      return [
        a[1] * b[2] - a[2] * b[1],
        a[2] * b[0] - a[0] * b[2],
        a[0] * b[1] - a[1] * b[0]
      ];
    };
    var subtract = function (a, b) {
      return [
        a[0] - b[0],
        a[1] - b[1],
        a[2] - b[2]
      ];
    };
    var normalize = function (a) {
      var l = Math.sqrt(a[0] * a[0] + a[1] * a[1] + a[2] * a[2]);
      return [
        a[0] / l,
        a[1] / l,
        a[2] / l
      ];
    };
    depth = depth | 1;
    var width = image.width;
    var height = image.height;
    var canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    var context = canvas.getContext('2d');
    context.drawImage(image, 0, 0);
    var data = context.getImageData(0, 0, width, height).data;
    var imageData = context.createImageData(width, height);
    var output = imageData.data;
    for (var x = 0; x < width; x++) {
      for (var y = 0; y < height; y++) {
        var ly = y - 1 < 0 ? 0 : y - 1;
        var uy = y + 1 > height - 1 ? height - 1 : y + 1;
        var lx = x - 1 < 0 ? 0 : x - 1;
        var ux = x + 1 > width - 1 ? width - 1 : x + 1;
        var points = [];
        var origin = [
            0,
            0,
            data[(y * width + x) * 4] / 255 * depth
          ];
        points.push([
          -1,
          0,
          data[(y * width + lx) * 4] / 255 * depth
        ]);
        points.push([
          -1,
          -1,
          data[(ly * width + lx) * 4] / 255 * depth
        ]);
        points.push([
          0,
          -1,
          data[(ly * width + x) * 4] / 255 * depth
        ]);
        points.push([
          1,
          -1,
          data[(ly * width + ux) * 4] / 255 * depth
        ]);
        points.push([
          1,
          0,
          data[(y * width + ux) * 4] / 255 * depth
        ]);
        points.push([
          1,
          1,
          data[(uy * width + ux) * 4] / 255 * depth
        ]);
        points.push([
          0,
          1,
          data[(uy * width + x) * 4] / 255 * depth
        ]);
        points.push([
          -1,
          1,
          data[(uy * width + lx) * 4] / 255 * depth
        ]);
        var normals = [];
        var num_points = points.length;
        for (var i = 0; i < num_points; i++) {
          var v1 = points[i];
          var v2 = points[(i + 1) % num_points];
          v1 = subtract(v1, origin);
          v2 = subtract(v2, origin);
          normals.push(normalize(cross(v1, v2)));
        }
        var normal = [
            0,
            0,
            0
          ];
        for (var i = 0; i < normals.length; i++) {
          normal[0] += normals[i][0];
          normal[1] += normals[i][1];
          normal[2] += normals[i][2];
        }
        normal[0] /= normals.length;
        normal[1] /= normals.length;
        normal[2] /= normals.length;
        var idx = (y * width + x) * 4;
        output[idx] = (normal[0] + 1) / 2 * 255 | 0;
        output[idx + 1] = (normal[1] + 1) / 2 * 255 | 0;
        output[idx + 2] = normal[2] * 255 | 0;
        output[idx + 3] = 255;
      }
    }
    context.putImageData(imageData, 0, 0);
    return canvas;
  },
  generateDataTexture: function (width, height, color) {
    var size = width * height;
    var data = new Uint8Array(3 * size);
    var r = Math.floor(color.r * 255);
    var g = Math.floor(color.g * 255);
    var b = Math.floor(color.b * 255);
    for (var i = 0; i < size; i++) {
      data[i * 3] = r;
      data[i * 3 + 1] = g;
      data[i * 3 + 2] = b;
    }
    var texture = new THREE.DataTexture(data, width, height, THREE.RGBFormat);
    texture.needsUpdate = true;
    return texture;
  }
};
THREE.SceneUtils = {
  createMultiMaterialObject: function (geometry, materials) {
    var group = new THREE.Object3D();
    for (var i = 0, l = materials.length; i < l; i++) {
      group.add(new THREE.Mesh(geometry, materials[i]));
    }
    return group;
  },
  detach: function (child, parent, scene) {
    child.applyMatrix(parent.matrixWorld);
    parent.remove(child);
    scene.add(child);
  },
  attach: function (child, scene, parent) {
    var matrixWorldInverse = new THREE.Matrix4();
    matrixWorldInverse.getInverse(parent.matrixWorld);
    child.applyMatrix(matrixWorldInverse);
    scene.remove(child);
    parent.add(child);
  }
};
THREE.FontUtils = {
  faces: {},
  face: 'helvetiker',
  weight: 'normal',
  style: 'normal',
  size: 150,
  divisions: 10,
  getFace: function () {
    return this.faces[this.face][this.weight][this.style];
  },
  loadFace: function (data) {
    var family = data.familyName.toLowerCase();
    var ThreeFont = this;
    ThreeFont.faces[family] = ThreeFont.faces[family] || {};
    ThreeFont.faces[family][data.cssFontWeight] = ThreeFont.faces[family][data.cssFontWeight] || {};
    ThreeFont.faces[family][data.cssFontWeight][data.cssFontStyle] = data;
    var face = ThreeFont.faces[family][data.cssFontWeight][data.cssFontStyle] = data;
    return data;
  },
  drawText: function (text) {
    var characterPts = [], allPts = [];
    var i, p, face = this.getFace(), scale = this.size / face.resolution, offset = 0, chars = String(text).split(''), length = chars.length;
    var fontPaths = [];
    for (i = 0; i < length; i++) {
      var path = new THREE.Path();
      var ret = this.extractGlyphPoints(chars[i], face, scale, offset, path);
      offset += ret.offset;
      fontPaths.push(ret.path);
    }
    var width = offset / 2;
    return {
      paths: fontPaths,
      offset: width
    };
  },
  extractGlyphPoints: function (c, face, scale, offset, path) {
    var pts = [];
    var i, i2, divisions, outline, action, length, scaleX, scaleY, x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2, laste, glyph = face.glyphs[c] || face.glyphs['?'];
    if (!glyph)
      return;
    if (glyph.o) {
      outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(' '));
      length = outline.length;
      scaleX = scale;
      scaleY = scale;
      for (i = 0; i < length;) {
        action = outline[i++];
        switch (action) {
        case 'm':
          x = outline[i++] * scaleX + offset;
          y = outline[i++] * scaleY;
          path.moveTo(x, y);
          break;
        case 'l':
          x = outline[i++] * scaleX + offset;
          y = outline[i++] * scaleY;
          path.lineTo(x, y);
          break;
        case 'q':
          cpx = outline[i++] * scaleX + offset;
          cpy = outline[i++] * scaleY;
          cpx1 = outline[i++] * scaleX + offset;
          cpy1 = outline[i++] * scaleY;
          path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);
          laste = pts[pts.length - 1];
          if (laste) {
            cpx0 = laste.x;
            cpy0 = laste.y;
            for (i2 = 1, divisions = this.divisions; i2 <= divisions; i2++) {
              var t = i2 / divisions;
              var tx = THREE.Shape.Utils.b2(t, cpx0, cpx1, cpx);
              var ty = THREE.Shape.Utils.b2(t, cpy0, cpy1, cpy);
            }
          }
          break;
        case 'b':
          cpx = outline[i++] * scaleX + offset;
          cpy = outline[i++] * scaleY;
          cpx1 = outline[i++] * scaleX + offset;
          cpy1 = outline[i++] * -scaleY;
          cpx2 = outline[i++] * scaleX + offset;
          cpy2 = outline[i++] * -scaleY;
          path.bezierCurveTo(cpx, cpy, cpx1, cpy1, cpx2, cpy2);
          laste = pts[pts.length - 1];
          if (laste) {
            cpx0 = laste.x;
            cpy0 = laste.y;
            for (i2 = 1, divisions = this.divisions; i2 <= divisions; i2++) {
              var t = i2 / divisions;
              var tx = THREE.Shape.Utils.b3(t, cpx0, cpx1, cpx2, cpx);
              var ty = THREE.Shape.Utils.b3(t, cpy0, cpy1, cpy2, cpy);
            }
          }
          break;
        }
      }
    }
    return {
      offset: glyph.ha * scale,
      path: path
    };
  }
};
THREE.FontUtils.generateShapes = function (text, parameters) {
  parameters = parameters || {};
  var size = parameters.size !== undefined ? parameters.size : 100;
  var curveSegments = parameters.curveSegments !== undefined ? parameters.curveSegments : 4;
  var font = parameters.font !== undefined ? parameters.font : 'helvetiker';
  var weight = parameters.weight !== undefined ? parameters.weight : 'normal';
  var style = parameters.style !== undefined ? parameters.style : 'normal';
  THREE.FontUtils.size = size;
  THREE.FontUtils.divisions = curveSegments;
  THREE.FontUtils.face = font;
  THREE.FontUtils.weight = weight;
  THREE.FontUtils.style = style;
  var data = THREE.FontUtils.drawText(text);
  var paths = data.paths;
  var shapes = [];
  for (var p = 0, pl = paths.length; p < pl; p++) {
    Array.prototype.push.apply(shapes, paths[p].toShapes());
  }
  return shapes;
};
(function (namespace) {
  var EPSILON = 1e-10;
  var process = function (contour, indices) {
    var n = contour.length;
    if (n < 3)
      return null;
    var result = [], verts = [], vertIndices = [];
    var u, v, w;
    if (area(contour) > 0) {
      for (v = 0; v < n; v++)
        verts[v] = v;
    } else {
      for (v = 0; v < n; v++)
        verts[v] = n - 1 - v;
    }
    var nv = n;
    var count = 2 * nv;
    for (v = nv - 1; nv > 2;) {
      if (count-- <= 0) {
        console.log('Warning, unable to triangulate polygon!');
        if (indices)
          return vertIndices;
        return result;
      }
      u = v;
      if (nv <= u)
        u = 0;
      v = u + 1;
      if (nv <= v)
        v = 0;
      w = v + 1;
      if (nv <= w)
        w = 0;
      if (snip(contour, u, v, w, nv, verts)) {
        var a, b, c, s, t;
        a = verts[u];
        b = verts[v];
        c = verts[w];
        result.push([
          contour[a],
          contour[b],
          contour[c]
        ]);
        vertIndices.push([
          verts[u],
          verts[v],
          verts[w]
        ]);
        for (s = v, t = v + 1; t < nv; s++, t++) {
          verts[s] = verts[t];
        }
        nv--;
        count = 2 * nv;
      }
    }
    if (indices)
      return vertIndices;
    return result;
  };
  var area = function (contour) {
    var n = contour.length;
    var a = 0;
    for (var p = n - 1, q = 0; q < n; p = q++) {
      a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
    }
    return a * 0.5;
  };
  var snip = function (contour, u, v, w, n, verts) {
    var p;
    var ax, ay, bx, by;
    var cx, cy, px, py;
    ax = contour[verts[u]].x;
    ay = contour[verts[u]].y;
    bx = contour[verts[v]].x;
    by = contour[verts[v]].y;
    cx = contour[verts[w]].x;
    cy = contour[verts[w]].y;
    if (EPSILON > (bx - ax) * (cy - ay) - (by - ay) * (cx - ax))
      return false;
    var aX, aY, bX, bY, cX, cY;
    var apx, apy, bpx, bpy, cpx, cpy;
    var cCROSSap, bCROSScp, aCROSSbp;
    aX = cx - bx;
    aY = cy - by;
    bX = ax - cx;
    bY = ay - cy;
    cX = bx - ax;
    cY = by - ay;
    for (p = 0; p < n; p++) {
      if (p === u || p === v || p === w)
        continue;
      px = contour[verts[p]].x;
      py = contour[verts[p]].y;
      apx = px - ax;
      apy = py - ay;
      bpx = px - bx;
      bpy = py - by;
      cpx = px - cx;
      cpy = py - cy;
      aCROSSbp = aX * bpy - aY * bpx;
      cCROSSap = cX * apy - cY * apx;
      bCROSScp = bX * cpy - bY * cpx;
      if (aCROSSbp >= -EPSILON && bCROSScp >= -EPSILON && cCROSSap >= -EPSILON)
        return false;
    }
    return true;
  };
  namespace.Triangulate = process;
  namespace.Triangulate.area = area;
  return namespace;
}(THREE.FontUtils));
self._typeface_js = {
  faces: THREE.FontUtils.faces,
  loadFace: THREE.FontUtils.loadFace
};
THREE.typeface_js = self._typeface_js;
THREE.Curve = function () {
};
THREE.Curve.prototype.getPoint = function (t) {
  console.log('Warning, getPoint() not implemented!');
  return null;
};
THREE.Curve.prototype.getPointAt = function (u) {
  var t = this.getUtoTmapping(u);
  return this.getPoint(t);
};
THREE.Curve.prototype.getPoints = function (divisions) {
  if (!divisions)
    divisions = 5;
  var d, pts = [];
  for (d = 0; d <= divisions; d++) {
    pts.push(this.getPoint(d / divisions));
  }
  return pts;
};
THREE.Curve.prototype.getSpacedPoints = function (divisions) {
  if (!divisions)
    divisions = 5;
  var d, pts = [];
  for (d = 0; d <= divisions; d++) {
    pts.push(this.getPointAt(d / divisions));
  }
  return pts;
};
THREE.Curve.prototype.getLength = function () {
  var lengths = this.getLengths();
  return lengths[lengths.length - 1];
};
THREE.Curve.prototype.getLengths = function (divisions) {
  if (!divisions)
    divisions = this.__arcLengthDivisions ? this.__arcLengthDivisions : 200;
  if (this.cacheArcLengths && this.cacheArcLengths.length == divisions + 1 && !this.needsUpdate) {
    return this.cacheArcLengths;
  }
  this.needsUpdate = false;
  var cache = [];
  var current, last = this.getPoint(0);
  var p, sum = 0;
  cache.push(0);
  for (p = 1; p <= divisions; p++) {
    current = this.getPoint(p / divisions);
    sum += current.distanceTo(last);
    cache.push(sum);
    last = current;
  }
  this.cacheArcLengths = cache;
  return cache;
};
THREE.Curve.prototype.updateArcLengths = function () {
  this.needsUpdate = true;
  this.getLengths();
};
THREE.Curve.prototype.getUtoTmapping = function (u, distance) {
  var arcLengths = this.getLengths();
  var i = 0, il = arcLengths.length;
  var targetArcLength;
  if (distance) {
    targetArcLength = distance;
  } else {
    targetArcLength = u * arcLengths[il - 1];
  }
  var low = 0, high = il - 1, comparison;
  while (low <= high) {
    i = Math.floor(low + (high - low) / 2);
    comparison = arcLengths[i] - targetArcLength;
    if (comparison < 0) {
      low = i + 1;
      continue;
    } else if (comparison > 0) {
      high = i - 1;
      continue;
    } else {
      high = i;
      break;
    }
  }
  i = high;
  if (arcLengths[i] == targetArcLength) {
    var t = i / (il - 1);
    return t;
  }
  var lengthBefore = arcLengths[i];
  var lengthAfter = arcLengths[i + 1];
  var segmentLength = lengthAfter - lengthBefore;
  var segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
  var t = (i + segmentFraction) / (il - 1);
  return t;
};
THREE.Curve.prototype.getTangent = function (t) {
  var delta = 0.0001;
  var t1 = t - delta;
  var t2 = t + delta;
  if (t1 < 0)
    t1 = 0;
  if (t2 > 1)
    t2 = 1;
  var pt1 = this.getPoint(t1);
  var pt2 = this.getPoint(t2);
  var vec = pt2.clone().sub(pt1);
  return vec.normalize();
};
THREE.Curve.prototype.getTangentAt = function (u) {
  var t = this.getUtoTmapping(u);
  return this.getTangent(t);
};
THREE.Curve.Utils = {
  tangentQuadraticBezier: function (t, p0, p1, p2) {
    return 2 * (1 - t) * (p1 - p0) + 2 * t * (p2 - p1);
  },
  tangentCubicBezier: function (t, p0, p1, p2, p3) {
    return -3 * p0 * (1 - t) * (1 - t) + 3 * p1 * (1 - t) * (1 - t) - 6 * t * p1 * (1 - t) + 6 * t * p2 * (1 - t) - 3 * t * t * p2 + 3 * t * t * p3;
  },
  tangentSpline: function (t, p0, p1, p2, p3) {
    var h00 = 6 * t * t - 6 * t;
    var h10 = 3 * t * t - 4 * t + 1;
    var h01 = -6 * t * t + 6 * t;
    var h11 = 3 * t * t - 2 * t;
    return h00 + h10 + h01 + h11;
  },
  interpolate: function (p0, p1, p2, p3, t) {
    var v0 = (p2 - p0) * 0.5;
    var v1 = (p3 - p1) * 0.5;
    var t2 = t * t;
    var t3 = t * t2;
    return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
  }
};
THREE.Curve.create = function (constructor, getPointFunc) {
  constructor.prototype = Object.create(THREE.Curve.prototype);
  constructor.prototype.getPoint = getPointFunc;
  return constructor;
};
THREE.CurvePath = function () {
  this.curves = [];
  this.bends = [];
  this.autoClose = false;
};
THREE.CurvePath.prototype = Object.create(THREE.Curve.prototype);
THREE.CurvePath.prototype.add = function (curve) {
  this.curves.push(curve);
};
THREE.CurvePath.prototype.checkConnection = function () {
};
THREE.CurvePath.prototype.closePath = function () {
  var startPoint = this.curves[0].getPoint(0);
  var endPoint = this.curves[this.curves.length - 1].getPoint(1);
  if (!startPoint.equals(endPoint)) {
    this.curves.push(new THREE.LineCurve(endPoint, startPoint));
  }
};
THREE.CurvePath.prototype.getPoint = function (t) {
  var d = t * this.getLength();
  var curveLengths = this.getCurveLengths();
  var i = 0, diff, curve;
  while (i < curveLengths.length) {
    if (curveLengths[i] >= d) {
      diff = curveLengths[i] - d;
      curve = this.curves[i];
      var u = 1 - diff / curve.getLength();
      return curve.getPointAt(u);
      break;
    }
    i++;
  }
  return null;
};
THREE.CurvePath.prototype.getLength = function () {
  var lens = this.getCurveLengths();
  return lens[lens.length - 1];
};
THREE.CurvePath.prototype.getCurveLengths = function () {
  if (this.cacheLengths && this.cacheLengths.length == this.curves.length) {
    return this.cacheLengths;
  }
  ;
  var lengths = [], sums = 0;
  var i, il = this.curves.length;
  for (i = 0; i < il; i++) {
    sums += this.curves[i].getLength();
    lengths.push(sums);
  }
  this.cacheLengths = lengths;
  return lengths;
};
THREE.CurvePath.prototype.getBoundingBox = function () {
  var points = this.getPoints();
  var maxX, maxY, maxZ;
  var minX, minY, minZ;
  maxX = maxY = Number.NEGATIVE_INFINITY;
  minX = minY = Number.POSITIVE_INFINITY;
  var p, i, il, sum;
  var v3 = points[0] instanceof THREE.Vector3;
  sum = v3 ? new THREE.Vector3() : new THREE.Vector2();
  for (i = 0, il = points.length; i < il; i++) {
    p = points[i];
    if (p.x > maxX)
      maxX = p.x;
    else if (p.x < minX)
      minX = p.x;
    if (p.y > maxY)
      maxY = p.y;
    else if (p.y < minY)
      minY = p.y;
    if (v3) {
      if (p.z > maxZ)
        maxZ = p.z;
      else if (p.z < minZ)
        minZ = p.z;
    }
    sum.add(p);
  }
  var ret = {
      minX: minX,
      minY: minY,
      maxX: maxX,
      maxY: maxY,
      centroid: sum.divideScalar(il)
    };
  if (v3) {
    ret.maxZ = maxZ;
    ret.minZ = minZ;
  }
  return ret;
};
THREE.CurvePath.prototype.createPointsGeometry = function (divisions) {
  var pts = this.getPoints(divisions, true);
  return this.createGeometry(pts);
};
THREE.CurvePath.prototype.createSpacedPointsGeometry = function (divisions) {
  var pts = this.getSpacedPoints(divisions, true);
  return this.createGeometry(pts);
};
THREE.CurvePath.prototype.createGeometry = function (points) {
  var geometry = new THREE.Geometry();
  for (var i = 0; i < points.length; i++) {
    geometry.vertices.push(new THREE.Vector3(points[i].x, points[i].y, points[i].z || 0));
  }
  return geometry;
};
THREE.CurvePath.prototype.addWrapPath = function (bendpath) {
  this.bends.push(bendpath);
};
THREE.CurvePath.prototype.getTransformedPoints = function (segments, bends) {
  var oldPts = this.getPoints(segments);
  var i, il;
  if (!bends) {
    bends = this.bends;
  }
  for (i = 0, il = bends.length; i < il; i++) {
    oldPts = this.getWrapPoints(oldPts, bends[i]);
  }
  return oldPts;
};
THREE.CurvePath.prototype.getTransformedSpacedPoints = function (segments, bends) {
  var oldPts = this.getSpacedPoints(segments);
  var i, il;
  if (!bends) {
    bends = this.bends;
  }
  for (i = 0, il = bends.length; i < il; i++) {
    oldPts = this.getWrapPoints(oldPts, bends[i]);
  }
  return oldPts;
};
THREE.CurvePath.prototype.getWrapPoints = function (oldPts, path) {
  var bounds = this.getBoundingBox();
  var i, il, p, oldX, oldY, xNorm;
  for (i = 0, il = oldPts.length; i < il; i++) {
    p = oldPts[i];
    oldX = p.x;
    oldY = p.y;
    xNorm = oldX / bounds.maxX;
    xNorm = path.getUtoTmapping(xNorm, oldX);
    var pathPt = path.getPoint(xNorm);
    var normal = path.getNormalVector(xNorm).multiplyScalar(oldY);
    p.x = pathPt.x + normal.x;
    p.y = pathPt.y + normal.y;
  }
  return oldPts;
};
THREE.Gyroscope = function () {
  THREE.Object3D.call(this);
};
THREE.Gyroscope.prototype = Object.create(THREE.Object3D.prototype);
THREE.Gyroscope.prototype.updateMatrixWorld = function (force) {
  this.matrixAutoUpdate && this.updateMatrix();
  if (this.matrixWorldNeedsUpdate || force) {
    if (this.parent) {
      this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
      this.matrixWorld.decompose(this.translationWorld, this.quaternionWorld, this.scaleWorld);
      this.matrix.decompose(this.translationObject, this.quaternionObject, this.scaleObject);
      this.matrixWorld.compose(this.translationWorld, this.quaternionObject, this.scaleWorld);
    } else {
      this.matrixWorld.copy(this.matrix);
    }
    this.matrixWorldNeedsUpdate = false;
    force = true;
  }
  for (var i = 0, l = this.children.length; i < l; i++) {
    this.children[i].updateMatrixWorld(force);
  }
};
THREE.Gyroscope.prototype.translationWorld = new THREE.Vector3();
THREE.Gyroscope.prototype.translationObject = new THREE.Vector3();
THREE.Gyroscope.prototype.quaternionWorld = new THREE.Quaternion();
THREE.Gyroscope.prototype.quaternionObject = new THREE.Quaternion();
THREE.Gyroscope.prototype.scaleWorld = new THREE.Vector3();
THREE.Gyroscope.prototype.scaleObject = new THREE.Vector3();
THREE.Path = function (points) {
  THREE.CurvePath.call(this);
  this.actions = [];
  if (points) {
    this.fromPoints(points);
  }
};
THREE.Path.prototype = Object.create(THREE.CurvePath.prototype);
THREE.PathActions = {
  MOVE_TO: 'moveTo',
  LINE_TO: 'lineTo',
  QUADRATIC_CURVE_TO: 'quadraticCurveTo',
  BEZIER_CURVE_TO: 'bezierCurveTo',
  CSPLINE_THRU: 'splineThru',
  ARC: 'arc',
  ELLIPSE: 'ellipse'
};
THREE.Path.prototype.fromPoints = function (vectors) {
  this.moveTo(vectors[0].x, vectors[0].y);
  for (var v = 1, vlen = vectors.length; v < vlen; v++) {
    this.lineTo(vectors[v].x, vectors[v].y);
  }
  ;
};
THREE.Path.prototype.moveTo = function (x, y) {
  var args = Array.prototype.slice.call(arguments);
  this.actions.push({
    action: THREE.PathActions.MOVE_TO,
    args: args
  });
};
THREE.Path.prototype.lineTo = function (x, y) {
  var args = Array.prototype.slice.call(arguments);
  var lastargs = this.actions[this.actions.length - 1].args;
  var x0 = lastargs[lastargs.length - 2];
  var y0 = lastargs[lastargs.length - 1];
  var curve = new THREE.LineCurve(new THREE.Vector2(x0, y0), new THREE.Vector2(x, y));
  this.curves.push(curve);
  this.actions.push({
    action: THREE.PathActions.LINE_TO,
    args: args
  });
};
THREE.Path.prototype.quadraticCurveTo = function (aCPx, aCPy, aX, aY) {
  var args = Array.prototype.slice.call(arguments);
  var lastargs = this.actions[this.actions.length - 1].args;
  var x0 = lastargs[lastargs.length - 2];
  var y0 = lastargs[lastargs.length - 1];
  var curve = new THREE.QuadraticBezierCurve(new THREE.Vector2(x0, y0), new THREE.Vector2(aCPx, aCPy), new THREE.Vector2(aX, aY));
  this.curves.push(curve);
  this.actions.push({
    action: THREE.PathActions.QUADRATIC_CURVE_TO,
    args: args
  });
};
THREE.Path.prototype.bezierCurveTo = function (aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
  var args = Array.prototype.slice.call(arguments);
  var lastargs = this.actions[this.actions.length - 1].args;
  var x0 = lastargs[lastargs.length - 2];
  var y0 = lastargs[lastargs.length - 1];
  var curve = new THREE.CubicBezierCurve(new THREE.Vector2(x0, y0), new THREE.Vector2(aCP1x, aCP1y), new THREE.Vector2(aCP2x, aCP2y), new THREE.Vector2(aX, aY));
  this.curves.push(curve);
  this.actions.push({
    action: THREE.PathActions.BEZIER_CURVE_TO,
    args: args
  });
};
THREE.Path.prototype.splineThru = function (pts) {
  var args = Array.prototype.slice.call(arguments);
  var lastargs = this.actions[this.actions.length - 1].args;
  var x0 = lastargs[lastargs.length - 2];
  var y0 = lastargs[lastargs.length - 1];
  var npts = [new THREE.Vector2(x0, y0)];
  Array.prototype.push.apply(npts, pts);
  var curve = new THREE.SplineCurve(npts);
  this.curves.push(curve);
  this.actions.push({
    action: THREE.PathActions.CSPLINE_THRU,
    args: args
  });
};
THREE.Path.prototype.arc = function (aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
  var lastargs = this.actions[this.actions.length - 1].args;
  var x0 = lastargs[lastargs.length - 2];
  var y0 = lastargs[lastargs.length - 1];
  this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);
};
THREE.Path.prototype.absarc = function (aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
  this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
};
THREE.Path.prototype.ellipse = function (aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise) {
  var lastargs = this.actions[this.actions.length - 1].args;
  var x0 = lastargs[lastargs.length - 2];
  var y0 = lastargs[lastargs.length - 1];
  this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise);
};
THREE.Path.prototype.absellipse = function (aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise) {
  var args = Array.prototype.slice.call(arguments);
  var curve = new THREE.EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise);
  this.curves.push(curve);
  var lastPoint = curve.getPoint(aClockwise ? 1 : 0);
  args.push(lastPoint.x);
  args.push(lastPoint.y);
  this.actions.push({
    action: THREE.PathActions.ELLIPSE,
    args: args
  });
};
THREE.Path.prototype.getSpacedPoints = function (divisions, closedPath) {
  if (!divisions)
    divisions = 40;
  var points = [];
  for (var i = 0; i < divisions; i++) {
    points.push(this.getPoint(i / divisions));
  }
  return points;
};
THREE.Path.prototype.getPoints = function (divisions, closedPath) {
  if (this.useSpacedPoints) {
    console.log('tata');
    return this.getSpacedPoints(divisions, closedPath);
  }
  divisions = divisions || 12;
  var points = [];
  var i, il, item, action, args;
  var cpx, cpy, cpx2, cpy2, cpx1, cpy1, cpx0, cpy0, laste, j, t, tx, ty;
  for (i = 0, il = this.actions.length; i < il; i++) {
    item = this.actions[i];
    action = item.action;
    args = item.args;
    switch (action) {
    case THREE.PathActions.MOVE_TO:
      points.push(new THREE.Vector2(args[0], args[1]));
      break;
    case THREE.PathActions.LINE_TO:
      points.push(new THREE.Vector2(args[0], args[1]));
      break;
    case THREE.PathActions.QUADRATIC_CURVE_TO:
      cpx = args[2];
      cpy = args[3];
      cpx1 = args[0];
      cpy1 = args[1];
      if (points.length > 0) {
        laste = points[points.length - 1];
        cpx0 = laste.x;
        cpy0 = laste.y;
      } else {
        laste = this.actions[i - 1].args;
        cpx0 = laste[laste.length - 2];
        cpy0 = laste[laste.length - 1];
      }
      for (j = 1; j <= divisions; j++) {
        t = j / divisions;
        tx = THREE.Shape.Utils.b2(t, cpx0, cpx1, cpx);
        ty = THREE.Shape.Utils.b2(t, cpy0, cpy1, cpy);
        points.push(new THREE.Vector2(tx, ty));
      }
      break;
    case THREE.PathActions.BEZIER_CURVE_TO:
      cpx = args[4];
      cpy = args[5];
      cpx1 = args[0];
      cpy1 = args[1];
      cpx2 = args[2];
      cpy2 = args[3];
      if (points.length > 0) {
        laste = points[points.length - 1];
        cpx0 = laste.x;
        cpy0 = laste.y;
      } else {
        laste = this.actions[i - 1].args;
        cpx0 = laste[laste.length - 2];
        cpy0 = laste[laste.length - 1];
      }
      for (j = 1; j <= divisions; j++) {
        t = j / divisions;
        tx = THREE.Shape.Utils.b3(t, cpx0, cpx1, cpx2, cpx);
        ty = THREE.Shape.Utils.b3(t, cpy0, cpy1, cpy2, cpy);
        points.push(new THREE.Vector2(tx, ty));
      }
      break;
    case THREE.PathActions.CSPLINE_THRU:
      laste = this.actions[i - 1].args;
      var last = new THREE.Vector2(laste[laste.length - 2], laste[laste.length - 1]);
      var spts = [last];
      var n = divisions * args[0].length;
      spts = spts.concat(args[0]);
      var spline = new THREE.SplineCurve(spts);
      for (j = 1; j <= n; j++) {
        points.push(spline.getPointAt(j / n));
      }
      break;
    case THREE.PathActions.ARC:
      var aX = args[0], aY = args[1], aRadius = args[2], aStartAngle = args[3], aEndAngle = args[4], aClockwise = !!args[5];
      var deltaAngle = aEndAngle - aStartAngle;
      var angle;
      var tdivisions = divisions * 2;
      for (j = 1; j <= tdivisions; j++) {
        t = j / tdivisions;
        if (!aClockwise) {
          t = 1 - t;
        }
        angle = aStartAngle + t * deltaAngle;
        tx = aX + aRadius * Math.cos(angle);
        ty = aY + aRadius * Math.sin(angle);
        points.push(new THREE.Vector2(tx, ty));
      }
      break;
    case THREE.PathActions.ELLIPSE:
      var aX = args[0], aY = args[1], xRadius = args[2], yRadius = args[3], aStartAngle = args[4], aEndAngle = args[5], aClockwise = !!args[6];
      var deltaAngle = aEndAngle - aStartAngle;
      var angle;
      var tdivisions = divisions * 2;
      for (j = 1; j <= tdivisions; j++) {
        t = j / tdivisions;
        if (!aClockwise) {
          t = 1 - t;
        }
        angle = aStartAngle + t * deltaAngle;
        tx = aX + xRadius * Math.cos(angle);
        ty = aY + yRadius * Math.sin(angle);
        points.push(new THREE.Vector2(tx, ty));
      }
      break;
    }
  }
  var lastPoint = points[points.length - 1];
  var EPSILON = 1e-10;
  if (Math.abs(lastPoint.x - points[0].x) < EPSILON && Math.abs(lastPoint.y - points[0].y) < EPSILON)
    points.splice(points.length - 1, 1);
  if (closedPath) {
    points.push(points[0]);
  }
  return points;
};
THREE.Path.prototype.toShapes = function (isCCW) {
  var i, il, item, action, args;
  var subPaths = [], lastPath = new THREE.Path();
  for (i = 0, il = this.actions.length; i < il; i++) {
    item = this.actions[i];
    args = item.args;
    action = item.action;
    if (action == THREE.PathActions.MOVE_TO) {
      if (lastPath.actions.length != 0) {
        subPaths.push(lastPath);
        lastPath = new THREE.Path();
      }
    }
    lastPath[action].apply(lastPath, args);
  }
  if (lastPath.actions.length != 0) {
    subPaths.push(lastPath);
  }
  if (subPaths.length == 0)
    return [];
  var solid, tmpPath, tmpShape, shapes = [];
  if (subPaths.length == 1) {
    tmpPath = subPaths[0];
    tmpShape = new THREE.Shape();
    tmpShape.actions = tmpPath.actions;
    tmpShape.curves = tmpPath.curves;
    shapes.push(tmpShape);
    return shapes;
  }
  var holesFirst = !THREE.Shape.Utils.isClockWise(subPaths[0].getPoints());
  holesFirst = isCCW ? !holesFirst : holesFirst;
  if (holesFirst) {
    tmpShape = new THREE.Shape();
    for (i = 0, il = subPaths.length; i < il; i++) {
      tmpPath = subPaths[i];
      solid = THREE.Shape.Utils.isClockWise(tmpPath.getPoints());
      solid = isCCW ? !solid : solid;
      if (solid) {
        tmpShape.actions = tmpPath.actions;
        tmpShape.curves = tmpPath.curves;
        shapes.push(tmpShape);
        tmpShape = new THREE.Shape();
      } else {
        tmpShape.holes.push(tmpPath);
      }
    }
  } else {
    tmpShape = undefined;
    for (i = 0, il = subPaths.length; i < il; i++) {
      tmpPath = subPaths[i];
      solid = THREE.Shape.Utils.isClockWise(tmpPath.getPoints());
      solid = isCCW ? !solid : solid;
      if (solid) {
        if (tmpShape)
          shapes.push(tmpShape);
        tmpShape = new THREE.Shape();
        tmpShape.actions = tmpPath.actions;
        tmpShape.curves = tmpPath.curves;
      } else {
        tmpShape.holes.push(tmpPath);
      }
    }
    shapes.push(tmpShape);
  }
  return shapes;
};
THREE.Shape = function () {
  THREE.Path.apply(this, arguments);
  this.holes = [];
};
THREE.Shape.prototype = Object.create(THREE.Path.prototype);
THREE.Shape.prototype.extrude = function (options) {
  var extruded = new THREE.ExtrudeGeometry(this, options);
  return extruded;
};
THREE.Shape.prototype.makeGeometry = function (options) {
  var geometry = new THREE.ShapeGeometry(this, options);
  return geometry;
};
THREE.Shape.prototype.getPointsHoles = function (divisions) {
  var i, il = this.holes.length, holesPts = [];
  for (i = 0; i < il; i++) {
    holesPts[i] = this.holes[i].getTransformedPoints(divisions, this.bends);
  }
  return holesPts;
};
THREE.Shape.prototype.getSpacedPointsHoles = function (divisions) {
  var i, il = this.holes.length, holesPts = [];
  for (i = 0; i < il; i++) {
    holesPts[i] = this.holes[i].getTransformedSpacedPoints(divisions, this.bends);
  }
  return holesPts;
};
THREE.Shape.prototype.extractAllPoints = function (divisions) {
  return {
    shape: this.getTransformedPoints(divisions),
    holes: this.getPointsHoles(divisions)
  };
};
THREE.Shape.prototype.extractPoints = function (divisions) {
  if (this.useSpacedPoints) {
    return this.extractAllSpacedPoints(divisions);
  }
  return this.extractAllPoints(divisions);
};
THREE.Shape.prototype.extractAllSpacedPoints = function (divisions) {
  return {
    shape: this.getTransformedSpacedPoints(divisions),
    holes: this.getSpacedPointsHoles(divisions)
  };
};
THREE.Shape.Utils = {
  removeHoles: function (contour, holes) {
    var shape = contour.concat();
    var allpoints = shape.concat();
    var prevShapeVert, nextShapeVert, prevHoleVert, nextHoleVert, holeIndex, shapeIndex, shapeId, shapeGroup, h, h2, hole, shortest, d, p, pts1, pts2, tmpShape1, tmpShape2, tmpHole1, tmpHole2, verts = [];
    for (h = 0; h < holes.length; h++) {
      hole = holes[h];
      Array.prototype.push.apply(allpoints, hole);
      shortest = Number.POSITIVE_INFINITY;
      for (h2 = 0; h2 < hole.length; h2++) {
        pts1 = hole[h2];
        var dist = [];
        for (p = 0; p < shape.length; p++) {
          pts2 = shape[p];
          d = pts1.distanceToSquared(pts2);
          dist.push(d);
          if (d < shortest) {
            shortest = d;
            holeIndex = h2;
            shapeIndex = p;
          }
        }
      }
      prevShapeVert = shapeIndex - 1 >= 0 ? shapeIndex - 1 : shape.length - 1;
      prevHoleVert = holeIndex - 1 >= 0 ? holeIndex - 1 : hole.length - 1;
      var areaapts = [
          hole[holeIndex],
          shape[shapeIndex],
          shape[prevShapeVert]
        ];
      var areaa = THREE.FontUtils.Triangulate.area(areaapts);
      var areabpts = [
          hole[holeIndex],
          hole[prevHoleVert],
          shape[shapeIndex]
        ];
      var areab = THREE.FontUtils.Triangulate.area(areabpts);
      var shapeOffset = 1;
      var holeOffset = -1;
      var oldShapeIndex = shapeIndex, oldHoleIndex = holeIndex;
      shapeIndex += shapeOffset;
      holeIndex += holeOffset;
      if (shapeIndex < 0) {
        shapeIndex += shape.length;
      }
      shapeIndex %= shape.length;
      if (holeIndex < 0) {
        holeIndex += hole.length;
      }
      holeIndex %= hole.length;
      prevShapeVert = shapeIndex - 1 >= 0 ? shapeIndex - 1 : shape.length - 1;
      prevHoleVert = holeIndex - 1 >= 0 ? holeIndex - 1 : hole.length - 1;
      areaapts = [
        hole[holeIndex],
        shape[shapeIndex],
        shape[prevShapeVert]
      ];
      var areaa2 = THREE.FontUtils.Triangulate.area(areaapts);
      areabpts = [
        hole[holeIndex],
        hole[prevHoleVert],
        shape[shapeIndex]
      ];
      var areab2 = THREE.FontUtils.Triangulate.area(areabpts);
      if (areaa + areab > areaa2 + areab2) {
        shapeIndex = oldShapeIndex;
        holeIndex = oldHoleIndex;
        if (shapeIndex < 0) {
          shapeIndex += shape.length;
        }
        shapeIndex %= shape.length;
        if (holeIndex < 0) {
          holeIndex += hole.length;
        }
        holeIndex %= hole.length;
        prevShapeVert = shapeIndex - 1 >= 0 ? shapeIndex - 1 : shape.length - 1;
        prevHoleVert = holeIndex - 1 >= 0 ? holeIndex - 1 : hole.length - 1;
      } else {
      }
      tmpShape1 = shape.slice(0, shapeIndex);
      tmpShape2 = shape.slice(shapeIndex);
      tmpHole1 = hole.slice(holeIndex);
      tmpHole2 = hole.slice(0, holeIndex);
      var trianglea = [
          hole[holeIndex],
          shape[shapeIndex],
          shape[prevShapeVert]
        ];
      var triangleb = [
          hole[holeIndex],
          hole[prevHoleVert],
          shape[shapeIndex]
        ];
      verts.push(trianglea);
      verts.push(triangleb);
      shape = tmpShape1.concat(tmpHole1).concat(tmpHole2).concat(tmpShape2);
    }
    return {
      shape: shape,
      isolatedPts: verts,
      allpoints: allpoints
    };
  },
  triangulateShape: function (contour, holes) {
    var shapeWithoutHoles = THREE.Shape.Utils.removeHoles(contour, holes);
    var shape = shapeWithoutHoles.shape, allpoints = shapeWithoutHoles.allpoints, isolatedPts = shapeWithoutHoles.isolatedPts;
    var triangles = THREE.FontUtils.Triangulate(shape, false);
    var i, il, f, face, key, index, allPointsMap = {}, isolatedPointsMap = {};
    for (i = 0, il = allpoints.length; i < il; i++) {
      key = allpoints[i].x + ':' + allpoints[i].y;
      if (allPointsMap[key] !== undefined) {
        console.log('Duplicate point', key);
      }
      allPointsMap[key] = i;
    }
    for (i = 0, il = triangles.length; i < il; i++) {
      face = triangles[i];
      for (f = 0; f < 3; f++) {
        key = face[f].x + ':' + face[f].y;
        index = allPointsMap[key];
        if (index !== undefined) {
          face[f] = index;
        }
      }
    }
    for (i = 0, il = isolatedPts.length; i < il; i++) {
      face = isolatedPts[i];
      for (f = 0; f < 3; f++) {
        key = face[f].x + ':' + face[f].y;
        index = allPointsMap[key];
        if (index !== undefined) {
          face[f] = index;
        }
      }
    }
    return triangles.concat(isolatedPts);
  },
  isClockWise: function (pts) {
    return THREE.FontUtils.Triangulate.area(pts) < 0;
  },
  b2p0: function (t, p) {
    var k = 1 - t;
    return k * k * p;
  },
  b2p1: function (t, p) {
    return 2 * (1 - t) * t * p;
  },
  b2p2: function (t, p) {
    return t * t * p;
  },
  b2: function (t, p0, p1, p2) {
    return this.b2p0(t, p0) + this.b2p1(t, p1) + this.b2p2(t, p2);
  },
  b3p0: function (t, p) {
    var k = 1 - t;
    return k * k * k * p;
  },
  b3p1: function (t, p) {
    var k = 1 - t;
    return 3 * k * k * t * p;
  },
  b3p2: function (t, p) {
    var k = 1 - t;
    return 3 * k * t * t * p;
  },
  b3p3: function (t, p) {
    return t * t * t * p;
  },
  b3: function (t, p0, p1, p2, p3) {
    return this.b3p0(t, p0) + this.b3p1(t, p1) + this.b3p2(t, p2) + this.b3p3(t, p3);
  }
};
THREE.LineCurve = function (v1, v2) {
  this.v1 = v1;
  this.v2 = v2;
};
THREE.LineCurve.prototype = Object.create(THREE.Curve.prototype);
THREE.LineCurve.prototype.getPoint = function (t) {
  var point = this.v2.clone().sub(this.v1);
  point.multiplyScalar(t).add(this.v1);
  return point;
};
THREE.LineCurve.prototype.getPointAt = function (u) {
  return this.getPoint(u);
};
THREE.LineCurve.prototype.getTangent = function (t) {
  var tangent = this.v2.clone().sub(this.v1);
  return tangent.normalize();
};
THREE.QuadraticBezierCurve = function (v0, v1, v2) {
  this.v0 = v0;
  this.v1 = v1;
  this.v2 = v2;
};
THREE.QuadraticBezierCurve.prototype = Object.create(THREE.Curve.prototype);
THREE.QuadraticBezierCurve.prototype.getPoint = function (t) {
  var tx, ty;
  tx = THREE.Shape.Utils.b2(t, this.v0.x, this.v1.x, this.v2.x);
  ty = THREE.Shape.Utils.b2(t, this.v0.y, this.v1.y, this.v2.y);
  return new THREE.Vector2(tx, ty);
};
THREE.QuadraticBezierCurve.prototype.getTangent = function (t) {
  var tx, ty;
  tx = THREE.Curve.Utils.tangentQuadraticBezier(t, this.v0.x, this.v1.x, this.v2.x);
  ty = THREE.Curve.Utils.tangentQuadraticBezier(t, this.v0.y, this.v1.y, this.v2.y);
  var tangent = new THREE.Vector2(tx, ty);
  tangent.normalize();
  return tangent;
};
THREE.CubicBezierCurve = function (v0, v1, v2, v3) {
  this.v0 = v0;
  this.v1 = v1;
  this.v2 = v2;
  this.v3 = v3;
};
THREE.CubicBezierCurve.prototype = Object.create(THREE.Curve.prototype);
THREE.CubicBezierCurve.prototype.getPoint = function (t) {
  var tx, ty;
  tx = THREE.Shape.Utils.b3(t, this.v0.x, this.v1.x, this.v2.x, this.v3.x);
  ty = THREE.Shape.Utils.b3(t, this.v0.y, this.v1.y, this.v2.y, this.v3.y);
  return new THREE.Vector2(tx, ty);
};
THREE.CubicBezierCurve.prototype.getTangent = function (t) {
  var tx, ty;
  tx = THREE.Curve.Utils.tangentCubicBezier(t, this.v0.x, this.v1.x, this.v2.x, this.v3.x);
  ty = THREE.Curve.Utils.tangentCubicBezier(t, this.v0.y, this.v1.y, this.v2.y, this.v3.y);
  var tangent = new THREE.Vector2(tx, ty);
  tangent.normalize();
  return tangent;
};
THREE.SplineCurve = function (points) {
  this.points = points == undefined ? [] : points;
};
THREE.SplineCurve.prototype = Object.create(THREE.Curve.prototype);
THREE.SplineCurve.prototype.getPoint = function (t) {
  var v = new THREE.Vector2();
  var c = [];
  var points = this.points, point, intPoint, weight;
  point = (points.length - 1) * t;
  intPoint = Math.floor(point);
  weight = point - intPoint;
  c[0] = intPoint == 0 ? intPoint : intPoint - 1;
  c[1] = intPoint;
  c[2] = intPoint > points.length - 2 ? points.length - 1 : intPoint + 1;
  c[3] = intPoint > points.length - 3 ? points.length - 1 : intPoint + 2;
  v.x = THREE.Curve.Utils.interpolate(points[c[0]].x, points[c[1]].x, points[c[2]].x, points[c[3]].x, weight);
  v.y = THREE.Curve.Utils.interpolate(points[c[0]].y, points[c[1]].y, points[c[2]].y, points[c[3]].y, weight);
  return v;
};
THREE.EllipseCurve = function (aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise) {
  this.aX = aX;
  this.aY = aY;
  this.xRadius = xRadius;
  this.yRadius = yRadius;
  this.aStartAngle = aStartAngle;
  this.aEndAngle = aEndAngle;
  this.aClockwise = aClockwise;
};
THREE.EllipseCurve.prototype = Object.create(THREE.Curve.prototype);
THREE.EllipseCurve.prototype.getPoint = function (t) {
  var deltaAngle = this.aEndAngle - this.aStartAngle;
  if (!this.aClockwise) {
    t = 1 - t;
  }
  var angle = this.aStartAngle + t * deltaAngle;
  var tx = this.aX + this.xRadius * Math.cos(angle);
  var ty = this.aY + this.yRadius * Math.sin(angle);
  return new THREE.Vector2(tx, ty);
};
THREE.ArcCurve = function (aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
  THREE.EllipseCurve.call(this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
};
THREE.ArcCurve.prototype = Object.create(THREE.EllipseCurve.prototype);
THREE.LineCurve3 = THREE.Curve.create(function (v1, v2) {
  this.v1 = v1;
  this.v2 = v2;
}, function (t) {
  var r = new THREE.Vector3();
  r.subVectors(this.v2, this.v1);
  r.multiplyScalar(t);
  r.add(this.v1);
  return r;
});
THREE.QuadraticBezierCurve3 = THREE.Curve.create(function (v0, v1, v2) {
  this.v0 = v0;
  this.v1 = v1;
  this.v2 = v2;
}, function (t) {
  var tx, ty, tz;
  tx = THREE.Shape.Utils.b2(t, this.v0.x, this.v1.x, this.v2.x);
  ty = THREE.Shape.Utils.b2(t, this.v0.y, this.v1.y, this.v2.y);
  tz = THREE.Shape.Utils.b2(t, this.v0.z, this.v1.z, this.v2.z);
  return new THREE.Vector3(tx, ty, tz);
});
THREE.CubicBezierCurve3 = THREE.Curve.create(function (v0, v1, v2, v3) {
  this.v0 = v0;
  this.v1 = v1;
  this.v2 = v2;
  this.v3 = v3;
}, function (t) {
  var tx, ty, tz;
  tx = THREE.Shape.Utils.b3(t, this.v0.x, this.v1.x, this.v2.x, this.v3.x);
  ty = THREE.Shape.Utils.b3(t, this.v0.y, this.v1.y, this.v2.y, this.v3.y);
  tz = THREE.Shape.Utils.b3(t, this.v0.z, this.v1.z, this.v2.z, this.v3.z);
  return new THREE.Vector3(tx, ty, tz);
});
THREE.SplineCurve3 = THREE.Curve.create(function (points) {
  this.points = points == undefined ? [] : points;
}, function (t) {
  var v = new THREE.Vector3();
  var c = [];
  var points = this.points, point, intPoint, weight;
  point = (points.length - 1) * t;
  intPoint = Math.floor(point);
  weight = point - intPoint;
  c[0] = intPoint == 0 ? intPoint : intPoint - 1;
  c[1] = intPoint;
  c[2] = intPoint > points.length - 2 ? points.length - 1 : intPoint + 1;
  c[3] = intPoint > points.length - 3 ? points.length - 1 : intPoint + 2;
  var pt0 = points[c[0]], pt1 = points[c[1]], pt2 = points[c[2]], pt3 = points[c[3]];
  v.x = THREE.Curve.Utils.interpolate(pt0.x, pt1.x, pt2.x, pt3.x, weight);
  v.y = THREE.Curve.Utils.interpolate(pt0.y, pt1.y, pt2.y, pt3.y, weight);
  v.z = THREE.Curve.Utils.interpolate(pt0.z, pt1.z, pt2.z, pt3.z, weight);
  return v;
});
THREE.ClosedSplineCurve3 = THREE.Curve.create(function (points) {
  this.points = points == undefined ? [] : points;
}, function (t) {
  var v = new THREE.Vector3();
  var c = [];
  var points = this.points, point, intPoint, weight;
  point = (points.length - 0) * t;
  intPoint = Math.floor(point);
  weight = point - intPoint;
  intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / points.length) + 1) * points.length;
  c[0] = (intPoint - 1) % points.length;
  c[1] = intPoint % points.length;
  c[2] = (intPoint + 1) % points.length;
  c[3] = (intPoint + 2) % points.length;
  v.x = THREE.Curve.Utils.interpolate(points[c[0]].x, points[c[1]].x, points[c[2]].x, points[c[3]].x, weight);
  v.y = THREE.Curve.Utils.interpolate(points[c[0]].y, points[c[1]].y, points[c[2]].y, points[c[3]].y, weight);
  v.z = THREE.Curve.Utils.interpolate(points[c[0]].z, points[c[1]].z, points[c[2]].z, points[c[3]].z, weight);
  return v;
});
THREE.AnimationHandler = function () {
  var playing = [];
  var library = {};
  var that = {};
  that.update = function (deltaTimeMS) {
    for (var i = 0; i < playing.length; i++)
      playing[i].update(deltaTimeMS);
  };
  that.addToUpdate = function (animation) {
    if (playing.indexOf(animation) === -1)
      playing.push(animation);
  };
  that.removeFromUpdate = function (animation) {
    var index = playing.indexOf(animation);
    if (index !== -1)
      playing.splice(index, 1);
  };
  that.add = function (data) {
    if (library[data.name] !== undefined)
      console.log('THREE.AnimationHandler.add: Warning! ' + data.name + ' already exists in library. Overwriting.');
    library[data.name] = data;
    initData(data);
  };
  that.get = function (name) {
    if (typeof name === 'string') {
      if (library[name]) {
        return library[name];
      } else {
        console.log('THREE.AnimationHandler.get: Couldn\'t find animation ' + name);
        return null;
      }
    } else {
    }
  };
  that.parse = function (root) {
    var hierarchy = [];
    if (root instanceof THREE.SkinnedMesh) {
      for (var b = 0; b < root.bones.length; b++) {
        hierarchy.push(root.bones[b]);
      }
    } else {
      parseRecurseHierarchy(root, hierarchy);
    }
    return hierarchy;
  };
  var parseRecurseHierarchy = function (root, hierarchy) {
    hierarchy.push(root);
    for (var c = 0; c < root.children.length; c++)
      parseRecurseHierarchy(root.children[c], hierarchy);
  };
  var initData = function (data) {
    if (data.initialized === true)
      return;
    for (var h = 0; h < data.hierarchy.length; h++) {
      for (var k = 0; k < data.hierarchy[h].keys.length; k++) {
        if (data.hierarchy[h].keys[k].time < 0)
          data.hierarchy[h].keys[k].time = 0;
        if (data.hierarchy[h].keys[k].rot !== undefined && !(data.hierarchy[h].keys[k].rot instanceof THREE.Quaternion)) {
          var quat = data.hierarchy[h].keys[k].rot;
          data.hierarchy[h].keys[k].rot = new THREE.Quaternion(quat[0], quat[1], quat[2], quat[3]);
        }
      }
      if (data.hierarchy[h].keys.length && data.hierarchy[h].keys[0].morphTargets !== undefined) {
        var usedMorphTargets = {};
        for (var k = 0; k < data.hierarchy[h].keys.length; k++) {
          for (var m = 0; m < data.hierarchy[h].keys[k].morphTargets.length; m++) {
            var morphTargetName = data.hierarchy[h].keys[k].morphTargets[m];
            usedMorphTargets[morphTargetName] = -1;
          }
        }
        data.hierarchy[h].usedMorphTargets = usedMorphTargets;
        for (var k = 0; k < data.hierarchy[h].keys.length; k++) {
          var influences = {};
          for (var morphTargetName in usedMorphTargets) {
            for (var m = 0; m < data.hierarchy[h].keys[k].morphTargets.length; m++) {
              if (data.hierarchy[h].keys[k].morphTargets[m] === morphTargetName) {
                influences[morphTargetName] = data.hierarchy[h].keys[k].morphTargetsInfluences[m];
                break;
              }
            }
            if (m === data.hierarchy[h].keys[k].morphTargets.length) {
              influences[morphTargetName] = 0;
            }
          }
          data.hierarchy[h].keys[k].morphTargetsInfluences = influences;
        }
      }
      for (var k = 1; k < data.hierarchy[h].keys.length; k++) {
        if (data.hierarchy[h].keys[k].time === data.hierarchy[h].keys[k - 1].time) {
          data.hierarchy[h].keys.splice(k, 1);
          k--;
        }
      }
      for (var k = 0; k < data.hierarchy[h].keys.length; k++) {
        data.hierarchy[h].keys[k].index = k;
      }
    }
    var lengthInFrames = parseInt(data.length * data.fps, 10);
    data.JIT = {};
    data.JIT.hierarchy = [];
    for (var h = 0; h < data.hierarchy.length; h++)
      data.JIT.hierarchy.push(new Array(lengthInFrames));
    data.initialized = true;
  };
  that.LINEAR = 0;
  that.CATMULLROM = 1;
  that.CATMULLROM_FORWARD = 2;
  return that;
}();
THREE.Animation = function (root, name, interpolationType) {
  this.root = root;
  this.data = THREE.AnimationHandler.get(name);
  this.hierarchy = THREE.AnimationHandler.parse(root);
  this.currentTime = 0;
  this.timeScale = 1;
  this.isPlaying = false;
  this.isPaused = true;
  this.loop = true;
  this.interpolationType = interpolationType !== undefined ? interpolationType : THREE.AnimationHandler.LINEAR;
  this.points = [];
  this.target = new THREE.Vector3();
};
THREE.Animation.prototype.play = function (loop, startTimeMS) {
  if (this.isPlaying === false) {
    this.isPlaying = true;
    this.loop = loop !== undefined ? loop : true;
    this.currentTime = startTimeMS !== undefined ? startTimeMS : 0;
    var h, hl = this.hierarchy.length, object;
    for (h = 0; h < hl; h++) {
      object = this.hierarchy[h];
      object.matrixAutoUpdate = true;
      if (object.animationCache === undefined) {
        object.animationCache = {};
        object.animationCache.prevKey = {
          pos: 0,
          rot: 0,
          scl: 0
        };
        object.animationCache.nextKey = {
          pos: 0,
          rot: 0,
          scl: 0
        };
        object.animationCache.originalMatrix = object instanceof THREE.Bone ? object.skinMatrix : object.matrix;
      }
      var prevKey = object.animationCache.prevKey;
      var nextKey = object.animationCache.nextKey;
      prevKey.pos = this.data.hierarchy[h].keys[0];
      prevKey.rot = this.data.hierarchy[h].keys[0];
      prevKey.scl = this.data.hierarchy[h].keys[0];
      nextKey.pos = this.getNextKeyWith('pos', h, 1);
      nextKey.rot = this.getNextKeyWith('rot', h, 1);
      nextKey.scl = this.getNextKeyWith('scl', h, 1);
    }
    this.update(0);
  }
  this.isPaused = false;
  THREE.AnimationHandler.addToUpdate(this);
};
THREE.Animation.prototype.pause = function () {
  if (this.isPaused === true) {
    THREE.AnimationHandler.addToUpdate(this);
  } else {
    THREE.AnimationHandler.removeFromUpdate(this);
  }
  this.isPaused = !this.isPaused;
};
THREE.Animation.prototype.stop = function () {
  this.isPlaying = false;
  this.isPaused = false;
  THREE.AnimationHandler.removeFromUpdate(this);
};
THREE.Animation.prototype.update = function (deltaTimeMS) {
  if (this.isPlaying === false)
    return;
  var types = [
      'pos',
      'rot',
      'scl'
    ];
  var type;
  var scale;
  var vector;
  var prevXYZ, nextXYZ;
  var prevKey, nextKey;
  var object;
  var animationCache;
  var frame;
  var JIThierarchy = this.data.JIT.hierarchy;
  var currentTime, unloopedCurrentTime;
  var currentPoint, forwardPoint, angle;
  this.currentTime += deltaTimeMS * this.timeScale;
  unloopedCurrentTime = this.currentTime;
  currentTime = this.currentTime = this.currentTime % this.data.length;
  frame = parseInt(Math.min(currentTime * this.data.fps, this.data.length * this.data.fps), 10);
  for (var h = 0, hl = this.hierarchy.length; h < hl; h++) {
    object = this.hierarchy[h];
    animationCache = object.animationCache;
    for (var t = 0; t < 3; t++) {
      type = types[t];
      prevKey = animationCache.prevKey[type];
      nextKey = animationCache.nextKey[type];
      if (nextKey.time <= unloopedCurrentTime) {
        if (currentTime < unloopedCurrentTime) {
          if (this.loop) {
            prevKey = this.data.hierarchy[h].keys[0];
            nextKey = this.getNextKeyWith(type, h, 1);
            while (nextKey.time < currentTime) {
              prevKey = nextKey;
              nextKey = this.getNextKeyWith(type, h, nextKey.index + 1);
            }
          } else {
            this.stop();
            return;
          }
        } else {
          do {
            prevKey = nextKey;
            nextKey = this.getNextKeyWith(type, h, nextKey.index + 1);
          } while (nextKey.time < currentTime);
        }
        animationCache.prevKey[type] = prevKey;
        animationCache.nextKey[type] = nextKey;
      }
      object.matrixAutoUpdate = true;
      object.matrixWorldNeedsUpdate = true;
      scale = (currentTime - prevKey.time) / (nextKey.time - prevKey.time);
      prevXYZ = prevKey[type];
      nextXYZ = nextKey[type];
      if (scale < 0 || scale > 1) {
        console.log('THREE.Animation.update: Warning! Scale out of bounds:' + scale + ' on bone ' + h);
        scale = scale < 0 ? 0 : 1;
      }
      if (type === 'pos') {
        vector = object.position;
        if (this.interpolationType === THREE.AnimationHandler.LINEAR) {
          vector.x = prevXYZ[0] + (nextXYZ[0] - prevXYZ[0]) * scale;
          vector.y = prevXYZ[1] + (nextXYZ[1] - prevXYZ[1]) * scale;
          vector.z = prevXYZ[2] + (nextXYZ[2] - prevXYZ[2]) * scale;
        } else if (this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD) {
          this.points[0] = this.getPrevKeyWith('pos', h, prevKey.index - 1)['pos'];
          this.points[1] = prevXYZ;
          this.points[2] = nextXYZ;
          this.points[3] = this.getNextKeyWith('pos', h, nextKey.index + 1)['pos'];
          scale = scale * 0.33 + 0.33;
          currentPoint = this.interpolateCatmullRom(this.points, scale);
          vector.x = currentPoint[0];
          vector.y = currentPoint[1];
          vector.z = currentPoint[2];
          if (this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD) {
            forwardPoint = this.interpolateCatmullRom(this.points, scale * 1.01);
            this.target.set(forwardPoint[0], forwardPoint[1], forwardPoint[2]);
            this.target.sub(vector);
            this.target.y = 0;
            this.target.normalize();
            angle = Math.atan2(this.target.x, this.target.z);
            object.rotation.set(0, angle, 0);
          }
        }
      } else if (type === 'rot') {
        THREE.Quaternion.slerp(prevXYZ, nextXYZ, object.quaternion, scale);
      } else if (type === 'scl') {
        vector = object.scale;
        vector.x = prevXYZ[0] + (nextXYZ[0] - prevXYZ[0]) * scale;
        vector.y = prevXYZ[1] + (nextXYZ[1] - prevXYZ[1]) * scale;
        vector.z = prevXYZ[2] + (nextXYZ[2] - prevXYZ[2]) * scale;
      }
    }
  }
};
THREE.Animation.prototype.interpolateCatmullRom = function (points, scale) {
  var c = [], v3 = [], point, intPoint, weight, w2, w3, pa, pb, pc, pd;
  point = (points.length - 1) * scale;
  intPoint = Math.floor(point);
  weight = point - intPoint;
  c[0] = intPoint === 0 ? intPoint : intPoint - 1;
  c[1] = intPoint;
  c[2] = intPoint > points.length - 2 ? intPoint : intPoint + 1;
  c[3] = intPoint > points.length - 3 ? intPoint : intPoint + 2;
  pa = points[c[0]];
  pb = points[c[1]];
  pc = points[c[2]];
  pd = points[c[3]];
  w2 = weight * weight;
  w3 = weight * w2;
  v3[0] = this.interpolate(pa[0], pb[0], pc[0], pd[0], weight, w2, w3);
  v3[1] = this.interpolate(pa[1], pb[1], pc[1], pd[1], weight, w2, w3);
  v3[2] = this.interpolate(pa[2], pb[2], pc[2], pd[2], weight, w2, w3);
  return v3;
};
THREE.Animation.prototype.interpolate = function (p0, p1, p2, p3, t, t2, t3) {
  var v0 = (p2 - p0) * 0.5, v1 = (p3 - p1) * 0.5;
  return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;
};
THREE.Animation.prototype.getNextKeyWith = function (type, h, key) {
  var keys = this.data.hierarchy[h].keys;
  if (this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD) {
    key = key < keys.length - 1 ? key : keys.length - 1;
  } else {
    key = key % keys.length;
  }
  for (; key < keys.length; key++) {
    if (keys[key][type] !== undefined) {
      return keys[key];
    }
  }
  return this.data.hierarchy[h].keys[0];
};
THREE.Animation.prototype.getPrevKeyWith = function (type, h, key) {
  var keys = this.data.hierarchy[h].keys;
  if (this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD) {
    key = key > 0 ? key : 0;
  } else {
    key = key >= 0 ? key : key + keys.length;
  }
  for (; key >= 0; key--) {
    if (keys[key][type] !== undefined) {
      return keys[key];
    }
  }
  return this.data.hierarchy[h].keys[keys.length - 1];
};
THREE.KeyFrameAnimation = function (root, data, JITCompile) {
  this.root = root;
  this.data = THREE.AnimationHandler.get(data);
  this.hierarchy = THREE.AnimationHandler.parse(root);
  this.currentTime = 0;
  this.timeScale = 0.001;
  this.isPlaying = false;
  this.isPaused = true;
  this.loop = true;
  this.JITCompile = JITCompile !== undefined ? JITCompile : true;
  for (var h = 0, hl = this.hierarchy.length; h < hl; h++) {
    var keys = this.data.hierarchy[h].keys, sids = this.data.hierarchy[h].sids, obj = this.hierarchy[h];
    if (keys.length && sids) {
      for (var s = 0; s < sids.length; s++) {
        var sid = sids[s], next = this.getNextKeyWith(sid, h, 0);
        if (next) {
          next.apply(sid);
        }
      }
      obj.matrixAutoUpdate = false;
      this.data.hierarchy[h].node.updateMatrix();
      obj.matrixWorldNeedsUpdate = true;
    }
  }
};
THREE.KeyFrameAnimation.prototype.play = function (loop, startTimeMS) {
  if (!this.isPlaying) {
    this.isPlaying = true;
    this.loop = loop !== undefined ? loop : true;
    this.currentTime = startTimeMS !== undefined ? startTimeMS : 0;
    this.startTimeMs = startTimeMS;
    this.startTime = 10000000;
    this.endTime = -this.startTime;
    var h, hl = this.hierarchy.length, object, node;
    for (h = 0; h < hl; h++) {
      object = this.hierarchy[h];
      node = this.data.hierarchy[h];
      if (node.animationCache === undefined) {
        node.animationCache = {};
        node.animationCache.prevKey = null;
        node.animationCache.nextKey = null;
        node.animationCache.originalMatrix = object instanceof THREE.Bone ? object.skinMatrix : object.matrix;
      }
      var keys = this.data.hierarchy[h].keys;
      if (keys.length) {
        node.animationCache.prevKey = keys[0];
        node.animationCache.nextKey = keys[1];
        this.startTime = Math.min(keys[0].time, this.startTime);
        this.endTime = Math.max(keys[keys.length - 1].time, this.endTime);
      }
    }
    this.update(0);
  }
  this.isPaused = false;
  THREE.AnimationHandler.addToUpdate(this);
};
THREE.KeyFrameAnimation.prototype.pause = function () {
  if (this.isPaused) {
    THREE.AnimationHandler.addToUpdate(this);
  } else {
    THREE.AnimationHandler.removeFromUpdate(this);
  }
  this.isPaused = !this.isPaused;
};
THREE.KeyFrameAnimation.prototype.stop = function () {
  this.isPlaying = false;
  this.isPaused = false;
  THREE.AnimationHandler.removeFromUpdate(this);
  for (var h = 0; h < this.data.hierarchy.length; h++) {
    var obj = this.hierarchy[h];
    var node = this.data.hierarchy[h];
    if (node.animationCache !== undefined) {
      var original = node.animationCache.originalMatrix;
      if (obj instanceof THREE.Bone) {
        original.copy(obj.skinMatrix);
        obj.skinMatrix = original;
      } else {
        original.copy(obj.matrix);
        obj.matrix = original;
      }
      delete node.animationCache;
    }
  }
};
THREE.KeyFrameAnimation.prototype.update = function (deltaTimeMS) {
  if (!this.isPlaying)
    return;
  var prevKey, nextKey;
  var object;
  var node;
  var frame;
  var JIThierarchy = this.data.JIT.hierarchy;
  var currentTime, unloopedCurrentTime;
  var looped;
  this.currentTime += deltaTimeMS * this.timeScale;
  unloopedCurrentTime = this.currentTime;
  currentTime = this.currentTime = this.currentTime % this.data.length;
  if (currentTime < this.startTimeMs) {
    currentTime = this.currentTime = this.startTimeMs + currentTime;
  }
  frame = parseInt(Math.min(currentTime * this.data.fps, this.data.length * this.data.fps), 10);
  looped = currentTime < unloopedCurrentTime;
  if (looped && !this.loop) {
    for (var h = 0, hl = this.hierarchy.length; h < hl; h++) {
      var keys = this.data.hierarchy[h].keys, sids = this.data.hierarchy[h].sids, end = keys.length - 1, obj = this.hierarchy[h];
      if (keys.length) {
        for (var s = 0; s < sids.length; s++) {
          var sid = sids[s], prev = this.getPrevKeyWith(sid, h, end);
          if (prev) {
            prev.apply(sid);
          }
        }
        this.data.hierarchy[h].node.updateMatrix();
        obj.matrixWorldNeedsUpdate = true;
      }
    }
    this.stop();
    return;
  }
  if (currentTime < this.startTime) {
    return;
  }
  for (var h = 0, hl = this.hierarchy.length; h < hl; h++) {
    object = this.hierarchy[h];
    node = this.data.hierarchy[h];
    var keys = node.keys, animationCache = node.animationCache;
    if (this.JITCompile && JIThierarchy[h][frame] !== undefined) {
      if (object instanceof THREE.Bone) {
        object.skinMatrix = JIThierarchy[h][frame];
        object.matrixWorldNeedsUpdate = false;
      } else {
        object.matrix = JIThierarchy[h][frame];
        object.matrixWorldNeedsUpdate = true;
      }
    } else if (keys.length) {
      if (this.JITCompile && animationCache) {
        if (object instanceof THREE.Bone) {
          object.skinMatrix = animationCache.originalMatrix;
        } else {
          object.matrix = animationCache.originalMatrix;
        }
      }
      prevKey = animationCache.prevKey;
      nextKey = animationCache.nextKey;
      if (prevKey && nextKey) {
        if (nextKey.time <= unloopedCurrentTime) {
          if (looped && this.loop) {
            prevKey = keys[0];
            nextKey = keys[1];
            while (nextKey.time < currentTime) {
              prevKey = nextKey;
              nextKey = keys[prevKey.index + 1];
            }
          } else if (!looped) {
            var lastIndex = keys.length - 1;
            while (nextKey.time < currentTime && nextKey.index !== lastIndex) {
              prevKey = nextKey;
              nextKey = keys[prevKey.index + 1];
            }
          }
          animationCache.prevKey = prevKey;
          animationCache.nextKey = nextKey;
        }
        if (nextKey.time >= currentTime)
          prevKey.interpolate(nextKey, currentTime);
        else
          prevKey.interpolate(nextKey, nextKey.time);
      }
      this.data.hierarchy[h].node.updateMatrix();
      object.matrixWorldNeedsUpdate = true;
    }
  }
  if (this.JITCompile) {
    if (JIThierarchy[0][frame] === undefined) {
      this.hierarchy[0].updateMatrixWorld(true);
      for (var h = 0; h < this.hierarchy.length; h++) {
        if (this.hierarchy[h] instanceof THREE.Bone) {
          JIThierarchy[h][frame] = this.hierarchy[h].skinMatrix.clone();
        } else {
          JIThierarchy[h][frame] = this.hierarchy[h].matrix.clone();
        }
      }
    }
  }
};
THREE.KeyFrameAnimation.prototype.getNextKeyWith = function (sid, h, key) {
  var keys = this.data.hierarchy[h].keys;
  key = key % keys.length;
  for (; key < keys.length; key++) {
    if (keys[key].hasTarget(sid)) {
      return keys[key];
    }
  }
  return keys[0];
};
THREE.KeyFrameAnimation.prototype.getPrevKeyWith = function (sid, h, key) {
  var keys = this.data.hierarchy[h].keys;
  key = key >= 0 ? key : key + keys.length;
  for (; key >= 0; key--) {
    if (keys[key].hasTarget(sid)) {
      return keys[key];
    }
  }
  return keys[keys.length - 1];
};
THREE.CubeCamera = function (near, far, cubeResolution) {
  THREE.Object3D.call(this);
  var fov = 90, aspect = 1;
  var cameraPX = new THREE.PerspectiveCamera(fov, aspect, near, far);
  cameraPX.up.set(0, -1, 0);
  cameraPX.lookAt(new THREE.Vector3(1, 0, 0));
  this.add(cameraPX);
  var cameraNX = new THREE.PerspectiveCamera(fov, aspect, near, far);
  cameraNX.up.set(0, -1, 0);
  cameraNX.lookAt(new THREE.Vector3(-1, 0, 0));
  this.add(cameraNX);
  var cameraPY = new THREE.PerspectiveCamera(fov, aspect, near, far);
  cameraPY.up.set(0, 0, 1);
  cameraPY.lookAt(new THREE.Vector3(0, 1, 0));
  this.add(cameraPY);
  var cameraNY = new THREE.PerspectiveCamera(fov, aspect, near, far);
  cameraNY.up.set(0, 0, -1);
  cameraNY.lookAt(new THREE.Vector3(0, -1, 0));
  this.add(cameraNY);
  var cameraPZ = new THREE.PerspectiveCamera(fov, aspect, near, far);
  cameraPZ.up.set(0, -1, 0);
  cameraPZ.lookAt(new THREE.Vector3(0, 0, 1));
  this.add(cameraPZ);
  var cameraNZ = new THREE.PerspectiveCamera(fov, aspect, near, far);
  cameraNZ.up.set(0, -1, 0);
  cameraNZ.lookAt(new THREE.Vector3(0, 0, -1));
  this.add(cameraNZ);
  this.renderTarget = new THREE.WebGLRenderTargetCube(cubeResolution, cubeResolution, {
    format: THREE.RGBFormat,
    magFilter: THREE.LinearFilter,
    minFilter: THREE.LinearFilter
  });
  this.updateCubeMap = function (renderer, scene) {
    var renderTarget = this.renderTarget;
    var generateMipmaps = renderTarget.generateMipmaps;
    renderTarget.generateMipmaps = false;
    renderTarget.activeCubeFace = 0;
    renderer.render(scene, cameraPX, renderTarget);
    renderTarget.activeCubeFace = 1;
    renderer.render(scene, cameraNX, renderTarget);
    renderTarget.activeCubeFace = 2;
    renderer.render(scene, cameraPY, renderTarget);
    renderTarget.activeCubeFace = 3;
    renderer.render(scene, cameraNY, renderTarget);
    renderTarget.activeCubeFace = 4;
    renderer.render(scene, cameraPZ, renderTarget);
    renderTarget.generateMipmaps = generateMipmaps;
    renderTarget.activeCubeFace = 5;
    renderer.render(scene, cameraNZ, renderTarget);
  };
};
THREE.CubeCamera.prototype = Object.create(THREE.Object3D.prototype);
THREE.CombinedCamera = function (width, height, fov, near, far, orthoNear, orthoFar) {
  THREE.Camera.call(this);
  this.fov = fov;
  this.left = -width / 2;
  this.right = width / 2;
  this.top = height / 2;
  this.bottom = -height / 2;
  this.cameraO = new THREE.OrthographicCamera(width / -2, width / 2, height / 2, height / -2, orthoNear, orthoFar);
  this.cameraP = new THREE.PerspectiveCamera(fov, width / height, near, far);
  this.zoom = 1;
  this.toPerspective();
  var aspect = width / height;
};
THREE.CombinedCamera.prototype = Object.create(THREE.Camera.prototype);
THREE.CombinedCamera.prototype.toPerspective = function () {
  this.near = this.cameraP.near;
  this.far = this.cameraP.far;
  this.cameraP.fov = this.fov / this.zoom;
  this.cameraP.updateProjectionMatrix();
  this.projectionMatrix = this.cameraP.projectionMatrix;
  this.inPerspectiveMode = true;
  this.inOrthographicMode = false;
};
THREE.CombinedCamera.prototype.toOrthographic = function () {
  var fov = this.fov;
  var aspect = this.cameraP.aspect;
  var near = this.cameraP.near;
  var far = this.cameraP.far;
  var hyperfocus = (near + far) / 2;
  var halfHeight = Math.tan(fov / 2) * hyperfocus;
  var planeHeight = 2 * halfHeight;
  var planeWidth = planeHeight * aspect;
  var halfWidth = planeWidth / 2;
  halfHeight /= this.zoom;
  halfWidth /= this.zoom;
  this.cameraO.left = -halfWidth;
  this.cameraO.right = halfWidth;
  this.cameraO.top = halfHeight;
  this.cameraO.bottom = -halfHeight;
  this.cameraO.updateProjectionMatrix();
  this.near = this.cameraO.near;
  this.far = this.cameraO.far;
  this.projectionMatrix = this.cameraO.projectionMatrix;
  this.inPerspectiveMode = false;
  this.inOrthographicMode = true;
};
THREE.CombinedCamera.prototype.setSize = function (width, height) {
  this.cameraP.aspect = width / height;
  this.left = -width / 2;
  this.right = width / 2;
  this.top = height / 2;
  this.bottom = -height / 2;
};
THREE.CombinedCamera.prototype.setFov = function (fov) {
  this.fov = fov;
  if (this.inPerspectiveMode) {
    this.toPerspective();
  } else {
    this.toOrthographic();
  }
};
THREE.CombinedCamera.prototype.updateProjectionMatrix = function () {
  if (this.inPerspectiveMode) {
    this.toPerspective();
  } else {
    this.toPerspective();
    this.toOrthographic();
  }
};
THREE.CombinedCamera.prototype.setLens = function (focalLength, frameHeight) {
  if (frameHeight === undefined)
    frameHeight = 24;
  var fov = 2 * THREE.Math.radToDeg(Math.atan(frameHeight / (focalLength * 2)));
  this.setFov(fov);
  return fov;
};
THREE.CombinedCamera.prototype.setZoom = function (zoom) {
  this.zoom = zoom;
  if (this.inPerspectiveMode) {
    this.toPerspective();
  } else {
    this.toOrthographic();
  }
};
THREE.CombinedCamera.prototype.toFrontView = function () {
  this.rotation.x = 0;
  this.rotation.y = 0;
  this.rotation.z = 0;
  this.rotationAutoUpdate = false;
};
THREE.CombinedCamera.prototype.toBackView = function () {
  this.rotation.x = 0;
  this.rotation.y = Math.PI;
  this.rotation.z = 0;
  this.rotationAutoUpdate = false;
};
THREE.CombinedCamera.prototype.toLeftView = function () {
  this.rotation.x = 0;
  this.rotation.y = -Math.PI / 2;
  this.rotation.z = 0;
  this.rotationAutoUpdate = false;
};
THREE.CombinedCamera.prototype.toRightView = function () {
  this.rotation.x = 0;
  this.rotation.y = Math.PI / 2;
  this.rotation.z = 0;
  this.rotationAutoUpdate = false;
};
THREE.CombinedCamera.prototype.toTopView = function () {
  this.rotation.x = -Math.PI / 2;
  this.rotation.y = 0;
  this.rotation.z = 0;
  this.rotationAutoUpdate = false;
};
THREE.CombinedCamera.prototype.toBottomView = function () {
  this.rotation.x = Math.PI / 2;
  this.rotation.y = 0;
  this.rotation.z = 0;
  this.rotationAutoUpdate = false;
};
THREE.CircleGeometry = function (radius, segments, thetaStart, thetaLength) {
  THREE.Geometry.call(this);
  radius = radius || 50;
  thetaStart = thetaStart !== undefined ? thetaStart : 0;
  thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
  segments = segments !== undefined ? Math.max(3, segments) : 8;
  var i, uvs = [], center = new THREE.Vector3(), centerUV = new THREE.Vector2(0.5, 0.5);
  this.vertices.push(center);
  uvs.push(centerUV);
  for (i = 0; i <= segments; i++) {
    var vertex = new THREE.Vector3();
    var segment = thetaStart + i / segments * thetaLength;
    vertex.x = radius * Math.cos(segment);
    vertex.y = radius * Math.sin(segment);
    this.vertices.push(vertex);
    uvs.push(new THREE.Vector2((vertex.x / radius + 1) / 2, (vertex.y / radius + 1) / 2));
  }
  var n = new THREE.Vector3(0, 0, 1);
  for (i = 1; i <= segments; i++) {
    var v1 = i;
    var v2 = i + 1;
    var v3 = 0;
    this.faces.push(new THREE.Face3(v1, v2, v3, [
      n,
      n,
      n
    ]));
    this.faceVertexUvs[0].push([
      uvs[i],
      uvs[i + 1],
      centerUV
    ]);
  }
  this.computeCentroids();
  this.computeFaceNormals();
  this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), radius);
};
THREE.CircleGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.CubeGeometry = function (width, height, depth, widthSegments, heightSegments, depthSegments) {
  THREE.Geometry.call(this);
  var scope = this;
  this.width = width;
  this.height = height;
  this.depth = depth;
  this.widthSegments = widthSegments || 1;
  this.heightSegments = heightSegments || 1;
  this.depthSegments = depthSegments || 1;
  var width_half = this.width / 2;
  var height_half = this.height / 2;
  var depth_half = this.depth / 2;
  buildPlane('z', 'y', -1, -1, this.depth, this.height, width_half, 0);
  buildPlane('z', 'y', 1, -1, this.depth, this.height, -width_half, 1);
  buildPlane('x', 'z', 1, 1, this.width, this.depth, height_half, 2);
  buildPlane('x', 'z', 1, -1, this.width, this.depth, -height_half, 3);
  buildPlane('x', 'y', 1, -1, this.width, this.height, depth_half, 4);
  buildPlane('x', 'y', -1, -1, this.width, this.height, -depth_half, 5);
  function buildPlane(u, v, udir, vdir, width, height, depth, materialIndex) {
    var w, ix, iy, gridX = scope.widthSegments, gridY = scope.heightSegments, width_half = width / 2, height_half = height / 2, offset = scope.vertices.length;
    if (u === 'x' && v === 'y' || u === 'y' && v === 'x') {
      w = 'z';
    } else if (u === 'x' && v === 'z' || u === 'z' && v === 'x') {
      w = 'y';
      gridY = scope.depthSegments;
    } else if (u === 'z' && v === 'y' || u === 'y' && v === 'z') {
      w = 'x';
      gridX = scope.depthSegments;
    }
    var gridX1 = gridX + 1, gridY1 = gridY + 1, segment_width = width / gridX, segment_height = height / gridY, normal = new THREE.Vector3();
    normal[w] = depth > 0 ? 1 : -1;
    for (iy = 0; iy < gridY1; iy++) {
      for (ix = 0; ix < gridX1; ix++) {
        var vector = new THREE.Vector3();
        vector[u] = (ix * segment_width - width_half) * udir;
        vector[v] = (iy * segment_height - height_half) * vdir;
        vector[w] = depth;
        scope.vertices.push(vector);
      }
    }
    for (iy = 0; iy < gridY; iy++) {
      for (ix = 0; ix < gridX; ix++) {
        var a = ix + gridX1 * iy;
        var b = ix + gridX1 * (iy + 1);
        var c = ix + 1 + gridX1 * (iy + 1);
        var d = ix + 1 + gridX1 * iy;
        var uva = new THREE.Vector2(ix / gridX, 1 - iy / gridY);
        var uvb = new THREE.Vector2(ix / gridX, 1 - (iy + 1) / gridY);
        var uvc = new THREE.Vector2((ix + 1) / gridX, 1 - (iy + 1) / gridY);
        var uvd = new THREE.Vector2((ix + 1) / gridX, 1 - iy / gridY);
        var face = new THREE.Face3(a + offset, b + offset, d + offset);
        face.normal.copy(normal);
        face.vertexNormals.push(normal.clone(), normal.clone(), normal.clone());
        face.materialIndex = materialIndex;
        scope.faces.push(face);
        scope.faceVertexUvs[0].push([
          uva,
          uvb,
          uvd
        ]);
        face = new THREE.Face3(b + offset, c + offset, d + offset);
        face.normal.copy(normal);
        face.vertexNormals.push(normal.clone(), normal.clone(), normal.clone());
        face.materialIndex = materialIndex;
        scope.faces.push(face);
        scope.faceVertexUvs[0].push([
          uvb.clone(),
          uvc,
          uvd.clone()
        ]);
      }
    }
  }
  this.computeCentroids();
  this.mergeVertices();
};
THREE.CubeGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.CylinderGeometry = function (radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded) {
  THREE.Geometry.call(this);
  this.radiusTop = radiusTop = radiusTop !== undefined ? radiusTop : 20;
  this.radiusBottom = radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;
  this.height = height = height !== undefined ? height : 100;
  this.radialSegments = radialSegments = radialSegments || 8;
  this.heightSegments = heightSegments = heightSegments || 1;
  this.openEnded = openEnded = openEnded !== undefined ? openEnded : false;
  var heightHalf = height / 2;
  var x, y, vertices = [], uvs = [];
  for (y = 0; y <= heightSegments; y++) {
    var verticesRow = [];
    var uvsRow = [];
    var v = y / heightSegments;
    var radius = v * (radiusBottom - radiusTop) + radiusTop;
    for (x = 0; x <= radialSegments; x++) {
      var u = x / radialSegments;
      var vertex = new THREE.Vector3();
      vertex.x = radius * Math.sin(u * Math.PI * 2);
      vertex.y = -v * height + heightHalf;
      vertex.z = radius * Math.cos(u * Math.PI * 2);
      this.vertices.push(vertex);
      verticesRow.push(this.vertices.length - 1);
      uvsRow.push(new THREE.Vector2(u, 1 - v));
    }
    vertices.push(verticesRow);
    uvs.push(uvsRow);
  }
  var tanTheta = (radiusBottom - radiusTop) / height;
  var na, nb;
  for (x = 0; x < radialSegments; x++) {
    if (radiusTop !== 0) {
      na = this.vertices[vertices[0][x]].clone();
      nb = this.vertices[vertices[0][x + 1]].clone();
    } else {
      na = this.vertices[vertices[1][x]].clone();
      nb = this.vertices[vertices[1][x + 1]].clone();
    }
    na.setY(Math.sqrt(na.x * na.x + na.z * na.z) * tanTheta).normalize();
    nb.setY(Math.sqrt(nb.x * nb.x + nb.z * nb.z) * tanTheta).normalize();
    for (y = 0; y < heightSegments; y++) {
      var v1 = vertices[y][x];
      var v2 = vertices[y + 1][x];
      var v3 = vertices[y + 1][x + 1];
      var v4 = vertices[y][x + 1];
      var n1 = na.clone();
      var n2 = na.clone();
      var n3 = nb.clone();
      var n4 = nb.clone();
      var uv1 = uvs[y][x].clone();
      var uv2 = uvs[y + 1][x].clone();
      var uv3 = uvs[y + 1][x + 1].clone();
      var uv4 = uvs[y][x + 1].clone();
      this.faces.push(new THREE.Face3(v1, v2, v4, [
        n1,
        n2,
        n4
      ]));
      this.faceVertexUvs[0].push([
        uv1,
        uv2,
        uv4
      ]);
      this.faces.push(new THREE.Face3(v2, v3, v4, [
        n2,
        n3,
        n4
      ]));
      this.faceVertexUvs[0].push([
        uv2,
        uv3,
        uv4
      ]);
    }
  }
  if (openEnded === false && radiusTop > 0) {
    this.vertices.push(new THREE.Vector3(0, heightHalf, 0));
    for (x = 0; x < radialSegments; x++) {
      var v1 = vertices[0][x];
      var v2 = vertices[0][x + 1];
      var v3 = this.vertices.length - 1;
      var n1 = new THREE.Vector3(0, 1, 0);
      var n2 = new THREE.Vector3(0, 1, 0);
      var n3 = new THREE.Vector3(0, 1, 0);
      var uv1 = uvs[0][x].clone();
      var uv2 = uvs[0][x + 1].clone();
      var uv3 = new THREE.Vector2(uv2.u, 0);
      this.faces.push(new THREE.Face3(v1, v2, v3, [
        n1,
        n2,
        n3
      ]));
      this.faceVertexUvs[0].push([
        uv1,
        uv2,
        uv3
      ]);
    }
  }
  if (openEnded === false && radiusBottom > 0) {
    this.vertices.push(new THREE.Vector3(0, -heightHalf, 0));
    for (x = 0; x < radialSegments; x++) {
      var v1 = vertices[y][x + 1];
      var v2 = vertices[y][x];
      var v3 = this.vertices.length - 1;
      var n1 = new THREE.Vector3(0, -1, 0);
      var n2 = new THREE.Vector3(0, -1, 0);
      var n3 = new THREE.Vector3(0, -1, 0);
      var uv1 = uvs[y][x + 1].clone();
      var uv2 = uvs[y][x].clone();
      var uv3 = new THREE.Vector2(uv2.u, 1);
      this.faces.push(new THREE.Face3(v1, v2, v3, [
        n1,
        n2,
        n3
      ]));
      this.faceVertexUvs[0].push([
        uv1,
        uv2,
        uv3
      ]);
    }
  }
  this.computeCentroids();
  this.computeFaceNormals();
};
THREE.CylinderGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.ExtrudeGeometry = function (shapes, options) {
  if (typeof shapes === 'undefined') {
    shapes = [];
    return;
  }
  THREE.Geometry.call(this);
  shapes = shapes instanceof Array ? shapes : [shapes];
  this.shapebb = shapes[shapes.length - 1].getBoundingBox();
  this.addShapeList(shapes, options);
  this.computeCentroids();
  this.computeFaceNormals();
};
THREE.ExtrudeGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.ExtrudeGeometry.prototype.addShapeList = function (shapes, options) {
  var sl = shapes.length;
  for (var s = 0; s < sl; s++) {
    var shape = shapes[s];
    this.addShape(shape, options);
  }
};
THREE.ExtrudeGeometry.prototype.addShape = function (shape, options) {
  var amount = options.amount !== undefined ? options.amount : 100;
  var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6;
  var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2;
  var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;
  var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
  var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
  var steps = options.steps !== undefined ? options.steps : 1;
  var extrudePath = options.extrudePath;
  var extrudePts, extrudeByPath = false;
  var material = options.material;
  var extrudeMaterial = options.extrudeMaterial;
  var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;
  var shapebb = this.shapebb;
  var splineTube, binormal, normal, position2;
  if (extrudePath) {
    extrudePts = extrudePath.getSpacedPoints(steps);
    extrudeByPath = true;
    bevelEnabled = false;
    splineTube = options.frames !== undefined ? options.frames : new THREE.TubeGeometry.FrenetFrames(extrudePath, steps, false);
    binormal = new THREE.Vector3();
    normal = new THREE.Vector3();
    position2 = new THREE.Vector3();
  }
  if (!bevelEnabled) {
    bevelSegments = 0;
    bevelThickness = 0;
    bevelSize = 0;
  }
  var ahole, h, hl;
  var scope = this;
  var bevelPoints = [];
  var shapesOffset = this.vertices.length;
  var shapePoints = shape.extractPoints(curveSegments);
  var vertices = shapePoints.shape;
  var holes = shapePoints.holes;
  var reverse = !THREE.Shape.Utils.isClockWise(vertices);
  if (reverse) {
    vertices = vertices.reverse();
    for (h = 0, hl = holes.length; h < hl; h++) {
      ahole = holes[h];
      if (THREE.Shape.Utils.isClockWise(ahole)) {
        holes[h] = ahole.reverse();
      }
    }
    reverse = false;
  }
  var faces = THREE.Shape.Utils.triangulateShape(vertices, holes);
  var contour = vertices;
  for (h = 0, hl = holes.length; h < hl; h++) {
    ahole = holes[h];
    vertices = vertices.concat(ahole);
  }
  function scalePt2(pt, vec, size) {
    if (!vec)
      console.log('die');
    return vec.clone().multiplyScalar(size).add(pt);
  }
  var b, bs, t, z, vert, vlen = vertices.length, face, flen = faces.length, cont, clen = contour.length;
  var RAD_TO_DEGREES = 180 / Math.PI;
  function getBevelVec(pt_i, pt_j, pt_k) {
    return getBevelVec2(pt_i, pt_j, pt_k);
  }
  function getBevelVec1(pt_i, pt_j, pt_k) {
    var anglea = Math.atan2(pt_j.y - pt_i.y, pt_j.x - pt_i.x);
    var angleb = Math.atan2(pt_k.y - pt_i.y, pt_k.x - pt_i.x);
    if (anglea > angleb) {
      angleb += Math.PI * 2;
    }
    var anglec = (anglea + angleb) / 2;
    var x = -Math.cos(anglec);
    var y = -Math.sin(anglec);
    var vec = new THREE.Vector2(x, y);
    return vec;
  }
  function getBevelVec2(pt_i, pt_j, pt_k) {
    var a = THREE.ExtrudeGeometry.__v1, b = THREE.ExtrudeGeometry.__v2, v_hat = THREE.ExtrudeGeometry.__v3, w_hat = THREE.ExtrudeGeometry.__v4, p = THREE.ExtrudeGeometry.__v5, q = THREE.ExtrudeGeometry.__v6, v, w, v_dot_w_hat, q_sub_p_dot_w_hat, s, intersection;
    a.set(pt_i.x - pt_j.x, pt_i.y - pt_j.y);
    b.set(pt_i.x - pt_k.x, pt_i.y - pt_k.y);
    v = a.normalize();
    w = b.normalize();
    v_hat.set(-v.y, v.x);
    w_hat.set(w.y, -w.x);
    p.copy(pt_i).add(v_hat);
    q.copy(pt_i).add(w_hat);
    if (p.equals(q)) {
      return w_hat.clone();
    }
    p.copy(pt_j).add(v_hat);
    q.copy(pt_k).add(w_hat);
    v_dot_w_hat = v.dot(w_hat);
    q_sub_p_dot_w_hat = q.sub(p).dot(w_hat);
    if (v_dot_w_hat === 0) {
      console.log('Either infinite or no solutions!');
      if (q_sub_p_dot_w_hat === 0) {
        console.log('Its finite solutions.');
      } else {
        console.log('Too bad, no solutions.');
      }
    }
    s = q_sub_p_dot_w_hat / v_dot_w_hat;
    if (s < 0) {
      return getBevelVec1(pt_i, pt_j, pt_k);
    }
    intersection = v.multiplyScalar(s).add(p);
    return intersection.sub(pt_i).clone();
  }
  var contourMovements = [];
  for (var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
    if (j === il)
      j = 0;
    if (k === il)
      k = 0;
    var pt_i = contour[i];
    var pt_j = contour[j];
    var pt_k = contour[k];
    contourMovements[i] = getBevelVec(contour[i], contour[j], contour[k]);
  }
  var holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();
  for (h = 0, hl = holes.length; h < hl; h++) {
    ahole = holes[h];
    oneHoleMovements = [];
    for (i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
      if (j === il)
        j = 0;
      if (k === il)
        k = 0;
      oneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k]);
    }
    holesMovements.push(oneHoleMovements);
    verticesMovements = verticesMovements.concat(oneHoleMovements);
  }
  for (b = 0; b < bevelSegments; b++) {
    t = b / bevelSegments;
    z = bevelThickness * (1 - t);
    bs = bevelSize * Math.sin(t * Math.PI / 2);
    for (i = 0, il = contour.length; i < il; i++) {
      vert = scalePt2(contour[i], contourMovements[i], bs);
      v(vert.x, vert.y, -z);
    }
    for (h = 0, hl = holes.length; h < hl; h++) {
      ahole = holes[h];
      oneHoleMovements = holesMovements[h];
      for (i = 0, il = ahole.length; i < il; i++) {
        vert = scalePt2(ahole[i], oneHoleMovements[i], bs);
        v(vert.x, vert.y, -z);
      }
    }
  }
  bs = bevelSize;
  for (i = 0; i < vlen; i++) {
    vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
    if (!extrudeByPath) {
      v(vert.x, vert.y, 0);
    } else {
      normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
      binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);
      position2.copy(extrudePts[0]).add(normal).add(binormal);
      v(position2.x, position2.y, position2.z);
    }
  }
  var s;
  for (s = 1; s <= steps; s++) {
    for (i = 0; i < vlen; i++) {
      vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
      if (!extrudeByPath) {
        v(vert.x, vert.y, amount / steps * s);
      } else {
        normal.copy(splineTube.normals[s]).multiplyScalar(vert.x);
        binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);
        position2.copy(extrudePts[s]).add(normal).add(binormal);
        v(position2.x, position2.y, position2.z);
      }
    }
  }
  for (b = bevelSegments - 1; b >= 0; b--) {
    t = b / bevelSegments;
    z = bevelThickness * (1 - t);
    bs = bevelSize * Math.sin(t * Math.PI / 2);
    for (i = 0, il = contour.length; i < il; i++) {
      vert = scalePt2(contour[i], contourMovements[i], bs);
      v(vert.x, vert.y, amount + z);
    }
    for (h = 0, hl = holes.length; h < hl; h++) {
      ahole = holes[h];
      oneHoleMovements = holesMovements[h];
      for (i = 0, il = ahole.length; i < il; i++) {
        vert = scalePt2(ahole[i], oneHoleMovements[i], bs);
        if (!extrudeByPath) {
          v(vert.x, vert.y, amount + z);
        } else {
          v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z);
        }
      }
    }
  }
  buildLidFaces();
  buildSideFaces();
  function buildLidFaces() {
    if (bevelEnabled) {
      var layer = 0;
      var offset = vlen * layer;
      for (i = 0; i < flen; i++) {
        face = faces[i];
        f3(face[2] + offset, face[1] + offset, face[0] + offset, true);
      }
      layer = steps + bevelSegments * 2;
      offset = vlen * layer;
      for (i = 0; i < flen; i++) {
        face = faces[i];
        f3(face[0] + offset, face[1] + offset, face[2] + offset, false);
      }
    } else {
      for (i = 0; i < flen; i++) {
        face = faces[i];
        f3(face[2], face[1], face[0], true);
      }
      for (i = 0; i < flen; i++) {
        face = faces[i];
        f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps, false);
      }
    }
  }
  function buildSideFaces() {
    var layeroffset = 0;
    sidewalls(contour, layeroffset);
    layeroffset += contour.length;
    for (h = 0, hl = holes.length; h < hl; h++) {
      ahole = holes[h];
      sidewalls(ahole, layeroffset);
      layeroffset += ahole.length;
    }
  }
  function sidewalls(contour, layeroffset) {
    var j, k;
    i = contour.length;
    while (--i >= 0) {
      j = i;
      k = i - 1;
      if (k < 0)
        k = contour.length - 1;
      var s = 0, sl = steps + bevelSegments * 2;
      for (s = 0; s < sl; s++) {
        var slen1 = vlen * s;
        var slen2 = vlen * (s + 1);
        var a = layeroffset + j + slen1, b = layeroffset + k + slen1, c = layeroffset + k + slen2, d = layeroffset + j + slen2;
        f4(a, b, c, d, contour, s, sl, j, k);
      }
    }
  }
  function v(x, y, z) {
    scope.vertices.push(new THREE.Vector3(x, y, z));
  }
  function f3(a, b, c, isBottom) {
    a += shapesOffset;
    b += shapesOffset;
    c += shapesOffset;
    scope.faces.push(new THREE.Face3(a, b, c, null, null, material));
    var uvs = isBottom ? uvgen.generateBottomUV(scope, shape, options, a, b, c) : uvgen.generateTopUV(scope, shape, options, a, b, c);
    scope.faceVertexUvs[0].push(uvs);
  }
  function f4(a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2) {
    a += shapesOffset;
    b += shapesOffset;
    c += shapesOffset;
    d += shapesOffset;
    scope.faces.push(new THREE.Face3(a, b, d, null, null, extrudeMaterial));
    scope.faces.push(new THREE.Face3(b, c, d, null, null, extrudeMaterial));
    var uvs = uvgen.generateSideWallUV(scope, shape, wallContour, options, a, b, c, d, stepIndex, stepsLength, contourIndex1, contourIndex2);
    scope.faceVertexUvs[0].push([
      uvs[0],
      uvs[1],
      uvs[3]
    ]);
    scope.faceVertexUvs[0].push([
      uvs[1],
      uvs[2],
      uvs[3]
    ]);
  }
};
THREE.ExtrudeGeometry.WorldUVGenerator = {
  generateTopUV: function (geometry, extrudedShape, extrudeOptions, indexA, indexB, indexC) {
    var ax = geometry.vertices[indexA].x, ay = geometry.vertices[indexA].y, bx = geometry.vertices[indexB].x, by = geometry.vertices[indexB].y, cx = geometry.vertices[indexC].x, cy = geometry.vertices[indexC].y;
    return [
      new THREE.Vector2(ax, ay),
      new THREE.Vector2(bx, by),
      new THREE.Vector2(cx, cy)
    ];
  },
  generateBottomUV: function (geometry, extrudedShape, extrudeOptions, indexA, indexB, indexC) {
    return this.generateTopUV(geometry, extrudedShape, extrudeOptions, indexA, indexB, indexC);
  },
  generateSideWallUV: function (geometry, extrudedShape, wallContour, extrudeOptions, indexA, indexB, indexC, indexD, stepIndex, stepsLength, contourIndex1, contourIndex2) {
    var ax = geometry.vertices[indexA].x, ay = geometry.vertices[indexA].y, az = geometry.vertices[indexA].z, bx = geometry.vertices[indexB].x, by = geometry.vertices[indexB].y, bz = geometry.vertices[indexB].z, cx = geometry.vertices[indexC].x, cy = geometry.vertices[indexC].y, cz = geometry.vertices[indexC].z, dx = geometry.vertices[indexD].x, dy = geometry.vertices[indexD].y, dz = geometry.vertices[indexD].z;
    if (Math.abs(ay - by) < 0.01) {
      return [
        new THREE.Vector2(ax, 1 - az),
        new THREE.Vector2(bx, 1 - bz),
        new THREE.Vector2(cx, 1 - cz),
        new THREE.Vector2(dx, 1 - dz)
      ];
    } else {
      return [
        new THREE.Vector2(ay, 1 - az),
        new THREE.Vector2(by, 1 - bz),
        new THREE.Vector2(cy, 1 - cz),
        new THREE.Vector2(dy, 1 - dz)
      ];
    }
  }
};
THREE.ExtrudeGeometry.__v1 = new THREE.Vector2();
THREE.ExtrudeGeometry.__v2 = new THREE.Vector2();
THREE.ExtrudeGeometry.__v3 = new THREE.Vector2();
THREE.ExtrudeGeometry.__v4 = new THREE.Vector2();
THREE.ExtrudeGeometry.__v5 = new THREE.Vector2();
THREE.ExtrudeGeometry.__v6 = new THREE.Vector2();
THREE.ShapeGeometry = function (shapes, options) {
  THREE.Geometry.call(this);
  if (shapes instanceof Array === false)
    shapes = [shapes];
  this.shapebb = shapes[shapes.length - 1].getBoundingBox();
  this.addShapeList(shapes, options);
  this.computeCentroids();
  this.computeFaceNormals();
};
THREE.ShapeGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.ShapeGeometry.prototype.addShapeList = function (shapes, options) {
  for (var i = 0, l = shapes.length; i < l; i++) {
    this.addShape(shapes[i], options);
  }
  return this;
};
THREE.ShapeGeometry.prototype.addShape = function (shape, options) {
  if (options === undefined)
    options = {};
  var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
  var material = options.material;
  var uvgen = options.UVGenerator === undefined ? THREE.ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;
  var shapebb = this.shapebb;
  var i, l, hole, s;
  var shapesOffset = this.vertices.length;
  var shapePoints = shape.extractPoints(curveSegments);
  var vertices = shapePoints.shape;
  var holes = shapePoints.holes;
  var reverse = !THREE.Shape.Utils.isClockWise(vertices);
  if (reverse) {
    vertices = vertices.reverse();
    for (i = 0, l = holes.length; i < l; i++) {
      hole = holes[i];
      if (THREE.Shape.Utils.isClockWise(hole)) {
        holes[i] = hole.reverse();
      }
    }
    reverse = false;
  }
  var faces = THREE.Shape.Utils.triangulateShape(vertices, holes);
  var contour = vertices;
  for (i = 0, l = holes.length; i < l; i++) {
    hole = holes[i];
    vertices = vertices.concat(hole);
  }
  var vert, vlen = vertices.length;
  var face, flen = faces.length;
  var cont, clen = contour.length;
  for (i = 0; i < vlen; i++) {
    vert = vertices[i];
    this.vertices.push(new THREE.Vector3(vert.x, vert.y, 0));
  }
  for (i = 0; i < flen; i++) {
    face = faces[i];
    var a = face[0] + shapesOffset;
    var b = face[1] + shapesOffset;
    var c = face[2] + shapesOffset;
    this.faces.push(new THREE.Face3(a, b, c, null, null, material));
    this.faceVertexUvs[0].push(uvgen.generateBottomUV(this, shape, options, a, b, c));
  }
};
THREE.LatheGeometry = function (points, segments, phiStart, phiLength) {
  THREE.Geometry.call(this);
  segments = segments || 12;
  phiStart = phiStart || 0;
  phiLength = phiLength || 2 * Math.PI;
  var inversePointLength = 1 / (points.length - 1);
  var inverseSegments = 1 / segments;
  for (var i = 0, il = segments; i <= il; i++) {
    var phi = phiStart + i * inverseSegments * phiLength;
    var c = Math.cos(phi), s = Math.sin(phi);
    for (var j = 0, jl = points.length; j < jl; j++) {
      var pt = points[j];
      var vertex = new THREE.Vector3();
      vertex.x = c * pt.x - s * pt.y;
      vertex.y = s * pt.x + c * pt.y;
      vertex.z = pt.z;
      this.vertices.push(vertex);
    }
  }
  var np = points.length;
  for (var i = 0, il = segments; i < il; i++) {
    for (var j = 0, jl = points.length - 1; j < jl; j++) {
      var base = j + np * i;
      var a = base;
      var b = base + np;
      var c = base + 1 + np;
      var d = base + 1;
      var u0 = i * inverseSegments;
      var v0 = j * inversePointLength;
      var u1 = u0 + inverseSegments;
      var v1 = v0 + inversePointLength;
      this.faces.push(new THREE.Face3(a, b, d));
      this.faceVertexUvs[0].push([
        new THREE.Vector2(u0, v0),
        new THREE.Vector2(u1, v0),
        new THREE.Vector2(u0, v1)
      ]);
      this.faces.push(new THREE.Face3(b, c, d));
      this.faceVertexUvs[0].push([
        new THREE.Vector2(u1, v0),
        new THREE.Vector2(u1, v1),
        new THREE.Vector2(u0, v1)
      ]);
    }
  }
  this.mergeVertices();
  this.computeCentroids();
  this.computeFaceNormals();
  this.computeVertexNormals();
};
THREE.LatheGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.PlaneGeometry = function (width, height, widthSegments, heightSegments) {
  THREE.Geometry.call(this);
  this.width = width;
  this.height = height;
  this.widthSegments = widthSegments || 1;
  this.heightSegments = heightSegments || 1;
  var ix, iz;
  var width_half = width / 2;
  var height_half = height / 2;
  var gridX = this.widthSegments;
  var gridZ = this.heightSegments;
  var gridX1 = gridX + 1;
  var gridZ1 = gridZ + 1;
  var segment_width = this.width / gridX;
  var segment_height = this.height / gridZ;
  var normal = new THREE.Vector3(0, 0, 1);
  for (iz = 0; iz < gridZ1; iz++) {
    for (ix = 0; ix < gridX1; ix++) {
      var x = ix * segment_width - width_half;
      var y = iz * segment_height - height_half;
      this.vertices.push(new THREE.Vector3(x, -y, 0));
    }
  }
  for (iz = 0; iz < gridZ; iz++) {
    for (ix = 0; ix < gridX; ix++) {
      var a = ix + gridX1 * iz;
      var b = ix + gridX1 * (iz + 1);
      var c = ix + 1 + gridX1 * (iz + 1);
      var d = ix + 1 + gridX1 * iz;
      var uva = new THREE.Vector2(ix / gridX, 1 - iz / gridZ);
      var uvb = new THREE.Vector2(ix / gridX, 1 - (iz + 1) / gridZ);
      var uvc = new THREE.Vector2((ix + 1) / gridX, 1 - (iz + 1) / gridZ);
      var uvd = new THREE.Vector2((ix + 1) / gridX, 1 - iz / gridZ);
      var face = new THREE.Face3(a, b, d);
      face.normal.copy(normal);
      face.vertexNormals.push(normal.clone(), normal.clone(), normal.clone());
      this.faces.push(face);
      this.faceVertexUvs[0].push([
        uva,
        uvb,
        uvd
      ]);
      face = new THREE.Face3(b, c, d);
      face.normal.copy(normal);
      face.vertexNormals.push(normal.clone(), normal.clone(), normal.clone());
      this.faces.push(face);
      this.faceVertexUvs[0].push([
        uvb.clone(),
        uvc,
        uvd.clone()
      ]);
    }
  }
  this.computeCentroids();
};
THREE.PlaneGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.RingGeometry = function (innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
  THREE.Geometry.call(this);
  innerRadius = innerRadius || 0;
  outerRadius = outerRadius || 50;
  thetaStart = thetaStart !== undefined ? thetaStart : 0;
  thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
  thetaSegments = thetaSegments !== undefined ? Math.max(3, thetaSegments) : 8;
  phiSegments = phiSegments !== undefined ? Math.max(3, phiSegments) : 8;
  var i, o, uvs = [], radius = innerRadius, radiusStep = (outerRadius - innerRadius) / phiSegments;
  for (i = 0; i <= phiSegments; i++) {
    for (o = 0; o <= thetaSegments; o++) {
      var vertex = new THREE.Vector3();
      var segment = thetaStart + o / thetaSegments * thetaLength;
      vertex.x = radius * Math.cos(segment);
      vertex.y = radius * Math.sin(segment);
      this.vertices.push(vertex);
      uvs.push(new THREE.Vector2((vertex.x / radius + 1) / 2, -(vertex.y / radius + 1) / 2 + 1));
    }
    radius += radiusStep;
  }
  var n = new THREE.Vector3(0, 0, 1);
  for (i = 0; i < phiSegments; i++) {
    var thetaSegment = i * thetaSegments;
    for (o = 0; o <= thetaSegments; o++) {
      var segment = o + thetaSegment;
      var v1 = segment + i;
      var v2 = segment + thetaSegments + i;
      var v3 = segment + thetaSegments + 1 + i;
      this.faces.push(new THREE.Face3(v1, v2, v3, [
        n,
        n,
        n
      ]));
      this.faceVertexUvs[0].push([
        uvs[v1],
        uvs[v2],
        uvs[v3]
      ]);
      v1 = segment + i;
      v2 = segment + thetaSegments + 1 + i;
      v3 = segment + 1 + i;
      this.faces.push(new THREE.Face3(v1, v2, v3, [
        n,
        n,
        n
      ]));
      this.faceVertexUvs[0].push([
        uvs[v1],
        uvs[v2],
        uvs[v3]
      ]);
    }
  }
  this.computeCentroids();
  this.computeFaceNormals();
  this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), radius);
};
THREE.RingGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.SphereGeometry = function (radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
  THREE.Geometry.call(this);
  this.radius = radius = radius || 50;
  this.widthSegments = widthSegments = Math.max(3, Math.floor(widthSegments) || 8);
  this.heightSegments = heightSegments = Math.max(2, Math.floor(heightSegments) || 6);
  this.phiStart = phiStart = phiStart !== undefined ? phiStart : 0;
  this.phiLength = phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;
  this.thetaStart = thetaStart = thetaStart !== undefined ? thetaStart : 0;
  this.thetaLength = thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;
  var x, y, vertices = [], uvs = [];
  for (y = 0; y <= heightSegments; y++) {
    var verticesRow = [];
    var uvsRow = [];
    for (x = 0; x <= widthSegments; x++) {
      var u = x / widthSegments;
      var v = y / heightSegments;
      var vertex = new THREE.Vector3();
      vertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
      vertex.y = radius * Math.cos(thetaStart + v * thetaLength);
      vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
      this.vertices.push(vertex);
      verticesRow.push(this.vertices.length - 1);
      uvsRow.push(new THREE.Vector2(u, 1 - v));
    }
    vertices.push(verticesRow);
    uvs.push(uvsRow);
  }
  for (y = 0; y < this.heightSegments; y++) {
    for (x = 0; x < this.widthSegments; x++) {
      var v1 = vertices[y][x + 1];
      var v2 = vertices[y][x];
      var v3 = vertices[y + 1][x];
      var v4 = vertices[y + 1][x + 1];
      var n1 = this.vertices[v1].clone().normalize();
      var n2 = this.vertices[v2].clone().normalize();
      var n3 = this.vertices[v3].clone().normalize();
      var n4 = this.vertices[v4].clone().normalize();
      var uv1 = uvs[y][x + 1].clone();
      var uv2 = uvs[y][x].clone();
      var uv3 = uvs[y + 1][x].clone();
      var uv4 = uvs[y + 1][x + 1].clone();
      if (Math.abs(this.vertices[v1].y) === this.radius) {
        this.faces.push(new THREE.Face3(v1, v3, v4, [
          n1,
          n3,
          n4
        ]));
        this.faceVertexUvs[0].push([
          uv1,
          uv3,
          uv4
        ]);
      } else if (Math.abs(this.vertices[v3].y) === this.radius) {
        this.faces.push(new THREE.Face3(v1, v2, v3, [
          n1,
          n2,
          n3
        ]));
        this.faceVertexUvs[0].push([
          uv1,
          uv2,
          uv3
        ]);
      } else {
        this.faces.push(new THREE.Face3(v1, v2, v4, [
          n1,
          n2,
          n4
        ]));
        this.faceVertexUvs[0].push([
          uv1,
          uv2,
          uv4
        ]);
        this.faces.push(new THREE.Face3(v2, v3, v4, [
          n2,
          n3,
          n4
        ]));
        this.faceVertexUvs[0].push([
          uv2.clone(),
          uv3,
          uv4.clone()
        ]);
      }
    }
  }
  this.computeCentroids();
  this.computeFaceNormals();
  this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), radius);
};
THREE.SphereGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.TextGeometry = function (text, parameters) {
  parameters = parameters || {};
  var textShapes = THREE.FontUtils.generateShapes(text, parameters);
  parameters.amount = parameters.height !== undefined ? parameters.height : 50;
  if (parameters.bevelThickness === undefined)
    parameters.bevelThickness = 10;
  if (parameters.bevelSize === undefined)
    parameters.bevelSize = 8;
  if (parameters.bevelEnabled === undefined)
    parameters.bevelEnabled = false;
  THREE.ExtrudeGeometry.call(this, textShapes, parameters);
};
THREE.TextGeometry.prototype = Object.create(THREE.ExtrudeGeometry.prototype);
THREE.TorusGeometry = function (radius, tube, radialSegments, tubularSegments, arc) {
  THREE.Geometry.call(this);
  var scope = this;
  this.radius = radius || 100;
  this.tube = tube || 40;
  this.radialSegments = radialSegments || 8;
  this.tubularSegments = tubularSegments || 6;
  this.arc = arc || Math.PI * 2;
  var center = new THREE.Vector3(), uvs = [], normals = [];
  for (var j = 0; j <= this.radialSegments; j++) {
    for (var i = 0; i <= this.tubularSegments; i++) {
      var u = i / this.tubularSegments * this.arc;
      var v = j / this.radialSegments * Math.PI * 2;
      center.x = this.radius * Math.cos(u);
      center.y = this.radius * Math.sin(u);
      var vertex = new THREE.Vector3();
      vertex.x = (this.radius + this.tube * Math.cos(v)) * Math.cos(u);
      vertex.y = (this.radius + this.tube * Math.cos(v)) * Math.sin(u);
      vertex.z = this.tube * Math.sin(v);
      this.vertices.push(vertex);
      uvs.push(new THREE.Vector2(i / this.tubularSegments, j / this.radialSegments));
      normals.push(vertex.clone().sub(center).normalize());
    }
  }
  for (var j = 1; j <= this.radialSegments; j++) {
    for (var i = 1; i <= this.tubularSegments; i++) {
      var a = (this.tubularSegments + 1) * j + i - 1;
      var b = (this.tubularSegments + 1) * (j - 1) + i - 1;
      var c = (this.tubularSegments + 1) * (j - 1) + i;
      var d = (this.tubularSegments + 1) * j + i;
      var face = new THREE.Face3(a, b, d, [
          normals[a],
          normals[b],
          normals[d]
        ]);
      face.normal.add(normals[a]);
      face.normal.add(normals[b]);
      face.normal.add(normals[d]);
      face.normal.normalize();
      this.faces.push(face);
      this.faceVertexUvs[0].push([
        uvs[a].clone(),
        uvs[b].clone(),
        uvs[d].clone()
      ]);
      face = new THREE.Face3(b, c, d, [
        normals[b],
        normals[c],
        normals[d]
      ]);
      face.normal.add(normals[b]);
      face.normal.add(normals[c]);
      face.normal.add(normals[d]);
      face.normal.normalize();
      this.faces.push(face);
      this.faceVertexUvs[0].push([
        uvs[b].clone(),
        uvs[c].clone(),
        uvs[d].clone()
      ]);
    }
  }
  this.computeCentroids();
};
THREE.TorusGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.TorusKnotGeometry = function (radius, tube, radialSegments, tubularSegments, p, q, heightScale) {
  THREE.Geometry.call(this);
  var scope = this;
  this.radius = radius || 100;
  this.tube = tube || 40;
  this.radialSegments = radialSegments || 64;
  this.tubularSegments = tubularSegments || 8;
  this.p = p || 2;
  this.q = q || 3;
  this.heightScale = heightScale || 1;
  this.grid = new Array(this.radialSegments);
  var tang = new THREE.Vector3();
  var n = new THREE.Vector3();
  var bitan = new THREE.Vector3();
  for (var i = 0; i < this.radialSegments; ++i) {
    this.grid[i] = new Array(this.tubularSegments);
    var u = i / this.radialSegments * 2 * this.p * Math.PI;
    var p1 = getPos(u, this.q, this.p, this.radius, this.heightScale);
    var p2 = getPos(u + 0.01, this.q, this.p, this.radius, this.heightScale);
    tang.subVectors(p2, p1);
    n.addVectors(p2, p1);
    bitan.crossVectors(tang, n);
    n.crossVectors(bitan, tang);
    bitan.normalize();
    n.normalize();
    for (var j = 0; j < this.tubularSegments; ++j) {
      var v = j / this.tubularSegments * 2 * Math.PI;
      var cx = -this.tube * Math.cos(v);
      var cy = this.tube * Math.sin(v);
      var pos = new THREE.Vector3();
      pos.x = p1.x + cx * n.x + cy * bitan.x;
      pos.y = p1.y + cx * n.y + cy * bitan.y;
      pos.z = p1.z + cx * n.z + cy * bitan.z;
      this.grid[i][j] = scope.vertices.push(pos) - 1;
    }
  }
  for (var i = 0; i < this.radialSegments; ++i) {
    for (var j = 0; j < this.tubularSegments; ++j) {
      var ip = (i + 1) % this.radialSegments;
      var jp = (j + 1) % this.tubularSegments;
      var a = this.grid[i][j];
      var b = this.grid[ip][j];
      var c = this.grid[ip][jp];
      var d = this.grid[i][jp];
      var uva = new THREE.Vector2(i / this.radialSegments, j / this.tubularSegments);
      var uvb = new THREE.Vector2((i + 1) / this.radialSegments, j / this.tubularSegments);
      var uvc = new THREE.Vector2((i + 1) / this.radialSegments, (j + 1) / this.tubularSegments);
      var uvd = new THREE.Vector2(i / this.radialSegments, (j + 1) / this.tubularSegments);
      this.faces.push(new THREE.Face3(a, b, d));
      this.faceVertexUvs[0].push([
        uva,
        uvb,
        uvd
      ]);
      this.faces.push(new THREE.Face3(b, c, d));
      this.faceVertexUvs[0].push([
        uvb.clone(),
        uvc,
        uvd.clone()
      ]);
    }
  }
  this.computeCentroids();
  this.computeFaceNormals();
  this.computeVertexNormals();
  function getPos(u, in_q, in_p, radius, heightScale) {
    var cu = Math.cos(u);
    var su = Math.sin(u);
    var quOverP = in_q / in_p * u;
    var cs = Math.cos(quOverP);
    var tx = radius * (2 + cs) * 0.5 * cu;
    var ty = radius * (2 + cs) * su * 0.5;
    var tz = heightScale * radius * Math.sin(quOverP) * 0.5;
    return new THREE.Vector3(tx, ty, tz);
  }
};
THREE.TorusKnotGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.TubeGeometry = function (path, segments, radius, radialSegments, closed) {
  THREE.Geometry.call(this);
  this.path = path;
  this.segments = segments || 64;
  this.radius = radius || 1;
  this.radialSegments = radialSegments || 8;
  this.closed = closed || false;
  this.grid = [];
  var scope = this, tangent, normal, binormal, numpoints = this.segments + 1, x, y, z, tx, ty, tz, u, v, cx, cy, pos, pos2 = new THREE.Vector3(), i, j, ip, jp, a, b, c, d, uva, uvb, uvc, uvd;
  var frames = new THREE.TubeGeometry.FrenetFrames(this.path, this.segments, this.closed), tangents = frames.tangents, normals = frames.normals, binormals = frames.binormals;
  this.tangents = tangents;
  this.normals = normals;
  this.binormals = binormals;
  function vert(x, y, z) {
    return scope.vertices.push(new THREE.Vector3(x, y, z)) - 1;
  }
  for (i = 0; i < numpoints; i++) {
    this.grid[i] = [];
    u = i / (numpoints - 1);
    pos = path.getPointAt(u);
    tangent = tangents[i];
    normal = normals[i];
    binormal = binormals[i];
    for (j = 0; j < this.radialSegments; j++) {
      v = j / this.radialSegments * 2 * Math.PI;
      cx = -this.radius * Math.cos(v);
      cy = this.radius * Math.sin(v);
      pos2.copy(pos);
      pos2.x += cx * normal.x + cy * binormal.x;
      pos2.y += cx * normal.y + cy * binormal.y;
      pos2.z += cx * normal.z + cy * binormal.z;
      this.grid[i][j] = vert(pos2.x, pos2.y, pos2.z);
    }
  }
  for (i = 0; i < this.segments; i++) {
    for (j = 0; j < this.radialSegments; j++) {
      ip = this.closed ? (i + 1) % this.segments : i + 1;
      jp = (j + 1) % this.radialSegments;
      a = this.grid[i][j];
      b = this.grid[ip][j];
      c = this.grid[ip][jp];
      d = this.grid[i][jp];
      uva = new THREE.Vector2(i / this.segments, j / this.radialSegments);
      uvb = new THREE.Vector2((i + 1) / this.segments, j / this.radialSegments);
      uvc = new THREE.Vector2((i + 1) / this.segments, (j + 1) / this.radialSegments);
      uvd = new THREE.Vector2(i / this.segments, (j + 1) / this.radialSegments);
      this.faces.push(new THREE.Face3(a, b, d));
      this.faceVertexUvs[0].push([
        uva,
        uvb,
        uvd
      ]);
      this.faces.push(new THREE.Face3(b, c, d));
      this.faceVertexUvs[0].push([
        uvb.clone(),
        uvc,
        uvd.clone()
      ]);
    }
  }
  this.computeCentroids();
  this.computeFaceNormals();
  this.computeVertexNormals();
};
THREE.TubeGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.TubeGeometry.FrenetFrames = function (path, segments, closed) {
  var tangent = new THREE.Vector3(), normal = new THREE.Vector3(), binormal = new THREE.Vector3(), tangents = [], normals = [], binormals = [], vec = new THREE.Vector3(), mat = new THREE.Matrix4(), numpoints = segments + 1, theta, epsilon = 0.0001, smallest, tx, ty, tz, i, u, v;
  this.tangents = tangents;
  this.normals = normals;
  this.binormals = binormals;
  for (i = 0; i < numpoints; i++) {
    u = i / (numpoints - 1);
    tangents[i] = path.getTangentAt(u);
    tangents[i].normalize();
  }
  initialNormal3();
  function initialNormal1(lastBinormal) {
    normals[0] = new THREE.Vector3();
    binormals[0] = new THREE.Vector3();
    if (lastBinormal === undefined)
      lastBinormal = new THREE.Vector3(0, 0, 1);
    normals[0].crossVectors(lastBinormal, tangents[0]).normalize();
    binormals[0].crossVectors(tangents[0], normals[0]).normalize();
  }
  function initialNormal2() {
    var t2 = path.getTangentAt(epsilon);
    normals[0] = new THREE.Vector3().subVectors(t2, tangents[0]).normalize();
    binormals[0] = new THREE.Vector3().crossVectors(tangents[0], normals[0]);
    normals[0].crossVectors(binormals[0], tangents[0]).normalize();
    binormals[0].crossVectors(tangents[0], normals[0]).normalize();
  }
  function initialNormal3() {
    normals[0] = new THREE.Vector3();
    binormals[0] = new THREE.Vector3();
    smallest = Number.MAX_VALUE;
    tx = Math.abs(tangents[0].x);
    ty = Math.abs(tangents[0].y);
    tz = Math.abs(tangents[0].z);
    if (tx <= smallest) {
      smallest = tx;
      normal.set(1, 0, 0);
    }
    if (ty <= smallest) {
      smallest = ty;
      normal.set(0, 1, 0);
    }
    if (tz <= smallest) {
      normal.set(0, 0, 1);
    }
    vec.crossVectors(tangents[0], normal).normalize();
    normals[0].crossVectors(tangents[0], vec);
    binormals[0].crossVectors(tangents[0], normals[0]);
  }
  for (i = 1; i < numpoints; i++) {
    normals[i] = normals[i - 1].clone();
    binormals[i] = binormals[i - 1].clone();
    vec.crossVectors(tangents[i - 1], tangents[i]);
    if (vec.length() > epsilon) {
      vec.normalize();
      theta = Math.acos(THREE.Math.clamp(tangents[i - 1].dot(tangents[i]), -1, 1));
      normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta));
    }
    binormals[i].crossVectors(tangents[i], normals[i]);
  }
  if (closed) {
    theta = Math.acos(THREE.Math.clamp(normals[0].dot(normals[numpoints - 1]), -1, 1));
    theta /= numpoints - 1;
    if (tangents[0].dot(vec.crossVectors(normals[0], normals[numpoints - 1])) > 0) {
      theta = -theta;
    }
    for (i = 1; i < numpoints; i++) {
      normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i));
      binormals[i].crossVectors(tangents[i], normals[i]);
    }
  }
};
THREE.PolyhedronGeometry = function (vertices, faces, radius, detail) {
  THREE.Geometry.call(this);
  radius = radius || 1;
  detail = detail || 0;
  var that = this;
  for (var i = 0, l = vertices.length; i < l; i++) {
    prepare(new THREE.Vector3(vertices[i][0], vertices[i][1], vertices[i][2]));
  }
  var midpoints = [], p = this.vertices;
  var f = [];
  for (var i = 0, l = faces.length; i < l; i++) {
    var v1 = p[faces[i][0]];
    var v2 = p[faces[i][1]];
    var v3 = p[faces[i][2]];
    f[i] = new THREE.Face3(v1.index, v2.index, v3.index, [
      v1.clone(),
      v2.clone(),
      v3.clone()
    ]);
  }
  for (var i = 0, l = f.length; i < l; i++) {
    subdivide(f[i], detail);
  }
  for (var i = 0, l = this.faceVertexUvs[0].length; i < l; i++) {
    var uvs = this.faceVertexUvs[0][i];
    var x0 = uvs[0].x;
    var x1 = uvs[1].x;
    var x2 = uvs[2].x;
    var max = Math.max(x0, Math.max(x1, x2));
    var min = Math.min(x0, Math.min(x1, x2));
    if (max > 0.9 && min < 0.1) {
      if (x0 < 0.2)
        uvs[0].x += 1;
      if (x1 < 0.2)
        uvs[1].x += 1;
      if (x2 < 0.2)
        uvs[2].x += 1;
    }
  }
  for (var i = 0, l = this.vertices.length; i < l; i++) {
    this.vertices[i].multiplyScalar(radius);
  }
  this.mergeVertices();
  this.computeCentroids();
  this.computeFaceNormals();
  this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), radius);
  function prepare(vector) {
    var vertex = vector.normalize().clone();
    vertex.index = that.vertices.push(vertex) - 1;
    var u = azimuth(vector) / 2 / Math.PI + 0.5;
    var v = inclination(vector) / Math.PI + 0.5;
    vertex.uv = new THREE.Vector2(u, 1 - v);
    return vertex;
  }
  function make(v1, v2, v3) {
    var face = new THREE.Face3(v1.index, v2.index, v3.index, [
        v1.clone(),
        v2.clone(),
        v3.clone()
      ]);
    face.centroid.add(v1).add(v2).add(v3).divideScalar(3);
    that.faces.push(face);
    var azi = azimuth(face.centroid);
    that.faceVertexUvs[0].push([
      correctUV(v1.uv, v1, azi),
      correctUV(v2.uv, v2, azi),
      correctUV(v3.uv, v3, azi)
    ]);
  }
  function subdivide(face, detail) {
    var cols = Math.pow(2, detail);
    var cells = Math.pow(4, detail);
    var a = prepare(that.vertices[face.a]);
    var b = prepare(that.vertices[face.b]);
    var c = prepare(that.vertices[face.c]);
    var v = [];
    for (var i = 0; i <= cols; i++) {
      v[i] = [];
      var aj = prepare(a.clone().lerp(c, i / cols));
      var bj = prepare(b.clone().lerp(c, i / cols));
      var rows = cols - i;
      for (var j = 0; j <= rows; j++) {
        if (j == 0 && i == cols) {
          v[i][j] = aj;
        } else {
          v[i][j] = prepare(aj.clone().lerp(bj, j / rows));
        }
      }
    }
    for (var i = 0; i < cols; i++) {
      for (var j = 0; j < 2 * (cols - i) - 1; j++) {
        var k = Math.floor(j / 2);
        if (j % 2 == 0) {
          make(v[i][k + 1], v[i + 1][k], v[i][k]);
        } else {
          make(v[i][k + 1], v[i + 1][k + 1], v[i + 1][k]);
        }
      }
    }
  }
  function azimuth(vector) {
    return Math.atan2(vector.z, -vector.x);
  }
  function inclination(vector) {
    return Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));
  }
  function correctUV(uv, vector, azimuth) {
    if (azimuth < 0 && uv.x === 1)
      uv = new THREE.Vector2(uv.x - 1, uv.y);
    if (vector.x === 0 && vector.z === 0)
      uv = new THREE.Vector2(azimuth / 2 / Math.PI + 0.5, uv.y);
    return uv.clone();
  }
};
THREE.PolyhedronGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.IcosahedronGeometry = function (radius, detail) {
  this.radius = radius;
  this.detail = detail;
  var t = (1 + Math.sqrt(5)) / 2;
  var vertices = [
      [
        -1,
        t,
        0
      ],
      [
        1,
        t,
        0
      ],
      [
        -1,
        -t,
        0
      ],
      [
        1,
        -t,
        0
      ],
      [
        0,
        -1,
        t
      ],
      [
        0,
        1,
        t
      ],
      [
        0,
        -1,
        -t
      ],
      [
        0,
        1,
        -t
      ],
      [
        t,
        0,
        -1
      ],
      [
        t,
        0,
        1
      ],
      [
        -t,
        0,
        -1
      ],
      [
        -t,
        0,
        1
      ]
    ];
  var faces = [
      [
        0,
        11,
        5
      ],
      [
        0,
        5,
        1
      ],
      [
        0,
        1,
        7
      ],
      [
        0,
        7,
        10
      ],
      [
        0,
        10,
        11
      ],
      [
        1,
        5,
        9
      ],
      [
        5,
        11,
        4
      ],
      [
        11,
        10,
        2
      ],
      [
        10,
        7,
        6
      ],
      [
        7,
        1,
        8
      ],
      [
        3,
        9,
        4
      ],
      [
        3,
        4,
        2
      ],
      [
        3,
        2,
        6
      ],
      [
        3,
        6,
        8
      ],
      [
        3,
        8,
        9
      ],
      [
        4,
        9,
        5
      ],
      [
        2,
        4,
        11
      ],
      [
        6,
        2,
        10
      ],
      [
        8,
        6,
        7
      ],
      [
        9,
        8,
        1
      ]
    ];
  THREE.PolyhedronGeometry.call(this, vertices, faces, radius, detail);
};
THREE.IcosahedronGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.OctahedronGeometry = function (radius, detail) {
  var vertices = [
      [
        1,
        0,
        0
      ],
      [
        -1,
        0,
        0
      ],
      [
        0,
        1,
        0
      ],
      [
        0,
        -1,
        0
      ],
      [
        0,
        0,
        1
      ],
      [
        0,
        0,
        -1
      ]
    ];
  var faces = [
      [
        0,
        2,
        4
      ],
      [
        0,
        4,
        3
      ],
      [
        0,
        3,
        5
      ],
      [
        0,
        5,
        2
      ],
      [
        1,
        2,
        5
      ],
      [
        1,
        5,
        3
      ],
      [
        1,
        3,
        4
      ],
      [
        1,
        4,
        2
      ]
    ];
  THREE.PolyhedronGeometry.call(this, vertices, faces, radius, detail);
};
THREE.OctahedronGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.TetrahedronGeometry = function (radius, detail) {
  var vertices = [
      [
        1,
        1,
        1
      ],
      [
        -1,
        -1,
        1
      ],
      [
        -1,
        1,
        -1
      ],
      [
        1,
        -1,
        -1
      ]
    ];
  var faces = [
      [
        2,
        1,
        0
      ],
      [
        0,
        3,
        2
      ],
      [
        1,
        3,
        0
      ],
      [
        2,
        3,
        1
      ]
    ];
  THREE.PolyhedronGeometry.call(this, vertices, faces, radius, detail);
};
THREE.TetrahedronGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.ParametricGeometry = function (func, slices, stacks) {
  THREE.Geometry.call(this);
  var verts = this.vertices;
  var faces = this.faces;
  var uvs = this.faceVertexUvs[0];
  var i, il, j, p;
  var u, v;
  var stackCount = stacks + 1;
  var sliceCount = slices + 1;
  for (i = 0; i <= stacks; i++) {
    v = i / stacks;
    for (j = 0; j <= slices; j++) {
      u = j / slices;
      p = func(u, v);
      verts.push(p);
    }
  }
  var a, b, c, d;
  var uva, uvb, uvc, uvd;
  for (i = 0; i < stacks; i++) {
    for (j = 0; j < slices; j++) {
      a = i * sliceCount + j;
      b = i * sliceCount + j + 1;
      c = (i + 1) * sliceCount + j + 1;
      d = (i + 1) * sliceCount + j;
      uva = new THREE.Vector2(j / slices, i / stacks);
      uvb = new THREE.Vector2((j + 1) / slices, i / stacks);
      uvc = new THREE.Vector2((j + 1) / slices, (i + 1) / stacks);
      uvd = new THREE.Vector2(j / slices, (i + 1) / stacks);
      faces.push(new THREE.Face3(a, b, d));
      uvs.push([
        uva,
        uvb,
        uvd
      ]);
      faces.push(new THREE.Face3(b, c, d));
      uvs.push([
        uvb.clone(),
        uvc,
        uvd.clone()
      ]);
    }
  }
  this.computeCentroids();
  this.computeFaceNormals();
  this.computeVertexNormals();
};
THREE.ParametricGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.AxisHelper = function (size) {
  size = size || 1;
  var geometry = new THREE.Geometry();
  geometry.vertices.push(new THREE.Vector3(), new THREE.Vector3(size, 0, 0), new THREE.Vector3(), new THREE.Vector3(0, size, 0), new THREE.Vector3(), new THREE.Vector3(0, 0, size));
  geometry.colors.push(new THREE.Color(16711680), new THREE.Color(16755200), new THREE.Color(65280), new THREE.Color(11206400), new THREE.Color(255), new THREE.Color(43775));
  var material = new THREE.LineBasicMaterial({ vertexColors: THREE.VertexColors });
  THREE.Line.call(this, geometry, material, THREE.LinePieces);
};
THREE.AxisHelper.prototype = Object.create(THREE.Line.prototype);
THREE.ArrowHelper = function (dir, origin, length, hex) {
  THREE.Object3D.call(this);
  if (hex === undefined)
    hex = 16776960;
  if (length === undefined)
    length = 1;
  this.position = origin;
  var lineGeometry = new THREE.Geometry();
  lineGeometry.vertices.push(new THREE.Vector3(0, 0, 0));
  lineGeometry.vertices.push(new THREE.Vector3(0, 1, 0));
  this.line = new THREE.Line(lineGeometry, new THREE.LineBasicMaterial({ color: hex }));
  this.line.matrixAutoUpdate = false;
  this.add(this.line);
  var coneGeometry = new THREE.CylinderGeometry(0, 0.05, 0.25, 5, 1);
  coneGeometry.applyMatrix(new THREE.Matrix4().makeTranslation(0, 0.875, 0));
  this.cone = new THREE.Mesh(coneGeometry, new THREE.MeshBasicMaterial({ color: hex }));
  this.cone.matrixAutoUpdate = false;
  this.add(this.cone);
  this.setDirection(dir);
  this.setLength(length);
};
THREE.ArrowHelper.prototype = Object.create(THREE.Object3D.prototype);
THREE.ArrowHelper.prototype.setDirection = function () {
  var axis = new THREE.Vector3();
  var radians;
  return function (dir) {
    if (dir.y > 0.99999) {
      this.quaternion.set(0, 0, 0, 1);
    } else if (dir.y < -0.99999) {
      this.quaternion.set(1, 0, 0, 0);
    } else {
      axis.set(dir.z, 0, -dir.x).normalize();
      radians = Math.acos(dir.y);
      this.quaternion.setFromAxisAngle(axis, radians);
    }
  };
}();
THREE.ArrowHelper.prototype.setLength = function (length) {
  this.scale.set(length, length, length);
};
THREE.ArrowHelper.prototype.setColor = function (hex) {
  this.line.material.color.setHex(hex);
  this.cone.material.color.setHex(hex);
};
THREE.BoxHelper = function (object) {
  var vertices = [
      new THREE.Vector3(1, 1, 1),
      new THREE.Vector3(-1, 1, 1),
      new THREE.Vector3(-1, -1, 1),
      new THREE.Vector3(1, -1, 1),
      new THREE.Vector3(1, 1, -1),
      new THREE.Vector3(-1, 1, -1),
      new THREE.Vector3(-1, -1, -1),
      new THREE.Vector3(1, -1, -1)
    ];
  this.vertices = vertices;
  var geometry = new THREE.Geometry();
  geometry.vertices.push(vertices[0], vertices[1], vertices[1], vertices[2], vertices[2], vertices[3], vertices[3], vertices[0], vertices[4], vertices[5], vertices[5], vertices[6], vertices[6], vertices[7], vertices[7], vertices[4], vertices[0], vertices[4], vertices[1], vertices[5], vertices[2], vertices[6], vertices[3], vertices[7]);
  THREE.Line.call(this, geometry, new THREE.LineBasicMaterial({ color: 16776960 }), THREE.LinePieces);
  if (object !== undefined) {
    this.update(object);
  }
};
THREE.BoxHelper.prototype = Object.create(THREE.Line.prototype);
THREE.BoxHelper.prototype.update = function (object) {
  var geometry = object.geometry;
  if (geometry.boundingBox === null) {
    geometry.computeBoundingBox();
  }
  var min = geometry.boundingBox.min;
  var max = geometry.boundingBox.max;
  var vertices = this.vertices;
  vertices[0].set(max.x, max.y, max.z);
  vertices[1].set(min.x, max.y, max.z);
  vertices[2].set(min.x, min.y, max.z);
  vertices[3].set(max.x, min.y, max.z);
  vertices[4].set(max.x, max.y, min.z);
  vertices[5].set(min.x, max.y, min.z);
  vertices[6].set(min.x, min.y, min.z);
  vertices[7].set(max.x, min.y, min.z);
  this.geometry.computeBoundingSphere();
  this.geometry.verticesNeedUpdate = true;
  this.matrixAutoUpdate = false;
  this.matrixWorld = object.matrixWorld;
};
THREE.BoundingBoxHelper = function (object, hex) {
  var color = hex || 8947848;
  this.object = object;
  this.box = new THREE.Box3();
  THREE.Mesh.call(this, new THREE.CubeGeometry(1, 1, 1), new THREE.MeshBasicMaterial({
    color: color,
    wireframe: true
  }));
};
THREE.BoundingBoxHelper.prototype = Object.create(THREE.Mesh.prototype);
THREE.BoundingBoxHelper.prototype.update = function () {
  this.box.setFromObject(this.object);
  this.box.size(this.scale);
  this.box.center(this.position);
};
THREE.CameraHelper = function (camera) {
  var geometry = new THREE.Geometry();
  var material = new THREE.LineBasicMaterial({
      color: 16777215,
      vertexColors: THREE.FaceColors
    });
  var pointMap = {};
  var hexFrustum = 16755200;
  var hexCone = 16711680;
  var hexUp = 43775;
  var hexTarget = 16777215;
  var hexCross = 3355443;
  addLine('n1', 'n2', hexFrustum);
  addLine('n2', 'n4', hexFrustum);
  addLine('n4', 'n3', hexFrustum);
  addLine('n3', 'n1', hexFrustum);
  addLine('f1', 'f2', hexFrustum);
  addLine('f2', 'f4', hexFrustum);
  addLine('f4', 'f3', hexFrustum);
  addLine('f3', 'f1', hexFrustum);
  addLine('n1', 'f1', hexFrustum);
  addLine('n2', 'f2', hexFrustum);
  addLine('n3', 'f3', hexFrustum);
  addLine('n4', 'f4', hexFrustum);
  addLine('p', 'n1', hexCone);
  addLine('p', 'n2', hexCone);
  addLine('p', 'n3', hexCone);
  addLine('p', 'n4', hexCone);
  addLine('u1', 'u2', hexUp);
  addLine('u2', 'u3', hexUp);
  addLine('u3', 'u1', hexUp);
  addLine('c', 't', hexTarget);
  addLine('p', 'c', hexCross);
  addLine('cn1', 'cn2', hexCross);
  addLine('cn3', 'cn4', hexCross);
  addLine('cf1', 'cf2', hexCross);
  addLine('cf3', 'cf4', hexCross);
  function addLine(a, b, hex) {
    addPoint(a, hex);
    addPoint(b, hex);
  }
  function addPoint(id, hex) {
    geometry.vertices.push(new THREE.Vector3());
    geometry.colors.push(new THREE.Color(hex));
    if (pointMap[id] === undefined) {
      pointMap[id] = [];
    }
    pointMap[id].push(geometry.vertices.length - 1);
  }
  THREE.Line.call(this, geometry, material, THREE.LinePieces);
  this.camera = camera;
  this.matrixWorld = camera.matrixWorld;
  this.matrixAutoUpdate = false;
  this.pointMap = pointMap;
  this.update();
};
THREE.CameraHelper.prototype = Object.create(THREE.Line.prototype);
THREE.CameraHelper.prototype.update = function () {
  var vector = new THREE.Vector3();
  var camera = new THREE.Camera();
  var projector = new THREE.Projector();
  return function () {
    var scope = this;
    var w = 1, h = 1;
    camera.projectionMatrix.copy(this.camera.projectionMatrix);
    setPoint('c', 0, 0, -1);
    setPoint('t', 0, 0, 1);
    setPoint('n1', -w, -h, -1);
    setPoint('n2', w, -h, -1);
    setPoint('n3', -w, h, -1);
    setPoint('n4', w, h, -1);
    setPoint('f1', -w, -h, 1);
    setPoint('f2', w, -h, 1);
    setPoint('f3', -w, h, 1);
    setPoint('f4', w, h, 1);
    setPoint('u1', w * 0.7, h * 1.1, -1);
    setPoint('u2', -w * 0.7, h * 1.1, -1);
    setPoint('u3', 0, h * 2, -1);
    setPoint('cf1', -w, 0, 1);
    setPoint('cf2', w, 0, 1);
    setPoint('cf3', 0, -h, 1);
    setPoint('cf4', 0, h, 1);
    setPoint('cn1', -w, 0, -1);
    setPoint('cn2', w, 0, -1);
    setPoint('cn3', 0, -h, -1);
    setPoint('cn4', 0, h, -1);
    function setPoint(point, x, y, z) {
      vector.set(x, y, z);
      projector.unprojectVector(vector, camera);
      var points = scope.pointMap[point];
      if (points !== undefined) {
        for (var i = 0, il = points.length; i < il; i++) {
          scope.geometry.vertices[points[i]].copy(vector);
        }
      }
    }
    this.geometry.verticesNeedUpdate = true;
  };
}();
THREE.DirectionalLightHelper = function (light, size) {
  THREE.Object3D.call(this);
  this.light = light;
  this.light.updateMatrixWorld();
  this.matrixWorld = light.matrixWorld;
  this.matrixAutoUpdate = false;
  var geometry = new THREE.PlaneGeometry(size, size);
  var material = new THREE.MeshBasicMaterial({
      wireframe: true,
      fog: false
    });
  material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
  this.lightPlane = new THREE.Mesh(geometry, material);
  this.add(this.lightPlane);
  geometry = new THREE.Geometry();
  geometry.vertices.push(new THREE.Vector3());
  geometry.vertices.push(new THREE.Vector3());
  geometry.computeLineDistances();
  material = new THREE.LineBasicMaterial({ fog: false });
  material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
  this.targetLine = new THREE.Line(geometry, material);
  this.add(this.targetLine);
  this.update();
};
THREE.DirectionalLightHelper.prototype = Object.create(THREE.Object3D.prototype);
THREE.DirectionalLightHelper.prototype.update = function () {
  var vector = new THREE.Vector3();
  return function () {
    vector.getPositionFromMatrix(this.light.matrixWorld).negate();
    this.lightPlane.lookAt(vector);
    this.lightPlane.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
    this.targetLine.geometry.vertices[1].copy(vector);
    this.targetLine.geometry.verticesNeedUpdate = true;
    this.targetLine.material.color.copy(this.lightPlane.material.color);
  };
}();
THREE.FaceNormalsHelper = function (object, size, hex, linewidth) {
  this.object = object;
  this.size = size || 1;
  var color = hex || 16776960;
  var width = linewidth || 1;
  var geometry = new THREE.Geometry();
  var faces = this.object.geometry.faces;
  for (var i = 0, l = faces.length; i < l; i++) {
    geometry.vertices.push(new THREE.Vector3());
    geometry.vertices.push(new THREE.Vector3());
  }
  THREE.Line.call(this, geometry, new THREE.LineBasicMaterial({
    color: color,
    linewidth: width
  }), THREE.LinePieces);
  this.matrixAutoUpdate = false;
  this.normalMatrix = new THREE.Matrix3();
  this.update();
};
THREE.FaceNormalsHelper.prototype = Object.create(THREE.Line.prototype);
THREE.FaceNormalsHelper.prototype.update = function (object) {
  var v1 = new THREE.Vector3();
  return function (object) {
    this.object.updateMatrixWorld(true);
    this.normalMatrix.getNormalMatrix(this.object.matrixWorld);
    var vertices = this.geometry.vertices;
    var faces = this.object.geometry.faces;
    var worldMatrix = this.object.matrixWorld;
    for (var i = 0, l = faces.length; i < l; i++) {
      var face = faces[i];
      v1.copy(face.normal).applyMatrix3(this.normalMatrix).normalize().multiplyScalar(this.size);
      var idx = 2 * i;
      vertices[idx].copy(face.centroid).applyMatrix4(worldMatrix);
      vertices[idx + 1].addVectors(vertices[idx], v1);
    }
    this.geometry.verticesNeedUpdate = true;
    return this;
  };
}();
THREE.GridHelper = function (size, step) {
  var geometry = new THREE.Geometry();
  var material = new THREE.LineBasicMaterial({ vertexColors: THREE.VertexColors });
  this.color1 = new THREE.Color(4473924);
  this.color2 = new THREE.Color(8947848);
  for (var i = -size; i <= size; i += step) {
    geometry.vertices.push(new THREE.Vector3(-size, 0, i), new THREE.Vector3(size, 0, i), new THREE.Vector3(i, 0, -size), new THREE.Vector3(i, 0, size));
    var color = i === 0 ? this.color1 : this.color2;
    geometry.colors.push(color, color, color, color);
  }
  THREE.Line.call(this, geometry, material, THREE.LinePieces);
};
THREE.GridHelper.prototype = Object.create(THREE.Line.prototype);
THREE.GridHelper.prototype.setColors = function (colorCenterLine, colorGrid) {
  this.color1.set(colorCenterLine);
  this.color2.set(colorGrid);
  this.geometry.colorsNeedUpdate = true;
};
THREE.HemisphereLightHelper = function (light, sphereSize, arrowLength, domeSize) {
  THREE.Object3D.call(this);
  this.light = light;
  this.light.updateMatrixWorld();
  this.matrixWorld = light.matrixWorld;
  this.matrixAutoUpdate = false;
  this.colors = [
    new THREE.Color(),
    new THREE.Color()
  ];
  var geometry = new THREE.SphereGeometry(sphereSize, 4, 2);
  geometry.applyMatrix(new THREE.Matrix4().makeRotationX(-Math.PI / 2));
  for (var i = 0, il = 8; i < il; i++) {
    geometry.faces[i].color = this.colors[i < 4 ? 0 : 1];
  }
  var material = new THREE.MeshBasicMaterial({
      vertexColors: THREE.FaceColors,
      wireframe: true
    });
  this.lightSphere = new THREE.Mesh(geometry, material);
  this.add(this.lightSphere);
  this.update();
};
THREE.HemisphereLightHelper.prototype = Object.create(THREE.Object3D.prototype);
THREE.HemisphereLightHelper.prototype.update = function () {
  var vector = new THREE.Vector3();
  return function () {
    this.colors[0].copy(this.light.color).multiplyScalar(this.light.intensity);
    this.colors[1].copy(this.light.groundColor).multiplyScalar(this.light.intensity);
    this.lightSphere.lookAt(vector.getPositionFromMatrix(this.light.matrixWorld).negate());
    this.lightSphere.geometry.colorsNeedUpdate = true;
  };
}();
THREE.PointLightHelper = function (light, sphereSize) {
  this.light = light;
  this.light.updateMatrixWorld();
  var geometry = new THREE.SphereGeometry(sphereSize, 4, 2);
  var material = new THREE.MeshBasicMaterial({
      wireframe: true,
      fog: false
    });
  material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
  THREE.Mesh.call(this, geometry, material);
  this.matrixWorld = this.light.matrixWorld;
  this.matrixAutoUpdate = false;
};
THREE.PointLightHelper.prototype = Object.create(THREE.Mesh.prototype);
THREE.PointLightHelper.prototype.update = function () {
  this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
};
THREE.SpotLightHelper = function (light) {
  THREE.Object3D.call(this);
  this.light = light;
  this.light.updateMatrixWorld();
  this.matrixWorld = light.matrixWorld;
  this.matrixAutoUpdate = false;
  var geometry = new THREE.CylinderGeometry(0, 1, 1, 8, 1, true);
  geometry.applyMatrix(new THREE.Matrix4().makeTranslation(0, -0.5, 0));
  geometry.applyMatrix(new THREE.Matrix4().makeRotationX(-Math.PI / 2));
  var material = new THREE.MeshBasicMaterial({
      wireframe: true,
      fog: false
    });
  this.cone = new THREE.Mesh(geometry, material);
  this.add(this.cone);
  this.update();
};
THREE.SpotLightHelper.prototype = Object.create(THREE.Object3D.prototype);
THREE.SpotLightHelper.prototype.update = function () {
  var vector = new THREE.Vector3();
  var vector2 = new THREE.Vector3();
  return function () {
    var coneLength = this.light.distance ? this.light.distance : 10000;
    var coneWidth = coneLength * Math.tan(this.light.angle);
    this.cone.scale.set(coneWidth, coneWidth, coneLength);
    vector.getPositionFromMatrix(this.light.matrixWorld);
    vector2.getPositionFromMatrix(this.light.target.matrixWorld);
    this.cone.lookAt(vector2.sub(vector));
    this.cone.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
  };
}();
THREE.VertexNormalsHelper = function (object, size, hex, linewidth) {
  this.object = object;
  this.size = size || 1;
  var color = hex || 16711680;
  var width = linewidth || 1;
  var geometry = new THREE.Geometry();
  var vertices = object.geometry.vertices;
  var faces = object.geometry.faces;
  for (var i = 0, l = faces.length; i < l; i++) {
    var face = faces[i];
    for (var j = 0, jl = face.vertexNormals.length; j < jl; j++) {
      geometry.vertices.push(new THREE.Vector3());
      geometry.vertices.push(new THREE.Vector3());
    }
  }
  THREE.Line.call(this, geometry, new THREE.LineBasicMaterial({
    color: color,
    linewidth: width
  }), THREE.LinePieces);
  this.matrixAutoUpdate = false;
  this.normalMatrix = new THREE.Matrix3();
  this.update();
};
THREE.VertexNormalsHelper.prototype = Object.create(THREE.Line.prototype);
THREE.VertexNormalsHelper.prototype.update = function (object) {
  var v1 = new THREE.Vector3();
  return function (object) {
    var keys = [
        'a',
        'b',
        'c',
        'd'
      ];
    this.object.updateMatrixWorld(true);
    this.normalMatrix.getNormalMatrix(this.object.matrixWorld);
    var vertices = this.geometry.vertices;
    var verts = this.object.geometry.vertices;
    var faces = this.object.geometry.faces;
    var worldMatrix = this.object.matrixWorld;
    var idx = 0;
    for (var i = 0, l = faces.length; i < l; i++) {
      var face = faces[i];
      for (var j = 0, jl = face.vertexNormals.length; j < jl; j++) {
        var vertexId = face[keys[j]];
        var vertex = verts[vertexId];
        var normal = face.vertexNormals[j];
        vertices[idx].copy(vertex).applyMatrix4(worldMatrix);
        v1.copy(normal).applyMatrix3(this.normalMatrix).normalize().multiplyScalar(this.size);
        v1.add(vertices[idx]);
        idx = idx + 1;
        vertices[idx].copy(v1);
        idx = idx + 1;
      }
    }
    this.geometry.verticesNeedUpdate = true;
    return this;
  };
}();
THREE.VertexTangentsHelper = function (object, size, hex, linewidth) {
  this.object = object;
  this.size = size || 1;
  var color = hex || 255;
  var width = linewidth || 1;
  var geometry = new THREE.Geometry();
  var vertices = object.geometry.vertices;
  var faces = object.geometry.faces;
  for (var i = 0, l = faces.length; i < l; i++) {
    var face = faces[i];
    for (var j = 0, jl = face.vertexTangents.length; j < jl; j++) {
      geometry.vertices.push(new THREE.Vector3());
      geometry.vertices.push(new THREE.Vector3());
    }
  }
  THREE.Line.call(this, geometry, new THREE.LineBasicMaterial({
    color: color,
    linewidth: width
  }), THREE.LinePieces);
  this.matrixAutoUpdate = false;
  this.update();
};
THREE.VertexTangentsHelper.prototype = Object.create(THREE.Line.prototype);
THREE.VertexTangentsHelper.prototype.update = function (object) {
  var v1 = new THREE.Vector3();
  return function (object) {
    var keys = [
        'a',
        'b',
        'c',
        'd'
      ];
    this.object.updateMatrixWorld(true);
    var vertices = this.geometry.vertices;
    var verts = this.object.geometry.vertices;
    var faces = this.object.geometry.faces;
    var worldMatrix = this.object.matrixWorld;
    var idx = 0;
    for (var i = 0, l = faces.length; i < l; i++) {
      var face = faces[i];
      for (var j = 0, jl = face.vertexTangents.length; j < jl; j++) {
        var vertexId = face[keys[j]];
        var vertex = verts[vertexId];
        var tangent = face.vertexTangents[j];
        vertices[idx].copy(vertex).applyMatrix4(worldMatrix);
        v1.copy(tangent).transformDirection(worldMatrix).multiplyScalar(this.size);
        v1.add(vertices[idx]);
        idx = idx + 1;
        vertices[idx].copy(v1);
        idx = idx + 1;
      }
    }
    this.geometry.verticesNeedUpdate = true;
    return this;
  };
}();
THREE.WireframeHelper = function (object) {
  var edge = [
      0,
      0
    ], hash = {};
  var sortFunction = function (a, b) {
    return a - b;
  };
  var keys = [
      'a',
      'b',
      'c',
      'd'
    ];
  var geometry = new THREE.Geometry();
  var vertices = object.geometry.vertices;
  var faces = object.geometry.faces;
  for (var i = 0, l = faces.length; i < l; i++) {
    var face = faces[i];
    for (var j = 0; j < 3; j++) {
      edge[0] = face[keys[j]];
      edge[1] = face[keys[(j + 1) % 3]];
      edge.sort(sortFunction);
      var key = edge.toString();
      if (hash[key] === undefined) {
        geometry.vertices.push(vertices[edge[0]]);
        geometry.vertices.push(vertices[edge[1]]);
        hash[key] = true;
      }
    }
  }
  THREE.Line.call(this, geometry, new THREE.LineBasicMaterial({ color: 16777215 }), THREE.LinePieces);
  this.matrixAutoUpdate = false;
  this.matrixWorld = object.matrixWorld;
};
THREE.WireframeHelper.prototype = Object.create(THREE.Line.prototype);
THREE.ImmediateRenderObject = function () {
  THREE.Object3D.call(this);
  this.render = function (renderCallback) {
  };
};
THREE.ImmediateRenderObject.prototype = Object.create(THREE.Object3D.prototype);
THREE.LensFlare = function (texture, size, distance, blending, color) {
  THREE.Object3D.call(this);
  this.lensFlares = [];
  this.positionScreen = new THREE.Vector3();
  this.customUpdateCallback = undefined;
  if (texture !== undefined) {
    this.add(texture, size, distance, blending, color);
  }
};
THREE.LensFlare.prototype = Object.create(THREE.Object3D.prototype);
THREE.LensFlare.prototype.add = function (texture, size, distance, blending, color, opacity) {
  if (size === undefined)
    size = -1;
  if (distance === undefined)
    distance = 0;
  if (opacity === undefined)
    opacity = 1;
  if (color === undefined)
    color = new THREE.Color(16777215);
  if (blending === undefined)
    blending = THREE.NormalBlending;
  distance = Math.min(distance, Math.max(0, distance));
  this.lensFlares.push({
    texture: texture,
    size: size,
    distance: distance,
    x: 0,
    y: 0,
    z: 0,
    scale: 1,
    rotation: 1,
    opacity: opacity,
    color: color,
    blending: blending
  });
};
THREE.LensFlare.prototype.updateLensFlares = function () {
  var f, fl = this.lensFlares.length;
  var flare;
  var vecX = -this.positionScreen.x * 2;
  var vecY = -this.positionScreen.y * 2;
  for (f = 0; f < fl; f++) {
    flare = this.lensFlares[f];
    flare.x = this.positionScreen.x + vecX * flare.distance;
    flare.y = this.positionScreen.y + vecY * flare.distance;
    flare.wantedRotation = flare.x * Math.PI * 0.25;
    flare.rotation += (flare.wantedRotation - flare.rotation) * 0.25;
  }
};
THREE.MorphBlendMesh = function (geometry, material) {
  THREE.Mesh.call(this, geometry, material);
  this.animationsMap = {};
  this.animationsList = [];
  var numFrames = this.geometry.morphTargets.length;
  var name = '__default';
  var startFrame = 0;
  var endFrame = numFrames - 1;
  var fps = numFrames / 1;
  this.createAnimation(name, startFrame, endFrame, fps);
  this.setAnimationWeight(name, 1);
};
THREE.MorphBlendMesh.prototype = Object.create(THREE.Mesh.prototype);
THREE.MorphBlendMesh.prototype.createAnimation = function (name, start, end, fps) {
  var animation = {
      startFrame: start,
      endFrame: end,
      length: end - start + 1,
      fps: fps,
      duration: (end - start) / fps,
      lastFrame: 0,
      currentFrame: 0,
      active: false,
      time: 0,
      direction: 1,
      weight: 1,
      directionBackwards: false,
      mirroredLoop: false
    };
  this.animationsMap[name] = animation;
  this.animationsList.push(animation);
};
THREE.MorphBlendMesh.prototype.autoCreateAnimations = function (fps) {
  var pattern = /([a-z]+)(\d+)/;
  var firstAnimation, frameRanges = {};
  var geometry = this.geometry;
  for (var i = 0, il = geometry.morphTargets.length; i < il; i++) {
    var morph = geometry.morphTargets[i];
    var chunks = morph.name.match(pattern);
    if (chunks && chunks.length > 1) {
      var name = chunks[1];
      var num = chunks[2];
      if (!frameRanges[name])
        frameRanges[name] = {
          start: Infinity,
          end: -Infinity
        };
      var range = frameRanges[name];
      if (i < range.start)
        range.start = i;
      if (i > range.end)
        range.end = i;
      if (!firstAnimation)
        firstAnimation = name;
    }
  }
  for (var name in frameRanges) {
    var range = frameRanges[name];
    this.createAnimation(name, range.start, range.end, fps);
  }
  this.firstAnimation = firstAnimation;
};
THREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function (name) {
  var animation = this.animationsMap[name];
  if (animation) {
    animation.direction = 1;
    animation.directionBackwards = false;
  }
};
THREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function (name) {
  var animation = this.animationsMap[name];
  if (animation) {
    animation.direction = -1;
    animation.directionBackwards = true;
  }
};
THREE.MorphBlendMesh.prototype.setAnimationFPS = function (name, fps) {
  var animation = this.animationsMap[name];
  if (animation) {
    animation.fps = fps;
    animation.duration = (animation.end - animation.start) / animation.fps;
  }
};
THREE.MorphBlendMesh.prototype.setAnimationDuration = function (name, duration) {
  var animation = this.animationsMap[name];
  if (animation) {
    animation.duration = duration;
    animation.fps = (animation.end - animation.start) / animation.duration;
  }
};
THREE.MorphBlendMesh.prototype.setAnimationWeight = function (name, weight) {
  var animation = this.animationsMap[name];
  if (animation) {
    animation.weight = weight;
  }
};
THREE.MorphBlendMesh.prototype.setAnimationTime = function (name, time) {
  var animation = this.animationsMap[name];
  if (animation) {
    animation.time = time;
  }
};
THREE.MorphBlendMesh.prototype.getAnimationTime = function (name) {
  var time = 0;
  var animation = this.animationsMap[name];
  if (animation) {
    time = animation.time;
  }
  return time;
};
THREE.MorphBlendMesh.prototype.getAnimationDuration = function (name) {
  var duration = -1;
  var animation = this.animationsMap[name];
  if (animation) {
    duration = animation.duration;
  }
  return duration;
};
THREE.MorphBlendMesh.prototype.playAnimation = function (name) {
  var animation = this.animationsMap[name];
  if (animation) {
    animation.time = 0;
    animation.active = true;
  } else {
    console.warn('animation[' + name + '] undefined');
  }
};
THREE.MorphBlendMesh.prototype.stopAnimation = function (name) {
  var animation = this.animationsMap[name];
  if (animation) {
    animation.active = false;
  }
};
THREE.MorphBlendMesh.prototype.update = function (delta) {
  for (var i = 0, il = this.animationsList.length; i < il; i++) {
    var animation = this.animationsList[i];
    if (!animation.active)
      continue;
    var frameTime = animation.duration / animation.length;
    animation.time += animation.direction * delta;
    if (animation.mirroredLoop) {
      if (animation.time > animation.duration || animation.time < 0) {
        animation.direction *= -1;
        if (animation.time > animation.duration) {
          animation.time = animation.duration;
          animation.directionBackwards = true;
        }
        if (animation.time < 0) {
          animation.time = 0;
          animation.directionBackwards = false;
        }
      }
    } else {
      animation.time = animation.time % animation.duration;
      if (animation.time < 0)
        animation.time += animation.duration;
    }
    var keyframe = animation.startFrame + THREE.Math.clamp(Math.floor(animation.time / frameTime), 0, animation.length - 1);
    var weight = animation.weight;
    if (keyframe !== animation.currentFrame) {
      this.morphTargetInfluences[animation.lastFrame] = 0;
      this.morphTargetInfluences[animation.currentFrame] = 1 * weight;
      this.morphTargetInfluences[keyframe] = 0;
      animation.lastFrame = animation.currentFrame;
      animation.currentFrame = keyframe;
    }
    var mix = animation.time % frameTime / frameTime;
    if (animation.directionBackwards)
      mix = 1 - mix;
    this.morphTargetInfluences[animation.currentFrame] = mix * weight;
    this.morphTargetInfluences[animation.lastFrame] = (1 - mix) * weight;
  }
};
THREE.LensFlarePlugin = function () {
  var _gl, _renderer, _precision, _lensFlare = {};
  this.init = function (renderer) {
    _gl = renderer.context;
    _renderer = renderer;
    _precision = renderer.getPrecision();
    _lensFlare.vertices = new Float32Array(8 + 8);
    _lensFlare.faces = new Uint16Array(6);
    var i = 0;
    _lensFlare.vertices[i++] = -1;
    _lensFlare.vertices[i++] = -1;
    _lensFlare.vertices[i++] = 0;
    _lensFlare.vertices[i++] = 0;
    _lensFlare.vertices[i++] = 1;
    _lensFlare.vertices[i++] = -1;
    _lensFlare.vertices[i++] = 1;
    _lensFlare.vertices[i++] = 0;
    _lensFlare.vertices[i++] = 1;
    _lensFlare.vertices[i++] = 1;
    _lensFlare.vertices[i++] = 1;
    _lensFlare.vertices[i++] = 1;
    _lensFlare.vertices[i++] = -1;
    _lensFlare.vertices[i++] = 1;
    _lensFlare.vertices[i++] = 0;
    _lensFlare.vertices[i++] = 1;
    i = 0;
    _lensFlare.faces[i++] = 0;
    _lensFlare.faces[i++] = 1;
    _lensFlare.faces[i++] = 2;
    _lensFlare.faces[i++] = 0;
    _lensFlare.faces[i++] = 2;
    _lensFlare.faces[i++] = 3;
    _lensFlare.vertexBuffer = _gl.createBuffer();
    _lensFlare.elementBuffer = _gl.createBuffer();
    _gl.bindBuffer(_gl.ARRAY_BUFFER, _lensFlare.vertexBuffer);
    _gl.bufferData(_gl.ARRAY_BUFFER, _lensFlare.vertices, _gl.STATIC_DRAW);
    _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, _lensFlare.elementBuffer);
    _gl.bufferData(_gl.ELEMENT_ARRAY_BUFFER, _lensFlare.faces, _gl.STATIC_DRAW);
    _lensFlare.tempTexture = _gl.createTexture();
    _lensFlare.occlusionTexture = _gl.createTexture();
    _gl.bindTexture(_gl.TEXTURE_2D, _lensFlare.tempTexture);
    _gl.texImage2D(_gl.TEXTURE_2D, 0, _gl.RGB, 16, 16, 0, _gl.RGB, _gl.UNSIGNED_BYTE, null);
    _gl.texParameteri(_gl.TEXTURE_2D, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE);
    _gl.texParameteri(_gl.TEXTURE_2D, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE);
    _gl.texParameteri(_gl.TEXTURE_2D, _gl.TEXTURE_MAG_FILTER, _gl.NEAREST);
    _gl.texParameteri(_gl.TEXTURE_2D, _gl.TEXTURE_MIN_FILTER, _gl.NEAREST);
    _gl.bindTexture(_gl.TEXTURE_2D, _lensFlare.occlusionTexture);
    _gl.texImage2D(_gl.TEXTURE_2D, 0, _gl.RGBA, 16, 16, 0, _gl.RGBA, _gl.UNSIGNED_BYTE, null);
    _gl.texParameteri(_gl.TEXTURE_2D, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE);
    _gl.texParameteri(_gl.TEXTURE_2D, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE);
    _gl.texParameteri(_gl.TEXTURE_2D, _gl.TEXTURE_MAG_FILTER, _gl.NEAREST);
    _gl.texParameteri(_gl.TEXTURE_2D, _gl.TEXTURE_MIN_FILTER, _gl.NEAREST);
    if (_gl.getParameter(_gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS) <= 0) {
      _lensFlare.hasVertexTexture = false;
      _lensFlare.program = createProgram(THREE.ShaderFlares['lensFlare'], _precision);
    } else {
      _lensFlare.hasVertexTexture = true;
      _lensFlare.program = createProgram(THREE.ShaderFlares['lensFlareVertexTexture'], _precision);
    }
    _lensFlare.attributes = {};
    _lensFlare.uniforms = {};
    _lensFlare.attributes.vertex = _gl.getAttribLocation(_lensFlare.program, 'position');
    _lensFlare.attributes.uv = _gl.getAttribLocation(_lensFlare.program, 'uv');
    _lensFlare.uniforms.renderType = _gl.getUniformLocation(_lensFlare.program, 'renderType');
    _lensFlare.uniforms.map = _gl.getUniformLocation(_lensFlare.program, 'map');
    _lensFlare.uniforms.occlusionMap = _gl.getUniformLocation(_lensFlare.program, 'occlusionMap');
    _lensFlare.uniforms.opacity = _gl.getUniformLocation(_lensFlare.program, 'opacity');
    _lensFlare.uniforms.color = _gl.getUniformLocation(_lensFlare.program, 'color');
    _lensFlare.uniforms.scale = _gl.getUniformLocation(_lensFlare.program, 'scale');
    _lensFlare.uniforms.rotation = _gl.getUniformLocation(_lensFlare.program, 'rotation');
    _lensFlare.uniforms.screenPosition = _gl.getUniformLocation(_lensFlare.program, 'screenPosition');
  };
  this.render = function (scene, camera, viewportWidth, viewportHeight) {
    var flares = scene.__webglFlares, nFlares = flares.length;
    if (!nFlares)
      return;
    var tempPosition = new THREE.Vector3();
    var invAspect = viewportHeight / viewportWidth, halfViewportWidth = viewportWidth * 0.5, halfViewportHeight = viewportHeight * 0.5;
    var size = 16 / viewportHeight, scale = new THREE.Vector2(size * invAspect, size);
    var screenPosition = new THREE.Vector3(1, 1, 0), screenPositionPixels = new THREE.Vector2(1, 1);
    var uniforms = _lensFlare.uniforms, attributes = _lensFlare.attributes;
    _gl.useProgram(_lensFlare.program);
    _gl.enableVertexAttribArray(_lensFlare.attributes.vertex);
    _gl.enableVertexAttribArray(_lensFlare.attributes.uv);
    _gl.uniform1i(uniforms.occlusionMap, 0);
    _gl.uniform1i(uniforms.map, 1);
    _gl.bindBuffer(_gl.ARRAY_BUFFER, _lensFlare.vertexBuffer);
    _gl.vertexAttribPointer(attributes.vertex, 2, _gl.FLOAT, false, 2 * 8, 0);
    _gl.vertexAttribPointer(attributes.uv, 2, _gl.FLOAT, false, 2 * 8, 8);
    _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, _lensFlare.elementBuffer);
    _gl.disable(_gl.CULL_FACE);
    _gl.depthMask(false);
    var i, j, jl, flare, sprite;
    for (i = 0; i < nFlares; i++) {
      size = 16 / viewportHeight;
      scale.set(size * invAspect, size);
      flare = flares[i];
      tempPosition.set(flare.matrixWorld.elements[12], flare.matrixWorld.elements[13], flare.matrixWorld.elements[14]);
      tempPosition.applyMatrix4(camera.matrixWorldInverse);
      tempPosition.applyProjection(camera.projectionMatrix);
      screenPosition.copy(tempPosition);
      screenPositionPixels.x = screenPosition.x * halfViewportWidth + halfViewportWidth;
      screenPositionPixels.y = screenPosition.y * halfViewportHeight + halfViewportHeight;
      if (_lensFlare.hasVertexTexture || screenPositionPixels.x > 0 && screenPositionPixels.x < viewportWidth && screenPositionPixels.y > 0 && screenPositionPixels.y < viewportHeight) {
        _gl.activeTexture(_gl.TEXTURE1);
        _gl.bindTexture(_gl.TEXTURE_2D, _lensFlare.tempTexture);
        _gl.copyTexImage2D(_gl.TEXTURE_2D, 0, _gl.RGB, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0);
        _gl.uniform1i(uniforms.renderType, 0);
        _gl.uniform2f(uniforms.scale, scale.x, scale.y);
        _gl.uniform3f(uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z);
        _gl.disable(_gl.BLEND);
        _gl.enable(_gl.DEPTH_TEST);
        _gl.drawElements(_gl.TRIANGLES, 6, _gl.UNSIGNED_SHORT, 0);
        _gl.activeTexture(_gl.TEXTURE0);
        _gl.bindTexture(_gl.TEXTURE_2D, _lensFlare.occlusionTexture);
        _gl.copyTexImage2D(_gl.TEXTURE_2D, 0, _gl.RGBA, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0);
        _gl.uniform1i(uniforms.renderType, 1);
        _gl.disable(_gl.DEPTH_TEST);
        _gl.activeTexture(_gl.TEXTURE1);
        _gl.bindTexture(_gl.TEXTURE_2D, _lensFlare.tempTexture);
        _gl.drawElements(_gl.TRIANGLES, 6, _gl.UNSIGNED_SHORT, 0);
        flare.positionScreen.copy(screenPosition);
        if (flare.customUpdateCallback) {
          flare.customUpdateCallback(flare);
        } else {
          flare.updateLensFlares();
        }
        _gl.uniform1i(uniforms.renderType, 2);
        _gl.enable(_gl.BLEND);
        for (j = 0, jl = flare.lensFlares.length; j < jl; j++) {
          sprite = flare.lensFlares[j];
          if (sprite.opacity > 0.001 && sprite.scale > 0.001) {
            screenPosition.x = sprite.x;
            screenPosition.y = sprite.y;
            screenPosition.z = sprite.z;
            size = sprite.size * sprite.scale / viewportHeight;
            scale.x = size * invAspect;
            scale.y = size;
            _gl.uniform3f(uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z);
            _gl.uniform2f(uniforms.scale, scale.x, scale.y);
            _gl.uniform1f(uniforms.rotation, sprite.rotation);
            _gl.uniform1f(uniforms.opacity, sprite.opacity);
            _gl.uniform3f(uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b);
            _renderer.setBlending(sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst);
            _renderer.setTexture(sprite.texture, 1);
            _gl.drawElements(_gl.TRIANGLES, 6, _gl.UNSIGNED_SHORT, 0);
          }
        }
      }
    }
    _gl.enable(_gl.CULL_FACE);
    _gl.enable(_gl.DEPTH_TEST);
    _gl.depthMask(true);
  };
  function createProgram(shader, precision) {
    var program = _gl.createProgram();
    var fragmentShader = _gl.createShader(_gl.FRAGMENT_SHADER);
    var vertexShader = _gl.createShader(_gl.VERTEX_SHADER);
    var prefix = 'precision ' + precision + ' float;\n';
    _gl.shaderSource(fragmentShader, prefix + shader.fragmentShader);
    _gl.shaderSource(vertexShader, prefix + shader.vertexShader);
    _gl.compileShader(fragmentShader);
    _gl.compileShader(vertexShader);
    _gl.attachShader(program, fragmentShader);
    _gl.attachShader(program, vertexShader);
    _gl.linkProgram(program);
    return program;
  }
  ;
};
THREE.ShadowMapPlugin = function () {
  var _gl, _renderer, _depthMaterial, _depthMaterialMorph, _depthMaterialSkin, _depthMaterialMorphSkin, _frustum = new THREE.Frustum(), _projScreenMatrix = new THREE.Matrix4(), _min = new THREE.Vector3(), _max = new THREE.Vector3(), _matrixPosition = new THREE.Vector3();
  this.init = function (renderer) {
    _gl = renderer.context;
    _renderer = renderer;
    var depthShader = THREE.ShaderLib['depthRGBA'];
    var depthUniforms = THREE.UniformsUtils.clone(depthShader.uniforms);
    _depthMaterial = new THREE.ShaderMaterial({
      fragmentShader: depthShader.fragmentShader,
      vertexShader: depthShader.vertexShader,
      uniforms: depthUniforms
    });
    _depthMaterialMorph = new THREE.ShaderMaterial({
      fragmentShader: depthShader.fragmentShader,
      vertexShader: depthShader.vertexShader,
      uniforms: depthUniforms,
      morphTargets: true
    });
    _depthMaterialSkin = new THREE.ShaderMaterial({
      fragmentShader: depthShader.fragmentShader,
      vertexShader: depthShader.vertexShader,
      uniforms: depthUniforms,
      skinning: true
    });
    _depthMaterialMorphSkin = new THREE.ShaderMaterial({
      fragmentShader: depthShader.fragmentShader,
      vertexShader: depthShader.vertexShader,
      uniforms: depthUniforms,
      morphTargets: true,
      skinning: true
    });
    _depthMaterial._shadowPass = true;
    _depthMaterialMorph._shadowPass = true;
    _depthMaterialSkin._shadowPass = true;
    _depthMaterialMorphSkin._shadowPass = true;
  };
  this.render = function (scene, camera) {
    if (!(_renderer.shadowMapEnabled && _renderer.shadowMapAutoUpdate))
      return;
    this.update(scene, camera);
  };
  this.update = function (scene, camera) {
    var i, il, j, jl, n, shadowMap, shadowMatrix, shadowCamera, program, buffer, material, webglObject, object, light, renderList, lights = [], k = 0, fog = null;
    _gl.clearColor(1, 1, 1, 1);
    _gl.disable(_gl.BLEND);
    _gl.enable(_gl.CULL_FACE);
    _gl.frontFace(_gl.CCW);
    if (_renderer.shadowMapCullFace === THREE.CullFaceFront) {
      _gl.cullFace(_gl.FRONT);
    } else {
      _gl.cullFace(_gl.BACK);
    }
    _renderer.setDepthTest(true);
    for (i = 0, il = scene.__lights.length; i < il; i++) {
      light = scene.__lights[i];
      if (!light.castShadow)
        continue;
      if (light instanceof THREE.DirectionalLight && light.shadowCascade) {
        for (n = 0; n < light.shadowCascadeCount; n++) {
          var virtualLight;
          if (!light.shadowCascadeArray[n]) {
            virtualLight = createVirtualLight(light, n);
            virtualLight.originalCamera = camera;
            var gyro = new THREE.Gyroscope();
            gyro.position = light.shadowCascadeOffset;
            gyro.add(virtualLight);
            gyro.add(virtualLight.target);
            camera.add(gyro);
            light.shadowCascadeArray[n] = virtualLight;
            console.log('Created virtualLight', virtualLight);
          } else {
            virtualLight = light.shadowCascadeArray[n];
          }
          updateVirtualLight(light, n);
          lights[k] = virtualLight;
          k++;
        }
      } else {
        lights[k] = light;
        k++;
      }
    }
    for (i = 0, il = lights.length; i < il; i++) {
      light = lights[i];
      if (!light.shadowMap) {
        var shadowFilter = THREE.LinearFilter;
        if (_renderer.shadowMapType === THREE.PCFSoftShadowMap) {
          shadowFilter = THREE.NearestFilter;
        }
        var pars = {
            minFilter: shadowFilter,
            magFilter: shadowFilter,
            format: THREE.RGBAFormat
          };
        light.shadowMap = new THREE.WebGLRenderTarget(light.shadowMapWidth, light.shadowMapHeight, pars);
        light.shadowMapSize = new THREE.Vector2(light.shadowMapWidth, light.shadowMapHeight);
        light.shadowMatrix = new THREE.Matrix4();
      }
      if (!light.shadowCamera) {
        if (light instanceof THREE.SpotLight) {
          light.shadowCamera = new THREE.PerspectiveCamera(light.shadowCameraFov, light.shadowMapWidth / light.shadowMapHeight, light.shadowCameraNear, light.shadowCameraFar);
        } else if (light instanceof THREE.DirectionalLight) {
          light.shadowCamera = new THREE.OrthographicCamera(light.shadowCameraLeft, light.shadowCameraRight, light.shadowCameraTop, light.shadowCameraBottom, light.shadowCameraNear, light.shadowCameraFar);
        } else {
          console.error('Unsupported light type for shadow');
          continue;
        }
        scene.add(light.shadowCamera);
        if (scene.autoUpdate === true)
          scene.updateMatrixWorld();
      }
      if (light.shadowCameraVisible && !light.cameraHelper) {
        light.cameraHelper = new THREE.CameraHelper(light.shadowCamera);
        light.shadowCamera.add(light.cameraHelper);
      }
      if (light.isVirtual && virtualLight.originalCamera == camera) {
        updateShadowCamera(camera, light);
      }
      shadowMap = light.shadowMap;
      shadowMatrix = light.shadowMatrix;
      shadowCamera = light.shadowCamera;
      shadowCamera.position.getPositionFromMatrix(light.matrixWorld);
      _matrixPosition.getPositionFromMatrix(light.target.matrixWorld);
      shadowCamera.lookAt(_matrixPosition);
      shadowCamera.updateMatrixWorld();
      shadowCamera.matrixWorldInverse.getInverse(shadowCamera.matrixWorld);
      if (light.cameraHelper)
        light.cameraHelper.visible = light.shadowCameraVisible;
      if (light.shadowCameraVisible)
        light.cameraHelper.update();
      shadowMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
      shadowMatrix.multiply(shadowCamera.projectionMatrix);
      shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
      _projScreenMatrix.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
      _frustum.setFromMatrix(_projScreenMatrix);
      _renderer.setRenderTarget(shadowMap);
      _renderer.clear();
      renderList = scene.__webglObjects;
      for (j = 0, jl = renderList.length; j < jl; j++) {
        webglObject = renderList[j];
        object = webglObject.object;
        webglObject.render = false;
        if (object.visible && object.castShadow) {
          if (!(object instanceof THREE.Mesh || object instanceof THREE.ParticleSystem) || !object.frustumCulled || _frustum.intersectsObject(object)) {
            object._modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
            webglObject.render = true;
          }
        }
      }
      var objectMaterial, useMorphing, useSkinning;
      for (j = 0, jl = renderList.length; j < jl; j++) {
        webglObject = renderList[j];
        if (webglObject.render) {
          object = webglObject.object;
          buffer = webglObject.buffer;
          objectMaterial = getObjectMaterial(object);
          useMorphing = object.geometry.morphTargets.length > 0 && objectMaterial.morphTargets;
          useSkinning = object instanceof THREE.SkinnedMesh && objectMaterial.skinning;
          if (object.customDepthMaterial) {
            material = object.customDepthMaterial;
          } else if (useSkinning) {
            material = useMorphing ? _depthMaterialMorphSkin : _depthMaterialSkin;
          } else if (useMorphing) {
            material = _depthMaterialMorph;
          } else {
            material = _depthMaterial;
          }
          if (buffer instanceof THREE.BufferGeometry) {
            _renderer.renderBufferDirect(shadowCamera, scene.__lights, fog, material, buffer, object);
          } else {
            _renderer.renderBuffer(shadowCamera, scene.__lights, fog, material, buffer, object);
          }
        }
      }
      renderList = scene.__webglObjectsImmediate;
      for (j = 0, jl = renderList.length; j < jl; j++) {
        webglObject = renderList[j];
        object = webglObject.object;
        if (object.visible && object.castShadow) {
          object._modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
          _renderer.renderImmediateObject(shadowCamera, scene.__lights, fog, _depthMaterial, object);
        }
      }
    }
    var clearColor = _renderer.getClearColor(), clearAlpha = _renderer.getClearAlpha();
    _gl.clearColor(clearColor.r, clearColor.g, clearColor.b, clearAlpha);
    _gl.enable(_gl.BLEND);
    if (_renderer.shadowMapCullFace === THREE.CullFaceFront) {
      _gl.cullFace(_gl.BACK);
    }
  };
  function createVirtualLight(light, cascade) {
    var virtualLight = new THREE.DirectionalLight();
    virtualLight.isVirtual = true;
    virtualLight.onlyShadow = true;
    virtualLight.castShadow = true;
    virtualLight.shadowCameraNear = light.shadowCameraNear;
    virtualLight.shadowCameraFar = light.shadowCameraFar;
    virtualLight.shadowCameraLeft = light.shadowCameraLeft;
    virtualLight.shadowCameraRight = light.shadowCameraRight;
    virtualLight.shadowCameraBottom = light.shadowCameraBottom;
    virtualLight.shadowCameraTop = light.shadowCameraTop;
    virtualLight.shadowCameraVisible = light.shadowCameraVisible;
    virtualLight.shadowDarkness = light.shadowDarkness;
    virtualLight.shadowBias = light.shadowCascadeBias[cascade];
    virtualLight.shadowMapWidth = light.shadowCascadeWidth[cascade];
    virtualLight.shadowMapHeight = light.shadowCascadeHeight[cascade];
    virtualLight.pointsWorld = [];
    virtualLight.pointsFrustum = [];
    var pointsWorld = virtualLight.pointsWorld, pointsFrustum = virtualLight.pointsFrustum;
    for (var i = 0; i < 8; i++) {
      pointsWorld[i] = new THREE.Vector3();
      pointsFrustum[i] = new THREE.Vector3();
    }
    var nearZ = light.shadowCascadeNearZ[cascade];
    var farZ = light.shadowCascadeFarZ[cascade];
    pointsFrustum[0].set(-1, -1, nearZ);
    pointsFrustum[1].set(1, -1, nearZ);
    pointsFrustum[2].set(-1, 1, nearZ);
    pointsFrustum[3].set(1, 1, nearZ);
    pointsFrustum[4].set(-1, -1, farZ);
    pointsFrustum[5].set(1, -1, farZ);
    pointsFrustum[6].set(-1, 1, farZ);
    pointsFrustum[7].set(1, 1, farZ);
    return virtualLight;
  }
  function updateVirtualLight(light, cascade) {
    var virtualLight = light.shadowCascadeArray[cascade];
    virtualLight.position.copy(light.position);
    virtualLight.target.position.copy(light.target.position);
    virtualLight.lookAt(virtualLight.target);
    virtualLight.shadowCameraVisible = light.shadowCameraVisible;
    virtualLight.shadowDarkness = light.shadowDarkness;
    virtualLight.shadowBias = light.shadowCascadeBias[cascade];
    var nearZ = light.shadowCascadeNearZ[cascade];
    var farZ = light.shadowCascadeFarZ[cascade];
    var pointsFrustum = virtualLight.pointsFrustum;
    pointsFrustum[0].z = nearZ;
    pointsFrustum[1].z = nearZ;
    pointsFrustum[2].z = nearZ;
    pointsFrustum[3].z = nearZ;
    pointsFrustum[4].z = farZ;
    pointsFrustum[5].z = farZ;
    pointsFrustum[6].z = farZ;
    pointsFrustum[7].z = farZ;
  }
  function updateShadowCamera(camera, light) {
    var shadowCamera = light.shadowCamera, pointsFrustum = light.pointsFrustum, pointsWorld = light.pointsWorld;
    _min.set(Infinity, Infinity, Infinity);
    _max.set(-Infinity, -Infinity, -Infinity);
    for (var i = 0; i < 8; i++) {
      var p = pointsWorld[i];
      p.copy(pointsFrustum[i]);
      THREE.ShadowMapPlugin.__projector.unprojectVector(p, camera);
      p.applyMatrix4(shadowCamera.matrixWorldInverse);
      if (p.x < _min.x)
        _min.x = p.x;
      if (p.x > _max.x)
        _max.x = p.x;
      if (p.y < _min.y)
        _min.y = p.y;
      if (p.y > _max.y)
        _max.y = p.y;
      if (p.z < _min.z)
        _min.z = p.z;
      if (p.z > _max.z)
        _max.z = p.z;
    }
    shadowCamera.left = _min.x;
    shadowCamera.right = _max.x;
    shadowCamera.top = _max.y;
    shadowCamera.bottom = _min.y;
    shadowCamera.updateProjectionMatrix();
  }
  function getObjectMaterial(object) {
    return object.material instanceof THREE.MeshFaceMaterial ? object.material.materials[0] : object.material;
  }
  ;
};
THREE.ShadowMapPlugin.__projector = new THREE.Projector();
THREE.SpritePlugin = function () {
  var _gl, _renderer, _precision, _sprite = {};
  this.init = function (renderer) {
    _gl = renderer.context;
    _renderer = renderer;
    _precision = renderer.getPrecision();
    _sprite.vertices = new Float32Array(8 + 8);
    _sprite.faces = new Uint16Array(6);
    var i = 0;
    _sprite.vertices[i++] = -1;
    _sprite.vertices[i++] = -1;
    _sprite.vertices[i++] = 0;
    _sprite.vertices[i++] = 0;
    _sprite.vertices[i++] = 1;
    _sprite.vertices[i++] = -1;
    _sprite.vertices[i++] = 1;
    _sprite.vertices[i++] = 0;
    _sprite.vertices[i++] = 1;
    _sprite.vertices[i++] = 1;
    _sprite.vertices[i++] = 1;
    _sprite.vertices[i++] = 1;
    _sprite.vertices[i++] = -1;
    _sprite.vertices[i++] = 1;
    _sprite.vertices[i++] = 0;
    _sprite.vertices[i++] = 1;
    i = 0;
    _sprite.faces[i++] = 0;
    _sprite.faces[i++] = 1;
    _sprite.faces[i++] = 2;
    _sprite.faces[i++] = 0;
    _sprite.faces[i++] = 2;
    _sprite.faces[i++] = 3;
    _sprite.vertexBuffer = _gl.createBuffer();
    _sprite.elementBuffer = _gl.createBuffer();
    _gl.bindBuffer(_gl.ARRAY_BUFFER, _sprite.vertexBuffer);
    _gl.bufferData(_gl.ARRAY_BUFFER, _sprite.vertices, _gl.STATIC_DRAW);
    _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, _sprite.elementBuffer);
    _gl.bufferData(_gl.ELEMENT_ARRAY_BUFFER, _sprite.faces, _gl.STATIC_DRAW);
    _sprite.program = createProgram(THREE.ShaderSprite['sprite'], _precision);
    _sprite.attributes = {};
    _sprite.uniforms = {};
    _sprite.attributes.position = _gl.getAttribLocation(_sprite.program, 'position');
    _sprite.attributes.uv = _gl.getAttribLocation(_sprite.program, 'uv');
    _sprite.uniforms.uvOffset = _gl.getUniformLocation(_sprite.program, 'uvOffset');
    _sprite.uniforms.uvScale = _gl.getUniformLocation(_sprite.program, 'uvScale');
    _sprite.uniforms.rotation = _gl.getUniformLocation(_sprite.program, 'rotation');
    _sprite.uniforms.scale = _gl.getUniformLocation(_sprite.program, 'scale');
    _sprite.uniforms.alignment = _gl.getUniformLocation(_sprite.program, 'alignment');
    _sprite.uniforms.color = _gl.getUniformLocation(_sprite.program, 'color');
    _sprite.uniforms.map = _gl.getUniformLocation(_sprite.program, 'map');
    _sprite.uniforms.opacity = _gl.getUniformLocation(_sprite.program, 'opacity');
    _sprite.uniforms.useScreenCoordinates = _gl.getUniformLocation(_sprite.program, 'useScreenCoordinates');
    _sprite.uniforms.sizeAttenuation = _gl.getUniformLocation(_sprite.program, 'sizeAttenuation');
    _sprite.uniforms.screenPosition = _gl.getUniformLocation(_sprite.program, 'screenPosition');
    _sprite.uniforms.modelViewMatrix = _gl.getUniformLocation(_sprite.program, 'modelViewMatrix');
    _sprite.uniforms.projectionMatrix = _gl.getUniformLocation(_sprite.program, 'projectionMatrix');
    _sprite.uniforms.fogType = _gl.getUniformLocation(_sprite.program, 'fogType');
    _sprite.uniforms.fogDensity = _gl.getUniformLocation(_sprite.program, 'fogDensity');
    _sprite.uniforms.fogNear = _gl.getUniformLocation(_sprite.program, 'fogNear');
    _sprite.uniforms.fogFar = _gl.getUniformLocation(_sprite.program, 'fogFar');
    _sprite.uniforms.fogColor = _gl.getUniformLocation(_sprite.program, 'fogColor');
    _sprite.uniforms.alphaTest = _gl.getUniformLocation(_sprite.program, 'alphaTest');
  };
  this.render = function (scene, camera, viewportWidth, viewportHeight) {
    var sprites = scene.__webglSprites, nSprites = sprites.length;
    if (!nSprites)
      return;
    var attributes = _sprite.attributes, uniforms = _sprite.uniforms;
    var invAspect = viewportHeight / viewportWidth;
    var halfViewportWidth = viewportWidth * 0.5, halfViewportHeight = viewportHeight * 0.5;
    _gl.useProgram(_sprite.program);
    _gl.enableVertexAttribArray(attributes.position);
    _gl.enableVertexAttribArray(attributes.uv);
    _gl.disable(_gl.CULL_FACE);
    _gl.enable(_gl.BLEND);
    _gl.bindBuffer(_gl.ARRAY_BUFFER, _sprite.vertexBuffer);
    _gl.vertexAttribPointer(attributes.position, 2, _gl.FLOAT, false, 2 * 8, 0);
    _gl.vertexAttribPointer(attributes.uv, 2, _gl.FLOAT, false, 2 * 8, 8);
    _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, _sprite.elementBuffer);
    _gl.uniformMatrix4fv(uniforms.projectionMatrix, false, camera.projectionMatrix.elements);
    _gl.activeTexture(_gl.TEXTURE0);
    _gl.uniform1i(uniforms.map, 0);
    var oldFogType = 0;
    var sceneFogType = 0;
    var fog = scene.fog;
    if (fog) {
      _gl.uniform3f(uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b);
      if (fog instanceof THREE.Fog) {
        _gl.uniform1f(uniforms.fogNear, fog.near);
        _gl.uniform1f(uniforms.fogFar, fog.far);
        _gl.uniform1i(uniforms.fogType, 1);
        oldFogType = 1;
        sceneFogType = 1;
      } else if (fog instanceof THREE.FogExp2) {
        _gl.uniform1f(uniforms.fogDensity, fog.density);
        _gl.uniform1i(uniforms.fogType, 2);
        oldFogType = 2;
        sceneFogType = 2;
      }
    } else {
      _gl.uniform1i(uniforms.fogType, 0);
      oldFogType = 0;
      sceneFogType = 0;
    }
    var i, sprite, material, screenPosition, size, fogType, scale = [];
    for (i = 0; i < nSprites; i++) {
      sprite = sprites[i];
      material = sprite.material;
      if (!sprite.visible || material.opacity === 0)
        continue;
      if (!material.useScreenCoordinates) {
        sprite._modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, sprite.matrixWorld);
        sprite.z = -sprite._modelViewMatrix.elements[14];
      } else {
        sprite.z = -sprite.position.z;
      }
    }
    sprites.sort(painterSortStable);
    for (i = 0; i < nSprites; i++) {
      sprite = sprites[i];
      material = sprite.material;
      if (!sprite.visible || material.opacity === 0)
        continue;
      if (material.map && material.map.image && material.map.image.width) {
        _gl.uniform1f(uniforms.alphaTest, material.alphaTest);
        if (material.useScreenCoordinates === true) {
          _gl.uniform1i(uniforms.useScreenCoordinates, 1);
          _gl.uniform3f(uniforms.screenPosition, (sprite.position.x * _renderer.devicePixelRatio - halfViewportWidth) / halfViewportWidth, (halfViewportHeight - sprite.position.y * _renderer.devicePixelRatio) / halfViewportHeight, Math.max(0, Math.min(1, sprite.position.z)));
          scale[0] = _renderer.devicePixelRatio;
          scale[1] = _renderer.devicePixelRatio;
        } else {
          _gl.uniform1i(uniforms.useScreenCoordinates, 0);
          _gl.uniform1i(uniforms.sizeAttenuation, material.sizeAttenuation ? 1 : 0);
          _gl.uniformMatrix4fv(uniforms.modelViewMatrix, false, sprite._modelViewMatrix.elements);
          scale[0] = 1;
          scale[1] = 1;
        }
        if (scene.fog && material.fog) {
          fogType = sceneFogType;
        } else {
          fogType = 0;
        }
        if (oldFogType !== fogType) {
          _gl.uniform1i(uniforms.fogType, fogType);
          oldFogType = fogType;
        }
        size = 1 / (material.scaleByViewport ? viewportHeight : 1);
        scale[0] *= size * invAspect * sprite.scale.x;
        scale[1] *= size * sprite.scale.y;
        _gl.uniform2f(uniforms.uvScale, material.uvScale.x, material.uvScale.y);
        _gl.uniform2f(uniforms.uvOffset, material.uvOffset.x, material.uvOffset.y);
        _gl.uniform2f(uniforms.alignment, material.alignment.x, material.alignment.y);
        _gl.uniform1f(uniforms.opacity, material.opacity);
        _gl.uniform3f(uniforms.color, material.color.r, material.color.g, material.color.b);
        _gl.uniform1f(uniforms.rotation, sprite.rotation);
        _gl.uniform2fv(uniforms.scale, scale);
        _renderer.setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst);
        _renderer.setDepthTest(material.depthTest);
        _renderer.setDepthWrite(material.depthWrite);
        _renderer.setTexture(material.map, 0);
        _gl.drawElements(_gl.TRIANGLES, 6, _gl.UNSIGNED_SHORT, 0);
      }
    }
    _gl.enable(_gl.CULL_FACE);
  };
  function createProgram(shader, precision) {
    var program = _gl.createProgram();
    var fragmentShader = _gl.createShader(_gl.FRAGMENT_SHADER);
    var vertexShader = _gl.createShader(_gl.VERTEX_SHADER);
    var prefix = 'precision ' + precision + ' float;\n';
    _gl.shaderSource(fragmentShader, prefix + shader.fragmentShader);
    _gl.shaderSource(vertexShader, prefix + shader.vertexShader);
    _gl.compileShader(fragmentShader);
    _gl.compileShader(vertexShader);
    _gl.attachShader(program, fragmentShader);
    _gl.attachShader(program, vertexShader);
    _gl.linkProgram(program);
    return program;
  }
  ;
  function painterSortStable(a, b) {
    if (a.z !== b.z) {
      return b.z - a.z;
    } else {
      return b.id - a.id;
    }
  }
  ;
};
THREE.DepthPassPlugin = function () {
  this.enabled = false;
  this.renderTarget = null;
  var _gl, _renderer, _depthMaterial, _depthMaterialMorph, _depthMaterialSkin, _depthMaterialMorphSkin, _frustum = new THREE.Frustum(), _projScreenMatrix = new THREE.Matrix4();
  this.init = function (renderer) {
    _gl = renderer.context;
    _renderer = renderer;
    var depthShader = THREE.ShaderLib['depthRGBA'];
    var depthUniforms = THREE.UniformsUtils.clone(depthShader.uniforms);
    _depthMaterial = new THREE.ShaderMaterial({
      fragmentShader: depthShader.fragmentShader,
      vertexShader: depthShader.vertexShader,
      uniforms: depthUniforms
    });
    _depthMaterialMorph = new THREE.ShaderMaterial({
      fragmentShader: depthShader.fragmentShader,
      vertexShader: depthShader.vertexShader,
      uniforms: depthUniforms,
      morphTargets: true
    });
    _depthMaterialSkin = new THREE.ShaderMaterial({
      fragmentShader: depthShader.fragmentShader,
      vertexShader: depthShader.vertexShader,
      uniforms: depthUniforms,
      skinning: true
    });
    _depthMaterialMorphSkin = new THREE.ShaderMaterial({
      fragmentShader: depthShader.fragmentShader,
      vertexShader: depthShader.vertexShader,
      uniforms: depthUniforms,
      morphTargets: true,
      skinning: true
    });
    _depthMaterial._shadowPass = true;
    _depthMaterialMorph._shadowPass = true;
    _depthMaterialSkin._shadowPass = true;
    _depthMaterialMorphSkin._shadowPass = true;
  };
  this.render = function (scene, camera) {
    if (!this.enabled)
      return;
    this.update(scene, camera);
  };
  this.update = function (scene, camera) {
    var i, il, j, jl, n, program, buffer, material, webglObject, object, light, renderList, fog = null;
    _gl.clearColor(1, 1, 1, 1);
    _gl.disable(_gl.BLEND);
    _renderer.setDepthTest(true);
    if (scene.autoUpdate === true)
      scene.updateMatrixWorld();
    camera.matrixWorldInverse.getInverse(camera.matrixWorld);
    _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
    _frustum.setFromMatrix(_projScreenMatrix);
    _renderer.setRenderTarget(this.renderTarget);
    _renderer.clear();
    renderList = scene.__webglObjects;
    for (j = 0, jl = renderList.length; j < jl; j++) {
      webglObject = renderList[j];
      object = webglObject.object;
      webglObject.render = false;
      if (object.visible) {
        if (!(object instanceof THREE.Mesh || object instanceof THREE.ParticleSystem) || !object.frustumCulled || _frustum.intersectsObject(object)) {
          object._modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
          webglObject.render = true;
        }
      }
    }
    var objectMaterial, useMorphing, useSkinning;
    for (j = 0, jl = renderList.length; j < jl; j++) {
      webglObject = renderList[j];
      if (webglObject.render) {
        object = webglObject.object;
        buffer = webglObject.buffer;
        if (object instanceof THREE.ParticleSystem && !object.customDepthMaterial)
          continue;
        objectMaterial = getObjectMaterial(object);
        if (objectMaterial)
          _renderer.setMaterialFaces(object.material);
        useMorphing = object.geometry.morphTargets.length > 0 && objectMaterial.morphTargets;
        useSkinning = object instanceof THREE.SkinnedMesh && objectMaterial.skinning;
        if (object.customDepthMaterial) {
          material = object.customDepthMaterial;
        } else if (useSkinning) {
          material = useMorphing ? _depthMaterialMorphSkin : _depthMaterialSkin;
        } else if (useMorphing) {
          material = _depthMaterialMorph;
        } else {
          material = _depthMaterial;
        }
        if (buffer instanceof THREE.BufferGeometry) {
          _renderer.renderBufferDirect(camera, scene.__lights, fog, material, buffer, object);
        } else {
          _renderer.renderBuffer(camera, scene.__lights, fog, material, buffer, object);
        }
      }
    }
    renderList = scene.__webglObjectsImmediate;
    for (j = 0, jl = renderList.length; j < jl; j++) {
      webglObject = renderList[j];
      object = webglObject.object;
      if (object.visible) {
        object._modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
        _renderer.renderImmediateObject(camera, scene.__lights, fog, _depthMaterial, object);
      }
    }
    var clearColor = _renderer.getClearColor(), clearAlpha = _renderer.getClearAlpha();
    _gl.clearColor(clearColor.r, clearColor.g, clearColor.b, clearAlpha);
    _gl.enable(_gl.BLEND);
  };
  function getObjectMaterial(object) {
    return object.material instanceof THREE.MeshFaceMaterial ? object.material.materials[0] : object.material;
  }
  ;
};
THREE.ShaderFlares = {
  'lensFlareVertexTexture': {
    vertexShader: [
      'uniform lowp int renderType;',
      'uniform vec3 screenPosition;',
      'uniform vec2 scale;',
      'uniform float rotation;',
      'uniform sampler2D occlusionMap;',
      'attribute vec2 position;',
      'attribute vec2 uv;',
      'varying vec2 vUV;',
      'varying float vVisibility;',
      'void main() {',
      'vUV = uv;',
      'vec2 pos = position;',
      'if( renderType == 2 ) {',
      'vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );',
      'visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );',
      'visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );',
      'visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );',
      'visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );',
      'visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );',
      'visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );',
      'visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );',
      'visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );',
      'vVisibility =        visibility.r / 9.0;',
      'vVisibility *= 1.0 - visibility.g / 9.0;',
      'vVisibility *=       visibility.b / 9.0;',
      'vVisibility *= 1.0 - visibility.a / 9.0;',
      'pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;',
      'pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;',
      '}',
      'gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );',
      '}'
    ].join('\n'),
    fragmentShader: [
      'uniform lowp int renderType;',
      'uniform sampler2D map;',
      'uniform float opacity;',
      'uniform vec3 color;',
      'varying vec2 vUV;',
      'varying float vVisibility;',
      'void main() {',
      'if( renderType == 0 ) {',
      'gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );',
      '} else if( renderType == 1 ) {',
      'gl_FragColor = texture2D( map, vUV );',
      '} else {',
      'vec4 texture = texture2D( map, vUV );',
      'texture.a *= opacity * vVisibility;',
      'gl_FragColor = texture;',
      'gl_FragColor.rgb *= color;',
      '}',
      '}'
    ].join('\n')
  },
  'lensFlare': {
    vertexShader: [
      'uniform lowp int renderType;',
      'uniform vec3 screenPosition;',
      'uniform vec2 scale;',
      'uniform float rotation;',
      'attribute vec2 position;',
      'attribute vec2 uv;',
      'varying vec2 vUV;',
      'void main() {',
      'vUV = uv;',
      'vec2 pos = position;',
      'if( renderType == 2 ) {',
      'pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;',
      'pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;',
      '}',
      'gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );',
      '}'
    ].join('\n'),
    fragmentShader: [
      'precision mediump float;',
      'uniform lowp int renderType;',
      'uniform sampler2D map;',
      'uniform sampler2D occlusionMap;',
      'uniform float opacity;',
      'uniform vec3 color;',
      'varying vec2 vUV;',
      'void main() {',
      'if( renderType == 0 ) {',
      'gl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );',
      '} else if( renderType == 1 ) {',
      'gl_FragColor = texture2D( map, vUV );',
      '} else {',
      'float visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;',
      'visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;',
      'visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;',
      'visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;',
      'visibility = ( 1.0 - visibility / 4.0 );',
      'vec4 texture = texture2D( map, vUV );',
      'texture.a *= opacity * visibility;',
      'gl_FragColor = texture;',
      'gl_FragColor.rgb *= color;',
      '}',
      '}'
    ].join('\n')
  }
};
THREE.ShaderSprite = {
  'sprite': {
    vertexShader: [
      'uniform int useScreenCoordinates;',
      'uniform int sizeAttenuation;',
      'uniform vec3 screenPosition;',
      'uniform mat4 modelViewMatrix;',
      'uniform mat4 projectionMatrix;',
      'uniform float rotation;',
      'uniform vec2 scale;',
      'uniform vec2 alignment;',
      'uniform vec2 uvOffset;',
      'uniform vec2 uvScale;',
      'attribute vec2 position;',
      'attribute vec2 uv;',
      'varying vec2 vUV;',
      'void main() {',
      'vUV = uvOffset + uv * uvScale;',
      'vec2 alignedPosition = position + alignment;',
      'vec2 rotatedPosition;',
      'rotatedPosition.x = ( cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y ) * scale.x;',
      'rotatedPosition.y = ( sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y ) * scale.y;',
      'vec4 finalPosition;',
      'if( useScreenCoordinates != 0 ) {',
      'finalPosition = vec4( screenPosition.xy + rotatedPosition, screenPosition.z, 1.0 );',
      '} else {',
      'finalPosition = projectionMatrix * modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',
      'finalPosition.xy += rotatedPosition * ( sizeAttenuation == 1 ? 1.0 : finalPosition.z );',
      '}',
      'gl_Position = finalPosition;',
      '}'
    ].join('\n'),
    fragmentShader: [
      'uniform vec3 color;',
      'uniform sampler2D map;',
      'uniform float opacity;',
      'uniform int fogType;',
      'uniform vec3 fogColor;',
      'uniform float fogDensity;',
      'uniform float fogNear;',
      'uniform float fogFar;',
      'uniform float alphaTest;',
      'varying vec2 vUV;',
      'void main() {',
      'vec4 texture = texture2D( map, vUV );',
      'if ( texture.a < alphaTest ) discard;',
      'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',
      'if ( fogType > 0 ) {',
      'float depth = gl_FragCoord.z / gl_FragCoord.w;',
      'float fogFactor = 0.0;',
      'if ( fogType == 1 ) {',
      'fogFactor = smoothstep( fogNear, fogFar, depth );',
      '} else {',
      'const float LOG2 = 1.442695;',
      'float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',
      'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',
      '}',
      'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',
      '}',
      '}'
    ].join('\n')
  }
};
'use strict';
void 0 === Date.now && (Date.now = function () {
  return new Date().valueOf();
});
var TWEEN = TWEEN || function () {
    var a = [];
    return {
      REVISION: '11dev',
      getAll: function () {
        return a;
      },
      removeAll: function () {
        a = [];
      },
      add: function (c) {
        a.push(c);
      },
      remove: function (c) {
        c = a.indexOf(c);
        -1 !== c && a.splice(c, 1);
      },
      update: function (c) {
        if (0 === a.length)
          return !1;
        for (var b = 0, d = a.length, c = void 0 !== c ? c : 'undefined' !== typeof window && void 0 !== window.performance && void 0 !== window.performance.now ? window.performance.now() : Date.now(); b < d;)
          a[b].update(c) ? b++ : (a.splice(b, 1), d--);
        return !0;
      }
    };
  }();
TWEEN.Tween = function (a) {
  var c = {}, b = {}, d = {}, e = 1000, g = 0, h = !1, n = 0, l = null, v = TWEEN.Easing.Linear.None, w = TWEEN.Interpolation.Linear, p = [], q = null, r = !1, s = null, t = null, j;
  for (j in a)
    c[j] = parseFloat(a[j], 10);
  this.to = function (a, c) {
    void 0 !== c && (e = c);
    b = a;
    return this;
  };
  this.start = function (e) {
    TWEEN.add(this);
    r = !1;
    l = void 0 !== e ? e : 'undefined' !== typeof window && void 0 !== window.performance && void 0 !== window.performance.now ? window.performance.now() : Date.now();
    l += n;
    for (var f in b) {
      if (b[f] instanceof Array) {
        if (0 === b[f].length)
          continue;
        b[f] = [a[f]].concat(b[f]);
      }
      c[f] = a[f];
      !1 === c[f] instanceof Array && (c[f] *= 1);
      d[f] = c[f] || 0;
    }
    return this;
  };
  this.stop = function () {
    TWEEN.remove(this);
    return this;
  };
  this.delay = function (a) {
    n = a;
    return this;
  };
  this.repeat = function (a) {
    g = a;
    return this;
  };
  this.yoyo = function (a) {
    h = a;
    return this;
  };
  this.easing = function (a) {
    v = a;
    return this;
  };
  this.interpolation = function (a) {
    w = a;
    return this;
  };
  this.chain = function () {
    p = arguments;
    return this;
  };
  this.onStart = function (a) {
    q = a;
    return this;
  };
  this.onUpdate = function (a) {
    s = a;
    return this;
  };
  this.onComplete = function (a) {
    t = a;
    return this;
  };
  this.update = function (m) {
    var f;
    if (m < l)
      return !0;
    !1 === r && (null !== q && q.call(a), r = !0);
    var i = (m - l) / e, i = 1 < i ? 1 : i, j = v(i);
    for (f in b) {
      var u = c[f] || 0, k = b[f];
      k instanceof Array ? a[f] = w(k, j) : ('string' === typeof k && (k = u + parseFloat(k, 10)), 'number' === typeof k && (a[f] = u + (k - u) * j));
    }
    null !== s && s.call(a, j);
    if (1 == i)
      if (0 < g) {
        isFinite(g) && g--;
        for (f in d)
          'string' === typeof b[f] && (d[f] += parseFloat(b[f], 10)), h && (i = d[f], d[f] = b[f], b[f] = i), c[f] = d[f];
        l = m + n;
      } else {
        null !== t && t.call(a);
        f = 0;
        for (i = p.length; f < i; f++)
          p[f].start(m);
        return !1;
      }
    return !0;
  };
};
TWEEN.Easing = {
  Linear: {
    None: function (a) {
      return a;
    }
  },
  Quadratic: {
    In: function (a) {
      return a * a;
    },
    Out: function (a) {
      return a * (2 - a);
    },
    InOut: function (a) {
      return 1 > (a *= 2) ? 0.5 * a * a : -0.5 * (--a * (a - 2) - 1);
    }
  },
  Cubic: {
    In: function (a) {
      return a * a * a;
    },
    Out: function (a) {
      return --a * a * a + 1;
    },
    InOut: function (a) {
      return 1 > (a *= 2) ? 0.5 * a * a * a : 0.5 * ((a -= 2) * a * a + 2);
    }
  },
  Quartic: {
    In: function (a) {
      return a * a * a * a;
    },
    Out: function (a) {
      return 1 - --a * a * a * a;
    },
    InOut: function (a) {
      return 1 > (a *= 2) ? 0.5 * a * a * a * a : -0.5 * ((a -= 2) * a * a * a - 2);
    }
  },
  Quintic: {
    In: function (a) {
      return a * a * a * a * a;
    },
    Out: function (a) {
      return --a * a * a * a * a + 1;
    },
    InOut: function (a) {
      return 1 > (a *= 2) ? 0.5 * a * a * a * a * a : 0.5 * ((a -= 2) * a * a * a * a + 2);
    }
  },
  Sinusoidal: {
    In: function (a) {
      return 1 - Math.cos(a * Math.PI / 2);
    },
    Out: function (a) {
      return Math.sin(a * Math.PI / 2);
    },
    InOut: function (a) {
      return 0.5 * (1 - Math.cos(Math.PI * a));
    }
  },
  Exponential: {
    In: function (a) {
      return 0 === a ? 0 : Math.pow(1024, a - 1);
    },
    Out: function (a) {
      return 1 === a ? 1 : 1 - Math.pow(2, -10 * a);
    },
    InOut: function (a) {
      return 0 === a ? 0 : 1 === a ? 1 : 1 > (a *= 2) ? 0.5 * Math.pow(1024, a - 1) : 0.5 * (-Math.pow(2, -10 * (a - 1)) + 2);
    }
  },
  Circular: {
    In: function (a) {
      return 1 - Math.sqrt(1 - a * a);
    },
    Out: function (a) {
      return Math.sqrt(1 - --a * a);
    },
    InOut: function (a) {
      return 1 > (a *= 2) ? -0.5 * (Math.sqrt(1 - a * a) - 1) : 0.5 * (Math.sqrt(1 - (a -= 2) * a) + 1);
    }
  },
  Elastic: {
    In: function (a) {
      var c, b = 0.1;
      if (0 === a)
        return 0;
      if (1 === a)
        return 1;
      !b || 1 > b ? (b = 1, c = 0.1) : c = 0.4 * Math.asin(1 / b) / (2 * Math.PI);
      return -(b * Math.pow(2, 10 * (a -= 1)) * Math.sin((a - c) * 2 * Math.PI / 0.4));
    },
    Out: function (a) {
      var c, b = 0.1;
      if (0 === a)
        return 0;
      if (1 === a)
        return 1;
      !b || 1 > b ? (b = 1, c = 0.1) : c = 0.4 * Math.asin(1 / b) / (2 * Math.PI);
      return b * Math.pow(2, -10 * a) * Math.sin((a - c) * 2 * Math.PI / 0.4) + 1;
    },
    InOut: function (a) {
      var c, b = 0.1;
      if (0 === a)
        return 0;
      if (1 === a)
        return 1;
      !b || 1 > b ? (b = 1, c = 0.1) : c = 0.4 * Math.asin(1 / b) / (2 * Math.PI);
      return 1 > (a *= 2) ? -0.5 * b * Math.pow(2, 10 * (a -= 1)) * Math.sin((a - c) * 2 * Math.PI / 0.4) : 0.5 * b * Math.pow(2, -10 * (a -= 1)) * Math.sin((a - c) * 2 * Math.PI / 0.4) + 1;
    }
  },
  Back: {
    In: function (a) {
      return a * a * (2.70158 * a - 1.70158);
    },
    Out: function (a) {
      return --a * a * (2.70158 * a + 1.70158) + 1;
    },
    InOut: function (a) {
      return 1 > (a *= 2) ? 0.5 * a * a * (3.5949095 * a - 2.5949095) : 0.5 * ((a -= 2) * a * (3.5949095 * a + 2.5949095) + 2);
    }
  },
  Bounce: {
    In: function (a) {
      return 1 - TWEEN.Easing.Bounce.Out(1 - a);
    },
    Out: function (a) {
      return a < 1 / 2.75 ? 7.5625 * a * a : a < 2 / 2.75 ? 7.5625 * (a -= 1.5 / 2.75) * a + 0.75 : a < 2.5 / 2.75 ? 7.5625 * (a -= 2.25 / 2.75) * a + 0.9375 : 7.5625 * (a -= 2.625 / 2.75) * a + 0.984375;
    },
    InOut: function (a) {
      return 0.5 > a ? 0.5 * TWEEN.Easing.Bounce.In(2 * a) : 0.5 * TWEEN.Easing.Bounce.Out(2 * a - 1) + 0.5;
    }
  }
};
TWEEN.Interpolation = {
  Linear: function (a, c) {
    var b = a.length - 1, d = b * c, e = Math.floor(d), g = TWEEN.Interpolation.Utils.Linear;
    return 0 > c ? g(a[0], a[1], d) : 1 < c ? g(a[b], a[b - 1], b - d) : g(a[e], a[e + 1 > b ? b : e + 1], d - e);
  },
  Bezier: function (a, c) {
    var b = 0, d = a.length - 1, e = Math.pow, g = TWEEN.Interpolation.Utils.Bernstein, h;
    for (h = 0; h <= d; h++)
      b += e(1 - c, d - h) * e(c, h) * a[h] * g(d, h);
    return b;
  },
  CatmullRom: function (a, c) {
    var b = a.length - 1, d = b * c, e = Math.floor(d), g = TWEEN.Interpolation.Utils.CatmullRom;
    return a[0] === a[b] ? (0 > c && (e = Math.floor(d = b * (1 + c))), g(a[(e - 1 + b) % b], a[e], a[(e + 1) % b], a[(e + 2) % b], d - e)) : 0 > c ? a[0] - (g(a[0], a[0], a[1], a[1], -d) - a[0]) : 1 < c ? a[b] - (g(a[b], a[b], a[b - 1], a[b - 1], d - b) - a[b]) : g(a[e ? e - 1 : 0], a[e], a[b < e + 1 ? b : e + 1], a[b < e + 2 ? b : e + 2], d - e);
  },
  Utils: {
    Linear: function (a, c, b) {
      return (c - a) * b + a;
    },
    Bernstein: function (a, c) {
      var b = TWEEN.Interpolation.Utils.Factorial;
      return b(a) / b(c) / b(a - c);
    },
    Factorial: function () {
      var a = [1];
      return function (c) {
        var b = 1, d;
        if (a[c])
          return a[c];
        for (d = c; 1 < d; d--)
          b *= d;
        return a[c] = b;
      };
    }(),
    CatmullRom: function (a, c, b, d, e) {
      var a = 0.5 * (b - a), d = 0.5 * (d - c), g = e * e;
      return (2 * c - 2 * b + a + d) * e * g + (-3 * c + 3 * b - 2 * a - d) * g + a * e + c;
    }
  }
};
(function ($window, $document, tagName, url, namespace, a, m) {
  $window['GoogleAnalyticsObject'] = namespace;
  $window[namespace] = $window[namespace] || function () {
    ($window[namespace].q = $window[namespace].q || []).push(arguments);
  }, $window[namespace].l = 1 * new Date();
  a = $document.createElement(tagName), m = $document.getElementsByTagName(tagName)[0];
  a.async = 1;
  a.src = url;
  m.parentNode.insertBefore(a, m);
}(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga'));
var Stats = function () {
  var startTime = Date.now(), prevTime = startTime;
  var ms = 0, msMin = Infinity, msMax = 0;
  var fps = 0, fpsMin = Infinity, fpsMax = 0;
  var frames = 0, mode = 0;
  var container = document.createElement('div');
  container.id = 'stats';
  container.addEventListener('mousedown', function (event) {
    event.preventDefault();
    setMode(++mode % 2);
  }, false);
  container.style.cssText = 'width:80px;opacity:0.9;cursor:pointer';
  var fpsDiv = document.createElement('div');
  fpsDiv.id = 'fps';
  fpsDiv.style.cssText = 'padding:0 0 3px 3px;text-align:left;background-color:#002';
  container.appendChild(fpsDiv);
  var fpsText = document.createElement('div');
  fpsText.id = 'fpsText';
  fpsText.style.cssText = 'color:#0ff;font-family:Helvetica,Arial,sans-serif;font-size:9px;font-weight:bold;line-height:15px';
  fpsText.innerHTML = 'FPS';
  fpsDiv.appendChild(fpsText);
  var fpsGraph = document.createElement('div');
  fpsGraph.id = 'fpsGraph';
  fpsGraph.style.cssText = 'position:relative;width:74px;height:30px;background-color:#0ff';
  fpsDiv.appendChild(fpsGraph);
  while (fpsGraph.children.length < 74) {
    var bar = document.createElement('span');
    bar.style.cssText = 'width:1px;height:30px;float:left;background-color:#113';
    fpsGraph.appendChild(bar);
  }
  var msDiv = document.createElement('div');
  msDiv.id = 'ms';
  msDiv.style.cssText = 'padding:0 0 3px 3px;text-align:left;background-color:#020;display:none';
  container.appendChild(msDiv);
  var msText = document.createElement('div');
  msText.id = 'msText';
  msText.style.cssText = 'color:#0f0;font-family:Helvetica,Arial,sans-serif;font-size:9px;font-weight:bold;line-height:15px';
  msText.innerHTML = 'MS';
  msDiv.appendChild(msText);
  var msGraph = document.createElement('div');
  msGraph.id = 'msGraph';
  msGraph.style.cssText = 'position:relative;width:74px;height:30px;background-color:#0f0';
  msDiv.appendChild(msGraph);
  while (msGraph.children.length < 74) {
    var bar = document.createElement('span');
    bar.style.cssText = 'width:1px;height:30px;float:left;background-color:#131';
    msGraph.appendChild(bar);
  }
  var setMode = function (value) {
    mode = value;
    switch (mode) {
    case 0:
      fpsDiv.style.display = 'block';
      msDiv.style.display = 'none';
      break;
    case 1:
      fpsDiv.style.display = 'none';
      msDiv.style.display = 'block';
      break;
    }
  };
  var updateGraph = function (dom, value) {
    var child = dom.appendChild(dom.firstChild);
    child.style.height = value + 'px';
  };
  return {
    REVISION: 11,
    domElement: container,
    setMode: setMode,
    begin: function () {
      startTime = Date.now();
    },
    end: function () {
      var time = Date.now();
      ms = time - startTime;
      msMin = Math.min(msMin, ms);
      msMax = Math.max(msMax, ms);
      msText.textContent = ms + ' MS (' + msMin + '-' + msMax + ')';
      updateGraph(msGraph, Math.min(30, 30 - ms / 200 * 30));
      frames++;
      if (time > prevTime + 1000) {
        fps = Math.round(frames * 1000 / (time - prevTime));
        fpsMin = Math.min(fpsMin, fps);
        fpsMax = Math.max(fpsMax, fps);
        fpsText.textContent = fps + ' FPS (' + fpsMin + '-' + fpsMax + ')';
        updateGraph(fpsGraph, Math.min(30, 30 - fps / 100 * 30));
        prevTime = time;
        frames = 0;
      }
      return time;
    },
    update: function () {
      startTime = this.end();
    }
  };
};
(function () {
  angular.module('app', [
    'async',
    'jed',
    'jquery',
    'underscore'
  ]).run([
    '$rootScope',
    '$location',
    'GitHub',
    'cookie',
    'i18n',
    function ($rootScope, $location, github, cookie, i18n) {
      var GITHUB_APPLICATION_CLIENT_ID_COOKIE_NAME, GITHUB_LOGIN_COOKIE_NAME, GITHUB_TOKEN_COOKIE_NAME;
      GITHUB_APPLICATION_CLIENT_ID_COOKIE_NAME = 'github-application-client-id';
      GITHUB_TOKEN_COOKIE_NAME = 'github-token';
      GITHUB_LOGIN_COOKIE_NAME = 'github-login';
      $rootScope.i18n = i18n;
      $rootScope.breadcrumbStrategy = { progressive: false };
      $rootScope.clientId = function () {
        return cookie.getItem(GITHUB_APPLICATION_CLIENT_ID_COOKIE_NAME);
      };
      $rootScope.log = function (thing) {
        return console.log(thing);
      };
      $rootScope.alert = function (thing) {
        return alert(thing);
      };
      $rootScope.isLoggedIn = function () {
        return cookie.hasItem(GITHUB_TOKEN_COOKIE_NAME);
      };
      $rootScope.loginEnabled = function () {
        return !cookie.hasItem(GITHUB_TOKEN_COOKIE_NAME);
      };
      $rootScope.logout = function () {
        cookie.removeItem(GITHUB_TOKEN_COOKIE_NAME);
        return cookie.removeItem(GITHUB_LOGIN_COOKIE_NAME);
      };
      return $rootScope.userLogin = function () {
        return cookie.getItem(GITHUB_LOGIN_COOKIE_NAME);
      };
    }
  ]);
}.call(this));
(function () {
  angular.module('app').controller('BrowseCtrl', [
    '$scope',
    '$window',
    '$location',
    function ($scope, $window, $location) {
      var EVENT_CATEGORY;
      EVENT_CATEGORY = 'browse';
      ga('create', 'UA-41504069-1', 'geometryzen.org');
      ga('set', 'page', '/browse');
      return ga('send', 'pageview');
    }
  ]);
}.call(this));
(function () {
  angular.module('app').controller('HomeCtrl', [
    '$rootScope',
    '$scope',
    '$http',
    '$location',
    '$window',
    'GitHub',
    'cookie',
    function ($rootScope, $scope, $http, $location, $window, github, cookie) {
      var EVENT_CATEGORY, GATEKEEPER_DOMAIN, GITHUB_LOGIN_COOKIE_NAME, GITHUB_TOKEN_COOKIE_NAME, code, match;
      EVENT_CATEGORY = 'home';
      ga('create', 'UA-41504069-1', 'geometryzen.org');
      ga('set', 'page', '/home');
      ga('send', 'pageview');
      GATEKEEPER_DOMAIN = '' + $location.protocol() + '://' + $location.host() + ':' + $location.port();
      GITHUB_TOKEN_COOKIE_NAME = 'github-token';
      GITHUB_LOGIN_COOKIE_NAME = 'github-login';
      match = $window.location.href.match(/\?code=([a-z0-9]*)/);
      if (match) {
        $location.search({});
        code = match[1];
        $http.get('' + GATEKEEPER_DOMAIN + '/authenticate/' + code).success(function (data, status, headers, config) {
          var token;
          token = data.token;
          cookie.setItem(GITHUB_TOKEN_COOKIE_NAME, token);
          github.getUser(token, function (error, user) {
            if (!error) {
              cookie.setItem(GITHUB_LOGIN_COOKIE_NAME, user.login);
            } else {
              alert('Error retrieving your user login!');
            }
          });
        }).error(function (data, status, headers, config) {
          alert('Something is rotten in Denmark.');
        });
      }
      match = $window.location.href.match(/\?error=access_denied/);
      if (match) {
        $location.search({});
      }
      $scope.work = function () {
        ga('send', 'event', EVENT_CATEGORY, 'work');
        $location.path('/work');
      };
      $scope.browse = function () {
        ga('send', 'event', EVENT_CATEGORY, 'browse');
        $location.path('/browse');
      };
      return $scope.user = function () {
        var path;
        ga('send', 'event', EVENT_CATEGORY, 'user');
        path = '/users/' + $scope.userLogin();
        $location.path(path);
      };
    }
  ]);
}.call(this));
(function () {
  angular.module('app').controller('NewFileCtrl', [
    '$scope',
    'GitHub',
    'Base64',
    'cookie',
    '$',
    '_',
    '$async',
    function ($scope, github, base64, cookie, $, _, $async) {
      var EVENT_CATEGORY, GITHUB_TOKEN_COOKIE_NAME, token;
      EVENT_CATEGORY = 'new-file';
      ga('create', 'UA-41504069-1', 'geometryzen.org');
      ga('set', 'page', '/new-file');
      ga('send', 'pageview');
      GITHUB_TOKEN_COOKIE_NAME = 'github-token';
      token = cookie.getItem(GITHUB_TOKEN_COOKIE_NAME);
      $('#new-file-dialog').on('show', function () {
        return $scope.file = {
          name: '',
          message: ''
        };
      });
      $('#new-file-dialog').on('shown', function () {
      });
      $('#new-file-dialog').on('hide', function () {
      });
      $('#new-file-dialog').on('hidden', function () {
      });
      return $scope.createFile = function () {
        var content, path;
        ga('send', 'event', EVENT_CATEGORY, 'createFile');
        content = base64.encode('# ' + $scope.file.name + '\n');
        path = $scope.path ? '' + $scope.path + '/' + $scope.file.name : $scope.file.name;
        return github.putFile(token, $scope.user.login, $scope.repo.name, path, $scope.file.message, content, void 0, function (err, response, status, headers, config) {
          var messages;
          if (!err) {
            $scope.$emit('createdFile', $scope.user, $scope.repo, response.content, response.commit);
            return $('#new-file-dialog').modal('hide');
          } else {
            messages = _.map(response.errors, function (error) {
              return error.message;
            }).join();
            return alert(messages);
          }
        });
      };
    }
  ]);
}.call(this));
(function () {
  angular.module('app').controller('NewRepoCtrl', [
    '$scope',
    'GitHub',
    'cookie',
    '$',
    '_',
    '$async',
    function ($scope, github, cookie, $, _, $async) {
      var EVENT_CATEGORY, GITHUB_TOKEN_COOKIE_NAME, token;
      EVENT_CATEGORY = 'new-repo';
      ga('create', 'UA-41504069-1', 'geometryzen.org');
      ga('set', 'page', '/new-repo');
      ga('send', 'pageview');
      GITHUB_TOKEN_COOKIE_NAME = 'github-token';
      token = cookie.getItem(GITHUB_TOKEN_COOKIE_NAME);
      $('#new-repo-dialog').on('show', function () {
        return $scope.repo = {
          path: '',
          description: '',
          'private': 'false',
          markdownReadme: true,
          pythonReadme: true
        };
      });
      $('#new-repo-dialog').on('shown', function () {
      });
      $('#new-repo-dialog').on('hide', function () {
      });
      $('#new-repo-dialog').on('hidden', function () {
      });
      return $scope.createRepo = function () {
        ga('send', 'event', EVENT_CATEGORY, 'createRepo');
        return github.postRepo(token, $scope.repo.name, $scope.repo.description, false, $scope.repo.markdownReadme, function (err, repo) {
          var messages;
          if (!err) {
            console.log('repo: ' + JSON.stringify(repo, null, 2));
            $scope.$emit('createdRepo', $scope.user, repo);
            return $('#new-repo-dialog').modal('hide');
          } else {
            messages = _.map(response.errors, function (error) {
              return error.message;
            }).join();
            return alert(messages);
          }
        });
      };
    }
  ]);
}.call(this));
(function () {
  angular.module('app').controller('PrinterCtrl', [
    '$scope',
    'GitHub',
    'cookie',
    '$',
    '_',
    '$async',
    function ($scope, github, cookie, $, _, $async) {
      var EVENT_CATEGORY, PRESERVE_ELEMENT_ID, escapeHtml;
      EVENT_CATEGORY = 'printer';
      ga('create', 'UA-41504069-1', 'geometryzen.org');
      ga('set', 'page', '/printer');
      ga('send', 'pageview');
      PRESERVE_ELEMENT_ID = 'a5f435e0-c92e-11e2-8b8b-0800200c9a66';
      escapeHtml = function (s) {
        return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#039;');
      };
      $scope.$on('reset', function (e) {
        var elem;
        elem = document.getElementById(PRESERVE_ELEMENT_ID);
        if (elem) {
          return elem.innerHTML = '';
        } else {
          return console.log('Unable to find element with Id ' + PRESERVE_ELEMENT_ID);
        }
      });
      return $scope.$on('print', function (e, text) {
        var elem;
        elem = document.getElementById(PRESERVE_ELEMENT_ID);
        if (elem) {
          return elem.innerHTML = elem.innerHTML + escapeHtml(text);
        } else {
          return console.log('Unable to find element with Id ' + PRESERVE_ELEMENT_ID);
        }
      });
    }
  ]);
}.call(this));
(function () {
  angular.module('app').controller('TreeCtrl', [
    '$rootScope',
    '$scope',
    '$window',
    '$routeParams',
    '$',
    '_',
    'GitHub',
    'Base64',
    'cookie',
    function ($rootScope, $scope, $window, $routeParams, $, _, github, base64, cookie) {
      var EVENT_CATEGORY, GITHUB_TOKEN_COOKIE_NAME, n, steps, token, _i;
      EVENT_CATEGORY = 'tree';
      ga('create', 'UA-41504069-1', 'geometryzen.org');
      ga('set', 'page', '/tree');
      ga('send', 'pageview');
      GITHUB_TOKEN_COOKIE_NAME = 'github-token';
      token = cookie.getItem(GITHUB_TOKEN_COOKIE_NAME);
      $scope.messages = [];
      $('.carousel').carousel({ interval: false });
      $scope.contextItem = {};
      if ($routeParams.user && $routeParams.repo) {
        $scope.user = { login: $routeParams.user };
        $scope.repo = { name: $routeParams.repo };
        $scope.branch = { name: $routeParams.branch };
        steps = [];
        for (n = _i = 0; _i <= 6; n = ++_i) {
          if ($routeParams['step' + n]) {
            steps.push($routeParams['step' + n]);
          }
        }
        $scope.path = steps.join('/');
        $scope.contextItem.name = $scope.repo.name;
        $scope.contextItem.type = 'repo';
        github.getPathContents(token, $scope.user.login, $scope.repo.name, $scope.path, function (err, response, status, headers, config) {
          if (!err) {
            return $scope.contextItem.childItems = response;
          } else {
            return alert('' + err.message + '. Cause: ' + response.message + '.');
          }
        });
      } else {
        $scope.contextItem.name = '';
        $scope.contextItem.type = void 0;
      }
      $scope.isNewFileEnabled = function () {
        return $scope.isLoggedIn() && $scope.userLogin() === $scope.user.login;
      };
      $scope.newFile = function () {
        if ($scope.isNewFileEnabled()) {
          return $('#new-file-dialog').modal({
            show: true,
            backdrop: true
          });
        } else {
          return alert('Create a New File is not enabled.');
        }
      };
      $scope.$on('createdFile', function (e, user, repo, item, commit) {
        return $scope.contextItem.childItems.push(item);
      });
      $scope.isDeleteItemEnabled = function () {
        return $scope.isLoggedIn() && $scope.userLogin() === $scope.user.login;
      };
      $scope.deleteItem = function (idx) {
        var childItem;
        ga('send', 'event', EVENT_CATEGORY, 'deleteItem');
        childItem = $scope.contextItem.childItems[idx];
        return github.deleteFile(token, $scope.user.login, $scope.repo.name, childItem.path, 'Delete item.', childItem.sha, function (err, response, status, headers, config) {
          if (!err) {
            return $scope.contextItem.childItems.splice(idx, 1);
          } else {
            return alert('Error deleting item: ' + err);
          }
        });
      };
      $scope.homeBreadcrumbClass = function () {
        if ($rootScope.breadcrumbStrategy.progressive) {
          return 'active';
        } else {
          return '';
        }
      };
      $scope.userBreadcrumbClass = function () {
        if ($rootScope.breadcrumbStrategy.progressive) {
          return 'active';
        } else {
          return '';
        }
      };
      $scope.repoBreadcrumbClass = function () {
        return 'active';
      };
      $scope.hrefFromItem = function (item) {
        var collectionName;
        collectionName = item.type === 'file' ? 'blob' : item.type === 'dir' ? 'tree' : 'unknown';
        return '/users/' + $scope.user.login + '/repos/' + $scope.repo.name + '/' + collectionName + '/' + $scope.branch.name + '/' + item.path;
      };
      $scope.iconFromItem = function (item) {
        switch (item.type) {
        case 'file':
          return 'icon-file';
        case 'dir':
          return 'icon-dir';
        default:
          return 'icon-question';
        }
      };
    }
  ]);
}.call(this));
(function () {
  angular.module('app').controller('UserCtrl', [
    '$rootScope',
    '$scope',
    'GitHub',
    'cookie',
    '$',
    '_',
    '$async',
    function ($rootScope, $scope, github, cookie, $, _, $async) {
      var EVENT_CATEGORY, GITHUB_TOKEN_COOKIE_NAME, token;
      EVENT_CATEGORY = 'user';
      ga('create', 'UA-41504069-1', 'geometryzen.org');
      ga('set', 'page', '/user');
      ga('send', 'pageview');
      GITHUB_TOKEN_COOKIE_NAME = 'github-token';
      token = cookie.getItem(GITHUB_TOKEN_COOKIE_NAME);
      $async.parallel([
        function (callback) {
          return github.getUser(token, function (err, user) {
            if (!err) {
              $scope.user = user;
            } else {
              alert('Error retrieving user profile');
            }
            return callback(err, user);
          });
        },
        function (callback) {
          return github.getUserRepos(token, function (err, repos) {
            if (!err) {
              $scope.repos = _.filter(repos, function (repo) {
                return repo.language === 'Python';
              });
            } else {
              alert('Error retrieving user repositories');
            }
            return callback(err, repos);
          });
        }
      ], function (err, results) {
      });
      $scope.homeBreadcrumbClass = function () {
        if ($rootScope.breadcrumbStrategy.progressive) {
          return 'active distance-1';
        } else {
          return '';
        }
      };
      $scope.userBreadcrumbClass = function () {
        if ($rootScope.breadcrumbStrategy.progressive) {
          return 'active distance-0';
        } else {
          return 'active distance-0';
        }
      };
      $scope.newRepo = function () {
        return $('#new-repo-dialog').modal({
          show: true,
          backdrop: true
        });
      };
      return $scope.$on('createdRepo', function (e, user, repo) {
        return $scope.repos.push(repo);
      });
    }
  ]);
}.call(this));
(function () {
  angular.module('app').controller('WorkCtrl', [
    '$rootScope',
    '$scope',
    '$window',
    '$routeParams',
    '$',
    '_',
    'GitHub',
    'Base64',
    'cookie',
    function ($rootScope, $scope, $window, $routeParams, $, _, github, base64, cookie) {
      var EVENT_CATEGORY, GITHUB_TOKEN_COOKIE_NAME, code, editor, isFullScreen, n, setFullScreen, steps, token, winHeight, winWidth, _i;
      EVENT_CATEGORY = 'work';
      ga('create', 'UA-41504069-1', 'geometryzen.org');
      ga('set', 'page', '/work');
      ga('send', 'pageview');
      GITHUB_TOKEN_COOKIE_NAME = 'github-token';
      token = cookie.getItem(GITHUB_TOKEN_COOKIE_NAME);
      $scope.messages = [];
      $('.carousel').carousel({ interval: false });
      $scope.contextItem = {};
      if ($routeParams.user && $routeParams.repo) {
        $scope.user = { login: $routeParams.user };
        $scope.repo = { name: $routeParams.repo };
        $scope.branch = { name: $routeParams.branch };
        steps = [];
        for (n = _i = 0; _i <= 6; n = ++_i) {
          if ($routeParams['step' + n]) {
            steps.push($routeParams['step' + n]);
          }
        }
        $scope.path = steps.join('/');
        $scope.contextItem.name = $routeParams.repo;
        $scope.contextItem.type = 'repo';
        github.getPathContents(token, $scope.user.login, $scope.repo.name, $scope.path, function (err, file) {
          var contextItem;
          if (!err) {
            contextItem = {
              name: file.name,
              path: file.path,
              sha: file.sha,
              type: file.type,
              parentItem: $scope.contextItem,
              childItems: []
            };
            $scope.contextItem = contextItem;
            if (file.encoding === 'base64') {
              return editor.setValue(base64.decode(file.content));
            } else {
              return alert('Unknown encoding: ' + file.encoding);
            }
          } else {
            return alert('Error retrieving the page');
          }
        });
      } else {
        $scope.contextItem.name = '';
        $scope.contextItem.type = void 0;
      }
      winHeight = function () {
        return $window.innerHeight || ($window.document.documentElement || $window.document.body).clientHeight;
      };
      winWidth = function () {
        return $window.innerWidth || ($window.document.documentElement || $window.document.body).clientWidth;
      };
      isFullScreen = function (cm) {
        return /\bCodeMirror-fullscreen\b/.test(cm.getWrapperElement().className);
      };
      setFullScreen = function (cm, full) {
        var wrapperElement;
        wrapperElement = cm.getWrapperElement();
        if (full) {
          wrapperElement.className += ' CodeMirror-fullscreen';
          wrapperElement.style.height = winHeight() + 'px';
          document.documentElement.style.overflow = 'hidden';
        } else {
          wrapperElement.className = wrapperElement.className.replace(' CodeMirror-fullscreen', '');
          wrapperElement.style.height = '800px';
          document.documentElement.style.overflow = '';
        }
        return cm.refresh();
      };
      code = document.getElementById('code');
      if (code) {
        editor = CodeMirror.fromTextArea(code, {
          'autofocus': false,
          'indentUnit': 4,
          'lineNumbers': true,
          'lineWrapping': true,
          'autoMatchParens': true,
          'parserConfig': {
            'pythonVersion': 2,
            'strictErrors': true
          },
          'theme': 'twilight',
          'extraKeys': {
            'Tab': function (cm) {
              var spaces;
              spaces = Array(cm.getOption('indentUnit') + 1).join(' ');
              return cm.replaceSelection(spaces, 'end', '+input');
            },
            'Ctrl-S': function (cm) {
              return $scope.saveFile();
            },
            'Ctrl-Enter': function (cm) {
              return $scope.run();
            }
          }
        });
      } else {
        alert('The code element could not be found');
      }
      $scope.run = function () {
        var e, message, name, prog, text;
        ga('send', 'event', EVENT_CATEGORY, 'run');
        $rootScope.$broadcast('reset');
        $scope.messages.length = 0;
        prog = editor.getValue();
        Sk.canvas = 'canvas';
        Sk.configure({
          'output': function (text) {
            return $rootScope.$broadcast('print', text);
          },
          'read': function (searchPath) {
            if (Sk.builtinFiles === void 0 || Sk.builtinFiles['files'][searchPath] === void 0) {
              throw new Error('File not found: \'' + searchPath + '\'');
            } else {
              return Sk.builtinFiles['files'][searchPath];
            }
          }
        });
        if (prog.trim().length > 0) {
          try {
            return eval(Sk.importMainWithBody('<stdin>', false, prog.trim()));
          } catch (_error) {
            e = _error;
            message = e.toString();
            name = message.substring(0, message.indexOf(':'));
            text = message.substring(message.indexOf(':') + 1);
            return $scope.messages.push({
              name: name,
              text: text,
              severity: 'error'
            });
          }
        }
      };
      $scope.saveFile = function () {
        var content;
        ga('send', 'event', EVENT_CATEGORY, 'savePage');
        content = base64.encode(editor.getValue());
        return github.putFile(token, $scope.user.login, $scope.repo.name, $scope.contextItem.path, 'Save file.', content, $scope.contextItem.sha, function (err, response, status, headers, config) {
          if (!err) {
            return $scope.contextItem.sha = response.content.sha;
          } else {
            return alert('Error saving file to repository. Cause: ' + err.message);
          }
        });
      };
      $scope.homeBreadcrumbClass = function () {
        if ($rootScope.breadcrumbStrategy.progressive) {
          return 'active';
        } else {
          return '';
        }
      };
      $scope.userBreadcrumbClass = function () {
        if ($rootScope.breadcrumbStrategy.progressive) {
          return 'active';
        } else {
          return '';
        }
      };
      $scope.repoBreadcrumbClass = function () {
        if ($rootScope.breadcrumbStrategy.progressive) {
          return 'active';
        } else {
          if ($scope.workEnabled()) {
            return '';
          } else {
            return 'active';
          }
        }
      };
      $scope.repoEnabled = function () {
        return $scope.repo && $scope.repo.name;
      };
      $scope.workEnabled = function () {
        return $scope.contextItem && $scope.contextItem.type === 'file' || !($scope.repo && $scope.repo.name);
      };
      $scope.saveEnabled = function () {
        return $scope.isLoggedIn() && $scope.userLogin() === $scope.user.login && $scope.contextItem && $scope.contextItem.type === 'file';
      };
      $scope.runEnabled = function () {
        return $scope.workEnabled();
      };
      $scope.iconFromItem = function (item) {
        switch (item.type) {
        case 'file':
          return 'icon-file';
        case 'dir':
          return 'icon-dir';
        default:
          return 'icon-question';
        }
      };
      if (editor) {
        setFullScreen(editor, false);
      }
      CodeMirror.on($window, 'resize', function () {
        var showing;
        showing = $window.document.body.getElementsByClassName('CodeMirror-fullscreen')[0];
        if (showing) {
          return showing.CodeMirror.getWrapperElement().style.height = winHeight() + 'px';
        } else {
        }
      });
    }
  ]);
}.call(this));
(function () {
  angular.module('app').directive('aBrand', function () {
    return {
      restrict: 'E',
      replace: true,
      templateUrl: 'angular/a-brand.html'
    };
  });
}.call(this));
(function () {
  angular.module('app').directive('aHome', function () {
    return {
      restrict: 'E',
      replace: true,
      templateUrl: 'angular/a-home.html'
    };
  });
}.call(this));
(function () {
  angular.module('app').directive('formSearch', function () {
    return {
      restrict: 'E',
      templateUrl: 'angular/form-search.html'
    };
  });
}.call(this));
(function () {
  angular.module('app').directive('githubAuthorize', function () {
    return {
      restrict: 'E',
      replace: true,
      templateUrl: 'angular/github-authorize.html'
    };
  });
}.call(this));
(function () {
  angular.module('app').directive('printer', function () {
    return {
      restrict: 'E',
      templateUrl: 'angular/printer.html'
    };
  });
}.call(this));
(function () {
  angular.module('app').directive('titleMarketing', function () {
    return {
      restrict: 'E',
      replace: true,
      templateUrl: 'angular/title-marketing.html'
    };
  });
}.call(this));
(function () {
  angular.module('app').config([
    '$routeProvider',
    '$locationProvider',
    function ($routeProvider, $locationProvider) {
      $routeProvider.when('/', {
        templateUrl: 'angular/home.html',
        controller: 'HomeCtrl'
      });
      $routeProvider.when('/users/:user/repos/:repo/blob/:branch/:step0/:step1/:step2', {
        templateUrl: 'angular/work.html',
        controller: 'WorkCtrl'
      });
      $routeProvider.when('/users/:user/repos/:repo/blob/:branch/:step0/:step1', {
        templateUrl: 'angular/work.html',
        controller: 'WorkCtrl'
      });
      $routeProvider.when('/users/:user/repos/:repo/blob/:branch/:step0', {
        templateUrl: 'angular/work.html',
        controller: 'WorkCtrl'
      });
      $routeProvider.when('/users/:user/repos/:repo/tree/:branch/:step0/:step1', {
        templateUrl: 'angular/tree.html',
        controller: 'TreeCtrl'
      });
      $routeProvider.when('/users/:user/repos/:repo/tree/:branch/:step0', {
        templateUrl: 'angular/tree.html',
        controller: 'TreeCtrl'
      });
      $routeProvider.when('/users/:user/repos/:repo/tree/:branch', {
        templateUrl: 'angular/tree.html',
        controller: 'TreeCtrl'
      });
      $routeProvider.when('/users/:user', {
        templateUrl: 'angular/user.html',
        controller: 'UserCtrl'
      });
      $routeProvider.when('/work', {
        templateUrl: 'angular/work.html',
        controller: 'WorkCtrl'
      });
      $routeProvider.otherwise({ redirectTo: '/' });
      return $locationProvider.html5Mode(true);
    }
  ]);
}.call(this));
(function () {
  var _keyStr, _utf8_decode, _utf8_encode;
  _keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
  _utf8_decode = function (utftext) {
    var c, c1, c2, c3, i, string;
    string = '';
    i = 0;
    c = c1 = c2 = 0;
    while (i < utftext.length) {
      c = utftext.charCodeAt(i);
      if (c < 128) {
        string += String.fromCharCode(c);
        i++;
      } else if (c > 191 && c < 224) {
        c2 = utftext.charCodeAt(i + 1);
        string += String.fromCharCode((c & 31) << 6 | c2 & 63);
        i += 2;
      } else {
        c2 = utftext.charCodeAt(i + 1);
        c3 = utftext.charCodeAt(i + 2);
        string += String.fromCharCode((c & 15) << 12 | (c2 & 63) << 6 | c3 & 63);
        i += 3;
      }
    }
    return string;
  };
  _utf8_encode = function (string) {
    var c, n, utftext, _i, _ref;
    string = string.replace(/\r\n/g, '\n');
    utftext = '';
    for (n = _i = 0, _ref = string.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; n = 0 <= _ref ? ++_i : --_i) {
      c = string.charCodeAt(n);
      if (c < 128) {
        utftext += String.fromCharCode(c);
      } else if (c > 127 && c < 2048) {
        utftext += String.fromCharCode(c >> 6 | 192);
        utftext += String.fromCharCode(c & 63 | 128);
      } else {
        utftext += String.fromCharCode(c >> 12 | 224);
        utftext += String.fromCharCode(c >> 6 & 63 | 128);
        utftext += String.fromCharCode(c & 63 | 128);
      }
    }
    return utftext;
  };
  angular.module('app').factory('Base64', [
    '$window',
    function ($window) {
      return {
        decode: function (input) {
          var chr1, chr2, chr3, enc1, enc2, enc3, enc4, i, output;
          output = '';
          i = 0;
          input = input.replace(/[^A-Za-z0-9\+\/\=]/g, '');
          while (i < input.length) {
            enc1 = _keyStr.indexOf(input.charAt(i++));
            enc2 = _keyStr.indexOf(input.charAt(i++));
            enc3 = _keyStr.indexOf(input.charAt(i++));
            enc4 = _keyStr.indexOf(input.charAt(i++));
            chr1 = enc1 << 2 | enc2 >> 4;
            chr2 = (enc2 & 15) << 4 | enc3 >> 2;
            chr3 = (enc3 & 3) << 6 | enc4;
            output = output + String.fromCharCode(chr1);
            if (enc3 !== 64) {
              output = output + String.fromCharCode(chr2);
            }
            if (enc4 !== 64) {
              output = output + String.fromCharCode(chr3);
            }
          }
          output = _utf8_decode(output);
          return output;
        },
        encode: function (input) {
          var chr1, chr2, chr3, enc1, enc2, enc3, enc4, i, output;
          output = '';
          i = 0;
          input = _utf8_encode(input);
          while (i < input.length) {
            chr1 = input.charCodeAt(i++);
            chr2 = input.charCodeAt(i++);
            chr3 = input.charCodeAt(i++);
            enc1 = chr1 >> 2;
            enc2 = (chr1 & 3) << 4 | chr2 >> 4;
            enc3 = (chr2 & 15) << 2 | chr3 >> 6;
            enc4 = chr3 & 63;
            if (isNaN(chr2)) {
              enc3 = enc4 = 64;
            } else if (isNaN(chr3)) {
              enc4 = 64;
            }
            output = output + _keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4);
          }
          return output;
        }
      };
    }
  ]);
}.call(this));
(function () {
  angular.module('app').factory('GitHub', [
    '$http',
    function ($http) {
      var GITHUB_DOMAIN, GITHUB_PROTOCOL, HTTP_METHOD_DELETE, HTTP_METHOD_GET, HTTP_METHOD_POST, HTTP_METHOD_PUT, Repo, User;
      GITHUB_PROTOCOL = 'https';
      GITHUB_DOMAIN = 'api.github.com';
      HTTP_METHOD_DELETE = 'DELETE';
      HTTP_METHOD_GET = 'GET';
      HTTP_METHOD_POST = 'POST';
      HTTP_METHOD_PUT = 'PUT';
      User = function () {
        function User(name, login) {
          this.name = name;
          this.login = login;
        }
        return User;
      }();
      Repo = function () {
        function Repo(name, description, language, github_html_url) {
          this.name = name;
          this.description = description;
          this.language = language;
          this.github_html_url = github_html_url;
        }
        return Repo;
      }();
      return {
        getUser: function (token, done) {
          var headers;
          headers = token ? { 'Authorization': 'token ' + token } : {};
          return $http({
            method: HTTP_METHOD_GET,
            url: '' + GITHUB_PROTOCOL + '://' + GITHUB_DOMAIN + '/user',
            headers: headers
          }).success(function (user, status, headers, config) {
            return done(null, new User(user.name, user.login), status, headers, config);
          }).error(function (response, status, headers, config) {
            return done(new Error(response.message), response, status, headers, config);
          });
        },
        getUserRepos: function (token, done) {
          var headers;
          headers = token ? { 'Authorization': 'token ' + token } : {};
          return $http({
            method: HTTP_METHOD_GET,
            url: '' + GITHUB_PROTOCOL + '://' + GITHUB_DOMAIN + '/user/repos',
            headers: headers
          }).success(function (repos, status, headers, config) {
            repos = _.map(repos, function (repo) {
              return new Repo(repo.name, repo.description, repo.language, repo.html_url);
            });
            return done(null, repos, status, headers, config);
          }).error(function (response, status, headers, config) {
            return done(new Error(response.message), response, status, headers, config);
          });
        },
        getRepoContents: function (token, user, repo, done) {
          var url;
          url = '' + GITHUB_PROTOCOL + '://' + GITHUB_DOMAIN + '/repos/' + user + '/' + repo + '/contents';
          return $http({
            'method': HTTP_METHOD_GET,
            'url': url,
            'headers': { Authorization: 'token ' + token }
          }).success(function (contents, status, headers, config) {
            return done(null, contents, status, headers, config);
          }).error(function (response, status, headers, config) {
            return done(new Error(response.message), response, status, headers, config);
          });
        },
        getPathContents: function (token, user, repo, path, done) {
          var headers, url;
          url = '' + GITHUB_PROTOCOL + '://' + GITHUB_DOMAIN + '/repos/' + user + '/' + repo + '/contents';
          if (path) {
            url = '' + url + '/' + path;
          }
          headers = token ? { 'Authorization': 'token ' + token } : {};
          return $http({
            'method': HTTP_METHOD_GET,
            'url': url,
            'headers': headers
          }).success(function (contents, status, headers, config) {
            return done(null, contents, status, headers, config);
          }).error(function (response, status, headers, config) {
            return done(new Error(response.message), response, status, headers, config);
          });
        },
        putFile: function (token, owner, repo, path, message, content, sha, done) {
          var data, headers, url;
          url = '' + GITHUB_PROTOCOL + '://' + GITHUB_DOMAIN + '/repos/' + owner + '/' + repo + '/contents/' + path;
          data = {
            message: message,
            content: content
          };
          if (sha) {
            data.sha = sha;
          }
          headers = token ? { 'Authorization': 'token ' + token } : {};
          return $http({
            method: HTTP_METHOD_PUT,
            url: url,
            data: data,
            headers: headers
          }).success(function (file, status, headers, config) {
            return done(null, file, status, headers, config);
          }).error(function (response, status, headers, config) {
            return done(new Error(response.message), response, status, headers, config);
          });
        },
        deleteFile: function (token, owner, repo, path, message, sha, done) {
          var data, url;
          url = '' + GITHUB_PROTOCOL + '://' + GITHUB_DOMAIN + '/repos/' + owner + '/' + repo + '/contents/' + path;
          data = {
            message: message,
            sha: sha
          };
          return $http({
            method: HTTP_METHOD_DELETE,
            url: url,
            data: data,
            headers: { Authorization: 'token ' + token }
          }).success(function (file, status, headers, config) {
            return done(null, file, status, headers, config);
          }).error(function (response, status, headers, config) {
            return done(new Error(response.message), response, status, headers, config);
          });
        },
        postRepo: function (token, name, description, priv, autoInit, done) {
          var data, headers, url;
          url = '' + GITHUB_PROTOCOL + '://' + GITHUB_DOMAIN + '/user/repos';
          data = {
            name: name,
            description: description,
            'private': priv,
            auto_init: autoInit
          };
          headers = token ? { 'Authorization': 'token ' + token } : {};
          return $http({
            method: HTTP_METHOD_POST,
            url: url,
            data: data,
            headers: headers
          }).success(function (repo, status, headers, config) {
            return done(null, repo, status, headers, config);
          }).error(function (response, status, headers, config) {
            return done(new Error(response.message), response, status, headers, config);
          });
        }
      };
    }
  ]);
}.call(this));
(function () {
  angular.module('async', []).factory('$async', [
    '$window',
    function (w) {
      return w.async;
    }
  ]);
}.call(this));
(function () {
  angular.module('app').factory('cookie', [function () {
      return {
        getItem: function (name) {
          var escapedName;
          escapedName = escape(name).replace(/[\-\.\+\*]/g, '\\$&');
          return unescape(document.cookie.replace(new RegExp('(?:(?:^|.*;)\\s*' + escapedName + '\\s*\\=\\s*([^;]*).*$)|^.*$'), '$1')) || null;
        },
        setItem: function (name, value, end, path, domain, secure) {
          var cookie, expires;
          if (!name || /^(?:expires|max\-age|path|domain|secure)$/i.test(name)) {
            throw new Error('Illegal name');
          }
          if (end) {
            switch (end.constructor) {
            case Number:
              expires = end === Infinity ? '; expires=Fri, 31 Dec 9999 23:59:59 GMT' : '; max-age=' + end;
              break;
            case String:
              expires = '; expires=' + end;
              break;
            case Date:
              expires = '; expires=' + end.toGMTString();
              break;
            default:
              expires = '';
            }
          } else {
            expires = '';
          }
          domain = domain ? '; domain=' + domain : '';
          path = path ? '; path=' + path : '';
          secure = secure ? '; secure' : '';
          cookie = '' + escape(name) + '=' + escape(value) + expires + domain + path + secure;
          document.cookie = cookie;
        },
        removeItem: function (name, path) {
          if (!name || !this.hasItem(name)) {
            return false;
          }
          return this.setItem(name, '', new Date(0), path);
        },
        hasItem: function (name) {
          return new RegExp('(?:^|;\\s*)' + escape(name).replace(/[\-\.\+\*]/g, '\\$&') + '\\s*\\=').test(document.cookie);
        }
      };
    }]);
}.call(this));
(function () {
  var locale_data_multi;
  locale_data_multi = {
    'messages_3': {
      '': {
        domain: 'messages_3',
        lang: 'en',
        'plural-forms': 'nplurals=2; plural=(n != 1);'
      },
      'test': [
        null,
        'test_1'
      ],
      'test singular': [
        'test plural',
        'test_1 singular',
        'test_1 plural'
      ],
      'context\x04test': [
        null,
        'test_1 context'
      ],
      'context\x04test singular': [
        'test context plural',
        'test_1 context singular',
        'test_1 context plural'
      ]
    },
    'messages_4': {
      '': {
        domain: 'messages_4',
        lang: 'en',
        'plural-forms': 'nplurals=2; plural=(n != 1);'
      },
      'test': [
        null,
        'test_2'
      ],
      'test singular': [
        'test plural',
        'test_2 singular',
        'test_2 plural'
      ],
      'context\x04test': [
        null,
        'test_2 context'
      ],
      'context\x04test singular': [
        'test context plural',
        'test_2 context singular',
        'test_2 context plural'
      ]
    }
  };
  angular.module('jed', []).factory('i18n', [
    '$window',
    function (w) {
      return new w.Jed({
        domain: 'the_domain',
        missing_key_callback: function (key) {
          return console.log(key);
        },
        locale_data: {
          'the_domain': {
            '': {
              domain: 'the_domain',
              lang: 'en',
              'plural-forms': 'nplurals=2; plural=(n != 1);'
            },
            'Create a New Repo': [
              null,
              'Create a New Project'
            ],
            'Create repo': [
              null,
              'Create project'
            ],
            'Repo': [
              null,
              'Project',
              'Projects'
            ],
            'Repo name': [
              null,
              'Project name'
            ],
            'My Repo': [
              null,
              'My Project',
              'My Projects'
            ],
            'Great repo names are short and memorable.': [
              null,
              'Great project names are short and memorable.'
            ],
            'Initialize this repo with a README.md': [
              null,
              'Initialize this project with a README.md'
            ],
            'This will allow you to clone the repo immediately in GitHub.': [
              null,
              'This will allow you to clone the project immediately in GitHub.'
            ],
            'Create a New File': [
              null,
              'Create a New File'
            ],
            'Create file': [
              null,
              'Create file'
            ],
            'File': [
              null,
              'File',
              'Files'
            ],
            'File name': [
              null,
              'File name'
            ],
            'My Space': [
              null,
              'My Universe'
            ],
            'icon-repo': [
              null,
              'icon-briefcase'
            ],
            'icon-dir': [
              null,
              'icon-book'
            ],
            'icon-file': [
              null,
              'icon-file-alt'
            ],
            'icon-question': [
              null,
              'icon-question'
            ]
          }
        }
      });
    }
  ]);
}.call(this));
(function () {
  angular.module('jquery', []).factory('$', [
    '$window',
    function (w) {
      return w.$;
    }
  ]);
}.call(this));
(function () {
  angular.module('underscore', []).factory('_', [
    '$window',
    function (w) {
      return w._;
    }
  ]);
}.call(this));
angular.module('app').run([
  '$templateCache',
  function ($templateCache) {
    $templateCache.put('angular/a-brand.html', '<a class="brand" href="/">\n' + '  <span class="brandname">{{marketing.name}} <sup class="version">{{marketing.version}} {{npm.version}}</sup></span>\n' + '</a>\n');
    $templateCache.put('angular/a-home.html', '<a href="/">\n' + '  <i class="icon-home"></i>\n' + '  <span>Home</span>\n' + '</a>\n');
    $templateCache.put('angular/browse.html', '<div id="browse">\n' + '  <header>\n' + '    <div class="navbar navbar-inverse navbar-fixed-top">\n' + '      <nav class="navbar-inner">\n' + '        <div class="container">\n' + '          <a-brand></a-brand>\n' + '          <ul class="nav pull-left">\n' + '            <li class="divider-vertical"></li>\n' + '          </ul>\n' + '          <ul class="nav pull-right">\n' + '            <li class="divider-vertical"></li>\n' + '            <li>\n' + '              <form-search></form-search>\n' + '            </li>\n' + '            <li class="divider-vertical"></li>\n' + '            <li>\n' + '              <github-authorize></github-authorize>\n' + '            </li>\n' + '          </ul>\n' + '        </div>\n' + '      </nav>\n' + '    </div>\n' + '  </header>\n' + '</div>\n');
    $templateCache.put('angular/form-search.html', '<form class="navbar-search pull-right ng-pristine ng-valid" method="GET" action="https://www.google.com/search">\n' + '  <input type="text" name="as_q" class="search-query" placeholder="Search">\n' + '  <input type="hidden" name="as_sitesearch" value="geometryzen.org">\n' + '</form>\n');
    $templateCache.put('angular/github-authorize.html', '<li>\n' + '  <!-- When logged out, present the user with an OAuth link-->\n' + '  <a ng-hide="isLoggedIn()" ng-href="https://github.com/login/oauth/authorize?client_id={{clientId()}}&amp;scope=repo,user,gist">\n' + '    <i class="icon-signin"></i>\n' + '    <span>Log In</span>\n' + '  </a>\n' + '\n' + '  <!-- TODO: When logged in, we would like to have a dropdown menu-->\n' + '  <a ng-show="isLoggedIn()" ng-click="logout()" href="#">\n' + '    <i class="icon-signout icon-white"></i>\n' + '    <span>{{userLogin()}}</span>\n' + '  </a>\n' + '</li>\n');
    $templateCache.put('angular/home.html', '<div id="home-view">\n' + '  <div class="subnavbar">\n' + '    <div class="subnavbar-inner">\n' + '      <div class="container">\n' + '        <a class="btn-subnavbar collapsed" data-toggle="collapse" data-target=".subnav-collapse">\n' + '          <i class="icon-reorder"></i>\n' + '        </a>\n' + '        <div class="subnav-collapse collapse">\n' + '          <ul class="mainnav">\n' + '            <li class="active">\n' + '              <a-home></a-home>\n' + '            </li>\n' + '            <li ng-show="isLoggedIn()">\n' + '              <a ng-href="/users/{{userLogin()}}">\n' + '                <i class="icon-user"></i>\n' + '                <span>{{i18n.translate("My Space").fetch()}}</span>\n' + '              </a>\n' + '            </li>\n' + '            <li class="dropdown">\n' + '              <a href="javascript:;" class="dropdown-toggle" data-toggle="dropdown">\n' + '                <i class="icon-eye-open"></i>\n' + '                <span>Learn</span>\n' + '                <b class="caret"></b>\n' + '              </a>\n' + '              <ul class="dropdown-menu">\n' + '                <!--li><a href="http://www.youtube.com/user/geometryzen">Watch</a></li-->\n' + '                <li><a href="/users/geometryzen/repos/demos/tree/master">Browse Examples</a></li>\n' + '              </ul>\n' + '            </li>\n' + '            <li class="dropdown">\n' + '              <a href="javascript:;" class="dropdown-toggle" data-toggle="dropdown">\n' + '                <i class="icon-external-link"></i>\n' + '                <span>Discuss</span>\n' + '                <b class="caret"></b>\n' + '              </a>\n' + '              <ul class="dropdown-menu">\n' + '                <li><a href="http://groups.google.com/group/geometryzen?src=email&amp;hl=en" target="_blank">Mailing List</a></li>\n' + '                <li><a href="http://webchat.freenode.net/?channels=geometryzen&amp;uio=d4" target="_blank">Web Chat</a></li>\n' + '                <li class="divider"></li>\n' + '                <li><a href="https://twitter.com/#!/geometryzen" target="_blank">Twitter</a></li>\n' + '                <li><a href="https://plus.google.com/u/0/s/Geometry%20Zen/communities" target="_blank">Google+</a></li>\n' + '                <li class="divider"></li>\n' + '                <li class="dropdown-submenu">\n' + '                  <a href="#">Source Code</a>\n' + '                  <ul class="dropdown-menu">\n' + '                    <li><a href="https://github.com/david-geo-holmes/geometry-zen" target="_blank">Application Repository</a></li>\n' + '                    <li><a href="https://github.com/geometryzen/geometryzen.github.io" target="_blank">Documentation Repository</a></li>\n' + '                  </ul>\n' + '                </li>\n' + '                <li class="divider"></li>\n' + '                <li><a href="https://github.com/geometryzen/geometryzen/issues" target="_blank">Issue Tracker</a></li>\n' + '              </ul>\n' + '            </li>\n' + '            <li>\n' + '              <a href="http://geometryzen.github.io/faq/" target="_blank" style="text-decoration: none">\n' + '                <i class="icon-question-sign"></i>\n' + '                <span>FAQ</span>\n' + '              </a>\n' + '            </li>\n' + '            <li>\n' + '              <a href="http://geometryzen.github.io/" target="_blank" style="text-decoration: none">\n' + '                <i class="icon-book"></i>\n' + '                <span>Pages</span>\n' + '              </a>\n' + '            </li>\n' + '          </ul>\n' + '          <ul class="mainnav pull-right">\n' + '            <github-authorize></github-authorize>\n' + '          </ul>\n' + '        </div>\n' + '      </div>\n' + '    </div>\n' + '  </div>\n' + '\n' + '  <div class="container-fluid">\n' + '    <div class="row-fluid">\n' + '      <div class="span8">\n' + '        <div class="widget">\n' + '          <div class="widget-header">\n' + '            <i class="icon-cogs"></i>\n' + '            <h3>Geometry Zen</h3>\n' + '          </div>\n' + '          <div class="widget-content">\n' + '            <div class="text-center">\n' + '              <h1>\n' + '                <large>Geometry Zen</large>\n' + '              </h1>\n' + '              <h1>\n' + '                <small><em>Looking at the multiverse from a Geometric Algebra perspective</em></small>\n' + '              </h1>\n' + '              <br/>\n' + '              <p><em>Geometry Zen</em> is a free, online, open-source, and collaborative tool for <em>Computational Modeling</em> combining the <em>Python</em> programming language, <em>WebGL</em> 3D visualization and <em>Geometric Algebra</em>.</p>\n' + '              <br/>\n' + '            </div>\n' + '            <div class="text-right">\n' + '              <blockquote>\n' + '                <p class="muted">...for geometry, you know, is the gate of science,<br/>and the gate is so low and small<br/>that one can only enter it as a little child.</p>\n' + '                <small>\n' + '                  <a href="http://en.wikipedia.org/wiki/William_Kingdon_Clifford" target="_blank">William K. Clifford</a> <cite title="Source Title"></cite>\n' + '                </small>\n' + '              </blockquote>\n' + '              <blockquote>\n' + '                <p class="muted">Geometry without algebra is dumb!<br/>Algebra without geometry is blind!</p>\n' + '                <small><a href="http://en.wikipedia.org/wiki/David_Hestenes" target="_blank">David O. Hestenes</a> <cite title="Source Title"></cite>\n' + '                </small>\n' + '              </blockquote>\n' + '            </div>\n' + '            <div class="text-center">\n' + '              <a href="/users/geometryzen/repos/demos/tree/master" class="btn btn-secondary">\n' + '                <i class="icon-th"></i>\n' + '                <span>Browse Examples</span>\n' + '              </a>\n' + '              <a href="http://geometryzen.github.io/start/" class="btn btn-primary" target="_blank">\n' + '                <i class="icon-thumbs-up"></i>\n' + '                <span>Getting Started</span>\n' + '              </a>\n' + '            </div>\n' + '          </div>\n' + '        </div>\n' + '      </div>\n' + '      <div class="span4">\n' + '        <div class="widget widget-nopad stacked">\n' + '          <div class="widget-header">\n' + '            <i class="icon-road"></i>\n' + '            <h3>Road Map</h3>\n' + '          </div>\n' + '          <div class="widget-content">\n' + '          <ul class="news-items">\n' + '            <li>\n' + '              <div class="news-item-detail">\n' + '                <a href="https://github.com/geometryzen/geometryzen/issues/3" target="_blank" class="news-item-title">GitHub Gists</a>\n' + '                <p class="news-item-preview">While it is possible to create your own permanent GitHub repository of Geometry Zen examples, these represent independent programs without supporting context such as descriptions or theory. The user should be able to create self-contained tutorials or lessons. A more appropriate packaging might be a GitHub Gist, which is a repository containing a single project with potentially many files.</p>\n' + '              </div>\n' + '              <div class="news-item-date">\n' + '                <span class="news-item-day">26</span>\n' + '                <span class="news-item-month">Jul</span>\n' + '              </div>\n' + '            </li>\n' + '            <li>\n' + '              <div class="news-item-detail">\n' + '                <a href="https://github.com/geometryzen/geometryzen/issues" target="_blank" class="news-item-title">What would you like to see?</a>\n' + '                <p class="news-item-preview">Let us know your enhancement requests, bug reports, or simply ask questions using the Geometry Zen <a href="https://github.com/geometryzen/geometryzen/issues" target="_blank">Issue Tracker</a></p>\n' + '              </div>\n' + '              <div class="news-item-date">\n' + '                <span class="news-item-day">26</span>\n' + '                <span class="news-item-month">Jul</span>\n' + '              </div>\n' + '            </li>\n' + '          </ul>\n' + '          </div>\n' + '        </div>\n' + '      </div>\n' + '    </div>\n' + '    <div class="row-fluid">\n' + '      <div class="span6">\n' + '        <div class="widget stacked">\n' + '          <div class="widget-header">\n' + '            <i class="icon-bullhorn"></i>\n' + '            <h3>Tell me More!</h3>\n' + '          </div>\n' + '          <div class="widget-content">\n' + '            <div id="introCarousel" class="carousel slide" data-interval="false">\n' + '              <ol class="carousel-indicators">\n' + '                <li data-target="#introCarousel" data-slide-to="0" class="active"></li>\n' + '                <li data-target="#introCarousel" data-slide-to="1"></li>\n' + '                <li data-target="#introCarousel" data-slide-to="2"></li>\n' + '                <li data-target="#introCarousel" data-slide-to="3"></li>\n' + '                <li data-target="#introCarousel" data-slide-to="4"></li>\n' + '                <li data-target="#introCarousel" data-slide-to="5"></li>\n' + '                <li data-target="#introCarousel" data-slide-to="6"></li>\n' + '              </ol>\n' + '              <!-- Carousel items -->\n' + '              <div class="carousel-inner">\n' + '\n' + '                <div class="active item">\n' + '                  <img src="img/stand-back.jpg" width="1920" height="1200" alt>\n' + '                  <div class="carousel-caption">\n' + '                    <h4>How does Geometry Zen work?</h4>\n' + '                    <p>Students, researchers and educators construct a concise mathematical model of the system of interest using the Python programming language. They then get to experience their model through a WebGL 3D Visualization along with keyboard, mouse and touch interaction. Geometry Zen provides native tools for Multivectors (Geometric Numbers that generalize vectors and scalars), Dimensionality checking (Mass, Length, Time), automated Units of Measure conversion, and Coordinate systems.</p>\n' + '                    <h5 class="muted">[1 of 7]</h5>\n' + '                  </div>\n' + '                </div>\n' + '\n' + '                <div class="item">\n' + '                  <img src="img/stand-back.jpg" width="1920" height="1200" alt>\n' + '                  <div class="carousel-caption">\n' + '                    <h4>Will it do what I want?</h4>\n' + '                    <p>The Geometry Zen programming environment is completely general (there is full access to the browser window and document object model), allowing for the construction of arbitrarly complex demonstrations, problem sets, simulations, and even games. Models may be exchanged through private and public repositories allowing for collaborative development of learning materials and problem solving.</p>\n' + '                    <h5 class="muted">[2 of 7]</h5>\n' + '                  </div>\n' + '                </div>\n' + '\n' + '                <div class="item">\n' + '                  <img src="img/stand-back.jpg" width="1920" height="1200" alt>\n' + '                  <div class="carousel-caption">\n' + '                    <h4>Will it cost me anything?</h4>\n' + '                    <p>Geometry Zen is 100% free to use and is Open Source Software. Grants and donations are used to further develop and maintain the software through student workshops.</p>\n' + '                    <h5 class="muted">[3 of 7]</h5>\n' + '                  </div>\n' + '                </div>\n' + '\n' + '                <div class="item">\n' + '                  <img src="img/stand-back.jpg" width="1920" height="1200" alt>\n' + '                  <div class="carousel-caption">\n' + '                    <h4>What do I need to get started?</h4>\n' + '                    <p>Geometry Zen requires no software installation other than a WebGL compliant web browser. <a href="https://www.google.com/chrome" target="_blank">The Google Chrome browser</a> is strongly recommended. Geometry Zen is certified for use on a Personal Computer (Linux, Mac or Windows) and we are working out the kinks to have it run on Android and iOS tablets.</p>\n' + '                    <h5 class="muted">[4 of 7]</h5>\n' + '                  </div>\n' + '                </div>\n' + '\n' + '                <div class="item">\n' + '                  <img src="img/stand-back.jpg" width="1920" height="1200" alt>\n' + '                  <div class="carousel-caption">\n' + '                    <h4>How do I get started?</h4>\n' + '                    <p>Take a look at some of the examples in the tutorials and try them in the Modeling Workbench. You\'ll soon want to Log In and create yourself a GitHub account (if you don\'t have one already), that way you will be able to save your work and share it with others. GitHub provides a host of other useful features for storing content; it\'s what all the cool kids are using to manage content and code.</p>\n' + '                    <h5 class="muted">[5 of 7]</h5>\n' + '                  </div>\n' + '                </div>\n' + '\n' + '                <div class="item">\n' + '                  <img src="img/stand-back.jpg" width="1920" height="1200" alt>\n' + '                  <div class="carousel-caption">\n' + '                    <h4>What if I have more questions?</h4>\n' + '                    <p>The frequently asked questions page is probably you best next stop. There\'s also the Geometry Zen <em>pages</em> and the online Geometry Zen community.</p>\n' + '                    <h5 class="muted">[6 of 7]</h5>\n' + '                  </div>\n' + '                </div>\n' + '\n' + '                <div class="item">\n' + '                  <img src="img/stand-back.jpg" width="1920" height="1200" alt>\n' + '                  <div class="carousel-caption">\n' + '                    <h4>What if want to contribute or get involved?</h4>\n' + '                    <p>You can donate, <a href="https://github.com/david-geo-holmes/geometry-zen" target="_blank">write code</a>, create learning content, create documentation, and provide <a href="https://github.com/david-geo-holmes/geometry-zen/issues" target="_blank">feedback</a>.</p>\n' + '                    <h5 class="muted">[7 of 7]</h5>\n' + '                  </div>\n' + '                </div>\n' + '\n' + '              </div> <!-- div.carousel.inner -->\n' + '              <!-- Carousel nav -->\n' + '              <a class="carousel-control left" data-target="#introCarousel" data-slide="prev">&lsaquo;</a>\n' + '              <a class="carousel-control right" data-target="#introCarousel" data-slide="next">&rsaquo;</a>\n' + '            </div> <!-- div.carousel.slide -->\n' + '          </div> <!-- div.widget-content -->\n' + '        </div> <!-- div.widget -->\n' + '      </div> <!-- div.span -->\n' + '      <div class="span6">\n' + '        <div class="widget">\n' + '          <div class="widget-header">\n' + '            <i class="icon-thumbs-up"></i>\n' + '            <h3>Features and Benefits</h3>\n' + '          </div>\n' + '          <div class="widget-content">\n' + '            <div class="accordion" id="fabAccordion">\n' + '              <!-- Web Browser Platform -->\n' + '              <div class="accordion-group">\n' + '                <div class="accordion-heading">\n' + '                  <a class="accordion-toggle" data-toggle="collapse" data-parent="#fabAccordion" data-target="#fabCollapse0">\n' + '                    Web Browser Platform\n' + '                  </a>\n' + '                </div>\n' + '                <div id="fabCollapse0" class="accordion-body collapse">\n' + '                  <div class="accordion-inner">\n' + '                    <p>Nothing to install. Just use a WebGL compliant browser such as Chrome or Firefox.</p>\n' + '                  </div>\n' + '                </div>\n' + '              </div>\n' + '              <!-- Optimized for Mobile -->\n' + '              <div class="accordion-group">\n' + '                <div class="accordion-heading">\n' + '                  <a class="accordion-toggle" data-toggle="collapse" data-parent="#fabAccordion" data-target="#fabCollapse1">\n' + '                    Optimized for Mobile\n' + '                  </a>\n' + '                </div>\n' + '                <div id="fabCollapse1" class="accordion-body collapse">\n' + '                  <div class="accordion-inner">\n' + '                    <p>Designed to be easily used on mobile tablet devices.</p>\n' + '                  </div>\n' + '                </div>\n' + '              </div>\n' + '              <!-- Modeling Workbench -->\n' + '              <div class="accordion-group">\n' + '                <div class="accordion-heading">\n' + '                  <a class="accordion-toggle" data-toggle="collapse" data-parent="#fabAccordion" data-target="#fabCollapse2">\n' + '                    Modeling Workbench\n' + '                  </a>\n' + '                </div>\n' + '                <div id="fabCollapse2" class="accordion-body collapse">\n' + '                  <div class="accordion-inner">\n' + '                    <p>Juxtaposes an analytical programming editor with a 3D geometry view reinforcing the learning of the mathematical notation as well as the geometric interpretation.</p>\n' + '                  </div>\n' + '                </div>\n' + '              </div>\n' + '              <!-- Python Language -->\n' + '              <div class="accordion-group">\n' + '                <div class="accordion-heading">\n' + '                  <a class="accordion-toggle" data-toggle="collapse" data-parent="#fabAccordion" data-target="#fabCollapse3">\n' + '                    Python Language\n' + '                  </a>\n' + '                </div>\n' + '                <div id="fabCollapse3" class="accordion-body collapse">\n' + '                  <div class="accordion-inner">\n' + '                    <p>Mathematical binary operators are natural to use. Easy to learn. Widely used in academia.</p>\n' + '                  </div>\n' + '                </div>\n' + '              </div>\n' + '              <!-- WebGL rendering -->\n' + '              <div class="accordion-group">\n' + '                <div class="accordion-heading">\n' + '                  <a class="accordion-toggle" data-toggle="collapse" data-parent="#fabAccordion" data-target="#fabCollapse4">\n' + '                    WebGL 3D rendering\n' + '                  </a>\n' + '                </div>\n' + '                <div id="fabCollapse4" class="accordion-body collapse">\n' + '                  <div class="accordion-inner">\n' + '                    <p>Fast GPU-based rendering provides smooth animation of simulations.</p>\n' + '                  </div>\n' + '                </div>\n' + '              </div>\n' + '              <!-- Geometric Algebra-->\n' + '              <div class="accordion-group">\n' + '                <div class="accordion-heading">\n' + '                  <a class="accordion-toggle" data-toggle="collapse" data-parent="#fabAccordion" data-target="#fabCollapse5">\n' + '                    Geometric Algebra(s)\n' + '                  </a>\n' + '                </div>\n' + '                <div id="fabCollapse5" class="accordion-body collapse">\n' + '                  <div class="accordion-inner">\n' + '                    <p>Support for 2D and 3D Euclidean (Now), Spacetime and Conformal algebras (Coming soon).</p>\n' + '                  </div>\n' + '                </div>\n' + '              </div>\n' + '              <!-- Dimensional Analysis-->\n' + '              <div class="accordion-group">\n' + '                <div class="accordion-heading">\n' + '                  <a class="accordion-toggle" data-toggle="collapse" data-parent="#fabAccordion" data-target="#fabCollapse6">\n' + '                    Dimensional Analysis\n' + '                  </a>\n' + '                </div>\n' + '                <div id="fabCollapse6" class="accordion-body collapse">\n' + '                  <div class="accordion-inner">\n' + '                    <p>Automatic verification of the correctness of physical expressions (Coming soon).</p>\n' + '                  </div>\n' + '                </div>\n' + '              </div>\n' + '              <!-- Units of Measure-->\n' + '              <div class="accordion-group">\n' + '                <div class="accordion-heading">\n' + '                  <a class="accordion-toggle" data-toggle="collapse" data-parent="#fabAccordion" data-target="#fabCollapse7">\n' + '                    Units of Measure\n' + '                  </a>\n' + '                </div>\n' + '                <div id="fabCollapse7" class="accordion-body collapse">\n' + '                  <div class="accordion-inner">\n' + '                    <p>Permits algebraic manipulations, even if the units differ, with automatic conversion (Coming soon).</p>\n' + '                  </div>\n' + '                </div>\n' + '              </div>\n' + '              <!-- Coordinate Systems-->\n' + '              <div class="accordion-group">\n' + '                <div class="accordion-heading">\n' + '                  <a class="accordion-toggle" data-toggle="collapse" data-parent="#fabAccordion" data-target="#fabCollapse8">\n' + '                    Coordinate Systems\n' + '                  </a>\n' + '                </div>\n' + '                <div id="fabCollapse8" class="accordion-body collapse">\n' + '                  <div class="accordion-inner">\n' + '                    <p>Enter initial configuration in a coordinate system that reflects the symmetry of the system.</p>\n' + '                  </div>\n' + '                </div>\n' + '              </div>\n' + '              <!-- Tutorials-->\n' + '              <div class="accordion-group">\n' + '                <div class="accordion-heading">\n' + '                  <a class="accordion-toggle" data-toggle="collapse" data-parent="#fabAccordion" data-target="#fabCollapse9">\n' + '                    Tutorials\n' + '                  </a>\n' + '                </div>\n' + '                <div id="fabCollapse9" class="accordion-body collapse">\n' + '                  <div class="accordion-inner">\n' + '                    <p>A comprehensive introduction to {{marketing.name}} and Geometric Algebra (Coming soon).</p>\n' + '                  </div>\n' + '                </div>\n' + '              </div>\n' + '              <!-- Examples-->\n' + '              <div class="accordion-group">\n' + '                <div class="accordion-heading">\n' + '                  <a class="accordion-toggle" data-toggle="collapse" data-parent="#fabAccordion" data-target="#fabCollapse10">\n' + '                    Examples\n' + '                  </a>\n' + '                </div>\n' + '                <div id="fabCollapse10" class="accordion-body collapse">\n' + '                  <div class="accordion-inner">\n' + '                    <p>Allow you to explore the capabilities and potential of {{marketing.name}}.</p>\n' + '                  </div>\n' + '                </div>\n' + '              </div>\n' + '              <!-- Works disconnected-->\n' + '              <div class="accordion-group">\n' + '                <div class="accordion-heading">\n' + '                  <a class="accordion-toggle" data-toggle="collapse" data-parent="#fabAccordion" data-target="#fabCollapse11">\n' + '                    Works disconnected\n' + '                  </a>\n' + '                </div>\n' + '                <div id="fabCollapse11" class="accordion-body collapse">\n' + '                  <div class="accordion-inner">\n' + '                    <p>No need to be connected to the internet unless you want to share your work with others.</p>\n' + '                  </div>\n' + '                </div>\n' + '              </div>\n' + '              <!-- OAuth authentication-->\n' + '              <div class="accordion-group">\n' + '                <div class="accordion-heading">\n' + '                  <a class="accordion-toggle" data-toggle="collapse" data-parent="#fabAccordion" data-target="#fabCollapse13">\n' + '                    OAuth authentication\n' + '                  </a>\n' + '                </div>\n' + '                <div id="fabCollapse13" class="accordion-body collapse">\n' + '                  <div class="accordion-inner">\n' + '                    <p>Secure authentication and authorization using GitHub. No extra passwords to memorize.</p>\n' + '                  </div>\n' + '                </div>\n' + '              </div>\n' + '              <!-- GitHub repository-->\n' + '              <div class="accordion-group">\n' + '                <div class="accordion-heading">\n' + '                  <a class="accordion-toggle" data-toggle="collapse" data-parent="#fabAccordion" data-target="#fabCollapse14">\n' + '                    GitHub repository\n' + '                  </a>\n' + '                </div>\n' + '                <div id="fabCollapse14" class="accordion-body collapse">\n' + '                  <div class="accordion-inner">\n' + '                    <p>Save and share your models in public repositories or use private repositories for assignments and problems. Search for public {{marketing.name}} models by other authors, improve on them, return the favor by offering back your changes.</p>\n' + '                  </div>\n' + '                </div>\n' + '              </div>\n' + '              <!-- Issue Tracking-->\n' + '              <div class="accordion-group">\n' + '                <div class="accordion-heading">\n' + '                  <a class="accordion-toggle" data-toggle="collapse" data-parent="#fabAccordion" data-target="#fabCollapse15">\n' + '                    Issue Tracking\n' + '                  </a>\n' + '                </div>\n' + '                <div id="fabCollapse15" class="accordion-body collapse">\n' + '                  <div class="accordion-inner">\n' + '                    <p>Want something incorporated, fixed or improved? <a href="https://github.com/david-geo-holmes/geometry-zen/issues">Discuss your issue</a> with the {{marketing.name}} community!</p>\n' + '                  </div>\n' + '                </div>\n' + '              </div>\n' + '              <!-- 100% freedom-->\n' + '              <div class="accordion-group">\n' + '                <div class="accordion-heading">\n' + '                  <a class="accordion-toggle" data-toggle="collapse" data-parent="#fabAccordion" data-target="#fabCollapse16">\n' + '                    100% freedom\n' + '                  </a>\n' + '                </div>\n' + '                <div id="fabCollapse16" class="accordion-body collapse">\n' + '                  <div class="accordion-inner">\n' + '                    <p>Freedom to run, copy, distribute, study, improve and change the software.</p>\n' + '                  </div>\n' + '                </div>\n' + '              </div>\n' + '              <!-- 100% free-->\n' + '              <div class="accordion-group">\n' + '                <div class="accordion-heading">\n' + '                  <a class="accordion-toggle" data-toggle="collapse" data-parent="#fabAccordion" data-target="#fabCollapse17">\n' + '                    100% free\n' + '                  </a>\n' + '                </div>\n' + '                <div id="fabCollapse17" class="accordion-body collapse">\n' + '                  <div class="accordion-inner">\n' + '                    <p>That\'s right.</p>\n' + '                  </div>\n' + '                </div>\n' + '              </div>\n' + '              <!-- Open Source Software-->\n' + '              <div class="accordion-group">\n' + '                <div class="accordion-heading">\n' + '                  <a class="accordion-toggle" data-toggle="collapse" data-parent="#fabAccordion" data-target="#fabCollapse18">\n' + '                    Open Source Software\n' + '                  </a>\n' + '                </div> <!-- accordion-toggle -->\n' + '                <div id="fabCollapse18" class="accordion-body collapse">\n' + '                  <div class="accordion-inner">\n' + '                    <p>What else would it be? Just head over to the <a href="https://github.com/david-geo-holmes/geometry-zen">{{marketing.name}} GitHub project.</a></p>\n' + '                  </div> <!-- accordion-inner -->\n' + '                </div> <!-- accordion-body -->\n' + '              </div> <!-- accordion-group -->\n' + '            </div> <!-- accordion -->\n' + '          </div> <!-- div.widget-content -->\n' + '        </div> <!-- div.widget -->\n' + '      </div> <!-- div.span -->\n' + '    </div> <!-- div.row-fluid -->\n' + '    <div class="row-fluid">\n' + '      <div class="span6">\n' + '        <div class="widget">\n' + '          <div class="widget-header">\n' + '            <i class="icon-cogs"></i>\n' + '            <h3>Geometric Algebra</h3>\n' + '          </div>\n' + '          <div class="widget-content">\n' + '            <p>Geometric Algebra is the generalization of the concept of a number to describe geometric quantities and defines the rules for manipulating those numbers. In essence, Geometric Algebra is about learning how to correctly multiply and interpret Geometric Numbers.</p>\n' + '            <p>Many of the Physical Laws that describe the phenomena of nature are Geometric and Algebraic in Character. That is to say, the laws have a precise mathematical structure that is amenable to a geometric interpretation. Geometric Algebra unifies these two aspects in a single mathematical tool. By learning and using Geometric Algebra (and Geometric Calculus) the student gains a new perspective and a lasting foundation for understanding the universe and making new discoveries.</p>\n' + '          </div> <!-- div.widget-content -->\n' + '        </div> <!-- div.widget -->\n' + '      </div> <!-- div.span -->\n' + '      <div class="span6">\n' + '        <div class="widget">\n' + '          <div class="widget-header">\n' + '            <i class="icon-time"></i>\n' + '            <h3>Timeline</h3>\n' + '          </div>\n' + '          <div class="widget-content">\n' + '            <table class="table table-condensed">\n' + '              <tbody>\n' + '                <tr>\n' + '                  <td><span nowrap=nowrap>300 BCE</span></td>\n' + '                  <td>Euclid</td>\n' + '                  <td><em>Geometry</em></td>\n' + '                </tr>\n' + '                <tr>\n' + '                  <td><span nowrap=nowrap>250 CE</span></td>\n' + '                  <td>Diophantes</td>\n' + '                  <td><em>Algebra</em></td>\n' + '                </tr>\n' + '                <tr>\n' + '                  <td>1545</td>\n' + '                  <td>Cardano</td>\n' + '                  <td><em>Imaginary numbers</em></td>\n' + '                </tr>\n' + '                <tr>\n' + '                  <td>1637</td>\n' + '                  <td>Descartes</td>\n' + '                  <td><em>Coordinates</em></td>\n' + '                </tr>\n' + '                <tr>\n' + '                  <td>1798</td>\n' + '                  <td>Gauss</td>\n' + '                  <td><em>Complex Algebra</em></td>\n' + '                </tr>\n' + '                <tr>\n' + '                  <td>1840</td>\n' + '                  <td>Grassman</td>\n' + '                  <td><em>Linear Algebra, Vector Space</em></td>\n' + '                </tr>\n' + '                <tr>\n' + '                  <td>1843</td>\n' + '                  <td>Hamilton</td>\n' + '                  <td><em>Quaternions</em></td>\n' + '                </tr>\n' + '                <tr>\n' + '                  <td>1844</td>\n' + '                  <td>Grassman</td>\n' + '                  <td><em>Extensive Algebra</em></td>\n' + '                </tr>\n' + '                <tr>\n' + '                  <td>1854</td>\n' + '                  <td>Cayley</td>\n' + '                  <td><em>Matrix Algebra</em></td>\n' + '                </tr>\n' + '                <tr>\n' + '                  <td>1870</td>\n' + '                  <td>Gibbs and Heaviside</td>\n' + '                  <td><em>Vector Calculus</em></td>\n' + '                </tr>\n' + '                <tr>\n' + '                  <td>1878</td>\n' + '                  <td>Clifford</td>\n' + '                  <td><em>Geometric Algebra</em></td>\n' + '                </tr>\n' + '                <tr>\n' + '                  <td>1890</td>\n' + '                  <td>Ricci</td>\n' + '                  <td><em>Tensors</em></td>\n' + '                </tr>\n' + '                <tr>\n' + '                  <td>1899</td>\n' + '                  <td>Cartan</td>\n' + '                  <td><em>Differential Forms</em></td>\n' + '                </tr>\n' + '                <tr>\n' + '                  <td>1928</td>\n' + '                  <td>Dirac</td>\n' + '                  <td><em>Spin Algebra</em></td>\n' + '                </tr>\n' + '                <tr>\n' + '                  <td>1957</td>\n' + '                  <td>Riesz</td>\n' + '                  <td><em>Clifford Numbers, Spinors</em></td>\n' + '                </tr>\n' + '                <tr>\n' + '                  <td>1966</td>\n' + '                  <td>Hestenes</td>\n' + '                  <td><em>Space Time Algebra, Geometric Calculus</em></td>\n' + '                </tr>\n' + '              </tbody>\n' + '            </table> <!-- table.table-->\n' + '            <dl class="dl-horizontal">\n' + '            </dl>\n' + '          </div> <!-- dive.widget-content -->\n' + '        </div> <!-- div.widget -->\n' + '      </div> <!-- div.span4 -->\n' + '    </div> <!-- div.row-fluid -->\n' + '  </div> <!-- div.container-fluid -->\n' + '</div> <!-- div.home-view -->\n' + '<script>\n' + '  $(\'.accordion\').on(\'show\', function (e) {\n' + '    $(e.target).prev(\'.accordion-heading\').parent ().addClass(\'open\');\n' + '  });\n' + '\n' + '  $(\'.accordion\').on(\'hide\', function (e) {\n' + '    $(this).find(\'.accordion-toggle\').not($(e.target)).parents (\'.accordion-group\').removeClass(\'open\');\n' + '  });\n' + '    \n' + '  $(\'.accordion\').each (function () {       \n' + '    $(this).find (\'.accordion-body.in\').parent ().addClass (\'open\');\n' + '  });\n' + '</script>\n');
    $templateCache.put('angular/printer.html', '<div ng-controller="PrinterCtrl" class="container-fluid">\n' + '  <div class="row-fluid">\n' + '    <div class="span12">\n' + '      <!-- Using anything other than a pre(serve) element is likely too be slow -->\n' + '      <!-- PRESERVE_ELEMENT_ID is defined in the printer controller -->\n' + '      <pre id="a5f435e0-c92e-11e2-8b8b-0800200c9a66" class="printer"></pre>\n' + '    </div>\n' + '  </div>\n' + '</div>\n' + '\n');
    $templateCache.put('angular/title-marketing.html', '<title>Geometry Zen</title>');
    $templateCache.put('angular/tree.html', '<div id="repo-view">\n' + '\n' + '  <div class="subnavbar">\n' + '    <div class="subnavbar-inner">\n' + '      <div class="container">\n' + '        <a class="btn-subnavbar collapsed" data-toggle="collapse" data-target=".subnav-collapse">\n' + '          <i class="icon-reorder"></i>\n' + '        </a>\n' + '        <div class="subnav-collapse collapse">\n' + '          <ul class="mainnav">\n' + '            <li class="{{homeBreadcrumbClass()}}">\n' + '              <a-home></a-home>\n' + '            </li>\n' + '            <li ng-show="isLoggedIn()" class="{{userBreadcrumbClass()}}">\n' + '              <a ng-href="/users/{{user.login}}">\n' + '                <i class="icon-user"></i>\n' + '                <span>{{i18n.translate("My Space").fetch()}}</span>\n' + '              </a>\n' + '            </li>\n' + '            <li class="{{repoBreadcrumbClass()}}">\n' + '              <a ng-click="bookView()" href="#">\n' + '                <i class="{{i18n.translate(\'icon-repo\').fetch()}}"></i>\n' + '                <span>{{i18n.translate("Repo").fetch()}}</span>\n' + '              </a>\n' + '            </li>\n' + '          </ul>\n' + '        </div>\n' + '      </div>\n' + '    </div>\n' + '  </div>\n' + '  \n' + '  <div id="work-layout" class="container-fluid">\n' + '    <div class="row-fluid">\n' + '      <div class="widget">\n' + '        <div class="widget-header">\n' + '          <i class="{{i18n.translate(\'icon-repo\').fetch()}}"></i>\n' + '          <h3>{{repo.name}}</h3>\n' + '        </div>\n' + '        <div class="widget-content">\n' + '          <div>\n' + '            <!--\n' + '            <i class="icon-user muted"></i>\n' + '            <span><a ng-href="/users/{{user.login}}">{{user.login}}</a></span>\n' + '            -->\n' + '            <!--\n' + '            <a ng-href="https://github.com/{{user.login}}" target="_blank" class="muted">\n' + '              <i class="icon-github"></i>\n' + '            </a>\n' + '            -->\n' + '            <span>{{repo.description}}</span>\n' + '          </div>\n' + '          <ul class="nav nav-tabs" id="myTab">\n' + '            <li><a data-target="#items" data-toggle="tab">{{i18n.translate(\'File\').ifPlural(2, \'Files\').fetch()}}</a></li>\n' + '            <!--li><a data-target="#commits" data-toggle="tab">Commits</a></li-->\n' + '            <!--li><a data-target="#branches" data-toggle="tab">Branches</a></li-->\n' + '          </ul>\n' + '          <div class="tab-content">\n' + '            <div class="tab-pane" id="items">\n' + '              <div class ="row-fluid">\n' + '                <table class="table table-condensed">\n' + '                  <tbody>\n' + '                    <tr ng-show="isNewFileEnabled()">\n' + '                      <td nowrap=nowrap>\n' + '                        <!--input type="text" placeHolder="Filter..."></input-->\n' + '                      </td>\n' + '                      <td nowrap=nowrap>\n' + '                        <button ng-click="newFile()" ng-show="isNewFileEnabled()" class="btn btn-primary">\n' + '                          <i class="icon-plus-sign-alt"></i> <i class="{{i18n.translate(\'icon-file\').fetch()}}"></i>\n' + '                          <span>{{i18n.translate("Create a New File").fetch()}}</span>\n' + '                        </button>\n' + '                      </td>\n' + '                    </tr>\n' + '                    <!-- Reminder: An item is a book or a page -->\n' + '                    <tr ng-repeat="item in contextItem.childItems">\n' + '                      <td nowrap=nowrap>\n' + '                        <h3>\n' + '                          <i class="{{i18n.translate(iconFromItem(item)).fetch()}} muted"></i>\n' + '                          <a href="{{hrefFromItem(item)}}" class="btn btn-link">\n' + '                            <span>{{item.name}}</span>\n' + '                          </a>\n' + '                        </h3>\n' + '                      </td>\n' + '                      <td nowrap=nowrap>\n' + '                        <!-- Make use of the HATEOAS links -->\n' + '                        <!--\n' + '                        <h3>\n' + '                          <i class="icon-github muted"></i>\n' + '                          <a ng-href="{{item.html_url}}" target="_blank" class="btn btn-link">\n' + '                            <span>GitHub</span>\n' + '                          </a>\n' + '                        </h3>\n' + '                        -->\n' + '                        <button ng-click="deleteItem($index)" ng-show="isDeleteItemEnabled()" class="btn btn-tertiary">\n' + '                          <i class="icon-minus-sign-alt"></i>\n' + '                          <span>Delete</span>\n' + '                        </button>\n' + '                      </td>\n' + '                    </tr>\n' + '                  </tbody>\n' + '                </table>\n' + '              </div>\n' + '            </div>\n' + '            <div class="tab-pane" id="commits">\n' + '              <p>Under Construction: Commits</p>\n' + '            </div>\n' + '            <div class="tab-pane" id="branches">\n' + '              <p>Under Construction: Branches</p>\n' + '            </div>\n' + '          </div>\n' + '          <script>\n' + '            $(function () {\n' + '              $(\'#myTab a[data-target="#items"]\').tab(\'show\');\n' + '            })\n' + '          </script>\n' + '          <script>\n' + '            $(\'#myTab a[data-target="#items"]\').click(function(e) {\n' + '              e.preventDefault();\n' + '              $(this).tab(\'show\');\n' + '            });\n' + '          </script>\n' + '          <script>\n' + '            $(\'#myTab a[data-target="#commits"]\').click(function(e) {\n' + '              e.preventDefault();\n' + '              $(this).tab(\'show\');\n' + '            });\n' + '          </script>\n' + '          <script>\n' + '            $(\'#myTab a[data-target="#branches"]\').click(function(e) {\n' + '              e.preventDefault();\n' + '              $(this).tab(\'show\');\n' + '            });\n' + '          </script>\n' + '        </div> <!-- div.widget-content -->\n' + '      </div> <!-- div.widget -->\n' + '    </div> <!-- div.row-fluid -->\n' + '  </div> <!-- div.container-fluid -->\n' + '  <div id="new-file-dialog" class="modal hide fade" tabindex="-1" role="dialog" aria-labelledby="new-file-dialog-label" aria-hidden="true">\n' + '    <div class="modal-header">\n' + '      <button type="button" class="close" data-dismiss="modal" aria-hidden="true">&times;</button>\n' + '      <h3 id="new-file-dialog-label"><i class="icon-plus-sign-alt muted"></i> <i class="{{i18n.translate(\'icon-file\').fetch()}} muted"></i> {{i18n.translate("Create a New File").fetch()}}</h3>\n' + '    </div>\n' + '    <form ng-controller="NewFileCtrl">\n' + '      <fieldset>\n' + '        <div class="modal-body">\n' + '          <label>{{i18n.translate(\'File name\').fetch()}}</label>\n' + '          <input type="text" name="name" ng-model="file.name"></input>\n' + '          <label>Commit message:</label>\n' + '          <input type="text" name="message" ng-model="file.message" placeholder="{{i18n.translate(\'Create file\').fetch()}}"></input>\n' + '        </div>\n' + '        <div class="modal-footer">\n' + '          <button id="btnCancel" class="btn" data-dismiss="modal" aria-hidden="true">Close</button>\n' + '          <button type="submit" ng-click="createFile()" id="btnOK" class="btn btn-primary">{{i18n.translate("Create file").fetch()}}</button>\n' + '        </div>\n' + '      </fieldset>\n' + '    </form>\n' + '  </div>\n' + '</div>\n');
    $templateCache.put('angular/user.html', '<div id="user-view">\n' + '  <div class="subnavbar">\n' + '    <div class="subnavbar-inner">\n' + '      <div class="container">\n' + '        <a class="btn-subnavbar collapsed" data-toggle="collapse" data-target=".subnav-collapse">\n' + '          <i class="icon-reorder"></i>\n' + '        </a>\n' + '        <div class="subnav-collapse collapse">\n' + '          <ul class="mainnav">\n' + '            <li class="{{homeBreadcrumbClass()}}">\n' + '              <a-home></a-home>\n' + '            </li>\n' + '            <li class="{{userBreadcrumbClass()}}">\n' + '              <a ng-href="/users/{{user.login}}">\n' + '                <i class="icon-user"></i>\n' + '                <span>{{i18n.translate("My Space").fetch()}}</span>\n' + '              </a>\n' + '            </li>\n' + '          </ul>\n' + '        </div> <!-- /.subnav-collapse -->\n' + '      </div> <!-- /container -->\n' + '    </div> <!-- /subnavbar-inner -->\n' + '  </div> <!-- /subnavbar -->\n' + '\n' + '  <div class="container-fluid">\n' + '    <div class="row-fluid">\n' + '      <div class="span4">\n' + '        <div class="widget">\n' + '          <div class="widget-header">\n' + '              <i class="icon-user"></i>\n' + '              <h3>Profile</h3>\n' + '          </div>\n' + '          <div class="widget-content">\n' + '            <h3>\n' + '              <span>{{user.name}}</span>\n' + '            </h3>\n' + '            <h4>\n' + '              <span>{{user.login}}</span>\n' + '            </h4>\n' + '            <!-- HATEOAS GitHub link? -->\n' + '            <!--\n' + '            <a href="https://github.com/{{user.login}}?tab=repositories" target="_blank" class="btn btn-secondary">\n' + '              <i class="icon-github"></i>\n' + '              <span>GitHub</span>\n' + '            </a>\n' + '            -->\n' + '          </div>\n' + '        </div>\n' + '      </div>\n' + '      <div class="span8">\n' + '        <div class="widget stacked">\n' + '          <div class="widget-content">\n' + '            <ul class="nav nav-tabs" id="myTab">\n' + '              <!--li><a data-target="#contributions" data-toggle="tab">Contributions</a></li-->\n' + '              <li><a data-target="#repositories" data-toggle="tab">{{i18n.translate("Repo").ifPlural(2, "Repos").fetch()}}</a></li>\n' + '              <!--li><a data-target="#activity" data-toggle="tab">Public Activity</a></li-->\n' + '            </ul>\n' + '            <div class="tab-content">\n' + '              <div class="tab-pane" id="contributions">\n' + '                <p>Under Construction: Contributions</p>\n' + '              </div>\n' + '              <div class="tab-pane" id="repositories">\n' + '                <div class ="row-fluid">\n' + '                  <table class="table table-condensed">\n' + '                    <tbody>\n' + '                      <tr>\n' + '                        <td nowrap=nowrap>\n' + '                          <!--input type="text" placeHolder="Filter..."></input-->\n' + '                        </td>\n' + '                        <td nowrap=nowrap>\n' + '                          <button ng-click="newRepo()" class="btn btn-primary">\n' + '                            <i class="icon-plus-sign-alt"></i> <i class="{{i18n.translate(\'icon-repo\').fetch()}}"></i>\n' + '                            <span>{{i18n.translate("Create a New Repo").fetch()}}</span>\n' + '                          </button>\n' + '                        </td>\n' + '                      </tr>\n' + '                      <tr ng-repeat="repo in repos">\n' + '                        <td nowrap=nowrap>\n' + '                          <h3>\n' + '                            <i class="{{i18n.translate(\'icon-repo\').fetch()}} muted"></i>\n' + '                            <a href="/users/{{user.login}}/repos/{{repo.name}}/tree/master" class="btn btn-link">\n' + '                              <span>{{repo.name}}</span>\n' + '                            </a>\n' + '                          </h3>\n' + '                          <p>{{repo.description}}</p>\n' + '                        </td>\n' + '                        <td nowrap=nowrap>\n' + '                          <!-- HATEOAS GitHub link-->\n' + '                          <!--\n' + '                          <a href="{{repo.github_html_url}}" target="_blank" class="btn btn-secondary">\n' + '                            <i class="icon-github"></i>\n' + '                            <span>GitHub</span>\n' + '                          </a>\n' + '                          -->\n' + '                          <button ng-click="deleteRepo($index)" class="btn btn-tertiary">\n' + '                            <i class="icon-minus-sign-alt"></i>\n' + '                            <span>Delete</span>\n' + '                          </button>\n' + '                        </td>\n' + '                      </tr>\n' + '                    </tbody>\n' + '                  </table>\n' + '                </div>\n' + '              </div>\n' + '              <div class="tab-pane" id="activity">\n' + '                <p>Under Construction: Public Activity</p>\n' + '              </div>\n' + '            </div>\n' + '            <script>\n' + '              $(function () {\n' + '                $(\'#myTab a[data-target="#repositories"]\').tab(\'show\');\n' + '              })\n' + '            </script>\n' + '            <script>\n' + '              $(\'#myTab a[data-target="#contributions"]\').click(function(e) {\n' + '                e.preventDefault();\n' + '                $(this).tab(\'show\');\n' + '              });\n' + '            </script>\n' + '            <script>\n' + '              $(\'#myTab a[data-target="#repositories"]\').click(function(e) {\n' + '                e.preventDefault();\n' + '                $(this).tab(\'show\');\n' + '              });\n' + '            </script>\n' + '            <script>\n' + '              $(\'#myTab a[data-target="#activity"]\').click(function(e) {\n' + '                e.preventDefault();\n' + '                $(this).tab(\'show\');\n' + '              });\n' + '            </script>\n' + '          </div>\n' + '        </div>\n' + '\n' + '        <div id="new-repo-dialog" class="modal hide fade" tabindex="-1" role="dialog" aria-labelledby="new-repo-dialog-label" aria-hidden="true">\n' + '          <div class="modal-header">\n' + '            <button type="button" class="close" data-dismiss="modal" aria-hidden="true">&times;</button>\n' + '            <h3 id="new-repo-dialog-label"><i class="icon-plus-sign-alt muted"></i> <i class="{{i18n.translate(\'icon-repo\').fetch()}} muted"></i> {{i18n.translate("Create a New Repo").fetch()}}</h3>\n' + '          </div>\n' + '          <form ng-controller="NewRepoCtrl">\n' + '            <fieldset>\n' + '              <div class="modal-body">\n' + '                <label>{{i18n.translate("Repo name").fetch()}}</label>\n' + '                <input type="text" name="repo" ng-model="repo.name"></input>\n' + '                <span class="help-block">{{i18n.translate("Great repo names are short and memorable.").fetch()}}</span>\n' + '                <label>Description<span class="muted"> (optional)</span></label>\n' + '                <input type="text" name="description" ng-model="repo.description"></input>\n' + '                <!--\n' + '                <hr/>\n' + '                <input type="radio" ng-model="repo.private" value="false"> <i class="{{i18n.translate(\'icon-repo\').fetch()}} muted"></i> Public<br/>\n' + '                <span class="help-block">Anyone can see this repository. You choose who can commit.</span>\n' + '                <input type="radio" ng-model="repo.private" value="true"> Private <br/>\n' + '                <span class="help-block">You choose who can see and commit to this repository.</span>\n' + '                -->\n' + '                <hr/>\n' + '                <label class="checkbox">\n' + '                  <input type="checkbox" name="markdown-readme" ng-model="repo.markdownReadme"> {{i18n.translate("Initialize this repo with a README.md").fetch()}}</input>\n' + '                </label>\n' + '                <span class="help-block">{{i18n.translate("This will allow you to clone the repo immediately in GitHub.").fetch()}}</span>\n' + '                <!--\n' + '                <label class="checkbox">\n' + '                  <input type="checkbox" name="python-readme" ng-model="repo.pythonReadme"> Initialize this book with a README.py</input>\n' + '                </label>\n' + '                <span class="help-block">Having at least one Python file will ensure that the GitHub repository is visible to Geometry Zen.</span>\n' + '                -->\n' + '              </div>\n' + '              <div class="modal-footer">\n' + '                <button id="btnCancel" class="btn" data-dismiss="modal" aria-hidden="true">Close</button>\n' + '                <button type="submit" ng-click="createRepo()" id="btnOK" class="btn btn-primary">{{i18n.translate("Create repo").fetch()}}</button>\n' + '              </div>\n' + '            </fieldset>\n' + '          </form>\n' + '        </div>\n' + '      </div>\n' + '    </div>\n' + '  </div>\n' + '</div>');
    $templateCache.put('angular/work.html', '<div id="work-view">\n' + '  <div class="subnavbar">\n' + '    <div class="subnavbar-inner">\n' + '      <div class="container">\n' + '        <a class="btn-subnavbar collapsed" data-toggle="collapse" data-target=".subnav-collapse">\n' + '          <i class="icon-reorder"></i>\n' + '        </a>\n' + '        <div class="subnav-collapse collapse">\n' + '          <ul class="mainnav">\n' + '            <li class="{{homeBreadcrumbClass()}}">\n' + '              <a-home></a-home>\n' + '            </li>\n' + '            <li ng-show="isLoggedIn()" class="{{userBreadcrumbClass()}}">\n' + '              <a ng-href="/users/{{user.name}}">\n' + '                <i class="icon-user"></i>\n' + '                <span>{{i18n.translate("My Space").fetch()}}</span>\n' + '              </a>\n' + '            </li>\n' + '            <li class="active">\n' + '              <a ng-click="reload()" href="#">\n' + '                <i class="icon-edit"></i>\n' + '                <span>Workbench</span>\n' + '              </a>\n' + '            </li>\n' + '            <li ng-show="saveEnabled()">\n' + '              <a ng-click="saveFile()" href="#">\n' + '                <i class="icon-save"></i>\n' + '                <span>Save</span>\n' + '              </a>\n' + '            </li>\n' + '            <li ng-show="runEnabled()">\n' + '              <a ng-click="run()" href="#">\n' + '                <i class="icon-cogs"></i>\n' + '                <span>Run</span>\n' + '              </a>\n' + '            </li>\n' + '          </ul>\n' + '        </div>\n' + '      </div>\n' + '    </div>\n' + '  </div>\n' + '  \n' + '  <div id="work-layout" class="container-fluid">\n' + '    <div class="row-fluid" ng-show="messages.length &gt; 0">\n' + '      <div class="span12">\n' + '        <div class="widget stacked">\n' + '          <div class="widget-header">\n' + '            <i class="icon-inbox"></i>\n' + '            <h3>Message</h3>\n' + '          </div>\n' + '          <div class="widget-content">\n' + '            <div class="alert alert-block alert-{{message.severity}}" ng-repeat="message in messages">\n' + '              <button type="button" class="close" data-dismiss="alert">&times;</button>\n' + '              <h4>{{message.name}}</h4>\n' + '              {{message.text}}\n' + '            </div>\n' + '          </div>\n' + '        </div>\n' + '      </div>\n' + '    </div>\n' + '\n' + '    <div class="row-fluid">\n' + '      <div class="span6">\n' + '        <div class="widget">\n' + '          <div class="widget-header">\n' + '            <i class="{{i18n.translate(\'icon-file\').fetch()}} muted"></i>\n' + '            <h3>{{contextItem.name}}</h3>\n' + '          </div>\n' + '          <div id="textarea-container" class="widget-plain">\n' + '            <textarea id="code"></textarea>\n' + '          </div>\n' + '        </div>\n' + '      </div>\n' + '      <div class="span6">\n' + '        <div class="row-fluid">\n' + '          <div class="span12">\n' + '            <div class="widget">\n' + '              <div id="canvas-container" class="widget-plain">\n' + '              </div>\n' + '            </div>\n' + '          </div>\n' + '        </div>\n' + '        <div class="row-fluid">\n' + '          <div class="span12">\n' + '            <div class="widget">\n' + '              <div class="widget-header">\n' + '                <i class="icon-print"></i>\n' + '                <h3>Printer</h3>\n' + '              </div>\n' + '              <div id="printer-container" class="widget-content">\n' + '                <printer></printer>\n' + '              </div>\n' + '            </div>\n' + '          </div>\n' + '        </div>\n' + '      </div>\n' + '    </div>\n' + '  </div>\n' + '</div>');
  }
]);